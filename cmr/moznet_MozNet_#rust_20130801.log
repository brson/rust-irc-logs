[00:00:11] * jack needs to upgrade to the new rust-mode
[00:00:18] <sully> oh, is there a new rust-mode?
[00:00:21] <cmr> yes
[00:00:22] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[00:00:26] <sully> how do I get it?
[00:00:29] <sully> is it just in the repo?
[00:00:32] <cmr> same way you got the old one
[00:00:35] <cmr> yes
[00:00:35] <sully> ok
[00:01:15] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[00:05:24] *** Quits: Rosti (Mibbit@moz-C995772.netcologne.de) (Quit: http://www.mibbit.com ajax IRC Client)
[00:05:28] <tikue> is there a solution to "Dynamic freeze scope artificially extended" when going from @mut to *mut by doing &mut *Foo
[00:06:02] <strcat> I don't think you want to do that
[00:06:11] <strcat> afaik it won't necessarily root it long enough
[00:06:31] <strcat> it will *right now*
[00:06:49] <tikue> strcat: is there a correct way to cast from @mut to *mut?
[00:06:58] <strcat> I don't think so
[00:07:11] <cmr> surely not safely
[00:07:14] <strcat> you would need an explicit API to interact with a gc
[00:07:57] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Connection reset by peer)
[00:07:59] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[00:08:08] <kmc> the issue is that if @mut used a real GC, the box could get moved?
[00:08:16] <strcat> it could be freed
[00:08:20] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:08:26] <sully> ok, does anybody have any idea how to debug emacs having bad ideas about rust indentation
[00:08:29] <sully> I am on master
[00:08:39] <strcat> the *mut won't be considered a root
[00:08:43] <sully> do I need to do something to rebuild the rust mode?
[00:09:18] <kmc> strcat: and why is it safe right now?
[00:09:23] <strcat> because there's no gc
[00:09:35] <strcat> if you only need the *mut for a short while, you could write a function taking &mut and have it for that scope
[00:09:58] <tikue> strcat: it needs it for a long while :)
[00:10:16] <strcat> tikue: well, can't really be pointing into @mut without a rooting API
[00:10:16] <cmr> dbaupp: status: working on cleaning up rust-zmq (it uses some deprecated stuff and generally needs some love), will get started on doing "real" work as soon as that's done.
[00:10:17] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[00:10:32] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[00:10:39] <strcat> tikue: use extra::rc if you need guarantees like that
[00:10:54] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Max SendQ exceeded)
[00:11:26] <kmc> strcat: sure, there's no GC, but the last reference to that @ box could still disappear while the raw pointer is alive
[00:11:58] <strcat> kmc: yes but you can reason about the lifetime of Rc based on scopes
[00:12:00] <strcat> not so with @
[00:12:26] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[00:12:50] <strcat> it's very unlikely that it will be safe to do it even with refcounting though
[00:12:50] <jack> strcat: we can't use Rc. these are JS managed boxes soon.
[00:13:20] <strcat> well, you can't keep around an *mut to a type you don't have a known lifetime for
[00:13:33] <jack> we'll have to root it obviously, but ti think that is already done.
[00:13:35] <sully> ok, who here knows something about the emacs mode?
[00:13:43] <jack> sully: i am trying to reproduce.
[00:13:49] <cmr> sully: graydon wrote it. tjc uses it. dunno beyond that
[00:13:55] <strcat> jack: there's no rooting API
[00:14:02] <strcat> it roots for the duration of an &/&mut's lifetime
[00:14:10] <strcat> it has no knowledge of *mut and no way to deal with it
[00:14:19] <tjc> sully: what's up with the emacs mode?
[00:14:30] <jack> it's not going to get freed early I think. the main task has a handle on it always.
[00:14:35] <sully> somehow my emacs has decided that the rust basic indent should be 8 spaces
[00:14:40] <sully> and I'm not sure how to change its mind
[00:14:42] <jack> strcat: i suppose it could get moved which would be very bad.
[00:14:52] <strcat> jack: not just moved
[00:14:56] <strcat> it could be freed
[00:15:12] <strcat> the *mut has no influence on the lifetime
[00:15:12] <jack> strcat: how is it going to get freed if we have a reference to the @T?
[00:15:20] <strcat> jack: the *mut doesn't count as a reference
[00:15:26] <tjc> sully: yeah, I'm having that problem too
[00:15:31] <tjc> graydon: ^
[00:15:37] <strcat> jack: the gc only walks from specified roots
[00:15:43] <jack> i didn't say it did. there is a long lived task that has an actual @T reference. *T is just used for less longer lived stuff i think.
[00:15:54] <jack> or at least, if this has any chance of being safe that has to be true.
[00:15:56] <sanxiyn> jack: Hi
[00:15:57] <strcat> well if you can guarantee that holds
[00:16:04] <sanxiyn> jack: Can you check /query?
[00:16:07] <kmc> ugh, I just realized that any explicit bump_box_refcount / forget code will need to be totally reworked for GC
[00:16:12] <strcat> it could be moved though
[00:16:15] <strcat> kmc: that code can use Rc
[00:16:25] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[00:16:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1487daa32 to 14ef87e2c: 02http://git.io/N3iJvQ
[00:16:25] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[00:16:30] <kmc> yeah
[00:16:32] <strcat> essentially anything not explicitly desiring garbage collection should already be doing that
[00:16:53] <kmc> but it's like 4 times as many characters, plus no deref sugar :(
[00:17:13] <strcat> sugar for @mut might go away anyway
[00:17:16] <sully> ok, it seems to be using something called default-tab-width
[00:17:18] <kmc> that's one solution!
[00:17:44] <kmc> I think we need deref sugar before replacing stuff with Rc<T> can begin in earnest
[00:17:49] <kmc> fortunately people are working on that
[00:17:53] <sully> but I have no idea how that is defined how how to change it
[00:18:09] *** Quits: bnicholson (bnicholson@moz-3492C575.rcmdva.fios.verizon.net) (Ping timeout)
[00:19:00] *** Joins: panzi (chatzilla@moz-7CD111D2.adsl.highway.telekom.at)
[00:19:09] <panzi> how do I declare a recursive struct that has a reference to it's parent?
[00:19:28] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:19:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:19:28] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:19:46] <tjc> panzi: struct T { parent = @T, â€¦ }
[00:19:48] <tjc> that's one way
[00:20:26] <dbaupp> panzi: you'll probably need an Option<..> too.
[00:20:41] *** Quits: jclements (jclements@F47764B0.E212572A.4B322BB7.IP) (Ping timeout)
[00:20:53] <strcat> @, Rc, unsafe pointers or represent it as an adjacency list
[00:20:54] <tjc> yeah
[00:21:23] <panzi> what's "Rc"?
[00:21:29] <strcat> reference counted box
[00:21:31] <cmr> extra::rc::Rc
[00:21:39] <kmc> http://static.rust-lang.org/doc/extra/rc.html
[00:21:48] <panzi> what's the difference to @?
[00:21:54] *** Joins: jclements (jclements@moz-6C9ED594.burl.east.myfairpoint.net)
[00:21:55] <kmc> you can't make cycles with Rc
[00:21:58] <kmc> that's assured statically
[00:22:01] <strcat> @ will be gc'ed, Rc has deterministic destruction
[00:22:26] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:22:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:22:26] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:22:27] <panzi> I thought @ also uses ref count
[00:22:34] <kmc> it does at the moment, but it does let you make cycles
[00:22:34] <cmr> @ is GC
[00:22:40] <strcat> panzi: due to a flawed implementation, but @ represents GC
[00:22:46] <kmc> and the cycles will go away only at task exit
[00:23:00] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[00:23:45] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Ping timeout)
[00:23:50] <strcat> @ is very bad for refcounting
[00:23:57] <strcat> since it allows cycles and doesn't have move semantics
[00:24:33] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:25:29] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[00:25:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:25:29] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[00:25:34] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:25:48] *** Joins: int3_ (int3_@moz-6F0859B8.dsl.pltn13.sbcglobal.net)
[00:25:51] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:26:57] *** Quits: jclements (jclements@moz-6C9ED594.burl.east.myfairpoint.net) (Ping timeout)
[00:27:12] <sully> graydon: ok, I think the problem is the emacs modes use of default-tab-width...
[00:27:47] <dbaupp> cmr: cool! (re the benchmarker stuff)
[00:28:26] *** Joins: jclements (jclements@BC794783.C405DCB0.EB48B30D.IP)
[00:28:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[00:28:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:28:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[00:31:28] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:31:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:31:29] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:32:11] <bjz> nmatsakis: how goes the extern fns?
[00:32:57] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[00:33:01] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:33:13] <sully> graydon: ok, so, I think default-tab-width is not the right way to configure this?
[00:33:18] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[00:33:20] *** Quits: IRCMonkey16438 (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[00:33:24] <eatkinson> what is the idiomatic way to do ~[my_fun(), ..1234] if 1234 isn't a constant?
[00:33:32] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:33:32] <sully> graydon: you probably want something like rust-basic-offset?
[00:33:43] <cmr> eatkinson: you don't
[00:33:51] <acrichto> eatkinson: vec::from_fn
[00:33:53] <cmr> eatkinson: Or, well, vec::from_elem
[00:33:54] <sully> graydon: as it is, you need to edit a rust hook to fix this, unless you want to always make the default tab width 4
[00:33:58] <cmr> But you don't use that syntax
[00:34:26] <eatkinson> cmr: mainly what i'm wondering is if i should use from_fn or from_elem
[00:34:29] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:34:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:34:29] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:34:39] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:34:44] <cmr> eatkinson: from_elem is slightly more optimized, since it doesn't use an intermediate closure
[00:34:51] <cmr> although I'm not sure that statement is accurate anymore
[00:34:54] <cmr> it used to be
[00:34:54] <strcat> they likely both compile to the same code now
[00:35:10] <strcat> but from_fn makes you define a closure
[00:35:21] <eatkinson> so from_elem doesn't store a temporary?
[00:35:27] <strcat> just choose based on convenience
[00:35:32] <strcat> eatkinson: from_elem clones N times in a loop
[00:35:36] * eatkinson looks at the src
[00:35:47] <strcat> both of them do a single allocation
[00:36:08] <ecr> Is pcwalton still around online somewhere?
[00:36:28] <cmr> ecr: send him an email, he usually replies to those quicklike
[00:36:33] *** Quits: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP) (Ping timeout)
[00:36:38] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[00:36:41] *** Quits: qmx (qmx@moz-B6DBCD05.qmx.me) (Ping timeout)
[00:36:47] *** Quits: smvv (smvv@moz-A397289C.xlshosting.net) (Ping timeout)
[00:36:48] *** Quits: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com) (Ping timeout)
[00:36:48] *** Quits: jhark (jhark@moz-B9920504.jhark.net) (Ping timeout)
[00:36:54] *** Quits: jpf (jan@moz-A8C26A15.org) (Ping timeout)
[00:36:55] *** Joins: jpf (jan@moz-A8C26A15.org)
[00:36:56] <ecr> thanks
[00:37:00] *** Joins: jhark (jhark@moz-B9920504.jhark.net)
[00:37:03] *** Quits: Thiez (thiez@moz-BF669398.student.utwente.nl) (Ping timeout)
[00:37:10] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[00:37:12] *** Joins: Thiez (thiez@moz-BF669398.student.utwente.nl)
[00:37:30] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[00:37:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:37:30] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[00:37:43] <strcat> bors, what are you doing >.<
[00:37:50] <Jeaye> haha
[00:37:56] <cmr> did something make every PR go stale?
[00:37:58] *** Joins: qmx (qmx@moz-B6DBCD05.qmx.me)
[00:38:07] *** Joins: katis (katis@40C8AF65.EFDC2270.EE6E63A5.IP)
[00:38:08] <strcat> graydon: bors is being weird and pushing 0 commits over and over ;\
[00:38:17] <strcat> I think he's on strike
[00:38:34] <tikue> to be fair he gots horrible hours and very minimal compensation
[00:38:34] <cmr> https://github.com/cmr/rust-zmq/blob/cleanup/zmq.rs#L85 is this sane for FFI?
[00:38:42] <cmr> I think it's safe..
[00:38:45] <eatkinson> strcat: if the closure can be optimized away, isn't from_fn faster because cloning takes time?
[00:39:00] <cmr> eatkinson: the clone can be optimized away too
[00:39:00] <eatkinson> cmr: ^
[00:39:02] <strcat> eatkinson: from_fn can't do anything more efficiently than clone
[00:39:21] <cmr> from_elem is literally a manually inlined version of from_fn
[00:39:31] <cmr> It used to be horribly awfully slow
[00:39:39] <eatkinson> strcat, cmr: even if i call intrinsics::uninit 
[00:39:41] <strcat> eatkinson: your from_fn closure does have to construct an element for each iteration, that's all clone does
[00:39:42] <cmr> now that strcat made it all better it can proably be fixed
[00:39:52] <strcat> eatkinson: there's no need to call uninit
[00:40:04] <cmr> eatkinson: from_elem is just as fast as a memcpy
[00:40:04] <strcat> it's not how you want want to create an uninit array
[00:40:18] <strcat> cmr: as a memset*
[00:40:21] <cmr> memset, right
[00:40:21] *** Joins: smvv (smvv@moz-A397289C.xlshosting.net)
[00:40:27] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:40:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:40:27] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:40:28] <strcat> it becomes one
[00:40:35] <eatkinson> strcat: how do i create an uninit array with a non-static size
[00:40:46] <strcat> eatkinson: of what kind of type?
[00:40:51] <strcat> and why?
[00:41:01] <cmr> No such thing as an uninit array, though with_capacity gets you halfway there
[00:41:04] <strcat> vec::with_capacity(N)
[00:41:08] <eatkinson> strcat: ~[AtomicUint]
[00:41:15] <eatkinson> strcat: it's for a chase-lev queue
[00:41:26] *** Quits: int3_ (int3_@moz-6F0859B8.dsl.pltn13.sbcglobal.net) (Client exited)
[00:41:36] <strcat> vec::with_capacity(N) is only a set_len away from an uninitialized array
[00:42:14] <eatkinson> strcat: thanks that will probably work
[00:42:23] <dbaupp> eatkinson: `vec::from_elem(N, unstable::atomics::INIT_ATOMIC_UINT)` ?
[00:42:52] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Ping timeout)
[00:43:27] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:43:27] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:43:27] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:44:00] *** Joins: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net)
[00:44:14] <panzi> why is it not possible to do: struct Node { parent: Option<&Node> } but somehow tell rust that the lifetime of parent is always > than of self? or is there some kind of weak ref in rust?
[00:44:43] *** Joins: int3_ (int3_@moz-6F0859B8.dsl.pltn13.sbcglobal.net)
[00:44:48] <strcat> because it's not provably safe
[00:45:16] <gavinb> rusti: use std::num::FromStrRadix; let a = fmt!("%04x", 5678u); let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();
[00:45:16] <dbaupp> panzi: struct Node<'self> { parent: Option<&'self Node> } says that the lifetime of self is *at most* the lifetime of parent
[00:45:19] -rusti- <anon>:5:74: 5:102 error: cannot determine a type for this bounded type parameter: unconstrained type
[00:45:19] -rusti- <anon>:5          use std::num::FromStrRadix; let a = fmt!("%04x", 5678u); let a = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap();
[00:45:19] -rusti-                                                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[00:45:19] -rusti- application terminated with error code 101
[00:45:26] <sanxiyn> jack: ping
[00:45:41] <geomyidae__> gr, rusti still manages to pop up in my irc client even when I'm on a different network. >_<
[00:45:42] <dbaupp> panzi: (it doesn't/can't say anything about the reverse.)
[00:45:44] <gavinb> I took this example almost directly from https://github.com/mozilla/rust/pull/8040/files but can't get past this error!
[00:45:51] <jack> sanxiyn: pong
[00:46:20] <dbaupp> rusti: use std::num::FromStrRadix; let a = fmt!("%04x", 5678u); let a: uint = FromStrRadix::from_str_radix(a.slice(0, 2), 16).unwrap(); a // gavinb
[00:46:22] *** Joins: bnicholson (bnicholson@moz-3492C575.rcmdva.fios.verizon.net)
[00:46:22] -rusti- 22
[00:46:28] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[00:46:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[00:46:28] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[00:46:29] *** Quits: int3_ (int3_@moz-6F0859B8.dsl.pltn13.sbcglobal.net) (Ping timeout)
[00:46:30] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[00:46:30] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/C9bvPA
[00:46:30] <ghrust> 13rust/06auto 145910834 15toddaaro: A major refactoring that changes the way the runtime uses TLS. In the...
[00:46:30] <ghrust> 13rust/06auto 14f1d909c 15Ben Blum: Have linked failure tests run on the new scheduler instead of requiring RUST_NEWRT to test.
[00:46:30] <ghrust> 13rust/06auto 1485d8552 15toddaaro: Fixed a race where a scheduler configured to only run tasks pinned to it would "bounch" a regular task in and out of the work queue without allowing a different scheduler to run it.
[00:46:33] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[00:47:00] <dbaupp> gavinb: it needs to have some way to infer the type to return
[00:47:16] <gavinb> dbaupp: thanks! But - why doesn't the net/ip.rs code have this and still work?
[00:47:35] <dbaupp> gavinb: becuse it's got surrounding information that allows the inference to happen
[00:47:41] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:48:02] <panzi> how does servo implement dom trees?
[00:48:05] <dbaupp> gavinb: the `%u` forces the a, b, c, ... to be uint
[00:48:31] <strcat> panzi: probably @
[00:49:12] <strcat> otherwise it would need to use unsafe code
[00:51:22] <strcat> there could be a version of Rc with a weak pointer type in a library
[00:51:23] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[00:51:36] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[00:52:36] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:52:58] <brson> there's a pr open that suggests adding a method to ToStr that takes a writer if anybody has an opinion https://github.com/mozilla/rust/pull/8089
[00:53:04] <gavinb> dbaupp: but the block starting on line 31 has only locals, with g coming from the pattern match, and cast as uint. How is there any extra type info to infer?
[00:53:45] <dbaupp> gavinb: the fmt! call
[00:54:01] <strcat> graydon: heh, making foreach a keyword broke the foreach tests >.<
[00:54:17] <dbaupp> gavinb: that is, the format call on line 38
[00:54:37] <acrichto> brson: I like the idea of having it in ToStr, although I'd prefer to see it with '&Trait' instead of 'T: Trait, &T'
[00:54:39] <dbaupp> gavinb: (the types of g, h, p are known from the types in the enum definition.)
[00:54:51] <strcat> acrichto: why &Trait?
[00:55:16] <acrichto> less parameterization and when you're doing writing/io/whatnot I don't think that the vtable overhead is really all that much
[00:55:16] <gavinb> dbaupp: Whoa, wait, what!? It infers types from uses later on in the block and from a cast?
[00:55:19] <dbaupp> acrichto: why? we can just have &Writer implement Writer, and we don't loose the flexibility, but still have the ability to avoid the code bloat
[00:55:26] <strcat> acrichto: it is a large overhead
[00:55:41] <acrichto> strcat: so is writing to memory if that's large?
[00:55:51] <dbaupp> gavinb: yes, it infers forward in time, ... not sure about what you mean by the cast though.
[00:55:53] <strcat> it's more expensive than writing out 20-50 bytes
[00:56:20] <acrichto> strcat: it's not a vtable call per byte in all cases
[00:56:46] <acrichto> I figured that most I/O things would take &Trait to generate less code
[00:57:09] <strcat> it won't generate less code though
[00:57:31] <strcat> it has to make a tydesc, visit glue, etc.
[00:57:31] <acrichto> won't it if you use it with multiple T's?
[00:57:44] <acrichto> it'll only generate one version of write_str
[00:58:35] <acrichto> strcat: this is all just hunches, I wouldn't actually make a decision without numbers
[00:58:41] <gavinb> dbaupp: inference forward was unexpected, but understandable. But I thought an expression like "g as uint" was essentially a safer C-style typecast, but didn't have implications for the type of g itself.
[00:59:01] <dbaupp> gavinb: yes, that's exactly what it is
[00:59:06] <strcat> acrichto: well we can measure the overhead of a virtual function call (in code size and actual speed)
[00:59:37] <acrichto> strcat: yeah obviously, but a virtual function call to determine what to write to a network is very different than a virtual function call when deciding what stage you are in a hashing function
[00:59:56] <strcat> in-memory formatting needs to be fast
[01:00:07] <strcat> stringstreams and iostreams in C++ suffer from virtual calls everywhere
[01:00:23] <strcat> because they were done before the language had mature alternatives
[01:00:30] <acrichto> oh definitely, and if everyone uses the same StringWriter instance (MemWriter) then the vtable call should be highly predictable anyway
[01:00:31] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Ping timeout)
[01:00:32] <gavinb> dbaupp: So in that code block, 'b' is declared without an explicit type on line 32, then its value is cast to a uint on line 38. So that is sufficient for the type system to infer that the actual type should originally have been uint?
[01:00:37] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[01:00:37] *** ChanServ sets mode: +qo graydon graydon
[01:00:49] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[01:00:50] <acrichto> strcat: again though, numbers should back this, not hunches
[01:00:52] <dbaupp> acrichto: I'm 100% sure that your objections are removed by having &Writer implement Writer, and using that to avoid the monomorphisation bloat.
[01:00:52] <strcat> acrichto: I don't think the cost of the call goes away if you call it more
[01:01:22] <dbaupp> acrichto: (where appropriate)
[01:01:29] <acrichto> dbaupp: I'm confused, fn foo<T>() {} generates one version per T I thought?
[01:01:43] <acrichto> dbaupp: whereas fn foo(t: &Trait){} only generates one version
[01:02:13] <strcat> the 'one version' is going to be longer in most cases
[01:02:14] <dbaupp> acrichto: yes, but, foo<T: Trait>(t: T) {}, foo(&bar as &Trait) only generates one version for &Trait
[01:02:23] <strcat> dealing with tydescs and visit glue is not cheap
[01:02:33] <strcat> you get a few hundred lines of *optimized* IR just for the basics
[01:03:01] <acrichto> dbaupp: true
[01:03:02] <dbaupp> gavinb: that's `p as uint`? not `b as uint`?
[01:03:10] <graydon> strcat: virtual method overhead isn't that bad. compare the codegen tests I just put in a PR.
[01:03:15] <graydon> it's reasonable to use sometimes
[01:03:28] *** Quits: jclements (jclements@BC794783.C405DCB0.EB48B30D.IP) (Ping timeout)
[01:03:28] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:03:30] <strcat> graydon: in a loop formatting an integer it is
[01:03:33] <strcat> it would be inlined
[01:03:44] <graydon> it's not free but it's in the few-percent range
[01:03:49] <graydon> over a static call
[01:03:56] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[01:03:58] <strcat> graydon: well if it's a few percent we have a problem with our regular calls
[01:04:06] <strcat> are you sure it's not devirtualized in that case?
[01:04:38] <strcat> in a simple case where it can inline the function everywhere it will devirtualize
[01:04:44] <strcat> if it knows the types
[01:04:46] <graydon> make #[bench] cases and measure please
[01:04:52] *** Joins: jclements (jclements@moz-8378FB3E.port.east.myfairpoint.net)
[01:04:57] <strcat> I will
[01:04:59] <graydon> ok
[01:05:01] <gavinb> dbaupp: aha, the penny drops! Ok, so the simple fact that it is being addressed as %u in the fmt!() string means it's a uint? That is unexpectedâ€¦! :) I'm guessing this is because the macro expansion of fmt!() ends up treating the variable as a uint such that the type system can unambiguously infer from theat?
[01:05:08] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:05:50] <graydon> test util::bench::trait_static_method_call ... bench: 7 ns/iter (+/- 5)
[01:05:50] <graydon> test util::bench::trait_vtable_method_call ... bench: 11 ns/iter (+/- 9)
[01:05:51] <dbaupp> gavinb: yes, it's entirely because %u uses the corresponding variable in a place that only takes `uint`.
[01:06:08] <graydon> ok that's more than a few percent. but it's not infinite.
[01:06:42] <gavinb> dbaupp: got it, thanks for the explanation! :)
[01:06:57] <strcat> graydon: I wouldn't be surprised if there was no virtual call though
[01:07:07] <strcat> just a bunch of tydesc bloat and a devirtualized call
[01:07:51] <graydon> strcat: pretty much every type has a tydesc emitted. the "bloat" is loading a static word into a cell of a pair.
[01:08:11] <graydon> it's possible it's devirtualized. I'll disassemble to check.
[01:08:51] <dbaupp> graydon: how do you get #[bench] to print the data-rate? (I saw someone had it printing 230 MB/s, or something like that.)
[01:09:00] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[01:09:08] <graydon> you set a bh.bytes value at the end of the run
[01:09:17] <graydon> indicating how many bytes were consumed in one loop of bh.iter
[01:09:30] <graydon> if that's nonzero, it prints out MB/s
[01:09:37] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[01:09:40] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[01:09:43] <dbaupp> ok, awesome, thanks.
[01:09:46] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[01:10:17] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[01:10:19] <graydon> (borrowed from go's benchmarker, it seems like a nice way to compensate for variable data-sizes in benchmark loops)
[01:10:36] *** Quits: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net) (Client exited)
[01:10:53] <graydon> dbaupp: note: do _not_ increment bh.bytes each time around the .iter loop
[01:11:31] <dbaupp> graydon: so `do bh.iter { use_1mb() } bh.bytes = 1024 * 1024`?
[01:11:36] *** Quits: jclements (jclements@moz-8378FB3E.port.east.myfairpoint.net) (Ping timeout)
[01:11:39] <graydon> dbaupp: yes
[01:11:58] <strcat> ugh, how do you make &Trait actually work?
[01:12:07] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[01:12:07] <strcat>         let x = 5;
[01:12:10] <strcat>         let y = &x as &Foo;
[01:12:12] <strcat>         foo_virtual(y)
[01:12:14] <strcat> yells about a non-static lifetime
[01:12:27] *** Joins: jclements (jclements@moz-5ED243A2.ptldme.east.myfairpoint.net)
[01:13:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[01:14:21] <graydon> jclements: confirmed on win32, if you remove the semicolons on the macro calls, that case crashes
[01:15:12] <brson> after all the outstanding runtime pull requests go through, one linked failure bug is fixed, and arc is fixed for newsched I think the entire test suite will pass with RUST_NEWRT=1
[01:16:00] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:16:30] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:16:30] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d07da7b to 14ef87e2c: 02http://git.io/N3iJvQ
[01:16:30] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:16:53] * brson itching to delete all those C++ files
[01:17:06] <brson> we may be able to completely eliminate rustrt's dependency on C++
[01:17:11] <brson> unwinding is tricky though
[01:17:29] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[01:19:22] <graydon> jclements: if you want to connect to the machine in question I can let you into it, but there's not much to see. you run the testcase, it crashes.
[01:19:28] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[01:19:29] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[01:19:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:19:29] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[01:20:32] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[01:20:45] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[01:21:44] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:21:54] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[01:21:58] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[01:22:12] *** Quits: cdidd (cdidd@moz-A628B9BE.broadband.corbina.ru) (Ping timeout)
[01:22:18] <panzi> now I fail writing a simple accessor! what's wrong here? http://pastie.org/8195380  error: mismatched types: expected `&'a str` but found `&~str` (expected &'a str but found &-ptr)
[01:22:20] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:22:29] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[01:22:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:22:29] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[01:24:24] <brson> panzi: &self.data is taking a pointer to an owned box (~str). try dereferencing data first, like &*self.data
[01:24:26] *** Quits: lkuper (lkuper@FBBF6446.A402E718.C082B7DC.IP) (Quit: lkuper)
[01:24:54] <dbaupp> graydon: I added a description of .bytes to https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking, if you want to check that it's correct.
[01:24:58] <panzi> brson: error: type ~str cannot be dereferenced
[01:25:23] <brson> panzi: oh, heh
[01:25:25] <dbaupp> panzi: self.data.as_slice()
[01:25:29] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:25:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:25:29] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:25:47] <graydon> dbaupp: that's correct, thanks
[01:25:55] <panzi> dbaupp: does this make a copy of the str?
[01:26:01] *** Joins: DeokjinKim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[01:26:20] <dbaupp> panzi: no, it just does the ~str -> &str coercion explicitly
[01:27:02] <strcat> does &mut Trait work?
[01:27:14] <strcat> can't seem to get it &Trait to do anything useful
[01:27:49] <panzi> dbaupp: is this specific to str? how wold it work for another tpye? (lets see...)
[01:27:52] <kmc> inlining as_slice() would give you  let s: &'a str = self.data; s
[01:27:58] <kmc> which does work, oddly enough
[01:28:00] <graydon> strcat: I believe &Trait is pretty broken. I was going to ask sully to spend some time on it next. It works for very simple cases but hardly anything complex.
[01:28:02] <dbaupp> panzi: it works for ~[]
[01:28:23] <dbaupp> kmc: that's exactly how .as_slice is implemented
[01:28:30] <kmc> that's what I said :)
[01:28:31] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:28:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:28:31] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:28:45] <dbaupp> kmc: oh, I see
[01:28:53] <kmc> it's just surprising that this code works when just returning self.data fails
[01:29:12] <kmc> since the function has an explicit return type anyway
[01:29:24] <dbaupp> yeah, it doesn't do the auto-slicing for return types (yet?)
[01:30:03] <dbaupp> panzi: it's really only relevant to ~str and ~[], because any other type ~T can be explicitly borrowed with &*foo
[01:30:11] * kmc â†’ afk
[01:31:28] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[01:31:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:31:29] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[01:31:33] <sully> graydon: do you have a good test case?
[01:32:16] <brson> toddaaro: your pr has failed twice for an obscure reason. can you investigate?
[01:32:17] *** Joins: cdidd (cdidd@moz-3285B1AC.broadband.corbina.ru)
[01:32:34] <brson> http://buildbot.rust-lang.org/builders/auto-linux-32-opt/builds/672/steps/test/logs/stdio
[01:33:12] <tjc> well, at least it's not my fault this time :-)
[01:33:19] <toddaaro> brson: that is weird, I'll try and reproduce
[01:34:31] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:34:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:34:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:34:46] <panzi> hmm, and why do I get tree.rs:52:2: 52:25 error: type `@Node` does not implement any method in scope named `appendChild` here?: http://pastie.org/8195412
[01:34:54] <brson> toddaaro: if it's 32-bit only you can configure with `../configure --build-triple=i686-apple-darwin`
[01:35:16] <panzi> also I'd guess it would leak mem if it worked, because of ref loops
[01:35:28] <panzi> if @ is implemented as ref counting
[01:37:30] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[01:37:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:37:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[01:37:39] <enix> bors appears to have gone nuts on my pull request: https://github.com/mozilla/rust/pull/8097
[01:37:43] <toddaaro> brson: ok, I might try that
[01:38:08] <dbaupp> enix: woah!
[01:38:14] <enix> it merges into auto every 3 minutes
[01:38:16] *** Quits: jclements (jclements@moz-5ED243A2.ptldme.east.myfairpoint.net) (Ping timeout)
[01:38:18] <enix> well, twice every 3 minutes
[01:38:37] <brson> graydon: ^
[01:38:43] *** Joins: jclements (jclements@moz-19C0E5F.ngn.east.myfairpoint.net)
[01:38:46] <enix> at 40 merges an hour, i'm becoming quite the rust contributor
[01:38:59] <graydon> checking
[01:39:23] <strcat> graydon: http://ix.io/6YZ my attempt at a benchmark
[01:39:33] <strcat> test bench_inline ... bench: 29 ns/iter (+/- 1)
[01:39:35] <strcat> test bench_static ... bench: 37 ns/iter (+/- 1)
[01:39:37] <strcat> test bench_virtual ... bench: 79 ns/iter (+/- 1)
[01:39:55] <strcat> the call itself doesn't matter much, but it makes zeroing the arrays slower
[01:39:58] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[01:40:18] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:40:21] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[01:40:29] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:40:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:40:29] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:40:29] <brson> nmatsakis: how attached are you to the debug_foo functions in rust_builtin for logging debug info about types? ever use them anymore?
[01:40:46] *** Joins: muslimasry (dasdasd@4A76D903.4FC71845.521C0519.IP)
[01:40:48] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[01:40:48] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:40:48] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[01:40:49] *** Quits: muslimasry (dasdasd@4A76D903.4FC71845.521C0519.IP) (User has been banned from Mozilla (abuse))
[01:41:00] <graydon> huh
[01:41:04] <graydon> it gets a bad status line from the merge
[01:41:11] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[01:41:13] <graydon> I have no idea what to do about that
[01:41:44] <graydon> strcat: so about 2x, ok. that's substantially slower, but it might make sense depending on code size.
[01:41:52] <graydon> (in particular, the inlinee code size)
[01:41:58] <brson> i'm guessying that nobody uses extra::dbg
[01:42:06] <graydon> brson: I believe it's long dead
[01:42:10] <brson> i think that's been dormant since i began on rust
[01:42:17] <graydon> yeah, around then
[01:42:18] * brson delete
[01:42:20] <graydon> kill it
[01:42:44] <graydon> enix: can you possibly close and reopen the PR? I don't know what's wrong but github is not responding sensibly to the merge request, and bors is crashing
[01:42:57] <enix> ok, closed
[01:43:06] <enix> should i just re-open the same request? should I wait a few mins?
[01:43:22] <graydon> same branch, but open a new PR
[01:43:28] <graydon> point me at it, I'll r+ with high priority
[01:43:46] <enix> ok, cool, will do
[01:44:23] <panzi> how do you call a method with that signature: fn appendChild(@mut self, node: @Node), I get: error: type `@Node` does not implement any method in scope named `appendChild`
[01:45:20] <graydon> strcat: if you compare the IR of the two calls, is there anything obviously wrong besides the indirect branch?
[01:45:22] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[01:45:27] <graydon> strcat: or is that just indirect branch costs?
[01:45:33] <strcat> sec
[01:45:40] <dbaupp> panzi: @Node is different to @mut Node
[01:45:49] <panzi> hmm
[01:46:16] <enix> I've opened up 8174: https://github.com/mozilla/rust/pull/8174
[01:46:47] <strcat> graydon: btw the reason it doesn't optimize the inline one to nothing is ptr -> int conversions in the vec iterator ;p
[01:46:53] <strcat> ptr -> int -> ptr
[01:47:01] <strcat> since it thinks that pointer could come from anywhere
[01:47:11] <enix> uh, all of bors's comments move over to the new pr
[01:47:12] <graydon> your GEP change should fix that, yes?
[01:47:13] <dbaupp> strcat: isn't that fixed now?
[01:47:20] <graydon> enix: the comments are on the head
[01:47:20] <panzi> ok, got it
[01:47:28] <graydon> enix: attempting to re-run
[01:47:29] <strcat> graydon: well I fixed ptr::offset but the vec iterator has to avoid using that due to zero-size types atm
[01:47:39] <strcat> graydon: it uses non-zero size_of in the offset
[01:47:45] <enix> ah, ic
[01:47:54] <dbaupp> strcat: can't it branch on size_of() == 0? (and let llvm const-fold?)
[01:47:57] <graydon> strcat: not sure I follow. what's the problem with zero sized types?
[01:47:59] <strcat> dbaupp: it could
[01:48:07] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:48:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDo0PA
[01:48:07] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:48:07] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[01:48:07] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/GYdM5A
[01:48:07] <ghrust> 13rust/06auto 14d3a6379 15Palmer Cox: Sha2: Remove unecessary integer type specifications.
[01:48:07] <ghrust> 13rust/06auto 142e95ccc 15Palmer Cox: Sha2: Rearrage traits / impls / structs....
[01:48:08] <ghrust> 13rust/06auto 149cc7573 15Palmer Cox: Sha2: Remove the result_X() methods; move logic into the Digest impls....
[01:48:10] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[01:48:13] <enix> thanks
[01:48:18] <strcat> graydon: well the iterator uses a start ptr and an end ptr, and so with zero-size types it will finish in the first iteration
[01:48:26] <strcat> so we switched it to non-zero size_of
[01:48:29] <engla> nice improvements to SHA enix 
[01:48:38] <enix> thanks!
[01:48:48] <graydon> strcat: what should it use, if not 2 pointers?
[01:48:49] *** Joins: maikklein (maik@moz-C3D98781.dip0.t-ipconnect.de)
[01:48:58] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[01:49:03] <strcat> graydon: well for zero-size types it essentially just needs a counter
[01:49:16] <strcat> but I'm unsure about how to specialize it for them without making it much worse for no-opt builds
[01:49:20] <strcat> I guess it doesn't really matter much
[01:49:25] <strcat> but vec iteration is very common
[01:49:35] <graydon> I'm not sure I get it. when do we iterate over arrays of zero sized types?
[01:49:45] <strcat> struct Foo; [Foo, Foo, Foo]
[01:49:48] *** Quits: maikklein (maik@moz-C3D98781.dip0.t-ipconnect.de) (Connection reset by peer)
[01:49:48] <graydon> and what .. should even happen there? why is it wrong to finish in the first iteration?
[01:50:00] <strcat> graydon: because you can have N zero-size types in an array
[01:50:09] <strcat> and the N is still semantically significant
[01:50:11] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[01:50:17] <graydon> hm. so this isn't really anything to do with LLVM not liking zero-sized types
[01:50:21] <strcat> rusti: std::sys::size_of::<[Foo, ..5]>()
[01:50:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CNKD
[01:50:30] <graydon> it's just our library code making the assumption that types have nonzero sizes?
[01:50:30] <strcat> rusti: struct Foo; std::sys::size_of::<[Foo, ..5]>()
[01:50:31] -rusti- 0
[01:50:59] <strcat> graydon: well, the issue here is that it's convenient/fast to write an iterator that way, but it doesn't work for zero-size ones
[01:51:11] <strcat> there are likely correctness issues elsewhere though
[01:51:20] <strcat> [Foo, Foo, Foo] is 0-size
[01:51:21] <graydon> sure. but ... back up a step
[01:51:31] <graydon> you told me there was something we were doing that was slow
[01:51:34] <graydon> because we didn't use GEP
[01:51:38] <graydon> right?
[01:51:39] <strcat> graydon: right
[01:51:48] <graydon> so how would we "use gep" in this case?
[01:51:52] <strcat> graydon: so, if vec iterators used ptr::offset it would use GEP
[01:52:00] <strcat> but ptr::offset bumps by size_of::<T>()
[01:52:06] <strcat> and it needs non-zero size atm
[01:52:19] <strcat> it's a weird issue.
[01:52:32] *** Quits: tchoma (tchoma@moz-E58E29CC.dsl.static.sonic.net) (Ping timeout)
[01:52:36] <graydon> what needs nonzero size? size_of::<T>, or the iterator?
[01:52:44] <strcat> graydon: the iterator
[01:52:53] <strcat> because it needs ptr to take N bumps to reach end
[01:53:03] <graydon> ok. then why don't we rewrite the iterator to use a counter and a pointer?
[01:53:07] <graydon> rather than 2 pointers
[01:53:11] <engla> does the branch on sizeof count as a constant bool, so it will be removed even before optimize?
[01:53:16] <strcat> graydon: it's slower
[01:53:23] <graydon> why?
[01:53:25] <strcat> graydon: because each iteration bumps the pointer and decreases the size
[01:53:33] <strcat> it doesn't actually optimize out
[01:53:34] *** Joins: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de)
[01:53:50] <graydon> seems like a case for two different iterator impls
[01:53:53] <strcat> (but then again neither does this current workaround)
[01:54:06] <maikklein> rusti: foreach x in [1,2,3] {}
[01:54:07] -rusti- <anon>:5:9: 6:5 error: type `&mut [<VI2>, .. 3]` does not implement any method in scope named `next`
[01:54:07] -rusti- <anon>:5          foreach x in [1,2,3] {}
[01:54:07] -rusti- <anon>:6     };
[01:54:07] -rusti- error: aborting due to previous error
[01:54:07] -rusti- application terminated with error code 101
[01:54:17] <maikklein> rusti: foreach x in ~[1,2,3] {}
[01:54:18] -rusti- <anon>:5:9: 6:5 error: type `&mut ~[<VI2>]` does not implement any method in scope named `next`
[01:54:18] -rusti- <anon>:5          foreach x in ~[1,2,3] {}
[01:54:18] -rusti- <anon>:6     };
[01:54:18] -rusti- error: aborting due to previous error
[01:54:18] -rusti- application terminated with error code 101
[01:54:28] <dbaupp> engla: I don't think so, because of the way intrinsics are trans'd (although strcat or doener would know the details.)
[01:54:29] <engla> maikklein: need to call .iter()
[01:54:30] <graydon> maikklein: .iter()
[01:54:49] <maikklein> rusti: foreach x in ~[1,2,3].iter() {}
[01:54:50] <graydon> we can maybe fix that, but the simple version I landed doesn't automatically call .iter() for you
[01:54:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/POcd
[01:54:52] <graydon> maybe it should?
[01:54:54] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[01:54:58] <engla> ok, yeah they probably already know. don't mind me everyone
[01:55:06] <strcat> graydon: well I think it should first make sure you're passing an Iterator impl
[01:55:15] <strcat> atm it's duck-typed, which is a bit weird
[01:55:21] <SiegeLord> Hmm? It's 'foreach' and not 'for'?
[01:55:23] <maikklein> rusti: let v = ~[1,2,3,4]; foreach x in v.iter() {}
[01:55:24] -rusti- <anon>:5:37: 5:38 warning: unused variable: `x` [-W unused-variable (default)]
[01:55:24] -rusti- <anon>:5          let v = ~[1,2,3,4]; foreach x in v.iter() {}
[01:55:24] -rusti-                                               ^
[01:55:24] -rusti- ()
[01:55:30] <graydon> SiegeLord: foreach is a temporary keyword
[01:55:33] <graydon> while we do the transition
[01:55:35] <SiegeLord> Ah, ok
[01:55:47] *** Joins: sammykim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[01:55:50] <dbaupp> graydon: if we had a method .iter(self) -> Self { self }, then it would work in a ducktype-y way
[01:55:52] <strcat> graydon: sroa makes this all pretty unreadable ;p
[01:56:05] <dbaupp> graydon: (that is a method on Iterator)
[01:56:27] <graydon> strcat: I know, I will rewrite it eventually to (presumably) do something like call to_iter(<expr>) on the passed in expr, and have that function demand an iterator<T> or iterable<T>
[01:56:33] <graydon> it's fixable
[01:58:03] * brson dinner
[01:58:11] <graydon> I'll head home soon. night.
[01:58:26] <strcat> graydon: http://ix.io/6Z0 doesn't look like great code
[01:58:41] <strcat> that's just a single virtual function call
[01:58:49] * strcat doesn't know what all that mess is for
[01:58:58] <graydon> yeah. I have an isolated codegen test about virtual calls too IIRC
[01:59:23] <graydon> yeah, test/codegen/virtual-method-call.{cc,rs}
[01:59:37] <graydon> er, in https://github.com/mozilla/rust/pull/8165
[01:59:40] <graydon> still landing
[01:59:53] <graydon> side-by-side with clang we're a fair bit worse
[02:00:06] <gavinb> I keep using 'let' and 'println' now when I'm writing C++ code!
[02:03:53] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[02:06:10] <strcat> gavinb: http://ix.io/6Z2 ;p
[02:06:13] * strcat runs
[02:06:36] <gavinb> strcat: wicked! :)
[02:06:54] *** Joins: jga (asdf@AADB87A2.35F814CC.B5524284.IP)
[02:07:16] <graydon> you forgot #define fn int
[02:07:16] <jga> anyone knows if there is a key-value database in progress or something planned?
[02:07:26] *** Quits: bytewise (bytewise@moz-649C630D.unitymediagroup.de) (Quit: Leaving)
[02:07:30] <graydon> jga: someone did mongo drivers
[02:07:39] <strcat> if you're okay with writing your strings as string<'a', 'b', 'c'> you can even have type-safe format strings like fmt! ;p
[02:07:53] <panzi> can I get a *mut Node from a ~Node?
[02:07:58] <panzi> how?
[02:08:07] <jga> graydon: yeah, I saw it, in (pure) rust I mean
[02:08:20] <strcat> panzi: let *mut Node = &mut *Node
[02:08:25] <aatch> graydon, if by "someone" you mean 10gen
[02:08:37] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[02:08:40] <panzi> or rather form an ~mut Node
[02:08:49] <strcat> ~mut doesn't actually exist anymore
[02:08:53] <graydon> strcat: C++11 : http://en.cppreference.com/w/cpp/language/user_literal
[02:08:55] <strcat> it's just mutable if the slot it's in is mutable
[02:08:59] <panzi> arg
[02:09:06] <panzi> I meant &mut Node
[02:09:10] <strcat> graydon: yeah but you can't do constexpr stuff on them
[02:09:13] <graydon> strcat: that kitchen sink can hold a lot!
[02:09:18] <strcat> graydon: with strings
[02:09:21] <panzi> unbeliavable. I think I have to got to sleep
[02:09:24] <graydon> what no constexpr?
[02:10:17] <graydon> aatch: oh I didn't put 2 and 2 together there, it was actually mongo-the-comapny, ok
[02:10:18] <strcat> graydon: they basically didn't bother supporting strings in that
[02:10:31] <strcat> because the use cases they were presented were things like complex numbers
[02:10:41] <strcat> maybe it'll come along in C++17
[02:10:45] <strcat> ;p
[02:11:15] <graydon> strcat: you can't do a custom literal that's written as a string but produces a different non-string-typed value?
[02:11:32] <strcat> graydon: nope, I think you can only do them on integers/floats
[02:11:35] <strcat> atm
[02:11:43] <graydon> aw what rubbish
[02:11:48] <graydon> like the template limitations
[02:11:49] <graydon> oh well
[02:11:50] <aatch> I kinda get why though
[02:12:04] <graydon> I can think of 100 reasons why. I was mostly kidding.
[02:12:14] <aatch> since strings are pointers..
[02:12:19] <strcat>     If L is a user-defined-string-literal, let str be the literal without its ud-suffix and let len be the number of code units in str (i.e., its length excluding the terminating null character). The literal L is treated as a call of the form
[02:12:19] <graydon> my jaw kinda hit the floor when I saw the literal operators in the first place
[02:12:21] <strcat>     operator "" X (str, len)
[02:12:24] *** Parts: jga (asdf@AADB87A2.35F814CC.B5524284.IP) ()
[02:12:40] <strcat> graydon: they basically forbid doing anything fancy
[02:13:02] <graydon> wait, did you just quote that from somewhere?
[02:13:06] <strcat> like their constexpr limitation (has to be 1 return statement, not other statements)
[02:13:08] <graydon> doesn't that imply they handle strings?
[02:13:09] <strcat> graydon: yes
[02:13:28] <strcat> graydon: they do actually, but you can't pass parameters
[02:13:37] <strcat> so you could do...
[02:13:43] <graydon> right, but it could produce a formatter object
[02:13:47] <graydon> from a format string
[02:13:54] <strcat> graydon: yes, but your type-checking has to be runtime
[02:14:00] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[02:14:03] <strcat> afaict.
[02:14:32] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:14:34] <graydon> I'd have to study the order of constexpr evaluation and SFINAE-evaluation
[02:14:34] <strcat> what you really want is... "%d %s"_fmt(5, "foo") + variadic template deals with type-checking
[02:14:41] <graydon> yeah
[02:14:42] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[02:14:48] <graydon> guess which game I am no longer interested in playing?
[02:15:02] <graydon> "how much can I write lisp in C++ metaprogram-ese?"
[02:15:21] <strcat> more like haskell ;p
[02:15:33] <graydon> (if only it _were_ lisp and not multi-phase prolog with extremely limited types)
[02:16:11] <graydon> yeah, it does feel a bit like writing haskell. ah well. I hope rust doesn't produce that sensation too.
[02:16:41] *** Quits: sebcrozet (sebcrozet@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Ping timeout)
[02:17:29] <strcat> graydon: boost has string metaprogramming but you have to write your strings as string<'foob', 'ar'> (yes, they use the implementation-defined long character constants)
[02:17:52] *** Quits: jgilbert (jgilbert@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[02:18:01] <strcat> not as bad as each character by itself I guess.
[02:18:09] *** Parts: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) ()
[02:18:13] <acrichto> graydon: could I ask you a condition! question?
[02:18:15] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[02:18:28] <graydon> acrichto: sure, but .. do be aware they are mostly broken now
[02:18:50] <acrichto> graydon: oh, for https://gist.github.com/alexcrichton/6127927 I'm sure that a condition is being raised, but the condition isn't invoking the `trap` closure
[02:18:50] <graydon> (apparently don't work cross-crate; was top-of-my-list until fixing jclements' let-hygiene thing bumped it, then foreach bumped that)
[02:18:59] <acrichto> oh, nevermind, that's cross-crate
[02:19:17] <acrichto> no worries, this isn't super urgent
[02:19:49] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[02:19:52] <strcat> graydon: there are even meta-type maps/sets/vectors and iterators...
[02:20:34] <strcat> 'type identity is used to impose an equivalence relation on keys, and the order in which sequence elements are traversed during iteration is left unspecified'
[02:20:43] <graydon> I would quite like them to work cross-crate. I think it has to do with function address taking happening at the thunk address, not the target address. it's ... possibly easy to fix? by using a static datum address instead. I was worried those might be consolidated.
[02:20:49] <engla> Do we change 5.times { }  to an iterator over () or into an unbreakable do { }  loop?
[02:21:08] <strcat> or just to using a range
[02:21:11] <graydon> strcat: yeah, I know, I used to hack that stuff for fun. eventually got sick of "typedef result = foo<T,U,V>;"
[02:21:51] <engla> strcat: .times() is pretty loved by the task module for some reason. overwhelmingly used unbroken (always all iterations)
[02:22:01] <acrichto> graydon: yeah you're right I just minimized it, you can't catch a cross-crate condition when it's raised in the other crate. I'll investigate this a bit and see if there's a quick fix.
[02:22:35] <graydon> acrichto: it's related to TLS. we use a TLS key to get the handler.
[02:22:40] *** Quits: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de) (Ping timeout)
[02:22:58] <graydon> acrichto: if TLS keys no longer have to be functions, that'd fix it.
[02:23:28] <acrichto> graydon: the TLS key is just a pointer to a piece of data
[02:23:32] <graydon> acrichto: alternatively it might just be that condition! needs to annotate things as no-inline or something
[02:24:03] <graydon> acrichto: right, so .. what that _should_ boil down to is pushing a handler on a TLS-list in the .trap() call and then looking-it-up and calling it in the .raise() step
[02:24:12] <engla> strcat: it sounds logical to use the do {} loop and convert the breaking ones to a range loop
[02:24:24] *** Quits: bnicholson (bnicholson@moz-3492C575.rcmdva.fios.verizon.net) (Input/output error)
[02:24:29] <acrichto> graydon: the weird thing is that the debug! statement in the `in` function is never executed
[02:24:31] <strcat> engla: that sounds good, you could just makes times not take a bool from the closure
[02:24:34] <graydon> acrichto: but note: in dynamic linking, function address are often non-identical between the inside and outside of a crate. depends on platform and dynamic linking discipline.
[02:25:01] <engla> strcat: yeah, so it's going to be dead simple
[02:25:17] <graydon> acrichto: so I _thought_ I handled that by having both .trap and .raise be methods compiled _in_ the crate that defines the TLS key
[02:25:32] <graydon> acrichto: but if they wind up inlined in the caller-crate, that'll break
[02:25:51] <graydon> acrichto: or worse, if you're not even seeing the .in closure executed, there might be something weirder going on still.
[02:26:13] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[02:26:19] <acrichto> graydon: interesting... the TLS key is just a static enum now, so maybe that ended up breaking something
[02:26:31] <graydon> acrichto: I would love it if you could figure this out. it's on my list but my list is like a pit of wild hyenas
[02:26:55] <graydon> (I guess we haven't managed to domesticate hyenas so that's a bit redundant)
[02:27:01] <acrichto> graydon: I can imagine :)
[02:28:33] <tjc> heh, that hyena comment was interesting out of context (reading bottom to top)
[02:30:19] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:30:38] <panzi> do I get this right, that only fields of @-objects are mutable?
[02:31:10] <panzi> how can I change an Option<T>-field from None to Some(thing)?
[02:31:17] <graydon> panzi: only fields of mutable values. @mut means the value is mutable. so is anything ~ owned by a mut variable.
[02:31:22] <tjc> graydon: speaking of a pit of wild hyenas, r? https://github.com/mozilla/rust/pull/8176
[02:31:36] <panzi> graydon: it's &mut
[02:31:42] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[02:31:50] <panzi> and I get "cannot assign to immutable field"
[02:32:05] <graydon> panzi: what's the type?
[02:32:13] <graydon> panzi: if there's a @ in the way that's a different owner
[02:32:34] <panzi> graydon: its line 15 here: http://pastie.org/8195502
[02:32:44] <acrichto> graydon: you're right, the crate that calls `trap` and `in` sees one version of `cond.key` while the other crate calling `raise` sees a different value of `cond.key`
[02:33:16] <graydon> panzi: child is ~Node there
[02:33:20] <graydon> that's an immutable type
[02:33:22] *** Quits: brson (brson@8ECA0B87.AD77F8DE.D1E74241.IP) (Ping timeout)
[02:33:36] <graydon> acrichto: yeah. so that's .. bad.
[02:33:42] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[02:33:44] <graydon> acrichto: if you can maybe make sure trap and in are non-inlined?
[02:34:15] <acrichto> graydon: no luck
[02:34:30] <panzi> graydon: ~mut says its obsolete (error)
[02:34:32] <acrichto> graydon: `trap` will be generated in the local crate anyway though I think
[02:34:41] <graydon> panzi: mut child: ~Node
[02:34:55] <graydon> panzi: the owner needs to be mut. in this case the owner is the local variable.
[02:34:58] <panzi> graydon: ah ic! thanks
[02:35:08] <graydon> panzi: mutability inherits through ownership
[02:35:21] <strcat> graydon: any idea how to fix this? foreach-external-iterators-break.rs:13:17: 13:18 error: found `foreach` in ident position
[02:35:27] <strcat> graydon: after making it count as a keyword
[02:35:43] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[02:35:47] <graydon> strcat: no, I thought I _did_ make it a keyword!
[02:35:59] <graydon> presumably parse it using a different function
[02:36:03] <strcat> graydon: you actually didn't :), because there were integers you didn't update
[02:36:13] <strcat> it identifies keywords by hardcoded integer ranges...
[02:36:24] <graydon> oh :(
[02:36:57] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:38:29] *** Quits: sigma-pc (sigma@moz-BE11A887.range109-151.btcentralplus.com) (Connection reset by peer)
[02:38:31] <graydon> snaps complete, registering
[02:38:33] <strcat> hrm.
[02:39:13] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[02:39:24] <Seldaek> woot! search! (very basic rendering, it's 5am I have to stop, but it works) http://seld.be/rustdoc/std/index.html
[02:40:04] <graydon> Seldaek: \o/ \o/
[02:40:29] <graydon> get some sleep
[02:40:35] <Seldaek> yeah ;)
[02:41:05] <graydon> r? https://github.com/mozilla/rust/pull/8177 new snapshots
[02:41:43] <strcat> graydon: afaict you're parsing it fine
[02:41:50] <strcat> maybe I need to do something else now that it's a keyword
[02:41:59] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[02:42:00] *** ChanServ sets mode: +o brson
[02:43:06] <toddaaro> brson: just finished make check, no error
[02:43:10] <toddaaro> brson: trying a 32bit build
[02:43:56] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[02:43:58] <strcat> graydon: ugh. I know what the issue is >.<
[02:44:07] <strcat> graydon: off-by-one error in one of the places these integers are
[02:44:10] * strcat sighs
[02:44:29] <graydon> :(
[02:45:10] <toddaaro> brson: bah, I don't have the ability to compile 32bit things
[02:45:17] <toddaaro> brson: I'm going to have to learn how to do this in the morning
[02:45:40] <toddaaro> (not enough battery to do so tonight)
[02:46:02] <strcat> graydon: https://github.com/mozilla/rust/pull/8162/files#L21R657 the issue was those evil match exprs btw
[02:46:10] <strcat> graydon: they hardcode a range of interned tokens that are keywords
[02:46:18] <brson> toddaaro: ok
[02:46:26] <graydon> acrichto: do you happen to know why http://huonw.github.io/isrustfastyet/buildbot/ shows a huge regression on #7924?
[02:46:34] <graydon> it might just be "we changed something on the bots that day" but ...
[02:46:38] <graydon> seems pretty bad
[02:46:54] *** Quits: zz_kimundi (kimundi@moz-D3F44D32.dip0.t-ipconnect.de) (Ping timeout)
[02:47:25] <graydon> strcat :(((((
[02:47:31] <graydon> how horrid
[02:47:42] <acrichto> graydon: oh that's not good... I don't think that the pull should have caused a huge regression like that...
[02:47:50] <graydon> can you change that to an if of some sort? with a min/max const or something?
[02:47:50] <strcat> graydon: and I managed to get In and For off-by-one ;p
[02:48:15] <strcat> In was ForEach and ForEach was Be, or something like that...
[02:48:19] * strcat shrugs
[02:48:32] <strcat> very weird anti-pattern we have in these places
[02:49:01] * strcat managed to make this same mistake while adding/removing lang items before
[02:49:28] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[02:49:56] *** Joins: zz_kimundi (kimundi@moz-CA8AB5FA.dip0.t-ipconnect.de)
[02:50:23] *** zz_kimundi is now known as kimundi
[02:50:43] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[02:51:45] <shachaf> Is there a reason Rust couldn't support Haskell-style type annotations?
[02:52:18] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:52:20] <shachaf> As in (e: int) to specify that e is an int (not a cast, just an annotation).
[02:53:23] <brson> shachaf: it's been proposed, and was in fact discussed this week on the mailing list
[02:53:27] *** Quits: lmandel (lmandel@moz-AEAD2F61.dsl.bell.ca) (Ping timeout)
[02:53:29] <brson> it's a pretty low priority
[02:53:42] <strcat> graydon: that little span of 2 PRs where it was faster seems like noise rather than a regression
[02:53:51] <shachaf> brson: Oh. I should follow the mailing list more! I just subscribed recently.
[02:54:16] <shachaf> I suppose it's less useful than Haskell because the kind of polymorphism where it's relevant comes up less often (but still does come up sometimes).
[02:54:20] <graydon> shachaf: the place you'd put it would cause it to collide with other syntax
[02:54:28] <graydon> (namely sub-patterns in labels)
[02:54:36] <shachaf> You can also use id::<t>(x) as an annotation.
[02:54:55] <benh> Does that move?
[02:55:02] <strcat> oh I guess you mean something else
[02:55:19] <strcat> benh: it's T -> U by-value
[02:55:35] <strcat> er
[02:55:38] <strcat> T -> T
[02:56:13] <shachaf> graydon: Sub-patterns? I'm talking about expressions.
[02:56:42] <graydon> shachaf:in expr context it might be feasible. we were discussing it in pattern grammar.
[02:56:45] <benh> (What does : do in the pattern language again?)
[02:56:46] <shachaf> (Though maybe that still comes up?)
[02:56:53] <graydon> shachaf: rust has roughly 3 grammars: types, exprs and patterns
[02:57:07] <graydon> benh: Foo { bar: <--- right there
[02:57:12] <benh> ah
[02:57:19] <shachaf> Right.
[02:57:39] <graydon> it shows up in exprs there too but it's a plausibly less-interesting spot to put an ascription
[02:57:58] <shachaf> It's kind of odd that : is used there, since a label isn't a type.
[02:58:09] <graydon> it's to be symmetric with types
[02:58:09] <shachaf> But I see that graydon already quoted Larry Wall on this particular issue. :-)
[02:58:17] <graydon> Foo { label: type }
[02:58:22] <graydon> is a production in type grammar
[02:58:29] <graydon> and Foo { label: expr }
[02:58:32] <graydon> is a production in expr grammar
[02:58:52] <shachaf> That's not really a place where I'd expect symmetry. But maybe that's just a matter of being used to Haskell syntax.
[02:59:37] <graydon> it's a sad sad story that mostly consists of a delicate pyramid of bikesheds stacked perilously atop one another
[02:59:48] <benh> I thought it was for symmetry with json :)
[03:00:01] <shachaf> If Rust had something like keyword arguments would it use fn f(x: int, y: char) ... f(x: 1, y: 'a')?
[03:00:03] <strcat> struct Foo { bar: T }; let x = { T: rab } ooF;
[03:00:17] <strcat> struct Foo { bar: T }; let x = { T :rab } ooF; *
[03:00:19] <shachaf> I like being able to read ":" as meaning "type".
[03:00:22] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[03:01:01] <graydon> shachaf: this is about 2, maybe 3 years too late to be moving these particular bikesheds around
[03:01:07] <shachaf> Fair enough!
[03:01:15] <graydon> sorry. I liked field=value too
[03:01:15] <strcat> there isn't really another way of making it clear that you're setting a specific field to a value
[03:01:26] <strcat> := ;p
[03:01:29] <graydon> but we have a couple hundred kloc now and many many user packages
[03:01:34] <sp3d> agreed :/
[03:01:35] <benh> strcat: a compromise! i like it!
[03:01:50] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[03:02:05] <shachaf> There are more interesting things to object to in the language anyway.
[03:02:25] <shachaf> (I wasn't even objecting.)
[03:02:34] <steven_is_false> Hello cmr. Did you create an issue for the weird bug you told me about earlier yet?
[03:02:37] <strcat> yes, 50% of allocations will be randomly chosen to be garbage collected, arrays will be 0.5-indexed and some type errors will be deferred to runtime
[03:02:55] <sp3d> some ICEs will occur /outside/ the compiler?
[03:02:56] <graydon> if at all possible -- and I say this out of a desire to have constructive conversation in a positive tone, not avoid input -- can you phrase it in terms of queries and suggestions rather than objections?
[03:03:15] *** Joins: lmandel (lmandel@CD1A664D.7ECD71DF.ADB88A9.IP)
[03:03:28] <strcat> sp3d: yes, we'll include some of rustc in every program :D
[03:03:48] <graydon> 8pm, still in the office. hmm. time to go home I think.
[03:03:52] <brson> toddaaro: i can't repro either :-/
[03:03:55] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[03:03:55] <graydon> night all
[03:03:58] <strcat> \o
[03:03:59] <shachaf> graydon: Yep, I realized that after I said that. I wasn't actually objecting.
[03:04:03] <graydon> o/
[03:04:11] <graydon> shachaf: cool. ttyl.
[03:04:15] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[03:05:04] <strcat> sp3d: or we can just make something like https://github.com/mattdiamond/fuckitjs ;p
[03:05:14] <strcat> but it'd be harder in rust.
[03:05:43] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:05:43] <strcat> hm, maybe...
[03:05:50] <strcat> type error -> insert transmute automatically
[03:06:40] <shachaf> GHC had a type error -> delete file bug once.
[03:07:08] <toddaaro> brson: ominous, anything unusual about the bot machine?
[03:07:17] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:07:51] <brson> toddaaro: not that I know of. i asked bors to retry yet again
[03:07:57] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[03:08:05] *** Quits: panzi (chatzilla@moz-7CD111D2.adsl.highway.telekom.at) (Quit: ChatZilla 0.9.90.1 [Firefox 22.0/20130624150515])
[03:08:25] <brson> toddaaro: when I run with RUST_NEWRT=1 (which is not what the bot's doing) on your branch it does fail
[03:08:33] <brson> unimpl try unsafe borrow
[03:08:38] <brson> probably logging
[03:09:01] <brson> toddaaro: well, the bot's running valgrind
[03:09:03] <brson> and i'm not
[03:09:10] <brson> but it's not showing valgrind errors
[03:09:57] <toddaaro> ok, I'll try RUST_NEWRT=1
[03:10:03] <toddaaro> though actually, what does that do?
[03:10:24] <brson> toddaaro: it makes the test case run using the new scheduler
[03:10:31] <toddaaro> oh RUST_NEWRT
[03:10:32] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[03:10:32] <toddaaro> duh
[03:10:46] <toddaaro> I was thinking threads
[03:14:05] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[03:14:07] <steven_is_false> I have a method declared as fn send_and_recv<T: Send>(&self, f: ~fn() -> T) -> T which runs the passed in closure on another thread.
[03:14:54] <steven_is_false> Is it correct to have f be &fn() -> T) -> T?
[03:15:15] <toddaaro> brson: is RUST_NEWRT=1 expected to work? I thought your branch had some changes required to make that work
[03:15:24] <toddaaro> brson: or is there a particular test case you were trying
[03:15:31] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[03:17:13] <brson> steven_is_false: yes
[03:17:32] <steven_is_false> brson: Shouldn't it be something like &fn:Send() -> T?
[03:17:33] <brson> toddaaro: i expect it to work on master, yes
[03:18:15] <brson> steven_is_false: not currently, no. &fn will probably never be a sendable type, and closure environment bounds don't currently exist
[03:18:18] <brson> afaik
[03:18:31] <brson> toddaaro: the fix landed yesterday
[03:18:40] <engla> closure bounds exist
[03:19:41] <engla> rusti: let x = 10; let f: &fn:Send() -> int = || { x };
[03:19:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KHDD
[03:19:46] <strcat> brson: I think bblum got them working
[03:19:56] <engla> errors on not fulfilling Send
[03:20:05] <steven_is_false> I'll need unsafe code to pass the f into the other thread though right?
[03:20:29] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:20:34] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[03:21:11] <strcat> I think : Send is only going to be useful to you on ~fn
[03:21:12] <engla> the only lifetime that would be sendable is &'static I think and that precludes you from capturing anything (?)
[03:21:41] <brson> steven_is_false: if you want to use a stack closure, yes. and you'll need to make some sort of guarantee that the other task is done with it before you destroy the closure
[03:22:05] <steven_is_false> Okay. Strange, there is not a *fn type.
[03:22:07] <brson> e.g. fork/join patterns will likely do this
[03:22:57] <ChrisMorgan> In a `fn main()`, one would do something like `os::set_exit_status(1); return;` where a C program with `int main()` would do `return 1;`, right?
[03:23:01] <brson> *before you destroy the values captured in the environment
[03:23:04] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:23:24] <brson> ChrisMorgan: yes
[03:24:47] <steven_is_false> This is really yucky that I have to use a *util::Void type for this.
[03:25:15] <brson> steven_is_false: you can transmute the &fn to sys::Closure (or wherever it lives now)
[03:25:34] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[03:25:34] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148e9d1ae to 14ef87e2c: 02http://git.io/N3iJvQ
[03:25:34] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[03:25:35] <brson> that's probably the best way to unsafely move around a closure
[03:25:36] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[03:25:36] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/fs85Ig
[03:25:36] <ghrust> 13rust/06auto 145910834 15toddaaro: A major refactoring that changes the way the runtime uses TLS. In the...
[03:25:36] <ghrust> 13rust/06auto 14f1d909c 15Ben Blum: Have linked failure tests run on the new scheduler instead of requiring RUST_NEWRT to test.
[03:25:37] <ghrust> 13rust/06auto 1485d8552 15toddaaro: Fixed a race where a scheduler configured to only run tasks pinned to it would "bounch" a regular task in and out of the work queue without allowing a different scheduler to run it.
[03:25:39] <steven_is_false> brson: Okay.
[03:25:40] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[03:25:48] <engla> steven_is_false: `extern "Rust" fn` is the function type
[03:25:58] <brson> maybe there's some helper function we could provide for doing fork/join things
[03:26:10] <brson> on &fn:Send
[03:26:21] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[03:27:00] <steven_is_false> brson: I think some people have ideas about that.
[03:27:13] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[03:27:22] <brson> i'm sure
[03:29:03] <strcat> brson: it would be nice to define a new kind for that though
[03:29:19] <strcat> so we could allow using a subset of &mut T and &mut [T] where T is of that kind too
[03:29:34] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[03:30:50] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[03:32:10] <strcat> it's the same guarantee needed to respond NoAlias in LLVM's TBAA pass
[03:32:17] <strcat> well, almost
[03:32:33] <steven_is_false> Dang. Well I'll have to figure out something else.
[03:33:07] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[03:33:09] <strcat> NoAlias needs the guarantee of no possible memory dependencies between the types
[03:33:18] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[03:33:21] <strcat> fork-join needs either that *or* locking
[03:34:16] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[03:35:17] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[03:36:39] <ChrisMorgan> I had a recursive function which was passing `mut chariter: CharIterator` successfully with a Rust build from some days ago, a fresh one made 12 hours ago was complaining "cannot move out of captured outer variable". Replace the for loop it was in with a foreach loop and the problem is solved :-)
[03:38:12] <engla> chariter used to be implicitly copyable I think
[03:38:30] <engla> yes it was
[03:39:20] <strcat> 'for' will be gone very soon ;p
[03:39:37] <ChrisMorgan> Yay!
[03:40:25] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[03:40:33] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[03:41:17] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[03:48:32] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[03:49:32] <tikue> strcat: any idea what the timetable is for `for â€¦ in â€¦`?
[03:49:36] * ChrisMorgan wants char-style u8 literalsâ€”b'a' == 97u8â€”and str-style [u8] literalsâ€”b"abc" == [97u8, 98u8, 99u8]
[03:49:51] <strcat> tikue: well a basic implement of `foreach` landed
[03:50:08] <tikue> strcat: awww yeaaaa
[03:50:15] <enix> so, my pull request had failed tests. However, as best as I can tell, the tests that failed had nothing to do with my changes. What do I do next?
[03:50:15] <strcat> a snapshot is the next thing in the bors queue, and then we can migrate to it and then replace `for`
[03:50:27] <tikue> strcat: how's it work? `foreach â€¦ in vec.iter()` ?
[03:50:38] <tikue> strcat: or `foreach â€¦ in vec`?
[03:50:44] <ChrisMorgan> tikue: .iter()
[03:50:47] *** Quits: Eridius (kevin@moz-533B0DB4.us) (Ping timeout)
[03:50:49] <tikue> ChrisMorgan: thx :)
[03:50:58] <strcat> rusti: let xs = [1, 2, 3]; let ys = ["foo", "bar", "baz"]; foreach (x, y) in xs.iter().zip(ys.iter()) { printfln!("%? %?", x, y) }
[03:50:59] -rusti- &1 &"foo"
[03:50:59] -rusti- &2 &"bar"
[03:50:59] -rusti- &3 &"baz"
[03:50:59] -rusti- ()
[03:51:08] <ChrisMorgan> It must have a next() method that returns Option<T>
[03:51:21] <strcat> yeah but it should really be based on Iterator
[03:51:39] <strcat> it'll be tightened up + we can possibly get Iterable working with it
[03:51:59] <enix> i made changes to the Sha1 & 2 code in libextra; the tests that failed were run-pass/core-rt-smoke.rs and run-pass/rt-start-main-thread.rs which don't even use extra
[03:52:48] <ChrisMorgan> Let it work on both, the sugar calling .iter() first, and having Iterator have some form of `fn iter(self) -> Self { self }`. Not sure precisely what decoration you'd need or what nasty side-effects that'd have.
[03:53:02] <ChrisMorgan> s/decoration/sigils/
[03:53:17] <tikue> strcat: ChrisMorgan: is making it work with iterables still a ways off?
[03:53:32] <strcat> tikue: yes it's not currently possible to define Iterable and implement it for all the containers
[03:53:45] <strcat> the compiler chokes on the 'self usage it requires, and it's not clear that it's even something we can express atm.
[03:53:45] <tikue> strcat: gotcha, thank you
[03:53:51] <tikue> ahh ok
[03:54:01] <tikue> what about sugar like ChrisMorgan suggests?
[03:54:09] <tikue> or is that essentially the same thing
[03:54:21] <strcat> well the issue is that (self) isn't going to be the signature of Iterable
[03:54:32] <strcat> it will be (&self) -> T
[03:54:35] <engla> strcat: you can implement it using a different form, not sure if it's useful.    trait Iterable<T> { fn iter(self) -> T }     then the lifetime is in the impl instead
[03:55:15] <strcat> engla: it doesn't allow that
[03:55:17] <strcat> it has to match
[03:55:23] <strcat> like, for ~[T]
[03:55:26] <engla> it does allow it, I've tried
[03:55:34] <strcat> it works for &'self [T]
[03:55:35] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:55:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147f10f6e to 14ef87e2c: 02http://git.io/N3iJvQ
[03:55:35] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:55:36] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[03:55:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/P_CS-A
[03:55:36] <ghrust> 13rust/06auto 144700b00 15Graydon Hoare: register snapshots.
[03:55:36] <ghrust> 13rust/06auto 140c716c6 15bors: auto merge of #8177 : graydon/rust/2013-07-31-register-new-snapshots, r=thestinger...
[03:55:36] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[03:55:38] <engla> yeah
[03:55:47] <strcat> not ~[T], @[T], HashMap, etc.
[03:55:50] <tikue> rusti: let names = ["tikue", "brson", "strcat"]; foreach name in names.iter() { printfln!("hi, %s!", name); }
[03:55:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TGNT
[03:56:00] <engla> right, it works on &'self HashMap
[03:56:02] <engla> etc
[03:56:14] <tikue> rusti: let names = ["tikue", "brson", "strcat"]; foreach name in names.iter() { printfln!("hi, %s!", **name); }
[03:56:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OLTh
[03:56:21] <ChrisMorgan> rusti: let names = ["tikue", "brson", "strcat"]; foreach &name in names.iter() { printfln!("hi, %s!", name); }
[03:56:22] -rusti- hi, tikue!
[03:56:22] -rusti- hi, brson!
[03:56:22] -rusti- hi, strcat!
[03:56:22] -rusti- ()
[03:56:23] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:56:29] <strcat> engla: yeah you need &'self self but it isn't happy when you try doing it with the trait
[03:56:30] <tikue> thanks :D
[03:57:03] <ChrisMorgan> tikue: you need to either use `&name` at the foreach level, or `*name` at the printfln! level, as it wants a &str but you're giving it a &&str
[03:57:06] <engla> strcat: why does it need to be a by-ref self in the trait?
[03:57:23] <strcat> engla: because if you took by-value self you would move the ~[T] or HashMap into it
[03:57:25] <tikue> ChrisMorgan: yeah true. thanks
[03:57:27] <engla> I'm not sure what way is the best. If this test had worked better with the &mut capture I'd have presented it
[03:57:42] <engla> strcat: as I said, my intention was to impl it on &'self HashMap
[03:57:45] <engla> not on HashMap
[03:57:52] <strcat> oh
[03:58:49] <strcat> rusti: trait Foo { fn foo(self); } impl Foo<'self> for &'self int { fn foo(self) {} } 5i.foo()
[03:58:50] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[03:58:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NCDi
[03:58:53] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[03:59:04] <strcat> rusti: trait Foo { fn foo(self); } impl<'self> Foo for &'self int { fn foo(self) {} } 5i.foo()
[03:59:04] -rusti- ()
[03:59:15] <strcat> didn't realize that'd auto-borrow
[03:59:29] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[03:59:36] <strcat> guess it doesn't distinguish in the auto-deref -> auto-ref cycle
[03:59:45] <engla> well, it's bound to run into all of the annoying cases generics with &
[04:01:25] <strcat> yeah and the rough point is that it needs to work in 100% of the cases we currently use iter() for it to land :)
[04:01:42] <strcat> can probably get it working though
[04:01:47] <strcat> maybe a bug or two will be found
[04:06:46] <engla> can I push the for 5.times -> do 5.times  commit to the present PR for removal of oldstyle iter loops?
[04:06:58] <strcat> yeah
[04:07:13] <engla> cool
[04:07:24] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[04:08:22] *** Joins: Eridius (kevin@moz-533B0DB4.us)
[04:09:02] *** Joins: safekeeping (Mibbit@moz-4ACBD19B.hsd1.nj.comcast.net)
[04:10:12] <engla> https://github.com/mozilla/rust/pull/8159  one big commit for converting .times()
[04:10:35] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:12:05] *** Joins: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de)
[04:13:44] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:15:51] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[04:15:55] <tikue> strcat: do you think it'd be useful to have a find_map, similar to filter_map? returns the first instance that isn't None
[04:18:20] <tikue> it'd be the equivalent of making a filter_map iterator and then calling find_ on it
[04:19:50] <strcat> tikue: dunno
[04:19:55] <strcat> I don't think there would be many users
[04:20:03] <tikue> strcat: I'd use it ;D
[04:20:07] <tikue> use case:
[04:20:14] <tikue> searching a tree for a particular node
[04:21:01] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[04:21:18] <tikue> sorry
[04:21:23] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[04:21:26] <tikue> it'd be the equiv. of making a filter_map iterator and calling next()
[04:21:43] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[04:22:31] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[04:23:23] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[04:23:27] <engla> right
[04:25:30] *** Quits: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de) (Ping timeout)
[04:28:08] *** Quits: lmandel (lmandel@CD1A664D.7ECD71DF.ADB88A9.IP) (Quit: lmandel)
[04:29:42] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[04:30:11] <bjz> rusti: unsafe { let mut v: [int,..2] = std::unstable::intrinsics::uninit(); } v[0] = 1; v[1] = 3; v
[04:30:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iMLA
[04:30:21] *** Joins: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[04:30:40] <bjz> rusti: let mut v: [int,..2] = unsafe { std::unstable::intrinsics::uninit(); } v[0] = 1; v[1] = 3; v
[04:30:40] -rusti- <anon>:5:80: 5:81 error: expected `;` but found `v`
[04:30:41] -rusti- <anon>:5          let mut v: [int,..2] = unsafe { std::unstable::intrinsics::uninit(); } v[0] = 1; v[1] = 3; v
[04:30:41] -rusti-                                                                                          ^
[04:30:41] -rusti- application terminated with error code 101
[04:30:51] <bjz> rusti: let mut v: [int,..2] = unsafe { std::unstable::intrinsics::uninit() }; v[0] = 1; v[1] = 3; v
[04:30:53] -rusti- [1, 3]
[04:31:02] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[04:33:46] *** Quits: safekeeping (Mibbit@moz-4ACBD19B.hsd1.nj.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:34:08] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:34:15] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:37:21] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[04:37:57] <bjz> rusti: let mut v: [int,..2] = unsafe { std::unstable::intrinsics::uninit() }; v
[04:37:57] -rusti- <anon>:5:17: 5:18 warning: variable does not need to be mutable [-W unused-mut (default)]
[04:37:58] -rusti- <anon>:5          let mut v: [int,..2] = unsafe { std::unstable::intrinsics::uninit() }; v
[04:37:58] -rusti-                           ^
[04:37:58] -rusti- [0, 0]
[04:40:43] *** Joins: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com)
[04:42:33] *** Joins: vodik_ (simon@moz-CBE4BB13.cable.teksavvy.com)
[04:43:55] *** Joins: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de)
[04:44:11] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[04:45:03] *** Joins: evan (evan@moz-B2CBB8FC.static.snlo.ca.charter.com)
[04:46:12] *** Quits: jclements (jclements@moz-19C0E5F.ngn.east.myfairpoint.net) (Ping timeout)
[04:47:36] *** Joins: jclements (jclements@moz-F06F2C30.ngn.east.myfairpoint.net)
[04:50:49] *** Joins: ecr (Thunderbir@moz-B5DB8615.uoregon.edu)
[04:51:25] *** Quits: ecr (Thunderbir@moz-B5DB8615.uoregon.edu) (Quit: ecr)
[04:52:30] *** Joins: jaen (jaen@moz-31BCD66C.play-internet.pl)
[05:01:27] <acrichto> strcat: you should have rusti use #[allow(warnings)]
[05:01:55] <strcat> acrichto: I used to, but decided not to because warnings are a valid thing to demonstrate
[05:02:13] <acrichto> huh, oh well
[05:02:24] <strcat> there were a few times when I wanted to show things like...
[05:02:34] <strcat> rusti: let mut x = 5; x = 6; x
[05:02:37] -rusti- <anon>:5:17: 5:18 warning: value assigned to `x` is never read [-W dead-assignment (default)]
[05:02:37] -rusti- <anon>:5          let mut x = 5; x = 6; x
[05:02:37] -rusti-                           ^
[05:02:38] -rusti- 6
[05:02:47] <acrichto> ah I guess so yeah
[05:04:27] *** Quits: gavinb (gavinb@moz-CA19A0CF.vic.adsl.internode.on.net) (Ping timeout)
[05:05:07] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (No route to host)
[05:05:10] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[05:06:09] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[05:06:31] <pupoque> hi guys
[05:06:35] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[05:07:51] <pupoque> i compiled rust on mac but it launches with a malloc error http://pastebin.com/DDad03QF how can i improve that?
[05:08:11] *** Quits: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de) (Ping timeout)
[05:09:09] <strcat> pupoque: with which version of OS X?
[05:09:14] *** Quits: jclements (jclements@moz-F06F2C30.ngn.east.myfairpoint.net) (Ping timeout)
[05:09:17] <pupoque> 10.8.2
[05:10:25] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[05:10:39] *** Joins: jclements (jclements@moz-D70BF5C5.ptldme.east.myfairpoint.net)
[05:10:53] <strcat> acrichto: we can also use available_externally on non-generic inline functions
[05:11:10] <strcat> so if it does decide to not inline, it won't need duplicate copies
[05:11:49] <strcat> if we implement exporting instantiations of generics, it'd even work with inlined generic fns
[05:12:09] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[05:12:24] *** Quits: jclements (jclements@moz-D70BF5C5.ptldme.east.myfairpoint.net) (Ping timeout)
[05:12:48] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[05:13:47] <acrichto> strcat: yeah I can't quite figure out where to put it
[05:13:53] <acrichto> I tried to get it working but got linker errors on stage2
[05:14:28] *** Joins: jclements (jclements@moz-3B1A4026.ptldme.east.myfairpoint.net)
[05:14:51] <strcat> acrichto: well, it needs to mangle the symbols the same way
[05:15:21] <strcat> and I think the definition of globals is separate from the declaration
[05:15:23] <acrichto> i64* @"_ZN3num7strconv13DIGIT_I_RADIX17_c8381d2b5bd35ccd14_0$x2e8$x2dpreE"
[05:15:26] <acrichto> invalid linkage type for global declaration
[05:15:32] <Jeaye> rusti: let mut v = vec::from_elem(5, 0); v.clear(); v.capacity()
[05:15:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/icMe
[05:15:40] <strcat> acrichto: it needs to go on the value definition
[05:15:41] <acrichto> strcat: stuff like that, but it wasn't all globals I think? I was gonna look more into it later
[05:15:50] <Jeaye> rusti: let mut v = std::vec::from_elem(5, 0); v.clear(); v.capacity()
[05:15:51] -rusti- 5
[05:16:06] <Jeaye> So vec::clear will never shrink the capacity?
[05:16:06] <strcat> acrichto: and you need to make the declaration actually use the crate mangling of the source crate (I assume it doesn't)
[05:16:12] <strcat> Jeaye: no
[05:16:18] <Jeaye> good
[05:16:18] <strcat> that'd be shrink_to_fit, but it's not implemented atm
[05:16:39] <strcat> http://en.cppreference.com/w/cpp/container/vector/shrink_to_fit
[05:16:50] <Jeaye> strcat: Oh, I'm very familiar. :)
[05:17:01] <Jeaye> Just making sure Rust is doing it properly. 
[05:20:22] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[05:22:10] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[05:23:50] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:24:10] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[05:25:21] *** Joins: jclements_ (jclements@moz-8ABFD639.ngn.east.myfairpoint.net)
[05:25:23] *** Quits: jclements (jclements@moz-3B1A4026.ptldme.east.myfairpoint.net) (Ping timeout)
[05:25:23] *** jclements_ is now known as jclements
[05:26:42] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:27:56] *** Quits: jclements (jclements@moz-8ABFD639.ngn.east.myfairpoint.net) (Ping timeout)
[05:28:19] *** Joins: jclements (jclements@moz-18DD6BE0.ngn.east.myfairpoint.net)
[05:30:53] *** Quits: jclements (jclements@moz-18DD6BE0.ngn.east.myfairpoint.net) (Ping timeout)
[05:31:59] <Jeaye> How can I memcpy with raw pointers?
[05:32:31] *** Joins: jclements (jclements@moz-6FCCF6E7.ngn.east.myfairpoint.net)
[05:33:45] <nmatsakis> bstrie: pong
[05:34:50] <nmatsakis> bjz: extern fns are going prety well, except that this week I am focusing on PJS (along iwth pnkfelix) and thus haven't invested much energy
[05:34:50] <pupoque> when i try to compile a simple example i get "warning: no debug symbols in executable (-arch x86_64)". this message occured several time during the compiler compilation. can this be connected to http://pastebin.com/DDad03QF ?
[05:35:05] <nmatsakis> bjz: i am mildly blocked by some limitations in macros, 
[05:35:06] *** Quits: jclements (jclements@moz-6FCCF6E7.ngn.east.myfairpoint.net) (Ping timeout)
[05:35:06] <pupoque> mac, latest OSX
[05:35:55] <strcat> Jeaye: there's ptr::copy_memory/ptr::copy_nonoverlapping_memory
[05:36:02] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[05:36:40] <nmatsakis> bjz: what I did was to modify the setup not to use a big stack implicitly, and added a lint if you call a C fn without a big stack,
[05:36:43] *** Joins: jclements (jclements@moz-7716FD5F.ptldme.east.myfairpoint.net)
[05:36:49] <nmatsakis> bjz: naturally this led to a lot of errors,
[05:36:51] <strcat> nmatsakis: btw, I think the changes to TypeContents needed for easily identifying noalias parameters are the same as the fork-join requirements
[05:37:02] <strcat> both just require that there can be no memory dependencies with other types
[05:37:08] <nmatsakis> strcat: "the fork-join requirements"?
[05:37:11] <strcat> (but fork-join would also allow things like ARC)
[05:37:15] <Jeaye> strcat: Ah, perfect. Thanks!
[05:37:23] <nmatsakis> strcat: I'm not sure why that is required for fork-join
[05:37:37] <nmatsakis> strcat: oh, I guess you mena no write-depedence, duh
[05:37:41] <strcat> nmatsakis: yeah
[05:37:48] <bjz> nmatsakis: ok np
[05:37:54] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:37:57] <strcat> it seems like a nearly identical requirement, so any changes to TypeContents could probably support both
[05:37:58] <bjz> nmatsakis: good to hear it's progressing1
[05:38:01] <nmatsakis> bjz: so I wrote a macro for declaring extern fns with a wrapper that switches stack (more or less what we have)
[05:38:01] <bjz> *!
[05:38:28] <nmatsakis> bjz: but that macro needs a way to add custom annotations, and you can't specify annotations in a macro def'n it seems
[05:38:31] <nmatsakis> pauls: ping :)
[05:39:02] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[05:39:02] *** ChanServ sets mode: +o pcwalton
[05:39:03] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: .)
[05:39:14] <nmatsakis> strcat: that is...possible. Interesting thought. I do want to rewrite Typecontents, I find it has grown into something horrible...
[05:40:24] <strcat> LLVM's definition of NoAlias is basically that a write through one pointer cannot be observed through the other - and ignoring locks, that's essentially the definition needed for data parallelism afaict
[05:40:34] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:40:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/P_CS-A
[05:40:34] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:40:55] <shachaf> Hmm, in what cases are lifetimes uninferrable?
[05:41:16] <nmatsakis> strcat: right, seems reasonable
[05:42:23] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Ping timeout)
[05:43:32] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:43:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/vRY3EA
[05:43:32] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:43:34] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[05:43:34] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/sYh7Rw
[05:43:34] <ghrust> 13rust/06auto 146cff279 15Patrick Walton: librustc: Remove `pub extern` and `priv extern` from the language....
[05:43:34] <ghrust> 13rust/06auto 14a094788 15Patrick Walton: librustc: Introduce a new visitor type based on traits and port syntax to it....
[05:43:35] <ghrust> 13rust/06auto 14fe0f4c9 15bors: auto merge of #8163 : pcwalton/rust/new-visitor, r=graydon...
[05:43:37] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[05:43:42] <bjz> nmatsakis: yeah, or expand to multiple items :(
[05:43:43] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[05:44:00] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[05:44:06] <bjz> nmatsakis: see std::{f64, f32}
[05:44:11] <nmatsakis> bjz: yeah, I had planned to just use one macro instance per fn, it winds up looking like:
[05:44:28] <nmatsakis> bjz: externfn!(foo(v: *u8) -> uint)
[05:44:32] <mihneadb> hi. I did this -- [1, 2, 3].map(|&x| println(fmt!("%d", x))) -- in rusti, prints 1,2,3 and then it seems to hang
[05:44:36] <mihneadb> rusti: [1, 2, 3].map(|&x| println(fmt!("%d", x)))
[05:44:40] -rusti- 1
[05:44:40] -rusti- 2
[05:44:40] -rusti- 3
[05:44:40] -rusti- ~[(), (), ()]
[05:44:41] <Jeaye> let v = ~[1, 2]; v.to_ptr()
[05:44:42] <nmatsakis> bjz: but I guess the link args would become repetitive after a while ... hmm ...
[05:44:54] <nmatsakis> bjz: externfn!(foo(v: *u8) -> uint, #[link....])
[05:44:55] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[05:44:58] <Jeaye> rusti: let v = ~[1, 2]; v.to_ptr()
[05:44:58] -rusti- <anon>:5:26: 6:5 error: type `~[<VI1>]` does not implement any method in scope named `to_ptr`
[05:44:59] -rusti- <anon>:5          let v = ~[1, 2]; v.to_ptr()
[05:44:59] -rusti- <anon>:6     };
[05:44:59] -rusti- error: aborting due to previous error
[05:44:59] -rusti- application terminated with error code 101
[05:45:05] <bjz> nmatsakis: I would prefer extern_fn!
[05:45:17] <nmatsakis> bjz: ok :) that is easy to accommodate...
[05:45:32] <nmatsakis> bjz: I guess I could just have `extern_fns` that expands to a module
[05:45:36] <Jeaye> bjz: Jeeze, you don't need to yell.
[05:45:39] <Jeaye> :P
[05:45:43] <nmatsakis> bjz: to deal with generating many fns with the same link args
[05:45:57] <nmatsakis> jclements: ping
[05:46:10] <nmatsakis> no chance he's awake but hey... :)
[05:46:31] <Jeaye> rusti: let v = ~[1, 2]; std::vec::raw::to_ptr(v)
[05:46:31] -rusti- 140638840424720
[05:46:47] <bjz> nmatsakis: sometimes it's nice to have fn_macro!(fn blah() -> T) because it syntax highlights for you
[05:46:48] *** Quits: jclements (jclements@moz-7716FD5F.ptldme.east.myfairpoint.net) (Ping timeout)
[05:46:49] *** Joins: jclements (jclements@moz-7DF34595.ptldme.east.myfairpoint.net)
[05:47:07] <nmatsakis> bjz: yeah we could keep the `fn` in there
[05:47:15] <strcat> you can probably wreck havok on syntax highlighting with macros if it does try to highlight inside it ;p
[05:47:19] <bjz> jclements: nmatsakis pinged you :)
[05:47:37] <bjz> strcat: heh, yup
[05:47:55] <bjz> strcat: syntax highlighters should probably ignore inside macros
[05:47:56] <nmatsakis> strcat: so, rather than me trawling through github commit emails, I wanted to ask, are we using defualt methods in collections etc now?
[05:48:17] <strcat> nmatsakis: yeah, we're using quite a few now
[05:48:18] <bjz> <3 default methods
[05:48:22] <nmatsakis> bjz/strcat: I'm not sure if that's true, our macros are required to at least obey our lexer, so they could still do some limited highlighting
[05:48:25] <strcat> sully fixed essentially all the bugs I ran into :)
[05:48:32] <nmatsakis> nice
[05:48:40] <nmatsakis> what a swell guy
[05:48:48] <bjz> three cheers for sully!
[05:49:03] <bjz> horrah!
[05:49:07] <bjz> hoorah!
[05:49:08] <bjz> hoorah!
[05:49:11] <strcat> nmatsakis: iterator's size_hint and Container's is_empty are default methods now
[05:49:12] <bjz> x)
[05:49:16] <strcat> and some things like insert on Map
[05:49:24] <sully> hm, has anybody found any new default method bugs
[05:49:28] * nmatsakis is trying to catch up with the Rust things that have accumultaed in the 3 days he's not been paying attention.
[05:49:32] <strcat> sully: nope ;p
[05:49:38] <bjz> sully: no
[05:49:40] <brson> i think our snapshot compiler no longer contains debug! logs ...
[05:49:41] <sully> I have on remaining, which is like
[05:49:48] <brson> so that sucks
[05:49:49] <nmatsakis> brson: that makes me sad
[05:50:12] <brson> i have no idea what's going on!
[05:50:23] <sully> formating borrow check errors in a default method invovling self
[05:50:28] <strcat> brson: what, you're not a wizard? :(
[05:50:31] <sully> there is a flag now, for disabling all debug things
[05:50:35] <sully> it is on by default
[05:50:59] <strcat> I hope we don't disable LLVM assertions by default any time soon
[05:51:06] *** Quits: jaen (jaen@moz-31BCD66C.play-internet.pl) (Ping timeout)
[05:51:08] <brson> there's pretty much no way i can figure out the stage0 trans bug i'm hitting
[05:51:25] <nmatsakis> we should definitely build snapshots with --enable-debug
[05:51:30] <nmatsakis> it's hard enough to debug stage0 stuff
[05:51:44] <Jeaye> rusti: let v = ~[1, 2]; let mut p: *mut void = std::cast::transmute(std::vec::raw::to_ptr(v));
[05:51:44] -rusti- <anon>:5:42: 5:46 error: use of undeclared type name `void`
[05:51:44] -rusti- <anon>:5          let v = ~[1, 2]; let mut p: *mut void = std::cast::transmute(std::vec::raw::to_ptr(v));
[05:51:44] -rusti-                                                    ^~~~
[05:51:44] -rusti- error: aborting due to previous error
[05:51:45] -rusti- application terminated with error code 101
[05:51:52] <strcat> nmatsakis: and foreach just got snapshotted several minutes ago ;p
[05:51:54] <Jeaye> rusti: let v = ~[1, 2]; let mut p: *mut c_void = std::cast::transmute(std::vec::raw::to_ptr(v));
[05:51:55] -rusti- <anon>:5:42: 5:48 error: use of undeclared type name `c_void`
[05:51:55] -rusti- <anon>:5          let v = ~[1, 2]; let mut p: *mut c_void = std::cast::transmute(std::vec::raw::to_ptr(v));
[05:51:55] -rusti-                                                    ^~~~~~
[05:51:55] -rusti- error: aborting due to previous error
[05:51:55] -rusti- application terminated with error code 101
[05:52:00] <strcat> can replace for now...
[05:52:22] <nmatsakis> strcat: yeah that's very exciting, so the new syntax is `foreach <pat> in <expr>`?
[05:52:26] <strcat> yeah
[05:52:29] <bjz> nmatsakis: how far off is relaxed operator overloading?
[05:52:33] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[05:52:33] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fe0f4c9 to 140c716c6: 02http://git.io/N3iJvQ
[05:52:33] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:52:34] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[05:52:35] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/5_ogAA
[05:52:35] <ghrust> 13rust/06auto 144bad515 15Daniel Micay: rm ancient error for lowercase kinds...
[05:52:35] <ghrust> 13rust/06auto 14c47be69 15Daniel Micay: remove `copy` as a keyword
[05:52:35] <ghrust> 13rust/06auto 14dabd476 15Daniel Micay: make `in` and `foreach` get treated as keywords
[05:52:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[05:52:49] <strcat> rusti: let xs = [1, 2, 3]; foreach x in xs.iter() { printfln!("%?", x) }
[05:52:49] -rusti- &1
[05:52:50] -rusti- &2
[05:52:50] -rusti- &3
[05:52:50] -rusti- ()
[05:53:11] <strcat> rusti: let xs = [1, 2, 3]; foreach x in xs.iter().skip(1) { printfln!("%?", x) }
[05:53:12] -rusti- &2
[05:53:12] -rusti- &3
[05:53:12] -rusti- ()
[05:53:16] <nmatsakis> bjz: interesting question, I have been thinking about that, but I don't know the answer yet. I have a branch that is working on fixing up &Objcets and it is kind of blocked by needing to improve some stuff in that area, so I was wondering if I could tackle that too
[05:53:18] <shachaf> Wait, printfln!() is a thing?
[05:53:33] <shachaf> Looks like it is.
[05:53:44] <bjz> nmatsakis: yeah, I'm working on stuff that needs it right now ^_^
[05:53:52] <bjz> nmatsakis: was just curious
[05:53:58] <Jeaye> rusti: let v = ~[1, 2]; let mut p: *mut std::libc::c_void = std::cast::transmute(std::vec::raw::to_ptr(v));
[05:53:58] -rusti- <anon>:5:62: 5:109 error: call to unsafe function requires unsafe function or block
[05:53:59] -rusti- <anon>:5          let v = ~[1, 2]; let mut p: *mut std::libc::c_void = std::cast::transmute(std::vec::raw::to_ptr(v));
[05:53:59] -rusti-                                                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[05:53:59] -rusti- error: aborting due to previous error
[05:54:00] -rusti- application terminated with error code 101
[05:54:02] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[05:54:06] <nmatsakis> bjz: :( I am blocking you left and right
[05:54:15] <bjz> nmatsakis: haha! no worries
[05:54:38] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[05:54:42] <mihneadb> hi, anybody has a few minutes to help me over an "I don't know what I'm doing" rust moment? :)
[05:54:50] <strcat> mihneadb: sure
[05:54:53] <bjz> sure
[05:54:55] <bjz> any time
[05:55:02] <mihneadb> strcat: I m trying to follow the rust for rubyists ebook
[05:55:09] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[05:55:11] <strcat> rusti: pure pure pure pure
[05:55:13] <mihneadb> even though I m not a rubyist, lol
[05:55:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IhUa
[05:55:20] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[05:55:29] <mihneadb> I m not sure I understand what happens when you call map on a vec
[05:55:29] <strcat> rusti: pure static
[05:55:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AjFL
[05:55:31] <bjz> nmatsakis: yeah, with the extern fns, I need to redo the loader anyway
[05:55:39] <bjz> nmatsakis: with static muts
[05:55:47] <mihneadb> http://pastebin.mozilla.org/2756236 line 16, how should I do this?
[05:56:46] <strcat> mihneadb: you want to print them out?
[05:56:53] <mihneadb> strcat: yes
[05:57:10] <strcat> mihneadb: you probably just want to use a for loop, rather than map
[05:57:10] <mihneadb> strcat: I m more interested in figuring out the type of the thing that gets passed to the inline func
[05:57:19] *** Quits: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com) (Quit: WeeChat 0.3.8)
[05:57:43] <bjz> vec.map(|x| println(fmt!("%?", xattack())));
[05:58:16] <strcat> mihneadb: map is for transforming one vector to another so it expects a function taking a type T and returning a type U
[05:58:22] <bjz> mihneadb: strength is a field of the monkey, you can't access it via the Monkey trait
[05:58:23] <strcat> so it converts ~[T] to ~[U]
[05:58:39] <mihneadb> bjz: oh damn, I m stupid
[05:58:46] <bjz> no worries
[05:58:54] <strcat> oh an earlier error ;]
[05:58:54] <mihneadb> strcat: that makes sense as well
[05:58:55] <mihneadb> thanks
[05:59:01] <mihneadb> ok
[05:59:03] <mihneadb> so.. for loop
[05:59:25] <bjz> also, printfln!("..", ...) is the printf macro
[05:59:33] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[05:59:40] <mihneadb> strcat: I found multiple ways (i.e. vec.each, vec.iter().advance..). Which one *should* I use?
[05:59:49] <strcat> mihneadb: vec.iter()
[05:59:49] <bjz> so you don't need the combined println and fmt
[05:59:58] <mihneadb> bjz: thanks, didn't know about that
[06:00:02] <strcat> mihneadb: http://static.rust-lang.org/doc/tutorial-container.html#iterators there's a nice iterator tutorial now
[06:00:03] <bjz> mihneadb: it's in the process of changing
[06:00:10] <bjz> mihneadb: iterators
[06:00:18] <bjz> mihneadb: strcat knows all
[06:00:21] <bjz> :)
[06:00:22] <mihneadb> oh, that's 0.8
[06:00:25] <mihneadb> I m on 0.7 now
[06:00:33] <bjz> use git master
[06:00:46] <mihneadb> I should do that
[06:00:52] <mihneadb> is there any printf?
[06:00:59] <strcat> yeah, printf! and printfln!
[06:00:59] <bjz> the point releases are just snapshots, really
[06:01:07] <bjz> mihneadb: that's what I said before^
[06:01:09] <strcat> they might not be in 0.7
[06:01:09] <bjz> :P
[06:01:24] <shachaf> How new is this iteration protocol?
[06:01:41] <mihneadb> bjz: you said printfln, I was curious about printf. 
[06:01:46] <mihneadb> thanks :D
[06:01:50] <strcat> shachaf: I implemented it between 0.5 and 0.6
[06:01:52] <bjz> mihneadb: we have both ofc :)
[06:01:55] <strcat> it became the "standard" way with 0.7
[06:01:59] <shachaf> strcat: Oh.
[06:02:02] <strcat> and by 0.8 the old for loop will be gone
[06:02:04] <mihneadb> bjz: great
[06:02:09] <strcat> the new one just landed as 'foreach' and will be renamed to 'for'
[06:02:09] <bjz> strcat: yay!
[06:02:18] <shachaf> Ah, the old for loop was still using bool.
[06:02:22] <strcat> it's snapshotted now so the transition can begin
[06:02:26] <bjz> strcat: can we use foreach now?
[06:02:29] <strcat> bjz: yep
[06:02:32] <strcat> bjz: like this
[06:02:38] <mihneadb> bjz: it seems that the for loop does some magic. Where can I learn about it? The source code? There's only an example in the tutorial from what I remember
[06:03:05] <strcat> rusti: let xs = [1, 2, 3]; let ys = ~["foo", "bar", "baz"]; for (x, y) in xs.iter().zip(ys.consume_iter()) { printfln("%? %?", x, y) }
[06:03:06] -rusti- <anon>:5:66: 5:72 error: `for` must be followed by a block call
[06:03:06] -rusti- <anon>:5          let xs = [1, 2, 3]; let ys = ~["foo", "bar", "baz"]; for (x, y) in xs.iter().zip(ys.consume_iter()) { printfln("%? %?", x, y) }
[06:03:06] -rusti-                                                                            ^~~~~~
[06:03:06] -rusti- application terminated with error code 101
[06:03:12] <strcat> rusti: let xs = [1, 2, 3]; let ys = ~["foo", "bar", "baz"]; foreach (x, y) in xs.iter().zip(ys.consume_iter()) { printfln("%? %?", x, y) }
[06:03:12] -rusti- <anon>:5:115: 5:123 error: unresolved name `printfln`.
[06:03:12] -rusti- <anon>:5          let xs = [1, 2, 3]; let ys = ~["foo", "bar", "baz"]; foreach (x, y) in xs.iter().zip(ys.consume_iter()) { printfln("%? %?", x, y) }
[06:03:12] -rusti-                                                                                                                             ^~~~~~~~
[06:03:14] -rusti- error: aborting due to previous error
[06:03:15] * strcat sighs
[06:03:16] -rusti- application terminated with error code 101
[06:03:18] <strcat> rusti: let xs = [1, 2, 3]; let ys = ~["foo", "bar", "baz"]; foreach (x, y) in xs.iter().zip(ys.consume_iter()) { printfln!("%? %?", x, y) }
[06:03:19] -rusti- &1 "foo"
[06:03:19] -rusti- &2 "bar"
[06:03:21] -rusti- &3 "baz"
[06:03:23] -rusti- ()
[06:03:30] <bjz> mihneadb: strcat is the man to talk to
[06:03:40] <bjz> as I say, we're in transition
[06:03:41] <strcat> bjz: it's a bit weird because it doesn't enforce that you pass an Iterator yet
[06:03:45] <bjz> ok
[06:03:57] <strcat> it's implemented entirely as an AST transformation
[06:04:51] <bjz> strcat: is tere a range iterator?
[06:04:55] <bjz> *there
[06:04:56] <strcat> bjz: not yet
[06:04:58] <strcat> there's Counter
[06:05:07] <strcat> Counter + take_while is an inconvenient range ;p
[06:05:40] <strcat> rusti: foreach x in std::iterator::Counter::new(0, 5).take_while(|&x| x < 100) { println(x.to_str()) }
[06:05:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SCNW
[06:06:09] <strcat> should just rename that constructor to count() and add a range() one
[06:06:25] <strcat> + maybe throw them in prelude
[06:06:46] <mihneadb> strcat: so how would I do "for (i = 0; i < N; ++i)" ?
[06:06:52] <mihneadb> the idiomatic way
[06:07:08] <strcat> mihneadb: well, once it's implemented range(0, N)
[06:07:13] <strcat> atm there isn't really an idiomatic way
[06:07:18] <mihneadb> ok
[06:07:28] <strcat> rusti: foreach x in std::iterator::Counter::new(0, 1).take_while(|&x| x < 4) { println(x.to_str()) }
[06:07:28] -rusti- 0
[06:07:28] -rusti- 1
[06:07:29] -rusti- 2
[06:07:29] -rusti- 3
[06:07:29] -rusti- ()
[06:07:38] *** Parts: evan (evan@moz-B2CBB8FC.static.snlo.ca.charter.com) (Leaving)
[06:08:03] <mihneadb> ok
[06:08:12] <mihneadb> so foreach x in ... { something }
[06:08:16] <strcat> yeah
[06:08:22] <mihneadb> is that a macro
[06:08:26] *** Quits: heftig (heftig@8DB4145A.5C7D981D.FEC4A986.IP) (Ping timeout)
[06:08:26] <mihneadb> i mean foreach
[06:08:30] <mihneadb> or is it deeper in the language
[06:08:52] *** Joins: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP)
[06:08:52] <strcat> mihneadb: it's a language feature, but it's not actually implemented any deeper than a macro would be
[06:08:59] <mihneadb> aha, ok
[06:09:38] <mihneadb> strcat: so I have a question (one more, surprise!). if I do [T].map(|x| ...)
[06:09:42] <mihneadb> is the type of x T ?
[06:09:52] <strcat> probably &T
[06:09:58] <shachaf> Isn't T a value there?
[06:10:01] <mihneadb> probably?
[06:10:06] * strcat looks
[06:10:11] <Eridius> &T
[06:10:13] <Eridius> map doesn't consume
[06:10:19] <strcat> it's deprecated though
[06:10:24] <mihneadb> ok
[06:10:27] <Eridius> [T].consume_iter().transform(|x| ...) will have x be T
[06:10:27] <mihneadb> then
[06:10:43] <Eridius> well it won't work with [T], it'll need a ~[T]
[06:10:48] <mihneadb> foreach x in [1, 2, 3] {x ...}
[06:10:51] <Eridius> since [T] gets borrowed to &[T] and you can't consume that
[06:10:52] <mihneadb> is x int?
[06:11:04] <strcat> mihneadb: well, vectors have different iterators
[06:11:08] <strcat> if you use .iter(), you get &int
[06:11:12] <mihneadb> Eridius: what's the best place to read on this? the manual?
[06:11:12] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[06:11:19] <strcat> mihneadb: the iterator tutorial
[06:11:27] <mihneadb> strcat: thanks
[06:11:29] <strcat> mihneadb: http://static.rust-lang.org/doc/tutorial-container.html#iterators
[06:11:43] <strcat> not very complete yet
[06:11:49] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Input/output error)
[06:11:52] <strcat> has more breadth than depth :)
[06:11:55] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[06:12:06] <mihneadb> ok
[06:12:17] <strcat> for loop section needs to updated to foreach
[06:12:25] <strcat> and then back to for when the old for loop is gone ;p
[06:12:34] <mihneadb> I guess the confusing thing for me is that I m used to sequence functions keeping the type of the elements in the sequence
[06:12:51] <mihneadb> and it seems to me that some convert to &T and some just keep T?!
[06:13:20] <strcat> mihneadb: they can't keep T
[06:13:41] <mihneadb> strcat: because you don't want to fill the stack
[06:13:45] <strcat> they take a reference (&T) and if they hand you T they did a copy from the reference
[06:13:47] <mihneadb> ?
[06:14:02] <strcat> mihneadb: no, because they would need to do a copy to turn &T into T
[06:14:22] <strcat> some types aren't copyable
[06:14:28] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:14:29] <mihneadb> it's not clear to me why they take &T. since the vector contains Ts
[06:14:37] <strcat> mihneadb: &T is a reference to a T
[06:15:03] <strcat> the vector contains T, the iterator is yielding references to the elements in the array
[06:15:03] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[06:15:04] <mihneadb> yeah
[06:15:10] <mihneadb> right
[06:15:15] <mihneadb> so it's because the iterator protocol
[06:15:26] <bjz> mihneadb: say you had a vector of bigints - you wouldn't want to copy them
[06:15:27] <strcat> well the iteration protocol doesn't specify types
[06:15:44] <mihneadb> bjz: I m thinking more like C
[06:15:51] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[06:15:54] <mihneadb> if I had that, I'd want to have a vector of pointers to bigints
[06:16:08] <mihneadb> but I would be the one controlling that
[06:16:11] <strcat> they do need to be stored somewhere
[06:16:14] <mihneadb> I m sure I m missing something :)
[06:16:24] <mihneadb> strcat: in C you'd do malloc
[06:16:41] <strcat> mihneadb: so now the dynamic memory has an *owner*, the place responsible for freeing it
[06:16:52] <strcat> and since rust is memory safe, ownership semantics have to be enforced
[06:16:55] <bjz> mihneadb: in rust you'd do ~
[06:17:08] <strcat> mihneadb: so if you have a generic type T, you own it
[06:17:15] <strcat> &T is a non-owning view of it (a reference)
[06:17:37] <mihneadb> ok
[06:17:39] <strcat> if you return something by-value, you are handing over ownership of it - if you didn't do a copy, you not longer have it
[06:17:44] <strcat> no longer*
[06:18:23] <strcat> rusti: let x = 5 /* x owns 5 */; let y = x /* integers are implicitly copyable, y owns another 5 */; y
[06:18:23] -rusti- 5
[06:18:37] <bjz> mihneadb: Rust seperates out the concepts that are conflated in C
[06:18:56] <strcat> rusti: let x = ~5 /* x owns this allocated memory */; let y = x /* y now owns it - x moved ownership */; y
[06:18:57] -rusti- ~5
[06:19:03] <strcat> rusti: let x = ~5 /* x owns this allocated memory */; let y = x /* y now owns it - x moved ownership */; (x, y)
[06:19:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LehI
[06:19:14] <strcat> <anon>:5:108: 5:109 error: use of moved value: `x`
[06:19:19] <strcat> <anon>:5:60: 5:61 note: `x` moved here because it has type `~int`, which is moved by default (use `ref` to override)
[06:19:20] <mihneadb> bjz: I will read the long explanation in the manual, the short one in the tutorial didn't make everything clear to me. 
[06:19:49] *** Joins: jdm (jdm@moz-DB7C6581.dsl.teksavvy.com)
[06:19:51] <strcat> ~int is dynamically allocated memory, so the owner is responsible for calling the destructor
[06:19:59] <bjz> mihneadb: and so provides semantic information to the compiler so that it can enforce safety and insert the mallocs and frees for you
[06:20:00] <mihneadb> strcat: so if you don't "own" it, you cannot even read it?
[06:20:01] <strcat> and without an explicit copy, anything by-value moves ownership of the memory
[06:20:06] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[06:20:17] <strcat> mihneadb: you can read it, if you have a reference to it
[06:20:22] <strcat> mihneadb: x gave up ownership there
[06:20:25] <strcat> it doesn't know when it will be freed
[06:20:41] <strcat> it could be passed to a function and freed, you just can't use a variable you've moved *from*
[06:20:41] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[06:20:56] <mihneadb> but can't you use lexical scoping for that particular case?
[06:21:05] <strcat> so essentially
[06:21:07] <strcat> let x = ~5
[06:21:16] <strcat> calls malloc(), assigns to x, initializes
[06:21:23] <strcat> let y = x
[06:21:35] <strcat> assigns x to y, sets x to null, makes x unusable
[06:21:40] <strcat> if you did...
[06:21:45] <strcat> let y = &*x;
[06:21:49] <strcat> you would now have an &int
[06:21:55] <strcat> you can still use x, you didn't move ownership from it
[06:22:05] <brson> hm, I haven't ported the the borrowck debugging stuff to newsched. darn
[06:22:11] <strcat> the int itself is implicitly copyable so you could copy it out of x
[06:22:38] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[06:23:18] <mihneadb> strcat: so now y is a reference to the 5 in (~5), correct?
[06:23:30] <strcat> mihneadb: yes
[06:23:42] <strcat> and now rust enforces that the &int must be outlived by x
[06:24:15] <strcat> &/&mut are a pointer used to reference something they don't own
[06:24:18] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:24:23] <mihneadb> strcat: but..
[06:24:27] <mihneadb> say you had
[06:24:29] <mihneadb> let mut x = ~5
[06:24:43] <mihneadb> let mut y = &*x
[06:24:51] <strcat> so x is ~int, y is &int
[06:24:55] <mihneadb> you *can* do *y = 6, right>?
[06:25:20] <strcat> you could do 'let y = *x' and it'd copy the integer out, because int is implicitly copyable
[06:25:28] <strcat> and y would just be int, and x would still be usable
[06:25:38] <mihneadb> right
[06:25:44] <mihneadb> I guess my question is
[06:25:54] <mihneadb> if you have a reference to something that is mutable
[06:25:59] <mihneadb> that you do not own
[06:26:06] <mihneadb> can you mutate that value?
[06:26:15] <strcat> mihneadb: only through the reference
[06:26:23] <brson> removing the C++ runtime:  56 files changed, 194 insertions(+), 6548 deletions(-)
[06:26:40] <mihneadb> strcat: let me try through rusti
[06:27:03] <mihneadb> rusti: let mut x = ~5; let y = &*x; y; *y = 6; x
[06:27:05] <strcat> brson: :D
[06:27:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HEGB
[06:27:30] <strcat> mihneadb: you'll need &mut *x
[06:27:38] <mihneadb> oh wow
[06:27:39] <mihneadb> right
[06:27:44] <mihneadb> rusti: let mut x = ~5; let y = &mut *x; y; *y = 6; x
[06:27:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PYDM
[06:27:48] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[06:28:09] <strcat> oh it's just mad about the 'y;'
[06:28:18] <mihneadb> but why
[06:28:26] <strcat> rusti: let mut x = ~5; let y = &mut *x; *y = 6; x
[06:28:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SOUU
[06:28:52] <brson> after deleting the c++ runtime there's ~3300 lines of 1st-party c++ code left
[06:28:56] <strcat> well, that's just because y is still in scope
[06:29:08] <strcat> rusti: let mut x = ~5; { let y = &mut *x; *y = 6; } x
[06:29:08] -rusti- ~6
[06:29:13] <brson> but it's almost all trivially portable
[06:29:22] <strcat> mihneadb: while you have an &mut, it becomes the only way to reference that value
[06:29:32] <strcat> mihneadb: & are allowed to alias each other, and still let you use the value
[06:29:34] <mihneadb> strcat: why? doesn't x keep ownership?
[06:29:48] <strcat> mihneadb: yes, but while you've borrowed an &mut, the &mut is the only usable handle
[06:29:55] <mihneadb> oh
[06:30:09] <strcat> the 'only one mutable reference' rule prevents memory unsafety from stuff like iterator invalidation
[06:30:23] <mihneadb> for some reason I thought you could still have read access
[06:30:25] <mihneadb> but you are right
[06:30:29] <mihneadb> you could segfault that way
[06:30:29] <mihneadb> I see
[06:30:51] <strcat> mihneadb: there's actually &const, which is allowed to alias with &mut, but it hasn't really found any real use cases
[06:30:53] <strcat> may end up removed
[06:31:13] <strcat> rusti: let mut x = 5; let y = &const x; let _z = &mut x; *y
[06:31:14] -rusti- 5
[06:31:19] <strcat> rusti: let mut x = 5; let y = &x; let _z = &mut x; *y
[06:31:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dXCM
[06:31:39] <strcat> &const just doesn't allow you to take a reference deeper inside itself
[06:31:49] *** Quits: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com) (Ping timeout)
[06:31:59] <mihneadb> wait
[06:32:02] <mihneadb> inside what
[06:32:07] <strcat> like
[06:32:10] <strcat> you can do
[06:32:14] <strcat> let y = &x;
[06:32:20] <strcat> let z = &y.foo;
[06:32:26] <strcat> but you can't do it with &const
[06:32:41] *** Joins: jaen (jaen@moz-E8D76C54.neoplus.adsl.tpnet.pl)
[06:32:52] <strcat> anyway should probably ignore &const because it's close to useless ;p
[06:33:08] <mihneadb> oh
[06:33:18] <mihneadb> ok, I see
[06:33:21] <mihneadb> but yeah
[06:33:26] <mihneadb> I'd say it's too much
[06:33:54] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[06:34:06] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[06:34:27] *** Quits: etw (john@moz-D871A25B.nyc.res.rr.com) (Ping timeout)
[06:34:47] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[06:34:48] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[06:34:49] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[06:35:17] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:36:02] <mihneadb> strcat: where can I find more details on ~ vs @?
[06:36:13] <mihneadb> http://static.rust-lang.org/doc/rust.html#memory-boxes just says that you can have multiple @ point at the same thing
[06:36:13] <strcat> mostly in the main tutorial
[06:36:34] *** Joins: sebcrozet (sebcrozet@moz-D8879CC3.w80-13.abo.wanadoo.fr)
[06:36:38] <strcat> mihneadb: ~ is malloc/free and @ is garbage collection
[06:37:02] <mihneadb> ok, that's what I thought
[06:37:04] <strcat> mihneadb: http://pcwalton.github.io/blog/2013/03/18/an-overview-of-memory-management-in-rust/ maybe
[06:37:17] <mihneadb> but I remember reading that you were considering taking away gc and making it just a lib, right?
[06:37:35] <mihneadb> strcat: great, thanks, will read
[06:39:47] <strcat> bjz: going to try killing off 99% of the for loops with sed ;p
[06:39:59] <bjz> :D
[06:40:12] <bjz> mihneadb: hopefully
[06:40:36] <bjz> mihneadb: there will be lang items to help sugar it
[06:40:54] <mihneadb> basically my question is.. if gc becomes external, what happens to @
[06:41:01] <strcat> mihneadb: it could become Gc<T>
[06:41:08] <mihneadb> ok
[06:41:10] <strcat> we already have an Rc<T> type for reference counting in the library
[06:41:14] <bjz> yeah
[06:41:30] <bjz> it's a pain to use though, without lang items
[06:42:07] <jensnockert> bjz: Isn't what we would actually want is some sort of property? So that Rc<T> always implements all stuff of T?
[06:42:22] <bjz> it requires you access the data through closures, because it needs some way to enforce safety
[06:42:28] <strcat> Rc doesn't
[06:42:30] <strcat> RcMut does
[06:42:32] <bjz> ohh
[06:42:34] <bjz> ok
[06:42:37] <strcat> Rc works like this
[06:42:38] <bjz> my mistake
[06:43:01] <mihneadb> so.. if you can't have globals, where's @ used? for sharing stuff between tasks?
[06:43:02] <strcat> rusti: let x = Rc::from_const(5); let y: &int = x.borrow();
[06:43:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LCBa
[06:43:04] <strcat> er
[06:43:10] <bjz> jensnockert: properties would be nice
[06:43:13] <strcat> mihneadb: @ is task-local
[06:43:27] <jensnockert> mihneadb: Mostly when you want to throw around stuff and not care about it.
[06:43:50] <strcat> mihneadb: most of the time memory is sent between tasks, rather than shared
[06:43:52] <jensnockert> I mostly use it because I have been told that ~Trait is broken.
[06:44:34] <mihneadb> jensnockert: can't you throw stuff around with ~?
[06:44:48] <jensnockert> mihneadb: Yeah, but then you can only have one owner.
[06:45:00] <mihneadb> since you are task local
[06:45:08] <jensnockert> mihneadb: With @ you can have many owners and don't really have to care about borrowing.
[06:45:08] <mihneadb> only one function needs to be owner, doesn't it?
[06:45:27] <mihneadb> jensnockert: can you please give an example of where you need many owners in the same task?
[06:45:28] <strcat> jensnockert: with @mut you end up actually having to care though ;p
[06:45:49] <strcat> mihneadb: the owner is the slot containing the value
[06:46:04] <strcat> when the owner goes out of scope, it's freed - unless you move ownership elsewhere
[06:46:12] <strcat> you rarely do need @ if you design with ownership in mind
[06:46:25] <strcat> you can write any program without it
[06:47:12] *** Quits: tautologico (lymph@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[06:47:20] <strcat> just not always easy to both avoid expensive copies *and* @
[06:47:34] <jensnockert> mihneadb: Disregard the fact that the API is shitty, https://github.com/jensnockert/aurora.rs/blob/master/src/transforms/transform.rs, for example, the library hands out @TransformStream that are 'owned' by both the client and the library. So the client can shuffle in data into one end, and the library process it on the other.
[06:48:20] <strcat> jensnockert: that'd be a place where you'd likely use Rc in the future though
[06:48:29] <jensnockert> strcat: Yes.
[06:48:34] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[06:48:35] <strcat> just such a pain atm
[06:48:38] <strcat> :]
[06:48:38] <jensnockert> strcat: Isn't Rc essentially replacing @?
[06:48:52] <jensnockert> All uses of @ should be able to be replaced with Rc, right?
[06:48:57] <strcat> jensnockert: most
[06:49:05] <jensnockert> strcat: Which couldn't?
[06:49:13] <strcat> sometimes you want cycles, or you can't prove to Rc that you don't have cycles
[06:49:18] *** Joins: webber46 (webber46@moz-717E9C5B.cust.bredband2.com)
[06:49:30] <strcat> and occasionally, gc is going to have better throughput than refcounting
[06:49:32] <jensnockert> strcat: @ doesn't handle cycles either though?
[06:49:38] <strcat> jensnockert: it will, when it has a gc
[06:49:45] <strcat> it doesn't *forbid* types with possible cycles though
[06:49:46] <jensnockert> strcat: Yeahâ€¦ but right now.
[06:49:48] <strcat> Rc does
[06:50:08] <strcat> rusti: use extra::rc::Rc; let x = Rc::from_const(5); x
[06:50:09] -rusti- {ptr: (0x7fe6a0200900 as *())}
[06:50:14] <strcat> rusti: use extra::rc::Rc; let x = Rc::from_const(5); *x.borrow()
[06:50:14] -rusti- 5
[06:50:21] <strcat> rusti: use extra::rc::Rc; let x = Rc::from_owned(5); *x.borrow()
[06:50:21] -rusti- 5
[06:50:28] <strcat> (should be from_send and from_freeze now ;p)
[06:51:05] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[06:51:12] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[06:51:46] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[06:53:19] <jensnockert> strcat: I haven't followed the discussion, but is Rc<T> getting sugar so it works essentially like @T?
[06:53:25] <strcat> jensnockert: yes
[06:53:29] <jensnockert> \o/
[06:53:31] <strcat> RcMut won't
[06:53:41] <jensnockert> I can understand why RcMut isn't.
[06:53:45] <strcat> the @mut sugar will probably die, maybe @mut itself will go away
[06:53:55] <strcat> and be replaced by using Cell
[06:53:57] * strcat shrugs
[06:54:05] <jensnockert> What's Cell?
[06:54:35] <strcat> jensnockert: a mutable field basically, it implements the dynamic borrow failure pattern
[06:54:47] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[06:55:03] <strcat> it's a non-Freeze type with mutability when it's not owned by something mutable
[06:55:27] <jensnockert> Ok, seems smart.
[06:55:39] <strcat> it's more restricted than @mut/RcMut but...
[06:55:51] <strcat> it could replace most use cases
[06:56:16] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[06:56:16] <jensnockert> I'll probably shift all my stuff that requires @mut into a separate task, and then just pass around channels instead.
[06:56:20] <jensnockert> Needs moar tasks.
[06:56:24] <jensnockert> Always needs moar tasks.
[06:56:28] <jensnockert> And less locks.
[06:56:50] <strcat> jensnockert: maybe you could just tag them #[non_send] ?
[06:57:04] <jensnockert> strcat: ?
[06:57:10] * strcat doesn't know exactly what it's for ;p
[06:57:38] <jensnockert> No, the only time I needed @mut is in that Trait.
[06:57:45] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[06:58:01] <jensnockert> And I can just move the object into it's own Task.
[06:58:12] <jensnockert> And let a small shim implement the Trait.
[06:58:25] <jensnockert> Which just serializes commands/data and shuffles it over a channel.
[06:58:31] <jensnockert> (If that makes sense)
[06:59:47] <mihneadb> jensnockert: strcat: thanks a lot for the examples & explaining
[06:59:54] <strcat> np
[07:01:40] *** Quits: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net) (Quit: KVIrc 4.0.4 Insomnia http://www.kvirc.net/)
[07:03:13] <jensnockert> mihneadb: You're welcome.
[07:03:35] <mihneadb> ok.. building rust HEAD on a macbook air
[07:03:37] <mihneadb> this is going to be fun
[07:07:49] <strcat> sed 's/for \(.*\).advance() |\(.*\)|/foreach \2 in \1/'
[07:07:54] * strcat crosses fingers
[07:08:03] * jensnockert hugs mihneadb, I feel your pain.
[07:08:20] <jensnockert> My 4 year old MBP is probably as slow :(
[07:09:03] <geomyidae> Do rust binaries work on #b2g? and is anyone /ever/ in there?
[07:09:32] <strcat> wow
[07:09:37] <strcat> I wonder if this will actually work
[07:09:42] <strcat> so far so good
[07:10:21] <Luqman> geomyidae: to an extent
[07:10:27] <Luqman> i tried it a few months ago
[07:10:49] <geomyidae> Luqman: heh, would I be able to run ChrisMorgan's http server on it?
[07:11:26] <Luqman> haha don't know how well that'd work since it uses the new runtime afaik
[07:11:31] <strcat> dammit sed
[07:11:34] <strcat> why'd you touch all the files
[07:11:35] *** Joins: wilsonk-laptop (kvirc@moz-8E86F35A.cg.shawcable.net)
[07:11:37] * strcat sighs
[07:12:21] <geomyidae> Luqman: hm, any idea how Go would stand up? My understanding is that it should compile for Android. The normal issue is UI, but I don't need UI for want I'm thinking of.
[07:12:47] <strcat> it touched *everything* ;[
[07:12:59] <Luqman> geomyidae: i've never tried to get go on android, so no idea
[07:13:14] <geomyidae> Luqman: but assuming it worked on my sgs4 it would work in b2g?
[07:13:26] <mihneadb> :)
[07:13:28] <geomyidae> or compiled for the appropriate arm level, etc?
[07:13:57] <geomyidae> anyway enough of that, thanks for entertaining me.
[07:15:42] <Luqman> geomyidae: best way to find out is to just give it a try
[07:17:26] <mihneadb> strcat: is there a shorter way to access stdin other than std::io::stdin?
[07:17:41] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[07:17:46] <strcat> mihneadb: dunno
[07:17:54] <strcat> all the I/O stuff is about to be replaced though
[07:18:13] <mihneadb> but in general
[07:18:15] <mihneadb> since it is
[07:18:21] <mihneadb> use std::io::stuff..
[07:18:35] <mihneadb> is there no use <something> as <x> ?
[07:18:41] <strcat> use x = y;
[07:18:51] <mihneadb> ah, cool
[07:18:52] <mihneadb> ty
[07:18:57] <strcat> don't know how well it works though
[07:18:57] <geomyidae> Luqman: unfortunately I don't own any devices that b2g is ported to, and the only one currently available has to be my daily driver and it's cdma soooo...
[07:19:15] <geomyidae> Luqman: I'm more curious about spitballing some b2g ideas but it seems barron over there often
[07:19:39] <strcat> mihneadb: but for example you can 'use std::io;' and then refer to 'io::foo'
[07:20:10] <mark_edward> we should make 100% Rust OS 
[07:20:16] <mihneadb> strcat: ok, perfect. ty
[07:20:47] <mihneadb> hm, didn't samsung put some engineers into servo?
[07:20:49] <Luqman> geomyidae: well, if you're curious enough you can fire up the qemu image :P
[07:20:57] <mihneadb> I guess that means rust works on arm
[07:21:11] <strcat> mihneadb: yeah it works on arm, including android
[07:21:28] <Luqman> more like, mostly android right now
[07:21:32] <strcat> ;]
[07:21:43] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[07:21:46] <strcat> it works on vanilla linux too though, doesn't it?
[07:22:12] <strcat> maybe not if we aren't testing it ;p
[07:22:16] <strcat> it probably broke
[07:22:34] <Luqman> strcat: yep, arm-unknown-linux-gnueabihf
[07:23:07] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[07:23:19] <Luqman> though, given that we use the mcr instruction to set/get the tls stuff i'm pretty sure it's only >=armv6
[07:23:27] <mihneadb> is there any rust package repo? I remember there being a json back when cargo was a thing
[07:23:45] <klutzy> the arm-unknown-linux-gnueabihf target is for raspberry pi, but afaik it does not support "./configure" cross-compilation
[07:24:30] <klutzy> the patch author actually did rustc --emit-llvm and linked by hands
[07:24:47] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[07:24:52] <Luqman> klutzy: odd, it should
[07:25:13] <Luqman> though you might need to pass --linker=arm-linux-gnueabihf-gcc to rustc
[07:27:24] <klutzy> Luqman: I think patch author used this script https://gist.github.com/crabtw/5150198
[07:28:07] <klutzy> actually, rustc tries to find android ndk if target is "arm"
[07:28:54] <Luqman> klutzy: no, it also makes sure the target is android afaik
[07:29:34] <Luqman> and yea, looking at that script --linker=arm-linux-gnueabihf-gcc plus perhaps some -Z linker-args would work
[07:29:56] <dbaupp> strcat: are you removing .advance now?
[07:30:02] <strcat> dbaupp: well, migrating to foreach
[07:30:10] <dbaupp> strcat: right
[07:30:19] * dbaupp stops doing it too
[07:30:21] <klutzy> Luqman: https://github.com/mozilla/rust/blob/d75ab4a5d798164c37e04a0794f2e28acdb76dd4/src/librustc/driver/driver.rs#L333
[07:30:21] <strcat> also can rename Clone/DeepClone to Copy/DeepCopy when my PR that's pending atm lands
[07:30:27] <strcat> dbaupp: you should do Copy/DeepCopy ;p
[07:30:38] <strcat> oh wait
[07:30:40] <strcat> we need a snapshot
[07:30:43] <strcat> :(
[07:30:46] * strcat sighs
[07:30:53] <strcat> dbaupp: I'm just using sed anyway
[07:30:56] <Luqman> klutzy: oh right, i had planned to change that :P
[07:31:23] <dbaupp> strcat: yeah, I was too, currently up to rustc complaining about mutability in std
[07:31:41] <dbaupp> strcat: (but since you're doing it, I'll stop fighting it.)
[07:32:18] <strcat> libstd is annoying because Iterator wasn't in scope anywhere
[07:32:36] <dbaupp> yeah, I know :(
[07:33:42] <strcat> [retreat a784444] migrate many `for` loops to `foreach`
[07:33:45] <strcat>  254 files changed, 1261 insertions(+), 1261 deletions(-)
[07:33:47] <strcat> :S
[07:34:03] * strcat thinks the branch name is clever
[07:34:03] <klutzy> Luqman: is it easy to fix? I didn't read code so had no idea to recognize arm-not-android
[07:34:11] <klutzy> at the time
[07:34:48] <Luqman> klutzy: yea, just make it targ_cfg.os == Android or something similar
[07:35:44] <strcat> dbaupp: and I didn't handle type annotations in my crappy regexp
[07:36:18] <dbaupp> strcat: yup, `found : but expecting in` whingewhingewhinge
[07:36:24] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[07:36:52] <strcat> rt/uv/net.rs:779:24: 784:21 error: unresolved enum variant, struct or const
[07:36:55] <strcat> ;\
[07:37:22] <dbaupp> it should definitely use `::std::option::Some(...)`
[07:37:35] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:37:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/5_ogAA
[07:37:36] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:38:00] <strcat> dbaupp: won't work in std itself though
[07:38:18] <dbaupp> strcat: yeah, it does because of the sneaky `mod std` in std.rs
[07:38:21] <dbaupp> strcat: in any case: https://github.com/mozilla/rust/issues/6449
[07:38:23] <strcat> oh
[07:38:34] *** Quits: Klaufir_ (admin@94E7A28F.E28D9BD4.349F3CD5.IP) (Ping timeout)
[07:38:47] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[07:38:50] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[07:39:18] <dbaupp> (it's a hack, we need something like `#[std_mod=""]` (defaulting to `std`) to make #[deriving] work without being such a huge hack.)
[07:40:25] *** Joins: Klaufir_ (admin@94E7A28F.E28D9BD4.349F3CD5.IP)
[07:40:35] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[07:40:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/YWeZsQ
[07:40:35] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[07:40:36] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[07:40:36] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/HSyp0g
[07:40:36] <ghrust> 13rust/06auto 146a69d27 15OGINO Masanori: Remove unused variables....
[07:40:36] <ghrust> 13rust/06auto 141b018dd 15bors: auto merge of #8149 : omasanori/rust/cleanup, r=alexcrichton...
[07:40:37] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[07:40:47] <strcat> wooo
[07:41:49] <strcat> oh and all the unused imports
[07:41:52] <strcat> hurray
[07:45:57] <strcat> dbaupp: I hope this speeds up compiles a little ;]
[07:46:25] <dbaupp> strcat: hopefully, and hopefully it'll make the binaries/IR smaller too
[07:46:51] <strcat> well there is room for improvement in the vec iterator anyway
[07:47:58] <strcat> dbaupp: what did you do with the unreachable pattern ones? :|
[07:48:20] <dbaupp> strcat: which ones?
[07:48:26] <strcat> either.rs:50:16: 50:19 error: unreachable pattern
[07:48:29] <strcat> either.rs:50         foreach elt in eithers.iter() {
[07:48:31] <strcat>                              ^~~
[07:48:48] <dbaupp> oh, eurgh.
[07:49:05] <dbaupp> that sounds like it doesn't make sense?
[07:49:07] <strcat> I think it means None isn't in scope
[07:49:16] <strcat> lets see
[07:49:19] <dbaupp> right, yeah
[07:49:36] * dbaupp wished we had Haskell's enforced-conventions sometimes
[07:49:46] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[07:49:46] <strcat> at least on variables
[07:51:15] <shachaf> enforced-conventions?
[07:52:03] <strcat> ugh the mutability ones are annoying
[07:52:05] <strcat> they need derefs
[07:52:21] <strcat> since it always borrows &mut
[07:52:32] <strcat> no auto-deref ;p
[07:52:34] <dbaupp> shachaf: TypeConstructors variblesFooBar
[07:52:52] <shachaf> Oh, that.
[07:53:33] <dbaupp> shachaf: because something like match foo { SomeEnumVariant => ..., OtherVariant => ... } gives a very strange error message if SomeEnumVariant isn't in scope
[07:53:58] <dbaupp> "unreachable pattern", because it just becomes a generic variable that matches everything.
[07:54:12] <shachaf> Right. Relying on scope for that is pretty strange.
[07:56:34] <shachaf> Hmm, I wonder how far you could get with lenses/prisms/etc. in Rust.
[07:57:21] *** Quits: ab (alex@BC9D99CC.37C1012D.FE617B51.IP) (Ping timeout)
[07:58:00] <mark_edward> shachaf: what is a lens/prism
[07:59:27] <dbaupp> mark_edward: http://www.haskellforall.com/2012/01/haskell-for-mainstream-programmers_28.html
[08:00:10] <dbaupp> mark_edward: specifically "Haskell's Lens type generalizes properties (i.e. accessors/mutators) found in other programming languages"
[08:00:11] <shachaf> A lens is a getter/setter pair. E.g. for struct Foo { x: int, y: char }, you could have x: Lens<Foo,int> which consists of a getter and setter for x.
[08:00:32] <shachaf> Hmm, I vaguely remember not liking that page but I don't remember why.
[08:00:39] *** Joins: ab (alex@BC9D99CC.37C1012D.FE617B51.IP)
[08:01:12] * dbaupp just found it on google, and thought the first sentence was a good summary
[08:01:21] <shachaf> Anyway a prism is the dual of a lens, for an enum. You have enum Foo { A { ... }, B { ... } }, and you can have a prism for matching on A and constructing a Foo out of the contents of A.
[08:01:42] <sammykim> When I make check for rust, it produce error in compiletest time at compiletest.rs. Are there any good ways to debug it? I changed some codes to fix #8047 in "std::option", "rustc/middle/trans/_match" which has dependency with option::mutate. 
[08:01:50] <strcat> pfft, lenses are really just an excuse to make 1000 incomprehensible operator overloads
[08:02:11] <shachaf> The nice thing about lenses etc. is that they're composable -- if you have Lens<Foo,Bar> and Lens<Bar,Vaz> you can make Lens<Foo,Vaz>.
[08:02:37] <dbaupp> sammykim: what's the error output?
[08:02:40] <shachaf> But I have the feeling the whole thing would be very different in a world with mutability. In fact we still haven't figured out how to make nice lensy things for mutable variables in Haskell lens.
[08:03:12] <sammykim> This is last some logs : /home/sammykim/rust-new/myrust-0731/src/compiletest/compiletest.rs:14: NOTE: remove after snapshot make: *** [tidy] Error 123
[08:03:28] <shachaf> Anyway there are a lot of nice generalizations of lenses -- like traversals, lenses onto more than one value, so you can say things like "world.monsters.each.appendages.each.x += 1" or what not. lvalues that refer to 0-or-more things.
[08:03:32] <shachaf> I think I'm being off-topic.
[08:03:51] <strcat> dbaupp: yay libstd done
[08:03:54] <strcat> ;p
[08:03:56] <sammykim> To build rust is OK but when I make check it . it makes error :(
[08:03:58] *** Joins: fabiand (fabiand@moz-B0C111AA.adsl.alicedsl.de)
[08:04:08] <dbaupp> sammykim: run `make tidy`
[08:04:25] <dbaupp> sammykim: (there'll be a line that is too long, or has trailing whitespace, or something like that.)
[08:04:52] <dbaupp> shachaf: those generalisations sound cool
[08:05:20] *** Joins: sastry (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP)
[08:05:33] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[08:05:34] <dbaupp> shachaf: (I assume that they would be possible in Rust... maybe in a kinda ugly way though.)
[08:05:38] *** Parts: xenocons (otk@moz-C675529E.members.linode.com) ()
[08:06:03] <dbaupp> strcat: awesome
[08:06:11] <strcat> rusti: let mut xs = [0u, ..10]; foreach (i, x) in xs.mut_iter().skip(3).enumerate() { *x = i } xs
[08:06:12] -rusti- [0, 0, 0, 0, 1, 2, 3, 4, 5, 6]
[08:06:14] * strcat is happy advance can go
[08:06:30] <shachaf> Well, you have not just mutability but all sorts of other things you don't worry about in Haskell. I don't know if it's possible to make it nice but if it is it'd certainly come out different.
[08:06:34] *** Quits: sastry (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP) (Quit: CGI:IRC)
[08:07:10] <dbaupp> strcat: I saw a few uses of `x.advance(f) && y.advance(g)`
[08:07:19] <strcat> that's okay, not removing advance
[08:07:22] <sammykim> dbaupp: What does "make tidy" do? I ran "make tidy" . But I can see same error. 
[08:07:24] *** Joins: sastry (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP)
[08:07:28] <strcat> just 99% of the users
[08:07:40] <strcat> libextra done
[08:07:43] <strcat> libsyntax!
[08:07:46] <sammykim> dbaupp: but I think I found why it has error. :) thx dbaupp . the comment is too long :)
[08:08:26] <dbaupp> strcat: yup, cool; I guessed you were just doing the for -> foreach change
[08:08:56] <sastry> Hey I wanna contribute to the rust project, but the thing is that where I come from bandwidth is really expensive. Now everytime I wanna make check, it downloads a snap shot. Now given that am a beginner I would be working on a single .rs file.
[08:09:22] <sastry> Is there a way I could just compile this single file along with its test cases and run em ? to see if it works fine ?
[08:09:32] *** Joins: Ms2ger (Ms2ger@moz-BA3429A8.adsl-dyn.isp.belgacom.be)
[08:09:44] <strcat> it only downloads a snapshot when there was a new one
[08:09:55] *** Joins: dim-an (ermolovd@moz-74FA7782.yandex.net)
[08:10:21] <sastry> Ohh I see :)
[08:10:37] <sammykim> sastry : I think you can use your best friend computer through ssh :)
[08:10:51] <strcat> libsyntax done
[08:10:54] <strcat> librustc!
[08:10:58] <strcat> middle/ty.rs:962:18: 962:19 error: expected `in`, found `|`
[08:11:00] <sammykim> sastry : how do you think about it ? just borrow his line ;)
[08:11:01] <strcat> middle/ty.rs:962         foreach tt| { f  in substs.tps.iter()= get(*tt).flags; }
[08:11:01] *** Quits: DeokjinKim (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:11:03] <strcat> huh.
[08:11:21] <strcat> waaat
[08:11:34] <sastry> Lol .. no even his bandwidth is expensive lol :P
[08:11:50] <dbaupp> strcat: that looks awesome
[08:11:58] <strcat> what did it do ;p
[08:12:15] <dbaupp> strcat: `for substs.tps.iter().advance |tt| { f |= get(*tt).flags; }`
[08:12:20] <dbaupp> strcat: greedy regexs <3
[08:12:22] <strcat> -        for substs.tps.iter().advance |tt| { f |= get(*tt).flags; }
[08:12:25] <strcat> +        foreach tt| { f  in substs.tps.iter()= get(*tt).flags; }
[08:12:27] <sammykim> sastry : make korean freiends ;) they usually use unlimited line.
[08:12:28] * strcat sighs
[08:12:41] <strcat> dbaupp: yep I always, always forget
[08:12:43] <strcat> dammit ;p
[08:13:04] * dbaupp used `|\([^|]*\)|` for his sed invocation
[08:13:32] <strcat> (.*?) is non-greedy
[08:13:41] <mihneadb> strcat: how do I have to do this? http://pastebin.mozilla.org/2756886
[08:13:47] <strcat> I just didn't remember ;p
[08:13:58] <sastry> Lol I will keep that in mind @sammykim. hey how do I compile a single file instead of the whole code base ?  I mean suppose I made a very minor local change.
[08:14:30] <dbaupp> rusti: use std::rand::*; rng().gen_int_range(0, 10)
[08:14:31] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[08:14:31] -rusti- 0
[08:14:33] <dbaupp> rusti: use std::rand::*; rng().gen_int_range(0, 10)
[08:14:34] -rusti- 0
[08:14:52] <strcat> rusti: use std::rand::*; rng().gen_int_range(0, 10)
[08:14:52] -rusti- 6
[08:15:02] <dbaupp> rusti: use std::rand::*; std::vec::from_fn(10, |_| rng().gen_int_range(0, 10))
[08:15:03] -rusti- ~[6, 2, 4, 4, 1, 2, 9, 0, 9, 4]
[08:15:10] * strcat can remove rusti's entropy
[08:15:10] *** Parts: dim-an (ermolovd@moz-74FA7782.yandex.net) ()
[08:15:12] <dbaupp> rusti: use std::rand::*; std::vec::from_fn(10, |_| task_rng().gen_int_range(0, 10))
[08:15:14] -rusti- ~[2, 7, 0, 5, 1, 2, 1, 8, 2, 1]
[08:15:16] <strcat> rusti: lobotomy time
[08:15:17] -rusti- <anon>:5:18: 5:22 error: expected `;` or `}` after expression but found `time`
[08:15:17] -rusti- <anon>:5          lobotomy time
[08:15:17] -rusti-                            ^~~~
[08:15:17] -rusti- application terminated with error code 101
[08:15:42] <dbaupp> mihneadb: rng() is very expensive operation, btw; you probably want `task_rng()`
[08:15:49] <mihneadb> dbaupp: strcat - I did try this first .. http://pastebin.mozilla.org/2756898
[08:16:02] <strcat> rusti: use std::rand::*; rng().gen_int_range(0, 10)
[08:16:02] -rusti- error opening /dev/urandom: Operation not permittedAborted
[08:16:02] -rusti- application terminated with error code 134
[08:16:03] <mihneadb> but how do I make it behave like RngUtil?
[08:16:04] <strcat> er
[08:16:12] <mihneadb> dbaupp: ok, thanks
[08:16:15] <strcat> rusti: use std::rand::*; rng().gen_int_range(0, 10)
[08:16:15] -rusti- error opening /dev/urandom: Operation not permittedAborted
[08:16:15] -rusti- application terminated with error code 134
[08:16:18] <dbaupp> mihneadb: what was the error message?
[08:16:31] <mihneadb> rand.rs:6:20: 6:43 error: type `std::rand::IsaacRng` does not implement any method in scope named `gen_int_ra
[08:16:32] <dbaupp> strcat: symlink it to /dev/zero
[08:16:34] <mihneadb> dbaupp: ^
[08:16:37] <strcat> dbaupp: I did
[08:16:49] <strcat> rusti: use std::rand::*; rng().gen_int_range(0, 10)
[08:16:49] -rusti- error opening /dev/urandom: Operation not permittedAborted
[08:16:50] -rusti- application terminated with error code 134
[08:16:52] <dbaupp> mihneadb: well, the method is misspelt there
[08:17:10] <strcat> dbaupp: oh
[08:17:14] <strcat> I don't have /dev/zero whitelisted
[08:17:16] <strcat> as a device
[08:17:18] <mihneadb> heh
[08:17:21] <strcat> like, the device node type
[08:17:21] <dbaupp> rusti: use std::rand::RngUtil; rng().gen_int_range(0, 10)
[08:17:21] -rusti- error opening /dev/urandom: Operation not permittedAborted
[08:17:22] -rusti- application terminated with error code 134
[08:17:38] <strcat> rusti: use std::rand::RngUtil; rng().gen_int_range(0, 10)
[08:17:39] -rusti- <anon>:5:33: 5:36 error: unresolved name `rng`.
[08:17:39] -rusti- <anon>:5          use std::rand::RngUtil; rng().gen_int_range(0, 10)
[08:17:39] -rusti-                                           ^~~
[08:17:39] -rusti- error: aborting due to previous error
[08:17:39] -rusti- application terminated with error code 101
[08:17:48] * strcat forgot about that
[08:17:48] <mihneadb> dbaupp: nice, thanks. now I get rand.rs:6:20: 6:23 error: cannot borrow immutable local variable as mutable
[08:17:54] <dbaupp> strcat: don't whitelist it! it's a *huge* security hole... :P
[08:17:59] <strcat> dbaupp: exactly
[08:18:10] <mark_edward> does Rust have TCO?
[08:18:12] *** Quits: jdm (jdm@moz-DB7C6581.dsl.teksavvy.com) (Quit: Lost terminal)
[08:18:15] <dbaupp> mihneadb: right, yeah, the rng needs to be mutable (since it modifies state)
[08:18:21] <dbaupp> mark_edward: not really
[08:18:27] <strcat> LLVM can do TCO
[08:18:33] * dbaupp digs up the mailing list thread
[08:18:49] <strcat> LLVM does sibling call optimization, rust has that
[08:18:50] <mark_edward> dbaupp: are there any Recursive algorithms that can't be converted to loops?
[08:18:55] <dbaupp> mark_edward: https://mail.mozilla.org/pipermail/rust-dev/2013-April/003557.html
[08:18:59] <strcat> mark_edward: yes
[08:19:07] <mark_edward> strcat: what;s sibling call optimization?
[08:19:09] <strcat> mark_edward: non-sibling calls do not have guaranteed TCO
[08:19:12] <strcat> sibling call == same signature
[08:19:16] <mihneadb> dbaupp: hm..
[08:19:18] <mark_edward> ah i see
[08:19:21] <dbaupp> mark_edward: computing the ackermann function
[08:19:22] <strcat> mutual recursion isn't necessarily optimized
[08:19:27] <strcat> you have to pass -tailcallopt for that
[08:19:31] <strcat> and it slows down all calls
[08:19:34] <dbaupp> mibi.e. `let mut rng = ...;`
[08:19:40] <mihneadb> dbaupp: I understand that
[08:19:42] <mihneadb> but
[08:19:43] <mark_edward> also, do you have examples algorithms that can't be made non-recursive?
[08:20:08] <mihneadb> dbaupp: that's some internal state about which I as an API user I don't know about
[08:20:11] <dbaupp> mark_edward: that doesn't make sense, since recursion and looping are equivalent
[08:20:16] <shachaf> What, Rust doesn't do TCO? :-(
[08:20:43] <dbaupp> mark_edward: (so what I said about ackermann function is wrong: you just have to create your own stack to simulate the recursion)
[08:20:50] <mark_edward> dbaupp: what do you mean? and if so, why ever recurse? isn't looping pretty always at least as performant if not more than loping?
[08:20:56] <dbaupp> shachaf: doesn't garauntee it
[08:21:07] <dbaupp> mihneadb: right
[08:21:09] <mihneadb> dbaupp: I guess the explanation is that behind it's just a struct and the fields inside inherit the immutability?
[08:21:11] <mark_edward> *recursion
[08:21:33] <mihneadb> dbaupp: but then, can't you change rng()'s return type to force mut?
[08:21:33] <dbaupp> mark_edward: because some algorithms are much cleaner with recursion? because recursion doesn't require mutable state?
[08:21:57] <mark_edward> dbaupp: i guess... it makes it harder to follow for me...
[08:22:00] <dbaupp> mihneadb: not really
[08:22:15] <mihneadb> mark_edward: have some LISP. recursion will be ok after that
[08:22:17] <mark_edward> dbaupp: especially anything more complex than tree traversals
[08:22:38] <dbaupp> mihneadb: (and that would be too restrictive: sometimes you might want to place an rng into another struct, which isn't necessarily mutable, etc, etc.)
[08:22:42] <mark_edward> mihneadb: i was introduced programming in a scheme dialect. i get it. just dont lie it
[08:22:44] <mark_edward> *like
[08:22:57] <mihneadb> dbaupp: can I use an immutable rng?
[08:23:12] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:23:12] <mihneadb> mark_edward: ok then :) I thought you said it was hard to follow
[08:23:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[08:23:38] <mark_edward> mihneadb: harder than imperative style, but not incomprehensible
[08:23:40] <dbaupp> mark_edward: personally, I find recursion fine to reason about (especially for certain things.)
[08:24:06] <dbaupp> (although I come from a maths background where induction/recursion is second-nature.)
[08:24:29] <dbaupp> mihneadb: not for anything useful, but it can get frozen/unfrozen like normal values.
[08:24:49] <mihneadb> dbaupp: so then.. why not force mut?
[08:25:08] <dbaupp> mihneadb: and I don't see any reason to break this rule, since the error message is "perfectly clear", after you see it a few times.
[08:25:12] *** Joins: slaren (slaren@moz-E221166D.red-81-35-253.dynamicip.rima-tde.net)
[08:25:17] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:25:31] <dbaupp> mihneadb: because it would be too restrictive, and "break" the type system
[08:25:40] <mihneadb> hm, ok
[08:25:58] <dbaupp> mihneadb: (well, special-case the type system)
[08:26:20] <dbaupp> and it would make it very confusing in generics
[08:26:36] <dbaupp> (or at least, in consistent.)
[08:26:38] <mihneadb> dbaupp: so.. the error is not obvious to me. when it says it tries to borrow the immutable local var as mutable, does it refer to &self being requested as mutable in the gen_int_range method?
[08:26:59] *** Quits: dormiens (dormiens@2F2DB458.B767B9B7.2675F9C0.IP) (Ping timeout)
[08:26:59] <dbaupp> mihneadb: yeah, gen_int_range takes &mut self
[08:27:09] <mihneadb> dbaupp: I thought you could specify that you want to return something mutable. Nvm then
[08:27:15] <mihneadb> dbaupp: ok, makes sense
[08:27:16] <mihneadb> thanks
[08:27:24] <strcat> dbaupp: librustc done
[08:27:25] <dbaupp> mihneadb: you can, via &'a mut x, or @mut x
[08:27:27] <strcat> :D
[08:27:32] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[08:27:35] <dbaupp> mihneadb: (but that's not appropriate for a rng.)
[08:27:41] <strcat> and by done I mean I compiled lib{std,extra,syntax,rustc} manually with rustc --test ;p
[08:27:45] <mihneadb> right
[08:27:46] <strcat> I hate those test errors at the end
[08:27:52] <strcat> so... that's what I do now
[08:28:03] <dbaupp> strcat: yeah, those are the worst.
[08:28:29] * dbaupp is exaggerating slightly
[08:28:36] <strcat> dbaupp: heh I missed the not(test) ones though
[08:28:39] <strcat> :)
[08:28:48] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[08:29:47] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Connection reset by peer)
[08:30:39] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[08:30:53] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[08:33:52] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[08:36:43] <strcat> dbaupp: needs a rebase already too
[08:36:46] <strcat> ;p
[08:40:29] <dbaupp> rusti: struct Foo; impl Foo { fn next(&self) -> Option<int> { Some(1) } } foreach i in Foo { break }
[08:40:30] -rusti- <anon>:5:89: 5:92 error: cannot borrow immutable static item as mutable
[08:40:30] -rusti- <anon>:5          struct Foo; impl Foo { fn next(&self) -> Option<int> { Some(1) } } foreach i in Foo { break }
[08:40:30] -rusti-                                                                                                   ^~~
[08:40:30] -rusti- error: aborting due to previous error
[08:40:31] -rusti- application terminated with error code 101
[08:40:42] <dbaupp> rusti: struct Foo; impl Foo { fn next(&mut self) -> Option<int> { Some(1) } } foreach i in Foo { break }
[08:40:42] -rusti- <anon>:5:93: 5:96 error: cannot borrow immutable static item as mutable
[08:40:42] -rusti- <anon>:5          struct Foo; impl Foo { fn next(&mut self) -> Option<int> { Some(1) } } foreach i in Foo { break }
[08:40:43] -rusti-                                                                                                       ^~~
[08:40:43] -rusti- error: aborting due to previous error
[08:40:43] -rusti- application terminated with error code 101
[08:40:55] <dbaupp> rusti: struct Foo; impl Foo { fn next(&mut self) -> Option<int> { Some(1) } } let mut f = Foo; foreach i in f { break }
[08:40:56] -rusti- <anon>:5:105: 5:106 warning: unused variable: `i` [-W unused-variable (default)]
[08:40:56] -rusti- <anon>:5          struct Foo; impl Foo { fn next(&mut self) -> Option<int> { Some(1) } } let mut f = Foo; foreach i in f { break }
[08:40:56] -rusti-                                                                                                                   ^
[08:40:56] -rusti- ()
[08:41:38] <dbaupp> strcat: now all we need is to remove the duck-typing, and implement Iterable
[08:41:48] <strcat> yep
[08:41:57] <strcat> src/librustc/middle/liveness.rs:1464: leftover conflict marker
[08:41:59] <strcat> yay pre-commit hook
[08:42:34] <ChrisMorgan> Am I right in believing that there is no way at present to make a macro available in more than one file?
[08:42:35] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[08:42:46] <dbaupp> ChrisMorgan: no
[08:42:52] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[08:43:10] <dbaupp> rusti: #[macro_escape] mod foo { macro_rules! bar( () => { 1 } ) } bar!()
[08:43:11] -rusti- 1
[08:43:20] <dbaupp> rusti: mod foo { macro_rules! bar( () => { 1 } ) } bar!()
[08:43:21] -rusti- <anon>:5:53: 5:56 error: macro undefined: 'bar'
[08:43:21] -rusti- <anon>:5          mod foo { macro_rules! bar( () => { 1 } ) } bar!()
[08:43:21] -rusti-                                                               ^~~
[08:43:21] -rusti- application terminated with error code 101
[08:43:51] <dbaupp> rusti: mod foo { #[macro_escape]; macro_rules! bar( () => { 1 } ) } bar!()
[08:43:52] -rusti- 1
[08:44:13] <dbaupp> strcat: https://github.com/mozilla/rust/pull/8184 r?
[08:44:17] *** Quits: jclements (jclements@moz-7DF34595.ptldme.east.myfairpoint.net) (Ping timeout)
[08:44:24] <dbaupp> (well, do you want an r?)
[08:44:55] <ChrisMorgan> Good, that gets it working. I had been trying include!, but that didn't work out.
[08:45:00] *** Joins: jclements (jclements@moz-82B0DFD.man.east.myfairpoint.net)
[08:45:05] <strcat> dbaupp: not done
[08:45:11] <dbaupp> strcat: ok
[08:45:23] <strcat> getting there
[08:46:31] *** Quits: recrack (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:47:06] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[08:47:38] <strcat> % git grep '\.advance' | wc -l
[08:47:41] <strcat> 68
[08:47:43] <strcat> missed some like this anyway
[08:47:45] <strcat> not a big deal
[08:48:44] <strcat> dbaupp: can you make a lint warning to find for loops?
[08:48:51] <strcat> hm
[08:49:21] <dbaupp> strcat: should be possible
[08:52:11] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[08:52:42] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: Leaving.)
[08:52:58] *** Quits: sastry (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP) (Quit: CGI:IRC (Ping timeout))
[08:53:08] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[08:56:16] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:57:47] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[08:58:56] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:59:02] <doomlord> is there a way to make %? dump the types as well as data
[08:59:07] <strcat> no
[08:59:09] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: Leaving.)
[09:00:14] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:00:42] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[09:00:45] <mark_edward> is there a way in rust to get the typename of an obejct?
[09:00:51] <mark_edward> like as a string or something?
[09:01:35] <ChrisMorgan> mark_edward: when dealing with a trait object, I presume?
[09:01:56] <mark_edward> ChrisMorgan: anything really
[09:02:19] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[09:03:15] <mark_edward> ChrisMorgan: analogous to Java obj.class.getName()
[09:03:21] <ChrisMorgan> Why would you want to?
[09:04:10] <dbaupp> strcat: https://github.com/mozilla/rust/pull/8186 r?
[09:04:14] <dbaupp> aatch: ^
[09:05:31] <strcat> dbaupp: dunno if it's a good idea
[09:05:58] <dbaupp> strcat: hashmaps are require the runtime without it, which is annoying.
[09:06:08] *** Quits: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com) (Ping timeout)
[09:06:10] <dbaupp> strcat: I could make it `unsafe`?
[09:06:17] <strcat> yeah but we can't actually not use the runtime + use the stdlib atm
[09:06:52] <dbaupp> aatch was complaining about it a little while ago
[09:07:08] * dbaupp was just implementing his implicit feature request
[09:08:14] * strcat shrugs
[09:08:33] <ChrisMorgan> dbaupp: you've left line 67 there...
[09:08:39] <strcat> I think only one should be exposed, depending on whether the rt is enabled
[09:09:04] <dbaupp> ChrisMorgan: whoops, thanks.
[09:09:26] <dbaupp> strcat: i.e. either `new` or `with_keys`?
[09:09:32] <strcat> yeah
[09:09:33] <strcat> like
[09:09:36] <strcat> if you disable the rt
[09:09:43] <strcat> you shouldn't be able to call things that are going to crash
[09:09:45] <strcat> or not work correctly
[09:09:54] <strcat> we should implement it properly
[09:10:00] <strcat> so that's what I don't feel right about it.
[09:10:15] * ChrisMorgan looks at that PR and doesn't see what's changed, except that you now have to use HashMap::* instead of linear_map_*
[09:10:33] <strcat> not really because I think exposing that is wrong but because I think using the stdlib without the runtime as-is is the wrong approach
[09:10:36] <ChrisMorgan> Sorry, finally I see :-/
[09:10:50] <dbaupp> strcat: yes, new would disappear without the runtime; that's pretty obvious.
[09:11:09] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[09:12:00] *** Joins: sigma-pc (sigma@moz-BE11A887.range109-151.btcentralplus.com)
[09:12:18] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[09:13:00] <dbaupp> in any case, I've removed that orphaned doc comment; should I leave the pr open, or not bother?
[09:13:11] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:13:28] <cde> dbaupp: wait until someone observes you. then collapse your state
[09:18:08] <strcat> dbaupp: https://github.com/mozilla/rust/pull/8184 r?
[09:18:33] <strcat> not entirely done but..
[09:18:41] <strcat> well it's at benchmarks now ;p
[09:18:41] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:19:26] <Seldaek> the rust indentation standard is 4 spaces right?
[09:19:45] <dbaupp> strcat: 'not entirely done' == you're still running tests, or there's more things to add?
[09:19:48] <dbaupp> Seldaek: yes
[09:19:54] <strcat> dbaupp: not done tests
[09:19:59] <strcat> well now it's done
[09:20:01] <strcat> it's on pretty.
[09:20:49] <strcat> some arch-specific thing will probably fail ;p
[09:20:51] <strcat> ohj
[09:20:53] <strcat> hm
[09:21:04] <ChrisMorgan> Is foreach faster than old-for?
[09:21:17] <dbaupp> acrichto: ping
[09:21:24] <strcat> ChrisMorgan: yes
[09:21:32] <Seldaek> dbaupp: thanks, updating wiki then
[09:21:36] <strcat> faster to compile and less opaque to LLVM
[09:21:49] <strcat> although in 99% of cases it shouldn't make a difference at runtime
[09:22:11] <strcat> it will just compile a bit faster, look saner and most importantly *will not have the restrictions of a closure in the body*
[09:22:40] <dbaupp> ChrisMorgan: also, it's less sensitive to the #[inline]'ing that the programmer/LLVM does
[09:23:08] <ChrisMorgan> It's the restrictions part that I'm most please about.
[09:24:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[09:24:44] <strcat> dbaupp: passed tests
[09:24:46] <strcat> ;]
[09:24:58] <strcat> now go bors
[09:25:09] <dbaupp> strcat: and bors just passed, so it'll merge in 2 hours or so
[09:25:25] <strcat> well, assuming windows or OS X doesn't have an arch-specific error
[09:25:26] <dbaupp> (assuming windows does stays sane.)
[09:25:30] <dbaupp> haha, yep
[09:25:32] <strcat> anyway this just zaps 95%
[09:25:34] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[09:25:40] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[09:25:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HSyp0g
[09:25:40] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[09:25:41] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:25:44] <strcat> dbaupp: at least windows goes fast because it hardly tests anything
[09:26:21] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[09:27:44] <ChrisMorgan> What sort of percentage speedup do you get for compiling Rust?
[09:28:03] <Seldaek> oh.. no regex yet. crap.
[09:28:07] <strcat> not measured on all of rust
[09:28:18] <strcat> graydon said it produces ~10% less IR
[09:28:34] <strcat> and it's entirely a preprocessing step done on the AST atm, no trans paths
[09:28:38] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:28:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/octW6A
[09:28:38] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:28:39] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:28:39] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/rdhq8w
[09:28:39] <ghrust> 13rust/06auto 145f59c46 15Daniel Micay: rc: from_{owned,const} -> from_{send,freeze}
[09:28:39] <ghrust> 13rust/06auto 1464f49cb 15Daniel Micay: migrate many `for` loops to `foreach`
[09:28:39] <ghrust> 13rust/06auto 14ec7c7fc 15bors: auto merge of #8184 : thestinger/rust/retreat, r=huonw
[09:28:41] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:29:21] <ChrisMorgan> Seldaek: ooh, look, you found something to do!
[09:29:33] <Seldaek> yes, cry :p
[09:29:37] <dbaupp> strcat: it looks like we're getting a billion format specifiers btw :(
[09:30:01] * strcat shrugs
[09:30:12] <strcat> my for loop! ;p
[09:30:28] <dbaupp> and they're using unsafe code
[09:32:55] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[09:34:08] <strcat> dbaupp: ugh I made a typo in the tutorial
[09:34:11] <strcat> might as well fix that now...
[09:34:40] *** Joins: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:35:18] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:35:41] * strcat will trigger a test fail
[09:36:00] <strcat> or let bors notice it's gone...
[09:37:38] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[09:37:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ec7c7fc to 141b018dd: 02http://git.io/N3iJvQ
[09:37:38] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[09:37:39] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[09:37:39] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/BUrFiw
[09:37:39] <ghrust> 13rust/06auto 145f59c46 15Daniel Micay: rc: from_{owned,const} -> from_{send,freeze}
[09:37:39] <ghrust> 13rust/06auto 141fc4db2 15Daniel Micay: migrate many `for` loops to `foreach`
[09:37:39] <ghrust> 13rust/06auto 145c6069c 15bors: auto merge of #8184 : thestinger/rust/retreat, r=huonw
[09:37:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[09:42:33] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:43:39] *** Quits: azita (Azita@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: azita)
[09:46:20] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[09:48:03] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[09:48:18] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[09:49:01] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[09:49:17] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[09:52:51] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:55:06] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[09:55:26] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[09:59:36] *** Quits: igl (igl@moz-6DEF9A2D.adsl.alicedsl.de) (Ping timeout)
[10:00:32] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:00:57] *** Joins: igl (igl@moz-120B7928.adsl.alicedsl.de)
[10:02:20] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:05:43] <strcat> dbaupp: windows passed ;p
[10:08:39] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[10:10:19] <mitsuhiko> strcat: why is it foo.iter().enumerate() instead  of enumerate(foo)?
[10:10:32] <mitsuhiko> and make .iter() implicit like in python
[10:10:35] <strcat> mitsuhiko: because we don't have an Iterable trait yet
[10:10:42] <strcat> it hits some weird bugs
[10:10:51] <mitsuhiko> fair enough, that explains the .iter() being explicit
[10:10:57] <mitsuhiko> but why not make enumerate a function instead of method?
[10:11:07] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[10:11:11] <strcat> well I like methods more because they chain well ;p
[10:11:21] <doomlord> less nesting
[10:11:26] <mitsuhiko> that will sooner or later lead to inconsistent patterns where builtin iter methods look different than what people add
[10:11:39] <strcat> mitsuhiko: you can extend Iterator with your own methods
[10:11:43] <strcat> via traits
[10:11:47] <doomlord> its eassier to add you own in rust
[10:11:54] <strcat> although then they'd have to be imported by users of them
[10:12:10] * strcat shrugs
[10:12:15] <mitsuhiko> fair enough
[10:12:29] <strcat> methods also open up the possibility of overriding default methods
[10:12:34] <mitsuhiko> was just looking through the examples from the foreach impl and they look very unfamiliar
[10:12:56] <Seldaek> I must be dense, but how do those mod tests work? I can't get it to resolve anything that's declared above outside the tests mod (even though it's pub)
[10:13:27] <mitsuhiko> Seldaek: you might need a "use super::*"
[10:13:42] <Seldaek> ah, awesome thanks
[10:13:52] <strcat> mitsuhiko: methods also have auto-deref/auto-ref so they often hide a lot of noise
[10:13:57] <Seldaek> don't know why I didn't find this is libstd tests I checked, but it works
[10:13:59] <strcat> but in theory that could apply to function params...
[10:14:19] <mitsuhiko> Seldaek: probably because there is a use std around the whole thing
[10:14:23] * strcat doesn't like really auto-deref though
[10:14:33] <mitsuhiko> i'm not a huge fan of auto deref i have to admit
[10:14:58] <strcat> I think it would be great to auto-ref &T, for T: Freeze - maybe too magical
[10:15:05] <strcat> but it's transparent because it's immutable
[10:15:18] <strcat> foo(&x, &y) could just be foo(x, y)
[10:15:45] <mitsuhiko> i don't mind to manually ref/deref
[10:15:51] *** Quits: joone (joone@moz-D3B2E195.jf.intel.com) (Ping timeout)
[10:16:03] <mitsuhiko> maybe just change the priority of *
[10:16:34] *** Joins: joone (joone@E10A1781.2160464A.A34EC3BB.IP)
[10:16:35] <doomlord> claay had an interesting idea, but a bit alien.. ^.
[10:16:47] <doomlord> postfix deref operator chains with . naturally
[10:17:15] <mitsuhiko> bring -> back
[10:17:23] <mitsuhiko> and the "-" can be repeated for the number of derefs
[10:17:29] <mitsuhiko> container----->foo()
[10:18:59] <strcat> rusti: let x = 5; let y = &x; *y.clone()
[10:19:03] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BVQJ
[10:19:04] <strcat> that's why auto-deref really sucks
[10:19:09] <strcat> err
[10:19:14] <strcat> rusti: let x = 5i; let y = &x; *y.clone()
[10:19:15] -rusti- <anon>:5:33: 6:5 error: type int cannot be dereferenced
[10:19:15] -rusti- <anon>:5          let x = 5i; let y = &x; *y.clone()
[10:19:15] -rusti- <anon>:6     };
[10:19:15] -rusti- error: aborting due to previous error
[10:19:15] -rusti- application terminated with error code 101
[10:19:30] <strcat> rusti: let x = 5i; let y = & &x; *y.clone()
[10:19:32] -rusti- 5
[10:19:54] <strcat> maybe that can be fixed...
[10:19:58] <strcat> atm it derefs before even trying
[10:20:11] <strcat> but I think the combination of auto-deref + auto-ref will always be weird
[10:20:38] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:20:51] <strcat> rusti: struct Foo(int); Foo(1).to_str()
[10:20:52] -rusti- ~"1"
[10:21:23] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:21:24] <strcat> anyway off to bed \o
[10:21:25] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[10:21:39] <doomlord> heh. an extra bit of complexity in what i'm about to try (finding the struct type next to a  . operator in the tree, of course it could be a pointer..)
[10:22:26] <doomlord> auto deref does make code seem a bit hazy at first but the compiler guides you with errors :)
[10:24:08] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[10:24:31] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[10:26:11] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:32:53] *** Quits: vodik_ (simon@moz-CBE4BB13.cable.teksavvy.com) (Ping timeout)
[10:39:09] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[10:40:15] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[10:40:49] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[10:41:47] *** Quits: igl (igl@moz-120B7928.adsl.alicedsl.de) (Ping timeout)
[10:41:47] *** Joins: igl1 (igl@moz-D739D9BB.adsl.alicedsl.de)
[10:42:34] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[10:42:38] *** Quits: StarLight (StarLight@moz-2FCDA2C1.dynamic.avangarddsl.ru) (Ping timeout)
[10:45:58] *** Quits: igl1 (igl@moz-D739D9BB.adsl.alicedsl.de) (Ping timeout)
[10:46:04] *** Joins: igl (igl@moz-54CC9C07.adsl.alicedsl.de)
[10:47:04] *** Joins: StarLight (StarLight@moz-966906A6.dynamic.avangarddsl.ru)
[10:57:16] *** Joins: Florob (Florob@moz-39532932.de)
[11:06:17] *** Joins: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP)
[11:06:32] *** Joins: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com)
[11:10:12] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[11:10:14] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[11:16:38] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[11:16:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/BUrFiw
[11:16:38] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[11:19:37] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[11:19:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/5mHJFw
[11:19:37] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[11:19:38] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[11:19:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/mrynHg
[11:19:38] <ghrust> 13rust/06auto 14a591273 15Stepan Koltsov: Implement Zero for unit
[11:19:38] <ghrust> 13rust/06auto 149824d90 15bors: auto merge of #8155 : stepancheg/rust/unit-zero, r=alexcrichton
[11:19:38] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[11:21:53] *** Parts: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) ()
[11:23:07] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[11:24:58] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[11:26:39] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[11:28:11] <dbaupp> https://github.com/mozilla/rust/pull/8187 r?
[11:47:40] *** Joins: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP)
[11:50:10] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[11:57:01] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[11:58:51] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[12:03:50] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[12:08:40] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[12:09:10] *** Quits: fabiand (fabiand@moz-B0C111AA.adsl.alicedsl.de) (Quit: Verlassend)
[12:09:29] *** Joins: fabiand (fabiand@moz-B0C111AA.adsl.alicedsl.de)
[12:09:58] <orshem> hi, what does static inside a fn mean? like in c?
[12:10:42] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[12:11:31] <dbaupp> orshem: you mean `fn foo() { static bar: ... }`?
[12:11:40] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:11:41] <orshem> dbaupp: yes
[12:12:00] <orshem> from rand: static MIDPOINT: uint = RAND_SIZE as uint / 2;
[12:12:23] <dbaupp> yup, just a scoped constant
[12:12:44] <dbaupp> (to get exactly like C, you'd need `static mut`, but that's unsafe.)
[12:13:00] <orshem> so how is it  different from let?
[12:13:22] <dbaupp> it's a compile-time constant
[12:13:35] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:13:57] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Connection reset by peer)
[12:13:57] <orshem> like #define ?
[12:14:01] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:14:06] <orshem> in the IR it's a number?
[12:14:08] *** Quits: webber46 (webber46@moz-717E9C5B.cust.bredband2.com) (Quit: webber46)
[12:14:12] <dbaupp> not much different, but it can be used in places like [, .. x] (I know that one isn't used liek that), and probably gets constant-folded better by LLVM
[12:14:19] <dbaupp> (not much different to let)
[12:14:23] <kimundi> orshem: It's the same like defining an fn, a module, a macro, a struct, an enum, etc inside a fn
[12:15:23] <orshem> dbaupp, kimundi - sorry for being thick but if it's not too different from let what's its purpose? 
[12:16:15] <dbaupp> orshem: (1) because disallowing it would be a (pointless) special, and (2) because you often want to guarantee that something is a compile time constant/computed at compile time
[12:16:19] <dbaupp> *special case
[12:16:20] <kimundi> orshem: let is a local variable. it only exists on one of more stack frames if the function runs
[12:17:10] <orshem> kimundi, and static is in the static heap? allocated even if the function never run?
[12:17:13] <kimundi> static is a compile time constant, it exists from the point the program starts running and until after it finished
[12:17:19] *** Quits: zxcdw (r-a@858B320D.B543C4DE.3933CC16.IP) (Ping timeout)
[12:17:20] <kimundi> yeah
[12:18:05] <orshem> i see. thanks dbaupp kimundi
[12:18:45] <orshem> this is the nicest irc room i've been in and one of the most active :) at any time of the day
[12:20:11] *** Joins: zxcdw (r-a@858B320D.B543C4DE.3933CC16.IP)
[12:20:15] *** Joins: webber46 (webber46@moz-717E9C5B.cust.bredband2.com)
[12:20:57] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[12:24:41] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[12:25:27] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[12:27:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[12:27:52] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[12:31:20] *** Joins: sw17ch (sw17ch@moz-6206F951.dia.static.qwest.net)
[12:40:10] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[12:43:08] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:52:15] *** Joins: sk (sk@25B0E51B.DB3C9D.78DD174B.IP)
[12:58:16] <doomlord_> expr_method_call(node_id,@expr/*receiver*/,ident/*methodname*/,~[Ty]/*TypeParams*/,~[@expr]/*fn args*/,CallSugar) <<< is that right?
[12:58:37] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[12:58:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mrynHg
[12:58:37] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[12:59:34] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:00:11] *** Quits: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP) (Quit: Leaving)
[13:00:22] *** Quits: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (Ping timeout)
[13:01:02] <dbaupp> doomlord_: I believe so
[13:01:38] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:01:41] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:01:41] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/A53GgA
[13:01:41] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:01:43] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[13:01:43] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/jdH_Ow
[13:01:43] <ghrust> 13rust/06auto 142e6dc16 15Ben Blum: Give tasks useful names. #2891
[13:01:43] <ghrust> 13rust/06auto 14bc7cee7 15Ben Blum: Move atomically to unstable::sync, and document what it actually does. Close #7872.
[13:01:43] <ghrust> 13rust/06auto 1418d124b 15bors: auto merge of #8158 : bblum/rust/task-cleanup, r=brson...
[13:01:44] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[13:02:20] <cmr> Maybe it's just me but the rate-of-change of newrt seems to be increasing
[13:02:45] <cmr> Maybe it's just actually getting applied to master instead of staying queued up in brson's branch
[13:02:51] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:03:33] <doomlord_> ok to find the 'definition' of a method name.. i need to scan the impls' for the Ty of the receiver, i guess .
[13:03:56] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[13:04:35] <dbaupp> cmr: (is the bencher off?)
[13:04:53] <cmr> yes
[13:06:27] <doomlord_> i see the 'ctxt_ has various things that look like they should have that info
[13:09:33] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[13:11:37] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[13:12:18] *** Joins: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP)
[13:14:17] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[13:15:24] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:18:05] *** Quits: LU324 (quassel@9AF4F288.83671C58.1B5D53D7.IP) (Input/output error)
[13:22:19] *** Joins: sastry (Mibbit@E29F48AE.70E3C627.4A5F0685.IP)
[13:22:43] <sastry> Hey could anyone tell me how to convert a owned string to borrowed string ?
[13:23:06] <kimundi> sastry: It usually borrows automatically
[13:23:28] <kimundi> sastry: The important thnig is to note that 'converting' doesn't make sanse
[13:23:34] <kimundi> sense*
[13:23:52] <sastry> well .. I have a vector of this form [~str] and when I pass it to a function which takes [&str] its not converting
[13:23:58] <kimundi> you have to keep the owned str somewhere, and borrow from that a borrowed str
[13:24:15] <kimundi> right, that's a bit trickier
[13:24:44] <sastry> Actually the string is generated from path("something").to_str()
[13:24:48] <kimundi> what you have to do is: create a new vector, and fill it with references to the elements of the old vector
[13:25:53] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[13:26:38] <kimundi> rusti: let v= [~"foo", ~"bar"]; let v2: ~[&str] = v.iter().transform(|s| s.as_slice()).collect(); 
[13:26:38] -rusti- <anon>:5:38: 5:40 warning: unused variable: `v2` [-W unused-variable (default)]
[13:26:39] -rusti- <anon>:5          let v= [~"foo", ~"bar"]; let v2: ~[&str] = v.iter().transform(|s| s.as_slice()).collect(); 
[13:26:39] -rusti-                                                ^~
[13:26:39] -rusti- ()
[13:27:34] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[13:27:35] <kimundi> rusti: let v= [~"foo", ~"bar"]; let v2: ~[&str] = v.iter().transform(|s| s.as_slice()).collect(); foreach s in v2.consume_iter() { printf!("%? ", s) }
[13:27:36] -rusti- "foo" "bar" ()
[13:28:17] <kimundi> rusti: let v= [~"foo", ~"bar"]; let v2: ~[&str] = v.map(|s| s.as_slice()); foreach s in v2.consume_iter() { printf!("%? ", s) }
[13:28:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Sdeg
[13:28:45] <dbaupp> sastry: what's the function that takes [&str]? one you wrote yourself?
[13:29:31] <kimundi> sastry: Anyway, the current canonical way would be this:
[13:29:33] <kimundi> rusti: let v= [~"foo", ~"bar"]; let v2: ~[&str] = v.iter().transform(|s| s.as_slice()).collect(); foreach s in v2.consume_iter() { printf!("%? ", s) }
[13:29:34] -rusti- "foo" "bar" ()
[13:29:49] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[13:30:36] <sastry> Okay !! hey I have only 3 elements in this vector. the first two are static strings like "test.c" and "-o" and the third one is generated on the fly. So its like am creating this vector at this point instead of making a second vector may be I could redfine this vector here itself ?
[13:30:44] <kimundi> a bit verbose right now because of transient stuff, and there could be shortcut methods, but in general, that's how you can do it.
[13:31:26] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[13:31:46] * ChrisMorgan likes the effect foreach has had on rustc build time, down 9% or more: http://huonw.github.io/isrustfastyet/buildbot/#5c6069c
[13:31:51] <dbaupp> sastry: do you have a snippet of code we can look at?
[13:32:02] <kimundi> sastry: Hu? [~str] and [&str] are diferent types, no way to change it instead of creating a new one
[13:32:09] *** Joins: nano (nano@moz-972880B.superkabel.de)
[13:32:26] <dbaupp> ChrisMorgan: nice! looks like a legitimate drop too, not just buildbot noise.
[13:32:33] <ChrisMorgan> Sure does.
[13:32:56] <ChrisMorgan> What's the deal with opt/noopt?
[13:32:56] <sastry> ok .. 
[13:33:10] <dbaupp> ChrisMorgan: what do you mean?
[13:33:12] <sastry> Am working on this bug so .. this code is from rustc
[13:33:13] <kimundi> sastry: you can of course just create a [~str] to begin with, than you can put in the &'static strings directly, and borrow the dynamically created ~str as a &str
[13:33:18] <ChrisMorgan> What's the difference?
[13:33:28] <kimundi> er, create a [&str] to begin with
[13:33:35] <dbaupp> ChrisMorgan: one builds with -O, one doesn't
[13:33:45] <dbaupp> ChrisMorgan: guess which is which :P
[13:33:58] <dbaupp> sastry: which bug?
[13:34:13] <ChrisMorgan> Oh, of course. A "normal" build (as in `./configure && make install`) would be opt, I presume?
[13:34:16] <dbaupp> yup
[13:34:30] <dbaupp> --disable-optimise gives you noopt
[13:34:38] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[13:34:39] <sastry> kimundi: let out = path("foo.o"); run::process_status("gcc",[&"foo.c", &"-o", out.tostr()]);
[13:34:43] <dbaupp> *optimize
[13:34:49] <sastry> let out = path("foo.o"); run:: process_status("gcc",[&"foo.c", &"-o", out.tostr()]);
[13:34:53] <kimundi> rusti: let dyn = ~"hello"; let v= ["foo", "bar", &*dyn];  foreach s in v.consume_iter() { printf!("%? ", s) }
[13:34:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YLYW
[13:35:08] <kimundi> rusti: let dyn = ~"hello"; let v= ["foo", "bar", dyn];  foreach s in v.consume_iter() { printf!("%? ", s) }
[13:35:09] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iJJj
[13:35:27] <kimundi> rusti: let dyn = ~"hello"; let v= ["foo", "bar", dyn.as_slice()];  foreach s in v.consume_iter() { printf!("%? ", s) }
[13:35:27] <ChrisMorgan> That, I take it, would make rustc slower to run, but have no change in functionality.
[13:35:27] -rusti- <anon>:5:82: 5:100 error: type `[&str, .. 3]` does not implement any method in scope named `consume_iter`
[13:35:27] -rusti- <anon>:5          let dyn = ~"hello"; let v= ["foo", "bar", dyn.as_slice()];  foreach s in v.consume_iter() { printf!("%? ", s) }
[13:35:28] -rusti-                                                                                            ^~~~~~~~~~~~~~~~~~
[13:35:28] -rusti- error: aborting due to previous error
[13:35:29] -rusti- application terminated with error code 101
[13:35:37] <dbaupp> sastry: you need [~str] anyway, so [~"foo.c", ~"-o", out.to_str()]
[13:35:42] <kimundi> rusti: let dyn = ~"hello"; let v= ["foo", "bar", dyn.as_slice()];  foreach s in v.iter() { printf!("%? ", s) }
[13:35:43] -rusti- &"foo" &"bar" &"hello" ()
[13:35:57] <dbaupp> ChrisMorgan: in theory... but in practice, no
[13:36:07] <ChrisMorgan> ... uh oh.
[13:36:22] <ChrisMorgan> That would suggest "bad" optimisations, surely?
[13:36:23] <kimundi> rusti: let dyn = ~"hello"; let v= ["foo", "bar", dyn.as_slice()];  foreach &s in v.iter() { printf!("%? ", s) }
[13:36:24] -rusti- "foo" "bar" "hello" ()
[13:36:36] <dbaupp> ChrisMorgan: LLVM optimises out noop infinite recursion, for instance
[13:36:48] <dbaupp> ChrisMorgan: fn f() { f() }
[13:37:00] <sastry> https://github.com/mozilla/rust/issues/7928#issuecomment-21892069
[13:37:04] <sastry> This is the bug I am working on
[13:37:18] <nmatsakis> pauls: ping
[13:37:33] <nmatsakis> jclements: ping
[13:37:44] <cmr> ChrisMorgan: The optimized code is the correct code, unfortunately
[13:37:58] <sastry> kimundi: So I thought of changing the process_status to accept [&str] instead of [~str]
[13:38:15] <dbaupp> sastry: did you see my comment about being `new<S: Str>(&str, &[S], ...)`?
[13:38:18] <ChrisMorgan> dbaupp: what's the difference with that case? Optimised will make it a noop and unoptimised will cull it?
[13:38:41] <dbaupp> ChrisMorgan: it'll be removed with -O, but will be `loop {}` without
[13:38:44] <ChrisMorgan> s/cull/leave it to run out of stack space/
[13:38:54] <sastry> dbaupp: Yes man I saw ur comment .. i thought of replying there
[13:38:56] <dbaupp> (yeah, loop, but using stack)
[13:39:36] <dbaupp> sastry: that would mean that you don't have to convert any of the current users at all, because [~str], [@str] and [&str] would be valid arguments
[13:40:31] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[13:40:43] <kimundi> sastry: Hmm... The problem is that both &[&str] and &[~str] are a problem if you have the other one. in both cases you have to create a vector. So dbaupp/huonw's proposal to make it a generic function seems like the best. except... dbaupp, is Str actually implemented on ~str?
[13:41:01] <dbaupp> kimundi: of course! Str provides .as_slice
[13:41:03] <ChrisMorgan> Hang on, I'm not quite grasping this. Scenarios: (a) rustc; (b) rustc -O; (c) --disable-optimize and rustc; (d) --disable-optimize and rustc -O. What are the outputs for that fn f() { f() } in each of those?
[13:41:25] <dbaupp> ChrisMorgan: https://github.com/mozilla/rust/issues/6179, btw (a "real world" example)
[13:41:25] <cmr> --disable-optimize just builds rustc without -O
[13:41:25] <sastry> dbaupp : I will stick with ur suggestion :)
[13:41:29] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[13:41:38] <kimundi> dbaupp: That doesn't mean much, a impl on &str can provite as_slice too :P
[13:41:44] * kimundi looks in the source
[13:42:13] <dbaupp> kimundi: I mean, when you call .as_slice() you're using ~str's impl (not an auto sliced one)
[13:42:24] <dbaupp> kimundi: (I implemented it :P )
[13:42:49] <dbaupp> ChrisMorgan: ./configure --disable-optimise just means that rustc isn't passed -O in the bootstrap
[13:43:21] <kimundi> dbaupp: Ah, I see. Didn't know the trait was layed out like that
[13:43:22] <dbaupp> ChrisMorgan: so the two states are rustc and rustc -O, and the former doesn't optimise fn f() { f() } to a noop, the latter does.
[13:43:24] <ChrisMorgan> I grasped that, just found it easier to express as --disable-optimize (tut tut, you spelled it wrong _again_!) than as two lots of -O
[13:43:36] * dbaupp hugs his 's's
[13:44:18] <ChrisMorgan> And so, if there is any such recursion in Rust's code, _then_ it shows. OK, I get it.
[13:44:32] <dbaupp> yup
[13:44:59] <ChrisMorgan> Seems a bit suspicious to just drop `loop{}`...
[13:45:35] <dbaupp> I believe it's a WONTFIX LLVM bug (I'm not 100% sure about the WONTFIX.)
[13:45:50] <cmr> rusti: loop {}
[13:45:52] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eLIg
[13:46:06] <dbaupp> rusti: if true { loop {} }
[13:46:12] -rusti- timeout triggered!
[13:46:26] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[13:46:27] <ChrisMorgan> ..?
[13:46:38] <dbaupp> rusti doesn't optimise
[13:46:40] <cmr> It doesn't optimize out loop{}
[13:46:44] <cmr> I just tested locally
[13:46:58] <cmr> Even at opt-level=3
[13:47:00] <dbaupp> rusti: fn f() { f() } f()
[13:47:00] <ChrisMorgan> More, why does `if true { loop {} }` work and `loop {}` not?
[13:47:01] -rusti- application terminated abnormally with signal 9 (Killed)
[13:47:11] <dbaupp> (that does run fine locally.)
[13:47:36] <cmr> ChrisMorgan: likely a bug in reachability
[13:47:40] <dbaupp> ChrisMorgan: oh, unreachable code things, where as the if true {} lets it think that the branch might not be taken
[13:47:49] <cmr> although I think it's trying to solve the halting problem
[13:47:53] <cmr> so, approximation
[13:49:01] *** Joins: rsaarelm (rsaarelm@moz-D1CB7158.dhcp.inet.fi)
[13:50:40] <benh> rusti: if true { loop {} } else { loop {} }
[13:50:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GKQR
[13:52:02] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:53:09] *** Joins: deLta30 (quassel@E9273A02.DD2595E6.110F01C1.IP)
[13:54:59] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[13:55:33] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[13:57:17] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[13:57:26] *** Quits: heftig (heftig@327C8F30.EBDCAFC6.FEC4A986.IP) (Ping timeout)
[13:57:43] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Input/output error)
[13:57:48] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[13:57:49] *** Joins: heftig (heftig@8D5076D2.6FC4DE2F.FEC4A986.IP)
[14:00:12] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[14:00:44] *** Quits: paupau (textual@FFAF02D4.F5573215.F20F0C5A.IP) (Ping timeout)
[14:05:42] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[14:07:11] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[14:07:49] *** Parts: poiru (poiru@moz-C4357EA7.kapsi.fi) ()
[14:09:24] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:09:54] *** Joins: Florob (Florob@moz-39532932.de)
[14:10:02] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[14:11:07] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[14:12:13] *** Quits: cyndis (cyndis@moz-FA10A1CD.fi) (Ping timeout)
[14:12:15] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[14:12:40] *** Joins: tautologico (lymph@9F01D096.92EA1F6.C27E1635.IP)
[14:13:32] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:13:52] *** Joins: LU324 (stuff@9AF4F288.83671C58.1B5D53D7.IP)
[14:15:56] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Client exited)
[14:17:19] *** Quits: webber46 (webber46@moz-717E9C5B.cust.bredband2.com) (Quit: webber46)
[14:19:42] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[14:23:05] *** Joins: bnicholson (bnicholson@moz-3492C575.rcmdva.fios.verizon.net)
[14:23:17] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[14:23:18] *** ChanServ sets mode: +o dherman
[14:26:22] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[14:27:53] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:28:02] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:31:42] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[14:35:06] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[14:35:08] *** Joins: webber46 (webber46@moz-717E9C5B.cust.bredband2.com)
[14:35:52] <pauls> nmatsakis: pong
[14:36:40] <nmatsakis> pauls: I want to have macros that take #[annotations]
[14:36:46] <nmatsakis> pauls: how hard would this be to make happen
[14:36:48] *** Joins: josh (josh@95276BCF.852D8405.1051363A.IP)
[14:36:58] <nmatsakis> pauls: I tried using `tt` as the type, but then I couldn't refer to the values anywhere
[14:37:10] <nmatsakis> pauls: I guess my mental model for how token trees and macros all fit together is broken
[14:37:30] <pauls> You mean, `m!(#[inline(always)])`?
[14:37:55] <nmatsakis> pauls: yeah basically
[14:38:00] <pauls> You can't currently transcribe a `tt` anywhere but the argument to a macro invocation.
[14:38:20] <nmatsakis> I noticed.
[14:38:39] <pauls> Adding unpack-and-parse-this transcription to `tt`s might make sense. It wouldn't be all that hard to implement.
[14:38:46] <nmatsakis> that would be great
[14:38:57] <nmatsakis> though in this case it also seems like "attribute" would be a useful type
[14:39:20] <pauls> That also makes sense.
[14:39:26] <pauls> Either should be not too hard.
[14:40:37] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[14:40:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/jdH_Ow
[14:40:38] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[14:40:42] <nmatsakis> pauls: Want to do it? ;)
[14:41:00] <josh> installing rust, at least on OS X, still installs libraries that don't have the word "rust" in the name - libsyntax, a couple of others - is this intentional?
[14:41:01] <nmatsakis> pauls: I'll take a look otherwise; it didn't *seem* too hard
[14:41:05] <pauls> nmatsakis: my wrists are getting better (finally!), but they're not there yet.
[14:41:18] <nmatsakis> pauls: oh, didn't know you were having problems. sorry to hear that.
[14:41:18] <josh> makes it hard to know what to clean out when you want to delete rust files for some reason
[14:41:26] <sastry> hey how come there are no terinary operators in rust ???
[14:41:31] <nmatsakis> josh: that's intentional, I suggest "make uninstall"
[14:41:32] <cmr> josh: They're not supposed to have the word 'rust' in them
[14:41:39] <cmr> sastry: don't need them
[14:41:46] <nmatsakis> sastry: because you can write "if cond { foo } else { bar }" as an expression
[14:41:46] <cmr> sastry: if foo { x } else { y }
[14:41:53] <cmr> if is an expression, not a statement
[14:42:08] <nmatsakis> though I still prefer to format if `if cond {foo} else {bar}` :)
[14:42:16] <nmatsakis> *format it
[14:42:23] <jedestep> rusti: let a = if 1 == 2 {1} else {0}; a
[14:42:24] -rusti- 0
[14:42:39] <sastry> ok ... now the tutorial section about expression makes sense to me :)
[14:43:22] *** Joins: Daniel_S (Daniel_S@moz-5B58D8B7.dhcp.snlo.ca.charter.com)
[14:43:37] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:43:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ik8pTA
[14:43:37] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:45:03] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[14:45:09] *** Joins: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu)
[14:45:51] <josh> cmr, nmatsakis: what's the story behind it being intentional?
[14:46:21] <nmatsakis> josh: uh, it's just the name of the library?
[14:46:25] <cmr> josh: Why would they have the name 'rust' in it? C++ libraries don't have the name 'C++' in them, and so forth.
[14:46:40] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:46:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ik8pTA
[14:46:40] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:46:41] <nmatsakis> josh: may I suggest you use GNU stow :)
[14:46:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[14:46:41] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/UBMcQQ
[14:46:41] <ghrust> 13rust/06auto 14ebd14c9 15Brian Anderson: std: Remove PortSet. Not supported by new scheduler. Replace uses with SharedChan.
[14:46:41] <ghrust> 13rust/06auto 14fe28ac6 15bors: auto merge of #8164 : brson/rust/noportset, r=pcwalton...
[14:46:42] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[14:49:33] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[14:51:20] *** Joins: lmandel (lmandel@CD1A664D.7ECD71DF.ADB88A9.IP)
[14:51:32] *** Quits: jaen (jaen@moz-E8D76C54.neoplus.adsl.tpnet.pl) (Ping timeout)
[14:58:03] *** Quits: deLta30 (quassel@E9273A02.DD2595E6.110F01C1.IP) (Connection reset by peer)
[14:58:30] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Ping timeout)
[14:59:17] *** Quits: sastry (Mibbit@E29F48AE.70E3C627.4A5F0685.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:59:25] *** Quits: josh (josh@95276BCF.852D8405.1051363A.IP) (Quit: josh)
[15:07:56] <jedestep> declaring a struct inside a macro seems buggy
[15:08:20] <pauls> jedestep: how so?
[15:08:25] <jedestep> implementations also defined inside the same macro aren't recognized
[15:08:35] <engla> jedestep: you can only expand one item inside a macro
[15:08:45] <pauls> jedestep: https://github.com/mozilla/rust/issues/4375 (what engla said)
[15:08:49] <jedestep> -_-
[15:08:58] <kimundi> jedestep: Not by design
[15:09:05] <kimundi> jedestep: It's a bug
[15:09:09] <engla> it's a bug, not a feature :)
[15:09:09] <jedestep> ok that's good
[15:09:23] <jedestep> because it would benefit me a lot, as would exporting macros from crates
[15:09:36] <engla> common workaround: macro expands to one module
[15:09:47] <jedestep> lol
[15:10:14] <jedestep> my documentation might cry a little on the inside
[15:10:21] <kimundi> (we really need to stop anwering those quesitons with "can't do that" if the correct answer is "should be able to/will be able to, just not now because of bugs")
[15:10:37] <engla> kimundi: ok, I'll try to remember next time!
[15:11:33] <kimundi> engla: It's not that big of a deal, but it's important to not accidentially spread misinformation :)
[15:12:18] <jedestep> this issue has been open for a long time. maybe i'll look into it
[15:12:30] <jedestep> and macro exports
[15:12:32] *** Joins: yonran (yonran@moz-962F33EB.acuitus.com)
[15:13:41] <doomlord_> given a 'ty::t', can i find the methods implemented for 't' in ctxt_ 
[15:13:43] <cmr> jedestep: talk to pauls and jclements about it
[15:14:37] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[15:14:41] <Daniel_S> is there a good opengl binding for rust?
[15:14:52] <cmr> Daniel_S: no
[15:15:02] <cmr> Bindings exist, but not any "good" ones
[15:15:15] <cmr> https://github.com/bjz/gl-rs will be good once PR 6661 lands
[15:15:21] *** Quits: jclements (jclements@moz-82B0DFD.man.east.myfairpoint.net) (Quit: jclements)
[15:15:50] <cmr> Until then, servo and q3 use https://github.com/mozilla-servo/rust-opengles
[15:15:55] <kimundi> Daniel_S: bjz is planning a proper one, but is blocked on an issue with funtcion pointers that will hopefuly soon be olved by nmatsakis 
[15:16:02] <doomlord_> (ah, Method contains ..self_ty.)
[15:16:24] <cmr> doomlord_: isn't navigating the labryinthine compiler data structures fun?
[15:16:31] <cmr> all the information is there... just gotta figure out how to get there
[15:16:41] <doomlord_> it might be if i get this tool working :)
[15:16:47] <cmr> heh
[15:18:06] <kimundi> jedestep: I'm not the slightiest bit an expert about such things, but afaik to solve the "macro expanding to more items" issue you'd need to introduc some kind of "flat scope" AST node... A node that can contain more nodes, but doesn't imply any actual nesting in the code.
[15:18:09] <nmatsakis> kimundi: I can finally say that we're making progress there :)
[15:18:13] <kimundi> yay
[15:18:14] <nmatsakis> shouldn't be that much longer
[15:18:24] <nmatsakis> just haven't been able to do anything this week, focused on PJS
[15:18:31] <nmatsakis> but I really want to get it done so I can go off to other patches damn it :)
[15:18:37] <kimundi> hehe
[15:18:50] <kimundi> how long has it been now? A couple of months at least
[15:19:54] <jedestep> kimundi: that sounds like it would be the right thing, yeah
[15:21:06] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:22:36] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[15:23:07] <cmr> nmatsakis: oh, ping!
[15:23:17] <nmatsakis> cmr: pong!
[15:23:19] <cmr> https://github.com/cmr/rustdoc_ng/blob/master/plugins.rs#L37
[15:23:26] <cmr> The destructor is called before I would expect it.
[15:23:44] <cmr> It's called on that line, and the destructor calls dlclose, so the call to lib.symbol on the next line segfaults
[15:23:47] <cmr> graydon told me to ask you about it
[15:24:16] <pauls> jedestep, kimundi: another option is to make fold.rs a bit fancier and able to flatten extra items into whatever is holding them.
[15:24:17] <cmr> I wouldn't expect it to be called at all, though, since it gets moved into self.dylibs afterwards
[15:24:29] <pauls> The former is probably easier.
[15:24:39] <nmatsakis> cmr: destructor of `lib`?
[15:24:44] <cmr> nmatsakis: yeah
[15:24:53] <nmatsakis> cmr: huh. sounds like a bug
[15:24:58] <nmatsakis> cmr: have you tried to minimize at all?
[15:25:00] <cmr> well, it might be destructing the wrapped value
[15:25:10] <cmr> nmatsakis: no, not really, I will do that tomorrow
[15:25:15] <nmatsakis> cmr: I'm thinking it is probably related to the call to unwrap,
[15:25:28] <nmatsakis> cmr: that is, it's not `lib` being destructed, but rather lib_result somehow
[15:25:34] <cmr> right
[15:25:42] *** Joins: jdm_ (jdm@F2D29657.F60B0462.67AC9B1.IP)
[15:26:21] <jedestep> pauls: yeah just having a dedicated flat node seems simpler
[15:26:27] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[15:26:51] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:28:31] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:34:00] <doomlord_> hmmm. i thought i had a "ty" for the receiver, but walking all the methods, none of their "transformed_self_ty'" match
[15:34:12] <doomlord_> ^ast::t
[15:34:25] <doomlord_> ^ty::t rather.
[15:37:02] <cmr> Does anyone know if I need to do anything to safely access errno?
[15:37:13] <cmr> I feel like rust's task model is going to make errno very non-obvious
[15:41:08] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[15:42:41] *** cade is now known as cade_lunch
[15:44:26] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:45:24] <doomlord_> can anyone explain what 'transformed_self_ty' is - i dont seem to be finding the ty::t's of anything i can get from the receiver yet, and the "transformed_" in the name makes me wonder if its something different
[15:46:57] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[15:47:02] <doomlord_> i get "ty::t"'s from ctxt_ node_types.find( .. some node_id .. )
[15:47:58] *** Joins: Florob (Florob@moz-39532932.de)
[15:48:21] *** jdm_ is now known as jdm
[15:53:59] *** Quits: Daniel_S (Daniel_S@moz-5B58D8B7.dhcp.snlo.ca.charter.com) (Quit: Leaving)
[15:55:46] *** Quits: lmandel (lmandel@CD1A664D.7ECD71DF.ADB88A9.IP) (Quit: lmandel)
[15:56:59] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:57:12] *** Joins: lmandel (lmandel@CD1A664D.7ECD71DF.ADB88A9.IP)
[15:58:47] *** Joins: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:58:48] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[16:00:05] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:03:06] <doomlord_> seems to be something to do with generic substitutions, do i have to use one of these 'subst' fn/methods to turn the transformed_self_ty into something that can be compared with node_types perhaps
[16:03:26] *** Joins: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de)
[16:03:46] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[16:03:47] <erickt2> cmr: thanks for the rust-zmq PR!
[16:04:27] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[16:04:28] <cmr> erickt2: I've another one cooking
[16:04:34] <cmr> removing usage of deprecated APIs
[16:05:22] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[16:05:29] <toddaaro> where should I look to see what happens before main is executed in a rust program?
[16:05:39] <toddaaro> the source code for the program runner I guess
[16:06:07] <cmr> toddaaro: http://git.musl-libc.org/cgit/musl/tree/crt/crt1.c is basically it
[16:06:21] <cmr> also http://git.musl-libc.org/cgit/musl/tree/crt/x86_64/crt1.s
[16:06:22] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[16:06:23] *** Quits: sw17ch (sw17ch@moz-6206F951.dia.static.qwest.net) (Quit: sw17ch)
[16:06:40] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:06:41] <cmr> it's not much; the kernel does all the hard work of putting argc/argv on the stack, as well as the elf auxillary vector
[16:06:49] <toddaaro> hm, where is the runtime started?
[16:07:07] <cmr> The kernel does its things and jumps to the _start symbol
[16:07:15] <cmr> Oh, the rust runtime?
[16:07:30] <toddaaro> yea, I assumed that was some sort of wrapper around main
[16:08:02] *** Quits: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de) (Ping timeout)
[16:08:34] <erickt2> Seldaek: yeah, my ragel port needs to be updated to HEAD. I think I was using labeled breaks though
[16:08:49] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:08:49] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:09:01] *** Joins: sw17ch (sw17ch@moz-6206F951.dia.static.qwest.net)
[16:09:19] <cmr> toddaaro: std::unstable::start
[16:09:42] <cmr> std::unstable::lang::start, sorry
[16:10:12] <toddaaro> cmr: perfect, thanks
[16:10:36] *** Joins: mib_6rwnpp (Mibbit@9130F362.17A1EB20.5211057F.IP)
[16:11:10] *** Quits: mib_6rwnpp (Mibbit@9130F362.17A1EB20.5211057F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:11:14] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[16:13:14] <erickt2> cmr: shall I wait for your second PR? Or look into merging the one you submitted?
[16:13:23] <cmr> erickt2: don't wait
[16:14:09] <erickt2> cmr: also, this should be fine: https://github.com/cmr/rust-zmq/blob/cleanup/zmq.rs#L85. The constants get explicitly casted to c_int when passed to the external fns
[16:14:53] <cmr> erickt2: yeah, that's what I figured
[16:14:56] <Seldaek> erickt2: alright, well it's not like I need it now anyway, it was mostly curiosity
[16:15:36] <erickt2> cmr: merged, thanks!
[16:16:12] <erickt2> Seldaek: Okay :) well let me know if you ever want to use it, i'll make sure it's ported to HEAD
[16:16:23] <Seldaek> thanks
[16:16:47] *** Joins: jensn (jensn@moz-3884E144.mobileonline.telia.com)
[16:16:47] <toddaaro> bblum: you awake yet?
[16:16:59] <toddaaro> bblum: the weird failure in my PR build seems to be an old runtime test
[16:16:59] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:17:31] <toddaaro> bblum: run-pass/unwind-resource.rs, fails trying to send on a shared chan from a destructor in oldrt
[16:17:49] <erickt2> Seldaek: last I checked, it performs pretty well too. The ragel url parser is faster than rust's hand written one. However the ragel C url parser was still much faster
[16:17:55] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[16:18:16] *** Joins: sp3d (a@moz-41A29595.dhcp.stls.mo.charter.com)
[16:18:30] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[16:18:53] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:18:56] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:19:28] <Seldaek> erickt2: it works without regexes right? you give it an ebnf of some sort and it generates a state machine? I haven't looked into it much..
[16:19:59] <erickt2> Seldaek: you can specify regexes in ragel. It just compiles those regexes down into a state machine
[16:20:37] <doomlord_> If i dont have any type-params, would Method.transformed_self_type match the 'ty:;t' i might get from a method call - it doesn't seem to
[16:22:42] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Quit: pyrac)
[16:23:21] <Seldaek> erickt2: ah but how does that work without regex support in rust? Or do you mean it actually expands the regexes into a state machine that doesn't use those regexes to find tokens?
[16:23:32] *** Joins: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de)
[16:23:33] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:23:41] <cmr> Seldaek: all "real" regexps can be expressed as a state machine
[16:23:50] <Seldaek> yeah I suppose
[16:23:54] <cmr> that is what ragel does
[16:24:05] <Seldaek> ok cool
[16:25:21] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:25:38] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[16:25:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/UBMcQQ
[16:25:38] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[16:27:01] *** Quits: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:27:32] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[16:27:46] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:28:13] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[16:28:35] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:28:38] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:28:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zZkV1A
[16:28:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:28:39] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[16:28:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_s5Sdg
[16:28:39] <ghrust> 13rust/06auto 148261f2c 15Graydon Hoare: test: add more codegen tests, add copyright headers to all.
[16:28:39] <ghrust> 13rust/06auto 147daea7c 15bors: auto merge of #8165 : graydon/rust/2013-07-31-new-codegen-tests, r=brson...
[16:28:40] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[16:29:25] *** Quits: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de) (Ping timeout)
[16:31:07] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[16:31:32] <toddaaro> how do I re-run the test suite after make check?
[16:31:34] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:31:41] <toddaaro> doing make check again NO_REBUILD=1 just runs the doc tests
[16:32:06] <cmr> toddaaro: I don't think the makefile exposes it :\
[16:32:25] <cmr> might have to remove some intermediate files, like stdtest and so on?
[16:32:32] <kimundi> toddaaro: you have to toch one of the files of the testsuite so that it thinks it needs to rerun them
[16:32:48] <toddaaro> kimundi: ah, I'll poke around there, thanks
[16:34:09] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:34:55] <Thiez> kimundi: doesn't deleting the test logs also work?
[16:35:09] <kimundi> dunno
[16:35:36] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:35:44] *** Joins: vodik_ (simon@moz-2C900B36.dsl.bell.ca)
[16:36:42] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[16:36:47] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:37:05] <doomlord_> ok i see 'LookupContext::search_for_method' which might eventually explain how the Method:: transformed_type works..
[16:37:06] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[16:38:09] *** Joins: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr)
[16:38:35] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[16:39:11] <orshem> hi everyone. does std have an implementation of Point2d Point3d? with operator overloading for add / sub and all the rest
[16:39:26] *** Joins: eholk (eholk@8CCCE0FC.83FFA18A.ABD5273E.IP)
[16:39:50] <jensn> orshem: I think bjz has a library with that (lmath)
[16:39:56] <cmr> orshem: no, and what jensn said
[16:40:49] <kmc> i'm still not sure what an extern "Rust" fn() is... it's a raw function pointer (no environment) to code which follows the Rust calling convention?
[16:41:44] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:42:20] *** Quits: pyrac (pyrac@moz-F28B7CAD.w90-55.abo.wanadoo.fr) (Ping timeout)
[16:42:31] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:42:31] <cmr> kmc: yes
[16:42:44] *** Joins: deLta30 (quassel@D2C62F7E.24095528.3FEEFD97.IP)
[16:42:53] <orshem> jensn, cmr: thanks found it. do you know if it is up to date?
[16:43:02] *** Joins: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de)
[16:43:10] <cmr> orshem: it is relatively up-to-date. bother bjz if you have problems
[16:43:28] *** Quits: tautologico (lymph@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[16:43:45] <orshem> cmr: thanks. but i don't want to bother anybody :)
[16:44:11] <jensn> I think he'll be happy if someone uses it ;)
[16:44:28] *** cade_lunch is now known as cade
[16:44:31] *** Quits: fabiand (fabiand@moz-B0C111AA.adsl.alicedsl.de) (Quit: Verlassend)
[16:44:57] <maikklein> why hasen't https://github.com/mozilla/rust/pull/6661 merged yet? are there still problems?
[16:45:06] <cmr> maikklein: yes
[16:45:21] <maikklein> :(
[16:45:24] <sebcrozet> orshem: lmath is regularily updated. There is also the nalgebra library, which has a slightly different design.
[16:46:34] <orshem> sebcrozet, link to nalgebra? google and github search didn't find anything
[16:46:53] <sebcrozet> orshem: https://github.com/sebcrozet/nalgebra
[16:46:56] <maikklein> orshem, what doesn't work in lmath?
[16:47:23] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[16:47:23] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[16:47:30] <kmc> cmr: thanks
[16:47:31] *** Quits: jensn (jensn@moz-3884E144.mobileonline.telia.com) (Ping timeout)
[16:47:38] <orshem> maikklein, nothing? i've not pulled it yet 
[16:47:46] <orshem> i'm still in the asking stage
[16:48:05] <maikklein> ah ok
[16:48:12] <maikklein> thought you got some problems :)
[16:49:02] <maikklein> lmath is more targeted for computergraphics
[16:49:06] *** Joins: thomaslee (thomaslee@moz-6C3931E3.static.twtelecom.net)
[16:50:00] <sebcrozet> orshem: I think lmath is easier to use overall. nalgebra is more stratified with a lot of traits, and is targeted for (generic) computer physics.
[16:50:18] <orshem> maikklein, it's certainly seems very general
[16:50:50] <orshem> sebcrozet, i see that what common to both of them is over abundance of macros :)
[16:51:44] *** Joins: brianm (brianm@moz-9B7D279E.dsl.static.sonic.net)
[16:51:44] <sebcrozet> orshem: well, its very boring to write repetedly the same code for each dimenson :p
[16:51:45] <maikklein> you can use lmath for GP but it has everyhing that you would need for computergraphics.
[16:53:01] <orshem> maikklein, simd?
[16:53:22] <maikklein> orshem, don't think that it uses simd yet
[16:53:50] <cmr> maikklein: lmath doesn't have n-dimensional matrixes
[16:53:55] <cmr> not very general purpose
[16:54:27] *** Joins: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com)
[16:54:27] *** ChanServ sets mode: +qo graydon graydon
[16:54:39] *** Quits: vodik_ (simon@moz-2C900B36.dsl.bell.ca) (Quit: work)
[16:55:14] <orshem> maikklein, doesn't matter. i'm not doing cg or anything intensive anyhow. both are overkill for my needs :)
[16:56:04] <jdm> rusti: 0 as *u8 as *mut u8
[16:56:05] -rusti- 0
[16:56:29] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[16:57:24] *** Joins: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:57:32] <maikklein> orshem, what do you need?
[16:58:04] *** Quits: sk (sk@25B0E51B.DB3C9D.78DD174B.IP) (Quit: Leaving)
[16:59:10] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:59:35] <orshem> just 2d points with support for basic operators, i'm using tuple / homemade struct currently
[16:59:58] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:00:31] *** Joins: MiLLiYeTCH (ain@D1A93B5B.684085D8.A8B149FF.IP)
[17:00:37] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[17:00:56] <MiLLiYeTCH> Azerbaijan International Network :: /server ain.az :)
[17:01:01] <MiLLiYeTCH> Azerbaijan International Network :: /server ain.az :)
[17:01:04] *** Quits: MiLLiYeTCH (ain@D1A93B5B.684085D8.A8B149FF.IP) (Quit: )
[17:01:23] <maikklein> orshem, well okay that should be really easy to implement. otherwhise https://github.com/bjz/lmath-rs/blob/master/src/math/point.rs
[17:01:33] <doomlord_> seems like 'CrateCtxt' might have what i need... 'method_map' ... 
[17:02:16] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:02:16] *** ChanServ sets mode: +o brson
[17:03:06] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[17:03:06] *** ChanServ sets mode: +o tjc
[17:03:09] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[17:03:29] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:04:04] <maikklein> cmr, well it sort of has https://github.com/bjz/lmath-rs/blob/master/src/math/macros.rs#L18 :)
[17:04:26] <orshem> maikklein, i've copied the op overloading off that.   
[17:04:33] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:04:46] <brson> tjc: we're doing triage in cya, not the bridge - the meeting was rescheduled there at some point
[17:05:00] <tjc> brson: thanks, I'll be right there
[17:05:33] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:05:34] <orshem> though i'm not clear how it works. is it like c++? i can create different overloaded version for p + p, p + scalar and such
[17:05:52] *** Joins: callen (callen@95EE74F7.F6EF2525.EE6E63A5.IP)
[17:06:01] <maikklein> not sure
[17:06:19] <maikklein> yeah i think so
[17:06:20] <callen> so what happened to cargo and what's the story for package management now?
[17:06:22] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[17:06:33] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[17:07:47] <kimundi> callen: cargo's dead, being replaced by rustpkg. rustpkg will be a decentral pachage manager similar to the way it works in go
[17:07:49] <sebcrozet> orshem: afaik, you cannot have both p + p and p + scalar
[17:08:08] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[17:08:11] <sebcrozet> orshem: because you cannot implement Mul<T, T> for the same type twice.
[17:08:13] <maikklein> orshem, you would have to impl Add<int,Point> and impl Add<Point,Point>
[17:08:21] <sebcrozet> orshem: Add<T, T>*
[17:08:33] <maikklein> btw
[17:08:41] <maikklein> can we do 2 + p?
[17:08:41] <callen> kimundi: that's potentially frightening given how flawed Go's is. Is there going to be versioning and repeatable builds?
[17:09:00] <callen> and a central config file for the package deps?
[17:09:11] <cmr> tjc: ^
[17:09:54] <jedestep> is there a way that a nested module can make all of its contents available to its containing module? pub use self::* throws ICE
[17:10:09] <ecr> maikklein, I think that would involve impl Add<Point, T> for int
[17:10:15] <kimundi> callen: dunno, but the devs are aware of the those problems and try not to have them
[17:10:46] <ecr> not sure if that is allowed
[17:10:48] <tjc> callen: I'm in a meeting right now, but https://github.com/mozilla/rust/blob/master/doc/rustpkg.md documents the state of rustpkg so far
[17:11:26] <tjc> callen: and https://github.com/mozilla/rust/issues?direction=asc&labels=A-pkg&milestone=&page=1&sort=updated&state=open lists what we think remains to be done
[17:11:51] <graydon> #rust-triage fwiw
[17:12:00] <orshem> maikklein, sebcrozet: thanks.
[17:12:06] <callen> tjc: thanks
[17:12:18] *** Joins: therantingnorwegian (Mibbit@moz-D5513CBA.static.snlo.ca.charter.com)
[17:14:14] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[17:14:41] <maikklein> ecr, I don't think you can impl on types that are cross crate, but I think it is possible with primitive types like int
[17:15:05] <Seldaek> callen: building package managers is hard :) but I should take a look at the current state as well, because it would suck if we start off the wrong foot on this front
[17:15:36] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:16:04] <therantingnorwegian> It's hard to use owned pointers in data structures because you can't (even temporarily) un-assign them. I've looked at std::util::(swap, replace), but I need to be able to use the original value in an expression (owned cons, for instance). Are there any plans to support this?
[17:16:12] <ecr> maikklein, that sounds right.
[17:17:09] <callen> Seldaek: the Clojure and Elixir communities did package management and builds pretty nicely. Golang seems to be irreparably damaged since the community isn't really picking up any of the third party alternatives. The internal dev team on Golang isn't interested in fixing it because they do all their builds including deps from one big p4 tree.
[17:17:33] <callen> Seldaek: I'm really exciting about having an alternative to C and C++, I'll be sad if there's a repeat of what Go did.
[17:17:38] <callen> excited*
[17:18:31] <kimundi> callen: what did you see as failure in gos way (never have used it)
[17:18:42] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[17:18:56] <Seldaek> callen: interesting, I didn't use go enough to dive into go get I have to say, but I spent the last two years working on composer (dep manager for php), I'd hope that means I can help a bit
[17:19:00] <ecr> therantingnorwegian: if you need a field that is only sometimes set, then you should use an Option
[17:20:21] <doomlord> (IMO, go was talked about as a c/c++ alternative but it's completely gc based so to my mind it doesn't count)
[17:20:22] <ecr> so you would have something like Option<~Thing>
[17:20:26] <therantingnorwegian> ecr: oh, there's a thought.
[17:21:33] <ecr> therantingnorwegian: usually if you think you want a null pointer, then you really want an Option. It's the way to represent nullability in the type system.
[17:21:40] <therantingnorwegian> I guess if I did list node struct rather than a cons, nil enum I could emulate nullable pointers that way.
[17:22:01] *** Joins: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:22:20] <Seldaek> doomlord: it probably is an alternative for use cases where you don't need 100% control/power, but yeah I hope rust gets closer to that as we progress
[17:22:58] <therantingnorwegian> ecr: thanks!
[17:23:12] *** Quits: therantingnorwegian (Mibbit@moz-D5513CBA.static.snlo.ca.charter.com) (Quit: http://www.mibbit.com ajax IRC Client)
[17:24:15] <ecr> therantingnorwegian: no problem :)
[17:24:49] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[17:24:49] *** ChanServ sets mode: +o pcwalton
[17:26:32] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[17:27:13] <callen> Seldaek: I was impressed with Composer when I used it briefly on a contract project, great work!
[17:28:03] <Seldaek> callen: thanks, it's a neverending project though :/
[17:28:04] <callen> kimundi: there were a number of things, but specific to packaging Golang has no way to manage package versions unless you download and locally host all dependencies as part of your project's version control (which is what Google does for various reasons)
[17:28:14] <callen> Seldaek: no doubt. I don't envy you.
[17:28:18] <Seldaek> hah
[17:28:50] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:28:57] <callen> Seldaek: I talk to the maintainer of Clojure's Leiningen a lot, which is an excellent package mgmt/dependency/build tool, the work never ends for him either. Although I think things have slowed down now that 2.x is out.
[17:29:28] <callen> kimundi: so if you're careless and use a dependency you haven't cached and version-controlled manually, you're potentially rather boned.
[17:29:50] *** Quits: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de) (Ping timeout)
[17:29:53] <callen> kimundi: it also doesn't allow you to manage stdlib/compiler versions at all. You just use whatever's installed.
[17:30:14] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:30:22] <Seldaek> callen: well I mean now I can let things go for a couple weeks and it's alright, mostly it runs well but it's hardly "done". Used to be we had emergencies and critical bugs every second day though so it's not all bad :)
[17:30:28] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[17:30:49] <callen> Seldaek: I'm glad things are starting to settle a bit :)
[17:31:50] *** Quits: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP) (Ping timeout)
[17:32:01] <kmc> cmr: is the Rust calling convention documented anywhere?
[17:36:33] <michaelgreene> hrm. I've gotten "multiple matching crates for `std`" before when I had too many versions of rust installed at once, but right now I am clean with just the very latest version from git.  However, I have -L /usr/local/lib passed in, so that the linker can find some other libraries (zmq in this case).  Any idea how to get around finding both the /usr/local/lib/rustc and the /usr/local/lib version of std (that happen to be the exact same)?
[17:39:00] <bblum> toddaaro: naturally i am awake by the time i respond to you
[17:39:13] <bblum> toddaaro: i dunno, sending from a destructor seems pretty fine to me
[17:39:35] <toddaaro> bblum: hm, I can't reproduce
[17:39:44] <toddaaro> bblum: but the error seems to come from there
[17:40:56] <bblum> that is not enough information for me to help you :P
[17:41:05] <orshem> is there a problem using 'return' in a stack closure?
[17:41:11] <toddaaro> bblum: that is all the information we have, it is a problem
[17:41:17] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:41:17] <toddaaro> bblum: but buildbot failed multiple times
[17:41:27] <toddaaro> we can't reproduce so we can't get a stacktrace
[17:41:37] <bblum> orshem: yeah, i think you're just not allowed to (yet)
[17:41:41] <toddaaro> graydon: can we manually ssh into the buildbot and run tests under gdb?
[17:42:19] <graydon> yes, but later. triage meeting now.
[17:43:01] <toddaaro> brson: I looked at the logging function, that is the newrt problem, should be an easy fix
[17:43:17] <toddaaro> brson: do you know if it needs to be unsafe? seems like try_borrow should work out ok
[17:43:55] <orshem> bblum: the 'yet' is encouraging
[17:45:01] <bblum> orshem: i think consensus is that you should be able to
[17:47:29] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:47:31] <brson> toddaaro: I don't know offhand, no
[17:47:52] <brson> I can't reproduce the bot failure under valgrind either. We'll have to log into the bots
[17:49:52] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[17:49:57] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[17:50:26] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[17:51:43] <Seldaek> brson: how's newrt/io going? I haven't seen a progress email in a while, it'd be good to hear what's up on that front
[17:51:50] *** Joins: azita (Azita@AB6AC589.10601D86.FAF22AF7.IP)
[17:52:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:52:39] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[17:52:53] <brson> Seldaek: we're on the verge of turning newrt on, at which point i'll send out a status update. after that i'll be working on servo porting, using ChrisMorgan's new http library, then pushing hard on I/O
[17:53:04] <Seldaek> alright cool
[17:53:11] <brson> perf is not going to be where we want it yet, but it will likely be better than the current scheduler
[17:54:22] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[17:54:26] *** Quits: deLta30 (quassel@D2C62F7E.24095528.3FEEFD97.IP) (Client exited)
[17:54:36] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[17:56:04] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Connection reset by peer)
[17:56:19] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[17:57:44] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Connection reset by peer)
[17:58:19] *** Quits: paulproteus (quassel@rose.makesad.us) (Quit: Quitters never win.)
[17:58:28] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[18:01:46] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[18:02:35] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[18:02:42] <jedestep> pauls: correct me if I'm wrong, but could syntax::ext::base::MRAny hold @fn() -> Option<~[@item]> instead of @fn() -> Option<@item>?
[18:03:07] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[18:03:16] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[18:03:21] * pauls blinks slowly, several times
[18:03:31] <jedestep> haha, sorry
[18:03:38] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[18:03:46] <pcwalton> there's a serious bug in @Trait I think :(
[18:03:57] <pcwalton> memory corruption in vtables
[18:03:59] <sully> do you have a test case?
[18:04:09] <pcwalton> sully: at the moment my test case is rustc
[18:04:14] <pcwalton> with my 2,000 line patch
[18:04:16] *** Joins: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com)
[18:04:16] <pcwalton> going to try to minimize
[18:04:17] <jedestep> was going back to macros expanding >1 item
[18:04:34] <pauls> It's been a while, so I don't remember much of the necessary context.
[18:04:42] <pcwalton> sully: it has something to do with calling an @mut self method via an @Trait that then casts self to @Trait
[18:04:43] <jedestep> ah ok
[18:04:50] *** Quits: azita (Azita@AB6AC589.10601D86.FAF22AF7.IP) (Quit: azita)
[18:04:55] <pauls> What is MRAny?
[18:05:04] <jedestep> variant of MacResult
[18:05:31] <jedestep> as far as I can tell, the rhs values of macro definitions are stored in that form
[18:05:45] <jedestep> but then again I'm looking at this for the first time so I don't actually know
[18:05:46] <pauls> jedestep: my bet is that the only thing stopping it from holding ~[@item] is that fold.rs doesn't support multiple items.
[18:05:52] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Ping timeout)
[18:05:57] <pauls> (no need to have it be Option, anymore)
[18:06:09] <cmr> kmc: nope
[18:06:15] <cmr> kmc: besides the source, of course.
[18:06:43] <jedestep> yeah it looks like there would need to be a fold_items function or something
[18:06:51] *** Joins: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de)
[18:07:13] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[18:07:26] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[18:07:37] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[18:07:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/_s5Sdg
[18:07:37] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[18:08:46] <kmc> cmr: does it differ from C in how registers are used etc., or just in stuff like __morestack()
[18:09:08] <cmr> kmc: It uses... fastcc's llvm calling convention I think
[18:09:14] * cmr checks
[18:10:37] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[18:10:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MesMyg
[18:10:37] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[18:10:38] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[18:10:38] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Z-b29g
[18:10:38] <ghrust> 13rust/06auto 14bd980bc 15Etienne Millon: mk/tests.mk: fix typo "srcrustllvm"
[18:10:38] <ghrust> 13rust/06auto 140e2a086 15Etienne Millon: mk/tests.mk: remove mention of nonexistent files
[18:10:39] <ghrust> 13rust/06auto 14479809a 15bors: auto merge of #8166 : emillon/rust/clean-tests-mk, r=brson...
[18:10:39] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[18:10:41] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[18:10:48] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[18:10:49] <cmr> kmc: nope, we use the C callinv convention right now
[18:10:59] *** Joins: azita (Azita@AB6AC589.10601D86.FAF22AF7.IP)
[18:11:28] <cmr> it takes pointers to tydescs and stuff though.
[18:11:35] <cmr> it's weird and I don't understand it
[18:15:00] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[18:15:01] *** Quits: maikklein (maik@moz-AEFED0CC.dip0.t-ipconnect.de) (Ping timeout)
[18:15:01] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[18:18:40] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Places to go, people to annoy)
[18:19:22] <brson> graydon: can i get the ip of linux2?
[18:19:36] <brson> need to do some investigation into why toddaaro's pr keeps failing
[18:21:12] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[18:21:32] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[18:24:40] <cmr> pub static EDOOFUS : c_int = 88
[18:24:45] <cmr> That's a new one for me
[18:25:33] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:27:50] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:29:17] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[18:30:25] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[18:30:29] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[18:31:02] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:31:56] <cmr> Ok, I don't understand destructors at all.
[18:31:59] <cmr> When are they called?
[18:32:38] <kimundi> cmr: at the end of the scope afaik
[18:32:48] <strcat> graydon: http://huonw.github.io/isrustfastyet/buildbot/ can see a perf improvement just from migrating those 1200 loops
[18:32:50] <strcat> ;]
[18:33:01] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[18:33:03] <graydon> I noticed
[18:33:18] <strcat> yay sed
[18:33:24] <graydon> very interested to see when the mem graph picks up the change
[18:33:46] <cmr> Might be a while :)
[18:34:55] <strcat> still plenty of them left ;p
[18:35:16] <kimundi> the memory graph has in interesting blocky shape now...
[18:35:29] <bblum> cmr: at end of scope, *or* immediately if the value is assigned to a 'let _'
[18:38:15] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[18:39:06] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[18:40:46] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[18:41:12] *** Joins: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:42:33] <kmc> how would I borrow without a dynamic freeze?  (to replace something even more unsafe)
[18:42:36] <olsonjeffery> brson: what's the diff between PortOne/Port & ChanOne/Chan?
[18:42:37] <kmc> borrow & and transmute to &mut?
[18:43:06] <olsonjeffery> the doc says "a channel/port w/ unbounded size" for Chan<T>/Port<T>
[18:43:14] <toddaaro> brson: any luck reproducing?
[18:43:18] <brson> olsonjeffery: PortOne and ChanOne can only send and recieve a single message, Port/Chan can send any number of them
[18:43:24] <strcat> kmc: & still freezes
[18:43:46] <olsonjeffery> brson: aaaaah. gotcha.. hence the `next` field. guess i shoulda looked at the impls. thanks.
[18:45:39] <sp3d> where would I look for info on the status of methods vs. functions, e.g. x.foo(y) vs. X::foo(x, y)?
[18:46:12] <sp3d> I think I recall that in the long term they should be identical but I'm curious how the present behavior and semantics differ from that
[18:46:37] <brson> toddaaro: I'm logged into the bots and building but it will take a while. Since the test exercises linked failure i'm wondering if the fixes bblum's working on might help, or if it's sensitive to thread scheduling. maybe can be reproduced with some stress testing. will give that a try
[18:47:12] <brson> toddaaro: if we can't figure it out today though I think we'll probably xfail it, even though it's a pretty important test :-/
[18:47:16] <cmr> sp3d: sp3d X::foo where foo isn't an associated function simply isn't allowed
[18:47:18] <cmr> oops
[18:47:24] <sp3d> oh
[18:47:25] <toddaaro> brson: ok, hopefully you find it then
[18:47:30] <bblum> if the error message is not "terminate called after throwing an instance of.." then it's not related to my bug
[18:47:45] <toddaaro> brson: I'm testing an implementation of try_unsafe_borrow::<Task> so logger works, seems to be doing well in the test suite
[18:48:30] <sp3d> cmr: but for associated functions you can still call as x.foo(y)?
[18:48:35] <cmr> sp3d: no
[18:48:39] <toddaaro> brson: it does expose an interesting dilemma, which is that it would be nice to have a function that takes two closures and runs one in the Some branch, the other in the None branch for try_borrow
[18:48:42] <sp3d> oh, no overlap at all? huh
[18:48:52] <cmr> sp3d: Associated functions are like any other associated item, X::foo
[18:48:55] <graydon> acrichto: does 8185 fix cross-crate conditions?
[18:48:59] <toddaaro> brson: but then you can't use the "do" syntax as there are two closures and your code readability dies
[18:49:09] <sp3d> ok, I just could have sworn there was some case where the two syntaxes were equivalent
[18:49:37] <acrichto> graydon: yes, for at least the case that I ran into. There may be more cases where they don't work but so far I think they work just fine. The test case includes catching in one crate while rasing in another
[18:50:30] <brson> toddaaro: indeed that's unfortunate
[18:50:47] <kimundi> sp3d, cmr: But isn't that planned as unified method call sntax?
[18:51:00] <graydon> acrichto: excellent!
[18:51:12] <cmr> kimundi: yes, some name like that
[18:51:13] <toddaaro> brson: it would be really great to have do syntax for multiple closure arguments, but that would be a major change and it is probably too late for that
[18:51:19] <cmr> I thought it was uniform function call syntax
[18:51:21] <cmr> *shrug*
[18:51:54] <kmc> toddaaro: it's unfortunate, however many other languages get by with nothing like 'do' at all
[18:52:03] <brson> toddaaro: you could have one closure that takes an Option<&T>
[18:52:31] <cmr> U?CS not quite as catchy as INHTWAMA
[18:52:33] <toddaaro> brson: that could work, still quite a bit more verbose than would be ideal
[18:52:42] <toddaaro> kmc: yea, and that is a problem for those langauges
[18:52:52] <kmc> sure I just think saying "readability dies" is a bit extreme
[18:53:48] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[18:54:53] <kmc> Rust's "do" is nice, but I am even more pleased when things like that fall out of the basic syntax naturally (as in Haskell)
[18:55:48] <cmr> https://gist.github.com/cmr/82459f5715e673a8e90f
[18:55:54] <cmr> Something is wonky with the destructors here
[18:56:25] <cmr> The destructor is getting called *before the constructor even returns*
[18:56:49] <brson> toddaaro: now that I'm reading it the unwind-resource test case looks a little bogus to me ...
[18:57:05] <cmr> https://github.com/mozilla/rust/blob/master/src/libstd/unstable/dynamic_lib.rs#L43
[18:57:07] <toddaaro> brson: the message send in a drop? according to bblum that should owrk
[18:57:09] <brson> the log on the bot never prints "Sent!", which is the signal for main to exit successfully
[18:57:37] <brson> oh, yeah, it should of course run regardless of the fail
[18:57:49] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[18:57:54] <brson> it doesn't run in the test case
[18:57:55] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[18:58:02] <brson> or hm
[18:58:11] <brson> i bet it's a double-fail
[18:58:17] <brson> it says 'About to send' but never 'Send'
[18:58:27] <brson> *Sent
[18:58:48] <toddaaro> the exception must be coming from the call to send, just need a stack trace to figure out why
[18:59:07] <brson> ah
[18:59:21] <brson> I bet, because the subtask is unlinked that main is exiting before the drop  finishes in the subtask
[18:59:47] <brson> the code for controlling runtime exit is incorrect
[19:00:18] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[19:00:39] <toddaaro> in what way? this is the old runtime code so bugs like this should have been found out long ago?
[19:00:53] <brson> oh right, sigh
[19:01:23] <Florob> Is there any trick to being able to do `use extra::sth;`? I tried `extern mod extra;` as suggested by rustc with the same result...
[19:01:44] <cmr> Florob: What error are you getting, and with what source?
[19:01:56] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[19:02:17] <brson> toddaaro: if i stress test the test case in a loop it reproduces locally
[19:02:20] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[19:02:34] <brson> for i in {0..100}; do i686-unknown-linux-gnu/test/run-pass/unwind-resource.stage2-i686-unknown-linux-gnu || break; done
[19:02:48] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:02:58] <brson> oh, i'm lying still
[19:03:03] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[19:03:07] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[19:03:10] <brson> running 100 times just finishes real fast
[19:03:12] <Florob> cmr, unresolved import for extra, with http://q.zash.se/e154149d.txt
[19:03:40] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[19:03:44] <cmr> Florob: use super::extra, perhaps
[19:04:04] <cmr> glob imports aren't rock-solid yet
[19:04:26] <Florob> cmr, under the presumption that I have extern mod extra in super?
[19:04:34] <cmr> Florob: yes
[19:05:15] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:05:15] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[19:05:18] <toddaaro> brson: oh well, my loop goes for 10k and never fails
[19:05:29] <Florob> cmr, is there any way to have that in the module? I don't really need extra apart from the benchmarking
[19:05:29] <toddaaro> brson: I'm still x64 though so that might be the reason
[19:05:45] <cmr> Florob: You should be able to have `extern mod extra` in the test module
[19:06:04] *** Joins: tautologico (linf@9C795610.A046D081.AB599759.IP)
[19:06:10] <Florob> cmr, I can have it there, it gives me an unresolved import then though...
[19:06:32] <cmr> If it does it's a bug, file an issue for it
[19:06:56] <Florob> Will do.
[19:07:21] <toddaaro> brson: newrt it seems to work at least
[19:10:13] *** Joins: sastry (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP)
[19:11:30] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:11:37] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:11:46] *** Quits: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (Ping timeout)
[19:12:28] <sastry> Hey I have been working on this bug https://github.com/mozilla/rust/issues/7928#issuecomment-21892069 
[19:13:01] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[19:13:33] <sastry> i am newbie to rust. so as pointed by huonw .. I am converting the process::new function to a generic one. and changing all other functions that this function calls to generic ones
[19:13:53] <graydon> acrichto the cross-crate failure, were you seeing it on linux or just mac?
[19:13:59] <graydon> cross-crate conditions
[19:14:31] *** Quits: chii (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:14:54] <sastry> but one function with_argv turns the ~str to @str by cloning and its not implemented by Str trait. I was wonder which Str trait implements the clone trait.
[19:15:47] <cmr> sastry: you can call as_slice().to_managed() I think
[19:16:33] <toddaaro> brson: what tests do you expect to fail in newrt? you mentioned there were a few. I
[19:16:40] <toddaaro> 'm getting a variety of portset issues
[19:17:02] <graydon> sastry: I doubt there need to be any @strs in there though
[19:17:49] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[19:17:54] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[19:18:24] <sastry> :cmr trying it out
[19:19:48] <brson> toddaaro: PortSet doesn't exist on master. some of the morestack tests fail and I have a pr open for them. some of the std tests relating to SingleThreaded fail but I have a patch for them that depends on your branch. beyond that the only problems I'm aware of are the ones bblum is working on
[19:19:55] <brson> relating to linked failure and arc
[19:20:03] <toddaaro> brson: great, so we are really close
[19:20:05] *** Joins: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP)
[19:20:07] <brson> very
[19:20:26] <toddaaro> brson: I'm getting a "used schedtask as greentask" error from one test, not sure which though
[19:20:40] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:20:57] <toddaaro> brson: "fatal runtime error: type error: expected GreenTask, found: SchedTask", it is an rtabort on a few of the task helpers
[19:21:08] <brson> i haven't seen that yet
[19:21:20] <brson> toddaaro: the unwind-resource failure does reproduce on the bot
[19:21:30] <brson> so weird
[19:21:32] <toddaaro> brson: awesome, can you stacktrace?
[19:21:50] <brson> it's a canary kill!
[19:22:05] <toddaaro> what is that?
[19:22:48] <brson> toddaaro: stack segments contain a canary value at the end that must remain untouched, as a sanity check that we don't overflow the stack
[19:22:59] <brson> and this test case is overwriting the canary
[19:23:05] <olsonjeffery> brson: so what do you think about the concept of a FailableFuture<TOk, TErr> ?
[19:23:12] <olsonjeffery> it'd basically be a deferred Result
[19:23:34] <sastry> graydon: it takes each argument and then pushes them onto a vector which requires the managed boxes .. so umm @strs are needed I guess. Anyways the error disappeard after @cmr's fix :)
[19:23:46] <graydon> sastry: which function?
[19:24:23] <steven_is_false> There are no plans to support address space layout randomization in the future right?
[19:24:37] <cmr> steven_is_false: what in rust precludes aslr?
[19:24:41] <cmr> I filed an issue btw
[19:24:45] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:24:46] <toddaaro> brson: what, that is odd
[19:24:49] <steven_is_false> I have no idea?
[19:25:01] <steven_is_false> cmr: Thanks for filing the issue can you give me a link?
[19:25:09] <toddaaro> brson: is this a morestack failure of some sort?
[19:25:12] <brson> olsonjeffery: sounds the same as Future<Result>?
[19:25:16] <graydon> steven_is_false: we ought to be ASLR-friendly
[19:25:17] <toddaaro> brson: but that doesn't make sense, as we don't have growth
[19:25:17] <cmr> https://github.com/mozilla/rust/issues/8189
[19:25:35] *** Quits: LU324 (stuff@9AF4F288.83671C58.1B5D53D7.IP) (Ping timeout)
[19:25:43] <steven_is_false> graydon: Okay, so it's easy to add support it's just not been gotten around to yet?
[19:25:43] <toddaaro> brson: is the canary wrong? could it be confused by the "using the pthread stack in a rust task" nature of the scheduler thread?
[19:25:52] <steven_is_false> cmr: Thank you.
[19:25:53] <cmr> steven_is_false: What support would need to be added?
[19:26:05] <cmr> It should be transparent to the language
[19:26:05] <graydon> steven_is_false: isn't it an OS-provided thing at the loader level?
[19:26:12] <cmr> graydon: that's what I thought
[19:26:15] <steven_is_false> cmr: As I understand position independent code needs to be generated right?
[19:26:16] <olsonjeffery> brson: hm. guess so. i came to it in the context of designing a Promise interface.. where the promise indicates failure to compute the value. but i guess that works just as well..
[19:26:23] <toddaaro> brson: wait nevermind, old runtime
[19:26:35] <olsonjeffery> KISS it is
[19:26:37] <cmr> steven_is_false: we already do that iirc
[19:26:51] <brson> olsonjeffery: ok, so it's not that the Promise is sending an error value, it's that the promise is failing to fulfil the promise?
[19:26:53] <steven_is_false> cmr: Then it should work I guess.
[19:27:02] <steven_is_false> Unless something weird, and unexpected comes up.
[19:27:03] <brson> olsonjeffery: can that functionality be folded into Future?
[19:27:14] <sastry> graydon: with_argv in libstd/run.rs it takes a vector of arguments and converts each argument to a managed box so that they can be pushed. 
[19:27:49] <brson> if the other side of Future is Promise, then where is there room for a separate FailableFuture? would normal Futures be unable to detect that the promise was unfulfilled?
[19:28:05] <graydon> sastry: oh. it's to keep them alive.
[19:28:15] <graydon> sastry: that's a .. pretty bad idiom, imo.
[19:28:22] <graydon> certainly not necessary
[19:28:25] <olsonjeffery> brson: at this time.. ive added anothe variant to FutureState that takes a port to recv() on..
[19:28:44] <olsonjeffery> so i didn't touch the existing API, much
[19:28:54] <olsonjeffery> kind of trying to stay on task and not do a total overhaul of future
[19:29:20] <graydon> sastry: I think that was written a long time ago and is no longer very reasonalbe
[19:29:40] <olsonjeffery> taking it to its logical conclusion.. yeah.. all future helper fns would use Promise behind the scenes
[19:30:10] <sastry> graydon: maybe I can modify it sir ? this is my 3rd day with rust if its in my reach I will definately help :)
[19:30:37] <cmr> sastry: go ahead, the stdlib is fair game
[19:30:39] <graydon> sastry: the caller guarantees the lifetime of all the ~str values in the args array, so you should be fine just calling as_c_str() on each of them
[19:31:24] <graydon> i.e. forget about the tmps array altogether. I think it's redundant.
[19:31:29] <graydon> (I also think that's extremely old code)
[19:31:32] <olsonjeffery> brson: i really do think im just going to go w/ Future<Result> for now..
[19:32:12] <graydon> sastry: similarly the with_envp change below doesn't need to use @fmt!, it can use fmt! on its own
[19:32:18] *** Quits: azita (Azita@AB6AC589.10601D86.FAF22AF7.IP) (Quit: azita)
[19:32:23] <olsonjeffery> i think to really nail down promise-fulfillment-failure you'd want some where you detach if the promise's chan was destroyed w/o sending, which implies a bunch of stuff i don't want to deal with.
[19:32:24] <graydon> sastry: (as the win32 variant does)
[19:33:18] <brson> olsonjeffery: ok!
[19:33:20] * brson lunch
[19:33:40] *** Joins: pnkfelix1 (pnkfelix@moz-43495417.fbx.proxad.net)
[19:34:07] <olsonjeffery> where you detect, even
[19:34:45] <sastry> graydon: ok but we are converting all the ~str's to generic types <S: Str> for compaitablity .. is as_c_str  implemented by str trait ?  
[19:34:57] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[19:35:32] <graydon> it's on StrSlice
[19:36:13] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[19:36:23] <graydon> so you can do .as_slice().as_c_str() I guess?
[19:36:24] <strcat> graydon: almost at the point where every loop is a 'times' or 'uint::range' one... I should really write the external version of that ;p
[19:36:47] <graydon> strcat: indeed. it'll be a really small iter!
[19:37:09] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[19:37:16] <strcat> not sure if our range ones do something special about overflow though
[19:37:44] <cmr> r? https://github.com/mozilla/rust/pull/8193
[19:37:45] <sastry> graydon: instead of as_slice.as_managed ? 
[19:37:55] <strcat> wow they're really awful
[19:37:59] <graydon> sastry: yeah, you want to avoid managed as much as possible
[19:38:10] <strcat> there's a non-inlined huge set of branches?
[19:38:13] <graydon> sastry: we would like libstd to have no use of managed pointers at all
[19:38:17] <sastry> graydon: why sir ?
[19:38:28] <strcat> I guess it's not incredibly bad since it's outside the loop
[19:38:28] <cmr> graydon: Requires GC, less efficient.
[19:38:28] <sastry> graydon: sure :)
[19:38:34] <graydon> sastry: because a substantial part of our user community wants to be able to run with no GC
[19:38:46] <cmr> less efficient than just taking a borrowed pointer, that is
[19:39:00] <cmr> as_managed requires GC *and* an extra copy, which is no good
[19:39:05] <sastry> Whats a gc sir ? @graydon
[19:39:09] <strcat> graydon: or just because they want to write libraries or kernels in rust
[19:39:20] <cmr> sastry: http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29
[19:39:20] <graydon> sastry: garbage collector. "managed" means held-in-the-garbage-collector.
[19:40:13] <cmr> nmatsakis: I stripped down the issue to https://github.com/mozilla/rust/issues/8189
[19:40:26] <graydon> we have multiple kinds of ownership. GC-owned memory is more costly to work with than non-GC.
[19:40:26] <graydon> generally. though in some cases it'll be faster to allocate (in the future)
[19:40:26] <sastry> Sorry .. I thought it meant something related to rust :D
[19:40:26] <graydon> at this point it's more expensive on pretty much everything
[19:40:26] <sastry> ohh I see !
[19:40:26] <strcat> graydon: it's still pretty hard to beat jemalloc
[19:40:26] <strcat> unless it was a moving gc
[19:40:48] <graydon> strcat: I hope it will be eventually.
[19:41:12] <strcat> jemalloc allocates faster than we can call a no-op C function :(
[19:41:26] <graydon> strcat: but I also don't imagine I'm half the allocator-writer that jason evans is
[19:41:32] <graydon> yeah, I know
[19:41:57] <sastry> thanks a lot @graydon @cmr :) I am changing it to as_slice.as_c_str !!! compiling !!! :)
[19:42:13] <strcat> alright a range iterator should be trivial
[19:42:55] <cmr> strcat: it can already be expressed in terms of Counter, I can't imagine it'd be that hard
[19:43:06] <strcat> well, range can
[19:43:19] <strcat> range_step maybe not, due to the overflow check
[19:43:21] <engla> strcat: with a restriction to integers, it can be double-ended and random access right
[19:43:25] <kimundi> strcat: while you're add it, range itarators for both [0 .. N] and [0 .. N) would be nice
[19:43:58] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:48:33] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:49:09] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[19:49:11] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[19:49:31] *** Joins: vosvos (vosvos@moz-9B8AD3A8.vinita.lt)
[19:49:36] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[19:49:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Z-b29g
[19:49:36] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[19:49:44] *** Quits: vosvos (vosvos@moz-9B8AD3A8.vinita.lt) (Quit: Leaving)
[19:49:49] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[19:49:56] *** Quits: sastry (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP) (Quit: CGI:IRC)
[19:50:17] *** Joins: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[19:50:22] <engla> or just for the regular range with One::one() as increment
[19:50:24] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[19:52:31] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[19:52:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VTihvg
[19:52:31] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[19:52:32] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[19:52:32] <ghrust> 01[13rust01] 15bors pushed 11 new commits to 06auto: 02http://git.io/Wv77yg
[19:52:32] <ghrust> 13rust/06auto 146d7a0c8 15blake2-ppc: std: Use `do` blocks instead of `for` with .iter_bytes()
[19:52:32] <ghrust> 13rust/06auto 1402bdf90 15blake2-ppc: extra: Use `do` instead of `for` in extra::iter
[19:52:33] <ghrust> 13rust/06auto 14b18bd78 15blake2-ppc: std: Replace `for` with `do { .. }` expr where internal iterators are used
[19:52:35] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[19:53:12] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:58:01] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:58:48] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[19:59:04] <nmatsakis> cmr: cool
[19:59:06] *** Quits: jesse98 (jjones@6251EDC2.15651213.B46B86FA.IP) (Ping timeout)
[20:01:25] <erickt> nmatsakis: ping
[20:03:41] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[20:03:54] <steven_is_false> cmr: I think I found the bug, and should send in a pull request to fix it soon.
[20:04:58] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[20:05:33] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[20:05:48] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[20:05:48] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:05:51] *** Parts: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) ()
[20:07:57] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[20:09:07] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[20:10:01] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[20:14:15] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:18:19] *** Quits: tautologico (linf@9C795610.A046D081.AB599759.IP) (Quit: tautologico)
[20:20:55] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[20:21:14] <graydon> erickt: nmatsakis has probably gone to bed. he's on paris time.
[20:21:19] *** Joins: zamjam (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP)
[20:21:29] <erickt> graydon: thanks
[20:21:36] <erickt> one day I'll catch him :)
[20:21:37] <graydon> anyone know if it's possible for us to summarize P+Q+R trait bounds in a single trait now?
[20:21:49] <graydon> like trait Summary : P+Q+R { } and then use Summary as a bound?
[20:21:58] <strcat> graydon: yes I think sully fixed the issues with it
[20:22:01] <graydon> ok
[20:22:06] <strcat> at least the ones when you aren't using trait objects
[20:22:15] <kimundi> trait objects might still have problems with them though
[20:22:21] <engla> Don't you need the impl too?
[20:22:35] <engla> just the trivial impl<T: P + Q + R> Summary for T
[20:22:51] <zamjam> hey I have been trying to compile rust using make and I get the error [tidy] error 123
[20:23:16] <kimundi> right, that's something I've been wondering: How is trait inhereitance suposed to work in regards to impls?
[20:23:17] <zamjam> I am running make check -j4
[20:23:43] <kimundi> zamjam: Hm does it say anything else except that number? :P
[20:23:55] <graydon> engla: why would I need an impl?
[20:23:58] *** Joins: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[20:23:58] <kimundi> zamjam: also, -j4 does nothnig for rust
[20:24:07] <graydon> zamjam: did you change anything?
[20:24:17] <kimundi> zamjam: only speeds up the llvm compile of it
[20:24:20] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Changing server)
[20:24:20] <strcat> and the tests
[20:24:24] <strcat> kind of.
[20:24:34] <zamjam> yes .. I added a line somewhere 
[20:24:35] <engla> graydon: there are no implicit trait implementations in Rust? It's not duck typed right
[20:24:42] <kimundi> strcat: aren't they getting slower? :P. They are already multicore
[20:24:52] <strcat> the run-pass ones
[20:24:52] <engla> I think the impl is needed
[20:25:13] <graydon> engla: I guess. I don't understand how inheritance interacts with bounds and impls
[20:25:51] <kimundi> graydon: Neither do I. We need someone to explain! :)
[20:26:03] <engla> summary traits like that came up in the numerical trait discussion. They work fine there, but the trivial impl is needed
[20:27:01] <graydon> ok
[20:27:22] <graydon> and Durable doesn't exist anymore, but 'static does?
[20:27:44] <graydon> but 'static isn't a trait, so can't be used in inheritance. or something.
[20:32:21] *** pnkfelix1 is now known as pnkfelix
[20:32:24] <engla> Durable is gone yeah
[20:32:37] <engla> inheriting from builtin traits like Send doesn't work yet
[20:32:39] <engla> either
[20:33:16] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[20:34:24] *** Quits: zamjam (bzlandfill@C8AEB144.5F4361F8.9105FBCF.IP) (Quit: CGI:IRC (Ping timeout))
[20:34:49] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[20:35:31] <steven_is_false> Inspired by this blog post http://securityblog.redhat.com/2012/12/12/position-independent-executable-pie-performance/ I made this shell script http://pastebin.mozilla.org/2760483 , and found that in my application I had these dynamic relocations http://pastebin.mozilla.org/2760486 . For perfectionism, is it possible to make the crate maps not cause dynamic relocations? Also am I missing any dynamic relocations?
[20:36:34] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[20:36:41] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[20:39:46] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[20:40:54] *** Joins: jesse98 (jjones@6251EDC2.15651213.B46B86FA.IP)
[20:41:15] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[20:41:35] <kmc> how does the compiler know when the dynamic borrow bit on an @mut box can be cleared?
[20:41:54] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[20:41:54] <strcat> when it goes out of scope I guess
[20:41:58] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[20:43:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:43:46] <kmc> when the borrowing ref goes out of scope?
[20:44:05] <kimundi> yeah
[20:44:07] <acrichto> graydon: re cross-crate condition failure -- I didn't test it on linux, but I definitely saw it on mac
[20:44:24] *** Quits: sp3d (a@moz-41A29595.dhcp.stls.mo.charter.com) (Ping timeout)
[20:44:25] <graydon> ok. can you tar up your test and email it to me?
[20:44:31] <kmc> it seems like you could have multiple concurrent borrowings of the same @ box (if you couldn't then I think the dynamic borrow check wouldn't be needed anyway?)
[20:44:34] <graydon> acrichto: or just gist the 2 files
[20:44:37] <graydon> side by side
[20:44:51] <graydon> I'm happy to fiddle, just doing "make the testcases and close the bugs" tidying-day
[20:45:12] <cde> tar it up, before you go go
[20:45:37] <kimundi> haha
[20:45:38] <strcat> kmc: you can only have one exclusive &mut borrow
[20:45:46] <strcat> kmc: you can have any number of & borrows
[20:45:50] <acrichto> graydon: yeah one second... there is a test case in the pull request though
[20:45:52] <strcat> there are 3 freeze states
[20:45:57] <strcat> mut borrow, borrow, none
[20:46:06] <strcat> if it's borrow, it will allow more & borrows
[20:46:11] <strcat> but not &mut
[20:46:17] <strcat> if it's mut borrow, it will not allow any more
[20:46:50] <graydon> acrichto: 8185? 8179?
[20:46:53] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:47:06] <graydon> 8179 I have turned into tests for our testsuite; but it's not testing conditions
[20:47:08] *** Joins: sp3d (a@moz-41A29595.dhcp.stls.mo.charter.com)
[20:47:08] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[20:47:38] *** Joins: tautologico (lymph@9F01D096.92EA1F6.C27E1635.IP)
[20:47:58] <acrichto> graydon: in 8179, also https://gist.github.com/alexcrichton/6135136
[20:48:07] <acrichto> although 8179 uses conditions as well as testing static addresses are the same
[20:48:26] <acrichto> graydon: oh wait 8185 was reading the wrong thing
[20:48:45] <graydon> acrichto: yeah, that thing you just gisted seems to work for me on linux
[20:48:49] <graydon> I'll run my test on mac, thanks
[20:48:52] <graydon> how does it fail for you?
[20:49:01] <acrichto> graydon: I get two separate addresses
[20:49:07] <bjz_> brson: did task::PlatformThread change to SingleThreaded?
[20:49:14] <acrichto> specifically the test case in the bug 8179 fails for me
[20:49:30] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:49:44] *** Quits: mark_edward (quassel@moz-9631ECE3.public.wayport.net) (Ping timeout)
[20:49:51] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Quit: Lost terminal)
[20:49:59] <graydon> acrichto: fails as in fail?
[20:50:05] *** Joins: veddan (viktor@moz-C79BC80B.csbnet.se)
[20:50:09] <graydon> 8179 does too
[20:50:11] <kmc> strcat: but there can be an arbitrary number of immut borrows, so how do we know when to go back to the 'none' state?
[20:50:14] <graydon> I am asking how the conditioin fails
[20:50:14] <acrichto> graydon: yes, just verified that the test case in 8179 fails 
[20:50:26] <acrichto> graydon: oh the condition fails saying "there was no handler"
[20:50:29] <graydon> ok
[20:50:40] <acrichto> that's because when you cal 'trap' it sets a differnet TLS key than 'raise' looks up
[20:50:47] <strcat> kmc: it is stack discipline
[20:50:53] <brson> bjz_: no, there isn't a replacement for PlatformThread atm. in the new runtime it requires overriding start and starting the runtime explicitly with rt::start_on_main_thread
[20:51:02] * brson breaking everything
[20:51:04] <strcat> kmc: they restore the previous state when the borrow is popped from the stack
[20:51:07] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[20:51:08] <brson> brb
[20:51:11] <strcat> kmc: look at how extra::rc::RcMut does it
[20:51:32] <veddan> I'm having some trouble compiling the latest rustc version.
[20:51:35] <strcat> I really think the implicit dynamic borrowing needs to go away
[20:51:50] <kmc> strcat: ok, so the borrowed pointer itself is responsible for remembering the old state
[20:51:55] <kmc> makes sense
[20:51:59] <strcat> kmc: the borrowed pointer doesn't
[20:52:01] <bjz_> brson: what would I do here? https://github.com/bjz/glfw-rs/blob/master/src/glfw.rs#L115
[20:52:09] <veddan> The stage1 rustc segfaults immediately.
[20:52:29] <strcat> kmc: a borrow *from* an @mut is inside a scope
[20:52:40] <bjz_> brson: and yeah no worries, good to hear the transition is starting to occur
[20:52:41] <strcat> the borrowed pointer is just a regular borrowed pointer, nothing special
[20:52:48] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:52:57] *** Quits: sp3d (a@moz-41A29595.dhcp.stls.mo.charter.com) (Ping timeout)
[20:53:42] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[20:54:07] <veddan> It segfaults in task::local_data_priv::get_local_map
[20:54:20] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Ping timeout)
[20:54:46] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:54:46] *** ChanServ sets mode: +o brson
[20:54:53] *** Joins: vcl (chatzilla@A2267643.76F9E272.DA40C4B3.IP)
[20:55:01] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[20:55:01] *** ChanServ sets mode: +o pcwalton
[20:55:06] <brson> Maybe we'll add some sugar to rustc to indicate that you want main to actually run on the main thread
[20:55:37] *** vcl is now known as vadimcn
[20:55:46] *** Joins: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:56:02] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[20:56:32] *** Parts: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) ()
[20:56:45] *** Joins: bobbyrward (bobbyrward@moz-66B120E.triad.res.rr.com)
[20:56:46] <strcat> brson: btw it would be nice to have a lang item for running code before the scheduler starts, for stuff like sandboxing
[20:57:09] <strcat> has to be before it spawns a thread
[20:57:40] <bobbyrward> Can anyone point me to a repo that builds with rustpkg?  trying to figure out how to get this working
[20:57:47] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[20:58:12] <brson> strcat: #[start]
[20:58:39] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[20:58:59] *** Quits: joone (joone@E10A1781.2160464A.A34EC3BB.IP) (Client exited)
[20:59:12] <veddan> bobbyrward: I just tinkered with https://github.com/veddan/rust-htmlescape and got it to build with rustpkg
[20:59:16] *** Quits: sw17ch (sw17ch@moz-6206F951.dia.static.qwest.net) (Quit: sw17ch)
[20:59:24] <brson> overriding #[start] basically dumps you here: https://github.com/mozilla/rust/blob/master/src/libstd/unstable/lang.rs#L142
[20:59:26] <bobbyrward> veddan: thanks
[20:59:27] <brson> with your own implementation
[20:59:29] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[20:59:40] <strcat> ah right
[20:59:43] <brson> this is what you'll have to do in order to call run_on_main_thread
[21:00:06] <Seldaek> oyeah, #[annihilate]
[21:00:08] <bblum> presumably that means you need to start up the scheduler and so forth instead
[21:00:18] <bblum> #[at_start]
[21:00:38] <strcat> brson: when we do support forking, I think we'd need a hook there too
[21:01:05] <strcat> although I don't really know how forking would work in rust
[21:01:11] *** Joins: joone (joone@moz-D3B2E195.jf.intel.com)
[21:01:54] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[21:02:41] <strcat> maybe you'd just manually fork and then start a scheduler yourself
[21:02:58] <pcwalton> I wonder if we can get rid of copy_args_to_allocas if the args are just immediates
[21:03:02] <pcwalton> that could be big for these little functions
[21:03:04] <kmc> strcat: I agree that the dynamic freezes are a major pain point (that's why I'm asking all these weird questions)
[21:03:23] <pcwalton> kmc: I want to kill @mut
[21:03:26] <pcwalton> and replace with Cell
[21:03:39] <pcwalton> which requires you to say when you want to freeze
[21:03:45] <pcwalton> this makes it more obvious
[21:04:21] <kmc> what I'm really trying to do: borrow something with as much /static/ checking as possible, but (unsafely) skip the dynamic freeze
[21:04:23] <strcat> the Cell freezing is more coarse atm, maybe you want to change it though
[21:04:33] <kmc> pcwalton: yeah that would be good
[21:05:04] <strcat> kmc: use RcMut and leak a raw pointer out of the closure? ;p
[21:05:18] <SimonSapin> So, I have a static mapping of 149 strings to RGB tuples: http://www.w3.org/TR/css3-color/#svg-color What can I use (that exists in current Rust) to make lookup fast?
[21:05:32] <kmc> strcat: good idea
[21:05:38] <pcwalton> SimonSapin: a syntax extension that generates perfect hashes
[21:05:40] <SimonSapin> HashMap can not be initialized statically
[21:05:42] <pcwalton> but we don't have such a thing
[21:05:48] <pcwalton> I have a proposal for exactly this ;)
[21:05:55] <SimonSapin> pcwalton: yes, hence the "exists in current rust"
[21:05:58] <pcwalton> exactly the infrastructure that would allow you to do that
[21:06:06] <pcwalton> probably write a python script to generate it
[21:06:09] <pcwalton> generate the rust code
[21:06:10] <pcwalton> sorry :(
[21:06:26] <SimonSapin> Iâ€™m fine with python-generated code, but generating what?
[21:06:43] <pcwalton> generate a perfect hash function like gperf does
[21:06:45] <vadimcn> @pcwalton: you were the author of fast_ffi, right?
[21:06:45] <SimonSapin> Iâ€™ll switch to this syntax when it exists, but what can I do now?
[21:06:46] <kimundi> pcwalton: how would you compute a "perfect hash"?
[21:06:52] <pcwalton> kimundi: same way gperf does
[21:07:00] <pcwalton> steal its algorithm
[21:07:02] <engla> kimundi: you know what set you are mapping to
[21:07:05] <pcwalton> that's what I'd do anyway
[21:07:13] <pcwalton> it basically generates a trie I think
[21:07:53] <veddan> I suppose you could generated a sorted static vec of (&'static str, (u8, u8, u8)) and binary search it. Easy to do compared to perfect hashing.
[21:08:06] <SimonSapin> pcwalton: gperf is GPL :(
[21:08:19] <strcat> cmph is MPL
[21:08:21] <strcat> iirc
[21:08:22] <pcwalton> SimonSapin: yeah, I would just generate a trie
[21:08:28] <pcwalton> oops, accidental underline
[21:08:54] <pcwalton> ooh, neat
[21:09:05] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[21:09:05] *** ChanServ sets mode: +o dherman
[21:09:07] <pcwalton> SimonSapin: CMPH seems fairly awesome
[21:09:45] <pcwalton> has high level descriptions of algorithms too so can be implemented from first principles
[21:09:53] <SimonSapin> looks cool
[21:10:01] <strcat> I used cmph once
[21:10:15] <strcat> I tried gperf but it falls down after a few thousand or so keys
[21:10:21] <strcat> and I had a lot ;p
[21:11:23] <bblum> brson: i just confirmed that making send() not reschedule fixes the ARC test cases with RUST_THREADS=1 RUST_NEWRT=1; i still have to actually make a polished interface for it, but in the meantime, https://github.com/mozilla/rust/pull/8195
[21:11:29] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[21:11:34] <bblum> (the other bug is fixed, and some cleanup)
[21:12:29] *** Quits: Ms2ger (Ms2ger@moz-BA3429A8.adsl-dyn.isp.belgacom.be) (Quit: nn)
[21:13:02] <SimonSapin> dual licensed means I get to decide which I like, right?
[21:13:11] <strcat> yes
[21:13:20] <SimonSapin> Is MPL 1.1 compatible with MPL 2?
[21:14:05] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[21:14:16] <brson> bblum: I'm very worried about these relaxed atomics
[21:14:38] <brson> there's no way we can know they are correct. we're not testing on arm hardware
[21:14:49] <brson> it's ambitiously clever
[21:15:02] *** Joins: sprocket (Mibbit@moz-93DE165F.pool.mediaways.net)
[21:15:36] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[21:15:38] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[21:16:15] <bblum> well... yes, that is true
[21:16:59] <strcat> SimonSapin: I'm not sure if it matters that gperf is GPL though
[21:17:01] <brson> pcwalton: r? https://github.com/mozilla/rust/pull/8170
[21:17:12] <strcat> SimonSapin: the code it generates isn't GPL, and you don't have to link against it
[21:17:23] <strcat> cmph is likely the same way, maybe not
[21:17:23] <bblum> brson: see if the reasoning in the documentation commit convinces you though
[21:17:36] <bblum> brson: i'm willing to leave the ones in kill.rs as SeqCst if necessary
[21:17:40] <SimonSapin> strcat: I have no idea
[21:17:50] <bblum> but i am pretty convinced they are right
[21:19:11] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[21:19:56] * graydon sighs, gives up (again) on trying to upgrade rparse to language changes
[21:20:07] <sprocket> hey there, quick question:
[21:20:10] <sprocket>  is there a way to determine the exact type of a generic T:Trait during runtime?
[21:20:25] <vadimcn> pcwalton: me and acrichto were discussing https://github.com/mozilla/rust/pull/7115 just now.   Since you are the original author of fast_ffi, would you care to chime in?
[21:20:31] <strcat> sprocket: no
[21:20:59] <pcwalton> vadimcn: hmmm
[21:21:01] <vadimcn> pcwalton: is it possible that function marked up with [fast_ffi] does not get a large stack segment?
[21:21:15] <pcwalton> perhaps the "fixedstacksegment" attribute is getting lost somehow.
[21:21:27] <pcwalton> make sure the generated LLVM IR has the fixedstacksegment attribute for that funtion
[21:21:28] <acrichto> pcwalton: what's the difference between fast_ffi and not?
[21:21:47] <pcwalton> fast_ffi uses the fixedstacksegment attribute to make the generated assembly request a large stack in morestack.
[21:21:56] <pcwalton> without fast_ffi, an explicit C stack switch is used.
[21:22:19] <acrichto> pcwalton: so C functions are called "inline" except that the function right before them requests a "huge" stack which may only result in a stack switch sometimes?
[21:22:20] <pcwalton> fast_ffi would go awry if the attribute (a) was getting lost; (b) was getting ignored
[21:22:25] <pcwalton> acrichto: right
[21:22:33] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[21:22:36] <acrichto> pcwalton: so if the fixed stack segment size were too small things would also go wrong?
[21:22:39] <sprocket> too bad. i can call a function like sys::size_of_val, but not type_of_val?
[21:22:42] <pcwalton> yes
[21:22:44] <olsonjeffery> farewell proto!, we hardly knew thee.
[21:22:55] <acrichto> pcwalton: that's my working hypothesis right now because it's only 2MB
[21:22:59] <strcat> sprocket: we just don't expose a way to get a type
[21:23:03] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[21:23:07] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:23:10] <acrichto> pcwalton: and this works unless you run LLVm with optimizations (which may have gotten more recursive in 3.3 than 3.2)
[21:23:12] <strcat> I guess there hasn't been a use case
[21:23:14] *** Quits: nwf (nwf@moz-E26BF8D7.rr.ietfng.org) (Ping timeout)
[21:23:23] <acrichto> it'll just take awhile to test
[21:23:32] <vadimcn> acrichto: 2MB stack ought to be enough for anyone :)
[21:23:48] <acrichto> vadimcn: I would hope so... but just in case I want to rule this out
[21:23:55] <vadimcn> default stack size on win32 is 1MB
[21:24:05] <acrichto> win32 auto-grows the stack though I think?
[21:24:24] <vadimcn> Yes, but you still need to reserve the address space
[21:24:26] <kmc> error: unresolved name `RcMut`. Did you mean `id`?
[21:24:31] <kmc> sure, the keys are right next to each other
[21:25:02] <vadimcn> One you run out of 1MB, you cannot extend it further
[21:25:11] *** Quits: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com) (Quit: pcwalton)
[21:25:39] *** Joins: nwf (nwf@moz-E26BF8D7.rr.ietfng.org)
[21:26:22] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[21:26:33] *** Joins: lkuper (lkuper@215593FA.A402E718.C082B7DC.IP)
[21:29:02] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[21:29:10] <thomaslee> graydon: can I trouble you for your thoughts on how https://github.com/mozilla/rust/issues/3319 would ideally be addressed?
[21:30:31] *** Joins: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP)
[21:30:59] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:31:01] <bjz_> brson: so it would be tricky to do https://github.com/bjz/glfw-rs/blob/master/src/glfw.rs#L115 atm?
[21:31:35] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[21:31:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Wv77yg
[21:31:36] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[21:32:01] *** Quits: askalski (akuda@2BA4E5A7.CC7751E8.6712E96B.IP) (Quit: Wychodzi)
[21:32:13] *** Quits: lmandel (lmandel@CD1A664D.7ECD71DF.ADB88A9.IP) (Ping timeout)
[21:34:04] *** Joins: lmandel (lmandel@moz-78664AAB.dsl.bell.ca)
[21:34:32] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[21:34:32] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HnnCVA
[21:34:32] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[21:35:51] *** Quits: sprocket (Mibbit@moz-93DE165F.pool.mediaways.net) (Quit: http://www.mibbit.com ajax IRC Client)
[21:37:33] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[21:37:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HnnCVA
[21:37:33] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[21:37:35] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:37:35] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/yNh_Aw
[21:37:35] <ghrust> 13rust/06auto 144b3e766 15Brian Anderson: Remove the pipes compiler...
[21:37:35] <ghrust> 13rust/06auto 14eb5743b 15bors: auto merge of #8170 : brson/rust/nopipes, r=pcwalton...
[21:37:36] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:37:38] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:37:43] <bjz_> Jeaye: I'm having troule with spawning glfw on the platform thread atm
[21:37:58] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[21:38:06] <bjz_> Jeaye: don't update your Rust if it is currently working for you
[21:38:36] <strcat> graydon: iterator::Range::new(0, 10) or just iterator::range(0, 10)?
[21:38:37] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[21:38:46] <SiegeLord> bjz_, That's possible to do? I was thinking of whether it could be done for a C library with thread local storage the other day...
[21:38:47] <strcat> the hardest part is always naming things ;p
[21:38:52] *** Joins: Ralith (ralith@moz-DEBA35B4.wireless.sfu.ca)
[21:39:01] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[21:39:24] <Jeaye> bjz_: Much appreciated. I was planning on updating today.
[21:39:37] <bjz_> SiegeLord: it used to be, but brson says it was removed in the transition to the new rt
[21:39:52] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[21:40:08] <SiegeLord> I think it's a pretty useful feature... I guess glfw wants it for the OSX nonsense?
[21:40:27] <SiegeLord> Something about OS events only handleable on the main thread iirc
[21:40:36] <bjz_> SiegeLord: basically glfw needs the events from the main event loop
[21:40:49] <bjz_> yeah
[21:40:58] <bjz_> I think that's it
[21:41:28] <strcat> meh I'll just go with range(0, 1)
[21:41:29] <Eridius> rust-lang.org is nonresponsive for me. Can anyone else get to it?
[21:41:39] <SiegeLord> Works fine here
[21:41:44] <strcat> Eridius: nope
[21:41:59] <strcat> oh there it is
[21:42:00] <Eridius> just came back up
[21:42:15] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:43:02] <bjz_> Jeaye: this was my plan for the shared window thingy: https://gist.github.com/bjz/ac0d3f1cb792e94a5841
[21:43:18] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[21:43:22] <bjz_> Jeaye: not sure how it'd play with the window destructor
[21:43:41] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[21:43:47] <bjz_> Jeaye: could you test it for me?
[21:45:54] <Jeaye> bjz_: I can put a bit of time in now, but I'll be able to dedicate more tonight after work.
[21:46:11] <Jeaye> Let's see if it compiles. :P
[21:46:18] *** Quits: nwf (nwf@moz-E26BF8D7.rr.ietfng.org) (Ping timeout)
[21:46:38] *** Joins: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:46:43] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[21:46:46] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[21:46:59] <kimundi> strcat: iterator::range() and iterator::counter() for the simple cases seem to be nice than the strict Type::new approach
[21:47:02] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[21:47:12] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[21:47:12] <strcat> kimundi: well, range() and count()
[21:47:16] <strcat> I think
[21:47:26] *** Quits: eschweic1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[21:47:29] <strcat> not sure anyway
[21:47:37] *** Joins: tcr (tcr@moz-965BB009.mycingular.net)
[21:47:49] <strcat> starting to dislike ::new ;p
[21:48:14] <kimundi> strcat: Rationale can be "Iterators main diffierence is the semantic, the actual type of an iterator(adapter) is usually not important for using them"
[21:48:47] <kimundi> like, for iterators we just care about them returning a type that Implements Iterator
[21:49:15] <Jeaye> bjz_: line 3 should be create_shared :P Other than that, it compiles. Let's see if it still works normally (without sharing)
[21:49:42] <brson> bjz_: yes, though you can force glfw users to opt into the new runtime. exes have to override #[start] then probably call some a glfw function that encapsulates the runtime initialization by calling std::rt::start_on_main_thread
[21:49:51] <strcat> for x in Range::new(0, 10) {}
[21:49:57] <strcat> for x in range(0, 10) {}
[21:49:58] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:50:05] <strcat> it's not that bad with ::new anyway
[21:50:23] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:50:34] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[21:52:08] <engla> range(a, b) is nice
[21:52:10] *** Joins: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[21:52:23] <engla> strcat: what do you think about moving std::iter::Times to either iterator or num?
[21:52:57] *** Quits: tcr (tcr@moz-965BB009.mycingular.net) (Ping timeout)
[21:52:59] <strcat> engla: I think I'd rather just replace it with range
[21:53:09] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:53:10] <strcat> closures as loop bodies are just annoying/slow
[21:53:28] <strcat> a 20% improvement in compile-time from migrating 1200 loops to foreach shows how bad it is
[21:53:38] <engla> that's a good point. I like the way   do 2.times { ... }   looks though
[21:53:49] <strcat> yeah it looks good but the errors are quite annoying
[21:53:50] *** Quits: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[21:53:56] <strcat> for _ in range(0, n) { } is okay
[21:53:57] <Eridius> could we rewrite times to be an iterator that just returns ()?
[21:54:06] <strcat> Eridius: it'd still be
[21:54:06] <kimundi> for _ in 5.times {...}
[21:54:09] <strcat> that
[21:54:17] *** Joins: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com)
[21:54:18] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[21:54:22] <strcat> it's not much more convenient than just using range
[21:54:25] <Jeaye> bjz_: Normal functionality is working for q3. I'll test the shared context tonight. :)
[21:54:30] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:54:33] <Eridius> yeah I was about to suggest tweaking the for sugar to skip the pattern binding entirely if the type is (), but that would only ever be used for this one function, which is a bad idea
[21:55:01] <engla> .times is used in a lot of places and only 4 out of ~150 occurences needed range to be able to break or return. the rest were plain repeats
[21:55:18] <Eridius> either that or just allow omitting the pattern binding entirely if you don't care about the values, but I'm not sure when you'd use a for loop and not care about the values except for .times
[21:55:28] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[21:55:34] <strcat> right but they're still hurting compile-time a lot, and they are resulting in captures that could be annoying
[21:55:37] *** Joins: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[21:55:58] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[21:56:21] <SimonSapin> FWIW, perfect hashes look fun but way overkill for me, at least for now. I went with a &'static [(&'static str, Color)] generated by a Python script (to make sure it is sorted), and vec.bsearch
[21:57:01] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[21:57:08] *** Quits: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Connection reset by peer)
[21:57:15] <Eridius> wow, with the foerach changes, and with --disable-lvvm-assertions, that compile was _fast_
[21:57:18] <strcat> I'm not really sure how to write Range/Counter without Clone though...
[21:57:18] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[21:57:21] <Eridius> *foreach
[21:57:22] *** Quits: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[21:57:24] *** Quits: lmandel (lmandel@moz-78664AAB.dsl.bell.ca) (Ping timeout)
[21:57:52] <strcat> although the internal iterator one has the same problem anyway
[21:58:07] <engla> why not use clone?
[21:58:28] <bblum> brson: you said you wanted me to make a separate trait for send-no-resched?
[21:58:32] <strcat> I guess it's fine
[21:58:33] *** Joins: sp3d (a@moz-41A29595.dhcp.stls.mo.charter.com)
[21:58:34] <SimonSapin> Does &str implement TotalOrd?
[21:58:37] <bblum> brson: i'm thinking SendDeferred as the name
[21:58:38] <strcat> yes
[21:58:41] <strcat> SimonSapin: 
[21:58:59] <bblum> SimonSapin: no. all strings are equal but some strings are more equal than others.
[21:59:03] <strcat> rusti: "foo".cmp(&("foo"))
[21:59:03] -rusti- Equal
[21:59:04] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[21:59:07] <strcat> rusti: "foo".cmp(&("foob"))
[21:59:07] <tikue> bblum: lol
[21:59:08] -rusti- Less
[21:59:08] <Eridius> hrm, how do you turn off benchmarks in make check? Or is that not possible?
[21:59:12] <SimonSapin> strcat: another documentation bug I suppose
[21:59:21] <strcat> SimonSapin: what do you mean?
[21:59:52] <strcat> it's in str.rs
[21:59:52] <SimonSapin> strcat: I mean that I didnâ€™t find that info in the docs for either std::cmp or std::str
[22:00:16] <bblum> brson: or should i just make it a separate method on chanones and chans?
[22:00:25] <strcat> SimonSapin: http://static.rust-lang.org/doc/std/str_traits.html
[22:00:30] <strcat> they're in a submodule for whatever reason
[22:00:45] <SimonSapin> I was looking at http://static.rust-lang.org/doc/std/str.html
[22:01:11] *** Quits: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:01:23] <strcat> Module str::not_utf8
[22:01:24] <strcat> Module str::raw - Unsafe operations
[22:01:26] <strcat> Module str::traits
[22:01:28] <strcat> at the bottom
[22:01:56] *** Joins: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:02:08] *** Quits: erickt2 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:02:44] <brson> bblum: I think it should be a separate trait. Other types implement the GenericPort and GenericChan traits where send_deferred doesn't mean anything.
[22:02:49] <brson> SendDeferred is fine
[22:03:23] <brson> oh, but ChanOne doesn't implement any traits, so I guess it just goes directly on the ChanOne impl
[22:03:27] <bblum> ok, ChanOne doesn't implement the traits though
[22:03:27] <bblum> yeah
[22:03:42] <bblum> ok, so trait for stream, extra method for oneshot
[22:03:47] <brson> yes
[22:04:35] *** Quits: DoomBoom (DoomBoom@6B14631A.ACEC7723.5D1D3FEF.IP) (Quit: Leaving)
[22:05:08] <steven_is_false> I don't follow how does one set --disable-assertions for Rust's configure script?
[22:06:02] <acrichto> vadimcn and I finally found what's blocking llvm upgrades: https://github.com/mozilla/rust/issues/8199
[22:06:20] <Eridius> strcat: ./configure --disable-llvm-assertions
[22:06:24] <Eridius> err steven_is_false ^
[22:06:40] <strcat> well, going to go with Range::new for now
[22:06:44] <strcat> we can talk about the convention later
[22:06:47] <steven_is_false> Gah! I didn't rebase against master.
[22:06:53] <steven_is_false> That's why it wasn't working.
[22:07:21] <brson> what does -D warnings do?
[22:07:31] <strcat> brson: prevents you from having any warnings
[22:07:45] <strcat> rusti: #[deny(warnings)] fn foo() { let x = 5; }
[22:07:46] -rusti- <anon>:5:42: 5:43 error: unused variable: `x` [-D unused-variable (default)]
[22:07:46] -rusti- <anon>:5          #[deny(warnings)] fn foo() { let x = 5; }
[22:07:46] -rusti-                                                    ^
[22:07:46] -rusti- error: aborting due to previous error
[22:07:46] -rusti- application terminated with error code 101
[22:07:56] <strcat> it's like -Werror
[22:08:12] <brson> strcat: so if the crate then adds #[warn(foo)] then -D warnings turns foo into an error?
[22:08:20] <strcat> brson: don't know ;]
[22:08:23] <brson> I'm wondering why we continue to have compiler warnings
[22:08:40] <brson> as evidenced by https://github.com/mozilla/rust/pull/8197
[22:08:47] <brson> I thought we were on lockdown
[22:08:56] <strcat> brson: we don't deny them for anything but libstd/libextra afaik
[22:09:16] <acrichto> brson: warnings aren't denied when building a test crate
[22:09:27] <brson> i see
[22:09:29] <acrichto> brson: but yes, #[warn] with a -D warnings will generate an error
[22:09:55] <acrichto> I thought warnings as errors during tests might just be annoying, but we could change that as well
[22:09:57] <kmc> strcat: unfortunately, refactoring my code to use RcMut will be a huge pain :/
[22:10:12] <strcat> kmc: well, at some point @mut is going to lose those implicit borrows ;p
[22:10:28] <brson> i think we should not have the build emit warnings anywhere, for appearances
[22:10:37] <kmc> or disappear entirely, yeah
[22:10:56] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Connection reset by peer)
[22:10:58] <acrichto> brson: I'd be a fan of -D warnings for libsyntax/librustc and -A warnings for all tests
[22:11:10] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[22:11:34] <strcat> I don't think there's any reason to allow them in the test harnesses
[22:11:40] <strcat> just in run-pass/compile-fail stuff
[22:11:47] <acrichto> oh no only for the --test type tests
[22:12:20] <acrichto> oh wait, nevermind, I just figured that they're mostly "you may want to fix this" type things which may be just annoying during tests
[22:12:51] <strcat> you can build the libstd/libextra/libsyntax/librustc test harnesses without even building a compiler though
[22:13:28] <acrichto> doesn't always work though because a librustc change may require an updated libsyntax
[22:13:49] <strcat> true, but you can use the stage1 target for that - right?
[22:13:55] <acrichto> yeah
[22:14:01] <bobbyrward> Can someone help me understand this error?  https://gist.github.com/bobbyrward/6135810 code here: http://bit.ly/1bPGOxj
[22:14:17] *** Joins: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[22:14:32] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[22:14:40] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[22:15:23] <Eridius> bobbyrward: stream is a function that's provided as part of the prelude
[22:15:28] <strcat> acrichto: -D warnings is somewhat annoying though because I'd like to be able to turn on the deprecated_for_loop warning before they are all fixed
[22:15:30] <Eridius> bobbyrward: your handle_request takes an argument "steam"
[22:15:39] <Eridius> bobbyrward: I suspect you meant to take the argument "stream"
[22:15:42] *** Quits: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Connection reset by peer)
[22:15:42] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[22:15:44] <bobbyrward> welp.  thanks
[22:16:20] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[22:16:33] <Eridius> hrm, I got an abort trap 6 while running `make check-stage1-std`. It's not reproducible though. What's abort trap 6?
[22:16:41] <acrichto> strcat: in theory that's nice but from what I've seen a warning is actually more of an indication of you should always disallow it or you should always allow it
[22:16:45] <strcat> Eridius: just an abort
[22:16:49] <acrichto> strcat: 
[22:16:50] <strcat> SIGABRT is 6
[22:17:04] <acrichto> strcat: it'd be a shame to introduce deprecated for loops and then have a build with 200 warnings for 2 weeks
[22:17:05] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[22:17:05] <Eridius> ok, why would stdtest-x86_64-apple-darwin have received a SGIABRT?
[22:17:19] <Eridius> s/SGI/SIG/
[22:17:20] <strcat> acrichto: they will be gone in 2 days if people see the warnings and fix them
[22:17:30] <acrichto> that is true
[22:17:31] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[22:17:39] <acrichto> but they would also be fixed immediately if it was an error
[22:17:50] <strcat> acrichto: yeah but then I have to fix *all* the uses of for
[22:17:55] <strcat> and people will still be adding more as I try
[22:18:11] <strcat> I'm close to done anyway
[22:18:12] <strcat> but...
[22:18:19] <acrichto> strcat: which is unfortunate, but you could fix in batches and then at the end turn the errors on (which may bounce once or twice but not forever)
[22:18:23] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[22:18:25] <strcat> I can see that this is something you might want for a transition
[22:18:28] <strcat> acrichto: true
[22:18:40] <engla> if you fix all range loops now there won't be many left
[22:18:43] <acrichto> eh I dunno, I'm basically in the boat of "I don't like warnings" and they just keep creeping in
[22:21:25] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[22:21:58] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 24.0a2/20130726004002])
[22:22:11] <engla> strcat: heh, my changes ended up adding more for loops too where I was converting internal iterators to external using .advance
[22:22:29] <Eridius> we have unsafe global variables now?
[22:22:38] <strcat> yes
[22:22:40] <strcat> static mut
[22:22:53] <Eridius> does that require living inside an unsafe {} block to write?
[22:22:57] <strcat> or read
[22:23:02] <Eridius> rusti: static mut x: int = 3; unsafe { x }
[22:23:04] -rusti- 3
[22:23:09] <Eridius> rusti: static mut x: int = 3; x
[22:23:09] -rusti- <anon>:5:32: 5:33 error: use of mutable static requires unsafe function or block
[22:23:10] -rusti- <anon>:5          static mut x: int = 3; x
[22:23:10] -rusti-                                          ^
[22:23:10] -rusti- error: aborting due to previous error
[22:23:10] -rusti- application terminated with error code 101
[22:23:49] *** Joins: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP)
[22:24:13] *** Quits: Ralith (ralith@moz-DEBA35B4.wireless.sfu.ca) (Ping timeout)
[22:26:11] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[22:26:29] <strcat> this is going to make integer literals defaulting to int really suck
[22:27:03] <strcat> would be so much better to not have that fallback imo
[22:27:07] <acrichto> strcat: it looks like the llvm upgrades might actually get through bors this time, would it be better to upgrade to current llvm trunk instead of just our own patches on 3.3?
[22:27:22] <strcat> acrichto: trunk makes more sense because they don't do stable releases
[22:27:27] <strcat> like, they *do*
[22:27:30] <strcat> but they don't support them
[22:27:32] <bblum> brson: ok, so the rationale for the relaxed swaps was convincing enough?
[22:27:42] *** Quits: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net) (Ping timeout)
[22:27:48] <acrichto> strcat: are there fancy things which we'd want between 3.3 and now?
[22:28:00] <strcat> acrichto: yes, loop-vectorize is much better and on at -O2 in clang
[22:28:06] <strcat> and soon SLP vectorize will be on by default
[22:28:09] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[22:28:12] <olsonjeffery> can anyone help with this error.. seems ~object related? https://gist.github.com/olsonjeffery/6135919
[22:28:41] <acrichto> strcat: hmm... ok, I'll try to rebase our own patches on top of llvm trunk tonight and then push the llvm-upgrades request through
[22:28:52] *** Joins: tcr_ (tcr@moz-5DED128E.mycingular.net)
[22:28:53] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[22:28:55] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[22:28:59] <bblum> olsonjeffery: i believe that's the problem where traits-as-types don't actually implement their own traits
[22:29:25] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[22:29:35] <bblum> olsonjeffery: see https://github.com/mozilla/rust/issues/7914
[22:29:40] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[22:29:53] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[22:29:55] <bblum> not sure if that's your bug because it depends on the types of other stuff
[22:30:15] *** Quits: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu) (Ping timeout)
[22:30:57] <Eridius> after looking at the Str trait, and seeing the suggested usage in https://github.com/mozilla/rust/issues/7928, I'm kind of tempted to say to_owned() should be part of Str. The impl for &str would stay the same, but the impl for ~str would just return self directly
[22:31:26] <Eridius> this way you can take a Str if you want, and if you need to use it as a ~str instead of a &str, you can skip the copy if it turns out the source value was already a ~str
[22:31:48] *** Quits: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru) (Quit: dim-an)
[22:31:52] <Eridius> does this make sense?
[22:31:57] <kimundi> Eridius: But then to_owned() needs to consume self
[22:32:16] <kimundi> which would be annoying
[22:32:34] <Eridius> hmm
[22:33:07] <dbaupp> Eridius: it could have `into_owned()` which would consume self
[22:33:15] <kimundi> To make a copy of a slice without consuming the slice itself you'd have to do (&s).clone().to_owned()
[22:33:20] *** Joins: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP)
[22:33:21] *** Quits: tcr_ (tcr@moz-5DED128E.mycingular.net) (Client exited)
[22:33:26] <Eridius> dbaupp: that may be the right way to go
[22:33:35] <engla> kimundi: slices copy implictly, shouldn't be a problem
[22:33:38] * dbaupp has forgotten if `into` is the conventional prefix
[22:33:52] <strcat> to_
[22:33:53] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[22:33:58] <Eridius> dbaupp: ascii uses into_ascii and into_bytes
[22:33:59] *** Joins: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net)
[22:34:00] <erickt1> dbaupp / Eridius: I also saw .be_owned() as another alternative
[22:34:07] <Eridius> to indicate that they consume self
[22:34:14] <engla> (as in, no clone needed)
[22:34:20] <dbaupp> strcat: what's the prefix for ones that allocate then?
[22:34:29] *** Joins: tcr (tcr@moz-5DED128E.mycingular.net)
[22:34:32] <brson> bblum: i haven't read it, no
[22:34:34] <strcat> dbaupp: there isn't one
[22:34:38] <Eridius> judging by std::acsii, to_ allocates and into_ consumes self
[22:34:44] <strcat> dbaupp: rarely makes sense to have both
[22:34:47] <engla> dbaupp: I think it's to_
[22:34:48] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Client exited)
[22:34:56] *** Joins: nwf (nwf@moz-E26BF8D7.rr.ietfng.org)
[22:35:02] <dbaupp> https://github.com/mozilla/rust/issues/7151
[22:35:25] <strcat> almost every case of ones copying existing is a bug
[22:35:29] <bblum> brson: ok, it's the sort of thing i want more pairs of eyes to approve
[22:35:42] <bjz_> brson: so should I just wait?
[22:35:43] <bblum> brson: it's just the last paragraph in the doc comment; the rest is stuff you already know
[22:36:19] *** Quits: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net) (Ping timeout)
[22:36:38] <Eridius> rusti: trait Foo { fn foo(self) -> ~str } impl<'self> Foo for &'self str { fn foo(self) -> ~str { self.to_owned() } } let x = &"test"; (x.foo(), x)
[22:36:39] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/GPTI
[22:36:49] <Eridius> rusti: trait Foo { fn foo(self) -> ~str; } impl<'self> Foo for &'self str { fn foo(self) -> ~str { self.to_owned() } } let x = &"test"; (x.foo(), x)
[22:36:50] -rusti- (~"test", "test")
[22:37:00] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:37:27] <Eridius> rusti: trait Foo { fn foo(self) -> ~str; } impl<'self> Foo for @str { fn foo(self) -> ~str { self.to_owned() } } let x = @"test"; (x.foo(), x)
[22:37:28] -rusti- (~"test", @"test")
[22:37:47] <Eridius> hmm, that seems to work. So to_owned() could in fact consume self without a problem it seems
[22:37:51] *** Joins: Voomer (Voomer@moz-CC05FF5E.hsd1.wa.comcast.net)
[22:37:53] <Eridius> rusti: trait Foo { fn foo(self) -> ~str; } impl<'self> Foo for &'self str { fn foo(self) -> ~str { self.to_owned() } } let x = &mut "test"; (x.foo(), x)
[22:37:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AjEi
[22:38:07] <Eridius> pfft
[22:38:11] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[22:38:52] <bjz_> rusti: enum Void {} fn uncallable(x: Void) -> Void { x }
[22:38:53] -rusti- ()
[22:38:56] <bjz_> :D
[22:39:07] <bjz_> uncallable function
[22:39:41] <strcat> rusti: enum Void {} fn uncallable(x: Void) -> Void { x } unsafe { let x: Void = std::cast::transmute(()); uncallable(x) }
[22:39:42] -rusti- rust: task failed at 'enum value matched no variant', /build/rust-git/src/rust/src/libstd/repr.rs:520
[22:39:42] -rusti- rust: domain main @0x1112100 root task failed
[22:39:42] -rusti- application terminated with error code 101
[22:39:54] <bjz_> :D
[22:39:55] <strcat> rusti: enum Void {} fn uncallable(x: Void) -> Void { x } unsafe { let x: Void = std::cast::transmute(()); uncallable(x) };
[22:39:55] -rusti- ()
[22:39:57] <strcat> breaks fmt!
[22:40:01] <strcat> ;p
[22:40:08] <bjz_> dand
[22:40:09] <bjz_> haha
[22:40:15] <toddaaro> brson: I rebased my branch on top of master, with the try_unsafe_borrow fix for logger, passed check-stage0std, running full suite now
[22:40:25] <strcat> bjz_: but yeah you're right ;p
[22:40:29] * strcat is just silly
[22:40:33] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[22:40:35] *** Joins: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com)
[22:40:35] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:40:52] <bjz_> strcat: part of the lovely algebra of adts
[22:41:45] <strcat> goodbye uint::range
[22:41:59] <toddaaro> brson: I was unable to reproduce the testrunner failure in newrt before I started to this, I'll see if master does the same thing soonish
[22:42:09] <toddaaro> brson: (unable to reproduce in gdb)
[22:42:16] <strcat> I wish we could implement a default method *for certain trait bounds*
[22:42:18] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[22:42:21] <miloshadzic> how do I iterate of characters in a string?
[22:42:28] <strcat> iter()
[22:42:39] <brson> bblum: I don't think it's prudent to be writing relaxed atomics, don't think I have the expertise to say whether it's correct, and we don't have the hardware to test that it might be correct
[22:42:47] * miloshadzic slaps himself
[22:42:58] <miloshadzic> strcat, thanks
[22:43:15] <strcat> rusti: let x = "foo"; foreach c in x.iter() { printfln("%?", c) }
[22:43:16] -rusti- <anon>:5:48: 5:56 error: unresolved name `printfln`.
[22:43:16] -rusti- <anon>:5          let x = "foo"; foreach c in x.iter() { printfln("%?", c) }
[22:43:16] -rusti-                                                          ^~~~~~~~
[22:43:16] -rusti- error: aborting due to previous error
[22:43:16] -rusti- application terminated with error code 101
[22:43:18] <strcat> rusti: let x = "foo"; foreach c in x.iter() { printfln!("%?", c) }
[22:43:19] -rusti- 'f'
[22:43:19] -rusti- 'o'
[22:43:21] -rusti- 'o'
[22:43:23] -rusti- ()
[22:43:23] *** concrete.mozilla.org sets mode: +M 
[22:43:32] *** brson sets mode: -M 
[22:43:42] <bjz_> strcat: enum Void {} = 0, struct X; = 1, enum Option<T> { Some(T), None } = 1 + T, enum Either<T,U> { Left(T), Right(U) }
[22:43:50] <bjz_> strcat: enum Void {} = 0, struct X; = 1, enum Option<T> { Some(T), None } = 1 + T, enum Either<T,U> { Left(T), Right(U) } = T + U
[22:43:56] <bblum> brson: what i mean is, i am willing to keep them as SeqCst, because i agree with all those reasons; but i want to see if the rationale was simple and convincing enough to justify it
[22:44:17] <strcat> bblum: hm?
[22:44:20] <strcat> bjz_: *
[22:44:47] <bjz_> strcat: adts form a semiring, apparently
[22:45:12] <brson> toddaaro: ok, thanks. Can you xfail that unwind-resource test? I'm worried about it, but I also want to get this landed. I'll keep poking at it to see if I can figure something out
[22:45:44] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[22:46:29] *** Joins: jclements (jclements@A03C2118.C65A2E34.EB48B30D.IP)
[22:46:33] *** Joins: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net)
[22:47:51] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[22:47:56] *** Quits: jmgrosen (jmgrosen@moz-A3814C08.sd.sd.cox.net) (Quit: jmgrosen)
[22:48:41] <toddaaro> brson: ok, will do. I'll make sure that stays a commit by itself for easy commit log viewing
[22:48:48] *** Joins: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com)
[22:50:06] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[22:51:09] <Eridius> hrm, problem with using fn to_owned(self) is existing code takes &~str and calls .to_owned() on it. In fact, that's how clone() is implemented for ~str
[22:51:20] <strcat> graydon: PEP8 was updated to 99 columns per line :)
[22:51:21] <Eridius> so I guess into_owned() is the way to go
[22:51:30] <strcat> graydon: http://hg.python.org/peps/rev/fb24c80e9afb ;p
[22:51:42] <strcat> we're style trend fortune tellers
[22:52:27] <dbaupp> strcat: https://codereview.appspot.com/12269044/diff/1/pep-0008.txt
[22:52:48] <strcat> nooo ;p
[22:53:03] <dbaupp> strcat: (that's Guido, too, apparently)
[22:56:33] <engla> sounds good
[22:56:49] <engla> Rust is unclear on this as well, "prefer 80 but allow 100"
[22:56:52] <strcat> oh well hardly anything uses these range functions
[22:57:45] <engla> user code will have a lot of range
[22:58:09] <engla> and as an iterator there will finally be a nice way to generate a vec from a range
[22:58:42] <steven_is_false> engla: uint::range(0, 10).collect()?
[22:58:48] <strcat> well atm
[22:58:54] <strcat> Range::new(0u, 10).collect()
[22:59:10] <steven_is_false> strcat: That's good too.
[22:59:21] <engla> or you can just use the range object as a sequence
[22:59:34] <tikue> strcat: haha I've been following that conversation :P I thought the same thing as well
[23:00:43] *** Quits: yuriks (yuriks@9C2CE887.E53EB8F9.8DE25902.IP) (Quit: updates)
[23:01:39] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[23:02:35] <brson> bjz_: I suggest waiting for a week. Hopefully the runtime will be transitioned by then. In the meantime you might want to figure out what your strategy is, because from the runtime's perspective, overloading #[start] is going to be the way to get on the platform thread, and it should basically work now, as long as you're not stressing certain parts of the runtime
[23:02:52] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[23:02:59] <bjz_> brson: ok cool
[23:03:09] <bjz_> brson: thanks for the info!
[23:03:10] <brson> bjz_: the runtime is no longer going to set up a scheduler on the main thread by default, since it mostly goes unused
[23:03:53] <brson> i'm curious to see how the ergonomics work out. it's probably going to suck for clients of windowing libraries, since they are all going to need to write their entry point in a special way
[23:04:09] <bjz_> brson: ok, I'll be interested to see how servo does it
[23:04:15] *** Quits: kimundi (kimundi@moz-CA8AB5FA.dip0.t-ipconnect.de) (Ping timeout)
[23:04:20] *** Joins: kimundi (kimundi@moz-CA8AB5FA.dip0.t-ipconnect.de)
[23:04:23] <bjz_> brson: might help give me an idea
[23:04:36] <bjz_> Jeaye: ^
[23:05:12] <brson> one way we could possibly improve the ergonimics is to do something like `#[main_thread] fn main { do glfw::start { ... } }` then provide some assertion that glfw can make to guarantee it's running on the right thread, like `assert!(rt::on_main_thread())`
[23:05:46] <brson> or rt::pinned_to_main_thread()
[23:06:16] <brson> bblum: ok, I'll review it. sorry for being an ass
[23:06:29] <eatkinson> hello all. I'm looking to create a first-class function that doesn't have an environment. apparently it can be done with extern "rust" or something similar. is there any source code that does something like this?
[23:06:54] <bblum> brson: thanks, i appreciate it
[23:07:14] <miloshadzic> rusti: std::u8::from_str_radix("1234", 64)
[23:07:15] -rusti- rust: task failed at 'from_str_bytes_common: radix 64 to high, must lie in the range [2, 36]', /build/rust-git/src/rust/src/libstd/num/strconv.rs:489
[23:07:15] -rusti- rust: domain main @0xabb100 root task failed
[23:07:15] -rusti- application terminated with error code 101
[23:07:17] <bjz_> brson: eventually glfw should spawn contexts on the main thread: https://gist.github.com/metajack/5982180
[23:07:51] *** Joins: mark_edward (quassel@moz-9631ECE3.public.wayport.net)
[23:07:52] <miloshadzic> is there a different way to decode a base64 encoded string?
[23:08:22] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Client exited)
[23:08:32] <engla> miloshadzic: extra::base64 exists
[23:08:54] <miloshadzic> engla: cool thanks
[23:09:11] <Eridius> hrm, std::run::with_argv takes each arg, clones it, stuffs into into a @-box, and holds onto that. This seems excessively complicated just to ensure the as_c_str *ptr sticks around
[23:09:40] <olsonjeffery> brson: https://gist.github.com/olsonjeffery/6135919
[23:09:42] <Eridius> why can't it just use the original array's values? What's the cloning for? The array can't be mutated during this functino
[23:10:01] <bjz_> brson: ok, gotta go!
[23:10:01] <kmc> eatkinson: you can do  let x: extern "Rust" fn(Foo) -> Bar = f;
[23:10:07] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:10:10] <kmc> where f is an ordinary top-level fn of the appropriate signature
[23:10:15] *** Quits: tcr (tcr@moz-5DED128E.mycingular.net) (Connection reset by peer)
[23:10:18] *** Joins: tcr (tcr@moz-5DED128E.mycingular.net)
[23:10:23] <strcat> Eridius: it shouldn't do that
[23:10:25] <Eridius> strcat: https://github.com/mozilla/rust/blob/master/src/libstd/run.rs#L695
[23:10:33] *** Quits: bjz_ (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[23:10:33] <strcat> really, rust's implementation is awful anywhere that hasn't been rewritten recently
[23:10:35] <strcat> that's just how it is
[23:10:39] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[23:10:41] <eatkinson> kmc: awesome thanks
[23:10:42] <Eridius> strcat: I'm trying to fix #7928 (make it take &[Str] instead of &[~str])
[23:10:45] <strcat> there are no reasons for why it's awful ;p
[23:10:50] <strcat> just ended up that way
[23:10:51] <graydon> strcat: "awful" is a strong word. it's been through a lot of growing pains, is all.
[23:10:53] <kmc> eatkinson: you can also put extern "Rust" on a fn definition itself in which case the function has type... *u8?
[23:10:58] <kmc> odd
[23:11:20] <strcat> graydon: well it has wonderful parts and awful parts ;p
[23:11:30] <strcat> look at how nice deriving is
[23:11:40] <eatkinson> kmc: well that's confusing
[23:11:42] <strcat> and then look at parser.rs or trans :(
[23:14:09] <graydon> parser (and ast.rs) retain aspects of "transliteration from ocaml code written 7 years ago"
[23:14:19] <strcat> I think it's just natural evolution of code vs. stuff designed top-down
[23:14:38] <graydon> most of the rest has mercifully been overhauled. but there's still a lot of .. yeah, we had a lot of experiments.
[23:15:13] <strcat> some parts were written in the modern dialect, others just rotted and ended up how they are now after 10000 iterations by people who might not have been familiar with the code
[23:15:55] <cmr> There was a quote I heard recently...
[23:16:00] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:16:02] <cmr> "Everything should be designed top-down, except the first time"
[23:16:03] <Eridius> : isn't implemented as the type ascription operator yet, right?
[23:16:08] <graydon> we have not felt like we had time to rewrite as often as we should have.
[23:16:17] <graydon> cmr: heh. that's good!
[23:16:19] <graydon> it's very true.
[23:16:30] <cmr> yep
[23:16:39] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:16:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/yNh_Aw
[23:16:39] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:16:57] <Eridius> without type ascription, what's the easiest way of providing a concrete type for [] without using a separate variable?
[23:17:05] <strcat> id::<T>()
[23:17:06] <cmr> I'd like to hit milestone #1 before any major overhauls
[23:17:29] <strcat> pcwalton and aatch did a lot of trans overhauls ;p
[23:17:35] <cmr> well
[23:17:39] <cmr> trans is different :p
[23:18:02] <Eridius> strcat: hrm, I suppose that works
[23:18:11] <cmr> doener did a lot of really good work too
[23:18:15] <brson> toddaaro: When I set RUST_MIN_STACK=large the bug doesn't appear. I think what is happening is that we call 'free' on the rust stack, and we're just legitimately overflowing
[23:18:29] <bobbyrward> Is there something describing how closures/functions get captured?  Like why a top level function would an environment to Send at all.  I'm a bit lost atm
[23:18:42] <brson> #[rust_stack] is tricky
[23:18:53] <cmr> brson: wasn't that the bug with jemalloc?
[23:18:55] <brson> wish we didn't use it
[23:19:04] <brson> cmr: the jemalloc bug was likely similar
[23:19:09] <Eridius> strcat: id::<&[&str]>([]) is significantly ugiler than [] though :/
[23:19:16] <Eridius> *uglier, even
[23:19:39] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[23:19:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/23shsg
[23:19:39] <ghrust> 13rust/06auto 141d256ba 15Brian Anderson: test: Disable morestack tests...
[23:19:39] <ghrust> 13rust/06auto 14d346f1a 15bors: auto merge of #8172 : brson/rust/nomorestack, r=pcwalton...
[23:19:39] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[23:20:04] <Eridius> guess I'll just use a local var
[23:20:20] <strcat> cmr: brson is essentially redesigning all the I/O stuff top-down too, you can't really just iterate until you get something good
[23:20:31] <strcat> you get php ;p
[23:20:55] <strcat> io/concurrency stuff
[23:21:11] <cmr> Well, the newrt is part of the well-defined story I think
[23:21:53] *** Quits: jclements (jclements@A03C2118.C65A2E34.EB48B30D.IP) (Ping timeout)
[23:22:19] <jld> Does our version of LLVM have known issues with GCC 4.8?
[23:22:41] <strcat> jld: perhaps, because we're behind even what 3.3 was afaik
[23:22:53] <strcat> although I haven't noticed anything and I have gcc 4.8
[23:23:29] <strcat> gcc 4.8 even broke zlib/gzip
[23:23:43] <strcat> they depended on undef behaviour with signed int overflow and the pre-c99 struct hack
[23:24:29] *** Quits: vodik (simon@moz-CBE4BB13.cable.teksavvy.com) (Quit: WeeChat 0.4.2-dev)
[23:24:31] <jld> ...oh so that's what the Frama-C blog post about the struck hack was about.
[23:24:58] <jld> Also, I missed the "fatal error: llvm/TableGen/TableGenAction.h: No such file or directory"
[23:25:24] <brson> olsonjeffery: so is there a workaround for that ~Trait casting problem? istm that at least that should work on some level
[23:25:58] <brson> olsonjeffery: also, sully will probably be interested in your ~Trait travails since he is interested in fixing them
[23:26:15] <strcat> Arch uses the latest stable gcc so we get to find/fix all the bugs from missing includes and undef behaviour uncovered by better compiler optimization ;p
[23:26:55] *** Quits: huseby (huseby@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: Leaving)
[23:27:08] <strcat> mesa broke too
[23:27:15] * strcat can't remember the 200 other things :)
[23:27:47] <strcat> at least they fix more than they break
[23:28:13] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:28:44] <olsonjeffery> brson: yeah.. problem is i can't repro in a constrained test case
[23:28:59] <olsonjeffery> i guess ill push up my latest
[23:29:08] *** Quits: tchoma (tchoma@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[23:29:10] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: Leaving.)
[23:30:38] *** Joins: azita (Azita@A49A97C8.2C945695.FAF22AF7.IP)
[23:30:57] *** Quits: ozten (ozten@19BD73A1.5D8BCA3A.A0C1B52F.IP) (Quit: ozten)
[23:32:19] * strcat doesn't understand why we generate 2 main functions now
[23:32:27] <strcat> we make rust_main and then it calls a mangled rust_main
[23:32:48] <strcat> but I think they're both external so it's not inlined
[23:33:12] <bblum> 'pub use' means reexport, right?
[23:33:29] *** Quits: yonran (yonran@moz-962F33EB.acuitus.com) (Ping timeout)
[23:34:05] <sully> yeah, unfortunately, "can't repro in a constrained test case"
[23:34:07] <jld> Aha.  I had a clang subsubmodule lying around which wasn't supposed to exist and wasn't deleted.
[23:34:10] <sully> seems to be what everybody says
[23:34:19] <enix> hey. my sha2 & sha1 fixes won't merge because they conflict with the for/foreach work being done. Whats the most review friendly way to fix this - rebase ontop of master or push a merge commit into master?
[23:34:32] <strcat> enix: a rebase is best
[23:34:37] <enix> i'm assuming that rebasing is the best way, but just want to check
[23:34:40] <enix> ok, cool, thanks
[23:34:42] <olsonjeffery> sully: if you wanna scope it out
[23:34:51] <olsonjeffery> olsonjeffery/rust branch aio_net_tcp
[23:34:59] <strcat> enix: it's nice to hide simple mistakes and so on in rebases too, and just have commits be standalone chunks of work
[23:35:03] <strcat> but you don't have to
[23:35:10] <olsonjeffery> make check-stage1-std will produce it
[23:35:29] <tikue> what is the foreach syntax on master currently?
[23:35:36] <strcat> foreach pattern in iterator {}
[23:35:46] <olsonjeffery> if not, ill try and get something to repro it.. maybe ill just take the clases and put em in a single gist or something
[23:35:51] <olsonjeffery> then again, maybe its a module issue.
[23:35:52] <sully> do you know what is going wrong?
[23:35:54] <tikue> I must not have the right thing, because I'm getting compile errors
[23:36:02] <olsonjeffery> sully: no.. i have a "test case", though
[23:36:08] <tikue> test.rs:7:17: 7:19 error: expected `;` or `}` after expression but found `in`
[23:36:09] <tikue> test.rs:7     foreach &num in evens {
[23:36:11] <sully> I mean, what is the failure mode?
[23:36:59] <strcat> tikue: that should work fine now
[23:37:04] <strcat> maybe you're not fully up-to-date?
[23:37:17] <tikue> strcat: I was using stage2/bin/rustc, is that incorrect?
[23:37:21] <olsonjeffery> sully: well, if you look at that gist.. it's failing where i cast a struct A, that impls trait B, like ~A(...) as ~B
[23:37:37] <sully> could you link it again?
[23:37:39] <olsonjeffery> previously... we worked around this with the RtioFooObject newtypes in std::rt::rtio
[23:37:40] <strcat> tikue: it's snapshotted, it's in stage0 through stage2
[23:37:46] <olsonjeffery> sully: https://gist.github.com/olsonjeffery/6135919
[23:38:01] <tikue> strcat: I git cloned mozilla/rust, I configured and made. Did I miss a step?
[23:38:03] <olsonjeffery> as i said.. that github repo/branch linked above can produce that error w/ make check-stage1-std
[23:38:19] <enix> strcat: yup, thats what I have done for everything pre-review, i just didn't know if there was a different policy for post review fixes like this. anyway, thanks, and i'll get it rebased.
[23:38:36] <olsonjeffery> sully: anywho, i gotta jet. sorry. guess ill check in later.
[23:39:01] <strcat> enix: and then just nag whoever reviewed it to r+ it again ;p
[23:39:17] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[23:39:34] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[23:40:40] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[23:41:21] <tikue> does anyone know what "error: linking with `cc` failed with code 1" means
[23:41:30] <tikue> happens when I do bin/rustc test.rs
[23:41:43] *** Quits: tcr (tcr@moz-5DED128E.mycingular.net) (Connection reset by peer)
[23:41:49] <tikue> from stage2 directory
[23:42:41] <brson> tikue: did it output a command line that you can try by hand?
[23:42:49] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[23:42:58] <brson> when rustc errors linking it's supposed to dump some info about the failed command
[23:43:13] <tikue> yes it gave me this
[23:43:28] *** Quits: azita (Azita@A49A97C8.2C945695.FAF22AF7.IP) (Quit: azita)
[23:43:38] <tikue> https://gist.github.com/tkuehn/c01b5bc89d9b56b7fb4b
[23:44:19] <brson> tikue: sounds like file 'test' is not writable
[23:44:24] <brson> 'ld: can't open output file for writing: test'
[23:44:25] <tikue> brson: ooo
[23:44:28] <bobbyrward> test is a directory
[23:44:29] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[23:44:31] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Ping timeout)
[23:45:03] <acrichto> strcat: do you know if there's like a "this is a daily stable llvm version" because I just rebased onto LLVM from about an hour ago and it just sits in an infinite loop optimizing libstd
[23:45:04] <tikue> that was the problem
[23:45:06] <tikue> it works now thanks guys
[23:45:09] *** Joins: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com)
[23:45:22] <strcat> acrichto: I don't really think so :(
[23:45:29] <acrichto> oh well
[23:46:14] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[23:46:53] *** Joins: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[23:47:16] <brson> have there been many failures of core-rt-smoke or rt-start-main-thread on the mac bots?
[23:47:53] <graydon> acrichto: ok, reproduced with a small testcase on mac that doesn't fail on linux
[23:47:57] <brson> http://buildbot.rust-lang.org/builders/auto-mac-64-opt-vg/builds/652/steps/test/logs/stdio
[23:48:13] <graydon> acrichto: your patch fixes the cross-crate-conditions problem?
[23:48:18] *** Joins: tcr_ (tcr@D26BCFC9.C2203064.EDCE493E.IP)
[23:48:26] *** Quits: tcr (tcr@D26BCFC9.C2203064.EDCE493E.IP) (Connection reset by peer)
[23:49:21] <acrichto> graydon: yes
[23:49:26] <acrichto> or rather it should
[23:49:52] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[23:50:11] <graydon> ok. I'm adding tests. if they pass they'll close the bug :)
[23:50:35] <tikue> brson: interesting error running my version of rust-lang.org test code
[23:50:35] <acrichto> I'm curious why it doesn't fail on linux, maybe the linux linker is super-smart...
[23:50:37] <tikue> example* code
[23:50:48] <bblum> brson: do you know why concurrent printlns can get their newlines interleaved, but never the actual messages?
[23:51:03] <graydon> acrichto: oh I see you added a test to your PR anyways
[23:51:08] * graydon sighs, nm
[23:51:31] <tikue> brson: https://gist.github.com/tkuehn/d53eacb215b85c8b1778
[23:51:35] <brson> bblum: write_line outputs the newline seperately from the line
[23:52:12] <bblum> should there be an issue on that?
[23:52:22] <graydon> acrichto: you included a test for #5446 in your PR #8185, right?
[23:52:44] <graydon> (if I'm reading it correctly)
[23:52:45] <tikue> brson: is that intentional? 
[23:52:50] <brson> bblum: yeah, I think so
[23:53:34] <acrichto> graydon: oh huh I forgot that *specific* test, but I think it's exercising whatever used to cause the ICE anyway
[23:53:55] <acrichto> the "it" being the test that I wrote
[23:54:10] <brson> tikue: no. it's because the newline printing gets interleaved with other threads
[23:54:39] <tikue> brson: I meant I was wondering if the nondeterminism of the newline interleaving was intentional
[23:54:57] <tikue> brson: but you answered bblum's equivalent question already :)
[23:54:59] <graydon> acrichto: I don't get what you mean that you forgot. that test demonstrates #5446 is working now, right?
[23:55:43] <acrichto> graydon: correct, I did define a condition in one crate and used it in another, but I didn't specifically call `raise` from the non-defining crate
[23:55:57] <graydon> oh. ok. I'll add one extra that does just that.
[23:56:03] <acrichto> cool
[23:56:11] <graydon> I'll add several extras, just to be clear that all scenarios work here.
[23:56:33] <acrichto> awesome! While you're at it you could even remove the allow(missing_doc) in condition.rs :)
[23:57:52] *** Joins: goffrie_ (goffrie@moz-E416245D.dsl.ncf.ca)
[23:58:01] *** Quits: goffrie (goffrie@moz-54FA0270.dsl.ncf.ca) (Ping timeout)
[23:58:13] <acrichto> strcat: do you know what the correlated-propagation pass is?
[23:59:07] *** Quits: jeff (jeff@moz-F81F6C4E.nyc.biz.rr.com) (Quit: jeff)
[23:59:52] <aatch> acrichto, I do

[00:01:55] *** Quits: lbergstrom (lbergstrom@moz-DB4A9C19.scl3.mozilla.com) (Quit: leaving)
[00:02:04] *** Joins: lbergstrom (Adium@moz-5D8E4B14.lightspeed.cicril.sbcglobal.net)
[00:04:22] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[00:04:22] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 146002acb to 149816665: 02http://git.io/k471pw
[00:04:22] <ghrust> 13rust/06try 149816665 15Alex Crichton: test fixes
[00:04:22] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[00:14:26] *** kimundi is now known as zz_kimundi
[00:24:47] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[00:38:21] *** Joins: Jesse_ (jruderman@moz-7B0110AD.mv.mozilla.com)
[00:41:09] *** Quits: Jesse_ (jruderman@moz-7B0110AD.mv.mozilla.com) (Quit: Jesse_)
[00:41:19] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:41:19] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SAWrBg
[00:41:19] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:41:20] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:41:20] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/lT1I6w
[00:41:20] <ghrust> 13rust/06auto 142049016 15Patrick Walton: test: Remove most uses of `&fn()` from the tests.
[00:41:20] <ghrust> 13rust/06auto 14042bab8 15bors: auto merge of #10572 : pcwalton/rust/more-bars, r=alexcrichton...
[00:41:20] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:41:42] *** Joins: Jesse_ (jruderman@moz-7B0110AD.mv.mozilla.com)
[00:47:54] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[00:48:11] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[00:48:22] *** Joins: Jesse__ (jruderman@moz-BBE3ABD.mv.mozilla.com)
[00:48:51] *** Quits: Jesse__ (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[00:49:12] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[01:09:19] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[01:09:49] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[01:10:16] *** Quits: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com) (Connection reset by peer)
[01:10:44] *** Joins: Jesse__ (jruderman@moz-BBE3ABD.mv.mozilla.com)
[01:15:13] *** Jesse_ is now known as Jesse
[01:15:28] *** Quits: Jesse__ (jruderman@moz-BBE3ABD.mv.mozilla.com) (Quit: Jesse__)
[01:59:55] <Luqman> oh hey, target_family is wrong when you're not cross-compiling for the same target family...
[02:00:17] <Luqman> i guess no one noticed because only unix -> unix has ever been done
[02:04:58] *** Quits: doomlord_ (servitor@moz-4625DF14.range86-184.btcentralplus.com) (Quit: Leaving)
[02:07:42] *** Quits: geoffhill (geoffhill@moz-738DC0DB.org) (Ping timeout)
[02:14:09] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[02:15:55] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[02:18:35] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[02:18:35] *** ChanServ sets mode: +qo brson brson
[02:20:56] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[02:24:18] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[02:24:18] *** ChanServ sets mode: +qo brson brson
[02:28:47] *** Quits: Jesse (jruderman@moz-7B0110AD.mv.mozilla.com) (Quit: Jesse)
[02:42:04] *** Quits: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net) (Quit: Lost terminal)
[03:13:27] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[03:15:58] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[03:18:51] *** Joins: jdm (jdm@moz-99690620.hinet-ip.hinet.net)
[03:24:02] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[03:31:48] <Luqman> success cross compiled a simple hello world from linux -> windows with mingw64
[03:31:56] <Luqman> and it seems to work in a win8 vm
[03:32:07] <dbaupp> \o/
[03:32:09] <klutzy> hooray
[03:32:36] *** Quits: zz_kimundi (kimundi@moz-3F7C7055.dip0.t-ipconnect.de) (Ping timeout)
[03:32:48] <dbaupp> next challenge: cross compile rustc to window on linuxs, and use that rustc to compile a linux binary on windows! :P
[03:33:30] <Luqman> dbaupp: i'd imagine that's much more annoying at the very least :P
[03:33:50] <jdm> Luqman: oooh
[03:33:54] <Luqman> going this way mostly involved installing a debian package or 2 and messing with the makefiles
[03:33:57] <jdm> I wonder if we could cross-compile servo
[03:34:07] <jdm> that would probably make our lives very easy
[03:34:10] <dbaupp> Luqman: yes, I'd guess there's a long line of yaks to shave
[03:34:28] <klutzy> Luqman: does binary depend on mingw-w64 dlls?
[03:34:55] <Luqman> klutzy: yes
[03:35:27] <Luqman> now i need to figure out where to find _Unwind_Resume and not just stub it out :P
[03:36:27] *** Joins: zz_kimundi (kimundi@moz-468E1F95.dip0.t-ipconnect.de)
[03:36:28] *** zz_kimundi is now known as kimundi
[03:36:40] <klutzy> I'm curious if cross-building is faster than normal building on windows :p
[03:37:08] <Luqman> klutzy: well you still have to build linux stage1/2
[03:37:20] <Luqman> so probably about however long the android bot takes maybe
[03:37:56] <Luqman> klutzy: oh right, you did the factoring out about which personality function to use right?
[03:38:32] <Luqman> i had to rearrange it to check for sjlj first and __gxx_personality_sjlj -> __gxx_personality_sj0
[03:47:46] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[03:53:23] *** Joins: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP)
[04:03:17] <klutzy> Luqman: hmm, it requires sj0 not v0?
[04:03:55] <klutzy> rust currently recognizes seh0, sjlj, v0 only. maybe it had to be added too https://github.com/mozilla/rust/blob/master/src/rt/rust_upcall.c#L28-L36
[04:04:25] <klutzy> oh wait. what is sjlj
[04:04:44] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[04:04:44] *** ChanServ sets mode: +ao pcwalton pcwalton
[04:05:12] <strcat> klutzy: setjmp longjmp, it's useless ;p
[04:05:24] <klutzy> Luqman: it should be s/__gxx_personality_sjlj/__gxx_personality_sj0/
[04:05:27] <klutzy> my bad
[04:09:08] <Luqman> strcat: but that's all the i686 target for mingw64 seems to support :P
[04:09:39] <strcat> we will be using LLVM eventually
[04:09:57] <Luqman> that'll make things easier then
[04:10:05] <klutzy> Luqman: but you had to change order too? it's interesting
[04:10:31] <strcat> libc++abi will have exception support cross-platform, doesn't yet (it lets libgcc provide it)
[04:10:52] <Luqman> klutzy: yes, because it seems to define both __SEH__ and __USING_SJLJ_EXCEPTIONS__ but i could only find the __gxx_personality_sj0 symbol
[04:11:03] <klutzy> wow
[04:11:04] <Luqman> so just moved the sjlj check to be first
[04:13:07] *** Quits: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP) (Quit: tikue__)
[04:14:08] *** Joins: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP)
[04:14:10] *** jdm is now known as jdm|f00ding
[04:17:03] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[04:24:43] <Luqman> what's the reason we use -Wl,--export-dynamic,--dynamic-list for rustrt?
[04:29:07] *** Quits: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP) (Quit: tikue__)
[04:31:22] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[04:31:22] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14042bab8 to 14c159acb: 02http://git.io/N3iJvQ
[04:31:22] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[04:31:27] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[04:31:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/QRVRjA
[04:31:27] <ghrust> 13rust/06auto 143e637d5 15Steven Fackler: Remove NonCopyable::new...
[04:31:27] <ghrust> 13rust/06auto 146a25ba3 15bors: auto merge of #10575 : sfackler/rust/non-copyable, r=huonw...
[04:31:28] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[04:34:36] *** Joins: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP)
[04:35:41] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[04:38:56] <sfackler> acrichto: ping
[04:43:30] <strcat> acrichto: https://github.com/mozilla/rust/pull/10576 r?
[04:52:25] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[04:58:12] <Luqman> it's a bit funny to see std.dll and such among libstd.so
[05:00:35] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[05:01:02] <Luqman> also, bit by case sensitivity once again :( -lWs2_32 but it's all lowercase on linux
[05:03:26] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[05:07:06] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[05:15:30] *** Joins: yuriks (yuriks@72011412.14007B8A.748B6D8D.IP)
[05:16:08] *** Quits: yuriks_ (yuriks@74A1181A.6C9AD9C4.8E0C6B01.IP) (Ping timeout)
[05:17:41] *** jdm|f00ding is now known as jdm
[05:30:38] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[05:33:30] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[05:41:21] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[05:41:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/QRVRjA
[05:41:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[06:01:24] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[06:15:47] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[06:19:38] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[06:19:38] *** ChanServ sets mode: +o tjc
[06:28:28] <Luqman> success! i've made a build of rustc with mingw64
[06:28:40] <Luqman> cross compiled that is
[06:28:49] <andrew-d> :D
[06:28:51] <klutzy> yay!
[06:29:37] <andrew-d> out of sheer curiosity, how hard was it?
[06:31:36] <Luqman> https://github.com/luqmana/rust/commit/1f32a4f75fb9fac78d854ad4b6fac0e8d271b9fb
[06:32:13] <klutzy> +CROSS_PREFIX_x86_64-w64-mingw32=x86_64-w64-mingw32-
[06:32:18] <klutzy> whoa, this will save me a lot!
[06:36:47] <klutzy> Luqman: isn't it that -fPIC is also ignored on 32-bit win?
[06:37:26] <Luqman> klutzy: yea, i think it is
[06:37:34] <strcat> Luqman: we can use mingw-w64 for 32-bit too, right?
[06:37:44] <strcat> it'd be really nice to drop the broken mingw garbage ;\
[06:37:51] <Luqman> strcat: yes, that's what i've built right now
[06:37:54] <strcat> oh good
[06:37:56] <klutzy> strcat: it even passes `make check`
[06:38:12] <klutzy> I've checked it last week
[06:38:17] <andrew-d> Luqman: Niiiiiiice :D
[06:38:17] <strcat> Luqman: make sure to bug acrichto until he gets it onto the buildbot and snapshotted ;p
[06:38:21] <Luqman> it seems to work with the quick stuff i tried in a win8 vm
[06:38:46] <Luqman> strcat: i think the first snapshot has to be generated manually or something
[06:39:06] <klutzy> strcat: but mingw-w64's 32bit rustc is really slow, although I haven't profiled it yet
[06:39:21] <klutzy> (to be clear, I have to learn how to use Very Sleepy...)
[06:39:31] <Luqman> klutzy: really? it seems much faster for me
[06:39:47] <Luqman> but i haven't run mingw32 rustc in a while
[06:39:50] <klutzy> Luqman: it is fast at startup
[06:40:00] <klutzy> but slow in some parts
[06:40:12] <Luqman> klutzy: you can try the one i have http://luqman.ca/rust-builds/rust-0.9-pre-c159acb-i686-w64-mingw32.zip
[06:41:04] <Yurume> Luqman: great!
[06:41:26] <Yurume> I was seriously thinking about making a nightly rustc for Windows
[06:41:52] <Yurume> but I couldn't easily automate the process
[06:42:34] <Luqman> i could probably automate this now that i don't have to boot up a vm
[06:43:33] <andrew-d> I'll have a windows box within the week, and it's something I've been considering too :)
[06:45:37] <Yurume> it would be good to have Ubuntu PPA and Win32 nightly synchronized to each other
[06:46:06] <strcat> why?
[06:46:12] <strcat> what about other ones? ;p
[06:46:28] <Yurume> Arch?
[06:46:38] <andrew-d> It should be easy enough to figure out what time the Ubuntu build is done at and then just pull at the same time.  Barring race conditions...
[06:46:56] <Yurume> oh, wait, I don't know that much how the current nightlies are built and deployed to the distro
[06:46:58] <strcat> Yurume: yeah but I imagine that people will set it up for opensuse, fedora, OS X
[06:47:11] <strcat> Yurume: I build the Arch ones on Arch's official build server
[06:47:27] <strcat> I am a packager so I have ssh access to that (the stable rust is in the official repos)
[06:47:33] <andrew-d> strcat: Not being familiar with how that works... do you kick it off manually, or what?
[06:47:33] *** Quits: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP) (Quit: tikue__)
[06:47:38] <strcat> andrew-d: cron job
[06:47:41] <andrew-d> Ah :)
[06:47:44] <strcat> it just runs on a daily schedule
[06:47:51] <klutzy> Luqman: hmm, I've built libstd and it took 1m 26s. it's not slow :o
[06:47:59] <strcat> packages get built in a clean container (which is a chroot + sandboxing)
[06:48:07] <Yurume> as always, LLVM is problematic (yet)
[06:48:17] <Yurume> rebuilding LLVM is*
[06:48:19] <klutzy> maybe I wrongly thought mingw-w64 is slow.. hmm
[06:48:30] <strcat> it has to build LLVM again every day to keep the package as a clean build
[06:48:33] <strcat> takes a while ;p
[06:48:37] <andrew-d> Hahaha
[06:48:50] <strcat> I find all the makefile bugs...
[06:49:08] <strcat> I wonder where my daily pkg is and it turns out it found a makefile race
[06:49:23] <klutzy> Luqman: ah, I got it. MY mingw-w64 is slow.
[06:49:24] <strcat> I actually have MAKEFLAGS unset at the moment due to a race...
[06:49:35] <Luqman> klutzy: well i'm assuming you built it on windows but i just built from a debian box
[06:49:43] <strcat> I think pnkfelix fixed it but I got tired of finding them
[06:49:48] <andrew-d> Better you than me :P  I'm reaaaaaaly not a fan of debugging Makefiles :P
[06:50:00] <klutzy> Luqman: I have a rustc.exe built on i686-w64-mingw32
[06:50:08] <Yurume> is there any way to ditch makefiles? ;)
[06:50:11] <strcat> Yurume: http://pkgbuild.com/~thestinger/repo/x86_64/ can see the approximate time it finishes building every day
[06:50:45] <klutzy> which uses dwarf2 and win32 thread as I remember
[06:50:46] <strcat> I guess it takes 40 minutes to build
[06:50:53] <strcat> with -j1
[06:50:58] <strcat> silly LLVM...
[06:51:01] <klutzy> I have to use sjlj for comparison. interesting
[06:52:34] <strcat> Luqman: was that -lWs thing just broken? :\
[06:52:50] <Luqman> strcat: no, just case sensitivity
[06:53:01] <Luqman> doesn't matter on windows but linux is a bit more picky
[06:53:10] <strcat> right
[06:53:13] <strcat> makes sense
[06:54:29] <andrew-d> Luqman: so, this is a cross-compile, right?  So, hypothetically, we can now have Linux/OS X-hosted Rust building windows binaries?
[06:54:47] <andrew-d> **can we now
[06:55:12] <Luqman> andrew-d: yep
[06:55:18] <acrichto> strcat: can you remove the r+ from #10578? I have questions about that I would like answered first
[06:55:23] <klutzy> Luqman: do you know what configuration is used for debian mingw-w64 package?
[06:55:31] <strcat> acrichto: sure
[06:55:33] <klutzy> it uses sjlj for unwinding, but I'm not sure of threading model
[06:56:11] *** kimundi is now known as zz_kimundi
[06:56:21] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[06:56:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9erj8Q
[06:56:21] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:56:22] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[06:56:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LpLYHg
[06:56:22] <ghrust> 13rust/06auto 141f32a4f 15Luqman Aden: Fix up mingw64 target.
[06:56:22] <ghrust> 13rust/06auto 145b62602 15bors: auto merge of #10578 : luqmana/rust/mingw64, r=thestinger...
[06:56:22] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:56:27] <strcat> er...
[06:56:29] <strcat> I removed the r+
[06:56:36] <andrew-d> acrichto: ping ^
[06:56:38] <acrichto> I'll cancel
[06:56:41] <strcat> I guess bors will stop because bors is supposed to be stateless
[06:56:45] <strcat> acrichto: I don't think you need to
[06:56:59] <Luqman> klutzy: i686-w64-mingw32-gcc -v says:  --enable-threads=win32 --enable-sjlj-exceptions
[06:57:00] <strcat> bors is a cron job that runs without state afaik
[06:57:03] <acrichto> andrew-d: ping for cross building?
[06:57:14] <andrew-d> acrichto: no, in case you didn't see bors.  never mind me :)
[06:57:25] <klutzy> Luqman: thanks!
[06:58:17] <Luqman> acrichto: can i just push to try in the meanwhile to catch any other platform breakage?
[06:58:39] <acrichto> Luqman: feel free, you want me to do that?
[06:58:54] <Luqman> cool, i got it
[06:59:04] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:59:04] <ghrust> 01[13rust01] 15luqmana 04force-pushed 06try from 149816665 to 141f32a4f: 02http://git.io/k471pw
[06:59:04] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:59:10] <acrichto> feel free to always push to try
[07:01:09] <sfackler> acrichto: any idea what the plan is for Mut?
[07:01:32] <acrichto> sfackler: it looks good to me, I think that pcwalton/nmatsakis wanted to look over it more though
[07:02:50] <sfackler> cool
[07:03:43] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[07:07:49] <strcat> vte finally rewraps text on resizing like urxvt...
[07:17:26] *** Joins: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP)
[07:20:14] <strcat> acrichto: it'd be really, really nice to start using mingw-w64 to support both 32-bit/64-bit windows
[07:20:32] <strcat> for one thing, #[thread_local] would work ;p, and the floating point tests would pass
[07:20:32] <acrichto> strcat: I agree, I also don't want to jump the gun
[07:20:46] <klutzy> I'm going to test various mingw-w64 packages on windows
[07:20:47] <acrichto> I'm not saying we shouldn't do that, I'm saying we should plan this out
[07:21:08] <acrichto> Luqman: have you used the w64 binary on windows to see if it works?
[07:21:25] <klutzy> I've found my x32-4.8.1-win32-dwarf-rev5 produced slow rustc, but luqman's one (win32-sjlj) is not slow so I have to see what is wrong
[07:22:20] <strcat> btw we really, really shouldn't use 'x32' as the terminology for 32-bit
[07:22:25] <strcat> it's a separate ABI than x86
[07:22:32] <strcat> and we're going to end up with a cfg flag for it ;p
[07:22:38] * strcat ends tangent
[07:22:53] <klutzy> what about #[cfg(target_os = "win32")]? :p
[07:23:04] <strcat> klutzy: I mean the architecture-based cfg
[07:24:12] <Luqman> acrichto: i have and compiled a few test programs.
[07:25:26] <acrichto> Luqman: have you tested unwinding?
[07:26:19] <Luqman> acrichto: well i tried a simple fail! which didn't seem to end horribly
[07:26:31] <Luqman> should probably test some more though
[07:26:43] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[07:26:46] <acrichto> Luqman: I'm just curious, although ideally we'd get a whole test suite running with it
[07:26:55] <klutzy> acrichto: if we want to migrate to mingw64, shouldn't we clarify what version we use?
[07:27:17] <Luqman> acrichto: yes, i want to make a "snapshot" and try it out soon in my win vm
[07:27:43] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[07:27:43] *** ChanServ sets mode: +o tjc
[07:27:50] <acrichto> klutzy: in terms of what target_os is?
[07:28:12] <acrichto> Luqman: I'm uneasy about this sjlj business, poking around LLVM code it looks like it's only done for ios
[07:28:34] <strcat> acrichto: right, proper exceptions on windows means using libc++abi
[07:28:41] <strcat> and I don't think they're done
[07:28:43] <klutzy> acrichto: I think of mingw-w64 version; there are lots of options user can select
[07:29:05] <strcat> acrichto: we can't use libstdc++ for exceptions on windows because their table-based unwinding is broken on 32-bit
[07:29:41] <strcat> LLVM will be compatible with the native exception ABI
[07:29:50] <strcat> at least, you'll have that option
[07:31:42] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[07:32:11] <andrew-d> "native exception ABI" - is that SEH on Windows?
[07:32:31] <strcat> andrew-d: on 64-bit windows, I think it is
[07:32:33] <strcat> well
[07:32:37] <strcat> they have other stuff too
[07:32:47] <klutzy> on 32-bit windows there exists SEH but it is patent-protected
[07:32:54] <andrew-d> o_0
[07:32:58] <klutzy> at least foss people thinks so
[07:33:20] <andrew-d> ... huh.  I've never heard that before
[07:33:33] <strcat> meh, if you respect software patents you're screwed anyway
[07:33:44] <klutzy> the patent is hold by borland; it will be expired in 2014
[07:33:49] <strcat> opengl is patented (floating point textures! texture compression!)
[07:33:59] <strcat> git is patented
[07:34:11] <klutzy> so I've heard mingw/mingw-w64 people may work next year, but well we have to drop 32-bit at the time :p
[07:34:15] <strcat> (persistent object graphs with hash tables)
[07:34:21] <Luqman> this page basically summaries it http://mingw-w64.sourceforge.net/download.php
[07:34:39] *** nrc is now known as nrc|afk
[07:35:00] * bjz_ shakes fist at software patents
[07:35:10] * andrew-d agrees
[07:36:20] <Yurume> strcat: but think of S2TC! /jk
[07:36:49] *** flaper87|afk is now known as flaper87
[07:37:14] <strcat> Arch ships mesa with floating point textures and S3TC so I'm happy :P
[07:37:27] <strcat> and all the non-proprietary codecs and so on...
[07:37:47] <strcat> subpixel rendering is patented too!
[07:38:16] <strcat> sadly the freetype2 packager doesn't want to enable the new cleartype bytecode support (subpixel *hinting*) by default because they think it's blurry :(
[07:38:18] * strcat sighs
[07:53:42] <dbaupp> hm, #[inline]-ing the #[deriving] methods apparently made us eat 40MB more RAM
[08:11:02] *** zz_kimundi is now known as kimundi
[08:12:51] *** Quits: ktt3ja (Mibbit@moz-D69B60E4.hsd1.va.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[08:13:39] <klutzy> Luqman: could you check where __SEH__ is defined at your platform? I'm curious if it's a mistake of debian maintainer
[08:14:25] <klutzy> I'm building rustc on mingw-w64 sjlj, then I found here's no __SEH__ correctly
[08:17:04] <Luqman> klutzy: oh it was x86_64-w64-mingw32 that had both
[08:17:50] <klutzy> huh. is x64 package too good to provide both? :D
[08:19:00] <Luqman> but both were compiled with --enable-sjlj-exceptions
[08:22:15] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[08:22:17] <klutzy> fatal: Unable to create 'c:/home/stone/rust-w32/.git/refs/remotes/luqmana/con.lock': Invalid argument
[08:22:22] <klutzy> stupid windows..
[08:22:39] <klutzy> I was trying to fetch your repo then it failed to create some <branch>.lock file
[08:23:37] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[08:24:39] <andrew-d> 'con' is a reserved name on Windows
[08:24:42] <andrew-d> :(
[08:24:49] <andrew-d> (same with 'nul', 'lpt1', etc.)
[08:26:02] <Luqman> ah, i had a branch named con.
[08:26:08] <Luqman> deleted now
[08:26:36] <klutzy> oh, thanks! :D
[08:30:18] <klutzy> I'm building rust on mingw-w64 by deceiving rustc: "you are on mingw"
[08:31:44] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[08:42:09] *** Quits: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[08:49:20] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Connection reset by peer)
[08:49:46] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[08:54:30] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[08:55:33] *** kimundi is now known as zz_kimundi
[08:56:23] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:56:23] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 145b62602 to 146a25ba3: 02http://git.io/N3iJvQ
[08:56:23] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:56:30] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:56:30] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/YvONFw
[08:56:30] <ghrust> 13rust/06auto 145e1e487 15Seo Sanghyeon: Make BytePos 32-bit
[08:56:30] <ghrust> 13rust/06auto 1425b6e30 15bors: auto merge of #10567 : sanxiyn/rust/bytepos, r=alexcrichton
[08:56:30] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:57:50] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[09:11:24] <strcat> dbaupp: https://github.com/thestinger/rust-core/commit/6badfea5b4ed297d72aa984b0e6314dcc8be62e2 :)
[09:11:31] <strcat> anyway I don't want to touch the other uses yet
[09:11:45] <strcat> I'll end up benchmarking signalling before/after releasing the lock for hours ;p
[09:12:23] <strcat> (on that note - really, really need to start parsing C headers with clang and marking them nounwind if the headers say so...)
[09:12:40] <klutzy> grrr, my rustc.exe from mingw-w64 is indeed slow because llvm uses winpthreads
[09:12:54] <klutzy> while Luqman's one doesn't
[09:13:38] <klutzy> don't know why it uses though :(
[09:14:18] <Luqman> how do you build llvm?
[09:15:02] <klutzy> I just typed `../configure && make`. This may be source of it
[09:15:26] <klutzy> configure sees `-mingw32` on triple then thinks it is on mingw
[09:15:39] <klutzy> although it's on i686-w64-mingw32.
[09:16:12] <klutzy> I did intentionally to remove any burden of "cross-build", but it may be just a hack
[09:17:01] <klutzy> I meant ../configure from rust
[09:19:53] *** zz_kimundi is now known as kimundi
[09:20:42] <klutzy> Luqman: did you cross-build llvm manually?
[09:21:49] <Luqman> yes, since i needed host and target = i686-w64-mingw32
[09:27:01] <klutzy> I'm going to add --disable-pthreads on LLVM_OPTS and see what happens
[09:27:24] <klutzy> maybe llvm is too smart to detect mingw64's pthread I don't want to use :S
[09:28:44] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[09:28:44] <ghrust> 01[13rust01] 15luqmana 04force-pushed 06try from 141f32a4f to 14191cba6: 02http://git.io/k471pw
[09:28:44] <ghrust> 13rust/06try 14191cba6 15Luqman Aden: Fix up mingw64 target.
[09:28:44] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[09:30:46] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[09:31:14] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[09:33:09] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Ping timeout)
[09:36:02] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[09:39:34] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[09:40:04] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[09:40:22] <klutzy> anyway is there any reason not to use `--disable-pthreads` on windows?
[09:40:58] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[09:41:53] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Ping timeout)
[09:56:42] <dbaupp> strcat: it might be easier to just support a #[no_unwind] on extern functions as a stop-gap measure?
[09:57:02] <dbaupp> (#[unsafe_no_unwind], I guess.)
[09:57:11] <strcat> and #[unsafe_readonly] and #[unsafe_readnone]? ;p
[09:57:32] <strcat> __attribute__((pure)) and __attribute__((const))
[09:57:42] <strcat> gcc also has nonnull annotations but LLVM doesn't support it atm
[09:59:31] <dbaupp> strcat: well, it's either that or using libclang properly, yes.
[10:00:12] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[10:05:10] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[10:08:35] <klutzy> Luqman: with --disable-pthreads, rustc seems to run as fast as your one does
[10:13:57] <dbaupp> klutzy: "Not it seems to run as fast as cross-one or mingw does." is that meant to be `Note it seems...`?
[10:14:46] <klutzy> ah, "Now"
[10:33:26] *** Quits: jdm (jdm@moz-99690620.hinet-ip.hinet.net) (Quit: Lost terminal)
[10:44:55] <strcat> nmatsakis: heh, I forgot that the priority queue depends on the drop flag
[10:45:20] <strcat> due to the way it does the maintenance of the heap
[10:45:29] <strcat> it could do swaps instead
[10:45:45] <strcat> could special-case types without dtors, somehow
[10:46:59] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[10:47:48] *** kimundi is now known as zz_kimundi
[10:56:12] *** zz_kimundi is now known as kimundi
[11:01:15] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[11:01:15] <ghrust> 01[13rust01] 15luqmana pushed 1 new commit to 06try: 02http://git.io/ya8vug
[11:01:15] <ghrust> 13rust/06try 141d11599 15Luqman Aden: mk: Get rid of redundant LIBUV_FLAGS.
[11:01:15] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[11:09:17] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[11:13:55] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:13:55] <ghrust> 01[13rust01] 15luqmana 04force-pushed 06try from 141d11599 to 14bac8ba3: 02http://git.io/k471pw
[11:13:55] <ghrust> 13rust/06try 14bac8ba3 15Luqman Aden: mk: Get rid of redundant LIBUV_FLAGS.
[11:13:55] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:17:55] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[11:22:01] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[11:22:34] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[11:24:15] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Ping timeout)
[11:39:01] <klutzy> Luqman: is i686-w64-mingw32-ar in debian mingw64 package?
[11:39:36] <klutzy> since on win package there's no -ar but -gcc-ar
[11:43:27] <dbaupp> klutzy: I have -ar but no -gcc-ar on debian
[12:05:00] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[12:05:14] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131114085019])
[12:07:30] *** Quits: tikue__ (tkuehn@1A16C144.CD72397.689607DE.IP) (Quit: tikue__)
[12:09:12] *** Joins: doomlord_ (servitor@moz-4625DF14.range86-184.btcentralplus.com)
[12:09:55] *** Joins: doomlord__ (servitor@moz-4625DF14.range86-184.btcentralplus.com)
[12:17:18] *** Quits: doomlord__ (servitor@moz-4625DF14.range86-184.btcentralplus.com) (Quit: Leaving)
[12:31:21] <eddyb> why do people call it mingw64?
[12:31:27] <eddyb> the project name is mingw-w64
[12:55:08] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Input/output error)
[12:55:37] *** Joins: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP)
[12:57:32] *** Quits: jensnockert (jensnocker@E26F71DB.81840CBC.B0E77544.IP) (Ping timeout)
[13:00:40] <klutzy> due to some history and abbr
[13:01:37] <klutzy> mingw was originally mingw32
[13:04:07] <klutzy> dbaupp: hmm, seems like the `-gcc-ar.exe` naming is intentional
[13:04:37] <klutzy> aha -gcc-ar is from gcc, not from binutils. interesting...
[13:05:27] <strcat> dbaupp: now to figure out code reuse of that concurrent stuff >.<
[13:05:36] <strcat> PriorityQueue essentially needs the same wrapper...
[13:05:40] <strcat> yay traits? ;p
[13:11:18] <dbaupp> strcat: you mean having both PriorityQueue and ConcurrentPQ?
[13:14:54] <strcat> yes
[13:15:16] <strcat> well I'll have a blocking + unbounded and blocking + unbounded wrapper around both queues (FIFO and priority)
[13:15:30] <strcat> the non-blocking ones are a lot more work ;p
[13:15:52] <strcat> I'm not sure about what you're supposed to do for a ConcurrentVec like intel-tbb has
[13:15:57] <strcat> I assume it uses fine-grained locking...
[13:17:04] <strcat> anyway I think it's likely that linux mutexes make non-blocking containers fairly pointless except for the real-time guarantees (and you can use timedwait instead...)
[13:17:40] * strcat will still have them for real-time stuff
[13:19:15] * eddyb tries to remember memory constraints in arduino code
[13:19:55] <eddyb> can it even have a heap? how much RAM is in one of those things - they usually have the ROM size somewhere in their name, RAM is less obvious
[13:20:31] <strcat> well you can have bounded concurrent data structures
[13:20:55] <strcat> eddyb: https://github.com/thestinger/rust-core/blob/master/core/concurrent.rs
[13:21:20] <strcat> they'll all support allocators when generic dtors work
[13:21:43] <eddyb> strcat: I was thinking of AVRs, not really related, sorry :P
[13:22:01] <strcat> it's super important for linked containers to support allocators so you can make them cache aligned
[13:22:06] <strcat> if you're sending them
[13:22:52] <strcat> or at all... eliminate false sharing by using a separate allocator
[13:23:02] <strcat> for the container as a whole
[13:23:07] * strcat shrugs
[13:23:56] <eddyb> 1KB of SRAM
[13:24:07] <strcat> 1KB ?!?!
[13:24:07] *** Joins: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net)
[13:24:12] <eddyb> imagine ~ working in that space
[13:24:17] <strcat> it won't ;p
[13:24:30] <strcat> eddyb: so you have 1 thread?
[13:24:42] <eddyb> with interrupts, I think
[13:24:47] *** Quits: dbaupp (Thunderbir@moz-4CA0D523.lns20.syd6.internode.on.net) (Quit: dbaupp)
[13:24:52] <strcat> ah so you're essentially writing a kernel
[13:25:33] <eddyb> yes. arduino makes that nice by using some C++ features for abstracting the inherent AVR details
[13:26:06] <eddyb> all code I've seen uses static or stack-local values
[13:26:57] <eddyb> " Optional boot code section with independent lock bits", wait, what?
[13:27:20] <eddyb> strcat: http://www.atmel.com/Images/doc2545.pdf - ah, I think by lock bits it means the "cannot read after programming" thing
[13:28:49] *** Joins: dbaupp (Thunderbir@moz-4CA0D523.lns20.syd6.internode.on.net)
[13:28:55] <eddyb> I think Rust could work very well in that niche, with some specific library implementations - like a compact(ing) tiny heap
[13:29:50] <strcat> eddyb: well, tcmalloc guarantees something like 12% upper bounds on fragmentation for each size class but... 
[13:30:18] <eddyb> maybe a compacting GC? :P
[13:30:45] <eddyb> (oh dear, I feel so silly thinking about GC running at that level)
[13:32:08] <strcat> eddyb: don't need compacting if you only allow dynamic allocation of certain sizes
[13:33:16] <eddyb> strcat: imagine the morestack check comparing the SP with the heap upper limit while heap allocation does the same thing to avoid growing over the stack >_>
[13:33:43] <strcat> eddyb: well I would imagine that you choose which size classes you need
[13:33:49] <strcat> and divide it up statically in advance
[13:34:08] <strcat> so lets say you have a tree, and the nodes are 32 bytes
[13:34:14] <strcat> you figure out how many nodes you need
[13:34:45] <strcat> and make a 32-byte size class with enough space + whatever max metadata overhead there is
[13:34:47] * strcat shrugs
[13:35:07] <strcat> anyway I don't expect dynamic allocation to work well there at all, do you?
[13:35:18] <strcat> anyway if you have 1KiB of dynamic memory....... how big is your stack?
[13:35:27] <eddyb> starts at the end of the RAM
[13:35:37] <strcat> so really, it's a bad idea to do dynamic alloc at all
[13:35:48] <strcat> haha, 1KiB of memory...
[13:35:50] <eddyb> (see my previous comment about morestack and heap alloc)
[13:36:22] <eddyb> strcat: wait, it's more like 768 bytes (including the stack)
[13:36:32] <eddyb> since actual RAM only starts at 0x100
[13:37:00] <strcat> so... really you're not even going to have an intrusive linked list
[13:38:13] <strcat> fixed-size arrays and integers ;p
[13:39:10] <strcat> eddyb: so what is that used for? signal processing? a wristwatch? ;p
[13:40:09] <eddyb> strcat: there's all sorts of shields, and I've seen examples doing some simple networking
[13:40:19] <eddyb> like, hosting an HTTP server
[13:40:38] <eddyb> for signal processing you'd get a powerful DSP
[13:40:40] <strcat> an http server in 768 bytes of ram? ;\
[13:40:51] <eddyb> way less
[13:41:04] <eddyb> strcat: that's why ROM size is more important
[13:43:06] *** Joins: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net)
[13:51:18] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:54:08] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[14:00:42] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[14:05:52] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Ping timeout)
[14:08:24] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[14:13:00] *** Quits: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net) (Ping timeout)
[14:32:27] <klutzy> strcat: does #10315 indicate use of winpthreads? (mingw-w64 implementation of pthreads)
[14:39:21] <strcat> hm?
[14:39:43] <strcat> klutzy: I don't think so
[14:40:04] <strcat> but perhaps it does
[14:40:13] <strcat> windows much have native thread-local data because MSVC++ supports thread_local in C++11
[14:40:31] <strcat> (specifically, *static* thread-local data)
[14:49:27] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[14:58:22] <eddyb> much have
[14:58:25] <eddyb> so standard
[14:58:28] <eddyb> *wow*
[14:58:31] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:58:47] <eddyb> strcat1: don't tell me you just missed that >_<
[14:58:48] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:58:54] <strcat1> missed what?
[14:58:56] *** strcat1 is now known as strcat
[14:59:05] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:59:31] <eddyb> strcat: "much have. so standard. *wow*"
[14:59:47] <strcat> haha, *must ;p
[15:08:01] *** kimundi is now known as zz_kimundi
[15:15:15] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:20:14] <klutzy> hmm, looks like llvm justs uses windows' tls structure
[15:20:27] <klutzy> but then I don't understand why it is even broken on mingw
[15:21:38] <strcat> klutzy: the linker is responsible for dealing with it
[15:21:40] <strcat> their linker is broken
[15:22:03] <strcat> in a statically linked executable it's pretty easy - the linker doesn't have to do anything at runtime
[15:22:07] <strcat> but in a dynamically linked one, it does
[15:24:11] <klutzy> but isn't it linker is from gcc side? if it just means mingw uses old gcc, then it may be resolved on current one
[15:47:37] <eddyb> ld is from binutils
[16:03:44] *** zz_kimundi is now known as kimundi
[16:15:02] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[16:15:02] *** ChanServ sets mode: +o tjc
[16:36:27] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:36:27] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1425b6e30 to 146a25ba3: 02http://git.io/N3iJvQ
[16:36:27] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:36:28] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[16:36:28] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/5-oZiQ
[16:36:28] <ghrust> 13rust/06auto 145e1e487 15Seo Sanghyeon: Make BytePos 32-bit
[16:36:28] <ghrust> 13rust/06auto 14f4c1f49 15Seo Sanghyeon: Fix parsing tests
[16:36:28] <ghrust> 13rust/06auto 140707660 15bors: auto merge of #10567 : sanxiyn/rust/bytepos, r=alexcrichton
[16:36:30] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[16:52:07] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Quit: leaving)
[16:52:43] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[17:19:31] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[17:29:31] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[17:29:31] *** ChanServ sets mode: +o pnkfelix
[17:43:16] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[17:47:26] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[17:47:26] *** ChanServ sets mode: +qo brson brson
[17:54:52] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[18:10:55] <Luqman> klutzy: dpkg -S `which i686-w64-mingw32-ar` says: binutils-mingw-w64-i686
[18:13:26] *** Joins: notmatt (notmatt@FC7F938D.DD50E21A.47C41102.IP)
[18:26:06] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[18:26:06] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:35:40] *** eddyb is now known as Qu
[18:35:59] *** Qu is now known as eddyb
[18:37:46] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[18:40:01] <nmatsakis> pnkfelix: ping
[18:51:31] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:51:31] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/Hfa-CQ
[18:51:31] <ghrust> 13rust/06auto 1450fb4be 15Eric Holk: Add Win64 calling convention.
[18:51:31] <ghrust> 13rust/06auto 145b534e4 15Eric Holk: Use the correct calling convention for extern rust functions.
[18:51:31] <ghrust> 13rust/06auto 1402e565a 15Eric Holk: Don't use win64 calling convention on 32-bit machines.
[18:51:33] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:53:51] *** Joins: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[18:53:56] *** nrc|afk is now known as nrc
[18:55:35] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Ping timeout)
[18:58:05] *** Quits: Sharp (Sharp@moz-7B61DF4.dsl.static.sonic.net) (Quit: Sharp)
[18:58:48] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[19:01:36] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[19:01:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d17ce9f to 146a25ba3: 02http://git.io/N3iJvQ
[19:01:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[19:12:04] *** Quits: notmatt (notmatt@FC7F938D.DD50E21A.47C41102.IP) (Client exited)
[19:12:07] <pnkfelix> nmatsakis: pong
[19:12:17] <nmatsakis> pnkfelix: pong
[19:12:19] <nmatsakis> pnkfelix: oh
[19:12:21] <nmatsakis> uh
[19:12:28] <nmatsakis> oh, I just wanted to mention,
[19:12:32] <nmatsakis> with respect to tracing of vector types,
[19:12:38] <nmatsakis> that if continue with DST in some form,
[19:12:54] <nmatsakis> we *might* be able to get away with *[T] being the "canonical way" to represent pointers to multiple values
[19:12:58] <nmatsakis> and hence tracing through `*` as we said
[19:13:42] <nmatsakis> this is related I think to this idea that pcwalton was just discussing with me, of moving growable vecs to a type `Vec<T>` and then having ~[T], &[T], and *[T] just be two word (ptr, length) pairs
[19:14:21] <pnkfelix> 1. I would be in favor of moving growable vecs to a separate library
[19:14:34] <pcwalton> the community really likes this idea in rust
[19:14:36] <pcwalton> in #rust
[19:14:48] <eddyb> mhmm
[19:14:53] <strcat> https://github.com/thestinger/rust-core/commit/b0d9f4ddba2474518f090e4bcd31026dea17e24b ;P
[19:14:57] <strcat> yay generics
[19:15:15] <strcat> if only fine-grained locking on vectors/hashmaps was so easy
[19:16:11] <nmatsakis> pcwalton: well I am not opposed in particular to the idea
[19:16:23] <pcwalton> btw, C++ did it somehow for unique_ptr
[19:16:33] <pcwalton> it's somehow overloaded to store the length when there's a T[] DST
[19:16:38] <pcwalton> I have no idea how it works
[19:16:56] <eddyb> a lot of things work in C++ because templates are so versatile :)
[19:17:05] <pcwalton> well, I have no idea how DSTs work in C++
[19:17:16] <eddyb> they.... don't really exist, I don't think
[19:17:22] <strcat> I find it hard to believe stuff like std::function<void(int, int)> can work without special cases
[19:17:29] <strcat> as in compiler support
[19:17:30] <pnkfelix> 2. I'm still thinking about this situation with how to deal with user-managed memory.  AFAICT, if you are going to allow interior pointers, then we will need to have users register their blocks of memory (or callbacks for processing them) in _some_ way.
[19:17:51] <strcat> but... I guess boost::function does exist
[19:17:56] * strcat checks if the syntax is the same...
[19:17:56] <eddyb> strcat: it's boxed and refcounted, I think. kinda like the exchange_heap_closure thing
[19:18:03] <strcat> I mean the syntax
[19:18:16] <strcat> eddyb: it's like ~fn afaik
[19:18:22] <nmatsakis> pnkfelix: well what I was saying is maybe we can get away without callbacks using only reflection, basically,
[19:18:31] <strcat> huh, boost::function has that syntax too...
[19:18:34] <nmatsakis> pnkfelix: it's going to be limiting to the flexibility of smart ptrs that store managed data tho
[19:18:40] <eddyb> strcat: the syntax? void(int, int) is fn(int, int) -> void
[19:18:42] <nmatsakis> pnkfelix: since they will be required to use *T and *[u]
[19:18:50] <strcat> eddyb: I know what it means
[19:18:54] <nmatsakis> pnkfelix: and the idea that the GC might traverse a *T is a bit scary
[19:19:01] <pnkfelix> nmatsakis: but its worse
[19:19:01] <eddyb> strcat: so what's special about it?
[19:19:02] <strcat> how is void(int, int) a valid type to pass to a template though?
[19:19:07] <strcat> void(int, int) isn't a type
[19:19:10] <eddyb> strcat: it is
[19:19:15] <eddyb> that's the trick here :P
[19:19:15] <pnkfelix> nmatsakis: when you say "they are required to use *T", can that be an interior pointer ?
[19:19:22] <strcat> eddyb: how is that a type? ;s
[19:19:31] <eddyb> strcat: you can't use it in a lot of places, but it's just like fn(int, int) in Rust
[19:19:47] <strcat> so they added it as a type?
[19:19:51] <eddyb> they didn't
[19:19:56] <eddyb> it's 30 years old or more
[19:19:58] <strcat> C++03 had void(int, int) as a type?
[19:20:02] <strcat> it's not a function ptr
[19:20:06] <eddyb> C has void(int, int) as a type
[19:20:19] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[19:20:22] <eddyb> a pointer to that is a function ptr
[19:20:22] <strcat> so it's just the non-ptr version of a fn ptr?
[19:20:25] <strcat> ;s
[19:20:38] <eddyb> yupp, that's why I mentioned fn(int, int)
[19:20:42] <strcat> well, I never realized it was valid as a non-ptr
[19:20:51] <nmatsakis> pnkfelix: interior to what? I must be confused
[19:20:53] <strcat> I've never once used it or thought about using it before C++11 ;p
[19:20:59] <eddyb> I wrote an almost complete cparse, I had to understand how types are parsed
[19:21:03] <strcat> but I guess since boost function uses it, it worked fine
[19:21:10] <pnkfelix> nmatsakis: ("interior pointer" meaning pointer into the middle of an allocated block of memory, rather than its beginning/header)
[19:21:32] <eddyb> strcat: it's actually type void with (int, int) appended to it
[19:21:52] <eddyb> void(*)(int, int) is a pointer to that type. some scary shit going on there
[19:22:12] <eddyb> I had functional combinators to put a type together
[19:22:15] <strcat> yeah I know the function ptr syntax, didn't know the non-ptr version existed
[19:23:13] <strcat> eddyb: so T[] is a type?
[19:23:20] <eddyb> T[] is T*
[19:23:22] <nmatsakis> pnkfelix: allocatoed by who? you mean interior to some managed object?
[19:23:41] <nmatsakis> pnkfelix: I'm assuming that smart pointers manage their own memory; isn't that the point?
[19:23:42] <pnkfelix> nmatsakis: there are a couple different cases I am worried about, in parallel.
[19:23:47] <eddyb> maybe slightly aliased, so you can match on it or something
[19:24:15] <eddyb> s/aliased/differentiated
[19:24:23] <strcat> pcwalton: hmm, it's possible they actually rejected the T[] stuff
[19:24:35] <strcat> oh nvm
[19:24:37] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[19:24:37] *** ChanServ sets mode: +qo brson brson
[19:24:39] <pnkfelix> nmatsakis: The main issue that I'm trying to fit into my head, if that the user has allocated a block of memory themselves.
[19:24:39] <nmatsakis> pnkfelix: ok
[19:24:42] <pcwalton> I saw it here http://en.cppreference.com/w/cpp/memory/unique_ptr
[19:24:45] <eddyb> I do remember something about C++ and T[] being special
[19:24:49] <strcat> pcwalton: yeah
[19:24:53] <strcat> pcwalton: but shared_ptr is missing it
[19:24:56] <pcwalton> right
[19:24:59] <strcat> maybe boost had it and they forgot
[19:25:03] <pnkfelix> nmatsakis: And they've borrowed a &ptr into some managed object
[19:25:13] <pnkfelix> nmatsakis: and have now stored that &ptr into their personally-allocated block of memory
[19:25:17] <strcat> like they forgot copy_if from the STL
[19:25:20] <strcat> until C++11
[19:25:22] <strcat> ;p
[19:25:42] <pnkfelix> nmatsakis: when you say that we should leverage reflection in some way
[19:25:54] <strcat> Starting with Boost release 1.53, shared_ptr can be used to hold a pointer to a dynamically allocated array. This is accomplished by using an array type (T[] or T[N]) as the template parameter. There is almost no difference between using an unsized array, T[], and a sized array, T[N]; the latter just enables operator[] to perform a range check on the index.
[19:26:05] <strcat> ah so boost added it post-C++11 standardization
[19:26:31] <pnkfelix> nmatsakis: is that supposed to help me extract that &ptr from the personally-allocated block of memory?  How so, without either registering that block of memory, or knowing how to trace it from some other pointer into that block of memory?
[19:26:37] <strcat> eddyb: apparently T[] and T* can be distinguished though
[19:26:50] <strcat> eddyb: std::is_array knows
[19:26:55] <nmatsakis> pnkfelix: yes, it is. You encounter the Smaht<&T> which contains within a *&T pointer
[19:27:02] <strcat> eddyb: http://en.cppreference.com/w/cpp/types/is_array
[19:27:05] <strcat> that's how they do it.
[19:27:15] <nmatsakis> pnkfelix: applying reflection, we find the *&T ponter, we assume its type is accurate and traverse it to find the &T, basically
[19:27:21] <eddyb> strcat: yeah, it didn't matter for C, but C++ is capable of distinguishing them
[19:27:25] <strcat> pcwalton: just a type trait hack.
[19:27:30] <strcat> ;]
[19:27:40] <nmatsakis> pnkfelix: but I have this lingering bad feeling that this is cute but ultimately we'll need something more flexible
[19:27:54] <strcat> it's not really DST, they just specialize array types as new[]/delete[]
[19:28:07] <strcat> even though actual arrays and new[]/delete[] are unrelated
[19:28:29] <pnkfelix> nmatsakis: and what about someone storing a **T instead of a *&T ?
[19:28:36] <pnkfelix> nmatsakis: do we do the same thing there?
[19:30:27] <pnkfelix> nmatsakis: (I also am quite concerned, as you noted, about the soundness of the GC tracing through *T.  It doesn't seem like that would be a good idea, not without ending up requiring the user to register their blocks of memory anyway, so that the GC could sanity check its own actions as it traversed.)
[19:30:53] <pcwalton> pnkfelix: just curious, do you have an ETA on nmatsakis' reviews?
[19:30:57] <pcwalton> I would like to get that stuff in soon
[19:31:02] <pcwalton> it interacts with things I'm doing.
[19:31:25] <pnkfelix> pcwalton: â€¦ the only PR I was aware of was retracted, let me go look at what the current state is
[19:32:45] <pnkfelix> pcwalton: ah, I overlookg PR 10506.  Why didn't I see that in github notifcations ...
[19:33:14] <pnkfelix> pcwalton: (same for 10519.  give me a sec to skim them to provide an ETA)
[19:33:25] <pcwalton> no worries, just curious :)
[19:33:46] * pnkfelix needs to using bors again instead of relying on github notifications
[19:33:48] <pcwalton> maybe we should have bugzilla whines
[19:33:50] <cmr> I find github notifications to be unreliable
[19:33:53] <pcwalton> for github r?
[19:34:05] <pcwalton> if you don't review then bugzilla sends you mail every so often until you clear the r? flag
[19:34:14] <pcwalton> which is really useful
[19:34:49] <pnkfelix> its unfortunate that bors doesn't have the "r?" lines from the descriptions on these two PR's.
[19:35:03] <cmr> We should suck in jdm's highfive bot
[19:35:36] <pcwalton> cmr++
[19:35:40] <nmatsakis> pcwalton: sometimes I wish we could just use bugzilla
[19:35:56] <pcwalton> be careful what you wish for :)
[19:35:57] <nmatsakis> or that github would learn from it
[19:36:03] <nmatsakis> I know, I know
[19:36:19] <cmr> github seems to be stagnating featurewise recently. I hope they're doing lots of backend work!
[19:36:33] <cmr> Though they say theystage things internally for months now
[19:37:30] <nmatsakis> in C++, can you instantiate a template parameter with a reference type?
[19:37:43] <strcat> nmatsakis: as in &int? yes
[19:37:47] <nmatsakis> e.g., template<typename T> void foo(T t) { ... } ... foo::<int&>
[19:37:55] <nmatsakis> or whatever the c++ syntax is :)
[19:37:59] <nmatsakis> foo<int&> I ugess
[19:38:02] <nmatsakis> *guess
[19:38:04] <strcat> nmatsakis: boost::optional for some odd reason specializes for reference types and implements nullable references
[19:38:09] * strcat shrugs
[19:38:18] <strcat> (which are essentially just raw pointers in C++...)
[19:38:44] <nmatsakis> I wonder how they deal with this with inference, or does C++ not infer template parameter types...I seem to recall I always writing them out explicitly, but that can't be
[19:38:57] <cmr> nmatsakis: it does no inference
[19:39:07] <nmatsakis> hmm. ok.
[19:39:21] <nmatsakis> also in C++11? I need to learn more about C++11
[19:39:22] <pnkfelix> nmatsakis: they have the ability to write default instantiations, no?  How far does that get you for C++'s case?
[19:39:45] * cmr hasn't used any C++ before C++11
[19:39:52] <strcat> nmatsakis: C++ infers function template params
[19:39:57] <strcat> but not struct template params
[19:40:08] <strcat> nmatsakis: they have decltype though (typeof operator)
[19:40:17] <strcat> and C++14 adds return type inference
[19:40:27] <eddyb> you can have default values for template params
[19:40:29] <strcat> 'auto' is local type inference based on the RHS expr, nothing more fancy
[19:41:27] <strcat> nmatsakis: constructing a container looks like 'std::vector<int> {1, 2, 3, 4}', it can't infer the inner types
[19:41:31] <strcat> but if you wrote a function...
[19:41:33] <strcat> you could do
[19:41:38] <strcat> make_vec({1, 2, 3, 4})
[19:41:49] <strcat> and it would infer std::vector<int> if the function return std::vector<T> from an initializer list
[19:42:06] <strcat> (they added make_unique in C++14 because of this - it just wraps std::unique)
[19:42:16] <strcat> std::unique_ptr*
[19:43:31] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[19:54:10] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[19:57:54] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[19:59:59] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[20:00:38] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:00:38] *** ChanServ sets mode: +qo brson brson
[20:01:21] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[20:02:19] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[20:03:51] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:04:43] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[20:06:22] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:06:22] *** ChanServ sets mode: +qo brson brson
[20:06:26] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:06:26] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/lA7lwA
[20:06:27] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:08:26] <eddyb> nmatsakis: wooo, the lifetime mess from before compiled :D - time to move on to actual usage implementation
[20:08:33] <nmatsakis> eddyb: oh nice
[20:08:47] <eddyb> now if only I didn't waste half a week on this (and one day every week for the past three weeks), that would be nice
[20:09:22] <eddyb> I even reused Cell's trick: #[no_freeze] and transmute_mut :D
[20:09:52] <eddyb> my usecase is limited, and shared mutable stack state is impossible
[20:10:34] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[20:13:48] <nmatsakis> pcwalton: I think I'm coming around to this fixed-length ~[T] idea
[20:14:13] <pcwalton> yeah, it seems to be the least-bad solution
[20:15:40] <pnkfelix> anyone mind if I make a A-visibility tag on github for privacy bugs, rather than continuing to abuse A-linkage for it?
[20:16:27] <pcwalton> fine by me
[20:19:08] *** Joins: mizar99 (onur@9A9BE926.63649021.8D47ACD1.IP)
[20:21:39] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[20:24:06] <nmatsakis> pcwalton: what PR were you waiting on?
[20:24:18] <pcwalton> multiple lifetime parameters
[20:24:24] <nmatsakis> oh, those should work now?
[20:24:30] <pcwalton> oh, they do? never mind then
[20:24:33] <nmatsakis> the PR for #5121 (lifetime parameters in bounds) mostly works,
[20:24:41] <nmatsakis> but I didn't implement all of my proposal
[20:24:54] <nmatsakis> I'm thinking of pushing it soon as an intermediate step nonetheless
[20:25:03] <nmatsakis> (or submitting it for review)
[20:25:22] <pcwalton> yeah
[20:25:52] <pcwalton> taking out "do" makes code so much clearer
[20:26:01] <pcwalton> I regret ever introducing "do" for anything but "spawn"
[20:26:18] <pcwalton> in particular conditions are so weird looking
[20:26:29] <nmatsakis> I've come to see it as something of an anti-pattern, though the emacs mode doesn't indent || expressions quite how I want
[20:26:35] <nmatsakis> (outside of tasks, that is)
[20:26:46] <pcwalton> we have way too much with_foo
[20:26:49] <pcwalton> in the stdlib
[20:26:56] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[20:27:15] <nmatsakis> I've got to patch up the RAII rules; so many of those I think get nicer, though not all
[20:28:43] <pcwalton> I see why people wanted once fns but I think what they really want is RAII
[20:28:46] <jack> Where is the code that reads attributes (#[foo...])?
[20:31:45] <pcwalton> jack: it's in the parser and then various other bits of the compiler consult them
[20:32:08] <nmatsakis> pcwalton: there are some use cases for once fns that RAII doesn't cover, but I continue to think they are sufficiently rare that the `fn foo<A>(args: A, x: |A|)` pattern suffices
[20:32:13] <pcwalton> yeah
[20:32:27] <pcwalton> Option.map is a big one
[20:32:35] <pcwalton> but that could be done with that pattern
[20:33:03] *** Quits: doomlord_ (servitor@moz-4625DF14.range86-184.btcentralplus.com) (Ping timeout)
[20:33:41] <pcwalton> pretty much every other case I've seen has been something that would be better with RAII
[20:33:44] <pcwalton> I really don't like with_c_str
[20:33:47] <pcwalton> that should be RAII'd
[20:35:27] <strcat> pcwalton: 'do' looks a lot better with 0-arg ones
[20:35:34] <strcat> but I don't find it to be much nicer for ones with args anyway
[20:36:22] * strcat thinks `do` looks really, really weird when it evaluates to a value and you use it too...
[20:36:34] <pcwalton> well, I'm taking it out of the language
[20:36:37] <pcwalton> except for procs
[20:36:55] <pcwalton> I'd probably take it out for "proc" too except that we have to compete with Go ;)
[20:37:10] <pcwalton> spawn(proc() { â€¦ }) is too ugly
[20:37:22] <pcwalton> although compared to
[20:37:29] <pcwalton> go func() { }()
[20:37:33] <pcwalton> it's a bit of a wash
[20:38:30] <strcat> std::thread foo([] { });
[20:39:18] <strcat> ofc being C++ that thing is a variadic template ;p
[20:49:17] *** Joins: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP)
[20:59:12] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[21:07:08] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[21:08:15] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:08:15] *** ChanServ sets mode: +qo brson brson
[21:16:52] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[21:30:41] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[21:31:15] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:31:15] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:32:16] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[21:36:24] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[21:38:25] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Ping timeout)
[21:38:54] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[21:38:54] *** ChanServ sets mode: +o tjc
[21:44:46] <jack> is package_id used internally anywhere?
[21:44:54] <jack> link.package_id i mean
[21:46:10] <jack> it's used in the crate meta hash, but i have no idea why since the docs don't mention it.
[21:46:26] <jack> i suppose techincally it's link meta data, but it skips name and version
[21:46:32] <tjc> jack: It's used for matching against an `extern mod foo = /a/b/c` thing
[21:46:46] <tjc> the docs don't mention it because I added it and didn't update the docs :P
[21:46:50] <tjc> (probably not realizing that there were docs)
[21:47:33] <jack> There's a big note about how CMH is calculated a few lines up
[21:48:00] <tjc> actually
[21:48:06] <jack> so is package_id supposed to be "github.com/foo/bar" ?
[21:48:08] <tjc> I think I know what happened -- I made rustpkg inject a package ID
[21:48:14] <tjc> but somebody else made rustc also inject a default one
[21:48:20] <tjc> so I wasn't looking at that file with the comment
[21:48:26] <tjc> yes, that's what package_id should be
[21:49:39] <jack> i suspect it shouldn't be i nthe CMH
[21:49:47] <jack> otherwise, why leave name and version out?
[21:50:55] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[21:51:24] <tjc> jack: Should version 0.2 of github.com/catamorphism/rust and version 0.2 of github.com/metajack/rust be considered the same package?
[21:51:28] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[21:51:36] <tjc> they both have the same short name, but different package IDs
[21:52:38] <jack> my point is that the reason to omit name/vers would also seem to apply to pkgid
[21:52:50] <jack> Maybe I should switch gears.
[21:53:13] <jack> What I propose is that we rename link.package_id to pkgid and SHA1(pkgid) is the filename hash
[21:53:16] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[21:54:39] <jack> STH(sym) would then be SHA1(CMH + type_str(sym))
[21:55:26] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[21:56:31] <jack> (name is no longer needed since it's in the pkgid)
[21:56:36] <tjc> Right
[21:56:58] <tjc> Also see https://github.com/mozilla/rust/issues/8523 , which is still in a not-really-decided-on state
[21:57:14] <jack> this makes the hash completely predictable, and build tooling can figure out with grep and a regex.
[21:58:12] <jack> well this would pretty much drop those, since i ahve no idea what they are for outside of the CMH
[21:58:18] <jack> and the linker's output filename
[22:02:02] <tjc> Yeah
[22:02:13] <tjc> just pointing it out since it's still open and this would close it :-)
[22:03:17] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:04:23] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:04:24] *** ChanServ sets mode: +qo brson brson
[22:08:22] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: Textual IRC Client: www.textualapp.com)
[22:11:15] *** Quits: bjz_ (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[22:12:20] <pcwalton> are folks ok with https://github.com/mozilla/rust/pull/10576 ?
[22:13:08] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[22:15:42] *** Joins: steveklabnik (steveklabn@moz-AB1D7A3B.nyc.res.rr.com)
[22:16:24] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[22:16:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/TN-g6w
[22:16:24] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[22:16:24] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[22:16:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2nrKJA
[22:16:25] <ghrust> 13rust/06auto 14543cae9 15Daniel Micay: add an initial `Gc<T>` stub with the API
[22:16:25] <ghrust> 13rust/06auto 14760942d 15bors: auto merge of #10576 : thestinger/rust/gc, r=pcwalton...
[22:16:26] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[22:16:39] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:18:13] <pcwalton> acrichto: r? https://github.com/mozilla/rust/pull/10581
[22:19:16] <acrichto> pcwalton: whoa, how come that last patc?
[22:19:26] <pcwalton> we're removing "do" from the language except for proc
[22:19:36] <acrichto> that seem... bad
[22:19:43] <pcwalton> it's part of closure reform.
[22:19:44] <acrichto> this just got way more verbose and ugly
[22:19:54] <acrichto> do b.iter { ... }
[22:19:55] <pcwalton> the ugliness is due to using "with_foo" instead of RAII
[22:20:01] <acrichto> what's the replacement for that/
[22:20:01] <pcwalton> iter should be an iterator
[22:20:02] <acrichto> ?
[22:20:07] <acrichto> that's not an iterator
[22:20:11] <acrichto> that's benchmarking
[22:20:11] <pcwalton> oh, well
[22:20:17] <pcwalton> yeah, that gets slightly more ugly.
[22:20:24] <pcwalton> although clearer IMHO
[22:21:17] <pcwalton> the idea is to remove all cases in which || infers to the right type of closure
[22:21:32] <acrichto> this is all kinda sad
[22:21:42] <pcwalton> because that hides allocation and will generally make it harder to switch to the "unifying fn and trait" stuff
[22:22:21] <acrichto> we have so many things that can't be expressed as raii
[22:22:33] <pcwalton> then we should fix the language
[22:22:36] <pcwalton> so that they can be
[22:22:46] <pcwalton> the "take a closure" style is really not good
[22:23:04] <acrichto> it's unfortunate because we have so much code written with that being "the good" style
[22:23:09] <pcwalton> yeah, it needs to be fixed
[22:23:24] <acrichto> I'm still seeing less and less how it was bad code in the first place anyway
[22:23:27] <pcwalton> it's all a hazard
[22:23:38] <pcwalton> because it requires devirtualization optimizations and once fn
[22:23:48] <acrichto> do with_local_io |io| { ... }
[22:23:52] <acrichto> that's impossible to make raii
[22:23:57] <acrichto> io is a &'task mut Thing
[22:25:18] <pcwalton> couldn't you return the &'task mut Thing as a pointer?
[22:25:24] <pcwalton> native::IoFactory can be a static, no?
[22:25:36] <acrichto> uvio::UvioFactory
[22:25:40] <acrichto> that's not &'static
[22:25:46] <acrichto> and &'task isn't a thing
[22:25:56] <pcwalton> where is the UvioFactory stored?
[22:26:07] <pcwalton> so I bet that with_local_io is *not* being devirtualized...
[22:26:13] <pcwalton> which is costing us performance every time
[22:26:14] <acrichto> it's stored in the local scheduler
[22:26:21] <pcwalton> can you return a pointer to that?
[22:26:27] <acrichto> what's the lifetime of it?
[22:26:30] <pcwalton> with an RAII based handle to put it back
[22:26:50] <acrichto> let io = get_local_io();
[22:26:58] <acrichto> there's no lifetime to associated with it
[22:27:18] <pcwalton> how does the borrow work?
[22:27:22] <pcwalton> is it dynamic borrowing semantics?
[22:28:01] <pcwalton> dynamic borrowing semantics can be RAII'd
[22:28:02] <acrichto> I/O needs the scheduler, so you can't remove the scheduler from TLS, so it unsafely borrows the scheduler and then fetches the I/O loop from it
[22:28:29] <pcwalton> if it's an unsafe borrow you might as well just return it because it's unsafe
[22:29:30] <acrichto> do io::ignore_io_error { /* code */ }
[22:29:41] <pcwalton> let ignored_io_error = io::ignore_io_errors();
[22:29:47] <pcwalton> or
[22:29:49] <pcwalton> let _ignored_io_error = io::ignore_io_errors();
[22:29:52] <acrichto> it works, but it seems a lot less readable
[22:29:53] <pcwalton> besides, conditions are going away :)
[22:30:06] <pcwalton> it saves us from having once fn though
[22:30:11] <pcwalton> also
[22:30:15] <pcwalton> it doesn't require devirtualization
[22:30:17] <acrichto> "saves us"
[22:30:31] <pcwalton> the RAII solution will be faster
[22:30:49] <acrichto> (|| f(unsafe_ptr)).finally(|| put(value_cell.take()));
[22:30:52] <acrichto> that's terrfifying
[22:30:55] <pcwalton> it's conditions
[22:31:00] <pcwalton> conditions were always unreadable
[22:31:03] <acrichto> that's just a finally block
[22:31:04] <acrichto> not conditions
[22:31:18] <pcwalton> oh right
[22:31:19] <pcwalton> I think we want a scope keyword probably
[22:31:28] <acrichto> I suppose that I want someone else to take a look at this
[22:31:39] <acrichto> all of this is an alarmingly large step backwards to me
[22:31:58] <pcwalton> nmatsakis: do you want to
[22:32:25] <acrichto> you mentioned that we don't want to have to infer &fn vs ~fn when you say || {}
[22:32:27] <pcwalton> this is a path we've been heading down ever since we got rid of the old iterators
[22:32:35] <acrichto> how are we goind to denote the two?
[22:32:41] <pcwalton> proc() for the new ones
[22:32:42] <pcwalton> err
[22:32:43] <pcwalton> proc() for ~fn
[22:32:46] <pcwalton> || will always be &fn
[22:33:02] <acrichto> foo(f: proc) <- how do I call this?
[22:33:10] <acrichto> do foo { .. } ?
[22:33:13] <pcwalton> yeah, do foo works
[22:33:19] <acrichto> how about without do?
[22:33:19] <pcwalton> "do" is hardwired to procs
[22:33:23] <pcwalton> foo(proc() { â€¦ })
[22:33:28] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[22:33:42] <acrichto> foo(proc(a, b, c) { .. } ) ?
[22:33:46] <acrichto> for arguments
[22:33:46] <pcwalton> yeah
[22:33:54] <jack> iterators went backwards too for a while, now they are nicer than before. i assume there is a nicer future for this?
[22:34:04] <pcwalton> jack: the nicer future is RAII
[22:34:17] <pcwalton> "do" is mostly there to support a pattern that doesn't work as well as RAII
[22:34:25] <pcwalton> from a optimization POV
[22:34:51] <pcwalton> (also from a language complexity POV, since you need once fn -- I understand that many people want once fn but I still think we haven't fully tried using RAII)
[22:34:58] <jack> so it's going to be spawn(proc() { ... });?
[22:35:04] <pcwalton> jack: no, do spawn { â€¦ }
[22:35:06] <nmatsakis> (on call)
[22:35:20] <pcwalton> "do" just works with procs
[22:35:30] <pcwalton> it makes the allocation explicit, whenever you see "do" you know there will be allocation
[22:36:37] <jack> so those dont' live on the stack?
[22:36:41] <acrichto> removing do means we no longer have a nice way of saying "do something N times" and it looks like we won't any time soon
[22:36:48] <jack> I guess that's what you mean about it hiding allocation
[22:37:00] <pcwalton> jack: right, "~fn" is always allocated on the heap
[22:37:07] <pcwalton> "times" has been on the chopping block for a while
[22:37:37] <jack> acrichto: for _ in range(...) { .. } works just fine
[22:37:38] <pcwalton> if we need it we can use iterators: for _ in 5.times() { â€¦ }
[22:37:52] <acrichto> jack: it indeed works, but it's fairly unintuitive
[22:37:56] <pcwalton> "times" was never converted over to be an external iterator
[22:38:06] <jack> do 5.times is not intuitive to anyone but a rubyist.
[22:38:07] <pcwalton> the external iterators vs. internal iterators ship sailed a long time
[22:38:11] <acrichto> range is fine, but you can't say for range(0, 4) {}
[22:38:19] <pcwalton> time ago
[22:38:24] <pcwalton> so most of all I want to be consistent
[22:38:31] <pcwalton> "times" is currently inconsistent because it is an internal iterator
[22:38:40] <pcwalton> Rust has made the decision to use external iteration
[22:38:59] <acrichto> we also keep saying we want to push for RAII, but we still don't have working generic RAII I thinkg?
[22:39:05] <pcwalton> no, we don't
[22:39:07] <pcwalton> we need to fix that
[22:39:14] <acrichto> I suppose in theory this will create the impetus to fix that
[22:39:29] <acrichto> r+
[22:39:32] <pcwalton> internal iterators are less composable and also require devirtualization, which LLVM isn't that great about doing
[22:39:36] <acrichto> we need reasons to fix all the bad use cases
[22:39:47] <pcwalton> thanks, and to be honest I totally understand your concerns
[22:40:07] <acrichto> I think the reasons for removing 'do' are more pressing
[22:40:10] <pcwalton> it's scary to me too but I think the optimization reasons for RAII are the most compelling
[22:40:20] <acrichto> we'll cope somehow :P
[22:40:30] <pcwalton> if we hate it we can always add it back, and once fn
[22:40:35] <pcwalton> I just want to try pervasive RAII
[22:40:42] <pcwalton> you can go in one direction but not the other
[22:40:47] <pcwalton> well, after 1.0
[22:41:05] <pcwalton> btw
[22:41:12] <pcwalton> if we decide that we *do* want it back I want once fn as well
[22:41:19] <acrichto> the syntax for &proc may be difficult to do backwards compatibly
[22:41:26] <acrichto> ~proc vs &proc
[22:41:27] <pcwalton> we should support the pattern completely or not at all
[22:41:36] <pcwalton> oh, this is what I was thinking
[22:41:41] <pcwalton> (this is in one of niko's old blog posts)
[22:41:44] <cmr> Wait, what is the difference between proc and once fn?
[22:41:51] <pcwalton> today we have || and proc
[22:41:53] <pcwalton> those will desugar into
[22:41:57] <dbaupp> cmr: proc == ~once fn
[22:42:10] <pcwalton> &mut Func() and ~OnceFunc()
[22:42:12] <pcwalton> err
[22:42:18] <pcwalton> &mut Func<> and ~OnceFunc<>
[22:42:25] <pcwalton> those will be magic traits that can be called
[22:42:39] <pcwalton> those traits are:
[22:43:09] <pcwalton> trait Func<Args,Ret> { fn call(&mut self, args: Args) -> Ret; }
[22:43:10] <pcwalton> and
[22:43:27] <pcwalton> trait OnceFunc<Args,Ret> { fn call(self, args: Args) -> Ret; }
[22:43:41] <pcwalton> note how OnceFunc just falls out of the system naturally with taking self by-value
[22:43:52] <pcwalton> then || and proc just turn from first class things into sugar
[22:44:14] <pcwalton> furthermore closures basically go away
[22:44:17] <pcwalton> except as sugar
[22:44:26] <pcwalton> without changing syntax of course
[22:44:56] <pcwalton> at this point we'll have the full generality, unified into the same system as traits
[22:44:59] <pcwalton> and it'll be glorious
[22:45:01] <cmr> Heh, and one just implements Func to have a callable type?
[22:45:17] <pcwalton> something like that, the details aren't fully ironed out
[22:45:28] <pcwalton> it also means you can do this
[22:45:37] <dbaupp> pcwalton: I assume it'd have to be `fn call(~self)` for OnceFunc with the current system?
[22:45:49] <pcwalton> yeah
[22:46:06] <pcwalton> fn my_map<F:Func<int,int>>(vector: &[int], f: F) -> ~[int] { â€¦ }
[22:46:15] <pcwalton> and the compiler would do guaranteed devirtualization for you (yeah!)
[22:47:19] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[22:47:20] *** ChanServ sets mode: +o tjc
[22:47:25] <pcwalton> and you could define custom smart pointers that point to functions
[22:47:27] <pcwalton> since they'd just be DSTs
[22:47:32] <pcwalton> since traits are DSTs and functions are just traits
[22:47:57] <pcwalton> but unlike C++11 you'd have incredibly short sugary syntax for them
[22:48:00] <pcwalton> |A|->B
[22:48:02] <pcwalton> instead of std::function
[22:48:07] <cmr> This future is much nicer than the past.
[22:48:52] <pcwalton> but in order to do that I think we need to get rid of the magic inference of || since automatically wrapping in custom smart pointers is...weird
[22:49:07] <cmr> pcwalton: did you see eddyb's variadic typarams proposal?
[22:49:12] <pcwalton> cmr: I didn't
[22:49:13] <pcwalton> link?
[22:49:24] <cmr> sec
[22:49:48] *** Quits: mizar99 (onur@9A9BE926.63649021.8D47ACD1.IP) (Quit: Leaving)
[22:49:55] <cmr> https://github.com/mozilla/rust/issues/10124
[22:51:18] <pcwalton> interesting
[22:51:19] <pcwalton> that looks like it could turn out to be pretty clean
[22:51:22] <pcwalton> yay tuples
[22:51:23] <cmr> Yeah
[22:51:26] <pcwalton> I'm glad we didn't remove them
[22:51:49] <tjc> heh
[22:51:50] <cmr> :P
[22:51:52] <tjc> I'm glad we put them back in
[22:52:03] <cmr> Why were they removed?
[22:52:06] * cmr thinks tuples are handy
[22:52:11] <pcwalton> language complexity concerns
[22:52:14] <pcwalton> we put them back in
[22:52:16] <cmr> Structural types are nice to have :)
[22:52:26] <cmr> Although Rust had structural records, didn't it?
[22:52:32] <pcwalton> I think that was maybe back when we had structural records
[22:52:38] <cmr> mm
[22:52:39] <tjc> yeah
[22:52:51] <tjc> if we'd started without structural records, tuples probably would never have been up for debate :-)
[22:55:07] <cmr> I wonder if [T, ..N] makes sense, pedagogically, as tuple sugar..
[22:55:53] <tjc> cmr: I'm not sure if it does or not; you can't index tuples, at least in Rust
[22:56:01] <cmr> Right
[22:58:02] <pcwalton> the worst idea I had was half indent for case blocks
[22:58:04] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[22:58:05] * pcwalton kicks himself for that
[22:58:37] <pcwalton> that is why you should not listen to what I say
[22:59:10] <tjc> pcwalton: I don't think that was the worst idea in the history of Rust :-)
[22:59:16] <cmr> pcwalton: Do you plan on removing fn() -> || coercion
[22:59:18] <pcwalton> it's up there :)
[22:59:22] <pcwalton> cmr: I don't think so
[22:59:27] <pcwalton> seems harmless
[22:59:56] <cmr> Ok, so the `do bh.iter { ... }` pattern can be approximated with inner fns
[23:00:21] <pcwalton> it may well be that Rust has removed more features than any other language
[23:00:40] <pcwalton> (this is why I bristle when people say that Rust was intentionally designed to be hard)
[23:00:49] <tjc> maybe Rust has *had* more features than any other language ever had :-)
[23:01:03] <pcwalton> that may well be true :)
[23:01:05] <tjc> it's forgotten more than some languages will ever know
[23:01:29] <pcwalton> people were really sad to see mut fields go
[23:01:45] <pcwalton> and type state for that matter
[23:02:11] <cmr> I probably wouldn't have seriously looked into Rust before 0.6, it would have thrown me off completely.
[23:05:34] *** Joins: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[23:06:11] <tjc> pcwalton: people were actually sad about mut fields being removed?
[23:06:14] <tjc> I don't remember that :-)
[23:06:35] <pcwalton> well, maybe
[23:08:07] <aatch> I remember some people being annoyed because their code relied on them.
[23:08:27] <aatch> which implied their code relied on what was fundamentally unsound behaviour...
[23:08:37] <pcwalton> I think it was mostly sound
[23:08:45] <pcwalton> except you just couldn't borrow them ever
[23:08:47] <pcwalton> which was pretty annoying
[23:09:26] <tjc> aatch: not necessarily -- I assume they were just annoyed because they had to change their code
[23:09:28] <aatch> ok, unsound is the wrong word.
[23:09:30] <tjc> not because it was impossible to
[23:09:39] <aatch> tjc, well yes.
[23:10:04] <tjc> if somebody found they really *couldn't* express their code with inherited mutability, then yes, they would probably be depending on unsoundness
[23:11:27] *** Quits: lkuper (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Ping timeout)
[23:13:48] *** flaper87 is now known as flaper87|afk
[23:16:40] <pcwalton> bh.iter(|| factorial(100));
[23:16:48] <pcwalton> bh.iter(func() { factorial(100); })
[23:17:13] <pcwalton> I think ours looks better than Go's anyway even without the "do"
[23:17:48] <pcwalton> what's D's lambda syntax?
[23:18:01] <pcwalton> bh.iter((){ factorial(100) });
[23:18:03] <pcwalton> C++
[23:18:06] <pcwalton> also line noise
[23:19:09] <dbaupp> pcwalton: http://dlang.org/expression.html "Lambdas": (int x) => ..., function(int x) => ..., delegate(int x) => ..., afaict
[23:19:17] <pcwalton> you have to type annotate? :(
[23:19:21] <dbaupp> not sure
[23:19:30] <dbaupp> (not sure if it's compulsory)
[23:19:30] <pcwalton> bh.iter(() => factorial(100));
[23:19:35] <pcwalton> yeah, that looks fairly nice
[23:19:42] <pcwalton> CoffeeScript lets you just say ->
[23:19:46] <pcwalton> bh.iter -> factorial 100
[23:20:00] <dbaupp> http://stackoverflow.com/questions/8857965/whats-the-new-lambda-syntax seems to say type aren't compulsory
[23:20:05] <pcwalton> ok
[23:20:18] <pcwalton> requires some sort of cover grammar though
[23:20:21] *** Joins: Jesse (jruderman@moz-C07D5168.p2p.sfo1.mozilla.com)
[23:20:56] *** Joins: jdm (jdm@moz-ED0C7AC7.hinet-ip.hinet.net)
[23:21:24] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:21:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/2nrKJA
[23:21:24] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:26:29] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:26:29] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VQyChw
[23:26:29] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:26:38] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:26:38] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/CfvYGw
[23:26:38] <ghrust> 13rust/06auto 142049016 15Patrick Walton: test: Remove most uses of `&fn()` from the tests.
[23:26:38] <ghrust> 13rust/06auto 145d57c24 15Patrick Walton: librustc: Remove remaining uses of `&fn()` in favor of `||`.
[23:26:38] <ghrust> 13rust/06auto 143b26855 15Patrick Walton: libsyntax: Remove the old-style borrowed closure type syntax from the...
[23:26:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:28:25] *** nrc is now known as nrc|lunch
[23:42:45] <pcwalton> maybe we really should think about a scope keyword
[23:42:48] <pcwalton> scope unkillable;
[23:43:10] <acrichto> it'd be really cool if we could make it a library implementation
[23:43:15] <acrichto> but I'm not sure if it'd be possible
[23:43:41] <acrichto> https://github.com/mozilla/rust/pull/9842 was a really slick implementation
[23:43:51] <pcwalton> "scope unkillable" fewer number characters than "do unkillable { }" and is 1 fewer lines and has no rightward drift
[23:44:03] <pcwalton> seems the best of all worlds.
[23:44:07] <pcwalton> well, ok
[23:44:08] <pcwalton> scope unkillable;
[23:44:13] <pcwalton> same number of characters, I think.
[23:44:14] <acrichto> seems like compiler magic though?
[23:44:21] <pcwalton> sure, but so is do :)
[23:44:33] <acrichto> what is 'unkillable' in that sense
[23:44:36] <cmr> What does scope do, exactly?
[23:44:38] <acrichto> is it a function returning an raii structure?
[23:44:38] <pcwalton> oh, just a function
[23:44:42] <pcwalton> maybe scope unkillable();
[23:44:55] <friggle> rightward drift seems desirable for most uses where I might want "scope"
[23:44:57] <acrichto> oh, so just holding something in scope
[23:44:58] <pcwalton> yeah
[23:45:05] <pcwalton> friggle: I don't really agree
[23:45:15] <pcwalton> in Servo the rightward drift of all the "do" is extremely annoying
[23:45:27] <pcwalton> makes Servo layout look way worse than most Web browser layout :(
[23:45:39] <pcwalton> because we use scope for returning interior references to @ boxes
[23:45:45] <pcwalton> and that is done with closures in many places
[23:45:52] <pcwalton> and not only is that slow, it also makes the code look really bad
[23:46:08] <friggle> pcwalton: yeah, I suppose I agree that a lot of rust code (particularly with lots of matches or closures) looks very indentation heavy
[23:46:39] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[23:48:05] <pcwalton> scope Finally(|| close_my_file());
[23:48:18] <pcwalton> or I guess Defer
[23:48:24] <pcwalton> scope Defer(|| close_my_file());
[23:50:33] <cmr> scope!(....)
[23:50:41] <cmr> expands to let _somewhatever = ....;
[23:50:41] <pcwalton> yeah, that would work
[23:50:48] <pcwalton> or just "let _ = ..."
[23:50:55] <pcwalton> with nmatsakis' changes
[23:50:55] <benh> ( I backread a bit but maybe I missed it; is "do blah |x| { ... }" still gonna work with procs or do I need to say blah(proc(x) { ... }) if I want an argument? )
[23:51:02] <pcwalton> benh: it works with procs
[23:51:08] <cmr> yeah
[23:51:25] <benh> ok, wasn't sure since the || are now kinda more closely associated with the syntax or the stack closures type :D
[23:54:12] *** Quits: steveklabnik (steveklabn@moz-AB1D7A3B.nyc.res.rr.com) (Ping timeout)
[23:56:07] <acrichto> pcwalton: why is it exp_map2, what was the first exp_map ?
[23:56:19] <pcwalton> that was something resolve1 did
[23:56:22] <pcwalton> I forget now :)
[23:56:32] <acrichto> ah oh well
[23:56:42] <pcwalton> lost to the mists of time
[23:56:50] <cmr> Oh, acrichto *linked* to an issue using macros for scope guards..
[23:57:10] * cmr goes back to his cave

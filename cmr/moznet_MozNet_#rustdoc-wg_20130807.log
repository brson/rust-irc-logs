[13:58:16] <Seldaek> cmr: and I thought I was asking dumb questions.. glad there's always someone with less of a clue to cheer one up :p
[13:58:24] <cmr> :P
[14:01:07] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:28:19] <cmr> If only the compiler could tell me where my logic bugs were
[14:29:07] <Seldaek> yeah, then we wouldn't need to program anymore though :p
[14:29:34] <dbaupp> cmr: that's `rustc -Z pebkac`
[14:29:39] <cmr> heh
[14:59:19] <cmr> dbaupp: do you mind looking over some code? I think I'm missing something obvious
[15:00:25] <dbaupp> cmr: sure
[15:00:26] <cmr> https://github.com/cmr/rustdoc_ng/blob/wip/passes.rs#L11 isn't working properly. The info line is printed exactly once, which can't be right
[15:00:35] <cmr> I think it's an improper recursion somewhere
[15:00:45] <cmr> https://github.com/cmr/rustdoc_ng/blob/wip/visit.rs
[15:00:54] <cmr> But it all looks right to me, and it visits every submodule correctly.
[15:02:22] <dbaupp> any particular reason you're doing it that way?
[15:02:26] <cmr> nope
[15:02:30] <cmr> seemed the easiest to me
[15:02:33] <dbaupp> i.e. having externally driven recursion
[15:03:30] <dbaupp> iirc, aatch's visitor had visit_item() {self.visit_item_contents()} (default) and visit_item_contents() did the actual recursion bit (also, default)
[15:03:54] <cmr> visit_item_contents is a misleading name
[15:04:01] <dbaupp> and someone would override visit_item, and call visit_item_contents at the appropriate time
[15:04:11] <cmr> that function's purpose is to touch all the fields except inner
[15:04:12] <dbaupp> (call it visit_item_recur, or something.)
[15:04:41] <cmr> ie, it's where you'd hang doc attribute folding or doc(hidden) stripping
[15:04:49] <dbaupp> yeah
[15:05:48] <dbaupp> how about implementing it as a fold?
[15:05:56] <cmr> I don't really know what a fold is
[15:06:02] <dbaupp> so the whole doc-ast gets destructured and rebuilt
[15:06:27] <dbaupp> i.e. it consumes the original doc-ast and builds an entirely new one as output
[15:06:38] <cmr> That sounds wretchedly slow
[15:06:40] <dbaupp> essentially what you have now, but taking self everywhere, instead of &mut self.
[15:06:50] <cmr> and tweaks my inner C programmer :p
[15:07:02] <dbaupp> it's *probably* not too bad, but I'm not sure.
[15:07:35] <dbaupp> (in fact, you're essentially doing that with the filter_maps.)
[15:08:09] <dbaupp> I think it'd just be more natural to think of it in that way.
[15:09:16] <dbaupp> so essentially, visit_crate(&mut self, c: clean::Crate) -> clean::Create { ... }
[15:09:35] <dbaupp> (i meant clean::* instead of &mut clean::*, btw, not the thing with `self`.)
[15:10:09] <cmr> I suppose ~3MB really isn't that large and I should stop worrying about it
[15:10:13] <dbaupp> yeah
[15:10:34] <dbaupp> it essentially makes it more functional: taking in an immutable tree, and transforming it into a new one.
[15:11:37] <dbaupp> (except, the immutability bit isn't true, because the functions own the tree, but it's a nice way to think of it.)
[15:13:34] <cmr> do you think it'd be better if I didn't maintain the arbitrary vectors in Module and just had a single ~[Item] ?
[15:13:46] <cmr> It just reuqires a filter when you want a single type of item
[15:16:03] <dbaupp> Maybe? especially since the vectors are just ~[Item] and so aren't particularly typesafe
[15:16:14] <cmr> Yeah
[15:16:16] <cmr> it's unfortunate
[15:21:49] <dbaupp> cmr: https://gist.github.com/huonw/4b560ef6d74ee26d7d1f
[15:23:24] <cmr> yeah, much simpler
[15:23:29] <dbaupp> cmr: (I guess fold_item_recur could return plain Item.)
[15:23:56] <cmr> dbaupp: visit_item_recur you mean?
[15:24:25] <dbaupp> cmr: I changed the names, but yeah
[15:24:29] <cmr> oh
[15:24:31] <cmr> yes
[15:24:34] <cmr> I don't think so?
[15:24:40] <cmr> It needs a way to entirely remove items from the tree
[15:25:10] <dbaupp> not the default one that handles the recursion?
[15:25:24] <dbaupp> the removal is decided by the "parent" code, isn't it?
[15:25:34] <dbaupp> (i.e. fold_item)
[15:25:58] <cmr> I don't even know anymore
[15:26:00] <cmr> ;p
[15:27:05] <dbaupp> haha
[15:27:21] <Seldaek> apparently memory safety isn't the only hard thing in computing :p
[15:27:58] <cmr> also hard: keeping track of who you are and what you're doing
[15:29:12] <Seldaek> in the last week I found that sleep depravation doesn't help with that
[15:29:30] <Seldaek> "wtf when did this happen?" happened too many times :p
[15:36:25] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[15:37:09] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[16:11:43] <cmr> dbaupp: I'd still be able to separate them out into separate JSON arrays when encoding, yeah?
[16:11:53] <dbaupp> cmr: maybe?
[16:12:00] <dbaupp> ... probably not.
[16:12:03] <dbaupp> I don't know.
[16:12:40] <dbaupp> anyway, it's late. I need sleep. night. :)
[16:12:44] <cmr> night!
[16:16:50] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[16:39:02] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:56:28] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:16:32] <cmr> Seldaek: The JSON just keeps getting worse and worse..
[17:16:47] <cmr> I really hope I'll be able to clean it up without ripping everything out again
[17:33:58] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:36:51] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[21:08:25] *** Quits: n0v (n0v@moz-690FFF9D.org) (Ping timeout)
[21:09:11] *** Joins: n0v (n0v@moz-690FFF9D.org)
[21:49:43] *** Quits: n0v (n0v@moz-690FFF9D.org) (Connection reset by peer)
[21:50:34] *** Joins: n0v (n0v@moz-690FFF9D.org)
[22:26:17] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:57:38] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)

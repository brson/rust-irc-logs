[00:00:08] *** Quits: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr) (Quit: moostik)
[00:00:12] <dbaupp> reference counting
[00:00:20] <whitequark> without cycle detection?
[00:00:21] <skrylar> according to the manual, @T is the equivalent of Rc<T> with a compiler warning
[00:00:23] <dbaupp> yes
[00:00:28] <tautologico> so don't create cyclic data with @ :)
[00:00:30] <dbaupp> cycles are just collected on task death
[00:00:33] <strcat> whitequark: it builds an intrusive linked list and frees them at the end of the task
[00:00:43] <whitequark> I see, thanks
[00:00:56] *** Quits: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net) (Ping timeout)
[00:00:58] <strcat> it adds 4 words to the allocation and since it copies implicitly, you'll be holding onto refs everywhere
[00:01:16] <strcat> let x = @5; foo(x); /* still holding onto x */
[00:01:21] <strcat> doesn't work well ;p
[00:01:35] <skrylar> don't you have to explicitly mark the x in foo(x)?
[00:01:42] <strcat> no
[00:01:45] <skrylar> unless foo is definde to accept a @x
[00:01:53] <strcat> that's what I was trying to demonstrate
[00:01:55] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[00:02:19] <strcat> let x = Rc::new(5); foo(x); /* no ref here anymore */
[00:02:28] <skrylar> i usually just use borrowed pointers and an explicit clone if i need to keep it for some reason, but thats just me :\
[00:02:34] <strcat> although a GC wouldn't fix this without being beyond just precise on the stack
[00:02:55] <strcat> skrylar: it's an example, there's no context
[00:03:02] <strcat> there are valid reasons to do what the example does
[00:03:03] *** Quits: _Vi (vi@D7277DB6.6FF508C1.10C239DF.IP) (Ping timeout)
[00:03:35] <dbaupp> wouldn't a (conservative-on-stack) GC fix it if we zeroed GC'd pointers when moved out of on last use?
[00:03:43] <dbaupp> (this isn't necessarily a good idea...)
[00:04:07] <strcat> dbaupp: sure
[00:04:43] <strcat> dbaupp: move semantics do exactly that for Rc
[00:04:57] *** Quits: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP) (Quit: brb)
[00:05:08] <strcat> the compiler could have built-in last-use semantics again as it did before, not just for @
[00:05:21] <skrylar> since Rc is now a library type, i imagine one could make a CyclicRc<> if they wanted to as well
[00:05:30] <strcat> skrylar: which would do what?
[00:05:34] <strcat> on cycles
[00:06:01] *** Quits: benh (ben@moz-4A0366D2.org) (Ping timeout)
[00:06:10] <skrylar> something smart? lol. I'd have to check what the consensus was on cycles
[00:06:22] <ChrisMorgan> What you want in such cases tends to be the concept of strong/weak references. Very often, a single owner and weak references to it.
[00:06:36] <skrylar> yeah, weak references are nice too
[00:06:40] <strcat> you can have multiple owners with strong/weak refs
[00:06:43] *** Quits: kngl1 (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[00:06:46] <strcat> just can't be cyclic or it'll leak
[00:07:01] <strcat> can have a directed acyclic graph of ownership through a cyclic graph of references
[00:07:05] <ChrisMorgan> Certainly.
[00:07:15] <skrylar> you could error on a cyclic relationship, and tell them to use weak refs, or something
[00:07:19] *** Joins: jhasse (jhass_000@moz-FFC47FF9.ewe-ip-backbone.de)
[00:07:41] *** Joins: benh (ben@moz-4A0366D2.org)
[00:07:49] <skrylar> if its a separate type to Rc then its up to the developer whether they care or not
[00:07:53] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:08:38] <strcat> skrylar: you don't know if it's cyclic due to type erased things like closures and trait objects
[00:08:43] <strcat> without adding very strict restrictions
[00:08:53] <pcwalton> acrichto: r? https://github.com/mozilla/rust/pull/11226
[00:09:17] <pcwalton> acrichto: this makes the Parser follow the normal uniqueness/mutability/borrowing rules, erasing all @muts (and @s) from it
[00:09:33] <pcwalton> except for the @mut Trait stuff which I'm addressing separately in the demuting branch
[00:09:41] <pcwalton> that branch is ready to go though
[00:10:05] *** Quits: vodik (simon@moz-42DA1A76.range86-149.btcentralplus.com) (Quit: WeeChat 0.4.3-dev)
[00:10:53] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[00:11:07] *** Quits: mib_h7le9f (Mibbit@moz-84A7864F.hsd1.ga.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[00:11:34] *** Quits: nkoep (nik@moz-614D7A24.pool.mediaways.net) (Quit: Leaving)
[00:12:27] <acrichto> nice work!
[00:12:38] <acrichto> makes me happy to see less @ in the compiler every day
[00:14:41] <acrichto> yea/nea 0x80i8 is out of the type range?
[00:15:15] <pcwalton> I think we decided to trust the programmer if they use a hex literal but I forget?
[00:15:20] <strcat> acrichto: yes it goes -128 to 127
[00:15:34] <acrichto> urgh I hate that lint
[00:15:47] <acrichto> if I give you a hex literal I don't want a warning about it
[00:16:04] <strcat> two's complement is weird that way since they're represented the same as unsigned ints and add/sub/mul are the same uop
[00:16:22] <strcat> acrichto: hm, but why not?
[00:16:25] <strcat> rusti: 0x80
[00:16:28] -rusti- 128
[00:16:34] <strcat> rusti: 0x80i8
[00:16:35] -rusti- -128i8
[00:16:50] <acrichto> I have specified that this is an 8-bit value, I gave you a definition of all 8 bits, you shouldn't warn mea bout that
[00:17:00] <strcat> shouldn't you use u8 then?
[00:17:07] <acrichto> not if I want it to be signed
[00:17:16] <acrichto> I was just testing 0x80i8 >> 1
[00:17:20] <acrichto> which is different than 0x80u8 >> 1
[00:17:47] <skrylar> i didn't think 128 was valid, because there's a zero in there somewhere
[00:17:59] * skrylar goes back to the cave
[00:18:06] <acrichto> I totally agree 128i8 should be invalid
[00:18:11] <acrichto> or at least have a warning
[00:18:12] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[00:18:19] <acrichto> 0xff, however, should not
[00:18:40] *** Joins: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au)
[00:18:53] <skrylar> i think the issue there is that 0xFF is technically 255, and the compiler is treating it like you just told it to put 255 in a signed unibyte
[00:19:28] <acrichto> but I'm not dealing with values in hex/octal/binary, I'm dealing with bit patterns
[00:19:48] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:19:51] <acrichto> I didn't ask for 255 to be placed into an i8 slot, I asked for the "all-1" bit pattern to be placed in the slot
[00:20:00] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[00:21:03] <skrylar> transmute(0xFF)?
[00:21:11] <ChrisMorgan> If 128i8 produces a warning or an error, I believe 0x80i8 should too. Treating literals of different forms differently in this way strikes me as inconsistent and undesirable.
[00:21:23] <skrylar> to me, 0xFFi8 doesn't read as "fill all the bits", it reads as "put 255 in a signed 8-bit"
[00:21:36] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[00:21:47] <ChrisMorgan> If I wanted bit patterns, I should be using u8 rather than i8.
[00:21:59] <acrichto> maybe I should just added RUST_FLAGS env var and set -A type_casts for myself then lol
[00:22:33] <skrylar> it sounds like what you're trying to do is satisfied by transmute or similar, which does explicitly state "shove these bits in those bits"
[00:23:00] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[00:23:06] <acrichto> it sounds like I just work differently, hex literals are bit patterns to me, not values
[00:23:18] <ChrisMorgan> Hey, we could have parser state change like that too… we need something like PHP’s environment-variable-or-apache-config-or-php.ini-or-ini_set-or-maybe-something-else-as-well.
[00:23:42] <ChrisMorgan> Hex literals may be bit patterns, but they may also be genuine numbers. I use both commonly.
[00:24:17] <skrylar> i seem to remember FreePascal complains about hex out of bounds, and some of the stricter C's
[00:24:30] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[00:24:52] *** Joins: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP)
[00:25:45] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[00:26:24] *** Quits: short (Mibbit@moz-E1532C88.amazon.com) (Quit: http://www.mibbit.com ajax IRC Client)
[00:27:12] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[00:27:34] *** Joins: twi1 (Adium@moz-174339A4.cust.dsl.vodafone.it)
[00:27:45] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Connection reset by peer)
[00:27:50] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[00:28:56] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[00:29:03] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[00:29:03] *** Quits: twi1 (Adium@moz-174339A4.cust.dsl.vodafone.it) (Connection reset by peer)
[00:30:54] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Ping timeout)
[00:33:17] *** Quits: io2 (io2@moz-34E8FDD4.home.otenet.gr) (Quit: )
[00:37:08] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[00:38:17] *** Joins: pheleas_frog (Mibbit@DDBB49A3.7E771A85.4707F662.IP)
[00:38:20] *** Quits: pheleas_frog (Mibbit@DDBB49A3.7E771A85.4707F662.IP) (Quit: pheleas_frog)
[00:38:38] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[00:40:09] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:42:13] <pcwalton> ok, all "@mut" removed from libsyntax, now to get it to compile
[00:42:19] <pcwalton> after that, on to librustpkg and librustdoc
[00:42:20] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[00:42:35] *** Joins: alan_andrade (alan_andra@2D866054.D1EB06A3.B7838CA6.IP)
[00:42:55] *** Joins: ekwan (ekwan@moz-6635E2EF.hsd1.ca.comcast.net)
[00:43:10] <cmr> only two uses of @mut, in its visitor and in the extra::json interaction
[00:43:17] <cmr> that can be changes to &mut though
[00:44:14] *** Parts: ekwan (ekwan@moz-6635E2EF.hsd1.ca.comcast.net) ()
[00:44:24] *** Quits: alan_andrade (alan_andra@2D866054.D1EB06A3.B7838CA6.IP) (Ping timeout)
[00:46:05] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[00:47:15] <dbaupp> cmr: I thought the extra::json @mut was removed
[00:47:38] <cmr> dbaupp: it was
[00:47:44] <cmr> it can be changed to &mut, as I said :p
[00:49:35] <dbaupp> I meant I thought it was already removed from rustdoc, but grep tells me that there are a few json @mut's still there
[00:49:46] <cmr> oh, yeah.
[00:49:55] <cmr> it was removed from multibuilder though :p
[00:50:19] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[00:51:38] *** Quits: tulloch (tulloch@moz-F362C074.lnse2.pie.bigpond.net.au) (Input/output error)
[00:53:26] <dbaupp> strcat: doesn't `pub use cmp;` work? https://github.com/thestinger/rust-core/commit/f6b6796df41699f92ab4dbb16b3a4ac12815c8ea#diff-772a9c2b17534b7d369952218954e895R89
[00:53:41] <strcat> I guess
[00:54:03] *** Quits: Bewilderforce (Bewilderfo@moz-EA5D4D40.ed.shawcable.net) (Ping timeout)
[00:54:18] <dbaupp> (just wondering if you'd met errors with it.)
[00:54:41] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[00:54:50] *** Joins: elux (peter@moz-6B45ADE5.dsl.bell.ca)
[00:56:28] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:58:40] *** Joins: centip3de (Mibbit@moz-DBAC3A38.static.wvi.com)
[00:58:52] *** Joins: Bewilderforce (Bewilderfo@moz-EA5D4D40.ed.shawcable.net)
[00:59:12] <centip3de> I have a quick question, but I can't figure it out for the life of me
[00:59:28] <centip3de> How would one make an array?
[00:59:34] <centip3de> Just a simple array of ints
[00:59:40] <dbaupp> ~[1, 2, 3]
[00:59:44] <dbaupp> for a ~[int]
[01:00:26] <centip3de> Would you access it in the usual sense? let mut foo: ~[int] = ~[1, 2, 3]; foo[0] = 2;
[01:00:44] <strcat> rusti: let mut xs = [1, 2, 3]; xs[0] = 10; xs
[01:00:45] -rusti- [10, 2, 3]
[01:00:54] <strcat> rusti: let mut xs: [int, ..3] = [1, 2, 3]; xs[0] = 10; xs
[01:00:55] -rusti- [10, 2, 3]
[01:01:05] <centip3de> Thank God
[01:01:07] <strcat> ~[int] if you want a dynamic array
[01:01:27] <centip3de> I've been tearing my hair out for hours trying to get this crap to work
[01:01:30] <brson> yikes. the pr queue is pretty huge these days
[01:01:46] <brson> need to put some effort into getting things reviewed
[01:01:54] <strcat> centip3de: there's the basic http://static.rust-lang.org/doc/master/tutorial.html#vectors-and-strings intro to them
[01:02:01] *** Joins: ekwan (ekwan@moz-6635E2EF.hsd1.ca.comcast.net)
[01:02:20] <FreeFull> rusti: let mut xs: [int, ..3] = [1, 2, 3]; xs[4]
[01:02:21] -rusti- out.rs:9:16: 9:18 warning: variable does not need to be mutable, #[warn(unused_mut)] on by default
[01:02:21] -rusti- out.rs:9         let mut xs: [int, ..3] = [1, 2, 3]; xs[4]
[01:02:21] -rusti-                          ^~
[01:02:21] -rusti- task '<unnamed>' failed at 'index out of bounds: the len is 3 but the index is 4', out.rs:9
[01:02:21] -rusti- application terminated with error code 101
[01:02:35] <FreeFull> Ah, I hoped for a compile-time error
[01:02:40] <dbaupp> brson: the doc update https://github.com/mozilla/rust/pull/10892 seems easy enough for someone who understands the exact semantics (possibly you)
[01:03:12] <strcat> FreeFull: easy enough to add a warning for that
[01:03:35] <strcat> but there are endless things like that
[01:03:39] *** Parts: ekwan (ekwan@moz-6635E2EF.hsd1.ca.comcast.net) ()
[01:03:53] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[01:06:29] *** Quits: heftig (heftig@moz-FB34F68F.dip0.t-ipconnect.de) (Ping timeout)
[01:09:06] *** Quits: jhasse (jhass_000@moz-FFC47FF9.ewe-ip-backbone.de) (Quit: Verlassend)
[01:09:08] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[01:09:19] *** Joins: pnkfelix (pnkfelix@moz-3DF70E54.hsd1.wa.comcast.net)
[01:09:26] *** Quits: pnkfelix (pnkfelix@moz-3DF70E54.hsd1.wa.comcast.net) (Input/output error)
[01:11:43] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[01:12:24] <FreeFull> strcat: It makes me sort of miss dependent typing though
[01:12:34] *** Joins: alan_andrade (alan_andra@2D866054.D1EB06A3.B7838CA6.IP)
[01:15:23] *** Joins: heftig (heftig@moz-65B20D7C.dip0.t-ipconnect.de)
[01:16:12] <skrylar> hrm.
[01:16:29] <skrylar> well thats.. annoying. `rustc` gets upset if multiple enum values have the same integral value
[01:16:39] <skrylar> Some of the nix terminal code actually does that
[01:17:21] <whitequark> but that doesn't make any sense
[01:17:56] <skrylar> whitequark: terminal code is a notorious mess
[01:17:59] <strcat> skrylar: rust's enums aren't meant to be used as C enums
[01:18:05] <strcat> they aren't enumerated constants
[01:18:07] <strcat> they are variants
[01:18:12] <strcat> poor naming, I agree
[01:18:14] <pcwalton> ok, all @mut removed from rustdoc and rustpkg
[01:18:18] <skrylar> strcat: they are if they have repr() on them, though
[01:18:23] <tomdale> are there docs on crate link attributes I can take a peek at?
[01:18:44] <strcat> skrylar: they are a variant with a type tag
[01:18:50] <skrylar> haXe has variant enums too, and I think they took that from ML
[01:18:52] <strcat> when they are all integers, you're setting the value of that tag
[01:19:13] <strcat> it needs to be able to distinguish between the tags and it needs to be an exhaustive list (no OR'ing them together) or match wouldn't be sound
[01:19:27] <skrylar> i liked go's Iota special token though, which they used instead of C enums
[01:19:31] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Quit: killerswan)
[01:19:58] <pcwalton> Iota is pretty bad
[01:20:03] <pcwalton> it doesn't allow for exhaustiveness
[01:20:07] <pcwalton> exhaustiveness checking
[01:20:18] <skrylar> iota is nice when you're dealing with bit masks
[01:20:23] <skrylar> (1 << iota)
[01:20:24] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[01:20:39] <pcwalton> I guess, but you could just use a macro
[01:20:58] <skrylar> that gets back in to the having to make a giant macro to fit all of the type in to :/
[01:21:09] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:21:25] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[01:21:33] <skrylar> i looked in to extra::EnumSet, which is nice but it assumes you don't require the enum values to have specific bit positions
[01:21:34] <pcwalton> you could implement iota as a macro if you really wanted to, is what I'm saying
[01:21:44] <pcwalton> I think we should have a bitfield! macro
[01:22:08] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[01:22:09] <whitequark> pcwalton: how'd it look like?
[01:22:22] <pcwalton> I dunno
[01:22:41] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[01:22:52] <pcwalton> bitfield!(bit 1 => foo, bit 2 => bar, bit 3 => baz)
[01:22:52] <pcwalton> maybe
[01:23:14] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:29:48] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[01:31:38] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Ping timeout)
[01:33:19] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[01:35:15] <centip3de> Is it possible to convert from a char to an int? If I do, "let number = '2' as int", number equals 50. If I do, "let number = to_digit('2', 10)", I get an option out that I can't convert to an int. 
[01:35:46] <FreeFull> rusti: 50u8 as char
[01:35:47] -rusti- '2'
[01:35:47] <dbaupp> using `as` gives you the unicode code-point number
[01:35:52] <FreeFull> rusti: 50int as char
[01:35:55] -rusti- pastebinned 6 lines of output: http://ix.io/9Au
[01:35:59] <FreeFull> rusti: 50 as char
[01:35:59] *** Joins: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP)
[01:36:01] -rusti- pastebinned 7 lines of output: http://ix.io/9Av
[01:36:41] <centip3de> All I want to do, is to be able to enter n and then use n later on in a math formula. 
[01:37:07] <dbaupp> is it a single character? or a string containing a number?
[01:37:46] <centip3de> Technically it's just a character, though that character comes from a string. 
[01:38:25] <dbaupp> and the problem with to_digit is it returns Option<uint> rather than int?
[01:38:35] <centip3de> Yup
[01:38:41] <dbaupp> rusti: '1'.to_digit(10)
[01:38:41] -rusti- Some(1u)
[01:38:53] <dbaupp> rusti: 'a'.to_digit(10)
[01:38:54] -rusti- None
[01:38:59] <centip3de> rusti: '1'.to_digit(10) as int
[01:39:01] -rusti- pastebinned 7 lines of output: http://ix.io/9Aw
[01:39:15] <centip3de> That's the issue
[01:39:18] <ChrisMorgan> rusti: '1'.to_digit(10).unwrap()
[01:39:20] -rusti- 1u
[01:39:21] <dbaupp> centip3de: you need to extract the value from the Option: it is representing that the conversion can fail
[01:39:28] <dbaupp> (like the 'a'.to_digit case)
[01:39:44] <centip3de> Ooh. Gotcha. 
[01:39:47] <pcwalton> ok, all @mut removed except for support code from libstd/libextra and tests
[01:39:47] <dbaupp> rusti: 'a'.to_digit(10).unwrap_or(0)
[01:39:48] -rusti- 0u
[01:39:57] <dbaupp> rusti: '4'.to_digit(10).unwrap_or(0)
[01:39:58] -rusti- 4u
[01:40:06] <dbaupp> rusti: 'a'.to_digit(10).unwrap()
[01:40:06] -rusti- task '<unnamed>' failed at 'called `Option::unwrap()` on a `None` value', /build/rust-git/src/rust/src/libstd/option.rs:289
[01:40:07] -rusti- application terminated with error code 101
[01:40:16] *** Joins: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au)
[01:40:32] <dbaupp> centip3de: http://static.rust-lang.org/doc/master/std/option/enum.Option.html for various methods of extracting options
[01:40:42] <dbaupp> (also, http://static.rust-lang.org/doc/master/std/option/index.html )
[01:41:11] <centip3de> Thanks
[01:43:29] <ChrisMorgan> Back on the topic of `iota`, we really need something like it. At present things like the lang items macro still needs the numbers to be hard-coded for each line, which is 'orrible.
[01:44:38] <whitequark> gensym!
[01:46:16] <ChrisMorgan> I cannot think of any way in which this can be circumvented in statics without the addition of a new syntax extension; with local variables, you can probably circumvent it with difficulty, maintaining a counter variable yourself, but that's a fairly silly way of doing it.
[01:47:17] <dbaupp> ChrisMorgan: `iota!(ident)` which has a separate count for each `ident`, maybe?
[01:47:51] <ChrisMorgan> dbaupp: either that or a scoped procedural macro of some form.
[01:49:27] <ChrisMorgan> I don't really like `iota!(ident)` because it's got global compiler state. Scoping it in some way would feel distinctly nicer.
[01:50:03] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:50:47] <dbaupp> yeah
[01:51:10] <dbaupp> (there is... scope... for scoping in the expansion stage.)
[01:51:17] *** Quits: ziad (ziad@B20586FB.BDB3D91.6E370BFC.IP) (Quit: ziad)
[01:52:09] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[01:54:21] *** Joins: judder (maradukewa@837BB533.C8128DC0.78E362FE.IP)
[01:54:25] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[01:55:43] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[01:55:53] *** vfetwnuncszu is now known as dcrewi
[01:56:36] <whitequark> is there a way to match a single integer in macros?
[01:56:39] <whitequark> similarly to $ident
[01:57:11] *** Quits: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) (Quit: Lost terminal)
[01:58:18] <whitequark> looks like there is not
[01:58:58] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:59:18] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[01:59:19] <sfackler> you can use pat or expr in some cases
[01:59:46] <whitequark> yeah, I'm using expr now
[02:00:58] <centip3de> Herm. Any reason why I'm getting an error when trying to assign a variable to the output of an if-statement that's the output of a function? Essentially the same thing that's here (http://static.rust-lang.org/doc/0.8/tutorial.html#syntax-basics) in section 3.1, but with a function instead of a number. 
[02:01:02] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[02:01:08] <centip3de> I'm getting a type error
[02:01:22] <dbaupp> centip3de: what's the code and error message?
[02:02:04] <centip3de> Herm. It's a bit long. I'll pastebin it
[02:03:02] <centip3de> http://pastebin.com/PGwtPK0g
[02:03:05] <centip3de> Code at the top
[02:03:09] <centip3de> Error at the bottom
[02:04:28] <FreeFull> You should include the code for div
[02:04:45] <FreeFull> I think you have one semicolon too many in div's definition
[02:04:53] <centip3de> fn div(first: int, second: int) -> int { 	return first / second; }
[02:04:57] <centip3de> There's div
[02:05:02] <FreeFull> Yep
[02:05:06] <FreeFull> Get rid of that semicolon
[02:05:21] <FreeFull> Actually, hmm
[02:05:21] <FreeFull> No
[02:05:22] <dbaupp> FreeFull: no
[02:05:29] <FreeFull> Because explicit return
[02:05:30] <FreeFull> Hmm
[02:05:30] <dbaupp> with return, a trailing semi is fine
[02:05:44] *** Joins: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se)
[02:05:54] <dbaupp> centip3de: the problem is the chain of if else-if without an else
[02:06:09] <dbaupp> what value is result if all the conditions fail?
[02:06:22] <FreeFull> Good point
[02:06:45] <centip3de> The result is massive errors. Just how I like it. 
[02:07:12] <dbaupp> btw, this would be clearer as `let a = nums[0] as int; let b = nums[2] as int; let result = match operation { '+' => add(a, b), '*' =>  mul(a, b), ... }`
[02:07:37] <whitequark> hm, how do I convert integers to enums?
[02:07:45] <dbaupp> I mean, conceptually, what value should `result` be if `operation` isn't *, +, / or -
[02:08:03] <centip3de> I just did a match up above it. Wasn't exactly feeling like doing another one. Seemed inefficient
[02:08:10] <centip3de> But yep, that worked
[02:08:13] <dbaupp> no, if chains are inefficient
[02:08:20] <dbaupp> match is efficient
[02:08:34] <centip3de> Woudn't they compile to the same code?
[02:08:38] <centip3de> *Wouldn't
[02:08:40] <dbaupp> not necessarily
[02:08:55] <dbaupp> in any case, the match is singificantly DRY-er
[02:08:57] <dbaupp> and shorter
[02:09:00] <dbaupp> and neater.
[02:09:05] <centip3de> I suppose
[02:09:07] * dbaupp likes `match`
[02:10:09] * FreeFull likes pattern matching
[02:10:15] * centip3de likes pasta
[02:10:27] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[02:10:40] * FreeFull matches centip3de's pasta with a pattern
[02:10:50] * centip3de eats the pasta
[02:10:55] *** Joins: maikklein (maik@moz-502609D4.dip0.t-ipconnect.de)
[02:11:49] <alan_andrade> I can't make this test to pass.
[02:11:52] <alan_andrade> https://gist.github.com/alan-andrade/8191375
[02:12:21] <whitequark> I expect to see something like #[deriving(FromInt)], but can't find one
[02:12:25] <alan_andrade> I need to add a feature for a documentation test.
[02:12:25] <dbaupp> alan_andrade: either do something like `/* */ #[feature(managed_boxes)];`
[02:12:32] <dbaupp> alan_andrade: or update
[02:13:20] <dbaupp> alan_andrade: the doc test runner used to hide lines starting with # from the output, but still execute them... minus the # (i.e. you can hide setup code from examples)
[02:13:37] <dbaupp> alan_andrade: this has changed to lines starting with '# ', so that #[feature] and #[deriving] etc, all work.
[02:13:53] <dbaupp> (that is, starting with # then a space.)
[02:14:06] <dbaupp> whitequark: #[deriving(FromPrimitive)] iirc
[02:14:51] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[02:14:54] <centip3de> Herm. Do you have to initialize all variables? 
[02:15:07] <whitequark> dbaupp: that worked, thanks
[02:15:10] <dbaupp> variables have to be initialised before use, yes
[02:15:20] <centip3de> Hm. Lame. 
[02:15:29] <centip3de> That makes it more difficult to use immutable data
[02:15:46] <dbaupp> you don't have to initialise them at the declaration
[02:16:13] <dbaupp> rusti: let a; if std::rand::random() { a = 1; } else { a = 2; } a
[02:16:14] -rusti- 2
[02:16:15] <dbaupp> rusti: let a; if std::rand::random() { a = 1; } else { a = 2; } a
[02:16:16] -rusti- 1
[02:16:30] <centip3de> Herm. 
[02:16:40] <dbaupp> they just have to be written to before any reads
[02:16:41] <dbaupp> rusti: let a; if std::rand::random() { a = 1; } a
[02:16:44] -rusti- pastebinned 7 lines of output: http://ix.io/9Ay
[02:17:16] <centip3de> I set operation in a case/match, then later do a case/match on operation itself. It's not happy about it.
[02:17:25] <dbaupp> code?
[02:17:43] <centip3de> Screw it, you can just have all my code. I'm sure I could have done something else better than I did. 
[02:18:16] <centip3de> http://pastebin.com/iP2Q3j8G
[02:18:25] <centip3de> Line in question is 35
[02:18:28] <centip3de> When it's:
[02:18:34] <centip3de> let mut operation: char = ' ';
[02:18:38] <centip3de> It works just fine
[02:19:02] <dbaupp> ah, the problem there is there's no guarantee that operation is actually set
[02:19:13] <dbaupp> e.g. what if someone enters "foo"
[02:19:15] <whitequark> or that it's set just once
[02:19:50] *** Quits: rce (henryhei@moz-4C25427B.cs.helsinki.fi) (Ping timeout)
[02:19:56] <centip3de> Is it possible to do the same thing without using mutables? 
[02:20:02] <centip3de> I'm using more than I'd prefer
[02:20:04] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[02:20:16] <dbaupp> unlikely
[02:20:49] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[02:21:32] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:22:20] <centip3de> That kind of sucks. There should be a way to allow unsafe code. 
[02:22:34] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[02:22:35] *** Quits: Bewilderforce (Bewilderfo@moz-EA5D4D40.ed.shawcable.net) (Connection reset by peer)
[02:22:43] <dbaupp> there is
[02:22:58] <dbaupp> but surely a mutable variable is strictly better than unsafe code.
[02:22:59] <centip3de> Orly?
[02:23:03] <centip3de> Well
[02:23:04] <centip3de> Yeah
[02:23:09] <centip3de> But for future reference
[02:23:19] <dbaupp> yes, `unsafe { ... }`, but that's only certain classes of "unsafe"-ness
[02:23:37] *** Joins: vmx_ (vmx@moz-6BCF7F11.pools.arcor-ip.net)
[02:23:38] <dbaupp> e.g. dereferencing pointers that could be null, calling C functions
[02:23:54] <strcat> well, calling unsafe functions
[02:24:08] <carter> whats a good example lib / role model for writing an ffi binding in rust?
[02:24:10] *** Joins: rce (henryhei@moz-4C25427B.cs.helsinki.fi)
[02:24:14] <speckle> no way around making unsafe calls at some level if you want to talk to the OS, huh? 
[02:24:15] <dbaupp> strcat: yes, but that's tautologically unsafe, and not a very good example :)
[02:24:39] <dbaupp> speckle: if your OS is written in Rust it's possibly possible :P
[02:24:40] *** Quits: vmx (vmx@moz-2197A4B5.pools.arcor-ip.net) (Ping timeout)
[02:24:46] *** Joins: astropirate (astropirat@8A97D38A.5117C5FE.465000F8.IP)
[02:24:56] <dbaupp> carter: there's http://static.rust-lang.org/doc/master/tutorial-ffi.html
[02:25:07] <strcat> speckle: the compiler itself counts as one giant unsafe block anyway
[02:25:12] <speckle> someone should go poke the Hurd devs to rewrite everything in Rust, it's not like they will get done any later from that 
[02:25:14] <strcat> language features are trusted just as unsafe blocks are
[02:25:25] *** Joins: steveno (steveno@moz-2B2BE86F.hsd1.pa.comcast.net)
[02:25:41] *** Quits: derby (dirby@moz-2D5D59EE.de) (Input/output error)
[02:26:39] <centip3de> Would throwing my variable declaration an 'unsafe {...}' allow it to go forward without any errors?
[02:27:05] <centip3de> I know using mut would be far better
[02:27:05] <dbaupp> no
[02:27:07] <centip3de> Just curious
[02:28:01] <dbaupp> things always have to be initialised, even in unsafe code, but you can explicitly initialise them to an undefined value, which is essentially the same as leaving them undefined
[02:28:20] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x = uninit(); x }
[02:28:23] -rusti- pastebinned 10 lines of output: http://ix.io/9Az
[02:28:38] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: int = uninit(); x }
[02:28:39] -rusti- 0
[02:28:41] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: int = uninit(); x }
[02:28:42] -rusti- 140024993548848
[02:28:43] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: int = uninit(); x }
[02:28:44] -rusti- 0
[02:29:09] <dbaupp> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: ~[int] = uninit(); x }
[02:29:13] -rusti- line longer than 10000 characters, bailing out
[02:29:16] <dbaupp> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: ~[int] = uninit(); x }
[02:29:17] <heftig> pfft
[02:29:20] -rusti- line longer than 10000 characters, bailing out
[02:29:35] <strcat> dbaupp: the length must be really long ;p
[02:29:38] <centip3de> dbaupp: That's what I was doing. I was just wondering if it were possible to let my code execute as is, using 'unsafe'
[02:29:47] <strcat> dbaupp: *shrug*
[02:30:33] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[02:30:53] <speckle> what on earth?!
[02:32:00] <speckle> why 10000 characters? is it just reading a memory block of an arbitrary size?
[02:32:02] <centip3de> Well thank you all, but I am out of here. Time to let my brain rest. Just started learning Rust today. Made decent progress. 
[02:32:08] <speckle> bye centip3de 
[02:32:17] <strcat> speckle: well it's dereferencing an undef ptr and finding some length
[02:32:18] *** Quits: centip3de (Mibbit@moz-DBAC3A38.static.wvi.com) (Quit: http://www.mibbit.com ajax IRC Client)
[02:32:19] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Ping timeout)
[02:32:27] <speckle> ah, thanks strcat 
[02:32:28] *** Joins: wilmoore (wilmoore@moz-4FDEFDD9.hsd1.co.comcast.net)
[02:32:44] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: &[int] = uninit(); x }
[02:32:45] -rusti- line longer than 10000 characters, bailing out
[02:32:47] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: &[int] = uninit(); x }
[02:32:48] -rusti- line longer than 10000 characters, bailing out
[02:32:49] <strcat> rusti: use std::unstable::intrinsics::uninit; unsafe { let x: &[int] = uninit(); x }
[02:32:50] -rusti- line longer than 10000 characters, bailing out
[02:32:52] <strcat> *shrug*
[02:33:22] <carter> oh cool, i found the atomic intrinsics https://github.com/mozilla/rust/blob/master/src/libstd/unstable/intrinsics.rs#L183-L285
[02:33:22] <carter> :)
[02:33:35] <speckle> yeah, memory attacks can be random, and sometimes it takes a lot of tries to get something to work
[02:33:38] <astropirate> when should I start convincing my boss to ditch .net for rust?
[02:33:41] <astropirate> :)
[02:33:49] <carter> astropirate: whats your problem domain
[02:33:59] <astropirate> web applications
[02:34:03] <astropirate> for core
[02:34:08] <astropirate> then we got a whole bunch of analytics stuff
[02:34:25] <astropirate> which don't really matter what tech it uses as long as it can talk to MS SQL
[02:34:43] <carter> astropirate: i'm investigating rust for performance math sensitive stuff in lieu of assembly and fortran 
[02:34:47] <astropirate> so the analytics stuff is what i woul duse rust for
[02:34:53] <speckle> astropirate - are you having performance problems? are you migrating away from Windows?
[02:35:10] <carter> astropirate: for high level math stuff i think rust isn't the right way to go
[02:35:11] <astropirate> nope no performance issues as of yet
[02:35:21] <astropirate> just playing with new shiny tech
[02:35:23] <carter> astropirate: honestly numpy and scipy are the way to go
[02:35:31] <astropirate> hmm interesting
[02:35:39] <carter> astropirate: i say that as someone writing a competitor to numpy / scipy in haskell
[02:35:40] <speckle> if you have zero performance issues, I am not sure of any reason to use Rust 
[02:35:40] <astropirate> is rust as fast as C++ when it comes to math stuff?
[02:35:47] <carter> both are terrible for math
[02:35:58] <carter> "naive" C++ is terrible for math
[02:36:14] <astropirate> carter, are you talking a bout expressiveness or performance?
[02:36:15] <carter> its very very non obvious how to write good performance numerical routines
[02:36:18] <carter> BOth
[02:36:23] <astropirate> hmm 
[02:36:42] <speckle> yeah, numpy/scipy is pretty nice, if you just want to do some mathy stuff
[02:36:56] *** Quits: wilmoore (wilmoore@moz-4FDEFDD9.hsd1.co.comcast.net) (Ping timeout)
[02:36:58] <astropirate> which would mean I would need to learn python :D
[02:37:00] <carter> the naive matrix mult in C, is 100x slower than a clever one in haskell, and 1000x slower than the hand tuned memory locality + simd + asm in c/c++/fortran
[02:37:11] <astropirate> haskell is nice
[02:37:14] <astropirate> i started learning haskell
[02:37:15] <carter> astropirate: it is!
[02:37:19] <carter> astropirate: :)
[02:37:25] <carter> astropirate: wanna help hack on ghc?
[02:37:26] <speckle> the syntax for arrays in numpy can be fairly tricky, but overall it's easy and lacks the mess of C++
[02:37:28] <carter> its easier than it sounds
[02:37:33] <astropirate> but my coworkers.... i don't see them learning haskell for the next 10 thousand years
[02:37:48] <alan_andrade> hahaha
[02:37:51] <astropirate> just did a massive migration away from asp classic :(
[02:37:53] <carter> astropirate: why not? don't tell them about monads for a while, just show them code that uses em
[02:37:55] <astropirate> ASP CLASSIC!!!
[02:38:08] <strcat> speckle: what's wrong with stuff like eigen? ;\
[02:38:12] <astropirate> learning OOP was a big hurdle for them
[02:38:21] <carter> strcat: speckle  eigen is cool, template errors are scary
[02:38:33] <strcat> carter: in python the error would happen at runtime
[02:38:34] <carter> astropirate: ghc needs more windows testers among the devs
[02:38:43] <astropirate> carter, ohh I'm a linux guy
[02:38:47] <carter> strcat: thats why i uses haskell instead
[02:38:48] <carter> ah
[02:38:59] <carter> astropirate: still, come try building ghc :)
[02:39:01] <astropirate> i just happen to work in a windows shop
[02:39:02] <carter> more people == more awesome
[02:39:16] <astropirate> thats a bit outside my skill set and interest 
[02:39:20] <carter> oh
[02:39:22] <carter> whats your interest?
[02:39:28] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[02:39:28] <astropirate> making end user stuff
[02:39:29] <carter> astropirate: i'm writing some blas/lapack bindings :)
[02:39:31] <carter> oh ok
[02:40:28] <astropirate> carter, lapack bindings for ghc?
[02:40:30] <speckle> strcat, I mean the messiness of C++ in general as opposed to Python
[02:40:32] <astropirate> or rust
[02:40:33] <carter> astropirate: and rust
[02:40:37] <carter> both
[02:40:41] <astropirate> ahh I see
[02:41:07] <astropirate> well I have also been doing GO for past couple of months
[02:41:10] <astropirate> so far really liking it
[02:41:17] <speckle> what's the big deal about Go? it seems silly
[02:41:18] <SiegeLord> I want a nice numerical library in Rust... 
[02:41:19] <carter> astropirate: go's lack of generics makes me sad and mad
[02:41:29] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:41:31] <astropirate> yes, thats the one thing I wish for.. generics
[02:41:38] <carter> SiegeLord: i'm happy to try to oblige
[02:41:39] <speckle> Go seems more primitive than Java 6
[02:41:41] <astropirate> but people wiser and smarter than me tell me nahh you don't need them
[02:41:49] <astropirate> just design better
[02:41:50] <strcat> astropirate: one thing? how about sum types? safety from data races? ;p
[02:41:52] <carter> astropirate: i need generics to engineer correct code
[02:41:53] <SiegeLord> carter: Any ETA on it?
[02:42:05] <speckle> smart people are not always right
[02:42:24] <carter> SiegeLord: i'll try to hammer out a basic dumb no abstraction blas / lapack binding  this week
[02:42:38] <carter> then i'll start thinking about how to design a decent api for current rust
[02:42:52] <carter> along with "nice to haves" to writing a great api in the future
[02:42:55] <SiegeLord> I care more about the API than the blassness... but alright
[02:43:03] <carter> SiegeLord: well, i'm still learning rust
[02:43:06] <SiegeLord> I'll be interested in what comes out of it
[02:43:19] <carter> and my current api designs require fancier types than rust 1.0 is slated
[02:43:20] <brson> would people rather break on rust_begin_unwind or rust_fail?
[02:43:35] <brson> maybe sticking with the old rust_begin_unwind is most prudent
[02:43:48] <SiegeLord> rust_fail is shorter to type...
[02:43:53] <dbaupp> brson: rust_fail seems more sensible
[02:44:00] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Ping timeout)
[02:44:01] <carter> SiegeLord: my near term focus is  the haskell numerical lib
[02:44:03] <dbaupp> (it's not like we care much about BC in much else yet ;P )
[02:44:12] <SiegeLord> Unless there's an expectation of some sort of predefined break macro in gdb?
[02:44:44] <carter> does that make sense?
[02:45:17] <SiegeLord> Well, we'll see :P
[02:45:30] <carter> yeah
[02:45:38] <carter> SiegeLord: be glad you didn't know me a year ago
[02:45:39] <carter> :)
[02:45:44] <carter> i'm much more productive now than I was then
[02:45:48] <SiegeLord> Hah
[02:45:54] <SiegeLord> That's great
[02:46:03] <SiegeLord> Being productive is awesome
[02:46:09] <carter> SiegeLord: that said, i think i have an ok api sketched for rust that'll (ab)use phantom types a bit
[02:46:18] <carter> i think
[02:46:38] <carter> one tricky thing is blas / lapack don't actually have a uniform api
[02:46:49] <carter> so i can't actually abstract all of blas /lapack
[02:47:05] <carter> i'll just opportunistically use them as part of a nice api
[02:47:19] <shammancer> Hey guys I am trying to add a bit of error handling to my toy echo client (https://github.com/shammancer/rusty/blob/master/client.rs), except I am getting "client.rs:24:4: 26:4 error: expected function but found `std::condition::Condition<std::io::IoError,()>"
[02:47:22] <carter> and just have the rest be exposed as nice things
[02:48:36] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[02:48:56] <shammancer> Just trying to get the error code from http://static.rust-lang.org/doc/master/std/io/index.html to work with it...
[02:49:00] *** Quits: maikklein (maik@moz-502609D4.dip0.t-ipconnect.de) (Ping timeout)
[02:51:05] *** Quits: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP) (Quit: ERC Version 5.3 (IRC client for Emacs))
[02:52:23] *** Joins: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP)
[02:53:09] *** Quits: astropirate (astropirat@8A97D38A.5117C5FE.465000F8.IP) (Ping timeout)
[02:54:57] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:55:16] *** Joins: pongad (Mibbit@moz-27B324E0.revip2.asianet.co.th)
[02:55:35] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[02:56:10] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[02:57:05] <pongad> Hello good sirs! I'm wondering if there's a plan to add a `rotate` function to stdlib? Or am I just blind? xD
[02:57:35] <pcwalton> yay, I have a bootstrapping rustc with no @mut at all
[02:57:43] <pcwalton> support removed from the compiler
[02:58:20] <pongad> pcwalton: So, @mut can just be syntax sugar now?
[02:58:26] <dbaupp> pongad: rotate as in bit rotate?
[02:58:38] <pcwalton> it'll be removed, replaced with Cell/refCell
[02:59:18] <heftig> @mut [T] => Rc<RefCell<~[T]>> ?
[02:59:34] <carter> whats @mut?
[02:59:37] <pongad> dbaupp: As in C++esqe iterator rotate. Changes [a1 a2 a3 b1 b2] into [b1 b2 a1 a2 a3]. if that makes sense
[03:00:18] <pongad> dbaupp: After that, functions like `partition` can also be implemented
[03:00:26] <dbaupp> carter: the sign of the devil; we will never speak of it again.
[03:01:43] <dbaupp> carter: it's actually a shared pointer such that the contents is mutable, which has some subtle and annoying dynamic checks to avoid violating the invariants that & and &mut have
[03:01:44] <pcwalton> heftig: or Gc<RefCell<~[T]>>
[03:01:45] <pcwalton> yes
[03:02:05] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[03:02:08] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[03:02:17] <dbaupp> pongad: Oh, I see. I don't think we have anything like that
[03:02:38] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:03:47] <pongad> dbaupp: Would it be appropriate to put it in? I volunteer xD
[03:04:13] <dbaupp> pongad: maybe... you can certainly implement it for yourself if you need it.
[03:04:33] <dbaupp> (of the top of my head... it might be tricky to convince the compiler that it's safe.)
[03:05:38] <dbaupp> it might be tricky to do efficiently and safely...
[03:06:45] <pongad> dbaupp: I certainly can. The reason I asked is that I don't think we have functions like `partition` either. They seem to be an important part of STL, IMO at least.
[03:07:01] <pongad> We won't be able to do it with iterators like C++
[03:08:23] <pongad> The way I'm doing it right now is like    vector.rotate(uint_rotate_pivot)
[03:09:13] <dbaupp> I think partition would be relatively easy and safe
[03:09:44] <carter> what invariants  being violated?
[03:09:45] <dbaupp> (fwiw)
[03:09:50] <dbaupp> carter: re @mut?
[03:09:52] <carter> yeh
[03:10:03] <dbaupp> &mut should be the only usable reference to that piece of data
[03:10:19] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:10:23] <carter> ah, so concurrent read write craziers?
[03:10:29] <dbaupp> and & should be immutable, in that it can't be mutated through the current pointer, nor through any other pointer
[03:10:47] <carter> ok
[03:10:55] <dbaupp> if @mut didn't check, then soemthing like `let x = @mut 1; let y = &mut *x; let z = &mut *x;` would break the &mut one
[03:10:56] <carter> i need more explaining
[03:11:02] <carter> hm
[03:11:22] <dbaupp> `let y = &mut *x; let z = &*x; *y = 2;` would break the & one
[03:11:47] <carter> break in which sense/
[03:11:54] <carter> walk me through this operationally?
[03:11:59] <pongad> Oh I see it
[03:12:08] *** Quits: judder (maradukewa@837BB533.C8128DC0.78E362FE.IP) (Ping timeout)
[03:12:08] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:12:20] <dbaupp> in the first one, both y and z are &mut int pointers pointing to the same piece of data (the 1 in x)
[03:12:26] <carter> ok
[03:12:27] <dbaupp> and both are usable
[03:12:40] <carter> ok
[03:12:46] <dbaupp> in the second, we modify the value that z points to through another pointer
[03:13:02] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[03:13:24] <carter> ok, and semantically, those constructs require  ownership?
[03:13:24] <dbaupp> (the second one actually breaks the &mut invariant too, since we have a &mut and & pointing to the same piece of data, both useable)
[03:13:30] <carter> the borrowing stuff?
[03:14:08] <pongad> I think the point is that you can change y and z would also change even z is supposed to be immutable right?
[03:14:19] <dbaupp> I guess? ... when you take a &mut to the @mut, you're effectively "owning" the @mut at that point
[03:14:36] <dbaupp> pongad: yes, exactly
[03:14:56] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[03:15:00] <carter> how would GC'd references differ from @mut?
[03:15:06] <brianm> how would I install rust-http with rustpkg?
[03:15:35] <dbaupp> carter: the borrowing would be explicit, so it's far more obvious when you're risking failure
[03:15:52] <dbaupp> rusti: let x = @mut 1; let _y = &mut *x; let _z = &mut *x;
[03:15:55] -rusti- pastebinned 10 lines of output: http://ix.io/9AD
[03:16:15] *** Joins: astropirate (astropirat@9DAFB0AB.C6971763.8D80FBB2.IP)
[03:17:03] <dbaupp> bleh, I can't demonstrate it
[03:17:12] <dbaupp> but I think `let x = @mut 1; fn foo(y: @mut int, _z: &mut int) { let _w = &mut *y; } foo(x, x)` would fail
[03:18:02] <dbaupp> (the examples I gave above are simplified version of that^ code just there; since the compiler does actually those exact examples as overlapping borrows)
[03:21:20] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[03:22:07] <pongad> dbaupp: So, do we agree to keep `rotate` and `partition` out of stdlib?
[03:23:02] <dbaupp> pongad: no
[03:23:08] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[03:23:47] <dbaupp> pongad: I'm pretty much neutral on their inclusion; you'll have to ask someone else for a decision :)
[03:24:33] <pongad> Who should I ask? xD
[03:24:38] <pongad> pretty new to the community
[03:25:16] <dbaupp> strcat's the originator of the iterator module, but he's doing less stdlib work now than before
[03:25:53] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:26:30] <pongad> Gotcha.
[03:26:44] <pongad> Should I try to catch him when he's on?
[03:27:11] <dbaupp> if you implement them anyway, feel free to open a PR (although you may feel like getting some more feedback before spending the energy on that)
[03:27:42] *** Quits: sammykim (sammy.kim@5AB4884B.FCC4549.14D5B978.IP) (Quit: Lost terminal)
[03:27:52] *** Joins: mr_fribble (Mibbit@moz-EB2EFE6F.lns20.syd6.internode.on.net)
[03:28:00] *** Quits: mr_fribble (Mibbit@moz-EB2EFE6F.lns20.syd6.internode.on.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:28:03] <dbaupp> I believe he's on now
[03:28:37] <pongad> Yeah, I was thinking about getting some blessing from a higher up xD
[03:28:48] <shammancer> Hey guys I am trying to add a bit of error handling to my toy echo client (https://github.com/shammancer/rusty/blob/master/client.rs), except I am getting "client.rs:24:4: 26:4 error: expected function but found `std::condition::Condition<std::io::IoError,()>"
[03:29:51] <dbaupp> shammancer: what version of Rust?
[03:30:07] <dbaupp> shammancer: the syntax on master appears to be different: http://static.rust-lang.org/doc/master/std/condition/index.html
[03:30:11] <shammancer> 0.9 pre
[03:30:33] <dbaupp> io_error::cond.trap(...).inside(|| { ... })
[03:31:11] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[03:31:17] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[03:31:53] <shammancer> What do you trap?
[03:32:59] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Ping timeout)
[03:33:09] <shammancer> http://static.rust-lang.org/doc/master/std/io/index.html The error section on this page is wrong then...
[03:34:14] <dbaupp> shammancer: oh, so it
[03:34:53] <dbaupp> (if you feel like submitting a PR fixing that, ping me and I'll review it for you :) )
[03:35:00] <dbaupp> if not, please file a bug
[03:35:10] <shammancer> On github?
[03:36:35] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[03:37:02] <dbaupp> yes
[03:37:05] <shammancer> k
[03:37:48] <shammancer> What should I be trapping?
[03:38:41] <dbaupp> I don't understand what you mean by that
[03:38:52] <dbaupp> does the example in http://static.rust-lang.org/doc/master/std/condition/index.html answer that question?
[03:39:22] <shammancer> Yup thanks
[03:40:53] *** Quits: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Client exited)
[03:40:54] *** Quits: zz_kimundi (kimundi@moz-6166D3C8.dip0.t-ipconnect.de) (Ping timeout)
[03:41:38] <pongad> dbaupp: So, strcat seems to not be on. Is there a way for me to leave him a message?
[03:42:00] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[03:42:03] <dbaupp> pongad: not via IRC
[03:42:12] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Quit: Leaving.)
[03:42:27] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[03:42:28] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[03:42:41] *** vfetwnuncszu is now known as dcrewi
[03:44:25] *** Joins: zz_kimundi (kimundi@moz-B14500D7.dip0.t-ipconnect.de)
[03:44:28] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[03:44:46] *** zz_kimundi is now known as kimundi
[03:45:03] <pongad> dbaupp: K, I'll try to catch him when he's on. I won't have access to my linux machine until next week anyway.
[03:47:33] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:47:46] *** Quits: pongad (Mibbit@moz-27B324E0.revip2.asianet.co.th) (Quit: http://www.mibbit.com ajax IRC Client)
[03:48:56] <shammancer> https://github.com/mozilla/rust/issues/11232
[03:50:00] <dbaupp> shammancer: thanks
[03:50:09] <shammancer> No problem
[03:50:27] <shammancer> Is it good? Should I change it a bit?
[03:51:03] <SiegeLord> Is there no memoserv on mozzila's severs?
[03:51:36] <SiegeLord> *servers
[03:53:11] <SiegeLord> Looks like there is... but pongad already left so meh...
[03:54:58] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[03:55:57] *** Quits: Ferreus (ferreus@moz-89CF2F76.pools.arcor-ip.net) (Quit: WeeChat 0.4.2)
[03:56:38] <dbaupp> shammancer: seems fine
[03:56:43] <dbaupp> SiegeLord: oh, oops
[03:57:22] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[03:57:25] <shammancer> K thansk
[04:05:34] *** Quits: ofeldt (ofeldt@moz-52BA9541.dip0.t-ipconnect.de) (Ping timeout)
[04:09:14] *** Joins: ofeldt (ofeldt@moz-52BA9541.dip0.t-ipconnect.de)
[04:10:13] *** Joins: gkostyanikov (gkostyanik@80620F73.3E410295.CA6E2165.IP)
[04:11:43] *** Joins: mib_d3btyh (Mibbit@moz-FE48F4A7.cinci.res.rr.com)
[04:13:01] *** Quits: mib_d3btyh (Mibbit@moz-FE48F4A7.cinci.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[04:13:57] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[04:14:45] <shammancer> How would you trap an IoERror
[04:15:30] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:19:40] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[04:19:52] *** vfetwnuncszu is now known as dcrewi
[04:19:58] <brianm> how would I install rust-http with rustpkg?
[04:20:50] <alan_andrade> What's wrong with this test, :( I can't make it pass
[04:21:06] <klutzy> brianm: as I remember chris-morgan removed rustpkg support from rust-http
[04:21:13] <brianm> ah
[04:21:20] <brianm> was listed as usable
[04:21:29] <brianm> so, how would I rely on rust-http?
[04:21:33] <alan_andrade> https://github.com/alan-andrade/rust/commit/4e189777509e040d006d37a3e6674a86ffd70307
[04:21:39] <klutzy> hmm, it just not use rustpkg for Makefile but it may still support it
[04:21:50] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:22:07] <dbaupp> alan_andrade: what's the error?
[04:22:32] <brianm> with master, incantation:
[04:22:32] <alan_andrade> the feature directive has no effect, https://gist.github.com/anonymous/210e6b4e306480abf7bc
[04:22:32] <brianm> rustpkg install github.com/chris-morgan/rust-http
[04:22:33] <brianm> ?
[04:22:48] <Luqman> alan_andrade: missing a semi-colon :P
[04:22:59] <alan_andrade> I compiles though
[04:23:05] <Luqman> #[feature(managed_boxes)];
[04:23:07] <dbaupp> alan_andrade: fwiw, I'd just not mention @str in the example, it's likely to be removed
[04:23:30] <Luqman> alan_andrade: yes, it's still valid syntax it just doesn't mean what you want
[04:23:40] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[04:24:06] <alan_andrade> The intention of the PR is not to change the documentation
[04:24:38] <dbaupp> what's the purpose of the change then?
[04:24:53] <dbaupp> to demonstrate #[feature(managed_boxes)]?
[04:25:27] <alan_andrade> No, it was a proposal of https://github.com/mozilla/rust/pull/11142#issuecomment-31208231
[04:26:14] <dbaupp> Oh, I see
[04:26:18] <klutzy> brianm: running `rustpkg install http` in git repo works, but it needs `git clone ...` at first
[04:26:35] <klutzy> I just don't know how to install it from remote repo :p
[04:26:48] <alan_andrade> The initial PR purpose was to modify the getopts docs to use specific mods instead of ::*
[04:27:34] <dbaupp> and it expanded...
[04:28:02] <alan_andrade> correct.
[04:28:14] <alan_andrade> A little bit. It seemed pretty simple
[04:28:27] <klutzy> brianm: ah, it doesn't work unless you manually invoke `make` first.
[04:28:33] <alan_andrade> and I'm pretty sure it is
[04:28:48] <dbaupp> alan_andrade: (fwiw, since you're submitting this to mozilla/rust, it would be good to rebase on top of master at some point to remove the unnecessary `/* */`, and putting a comment like `// required for @str` near the feature would be good.)
[04:29:20] <dbaupp> alan_andrade: (did you see Luqman's comment about `#[feature(managed_boxes)];`?)
[04:29:58] <Luqman> dbaupp: for a second there i thought you meant comment on github and was confused ;P
[04:30:16] <alan_andrade> I did, the semi-colon yields another error
[04:30:39] <alan_andrade> I'll rebase and come back with results
[04:30:47] <dbaupp> alan_andrade: ah? what's the error?
[04:30:55] <brianm> klutzy: am confused as bejoobers
[04:30:55] <dbaupp> Luqman: maybe I did :P
[04:30:56] <alan_andrade> Expecting object, sow ;
[04:30:58] <alan_andrade> or something like that
[04:31:02] <dbaupp> alan_andrade: hm
[04:31:03] <brianm> I want to make executable which uses http
[04:31:25] <brianm> a .rust/ in tat projct is great place to drop things, yea
[04:31:37] <brianm> I can rustpkg install, which fetches but fails build
[04:31:40] *** Joins: derek_c (derek@9444CCD6.74FA9A9F.EB673A25.IP)
[04:31:50] <brianm> if I cd into downlaoded sources and run make, it succeeds (with unused code warnings)
[04:32:02] <brianm> but I go back up to my project, and rustpkg install/build still craps
[04:32:03] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[04:32:19] <alan_andrade> @dbaupp Is it normal that the tests take super long to run ?
[04:32:36] <alan_andrade> I do make check-stage2-doc-std
[04:32:37] <brianm> kite:~/src/rust-play<master *#%>$ rustpkg install github.com/chris-morgan/rust-http
[04:32:37] <brianm> WARNING: The Rust package manager is experimental and may be unstable
[04:32:47] <brianm> task '<unnamed>' failed at 'Unhandled condition: nonexistent_package: (crate_id::CrateId{path: std::path::posix::Path{repr: ~[103u8, 105u8, 116u8, 104u8, 117u8, 98u8, 46u8, 99u8, 111u8, 109u8], sepidx: None}, short_name: ~"github", version: NoVersion}, ~"supplied path for package dir does not exist, and couldn't interpret it as a URL fragment")', /private/tmp/rust-33Lr/src/libstd/condition.rs:139
[04:33:05] <dbaupp> alan_andrade: that will likely require recompiling everything
[04:33:05] <alan_andrade> and that compiles ( I think ) and move things around, and after that runs the test
[04:33:09] <alan_andrade> ok ok
[04:33:14] *** Quits: Reisen (m@moz-A0F67AD4.org) (Ping timeout)
[04:33:28] *** Joins: Reisen (m@moz-A0F67AD4.org)
[04:33:48] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Ping timeout)
[04:33:49] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[04:33:52] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[04:33:57] <dbaupp> alan_andrade: you can do it faster using `path/to/build/dir/<target-triples>/stage2/bin/rustdoc --test path/to/libstd/lib.rs`
[04:34:04] <dbaupp> which will just run the tests them selves
[04:34:18] <dbaupp> and then even faster-er if you add `--test-args str` to that invocation
[04:34:44] <dbaupp> (which filters the tests run to just those with 'str' in the name)
[04:34:48] <alan_andrade> whoaaa
[04:34:54] <brianm> oOo
[04:35:03] <brianm> go down to sources, run make, then rustpkg install http
[04:35:18] <dbaupp> alan_andrade: (after rebasing you will need to run `make` to get the new rustdoc that handles # correctly.)
[04:35:19] <klutzy> brianm: rust-http uses some .rs generated by codegen, so rustpkg would fail if it's not presented
[04:35:28] <alan_andrade> yeah
[04:35:28] <alan_andrade> ok
[04:35:32] <alan_andrade> let me try that
[04:35:37] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Ping timeout)
[04:36:05] <alan_andrade> Thanks @dbaupp. I honestly appreciate your patience.
[04:36:25] <dbaupp> alan_andrade: (with the new rustdoc, a doc comment with '#[feature(managed_boxes)]; fn main() { @1; }' passes for me, so, in theory, you'll be good to go)
[04:36:35] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[04:36:44] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[04:36:47] <dbaupp> alan_andrade: thanks for your patience for following acrichto's request! :)
[04:37:31] <ecl3ctic1> does anyone know what's going on here during my attempted build of the compiler
[04:37:31] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[04:37:46] <ecl3ctic1> ~/workspace/rust/src/llvm/include/llvm/Support/AlignOf.h:19:10: fatal error:        'cstddef' file not found
[04:38:01] <ecl3ctic1> something's up with the includes?
[04:38:39] <ecl3ctic1> I'm no build tool/compiler aficionado
[04:39:40] <klutzy> ecl3ctic1: what's your os?
[04:39:44] *** Quits: steveno (steveno@moz-2B2BE86F.hsd1.pa.comcast.net) (Input/output error)
[04:39:47] <ecl3ctic1> ubuntu linux
[04:39:54] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[04:40:24] <ecl3ctic1> I've done ./configure --enable-clang
[04:40:30] <ecl3ctic1> then make
[04:40:36] <ecl3ctic1> then magic error
[04:41:06] <brianm> klutzy: so I do that, how do I then build my app against it?
[04:42:06] <ecl3ctic1> (also I'm building master)
[04:43:38] <klutzy> brianm: you may build your program with `rustc some.rs -L /path/to/rust-http/build`
[04:44:07] <brianm> ah
[04:44:17] <brianm> thought rustpkg also built local and handled the -L's for you
[04:44:53] <klutzy> brianm: I don't know how rustpkg works, but seems that it doesn't use dynamic link ability
[04:45:02] *** Quits: derek_c (derek@9444CCD6.74FA9A9F.EB673A25.IP) (Ping timeout)
[04:45:16] <klutzy> that is, it only builds .so files, and final executable relies on them at runtime
[04:45:48] <brianm> fine by me, i want static everything
[04:45:55] <brianm> down with berkeley!
[04:46:14] <klutzy> to use static link, you need .rlib files
[04:46:46] <klutzy> I'm not sure if rustpkg builds them
[04:46:48] <ChrisMorgan> BTW, anyone want to try figuring out doing the code generation in the rustpkg pkg.rs so that it can be completely rustpkg-compatible?
[04:47:05] <brianm> ah
[04:47:39] <cmr> ecl3ctic1: something is wrong with your clang or glibc.
[04:47:46] <brianm> basically, don't use rustpkg yet :-)
[04:47:55] <cmr> ecl3ctic1: or, rather, your libstdc++
[04:48:25] <cmr> brianm: that's sound advice :)
[04:49:54] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[04:49:54] *** ChanServ sets mode: +ao pcwalton pcwalton
[04:50:33] <ecl3ctic1> cmr: sounds like it...
[04:50:58] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[04:51:05] <klutzy> I added #[crate_type = "rlib"]; to rust-mustache and ran `rustpkg install mustache`
[04:51:30] <klutzy> then I found both .so and .rlib in build/<triple>/, but only .so in lib/<triple> :(
[04:52:07] <klutzy> so rustpkg seems to ignore rlibs now
[04:53:04] <cmr> I don't doubt that rustpkg was never taught about rlibs
[04:53:10] <cmr> I don't recall seeing that in any PR
[04:53:14] <klutzy> yeah
[04:56:04] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[04:56:43] *** Quits: gkostyanikov (gkostyanik@80620F73.3E410295.CA6E2165.IP) (Ping timeout)
[04:56:44] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[04:57:25] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[04:58:58] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[04:59:15] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[04:59:43] *** Quits: vmx_ (vmx@moz-6BCF7F11.pools.arcor-ip.net) (Quit: Leaving)
[05:00:18] <ecl3ctic1> so I 'solved' my issue by not using clang
[05:00:28] *** Joins: gkostyanikov (gkostyanik@80620F73.3E410295.CA6E2165.IP)
[05:00:53] <ecl3ctic1> easier than the headaches of finding the cause of strange errors
[05:02:24] *** Quits: gkostyanikov (gkostyanik@80620F73.3E410295.CA6E2165.IP) (Ping timeout)
[05:04:17] *** Joins: derek_c (derek@E40660A2.8FCFF51F.AA745434.IP)
[05:04:29] <nielsle> Is the following idiomatic? impl Foo { fn(new) -> Result<Foo,~str>[..}}
[05:04:31] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[05:04:37] <dbaupp> nielsle: yes
[05:05:00] <nielsle> Thanks
[05:05:00] <dbaupp> ecl3ctic1: what does `clang --version` say?
[05:06:00] *** Joins: gkostyanikov (gkostyanik@5381327A.2AEE264E.CA6E2165.IP)
[05:06:47] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[05:08:16] *** Quits: victorporof (victorporo@773D35C8.FAB6DAB7.79933D60.IP) (Quit: victorporof)
[05:09:03] *** Quits: hacker_s_ (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Connection reset by peer)
[05:09:17] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[05:11:06] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Ping timeout)
[05:12:07] *** Quits: gkostyanikov (gkostyanik@5381327A.2AEE264E.CA6E2165.IP) (Ping timeout)
[05:12:23] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[05:12:32] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[05:12:36] <sfackler> nielsle: ~str isn't the greatest error type, but other than that, yes
[05:12:40] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:13:13] *** Quits: elux (peter@moz-6B45ADE5.dsl.bell.ca) (Quit: Bye!)
[05:13:51] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:15:03] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[05:15:36] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:15:39] *** Joins: gkostyanikov (gkostyanik@5381327A.2AEE264E.CA6E2165.IP)
[05:16:35] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[05:19:27] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:20:42] *** Joins: mib_5rk4id (Mibbit@B0A5805D.34760237.5AF0B7BC.IP)
[05:20:59] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[05:21:17] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[05:22:17] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[05:22:52] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:24:00] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[05:24:51] *** Quits: astropirate (astropirat@9DAFB0AB.C6971763.8D80FBB2.IP) (Quit: Leaving)
[05:25:01] *** Joins: davebettin (davebettin@DB5B55EA.1A386E97.94FF2961.IP)
[05:25:39] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:27:09] <nielsle> Thanks.
[05:28:24] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[05:28:44] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[05:30:34] <ecl3ctic1> dbaupp: Debian clang version 3.2-7ubuntu1 (tags/RELEASE_32/final) (based on LLVM 3.2) Target: x86_64-pc-linux-gnu Thread model: posix
[05:30:54] <ChrisMorgan> http://www.reddit.com/r/rust/comments/1u2b6a/unloadable_crate/ — what would be the point of having crates that can be unloaded? What's the point of dlclose?
[05:33:34] <brianm> ChrisMorgan: often used for plugins
[05:34:16] <brianm> dlopen >> dlclose though
[05:34:30] <brianm> if you have to pick one
[05:34:34] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[05:34:41] <brianm> though dlclose without dlopen would be unusual :-D
[05:34:52] <cmr> well we have dlclose, it happens when the DynamicLib goes out of scope.
[05:35:04] <cmr> it's an unsafe interface though
[05:36:30] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Ping timeout)
[05:38:26] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.2)
[05:38:35] *** Quits: reedlepee (Mibbit@moz-A06909E4.glbb.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[05:39:52] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[05:40:18] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[05:40:19] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[05:40:21] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[05:40:30] *** Quits: zxcdw (r-a@5F0EDB29.B543C4DE.3933CC16.IP) (Ping timeout)
[05:44:22] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[05:44:23] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[05:48:18] *** Quits: gkostyanikov (gkostyanik@5381327A.2AEE264E.CA6E2165.IP) (Ping timeout)
[05:49:07] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[05:49:11] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:49:38] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[05:49:53] *** vfetwnuncszu is now known as dcrewi
[05:50:02] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:50:40] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[05:51:44] *** Joins: gkostyanikov (gkostyanik@E6C65C63.EF9FA30D.CA6E2165.IP)
[05:52:47] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Leaving...)
[05:53:28] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Ping timeout)
[05:55:37] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[05:56:38] *** Parts: mib_5rk4id (Mibbit@B0A5805D.34760237.5AF0B7BC.IP) ()
[05:57:14] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[05:58:10] *** Joins: moli (Mibbit@B0A5805D.34760237.5AF0B7BC.IP)
[05:58:30] *** Parts: moli (Mibbit@B0A5805D.34760237.5AF0B7BC.IP) ()
[05:58:53] *** Joins: lpy_ (lpy@9A6870A6.F09091A8.1348A864.IP)
[06:02:36] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:03:23] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[06:03:26] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[06:04:15] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[06:05:45] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[06:06:02] *** Joins: mib_hsi8q0 (Mibbit@moz-A06909E4.glbb.ne.jp)
[06:06:03] *** Quits: mib_hsi8q0 (Mibbit@moz-A06909E4.glbb.ne.jp) (Quit: mib_hsi8q0)
[06:07:12] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[06:08:12] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Client exited)
[06:08:14] *** Joins: b_ugh (Mibbit@moz-54E13927.washdc.fios.verizon.net)
[06:08:33] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[06:09:33] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Client exited)
[06:09:33] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[06:09:35] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[06:10:17] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:10:30] *** Joins: brandon-m-skinner (brandon@moz-C7AC35F5.mh.shawcable.net)
[06:10:51] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[06:11:55] <bstrie_mojitos> dbaupp: pong
[06:11:57] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[06:12:01] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[06:12:08] <ecl3ctic1> What's the logic behind allowing local variable shadowing in Rust?
[06:12:16] <dbaupp> bstrie_mojitos: ok for PM?
[06:12:35] <cmr> ecl3ctic1: it's useful and how `let` works in every language that has it.
[06:12:58] <cmr> (actual let, ala ML, not just having local variables)
[06:13:25] <ecl3ctic1> I'm not familiar with languages outside the C family
[06:13:28] <bjz> \o/ shadowing
[06:13:48] <ecl3ctic1> It seems like it would be an endless source of sneaky errors in large functions for small variables like i, x, y etcc
[06:13:48] <cmr> not 10 minutes ago I wrote code that used shadowing :p
[06:13:56] <cmr> having to comeup with new names is stupid.
[06:14:02] <cmr> when it's the same thing
[06:14:05] <bjz> ecl3ctic1: you should learn omre languages
[06:14:21] <dbaupp> bjz: well they're learning Rust ... :)
[06:14:22] <ecl3ctic1> bjz: It's on my endless list of things to do
[06:14:25] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[06:14:27] <bjz> ecl3ctic1: great that you are doing Rust!
[06:14:29] <cmr> ecl3ctic1: it's not been a problem in practice
[06:14:35] <bjz> dbaupp: haha
[06:15:42] <bjz> ecl3ctic1: Rust has a pretty strict static type system, so there is less chance for error too
[06:16:20] *** Quits: b_ugh (Mibbit@moz-54E13927.washdc.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:16:30] <bjz> also, one should aviod having functions that are excessively long anyway
[06:17:30] <alan_andrade> @dbaupp It worked just as you said ! :')
[06:18:53] <dbaupp> alan_andrade: \o/ yay!
[06:21:06] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[06:21:36] *** Quits: derek_c (derek@E40660A2.8FCFF51F.AA745434.IP) (Quit: Leaving)
[06:22:31] <bstrie_mojitos> dbaupp: yeo
[06:22:35] <bstrie_mojitos> *yep
[06:22:38] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[06:23:15] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[06:23:31] <ecl3ctic1> yeah Rust looks pretty promising on the safety front
[06:24:27] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[06:26:11] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[06:26:18] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[06:26:33] *** Quits: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP) (Ping timeout)
[06:26:40] <ecl3ctic1> So it seems immutability by default something common to languages-which-I-know-nothing-about like Haskell and ML too
[06:27:03] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[06:27:14] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[06:27:25] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[06:27:28] <ecl3ctic1> does that actually reduce errors in practice?
[06:27:41] <cmr> yes, definitely.
[06:27:52] <ecl3ctic1> because it seems like 90% of variable declarations will have mut in their declaration
[06:27:55] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[06:28:02] <cmr> and it's required to have a usable safe region system! otherwise would need &const etc everywhere
[06:28:05] <cmr> no, not at all.
[06:28:06] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[06:28:13] <cmr> other way around really.
[06:29:15] *** Joins: victorporof (victorporo@773D35C8.FAB6DAB7.79933D60.IP)
[06:29:44] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[06:31:14] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[06:31:56] *** Quits: xales (xales@moz-7DEA692E.forevernothing.com) (Connection reset by peer)
[06:32:08] <cmr> 1058 let mut in librustc, compared to 5896 let
[06:32:18] <cmr> and librustc is a much older codebase
[06:33:27] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[06:33:36] <ecl3ctic1> so 15% mutable
[06:33:39] <ecl3ctic1> that's interesting
[06:33:50] <cmr> 368 &mut compared to 1825 &
[06:34:18] <ecl3ctic1> is the latter value including the former
[06:34:24] <cmr> no
[06:35:13] <cmr> and as const correctness in c++ has shown, it's easier and less painful to just start with immutable-by-default.
[06:36:03] <ecl3ctic1> yeah, I suppose so
[06:36:08] <ecl3ctic1> those are good statistics
[06:36:52] <ecl3ctic1> I'm going to enjoy learning Rust
[06:37:54] *** Joins: xales (xales@moz-7DEA692E.forevernothing.com)
[06:38:32] *** Quits: xales (xales@moz-7DEA692E.forevernothing.com) (Input/output error)
[06:39:39] *** Joins: oisa (oisa___@9AC1CCE2.FCC4B66A.A6DC652B.IP)
[06:39:53] <oisa> I've searched the std lib docs, but can't find a mention of how to detect the number of processors?
[06:40:57] *** Joins: xales (xales@moz-7DEA692E.forevernothing.com)
[06:41:12] <dbaupp> oisa: there's a secret std::rt::util::num_cpus()
[06:41:21] <dbaupp> rusti: std::rt::util::num_cpus()
[06:41:24] -rusti- pastebinned 7 lines of output: http://ix.io/9AH
[06:41:27] *** Joins: MrOrdinaire (Mibbit@6DAC4E9C.9668DC44.FD383126.IP)
[06:41:35] <cmr> ecl3ctic1: some more numbers: 6 &mut and 86 &, 120 let mut to 360 let, in q3. in sprocketnes, 67 let mut to 288 let, 35 &mut to 47 &. rust-http: 47 &mut to 71 &, 72 let to 129 let mut.
[06:41:48] <cmr> ecl3ctic1: and these are only type signatures, not uses of types, for &/&mut
[06:41:51] *** Quits: gkostyanikov (gkostyanik@E6C65C63.EF9FA30D.CA6E2165.IP) (Ping timeout)
[06:42:11] <oisa> dbaupp: thanks
[06:42:18] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[06:42:49] <dbaupp> cmr: are you just grepping? are you including &mut lines in the results of &?
[06:42:58] <dbaupp> (also patterns with &?)
[06:43:23] <cmr> dbaupp: ag ': &mut' | wc -l
[06:43:25] <cmr> ag ': &' | grep -v ': &mut' | wc -l
[06:43:34] <cmr> same with `let mut` and `let`
[06:43:40] <cmr> (no patterns)
[06:44:04] <cmr> it's a rough approximation, yeah
[06:44:12] <ChrisMorgan> cmr: ag ': &(?!mut)'
[06:44:29] <ChrisMorgan> But you've got lifetimes to think about as well.
[06:44:34] <cmr> ChrisMorgan: like I know regex that well :)
[06:44:37] <cmr> ohh yeah
[06:44:42] <cmr> I forgot about that
[06:45:15] *** Joins: gkostyanikov (gkostyanik@1EF0F1D9.EF9FA30D.CA6E2165.IP)
[06:45:23] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[06:51:11] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[06:51:26] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:52:34] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[06:53:32] <alan_andrade> Could please trigger the bot https://github.com/mozilla/rust/pull/11142 ?
[06:54:02] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[06:54:34] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[06:59:12] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:02:42] *** Joins: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP)
[07:04:32] *** Quits: MrOrdinaire (Mibbit@6DAC4E9C.9668DC44.FD383126.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:10:35] *** Joins: sproing (Mibbit@D45A3673.BBF72655.65B957D6.IP)
[07:12:37] <sproing> Does someone know that How Microsoft makes its m# fast based on CLR vm?
[07:14:13] <sproing> As we know that CLR is even slower than JVM, how can?
[07:14:48] <cmr> sproing: Not really on topic though, and there aren't many details. They might not even be using the CLR. surely not if they claim it to be a systems language. netmf is a sad excuse for a systems platform
[07:15:25] <brson> is m# confirmed to actually run on the clr?
[07:15:43] <cmr> brson: not afaik
[07:16:08] <sproing> thank you!
[07:16:27] <brson> we should publish a paper about borrowck before ms completely steals our thunder
[07:16:45] <alan_andrade> +1
[07:17:08] <cmr> yeah
[07:17:12] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[07:17:14] <cmr> that'd be good
[07:17:28] <cmr> I hear they have an impressive amount of patents on it coming.
[07:17:37] <cmr> Wanna take bets on how many are silly? ;p
[07:18:14] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[07:19:36] <sproing> the ms' language would not be open source, so I think it would not influence the market of Rust.
[07:19:50] <cmr> sproing: sure it will be.
[07:20:03] <cmr> F# is, and they say they want to keep codename-M# open too.
[07:20:29] <cmr> closed languages can't succeed anymore I don't think
[07:21:58] <sproing> ok, f# is not as succesful as c#.
[07:22:13] <cmr> it's newer
[07:22:14] *** Joins: blank_name (blank_name@78B04CD2.66204B68.6D228269.IP)
[07:22:17] <sproing> so that I am not aware of its license.
[07:22:35] <cmr> (by "can't succeed", I mean "new closed languages")
[07:23:10] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[07:24:44] <sproing> Java is turning closed ;)
[07:24:52] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[07:26:14] <cmr> How? OpenJDK is the only JDK now. Even weird Oracle-driven stuff like JavaFX are open.
[07:27:04] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[07:27:40] <sproing> just hearing that Oracle would make a faster closed jvm
[07:28:35] <brson> sproing: i haven't heard that! do you have a source?
[07:29:34] <Zor> JVM faster than CLR? uhh...
[07:29:51] <cmr> Zor: it's not worth it :)
[07:29:59] <sproing> wait a moment, I search it brson
[07:30:47] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[07:31:31] * Zor throws a boxed integer at cmr
[07:31:39] <doy> (m# is quite search-engine-unfriendly)
[07:31:57] <cmr> doy: it also doesn't exist
[07:32:09] <cmr> it's a codename for an unfinished product
[07:32:40] <doy> yeah, i was just trying to find more information on it
[07:32:57] <cmr> easiest way tbh is through reddit.com/r/rust ;p
[07:33:05] <doy> heh
[07:33:09] <doy> i try to avoid reddit, when possible
[07:34:11] <ecl3ctic1> I can't wait to see what Microsoft tries to patent with their language
[07:35:02] <ecl3ctic1> stifling innovation is the only strategy they have left
[07:35:09] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[07:35:41] <alan_andrade> doing more marketing of the tablets still an option XD
[07:35:51] <alan_andrade> lol
[07:37:00] <sproing> brson I remember that oracle will make JRockit or Hotspot not free, by Mark Reinhold
[07:37:15] <sproing> but can not find that page.
[07:38:04] <sproing> rumors
[07:39:09] *** Quits: z0w0 (zack@moz-356923D4.lnse4.woo.bigpond.net.au) (Client exited)
[07:41:47] *** Quits: sproing (Mibbit@D45A3673.BBF72655.65B957D6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:45:17] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[07:46:37] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[07:46:41] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[07:48:48] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:52:06] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Ping timeout)
[07:52:09] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[07:53:02] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[07:55:14] *** Quits: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP) (Quit: sp3d)
[07:55:43] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[08:01:43] *** Quits: ecl3ctic1 (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:02:14] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[08:04:06] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Ping timeout)
[08:04:13] *** Joins: eccl3ctic (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP)
[08:04:18] *** Quits: eccl3ctic (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP) (Quit: eccl3ctic)
[08:04:46] *** Joins: ecl3ctic1 (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP)
[08:05:14] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[08:08:07] *** Quits: gkostyanikov (gkostyanik@1EF0F1D9.EF9FA30D.CA6E2165.IP) (Ping timeout)
[08:10:37] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[08:10:38] <oisa> Does Rust prevent access to private functions?
[08:11:24] *** Joins: gkostyanikov (gkostyanik@1EF0F1D9.EF9FA30D.CA6E2165.IP)
[08:11:34] <sanxiyn> As far as I know, yes
[08:12:19] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[08:13:16] *** Quits: alan_andrade (alan_andra@2D866054.D1EB06A3.B7838CA6.IP) (Input/output error)
[08:15:18] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[08:15:34] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[08:15:49] *** vfetwnuncszu is now known as dcrewi
[08:16:04] *** Quits: brandon-m-skinner (brandon@moz-C7AC35F5.mh.shawcable.net) (Quit: Konversation terminated!)
[08:16:28] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[08:17:26] *** Joins: Ms2ger (Ms2ger@moz-268A540A.access.telenet.be)
[08:17:32] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[08:17:41] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[08:20:06] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[08:21:01] <adridu59> Hi guys, how do I get to use the read_line() function? Seems like I can't get the right imports
[08:21:03] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[08:21:18] <adridu59> Do I have to use a BufferedReader for that?
[08:23:38] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[08:25:06] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[08:25:29] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[08:27:29] <adridu59> why doesn't Reader implement read_line()?
[08:28:02] <oisa> How can I split a string literal across multiple lines?
[08:28:12] *** Quits: gkostyanikov (gkostyanik@1EF0F1D9.EF9FA30D.CA6E2165.IP) (Ping timeout)
[08:28:35] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[08:28:45] <adridu59> oisa: .lines()
[08:28:54] <geomyidae_> Hm, so I'm getting error: struct `Date` is private but the struct is marked "pub struct Date" ?
[08:29:11] <oisa> adridu59: sorry, I meant just to write a long line in my editor without it wrapping
[08:29:47] <adridu59> oisa:  I see, well you can concat with +, no?
[08:30:10] <oisa> adridu59: ah, yeah.. thanks
[08:30:14] <adridu59> "foo" + "bar"
[08:31:25] <geomyidae_> Is this a bug? https://github.com/wycats/rust-activesupport/blob/master/date.rs#L6
[08:31:32] <geomyidae_> That's clearly marked pub, unless I don't understand the pub rules.
[08:32:47] <sanxiyn> geomyidae: As I understand, you get "X is private" error whenver X is not reachable
[08:32:52] <dbaupp> adridu59: that has runtime consequences
[08:33:08] <sanxiyn> geomyidae: That is, X may be marked public, but it may be still unreachable from the current location
[08:33:14] <adridu59> dbaupp: oh, so how would you do?
[08:33:17] <dbaupp> oisa: you can write "foo\<newline>    bar" (where <newline> is a new line)
[08:33:28] <dbaupp> the \ escapes the newline and any following whitespace
[08:33:32] <adridu59> geomyidae_: it's maybe there https://github.com/mozilla/rust/search?q=pub+struct&ref=cmdform&state=open&type=Issues
[08:33:45] *** Joins: bjz (bjz@moz-7290FC9E.hdqu1.vic.bigpond.net.au)
[08:33:46] <adridu59> as in makefiles
[08:33:50] * geomyidae_ 9 pages :(
[08:33:53] <oisa> dbaupp: oh, thanks
[08:34:11] <adridu59> geomyidae: quite some issues involving structs! :p
[08:34:13] <sanxiyn> geomyidae: In this case, Date is public, but date is not, so date::Date is probably not reachable
[08:34:14] <dbaupp> oisa, adridu59: https://gist.github.com/huonw/26f4972d91cc6d5ccb7c
[08:34:25] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Ping timeout)
[08:34:46] <adridu59> dbaupp: do you know why Reader does not implement read_line()?
[08:34:55] <dbaupp> adridu59: performance I guess
[08:35:06] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[08:35:08] <adridu59> should I use a BufferedReader to read from stdin?
[08:35:15] <adridu59> I thought it was for files
[08:35:16] <dbaupp> I guess so
[08:35:21] <adridu59> ok
[08:35:23] <dbaupp> well, it's for any readers
[08:35:26] * dbaupp shrugs
[08:35:29] <adridu59> in Java I used that for files
[08:35:35] <geomyidae_> Oh, the container mod wasn't marked as pub I guess.
[08:35:45] <dbaupp> geomyidae_: https://github.com/wycats/rust-activesupport/blob/master/lib.rs#L9 , yes
[08:36:01] <geomyidae_> sanxiyn: just saw that, missed your mention (can I recommend tab completion for user names if you aren't aware of that feature)
[08:36:16] <sanxiyn> geomyidae_: ok
[08:36:22] <adridu59> dbaupp: should I pass stdin() as argument of BufferedReader?
[08:36:35] <dbaupp> adridu59: do the types match?
[08:36:38] <dbaupp> (if so, yes.)
[08:36:58] *** Quits: ecl3ctic1 (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:37:00] *** Joins: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au)
[08:37:13] <adridu59> well stdin is StdReader, but I guess it's quite the same, I'll try
[08:37:17] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[08:39:23] <adridu59> dbaupp: it works, I should probably add an example
[08:40:30] <geomyidae_> sanxiyn: thank you of course, as well
[08:40:46] <sanxiyn> No problem :)
[08:41:35] *** Joins: jviereck (Adium@moz-9CCF231E.dip0.t-ipconnect.de)
[08:41:54] *** Joins: nkoep (nik@moz-F424EA91.pool.mediaways.net)
[08:42:47] <adridu59> dbaupp: is it possible to call .lines() on stdin?
[08:44:09] <dbaupp> adridu59: did you try it? :)
[08:45:00] <adridu59> dbaupp: no but if it works and if you do a foor loop it should turn into infinite
[08:45:04] <adridu59> for
[08:45:39] <adridu59> something like for line in input.lines()
[08:46:31] <dbaupp> `let mut reader = buffered::BufferedReader::new(stdin()); for line in reader.lines() { print(line) }` is a basic `cat`, which works for me
[08:47:01] <Ms2ger> It's not a cat if it doesn't concatenate...
[08:47:17] <adridu59> I see
[08:47:17] <oisa> How am I to cast this? `matches.opt_str("int_arg") as int;`
[08:47:22] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Quit: Leaving...)
[08:47:25] <oisa> That gives me a std::option::Option type instead of int?
[08:47:37] <adridu59> oisa: .unwrap() I guess?
[08:47:49] <adridu59> unwrap removes Option wrapper
[08:47:56] <oisa> oh, hm
[08:47:56] <Ms2ger> You need to handle the case where you didn't get the argument
[08:48:15] <oisa> Then is it a match with Ok and Err?
[08:48:25] <adridu59> Some() and None
[08:48:36] *** Joins: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net)
[08:48:37] <oisa> ok
[08:48:37] <Ms2ger> Ok and Err are Result :)
[08:48:38] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Quit: Leaving.)
[08:48:49] <adridu59> what's Result btw? compared to Option
[08:49:04] <dbaupp> adridu59: http://static.rust-lang.org/doc/master/std/result/enum.Result.html
[08:49:10] <Ms2ger> You can store an error value in Result
[08:49:50] <adridu59> Ms2ger: that's what makes it differ from Option? because otherwise success/failure sounds Option to me
[08:50:05] <sanxiyn> adridu59: Yes
[08:50:14] <dbaupp> option doesn't let you give a reason *why* it failed, result does
[08:50:18] *** Parts: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Leaving)
[08:50:46] <adridu59> and if we have both of these, it's because Result is more expensive?
[08:50:49] <Ms2ger> And Option doesn't necessarily imply "failure", imo
[08:50:56] <dbaupp> no
[08:51:10] <dbaupp> Option<T> and Result<T, ()> have identical runtime representations
[08:51:29] <adridu59> so why do we don't just have Result
[08:52:10] <dbaupp> because Option doesn't imply failure always, e.g. one uses it for FFI (for passing null pointers to thing)
[08:52:12] <dbaupp> s
[08:53:11] <dbaupp> and one might use Option for things that aren't really failures, like the opt_str thing is just saying that "this argument is missing", not "the computation failed"
[08:54:04] <adridu59> I see
[08:54:58] <adridu59> but what can you do with the error message returned by Result besides displaying it? can you like do different things depending on the error code?
[08:55:15] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[08:55:29] <dbaupp> sure
[08:55:38] <dbaupp> Result is generic in both Ok and Err
[08:56:03] <dbaupp> so you can have Result<T, ~str>, or Result<T, int> or Result<T, MyErrorEnum>
[08:56:15] <dbaupp> and then you just handle the Err case as you wish
[08:56:39] <adridu59> sounds cool
[08:56:43] <ecl3ctic> I'm liking Rust's approach to primitive types
[08:56:55] <ecl3ctic> none of that float, double, long, long long rubbish
[08:57:07] <ecl3ctic> I noticed 'float' was recently chucked out
[08:57:11] <dbaupp> ecl3ctic: i.e. they all have sensible names?
[08:57:17] <ecl3ctic> yeah
[08:57:23] <ecl3ctic> and clearly defined sizes
[08:57:38] * dbaupp now typedef's f32 and f64 in his C code
[08:57:59] <adridu59> haha
[08:58:11] <ecl3ctic> that's a good idea
[08:58:28] <oisa> For converting strings to ints, do I need to use transmute?
[08:58:33] <dbaupp> no
[08:58:40] <dbaupp> that'll not do what you expect at all
[08:58:42] *** Joins: gkostyanikov (gkostyanik@CD8BBD8D.A859D9FD.CA6E2165.IP)
[08:58:48] <eddyb> dbaupp: https://github.com/mozilla/rust/issues/11196#issuecomment-31369262 the generic should work with trait pointers - if it doesn't, that's a bug
[08:58:59] <dbaupp> rusti: from_str::<int>("1").unwrap()
[08:59:00] -rusti- 1
[08:59:06] <eddyb> dbaupp: well, the bug is the lack of DST, mainly :/
[08:59:27] <dbaupp> eddyb: that's not my point (i'll get back to you in a sec)
[08:59:50] <eddyb> yay more confusion :(
[08:59:53] <dbaupp> oisa: ^ (the ::<int> type hint can often be dropped due to type inference)
[09:00:15] <dbaupp> oisa: it returns an Option too, since the string doesn't necessarily contain an integer
[09:00:20] <dbaupp> rusti: from_str::<int>("a")
[09:00:21] -rusti- None
[09:00:23] <oisa> dbaupp: I see, thanks
[09:01:16] *** Quits: gkostyanikov (gkostyanik@CD8BBD8D.A859D9FD.CA6E2165.IP) (Ping timeout)
[09:01:34] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:01:49] <dbaupp> eddyb: &Trait is currently a trait object which always has virtual calls, yes? so you *can't* convert foo<T: Trait>(x: &T) to foo(x: &Trait) without losing static dispatch
[09:02:19] <eddyb> dbaupp: the point of the RFC is to make the latter a shorthand for the former
[09:02:38] <dbaupp> how do you pass a trait object to a function then?
[09:02:47] <eddyb> it makes more sense without the &, though
[09:02:52] <dbaupp> yes
[09:02:56] <dbaupp> but how common is that?
[09:03:03] <eddyb> dbaupp: as I said, the generic should work with a trait pointer
[09:03:06] <dbaupp> in most cases generic functions take references because they don't need objects
[09:03:08] <dbaupp> what?
[09:03:23] <eddyb> foo<T: Trait>(x: &T) should accept &Trait
[09:03:35] <dbaupp> that's not what I'm talking about
[09:03:38] <eddyb> it doesn't right now because Trait isn't a type (T)
[09:03:48] <dbaupp> &Trait is dynamic dispatch, <T: Trait> &T is static
[09:03:55] <dbaupp> the first is slow, the second is fast
[09:04:10] <eddyb> and I'm saying make them both the same
[09:04:16] <dbaupp> huh?
[09:04:18] <dbaupp> how?
[09:04:28] <eddyb> slow only if someone passes a trait object
[09:04:53] <dbaupp> oh, so it becomes the callers responsibility to decide to pass a trait object or not?
[09:04:57] *** Joins: gkostyanikov (gkostyanik@CD8BBD8D.A859D9FD.CA6E2165.IP)
[09:05:16] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[09:05:33] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[09:05:34] <eddyb> dbaupp: yeah. maybe it could be inferred in types where you have ~T stored as ~Trait with different T's
[09:05:44] <dbaupp> you'll need to make that clear as part of the proposal
[09:05:54] <dbaupp> "it"?
[09:05:56] <eddyb> I don't know if it's too much magic if you add it everywhere
[09:06:05] <ecl3ctic> what was that magic rusti thing
[09:06:23] <dbaupp> ecl3ctic: a eval-bot
[09:06:27] *** flaper87|afk is now known as flaper87
[09:06:41] <dbaupp> ecl3ctic: takes a line of input and evaluates it through https://github.com/thestinger/rust-playpen/blob/master/bin/irc.sh
[09:06:47] <eddyb> dbaupp: it = trait object or generic. sorry, I just woke up
[09:06:59] *** Quits: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: klaus)
[09:07:25] <ecl3ctic> sweet
[09:07:32] <ecl3ctic> that's a cool bot
[09:07:45] <dbaupp> eddyb: you'll have to be clearer with what you mean with the ~Trait example
[09:08:01] <oisa> Is there a way to force an import of a private func?
[09:08:19] <eddyb> dbaupp: like, I could see ~[~Trait] be generic if you don't store multiple types inside
[09:08:20] <dbaupp> eddyb: I don't understand how having a ~Trait could ever not be dynamic dispatch (i.e. it's impossible to go from ~Trait to T, in general)
[09:08:21] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: Textual IRC Client: www.textualapp.com)
[09:08:29] *** Quits: gkostyanikov (gkostyanik@CD8BBD8D.A859D9FD.CA6E2165.IP) (Ping timeout)
[09:08:29] <dbaupp> ew
[09:08:41] <dbaupp> pls no. :P
[09:08:54] <ecl3ctic> rusti: 2*6
[09:08:55] -rusti- 12
[09:08:56] <dbaupp> oisa: nope private means private
[09:09:03] *** Joins: twi (Adium@366146E1.F33C246D.C3DDD137.IP)
[09:09:12] <dbaupp> ecl3ctic: (you can also private message rusti to use it as a (stateless) repl)
[09:09:48] <ecl3ctic> I'm in love
[09:10:24] <eddyb> dbaupp: I don't know. just close the issue. meh. it was just a desperate attempt to keep backwards compatibility with the current closure syntax and have that work with unboxed closures
[09:10:49] <dbaupp> eddyb: I agree with you that having a short syntax for basic generics would be nice
[09:11:10] <dbaupp> eddyb: but I don't think doing it in a way that tramples all over trait objects (etc) is good
[09:11:44] <dbaupp> if it was, say, <T: Trait> x: T <=> x: ^Trait, or something, that'd be ok
[09:12:01] <dbaupp> (although adding sigils isn't necessarily a good thing...)
[09:12:26] *** Joins: Blei (Philipp@moz-B2F9E4BD.cust.bluewin.ch)
[09:12:35] *** Joins: gkostyanikov (gkostyanik@34AE8EB0.EF9FA30D.CA6E2165.IP)
[09:12:39] <dbaupp> (that would allow `x: &^Trait` and `x: &Option<Result<^Trait, ~str>>` etc. no problems)
[09:12:43] *** flaper87 is now known as flaper87|afk
[09:13:06] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[09:13:31] *** Joins: mpie (Mibbit@moz-4FAE147D.graz.surfer.at)
[09:13:37] <ecl3ctic> so 'int' and 'uint' are register-sized in Rust?
[09:13:53] <dbaupp> no, pointer sized
[09:14:13] <ecl3ctic> ah, that's what I meant
[09:14:22] <dbaupp> (e.g., if we supported x32 (which is 32 bit pointers on the 64-bit x86-64), int and uint would be u32.)
[09:14:29] <dbaupp> err, i32 and u32 respectively.
[09:14:41] <ecl3ctic> yeah, fair enough
[09:15:20] <ecl3ctic> obviously compiled code that runs on x86 and x86-64 would break if it worked on register sizes
[09:16:12] <dbaupp> register-of-target-architecture sized  wouldn't break
[09:16:25] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:16:56] *** Quits: gkostyanikov (gkostyanik@34AE8EB0.EF9FA30D.CA6E2165.IP) (Ping timeout)
[09:17:04] <dbaupp> (rather than "register-of-exact-computer-the-code-is-currently-on sized", which is what I think you're thinking of?)
[09:17:20] <ecl3ctic> yeah, I was
[09:17:40] <ecl3ctic> I don't know much about that area
[09:17:45] <ecl3ctic> hence me saying stupid things
[09:19:28] <eddyb> dbaupp: I didn't want to trample, just "optimize" the cases where they weren't necessary
[09:20:14] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[09:20:28] *** Joins: gkostyanikov (gkostyanik@64C75572.2AEE264E.CA6E2165.IP)
[09:20:29] *** Joins: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr)
[09:20:30] *** flaper87|afk is now known as flaper87
[09:20:59] <dbaupp> eddyb: well, one normally chooses trait objects explicitly to avoid code bloat from many many monomorphisations
[09:22:48] <eddyb> hmpf. there's no way to even test this before you can use a trait object through a generic. that has to be fixed first
[09:23:20] <dbaupp> you can partially test it by implementing the trait on &Trait
[09:23:29] <dbaupp> and passing &&Trait instead of just &Trait
[09:23:59] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[09:24:01] <eddyb> yeah, but that would break existing code (including std)
[09:24:13] <eddyb> does && work yet?
[09:24:20] <eddyb> rusti: &&"foo"
[09:24:23] -rusti- pastebinned 6 lines of output: http://ix.io/9AI
[09:24:25] <dbaupp> nope
[09:24:32] <dbaupp> (rusti's old, btw.)
[09:24:45] <eddyb> dbaupp: that's what I tell to other people
[09:24:46] <dbaupp> eddyb: why would that break existing code?
[09:25:05] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[09:25:05] *** Quits: jviereck (Adium@moz-9CCF231E.dip0.t-ipconnect.de) (Quit: Leaving.)
[09:25:06] <dbaupp> I meant pass & &Trait to `<T: Trait> x: &T`
[09:25:15] <eddyb> anything that would take a trait object wouldn't work with the trait object
[09:25:15] <dbaupp> (were the latter generic is pre-existing.)
[09:25:43] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[09:25:58] <eddyb> wait. I just realized this is a DST-related "optimization"
[09:26:03] <dbaupp> also... there are fundamental differences between <T: Trait> &T and &Trait: the former can call generic methods and methods involving Self, but the latter can't.
[09:26:49] *** Quits: lpy_ (lpy@9A6870A6.F09091A8.1348A864.IP) (Client exited)
[09:26:56] <eddyb> now imagine &[T] accepting &[T, ..N] *and producing monomorphic code for each N*
[09:27:35] * dbaupp shrugs
[09:27:37] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[09:27:37] *** Quits: gkostyanikov (gkostyanik@64C75572.2AEE264E.CA6E2165.IP) (Ping timeout)
[09:27:40] <eddyb> (I guess that shows you how crazy it is. and that it requires nmatsakis to discuss)
[09:28:08] <dbaupp> again, I have a feeling that is liable to cause code bloat
[09:28:16] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[09:28:57] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[09:29:02] *** Joins: gkostyanikov (gkostyanik@78E60CC5.3E410295.CA6E2165.IP)
[09:29:11] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[09:30:55] *** Joins: rca (rcatolino@moz-9311B86D.adsl.proxad.net)
[09:31:02] *** Joins: valenting (Thunderbir@moz-9DFB83CF.residential.rdsnet.ro)
[09:32:13] <adridu59> dbaupp: I've got something weird
[09:32:35] *** Quits: gkostyanikov (gkostyanik@78E60CC5.3E410295.CA6E2165.IP) (Ping timeout)
[09:33:21] <adridu59> dbaupp: I've written print("Type something:") then I use my stdin instruction, but the print always show afterwards... is it because read_line() can't accept prints on the same line?
[09:33:45] <dbaupp> I guess it's because stdout is line buffered by default
[09:33:53] <adridu59> yea I think it's that, println works fine
[09:33:59] <dbaupp> you may need to write stdout().flush()
[09:34:11] <dbaupp> (possibly caching the result of stdout())
[09:34:56] <adridu59> yea but flush will make my message disappear
[09:35:06] <adridu59> I'll just use println, no biggies
[09:36:13] <dbaupp> which message?
[09:36:56] <adridu59> "Type something:"
[09:37:20] <oisa> I get an unresolved import on `use libc;`, but it's clearly used all over stdlib... am I not permitted in Rust..?
[09:37:20] <adridu59> in Java I would just do that inline, input after the message on the same line
[09:37:22] *** Joins: twi1 (Adium@366146E1.F33C246D.C3DDD137.IP)
[09:37:48] <adridu59> dbaupp: how can I match on empty input? Some(~"") and None both don't catch it
[09:38:03] *** Quits: twi (Adium@366146E1.F33C246D.C3DDD137.IP) (Ping timeout)
[09:38:09] <adridu59> I'll raw print it to see
[09:38:21] <dbaupp> oh, you have to do stdout.write() as well
[09:38:23] <dbaupp> print doesn't work
[09:38:28] <dbaupp> oisa: `use std::libc;`
[09:38:38] <dbaupp> oisa: (assuming you're outside of libstd.)
[09:38:48] <dbaupp> oisa: i.e. you have to import it from the `std` crate.
[09:38:55] <oisa> dbaupp: oops, way too late here... thanks.
[09:39:00] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[09:39:35] <dbaupp> adridu59: `stdout.write("type: ".as_bytes()); print(reader.read_line().unwrap());` works for me
[09:39:47] <dbaupp> it'll pritn `type: ` wait for input, and then print the input.
[09:40:03] <dbaupp> I think .read_line includes the new line
[09:40:34] <dbaupp> adridu59: http://static.rust-lang.org/doc/master/std/io/trait.Buffer.html#method.read_line
[09:43:59] *** Quits: bjz (bjz@moz-7290FC9E.hdqu1.vic.bigpond.net.au) (Ping timeout)
[09:44:35] <adridu59> dbaupp: yes it does
[09:44:45] <adridu59> I matched against ~"\n"
[09:45:12] <adridu59> so None should never happen
[09:47:13] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[09:50:12] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[09:50:25] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[09:50:25] *** Quits: valenting (Thunderbir@moz-9DFB83CF.residential.rdsnet.ro) (Quit: valenting)
[09:50:33] *** Joins: valenting (Thunderbir@moz-9DFB83CF.residential.rdsnet.ro)
[09:50:48] <adridu59> dbaupp: btw do you know why print does not work?
[09:52:39] <nrc> if I want to implement a trait and don't need any data to do it, what is the canonical way? To use an empty struct?
[09:53:20] <rca> if you don't need any data, why not implement in the trait itself?
[09:53:59] <adridu59> don't see why num::abs returns int and not uint... uhm
[09:54:41] *** Joins: twi (Adium@366146E1.F33C246D.C3DDD137.IP)
[09:55:32] *** Quits: twi1 (Adium@366146E1.F33C246D.C3DDD137.IP) (Ping timeout)
[09:55:56] <nrc> rca: the trait is already defined elsewhere
[09:59:15] <rca> nrc: arf, then i guess the empty struct will do.
[09:59:17] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[09:59:26] <nrc> cool, thanks
[10:03:57] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[10:15:48] *** Joins: jviereck (Adium@moz-9CCF231E.dip0.t-ipconnect.de)
[10:17:14] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[10:18:03] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[10:19:07] *** Joins: zxcdw (r-a@5F0EDB29.B543C4DE.3933CC16.IP)
[10:21:12] *** Quits: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr) (Ping timeout)
[10:22:32] *** Joins: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr)
[10:24:18] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[10:25:07] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[10:26:02] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[10:28:37] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[10:32:50] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[10:39:54] <adridu59> dbaupp: calling From_str::<int> on a read_line doesn't work because of \n, sounds silly
[10:40:19] *** Joins: twi1 (Adium@366146E1.F33C246D.C3DDD137.IP)
[10:40:30] *** Quits: twi1 (Adium@366146E1.F33C246D.C3DDD137.IP) (Max SendQ exceeded)
[10:40:52] *** Joins: twi1 (Adium@366146E1.F33C246D.C3DDD137.IP)
[10:41:06] *** Quits: twi (Adium@366146E1.F33C246D.C3DDD137.IP) (Ping timeout)
[10:41:45] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[10:41:59] *** Quits: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP) (Quit: Konversation terminated!)
[10:42:23] *** Joins: dsirenko (mitra@8E712A0.54C21BA0.9F317420.IP)
[10:42:29] *** Quits: mpie (Mibbit@moz-4FAE147D.graz.surfer.at) (Quit: http://www.mibbit.com ajax IRC Client)
[10:43:05] <nrc> where does the :'static part of the type @syntax::parse::lexer::reader:'static come from?
[10:43:22] <eddyb> reader must be a trait
[10:43:30] <nrc> it is
[10:43:45] <eddyb> nrc: it has something to do with references stored inside objects cast to the trait object
[10:43:57] <eddyb> and @T in general
[10:44:41] <eddyb> AFAIK, @ can't contain &T other than &'static T
[10:45:04] <nrc> So how do I call a method on an object with type @T ? (where T is a trait)
[10:47:51] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Connection reset by peer)
[10:48:06] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[10:48:15] *** Quits: nfroidure (nfroidure@moz-139A8041.w90-18.abo.wanadoo.fr) (Ping timeout)
[10:48:16] <Ms2ger> x.foo()?
[10:49:06] <nrc> well, yes, but what should x be?
[10:49:15] <nrc> Actually, I just needed a 'mut'
[10:49:22] <adridu59> how can I trim x number of chars at the end of a str? something like .slice_to(self.len() - 2) but not involving len
[10:49:35] <nrc> let x = blah as @mut reader
[10:49:53] <rca> adridu59: isn't there a pop method on owned strings ?
[10:49:56] * nrc wishes 'mut' would make up its mind as to whether it is part of the type or not
[10:50:07] <rca> oh x number...
[10:50:09] <rca> hum
[10:50:49] <eddyb> nrc: that's just @mut
[10:51:06] <eddyb> nrc: and you don't really want it. pcwalton is removing it from libsyntax right now
[10:51:30] <nrc> yeah, I bet this is going to need rebasing again very soon :-(
[10:51:36] <eddyb> if you can, don't use @ at all
[10:51:49] <adridu59> rca: there's pop() but you have to call it n times for n chars... is there an equivalent for slices?
[10:51:49] <nrc> for now I have to, because that is what lexer is giving me
[10:52:09] <eddyb> mkay. so what are you doing with @mut?
[10:52:17] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[10:52:22] <eddyb> I thought @T and @mut T were incompatible
[10:53:36] <nrc> I was accidently casting away the mut-ness and thus missing out on the method impls. It works now, but I still don't really understand the 'static in the type in the error message
[10:54:15] <dbaupp> adridu59: print doesn't work because it goes by a different path than just stdout().write(..)
[10:54:21] <eddyb> you can cast away mut-ness o_O?
[10:54:28] *** Quits: jviereck (Adium@moz-9CCF231E.dip0.t-ipconnect.de) (Quit: Leaving.)
[10:54:31] <dbaupp> eddyb: I don't think so
[10:54:52] <dbaupp> adridu59: it's uses a task-local buffered stdout handle iirc
[10:55:01] <eddyb> nrc: thus I don't understand what nrc is talking about
[10:55:22] <dbaupp> adridu59: I'd write `line.trim_chars_right(&'\n')` to remove the newline
[10:56:18] <nrc> so I have this stmt: |let mut toks = lexer::new_string_reader(handler, filemap) as @mut lexer::reader;|
[10:56:34] <nrc> er, |let mut toks = lexer::new_string_reader(handler, filemap) as @mut lexer::reader;   |
[10:57:33] <nrc> and if I omit the 'mut' in the cast, it compiles still, but I get the error message that the method is missing (because it is defined only for mut self)
[10:57:37] <nrc> which all makes sense
[10:57:40] <nrc> I think
[10:57:46] *** Quits: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org) (Ping timeout)
[10:57:53] <eddyb> nrc: why are you casting it at all?
[10:58:12] <adridu59> dbaupp: ty!
[10:58:13] *** Quits: pepijndevos (pepijndevo@9EACEF43.E50A3180.BCE47D84.IP) (Ping timeout)
[10:58:42] <eddyb> nrc: are you casting it to be able to call methods on it :)?
[10:58:46] <nrc> I think my snapshot is pre-subsumption? I get a compile error if I don't, I think :-s
[10:58:52] <nrc> eddyb: yes
[10:59:14] <eddyb> pfffffft. we really need to have stuff like this in a FAQ
[10:59:45] <eddyb> nrc: "use syntax::parser::lexer::reader;"
[11:01:32] <nrc> wait, use stmts affect item visibility?
[11:01:45] <dbaupp> what else would they change?
[11:01:48] *** Joins: pepijndevos (pepijndevo@9EACEF43.E50A3180.BCE47D84.IP)
[11:02:09] <nrc> I thought they were purely syntactic sugar, so you could write 'reader' rather than 'syntax::parser::lexer::reader'
[11:02:23] <nrc> not which methods I can call on an object with type reader
[11:03:19] *** Joins: nfroidure (nfroidure@moz-B747FB5E.w90-18.abo.wanadoo.fr)
[11:03:26] <doener> for instances of a given type, the type's method are always available. But traits have to be imported with "use" to have their methods available
[11:04:00] <eddyb> because of coherency, I think
[11:04:10] *** Joins: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org)
[11:04:32] <nrc> oh, ok, that is interesting
[11:04:52] <eddyb> nrc: trait objects are bad for perf. don't use them at all if possible
[11:05:17] <dbaupp> eddyb: they're not completely bad :P
[11:05:31] <dbaupp> large code is bad for perf
[11:06:01] <eddyb> less so than virtual calls
[11:06:19] <eddyb> dbaupp: imagine a virtual folder or visitor
[11:07:12] <dbaupp> virtual calls aren't so bad if you're doing a lot of work for each call
[11:07:12] *** Joins: jackneill (jackneill@moz-CFDD7A9B.pool.digikabel.hu)
[11:07:30] *** flaper87 is now known as flaper87|afk
[11:07:37] <Blei> nrc: the problem is that there might be multiple traits that contain methods of the same name, so you have to explicitely say that you want the methods of this particular trait to be visible
[11:08:00] <dbaupp> doing a virtual call for i8 addition would be bad; but doing it for addition of two large bigints wouldn't be particularly bad.
[11:08:27] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[11:10:36] *** Joins: derek_c (derek@7853C83E.3B8FFE11.DD630FEE.IP)
[11:11:11] <derek_c> how does uint compare to u64 on a 64-bit machine?
[11:11:27] <dbaupp> normally equal, but not necessarily
[11:11:32] <dbaupp> (equal sized)
[11:11:39] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Ping timeout)
[11:11:40] <dbaupp> uint is pointer-sized
[11:12:04] <dbaupp> so for x32, uint would be 32-bit even though the machine is 64-bit
[11:13:13] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[11:13:22] <derek_c> dbaupp: what do you mean by x32?
[11:13:47] <dbaupp> it's the x86-64 architecture but using 32-bit pointers
[11:14:00] <dbaupp> http://en.wikipedia.org/wiki/X32_ABI
[11:15:02] *** Quits: twi1 (Adium@366146E1.F33C246D.C3DDD137.IP) (Ping timeout)
[11:15:14] *** Joins: telotortium (rmi1@moz-46F0EE50.hsd1.ca.comcast.net)
[11:15:28] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[11:15:38] *** Joins: twi (Adium@366146E1.F33C246D.C3DDD137.IP)
[11:15:42] *** Joins: derby (dirby@moz-A22BFFCA.tuxli.ch)
[11:15:47] *** Quits: twi (Adium@366146E1.F33C246D.C3DDD137.IP) (Max SendQ exceeded)
[11:16:03] *** Joins: twi (Adium@366146E1.F33C246D.C3DDD137.IP)
[11:16:38] <telotortium> I have a question about a function I'm trying to write to append an extension to a `std::path::Path`.
[11:16:39] *** Quits: twi (Adium@366146E1.F33C246D.C3DDD137.IP) (Max SendQ exceeded)
[11:16:49] *** Joins: twi (Adium@366146E1.F33C246D.C3DDD137.IP)
[11:18:40] <telotortium> Here it is: https://gist.github.com/telotortium/8195450
[11:19:53] *** Joins: Sorella (quildreen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[11:20:05] <adridu59> maybe something like path.to_owned()? I do not know really
[11:20:28] <telotortium> No, that doesn't exist.
[11:20:40] <dbaupp> telotortium: what's the type of .with_extension?
[11:21:22] <telotortium> http://static.rust-lang.org/doc/master/std/path/trait.GenericPath.html#method.with_extension
[11:21:30] <telotortium> fn with_extension<T: BytesContainer>(&self, extension: T) -> Self
[11:21:46] <adridu59> doesn't swap type
[11:21:54] <dbaupp> telotortium: you can fix some of the errors by changing `... = [orig_ext, ext].iter()` to `let tmp = [orig_ext, ext]; ... = tmp.iter();`
[11:22:57] <dbaupp> also, off the top of my head, don't think you need the .map(|x| x.clone())?
[11:23:38] <adridu59> dbaupp: how is this different from .clone()?
[11:23:45] <telotortium> Yeah, probably not. I probably put that in while I was messing around
[11:24:15] *** Quits: twi (Adium@366146E1.F33C246D.C3DDD137.IP) (Quit: Leaving.)
[11:24:23] <adridu59> oh right
[11:24:40] <telotortium> I can't tell where exactly the lifetimes for these pointers are beginning and ending
[11:24:46] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[11:24:49] <dbaupp> yeah, the error messages suck :(
[11:25:05] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[11:25:18] <telotortium> For example, `path` has a lifetime of the entire function.
[11:25:27] <dbaupp> the vector .iter thing is just because the temporary basically only lasts for one method call, rather than the full chain of method calls
[11:26:04] <dbaupp> it's something like [orig_ext, ext].iter() is basically `{ let foo = [orig_ext, ext]; foo.iter() }` at the moment (this may change)
[11:26:05] <telotortium> And `.extension_str` borrows an immutable reference to the data buffer inside the `Path` object
[11:26:31] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[11:26:50] <telotortium> That particular fix didn't resolve the lifetime issues in the iterator chain.
[11:27:04] <dbaupp> oh, really?
[11:27:15] <dbaupp> what's the code look like now?
[11:27:34] <telotortium> let tmp = [orig_ext, ext].iter();
[11:28:00] <telotortium> The borrowed value is only valid for the iter() method call.
[11:28:07] <telotortium> That's what rustc says
[11:28:29] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[11:28:45] <telotortium> Of course, I have the slice inside `ext: Option<&str>`
[11:28:46] <dbaupp> that's no different to the code you had originally, the problem is calling .iter() directly on the temporary array
[11:28:58] <dbaupp> let tmp = [orig_ext, ext]; ...
[11:29:30] <derek_c> dbaupp: I see. thanks!
[11:30:25] <telotortium> That seems to work better
[11:30:28] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Ping timeout)
[11:30:56] <telotortium> let tmp = [...]; let tipi = tmp.iter(); let res = tempi.[..iterator chain..];
[11:30:57] *** Joins: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net)
[11:31:19] <dbaupp> you don't need tempi
[11:31:20] <telotortium> Lots of autocorrect, but I think you can figure it out
[11:31:24] <derek_c> rusti: let k = ~[1, 2, 3]; k.iter().map(|n| -> int {n + 1}).collect()
[11:31:26] -rusti- pastebinned 39 lines of output: http://ix.io/9AO
[11:31:28] <dbaupp> tmp.iter().iteartorchain should be ok
[11:31:53] <telotortium> Yeah, it is
[11:32:03] <dbaupp> but there's still another error, right?
[11:32:11] <telotortium> Yeah
[11:32:19] <derek_c> rusti: let k = ~[1, 2, 3]; k.iter().map(|n: int| -> int {n + 1}).collect()
[11:32:21] -rusti- pastebinned 9 lines of output: http://ix.io/9AP
[11:32:45] <dbaupp> telotortium: hm, I think it may be fixed by `append_extension<'a>(path: &'a Path, ext: Option<&'a str>) -> Path { ... }`
[11:32:55] *** Quits: ofeldt (ofeldt@moz-52BA9541.dip0.t-ipconnect.de) (Ping timeout)
[11:33:09] <derek_c> rusti: let k = ~[1, 2, 3]; k.iter().map(|n: &int| -> int {n + 1}).collect()
[11:33:11] -rusti- pastebinned 6 lines of output: http://ix.io/9AQ
[11:33:25] <dbaupp> rusti: let k = [1, 2, 3]; k.iter().map(|&n| n + 1).collect::<~[int]>()
[11:33:25] -rusti- ~[2, 3, 4]
[11:34:05] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[11:34:13] <derek_c> let k = [1, 2, 3]; k.iter().map(|&n| n + 1).collect()
[11:34:20] <derek_c> rusti: let k = [1, 2, 3]; k.iter().map(|&n| n + 1).collect()
[11:34:24] -rusti- pastebinned 6 lines of output: http://ix.io/9AR
[11:34:43] <derek_c> rusti: let k = [1, 2, 3]; k.iter().map(|&n| -> ~int {n + 1}).collect()
[11:34:43] <telotortium> dbaupp: Yes, that did fix it. Thanks!
[11:34:45] -rusti- pastebinned 9 lines of output: http://ix.io/9AS
[11:34:46] <dbaupp> telotortium: (taking a &Path like that rather than a plain Path is better style too, btw. you don't need ownership of the path so taking a references stops the caller having to copy the path if they want to use it again.)
[11:34:54] <dbaupp> telotortium: would you like an explanation? :)
[11:34:58] <telotortium> Yes
[11:35:14] <telotortium> I mean, I kinda get the principle, but I don't know how to apply it in every case
[11:35:20] <dbaupp> .extension_str is &'a self -> Option<&'a str>
[11:35:51] <dbaupp> so orig_ext has lifetime 'path (using this to denote the lifetime of the path variable)
[11:35:53] <derek_c> dbaupp: is there a less verbose way to map a vector?
[11:36:07] <derek_c> or do we have to do iter().map().collect()
[11:36:10] <dbaupp> yes
[11:36:30] <telotortium> Right, that makes sense.
[11:36:33] <dbaupp> telotortium: but s has type Option<&'anon_lifetime str>
[11:36:43] <dbaupp> (where 'anon_lifetime is one inserted by the compiler)
[11:36:48] *** Joins: ofeldt (ofeldt@moz-A3FD068B.dip0.t-ipconnect.de)
[11:37:12] <dbaupp> so [orig_ext, ext] is ill-typed, because Option<&'path str> and Option<&'anon_lifetime str> are different types
[11:37:31] <Ms2ger> Yay lifetimes
[11:37:35] <derek_c> dbaupp: were you saying yes we have to do iter().map().collect()?
[11:37:45] <telotortium> So I needed to force the vector to have the same lifetime for all elements.
[11:37:49] <dbaupp> however, if you have &'a Path and Option<&'a str>, then .extension_str() is being called on a Path with lifetime 'a, i.e. it gives a Option<&'a str> too
[11:38:02] <telotortium> Right
[11:38:14] <dbaupp> and then orig_ext and ext haev the same type (Option<&'a str>) so it's all ok
[11:38:16] <dbaupp> derek_c: yes
[11:39:08] <derek_c> dbaupp: thanks
[11:39:26] <telotortium> So the compiler infers different anonymous lifetimes for path and orig_ext without the explicit lifetime annotation, causing the vector to be ill-typed?
[11:39:55] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[11:40:43] <dbaupp> yes
[11:41:16] <dbaupp> well, with `path: Path` the lifetime "inference" is just looking at the scope of that variable
[11:41:21] <dbaupp> since it's passed by value
[11:41:31] <dbaupp> (in this case the scope is the body of the function.)
[11:41:40] <telotortium> Yes, that makes sense.
[11:41:56] <dbaupp> if it was path: &Path then they would be inferred to have different anon lifetimes
[11:42:17] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[11:42:47] <telotortium> So what is the difference in lifetimes between Path and &Path?
[11:43:10] <dbaupp> when passed by value, path goes out of scope at the end of the call to that function and gets deallocated there
[11:43:24] <telotortium> Okay
[11:43:46] <dbaupp> when passed by reference (&Path), some other stack frame has the responsibility for freeing it
[11:44:09] <telotortium> Right
[11:44:21] <luz> where can i find rusti's source code?
[11:44:33] <telotortium> That's the same as C, C++, etc.
[11:44:44] <dbaupp> yeah, exactly
[11:44:49] <dbaupp> luz: rusti the irc bot?
[11:44:53] <luz> yes
[11:45:15] <dbaupp> luz: it's (apparently) a python script that runs the input through https://github.com/thestinger/rust-playpen/blob/master/bin/irc.sh
[11:45:26] <dbaupp> (in a sandbox: https://github.com/thestinger/playpen )
[11:45:38] <luz> thanks
[11:46:37] <dbaupp> telotortium: and, if it wasn't clear, lifetimes are essentially just a reification of the "who frees what" idea.
[11:46:38] <telotortium> So what does it mean to say the two input arguments have the same lifetime?
[11:47:39] <dbaupp> saying `fn b<'a>(x: &'a T, y: &'a U)` makes `'a` the intersection of the lifetimes of the references passed as x and y
[11:47:51] <dbaupp> (i.e. it is the largest period for which both arguments are valid)
[11:48:18] <dbaupp> in this case, I don't think there is any change at all, because you're not trying to return the arguments
[11:48:36] <dbaupp> (i.e. no observable change from the outside)
[11:49:05] <telotortium> Yeah, that's the example in the borrowed pointer tutorial
[11:49:16] <dbaupp> but in `fn b<'a>(x: &'a T, y: &'a U) -> &'a int`, the return value is then only valid for that intersection.
[11:49:26] <telotortium> Right
[11:49:43] <dbaupp> i.e. you might have one argument that lasts a long time, and one that is very short, and the return value from `b` can only be used for the short one
[11:49:48] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[11:50:06] <telotortium> OK
[11:50:26] *** Quits: oisa (oisa___@9AC1CCE2.FCC4B66A.A6DC652B.IP) (Ping timeout)
[11:50:34] * dbaupp probably isn't explaining this very well...
[11:51:04] *** Joins: jhasse (jhass_000@moz-FA91BB40.ewe-ip-backbone.de)
[11:51:05] <telotortium> I think I need more practice in writing code with it
[11:51:08] *** Quits: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[11:51:20] <telotortium> I mean, I'm working on a project, so that should give me some experience.
[11:51:28] <dbaupp> yup
[11:51:43] <dbaupp> that's how I got the hang of lifetimes... just using them for a while. :)
[11:52:17] <telotortium> So what determines which types move by default versus copy?
[11:53:02] <telotortium> For example, 'let x = 4.0; let y = sqrt(x);' doesn't make x invalid.
[11:53:03] <dbaupp> first things first: a move is the same machine operation as a copy, just the compiler enforces that you don't use the source again
[11:53:06] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:53:10] <dbaupp> but...
[11:53:22] *** Quits: nrc (ncameron@moz-AD2938E.hari.cable.virginm.net) (Ping timeout)
[11:53:37] <dbaupp> things move if they contain things that have destructors (like ~, or types implementing Drop)
[11:53:43] <dbaupp> (or have a dtor themselves)
[11:54:08] <dbaupp> or if they contain/are &mut.
[11:54:21] <dbaupp> (and closures too)
[11:54:29] <luz> http://docs.octayn.net/ is broken
[11:54:55] <dbaupp> things don't move if they only contain primitive types (all the way through any structs/enums it contains)
[11:55:29] <telotortium> Thanks.
[11:55:35] <dbaupp> (@T, @mut T, *T, *mut T and &T all count as primitive for this purpose.)
[11:55:52] <telotortium> Why @mut T?
[11:55:53] <eddyb> and &mut T :P
[11:56:04] <dbaupp> eddyb: no, &mut moves
[11:56:13] <eddyb> oh, right
[11:56:25] <dbaupp> telotortium: because @mut T is essentially @(mut T) (unlike &mut T)
[11:56:46] <dbaupp> telotortium: (the modern replacement for @mut makes this clear: Gc<RefCell<T>>)
[11:57:09] <eddyb> @mut should just disappear soon
[11:57:14] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[11:57:16] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:57:27] <telotortium> And RefCell<T> has to check for mutation at runtime.
[11:57:43] <dbaupp> it has to check for borrowing at runtime, yes
[11:57:57] <dbaupp> (@mut does the same, but it's less obvious that it's happening.)
[11:58:25] <dbaupp> luz: I think cmr (the maintainer) has dropped it, for some reason... :(
[11:58:35] <eddyb> dbaupp: I think pcwalton's PR would remove @mut from both librustc and libsyntax *completely*
[11:58:53] <dbaupp> cmr: (luz has just pointed out that http://docs.octayn.net/ is broken, e.g. http://docs.octayn.net/postgres is a 404)
[11:59:07] <dbaupp> eddyb: yes, and he said he had a bootstrapping compiler with no @mut support at all.
[11:59:18] <eddyb> dbaupp: last night?
[11:59:35] <dbaupp> eddyb: this morning for me :P
[11:59:40] <dbaupp> (but yes)
[11:59:59] <eddyb> can we now get smart ptrs pls? as in, is anyone working or planning them?
[12:00:07] * dbaupp doesn't know
[12:00:52] * dbaupp guesses that may be pcwalton's next task after @mut--
[12:00:53] <dbaupp> but that's just speculation
[12:01:45] * eddyb needs 4-5 monitors and 8GB of RAM
[12:02:20] <eddyb> rust really needs you to expand your vision :P
[12:03:22] *** Joins: pao (pao@moz-AF905E87.fbx.proxad.net)
[12:03:32] * telotortium is reading the source of RefCell
[12:04:05] <eddyb> is RWArc using a custom atomic RefCell?
[12:04:57] <eddyb> because Arc<AtomicRefCell<T>> would make more sense then (with nicer names, ofc)
[12:05:15] <eddyb> and MutexArc or ArcMutex would be Arc<MutexCell<T>>
[12:05:34] <eddyb> and we could move Arc into std::rc
[12:06:32] *** flaper87|afk is now known as flaper87
[12:15:27] *** Joins: sk (sk@F9A3A16F.3DDD1ABD.33B96495.IP)
[12:16:56] *** Quits: telotortium (rmi1@moz-46F0EE50.hsd1.ca.comcast.net) (Quit: telotortium)
[12:22:17] <adridu59> dbaupp: when I use .trim_right_chars() I have borrowed value does not leave long enough since it returns &'a str
[12:22:27] <adridu59> how can I get around that?
[12:22:37] <adridu59> I am matching against that trim, converted to an int
[12:23:21] <dbaupp> adridu59: I'll need to see the code
[12:24:04] <adridu59> the block of code here: http://mibpaste.com/NLGif0 input_line() returns an ~str
[12:25:05] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[12:25:05] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:25:37] <dbaupp> let tmp = input_line(); ....
[12:25:42] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[12:25:49] <eddyb> adridu59: fwiw, you should be able to pop a char (or more) from a mut ~str
[12:26:10] <adridu59> eddyb: .pop_char() is quite sucky since it returns the char
[12:26:18] <dbaupp> why is that bad?
[12:26:21] <dbaupp> just ignore it?
[12:26:35] <dbaupp> `if s.ends_with("\n") { s.pop_char(); }`
[12:26:48] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[12:26:55] <dbaupp> (however, the trimming is nicer, from my perspective.)
[12:27:02] <adridu59> how's that more desirable than trim_right
[12:27:05] <adridu59> yea
[12:27:10] *** Quits: pao (pao@moz-AF905E87.fbx.proxad.net) (Quit: pao)
[12:27:18] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[12:28:18] <eddyb> adridu59: it's desirable when you want to move the ~str around
[12:28:29] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[12:29:02] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[12:30:08] *** Quits: derby (dirby@moz-A22BFFCA.tuxli.ch) (Input/output error)
[12:30:12] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Client exited)
[12:30:22] *** Joins: derby (dirby@9901445D.8128FD8D.337D5089.IP)
[12:30:33] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[12:32:36] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[12:33:02] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[12:33:46] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[12:35:03] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[12:36:09] *** Joins: pongad (Mibbit@moz-831734D6.revip2.asianet.co.th)
[12:36:58] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[12:37:51] <derek_c> can someone tell me what's wrong with this code? http://upl.io/f46vzr
[12:37:59] <derek_c> the error is here: http://upl.io/echj5f
[12:38:05] <derek_c> for some reason it can't find a method
[12:38:44] <dbaupp> are you trying to use the from_str method from the FromStr trait?
[12:41:10] *** Joins: judder (maradukewa@837BB533.C8128DC0.78E362FE.IP)
[12:45:59] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[12:46:58] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[12:47:40] *** Joins: mib_qk4m2w (Mibbit@moz-9BDD5B5A.w2-6.abo.wanadoo.fr)
[12:49:12] *** flaper87 is now known as flaper87|afk
[12:50:56] *** Quits: Blei (Philipp@moz-B2F9E4BD.cust.bluewin.ch) (Quit: Blei)
[12:51:55] *** Quits: mib_qk4m2w (Mibbit@moz-9BDD5B5A.w2-6.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[12:52:26] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[12:52:31] <doener> https://gist.github.com/dotdash/8196340 -- I wonder where the missing 4.3s are spent..
[12:52:43] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[12:53:35] *** Joins: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de)
[12:55:02] *** Parts: judder (maradukewa@837BB533.C8128DC0.78E362FE.IP) ()
[12:56:03] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[13:00:03] <ChrisMorgan> Ooh, look. It's next year.
[13:00:22] <sigma> 11 hours to go here ^^
[13:00:32] <eddyb> 9 here
[13:00:34] <derek_c> dbaupp: yeah I am
[13:00:41] <eddyb> ChrisMorgan: ur in teh future!
[13:00:43] <derek_c> and I imported the trait
[13:02:02] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[13:04:04] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[13:05:03] *** Quits: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de) (Ping timeout)
[13:07:37] <erickt1> happy new years, time travelers!
[13:07:44] <erickt1> err, new year!
[13:08:32] *** Quits: jhasse (jhass_000@moz-FA91BB40.ewe-ip-backbone.de) (Quit: Verlassend)
[13:09:23] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[13:10:14] *** flaper87|afk is now known as flaper87
[13:10:59] *** Joins: io2 (io2@moz-34E8FDD4.home.otenet.gr)
[13:13:12] <derek_c> what could be the reason that rustc can't find a method, given that I've imported the relevant trait?
[13:15:02] *** Quits: limeburst (me@247D1419.D73964AC.27A8748.IP) (Quit: leaving)
[13:15:18] *** Joins: limeburst (me@247D1419.D73964AC.27A8748.IP)
[13:15:39] <ChrisMorgan> derek_c: by far the most likely is that you made a mistake.
[13:15:45] <ChrisMorgan> Can you post the code?
[13:16:04] *** Joins: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de)
[13:16:26] <derek_c> http://upl.io/f46vzr
[13:16:32] <pyon> uint is what C++ calls std::size_t, right?
[13:16:33] <derek_c> error here: 
[13:16:37] <derek_c> the error is here: http://upl.io/echj5f
[13:16:48] <derek_c> can't find from_str
[13:16:49] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[13:16:53] <eddyb> pyon: uintptr_t
[13:17:04] <pyon> eddyb: Ah!
[13:17:24] <derek_c> ChrisMorgan: ^
[13:17:27] <eddyb> which is the same as size_t on all supported triples AFAIK
[13:17:28] <ChrisMorgan> derek_c: static trait methods must be called on the trait: FromStr::from_str
[13:18:05] <derek_c> ChrisMorgan: how is it different than the normal new method?
[13:18:13] <derek_c> how do I know if it's static?
[13:18:39] <ChrisMorgan> derek_c: static means that it has no self argument; trait method means that it's an impl of a trait, not just the plain impl.
[13:19:52] <derek_c> ChrisMorgan: if I want to define a method on a struct
[13:19:54] <ChrisMorgan> So `impl Foo { fn new() {}}` is called `Foo::new()`, and `trait Bar { fn bar() -> Self {} } impl Bar for Foo { fn bar() -> Foo {}}` is called with `Bar::bar()`, and it must be able to infer the type.
[13:19:56] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[13:19:57] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[13:20:12] <derek_c> huh, I didn't know that
[13:20:16] <derek_c> ChrisMorgan: many thanks!
[13:21:09] <ChrisMorgan> (If the Self type can't be inferred, it's impossible to do—so you can't just have a generic `trait Bar { fn bar() { } }` as you won't actually be able to call `Bar::bar()`—there's no syntax as yet for specifying "use the impl on this type".
[13:21:11] <ChrisMorgan> )
[13:21:22] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[13:21:49] <ChrisMorgan> erickt1: time travellers *may* have new years. The skilful International Date Line traveller may get a couple of new years'.
[13:23:38] <ChrisMorgan> derek_c: in case you're interested further, the primary syntax suggested would have `Bar::<for Foo>::bar()`, but this hasn't been implemented yet; the standard workaround in such cases is to take a dummy Option<Self> parameter and call it with None::<Foo> as the first argument.
[13:23:58] *** Quits: thesnowdog (doug@ADE066C5.CDB23781.6F17036B.IP) (Ping timeout)
[13:24:35] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[13:24:37] <dbaupp> doener: aren't there 4 headings in -Z time-llvm-passes?
[13:25:02] <dbaupp> ChrisMorgan: erickt1 may've just been wishing us well for 2015 too
[13:25:04] <derek_c> ChrisMorgan: interesting, I will think about that.  Thanks!
[13:25:08] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[13:25:23] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[13:25:33] *** Joins: thesnowdog (doug@ADE066C5.CDB23781.6F17036B.IP)
[13:25:44] <dbaupp> derek_c: btw, there's also a wrapper function the prelude, so you can just write `from_str(string)` rather than the trait FromStr::from_str
[13:25:45] <erickt1> ChrisMorgan: that's a good point.
[13:25:56] <dbaupp> (it's a wrapper for the generic FromStr trait)
[13:25:58] <erickt1> dbaupp: I've decided thats what I meant
[13:26:19] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[13:26:25] *** Joins: vmx (vmx@moz-6BCF7F11.pools.arcor-ip.net)
[13:26:37] * ChrisMorgan had temporarily forgotten about the fn from_str
[13:26:41] <dbaupp> derek_c: a type hint (from_str::<SocketAddr>(s)) works fine with that
[13:27:10] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[13:28:24] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[13:30:25] *** Joins: metaman (Mibbit@C0879E1F.D3432586.8D9DA8D9.IP)
[13:30:34] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[13:30:53] <doener> dbaupp: that was with --emit-llvm
[13:31:03] <metaman> Whats the best way to learn about graphics programming with rust?
[13:32:01] <doener> dbaupp: and without that, the time of the four sections still don't add up to the time reported for "LLVM passes"
[13:35:13] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[13:35:31] *** Joins: Ferreus (ferreus@moz-9ADFC210.pools.arcor-ip.net)
[13:38:35] *** Joins: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP)
[13:38:50] <dbaupp> doener: weird; I guess it might be the set up we do
[13:39:29] <dbaupp> like creating (and destroying) the pass manager
[13:40:31] *** Quits: metaman (Mibbit@C0879E1F.D3432586.8D9DA8D9.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:41:44] <maikklein> what is the recommended error report system in Rust? Is it Either/Option?
[13:41:54] <benh> Result/Option
[13:41:56] <doener> dbaupp: only a small part. The three subtiming we do only miss ~0.2s
[13:42:21] <benh> Result is pretty much Either with more suggestively named constructors
[13:42:22] <derek_c> ChrisMorgan: interesting, I will think about that.  Thanks!
[13:42:27] <derek_c> oops wrong window
[13:42:27] <maikklein> is there syntactic sugar for options/result?
[13:42:29] <derek_c> dbaupp: thanks
[13:42:35] <benh> no
[13:42:37] <maikklein> or do I always have to pattern match?
[13:42:56] <benh> There's tons of utility methods defined on those types
[13:43:24] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Ping timeout)
[13:43:39] *** Quits: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net) (Connection reset by peer)
[13:45:31] *** Quits: pongad (Mibbit@moz-831734D6.revip2.asianet.co.th) (Quit: http://www.mibbit.com ajax IRC Client)
[13:47:28] <maikklein> can I create custom infix functions?
[13:47:54] <maikklein> like 5 dd` 5
[13:48:27] <dbaupp> maikklein: no
[13:48:30] <adridu59> I just pushed an update to rust-tuts in case someone wants to check that out: http://adridu59.github.io/rust-tuts/tutorial/index.html
[13:49:36] <dbaupp> doener: the 'codegen passes' timing includes some more set-up/clean-up
[13:49:44] <dbaupp> multiple seconds seems like a lot though...
[13:52:52] *** Quits: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP) (No route to host)
[13:56:19] *** Joins: eddyb (eddy@EE946B63.921A1753.FCAAE698.IP)
[13:58:00] *** Quits: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net) (Ping timeout)
[13:59:28] *** Joins: dyrden (Mibbit@moz-B14702BE.superkabel.de)
[14:00:27] *** Quits: dyrden (Mibbit@moz-B14702BE.superkabel.de) (Quit: http://www.mibbit.com ajax IRC Client)
[14:00:28] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[14:01:02] *** Quits: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca) (Ping timeout)
[14:01:10] *** Joins: maxli (maxli@moz-4D28BA20.student.cs.uwaterloo.ca)
[14:01:36] *** Joins: Jesin (Jesin@moz-4B662E55.washdc.fios.verizon.net)
[14:03:17] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[14:05:08] <maikklein> what is the type of |x:int| x * 2? is it fn(int)->int?
[14:05:39] <rca> it's |int|-> int
[14:05:46] <rca> on master
[14:05:55] <maikklein> hm
[14:05:59] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[14:06:43] <maikklein> option map looks like this "fn map<'a, U>(&'a self, f: &fn(&'a T) -> U) -> Option<U>" and I could use it like x.map(|i| i*2);
[14:06:56] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[14:07:21] <maikklein> but f is of type &fn
[14:07:29] <eddyb> maikklein: are you using 0.8?
[14:07:34] <rca> what doc are you looking at?
[14:07:45] <maikklein> oh ups
[14:08:22] <maikklein> ok
[14:08:30] <maikklein> yeah I was looking at the wrong docs ofc
[14:09:28] <maikklein> ok this means that fn times2(i:int){2*1} is of type |int|->int too?
[14:09:44] <dbaupp> no
[14:09:46] <eddyb> that's extern "Rust" fn(int) -> int
[14:09:54] <dbaupp> (or just `fn(int) -> int`)
[14:09:55] <eddyb> (but it can be coerced to a closure)
[14:11:33] <vmx> adridu59: in chapter 4 i find the title of the section "doing it wrong" misleading. for me it's not clear what one would do wrong
[14:11:58] <maikklein> okay so when I call some(5).map(|x| * 2); then it casts fn(int) -> int to |int| -> int?
[14:12:26] <eddyb> maikklein: no, |x| x*2 is |int|->int
[14:12:43] <eddyb> if you call Some(5).map(times2), then it coerces times2 into a closure
[14:12:49] <rca> no, in that case you gave it a closure, |x| x*2 which is of type |x| -> x
[14:12:52] <maikklein> oh sry I am stupid
[14:13:04] <rca> s/x/int
[14:13:06] <maikklein> okay thanks 
[14:13:44] *** Joins: fabiand (fabiand@moz-C8DB808F.adsl.alicedsl.de)
[14:15:30] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[14:16:11] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[14:17:56] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[14:20:06] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[14:25:08] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[14:25:13] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[14:25:58] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[14:26:35] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[14:27:42] <maikklein> why doesn't this compile? let f = || -> print("Start");
[14:27:44] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[14:27:49] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[14:28:03] <doener> let f = || { print("Start"); };
[14:28:15] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[14:28:35] <maikklein> hm, doesn't print return () ?
[14:29:06] <Ms2ger> Where does that -> syntax come from?
[14:29:08] <adridu59> vmx: some kind of humor, like this talks about fail! and such
[14:29:09] <doener> yeah, you could skip the braces. But the arrow is wrong
[14:29:47] <vmx> adridu59: ic. though i didn't get it when i first read it
[14:29:57] *** Joins: andreypopp (andreypopp@moz-CB5A0154.etelecom.spb.ru)
[14:29:58] *** Quits: andreypopp (andreypopp@moz-CB5A0154.etelecom.spb.ru) (Quit: andreypopp)
[14:30:47] <dbaupp> Ms2ger: one can write `|x: int| -> int x + 1` to give a closure explicit types
[14:31:10] <Ms2ger> TIL
[14:31:12] <whitequark> https://gist.github.com/whitequark/edba9921ca245dab5b1e
[14:31:15] <adridu59> vmx: a tutorial that's seriously about doing it wrong would be quite weird ;)
[14:31:16] <dbaupp> maikklein: you could write `let f = || -> () print("Start";`
[14:31:19] <whitequark> test.rs:18:8: 18:10 error: unresolved name `SW`.
[14:31:19] <whitequark> test.rs:18         SW.from_u8((self.value >> 0) & mask)
[14:31:22] <whitequark> why does this happen?
[14:31:39] <Ms2ger> But yes, the void type is "()", not ""
[14:32:03] <dbaupp> whitequark: SW isn't a value
[14:32:05] <dbaupp> it's a type
[14:32:10] <dbaupp> oh
[14:32:23] <whitequark> uh, yes, wrong error pasted
[14:32:27] <dbaupp> yeah, the syntax for calling static methods is `Sw::from_u8`
[14:32:29] <Ms2ger> And that looks like a C enum, not a rust enum
[14:32:32] <dbaupp> *SW::from_u8
[14:32:32] <vmx> adridu59: i could imagine cases where you want do show things that sounds like a good idea, but are the wrong thing to do
[14:33:06] <dbaupp> whitequark: btw, #[deriving(FromPrimitive)] #[repr(i8)] enum SW { .. } will be much better than that ridiculously unsafe from_u8
[14:33:25] <adridu59> vmx: yea I can see that
[14:33:42] <dbaupp> whitequark: from_u8(x) where x is anything but 0 1 or 2 is undefined behaviour
[14:33:58] <whitequark> dbaupp: it's intended. a hardware invariant guarantees that it'll only contain 0, 1 or 2
[14:34:22] <dbaupp> whitequark: it better :)
[14:34:29] <maikklein> okay cool continuations are working https://gist.github.com/MaikKlein/8197611
[14:34:37] <dbaupp> or you'll have a program that could do anything
[14:34:43] <whitequark> I know
[14:34:51] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[14:34:59] <whitequark> but if that field contains 0b11, the CPU is probably already in lockup or something
[14:35:21] <whitequark> dbaupp: btw, FromPrimitive generates from_i64 methods
[14:35:27] <whitequark> that's a bit too excessive for a 32-bit arch
[14:35:31] <Ms2ger> dbaupp, mm, we should make "undefined behaviour" clear the user hdd, or something :)
[14:35:46] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[14:35:50] <dbaupp> Ms2ger: make it predictable? how boring! :P
[14:36:06] <Ms2ger> maikklein, nit: "if(iv.len() > 0){" should just be "if iv.len() > 0 {"
[14:36:10] <eddyb> lint against UB
[14:36:15] <dbaupp> whitequark: the optimiser may be able to help with something
[14:36:25] <dbaupp> eddyb: that's called "rustc" :P
[14:36:42] <whitequark> dbaupp: well, if it's inlined, probably...
[14:36:51] <maikklein> Ms2ger, ah didn't now that
[14:37:10] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:37:19] <dbaupp> eddyb: (in theory anything that passes rustc with no `unsafe` contains no UB; and anything with `unsafe` contains things that may be UB by design.)
[14:37:51] <eddyb> hmm, okay, makes sense. I should read whitequark's code :P
[14:38:11] <eddyb> ah, lol, transmute, I see
[14:38:54] <dbaupp> the point of `unsafe` is basically telling rustc "this could trigger UB, but trust me, I've been careful so it won't".
[14:39:20] <dbaupp> whitequark: did we resolve your original error?
[14:39:27] <whitequark> dbaupp: yes, thank you
[14:39:43] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[14:39:49] <derek_c> I want to create an array of TcpStream that can be shared among tasks.  Before contacting a machine, the program checks the array to see if a TcpStream between it and the machine already exists; if so, it uses the TcpStream; otherwise, the program creates a new stream and add it to the array.  However, I'm not sure how to achieve this using Rust's sync primitives.  Any ideas?
[14:42:13] <maikklein> btw do we have tail rec yet?
[14:42:43] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[14:44:04] <dbaupp> yes
[14:44:13] <dbaupp> fn f() { f() } // <- tail recursion.
[14:45:04] <dbaupp> if you mean "does tail recursion get optimised to a loop", the answer is "sometimes", and will *never* be always
[14:45:37] <dbaupp> (or, more accurately, "get optimised to constant stack use")
[14:45:54] *** Joins: elux (peter@moz-6B45ADE5.dsl.bell.ca)
[14:46:36] <dbaupp> supporting guaranteed TCO is a trade off that was deemed too expensive (it forces us to use an ABI that makes every function call slower.)
[14:47:18] <dbaupp> however, LLVM does optimise many tail calls (and non tail calls) into plain loops, via "sibling call optimisation" (which definitely includes a function calling itself)
[14:48:47] <maikklein> okay thanks
[14:50:43] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.2)
[14:58:34] *** Joins: awidegreen (awidegreen@moz-43381F01.pppoe.wtnet.de)
[14:58:40] *** Joins: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net)
[15:04:40] *** Quits: erickt1 (Adium@moz-4B000CB7.dyn.optonline.net) (Quit: Leaving.)
[15:05:09] <SiegeLord> Man, I really hope some solution other than inferred return types shows up to solve the unboxed closure returns
[15:06:51] *** Joins: Kez (Mibbit@moz-86BCC7DB.qld.bigpond.net.au)
[15:08:20] *** Quits: Kez (Mibbit@moz-86BCC7DB.qld.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[15:08:49] *** Quits: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de) (Ping timeout)
[15:10:02] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[15:11:21] <SiegeLord> To rely on non-existent documentation to figure out what exactly the function returns seems very counter productive
[15:12:01] <SiegeLord> I've been writing some SCons (a Python build system thing) and it's just impossible to program when nothing tells you what the functions return
[15:12:04] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Quit: Leaving...)
[15:12:06] <SiegeLord> (or expect in Python's case)
[15:12:42] <eddyb> SiegeLord: the other solution is really nasty
[15:13:01] <SiegeLord> Nothing is as bad as inferred return types
[15:13:09] <eddyb> rusti: fn foo() -> Foo {struct Foo; Foo}
[15:13:16] -rusti- pastebinned 7 lines of output: http://ix.io/9AW
[15:13:20] <SiegeLord> You will literally have no idea what the function does until you try to compile it
[15:13:22] <eddyb> rusti: fn foo() -> foo::Foo {struct Foo; Foo}
[15:13:25] -rusti- pastebinned 13 lines of output: http://ix.io/9AX
[15:13:44] <eddyb> rusti: fn foo() -> self::foo::Foo {struct Foo; Foo}
[15:13:46] -rusti- pastebinned 13 lines of output: http://ix.io/9AY
[15:13:47] <rntz_> "unboxed closure returns"?
[15:14:02] <eddyb> rntz_: returning an unboxed closure
[15:14:10] <rntz_> what is an "unboxed closure"?
[15:14:22] <SiegeLord> It's like a C++03 functor
[15:14:30] <rntz_> that is an unhelpful analogy, for me
[15:14:40] <eddyb> like fn add_factory(x: int) -> ??? {|y| x + y}
[15:14:58] <rntz_> is that not... just a closure?
[15:15:04] <SiegeLord> Well, imagine a struct that implements trait Func with a fn call method
[15:15:06] <rntz_> why do you call it "unboxed"?
[15:15:09] <eddyb> nope. you couldn't return a closure
[15:15:16] <eddyb> a closure would hang on to the stack frame
[15:15:22] <SiegeLord> An unboxed closure is as if you passed an instance of that struct directly
[15:15:31] <SiegeLord> A boxed closure (what we have today) is the trait object of that struct
[15:15:42] <rntz_> the closure allocates a *closure* into which it places the things it closes over
[15:15:55] <rntz_> or, it could. apparently it doesn't. why not?
[15:16:12] <rntz_> eddyb: ^
[15:16:27] <SiegeLord> That's not really the point, an unboxed closure could hang on to a stack frame too
[15:16:43] <SiegeLord> The point is that there is no function pointer in an unboxed closure
[15:16:43] <eddyb> rntz_: what that function returns is struct SOMETHING_ANON{priv x: int}; impl Fn<int, int> for SOMETHING_ANON {fn call(&self, y: int) {self.x + y}} SOMETHING_ANON{x: x}
[15:16:58] <rntz_> SiegeLord: your trait analogy is... also unhelpful. can you describe it in terms of what's actually going on under the hood as opposed to using other language features as analogies?
[15:17:07] <eddyb> rntz_: the closure is actually a pointer to an unboxed closure which is an anonymous type
[15:17:26] <dbaupp> rntz_: the current || closures are essentially no different to &mut Callable
[15:17:33] <rntz_> ah, "no function pointer in an unboxed closures". interesting.
[15:17:47] <dbaupp> (where Callable is a hypothetical trait that provides the () operator)
[15:18:06] <eddyb> the unboxed closure can contain a bunch of captures (pointers to locals on the stack) or the actual values themselves
[15:18:06] <rntz_> oh, you are saying that a closure presently is a pair of (fn pointer, environment)
[15:18:11] <SiegeLord> Yes
[15:18:12] <rntz_> and an unboxed closure is just (environment)
[15:18:31] <eddyb> rntz_: an unboxed closure is env while a closure is (*fn, *env)
[15:18:33] <dbaupp> closure is currently (fn pointer, pointer to environment)
[15:18:37] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[15:18:38] <eddyb> that's what "unboxed" means
[15:18:38] *** Quits: derek_c (derek@7853C83E.3B8FFE11.DD630FEE.IP) (Ping timeout)
[15:18:39] <rntz_> and somehow you know what the fn pointer should be, magically.
[15:18:48] *** Quits: awidegreen (awidegreen@moz-43381F01.pppoe.wtnet.de) (Ping timeout)
[15:18:52] <eddyb> not magically, but by the implementation of the Fn/Callable trait
[15:19:06] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[15:19:08] <eddyb> each unboxed closure type is unique
[15:19:10] <SiegeLord> Because each unboxed closure is a unique type, you know it via that type
[15:19:17] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:19:22] <rntz_> ah.
[15:19:26] <eddyb> and it's anonymous which makes it a pain to return
[15:20:19] <rntz_> why... are these being introduced? they seem like a language-level change to allow for a micro-optimization. is there documentation of the problem that requires this micro-optimization?
[15:20:23] <adridu59> dbaupp: #10801 should be mergeable now, no? https://github.com/mozilla/rust/pull/10801
[15:20:50] <dbaupp> eh, I'm not sold on it
[15:20:56] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[15:21:08] <rntz_> are they being introduces, or is this being discusses only hypothetically?
[15:21:11] <rntz_> *introduced
[15:21:12] *** Joins: rca_ (rcatolino@moz-11D6C67F.adsl.proxad.net)
[15:21:26] <SiegeLord> It seems like a nice feature, but not it it brings inferred return types along with it :{
[15:21:27] <SiegeLord> *:P
[15:21:42] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:21:48] *** Quits: rca (rcatolino@moz-9311B86D.adsl.proxad.net) (Ping timeout)
[15:22:36] <SiegeLord> Maybe there could be some special case feature just for them
[15:22:43] <rntz_> SiegeLord: it seems like a terrible feature to me.
[15:23:01] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[15:23:06] <SiegeLord> There's nothing particularly wrong with it as far as I can see (aside from the return thing)
[15:23:06] <eddyb> SiegeLord: make return type inferrence an error if it's used for non-anonymous types
[15:23:24] <rntz_> SiegeLord: "a language-level change to allow for a micro-optimization" basically sums up what seems wrong with it to me
[15:23:57] <eddyb> rntz_: unboxed closures would allow you to get much closer to JS' level of closure interactions
[15:24:18] <eddyb> it's not a micro-optimization. LLVM doesn't perform devirtualization well
[15:24:19] <SiegeLord> eddyb: Which types are anonymous types?
[15:24:19] <rntz_> aiui it doesn't let you do anything you couldn't before, it just adds another (more complicated) way to do it that's more efficient.
[15:24:26] <eddyb> SiegeLord: unboxed closures
[15:25:07] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[15:25:10] <eddyb> rntz_: it lets you do things which are impossible now
[15:25:14] <rntz_> eddyb: explain?
[15:25:34] <eddyb> you can't return a boxed closure *even if it only had values in it*
[15:25:46] <eddyb> because it still points at an anonymous type on the stack
[15:25:53] <rntz_> oh, normal closures can't be returned?
[15:26:05] <rntz_> oh, that is weird. why is that?
[15:26:06] <eddyb> we only have boxed stack closures and procs
[15:26:14] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[15:26:18] *** Quits: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr) (Quit: moostik)
[15:26:32] <eddyb> procs move all their captures in a heap box and they can only be called once
[15:27:03] <dbaupp> unboxed closures would be very very useful for getting the utmost performance out of iterators, etc.
[15:27:12] <dbaupp> (fwiw)
[15:27:16] <rntz_> okay, so adding unboxed closures would let you do some of the things you could do with ~fn and @fn
[15:27:28] <eddyb> ~fn and @fn were a mess
[15:27:32] <dbaupp> yes, and more besides that
[15:27:47] <rntz_> dbaupp: anything more besides that that isn't "get more performance"?
[15:27:51] <dbaupp> having unboxed closures is strictly more flexible than any subset of boxed closures
[15:28:01] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[15:28:04] <rntz_> yes, that's very tautological
[15:28:05] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[15:28:17] <dbaupp> it's essentially the same as the difference between <T: Trait> &T and &Trait
[15:28:27] <eddyb> (for performance)
[15:28:36] <SiegeLord> That difference is not just performance though
[15:28:37] <dbaupp> and others
[15:28:55] <eddyb> rntz_: if you had unboxed closures, you could box them into an Rc<~Fn> for example
[15:29:04] <SiegeLord> T: Trait and &Trait are semantically different
[15:29:14] <eddyb> or even an Arc and allow them to be called from different tasks
[15:29:19] <dbaupp> SiegeLord: as are unboxed and boxed closures
[15:29:27] <SiegeLord> You literally call all Trait's methods on a &Trait
[15:29:31] <SiegeLord> *cannot call
[15:29:46] <rntz_> SiegeLord: that depends on the signature of Trait.
[15:29:56] <dbaupp> there's no possibility for boxed stack once closures without some compiler magic
[15:29:57] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[15:30:02] <dbaupp> unboxed -> easy
[15:30:22] <eddyb> do current closures always take references, even to Pods?
[15:30:26] <dbaupp> it follows from Rust's standard move semantics... with unboxed closures
[15:30:29] <dbaupp> eddyb: yes
[15:30:31] <SiegeLord> rntz_: The traits for which you can't are useful
[15:30:35] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[15:30:44] <SiegeLord> Therefore static dispatch is useful for traits
[15:31:01] <dbaupp> and static dispatch is optimisable
[15:31:01] <rntz_> SiegeLord: hm? that's... just not true. what kind of things are you thinking of when you say you can't call Trait's methods on a &Trait
[15:31:02] <eddyb> dbaupp: not sure if taking by value or moving into (wherever possible) would be a good default behavior
[15:31:05] <dbaupp> while dynmaic is very hard
[15:31:16] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[15:31:17] <dbaupp> eddyb: meh, need capture clauses.
[15:31:26] <SiegeLord> rntz_: Eq, Clone
[15:31:36] <rntz_> right, yes.
[15:31:40] <eddyb> C++11/14 do it quite well
[15:31:42] <rntz_> but there are plenty of useful traits that aren't like that.
[15:31:57] <SiegeLord> I don't know how you'd write Rust code without Clone
[15:32:16] <rntz_> yes yes yes, the claim is not that you can do *without* such traits
[15:32:21] * dbaupp doesn't use clone a lot
[15:32:36] <rntz_> but that there exist traits where &Trait is as useful as &T for T:Trait
[15:32:46] <rntz_> in particular, most "function-like" traits
[15:33:02] <rntz_> trait FnLike { fn call(...) -> ...; }
[15:33:09] <SiegeLord> Yes, my point is that just because T:Trait is useful, doesn't make T:FnLike useful
[15:33:29] <SiegeLord> But there's other uses of T:FnLike, which are useful in different ways
[15:33:36] <dbaupp> do we want a slow language?
[15:33:50] *** Joins: awidegreen (awidegreen@moz-43381F01.pppoe.wtnet.de)
[15:33:52] <eddyb> nope
[15:33:55] <rntz_> dbaupp: that is a non-question. what are you *actually* asking or proposing?
[15:33:59] *** Joins: dogurness (dogurness@moz-1BF32EBD.pitbpa.fios.verizon.net)
[15:34:00] <SiegeLord> You can manually implement trait Func on a struct
[15:34:02] <dbaupp> unboxed closures == fast.
[15:34:06] <SiegeLord> Without introducing unboxed closures
[15:34:15] <eddyb> closures are devirtualized by LLVM *sometimes*
[15:34:18] <SiegeLord> Like C++ did before C++11
[15:34:29] <SiegeLord> Nobody called C++ slow before 2011
[15:34:31] *** Joins: derek_c (derek@69E4ACC.E9B0596F.C34016C.IP)
[15:34:35] <dbaupp> eddyb: only with a lot of convincing
[15:34:49] <eddyb> once you pass an arbitrary limit in a function using closures, your perf *halves*
[15:35:00] <brianm> SiegeLord: C++ was slow before 2011. There!
[15:35:20] <eddyb> rntz_: I have code where decommenting a match case which never gets touched makes the whole thing twice as slow
[15:35:24] <dbaupp> https://github.com/mozilla/rust/pull/11064#issuecomment-30979819 the original column is with boxed closures, the trait column is what unboxed closures would give us
[15:35:29] <eddyb> that's not micro-optimization
[15:35:30] <rntz_> dbaupp: "we don't want a slow language. this thing lets us go faster." is not a legitimate argument. everybody wants a slow language. there are ways to make any language faster. it does not follow that every language should be assembly. 
[15:35:45] <dbaupp> what?
[15:35:48] <rntz_> you have to show that the speed boost from getting a feature is actually worth the added complexity of the feature.
[15:35:53] <dbaupp> "everybody wants a slow language"?
[15:35:59] <rntz_> er, the opposite
[15:36:07] <rntz_> nobody wants a slow language / everybody wants a fast language
[15:36:11] <rntz_> slipped up constructing that sentence
[15:36:13] <eddyb> rntz_: unboxed closures are actually less magic than boxed closures
[15:36:15] <dbaupp> (the "trait" column there was implemented by static dispatch  using traits.)
[15:37:05] <rntz_> ah, that github link has actual stats
[15:37:08] <eddyb> (an anon type implementing a Fn trait, of course)
[15:37:18] <SiegeLord> brianm: There's literally nothing you do with C++11 closures that you couldn't do with C++03 functors
[15:37:24] <SiegeLord> It's merely a syntax sugar
[15:37:35] <dbaupp> as unboxed closures would be for Rust
[15:37:42] <brianm> SiegeLord: I said it so that you could say someone said it, not some belief that it is true ;-)
[15:37:44] <Ms2ger> Syntax sugar is underrated :)
[15:37:49] <SiegeLord> brianm: Hehehe
[15:37:52] <brianm> SiegeLord: some people really like syntax
[15:37:57] <dbaupp> we can currently do it verbosely with manual environement structs + trait impls
[15:38:05] <brianm> Those "programmers"
[15:38:32] <SiegeLord> I like syntax too, but right now it's looking like it comes bundled with other horribleness
[15:38:37] <dbaupp> and then our current boxed closures become really obvious: `&mut struct as &mut FunctionTrait`
[15:38:51] <eddyb> oooh, that I didn't think of
[15:39:00] <dbaupp> and proc: `~env_struct as ~ProcTrait`
[15:39:04] <brianm> can C++11 not staticify closures if they are not passed off thread
[15:39:08] <brianm> ?
[15:39:14] *** Quits: io2 (io2@moz-34E8FDD4.home.otenet.gr) (Quit: )
[15:39:26] <brianm> well, I guess once you pointer them it gets hard in C++ :-(
[15:39:26] <eddyb> C++11 closures allow you to specify the capturing mechanism for every capture
[15:39:32] <brianm> ah
[15:39:39] * brianm has not actually used C++11 yet
[15:40:06] <eddyb> dbaupp: &mut struct {x: x} as &mut Fn {fn call(&mut self, y: int) {self.x + y}}
[15:40:24] <derek_c> can we have channel of channels?
[15:40:30] <dbaupp> eddyb: sounds like Java :P
[15:40:30] <eddyb> there, Java interface object thing magic (I have no idea how it's called)
[15:40:32] <dbaupp> derek_c: probably
[15:40:39] <eddyb> dbaupp: hehe I'm too slow
[15:40:56] <brianm> and to be honest, have not used C++ in anger since the, er, 90s
[15:41:00] <olsonjeffery> yeah you can send a channel over a channel.. it's how you'd do req/resp
[15:41:03] <derek_c> dbaupp: do we have it?
[15:41:26] <dbaupp> rusti: let (p, c) = stream::<int>(); let (p1, c1) = stream(); p1.send(c); c1.recv().send(1); p.recv()
[15:41:28] -rusti- pastebinned 13 lines of output: http://ix.io/9AZ
[15:41:47] <dbaupp> rusti: let (p, c) = stream::<int>(); let (p1, c1) = stream(); c1.send(c); p1.recv().send(1); p.recv()
[15:41:49] -rusti- 1
[15:41:54] <SiegeLord> I might like something like fn foo() -> anon<Fn<(int, int)>>
[15:41:59] <olsonjeffery> let src_chan: Chan<(Req, Chan<Resp>)> = ...;
[15:42:10] <SiegeLord> But then people will complain about not being able to return function-local structs etc
[15:42:10] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[15:42:20] <eddyb> SiegeLord: oh, I know :D. I'm so silly
[15:42:30] <eddyb> fn foo() -> Fn<int, int>
[15:42:34] <olsonjeffery> dbaupp: or what dbaupp said, heh.
[15:42:41] <olsonjeffery> my comm knowledge is pretty antiquated ;{
[15:42:42] <eddyb> SiegeLord: that doesn't make sense right now
[15:42:48] <olsonjeffery> ;P
[15:42:48] <SiegeLord> No, not quite
[15:43:04] <dbaupp> olsonjeffery: I think your types work
[15:43:20] <dbaupp> it's all changed recently though, and looks completely different to that code...
[15:43:24] <dbaupp> Chan::new or something
[15:43:31] <eddyb> SiegeLord: which means we can use it to expand the syntax. just like I wanted fn foo(x: Clone) to work (though it might be useles))
[15:43:34] <olsonjeffery> hence my welching out on the actual initialization :P
[15:43:54] <olsonjeffery> im pretty close to doing some actual comm usage, though. so ill get hip pretty soon.
[15:44:01] <eddyb> SiegeLord: and then you can even do fn foo() -> |int| -> int :D
[15:44:02] <olsonjeffery> with 1:1 mode, no less!
[15:44:13] <derek_c> dbaupp: that's very cool!
[15:44:42] <dbaupp> eddyb: fwiw, that hits the same problem as the short hand you were proposing before: e.g. returning an unboxed anonymous closure behind a ~ (but not as a trait object): `-> ~Fn<(int, int)>` 
[15:44:52] <SiegeLord> Heh, someone on the ML suggested fn <T: |int|->int>foo() -> T
[15:45:12] <SiegeLord> I don't see how it'd work though
[15:45:17] <eddyb> SiegeLord: haha. pcwalton mentioned that for arguments.
[15:45:28] <dbaupp> SiegeLord: in Gabor's most recent email?
[15:45:31] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[15:45:32] <eddyb> for return it's weirder, since the type isn't inferred
[15:45:34] <SiegeLord> Yes
[15:45:51] <SiegeLord> For one, what'd happen if inside that function you implement Func and some other trait
[15:46:02] <SiegeLord> Will you be able to use that other trait on the return type?
[15:46:22] <eddyb> SiegeLord: inside Fn::call, yes
[15:46:37] <eddyb> that's possible right now
[15:46:38] <SiegeLord> I mean: let f = foo(); f.other_trait_method()
[15:46:47] <eddyb> aaah, outside
[15:47:08] <SiegeLord> If that's allowed, then that solution is basically not restricting anything
[15:47:08] <eddyb> SiegeLord: not from the function definition. but you can add another trait to T :P
[15:47:24] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Quit: leaving)
[15:47:26] <dbaupp> if it's foo() -> Iterator<T>, I'd personally say no, only those traits
[15:47:39] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[15:47:48] <SiegeLord> That'd be ok... I don't know how'd you implement that though :P
[15:47:50] <dbaupp> (traits because writing `-> Iterator<T> + Clone + SomeOtherTrait` might be useful.)
[15:48:06] <dbaupp> niko.clone()
[15:48:12] <dbaupp> easy. :P
[15:48:15] <SiegeLord> What exactly is 'f' in let f = foo()
[15:48:36] <SiegeLord> You'd actually have to introduce anonymous types as a first class citizen, it seems to me
[15:48:50] <dbaupp> not necessarily
[15:49:09] <dbaupp> you could just disallow writing anonymous types down
[15:50:14] <SiegeLord> Well what is the type of 'f'. It can't be the same type as struct s; inside foo() that you returned
[15:50:28] <SiegeLord> Because 'f' only implements Func, but s implements Func and SomeOtherTrait
[15:50:43] <SiegeLord> It'd have to be a second anonymous type
[15:50:45] *** Joins: kermi (Mibbit@moz-77C998AC.hsd1.ct.comcast.net)
[15:50:54] <dbaupp> not necessarily
[15:51:13] <dbaupp> there could be a second check to make suer you're only calling kosher methods on anon types
[15:51:16] *** Quits: kermi (Mibbit@moz-77C998AC.hsd1.ct.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[15:51:36] <SiegeLord> Well, yes... I guess. It sounds complicated
[15:53:00] *** Quits: awidegreen (awidegreen@moz-43381F01.pppoe.wtnet.de) (Ping timeout)
[15:53:32] <eddyb> SiegeLord: not as complicated as the bikeshedding it would start
[15:54:09] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[15:54:19] <SiegeLord> I like dark blue
[15:54:38] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Leaving...)
[15:58:08] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[15:58:24] <eddyb> so pcwalton doesn't want blocking 1.0 on Fn, either
[15:58:39] <eddyb> which means I have to hurry to get it through. but I can't do anything without nmatsakis
[16:02:17] *** Quits: fabiand (fabiand@moz-C8DB808F.adsl.alicedsl.de) (Client exited)
[16:02:52] *** Quits: elux (peter@moz-6B45ADE5.dsl.bell.ca) (Quit: Leaving...)
[16:05:23] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[16:06:36] <olsonjeffery> eddyb: what are you talking about, exactly? is there a ticket?
[16:06:43] <olsonjeffery> is the whole Thunk thing?
[16:06:56] <olsonjeffery> and more explicit env capture ala c++11 and obj-c?
[16:07:52] <eddyb> olsonjeffery: no idea what you're referring to. if it's "Fn", that depends on variadic generics, which I should be working on, but I can't replace nmatsakis (yet) so I need him to discuss the various details
[16:08:27] <eddyb> he still hasn't updated his message on the RFC, which he latter commented noting some mistakes
[16:08:47] *** Joins: awidegreen (awidegreen@moz-43381F01.pppoe.wtnet.de)
[16:08:57] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[16:12:07] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[16:13:24] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[16:17:51] *** Quits: awidegreen (awidegreen@moz-43381F01.pppoe.wtnet.de) (Ping timeout)
[16:18:05] <bstrie_mojitos> new rust motto: "Rust: The Intersection of Trust and Frustration"
[16:18:29] <eddyb> bstrie_mojitos: <3
[16:18:49] <eddyb> "Have an above average new year everybody!" - Dinnerbunny
[16:20:35] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Quit: Ex-Chat)
[16:20:46] *** Quits: derek_c (derek@69E4ACC.E9B0596F.C34016C.IP) (Quit: Leaving)
[16:21:54] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[16:23:49] *** Quits: sk (sk@F9A3A16F.3DDD1ABD.33B96495.IP) (Quit: Leaving)
[16:26:35] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[16:28:19] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[16:30:36] <cmr> bstrie_mojitos++
[16:32:29] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[16:32:45] <cmr> luz: dbaupp: not completely unmaintained; but not far from the truth. When a crate's docs fail to build they are removed. Once I have some time I'm going to set it up differently such that one uploads JSON from travis so that it can be integrated with rust-ci
[16:33:08] *** Quits: Kxepal832 (Miranda@moz-1E4F2404.pppoe.mtu-net.ru) (Ping timeout)
[16:35:24] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[16:35:34] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[16:35:56] *** Joins: elux (peter@B6F21F4B.1F20BC31.2170E5F.IP)
[16:36:25] *** Joins: Kxepal (Miranda@moz-B7DB05D8.pppoe.mtu-net.ru)
[16:39:36] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[16:41:27] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Connection reset by peer)
[16:41:31] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[16:43:15] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[16:45:17] *** Joins: zootm (calum@moz-150DDDC2.sgyl.cable.virginm.net)
[16:48:01] *** Quits: vmx (vmx@moz-6BCF7F11.pools.arcor-ip.net) (Quit: Leaving)
[16:48:07] <tiffany> what's the difference between the Future get and unwrap functions?
[16:48:13] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[16:51:30] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[16:51:42] <olsonjeffery> tiffany: get() requires your T to impl Clone and will do a clone() of it.. unwrap() will move the value out of the future
[16:52:11] <olsonjeffery> both will force evaluation via a call to get_ref()
[16:52:21] <tiffany> so you can .get() multiple times, but you can .unwrap() only once?
[16:53:23] <geomyidae_> and copying vs just moving.
[16:53:26] <olsonjeffery> yes. notice the signature of unwrap is unwrap(mut self) .. so it will consume itself as a result of the invocation and be unavailable afterwards
[16:53:31] <geomyidae_> copying is going to be slower, use more memory, etc
[16:54:40] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[16:55:37] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[16:57:36] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[16:58:03] *** Quits: Yurume (Yurume@A826BD81.8A0DEF81.38747683.IP) (Ping timeout)
[16:58:11] *** flaper87 is now known as flaper87|afk
[16:58:13] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[16:58:14] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Ping timeout)
[16:59:47] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[17:00:08] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[17:07:12] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[17:07:28] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[17:11:10] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Ping timeout)
[17:13:43] *** Joins: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr)
[17:14:01] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[17:14:34] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:14:36] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[17:20:38] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[17:22:24] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Ping timeout)
[17:23:11] * geomyidae_ unused variables in test code seems to cause silent failure
[17:23:29] *** Joins: Yurume (Yurume@A826BD81.8A0DEF81.38747683.IP)
[17:23:34] <geomyidae_> or something. I've got a test that just does assert_eq!(10u, 10u) and it fails unless I comment out two `let = blah...` lines.
[17:23:53] <geomyidae_> https://github.com/colemickens/pcapfe/blob/master/test.rs
[17:24:07] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[17:25:05] <cmr> geomyidae_: obvious question: is DecodePacket failing?
[17:25:18] <cmr> is the assert_eq actually failing?
[17:27:07] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[17:28:22] *** Joins: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de)
[17:28:50] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[17:31:14] <geomyidae_> Honestly, I have no idea how to know. I guess there's a way to recover from fails?
[17:31:32] <geomyidae_> I would've expected it to ... say something about a failure in the output, which I didn't see, hmm
[17:32:06] <geomyidae_> I'm an idiot
[17:32:15] * geomyidae_ runs away
[17:32:36] <geomyidae_> task 'test_decode_udp_packet' failed at 'failed to decode', /build/rust-git/src/rust/src/libstd/option.rs:111
[17:33:24] <geomyidae_> I feel like I solve all sorts of difficult issues on my own and then proudly display silly mistakes for all of #rust :)
[17:33:43] *** Quits: nkoep (nik@moz-F424EA91.pool.mediaways.net) (Quit: Leaving)
[17:34:30] *** Joins: mib_qjh3ux (Mibbit@moz-7D437995.insight.res.rr.com)
[17:34:44] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[17:34:58] *** Quits: mib_qjh3ux (Mibbit@moz-7D437995.insight.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[17:37:08] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[17:37:42] *** Quits: Ms2ger (Ms2ger@moz-268A540A.access.telenet.be) (Quit: nn)
[17:39:35] *** Quits: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de) (Ping timeout)
[17:39:38] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[17:41:00] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[17:44:13] *** Quits: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP) (Ping timeout)
[17:47:52] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[17:53:26] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:54:24] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[17:55:31] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[17:57:12] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[17:59:01] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[18:03:01] *** Joins: mpiechotka (mpiechotka@moz-FF5F76BA.adsl.inetia.pl)
[18:05:28] *** Quits: moostik (Icedove@moz-40E6ACEF.w2-2.abo.wanadoo.fr) (Ping timeout)
[18:05:33] *** Joins: pepper_chico (pepper_chi@E4B89D8C.3C9EA51F.F546FA5F.IP)
[18:08:29] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[18:09:01] *** Joins: moostik (Icedove@moz-5956E11F.w92-135.abo.wanadoo.fr)
[18:09:31] *** Quits: jesse99 (jesse99@moz-8B1E0C5D.hsd1.wa.comcast.net) (Ping timeout)
[18:09:58] *** Joins: jesse99 (jesse99@moz-8B1E0C5D.hsd1.wa.comcast.net)
[18:13:46] *** Joins: pongad (Mibbit@moz-831734D6.revip2.asianet.co.th)
[18:15:17] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[18:19:22] *** Quits: pepper_chico (pepper_chi@E4B89D8C.3C9EA51F.F546FA5F.IP) (Quit: Ex-Chat)
[18:21:23] *** Joins: eholk (eholk@moz-58C5EE6F.wavecable.com)
[18:23:08] <mpiechotka> Hi. I'm just starting with rust so sorry for basic question. When I run 'rustpkg build' it just displays a help message (I have src subdir so according to message it should build my package).
[18:23:49] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Ping timeout)
[18:24:18] <mpiechotka> Ok. It needed to be 'src/<PACKAGE NAME>'
[18:24:45] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[18:26:40] *** Quits: pongad (Mibbit@moz-831734D6.revip2.asianet.co.th) (Quit: http://www.mibbit.com ajax IRC Client)
[18:27:35] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[18:27:36] *** Quits: elux (peter@B6F21F4B.1F20BC31.2170E5F.IP) (Quit: Bye!)
[18:28:43] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[18:29:17] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[18:30:02] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[18:30:36] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[18:30:41] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[18:30:51] *** Joins: alan_andrade (alan_andra@2D866054.D1EB06A3.B7838CA6.IP)
[18:31:06] *** Quits: rca_ (rcatolino@moz-11D6C67F.adsl.proxad.net) (Quit: leaving)
[18:31:07] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[18:31:49] *** Joins: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net)
[18:40:17] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:40:17] *** ChanServ sets mode: +ao brson brson
[18:41:36] *** Quits: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net) (Quit: klaus)
[18:43:35] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[18:45:00] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[18:45:32] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[18:46:59] *** Joins: klaus (koz@moz-E49E7C4B.hsd1.wa.comcast.net)
[18:49:17] *** Joins: Earnestly (earnest@88884C6.A3735F9C.39C00A7A.IP)
[18:56:15] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[18:57:46] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:57:57] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[19:02:22] <pyon> What is the syntax for an owned vector whose elements are borrowed pointers?
[19:02:42] <benh> ~[~T]?
[19:02:54] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[19:02:56] *** Joins: pongad (Mibbit@moz-831734D6.revip2.asianet.co.th)
[19:03:11] <pyon> benh: That is an owned vector whose elements are owned pointers.
[19:03:12] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[19:03:12] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[19:03:37] <sfackler> ~[&T]
[19:04:09] <pyon> sfackler: Ah. How do I tie the lifetime of the borrowed pointers to the lifetime of the vector?
[19:04:31] <sfackler> it's implicit iirc
[19:04:35] <pyon> Oh, never mind. I am just stupid.
[19:04:45] <benh> ...that's true. i just woke up from a nap and am bad at reading, apparently.
[19:05:13] <benh> I don't think the lifetime of the borrowed pointers is tied to the vector at all :(
[19:06:04] <sfackler> I mean, they can't live for less time than the vector does
[19:06:05] <pyon> benh: Yeah, I just realized a crucial thing: the vector is an element from struct, so I can tie the lifetime of the borrowed elements to the lifetime of the struct.
[19:07:04] <pyon> struct Foo<'self> { priv bars: ~[&'self Bar] }
[19:07:29] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[19:08:36] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[19:09:10] <pyon> The nice thing about this lifetime thingy is how it really forces me to plan stuff ahead - and this is the kind of stuff that, if you are not careful, will cause incomprehensible bugs. :-)
[19:10:07] <pongad> I never programmed in C++, but all this lifetime insanity is giving me an idea of how hard it has to be :S
[19:10:12] <benh> With mutable borrowed pointers being exclusive, I'm not sure how far you can really get with elaborate planned-ahead lifetime annotations :i
[19:10:13] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[19:12:44] *** Quits: FreeFull (freefull@moz-EFEF3DB5.as13285.net) (Ping timeout)
[19:13:42] *** Joins: FreeFull (freefull@moz-4A6266D8.as13285.net)
[19:14:12] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[19:14:34] <pyon> pongad: When you program in C++, you have to be just as careful about lifetimes as when you program in Rust. The only difference is that the compiler will only help you for owning pointers (std::unique_ptr and std::shared_ptr) but not for borrowed pointers (& and *).
[19:14:59] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[19:15:00] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[19:16:59] <pongad> pyon: Even in unique_ptr, you don't get all the errors at compilation right? If you make a null unique_ptr, the access still fails at runtime. Compiler just makes sure you don't copy the ptr
[19:17:25] <pyon> pongad: That's right.
[19:18:06] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[19:18:37] <pyon> pongad: But in my experience, null unique_ptrs don't happen too frequently, unless you are doing something fundamentally wrong, whereas invalid raw references and pointers happen all the time.
[19:19:30] *** Quits: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP) (Client exited)
[19:20:02] <pongad> pyon: True
[19:23:49] *** Quits: FreeFull (freefull@moz-4A6266D8.as13285.net) (Ping timeout)
[19:24:00] *** Joins: FreeFull (freefull@moz-12F67E3B.as13285.net)
[19:24:43] *** Quits: StarLight (StarLight@moz-A3D56A9D.pppoe.avangarddsl.ru) (Ping timeout)
[19:25:02] <SiegeLord> How do I work with RefCell? Do I use 'with' or do I use 'borrow'?
[19:25:58] *** Quits: FreeFull (freefull@moz-12F67E3B.as13285.net) (Ping timeout)
[19:27:55] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[19:28:58] *** Joins: StarLight (StarLight@moz-941BC59B.dynamic.avangarddsl.ru)
[19:29:38] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[19:33:41] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[19:34:37] <eddyb> SiegeLord: (great, I can't remember the acronym) borrow is preferred
[19:35:21] <eddyb> RAII > closures (especially now without "do")
[19:35:55] <SiegeLord> OK
[19:37:57] *** Joins: maxiepoo (Max@moz-D66F3D4E.atvci.net)
[19:39:07] *** Quits: Kxepal (Miranda@moz-B7DB05D8.pppoe.mtu-net.ru) (Ping timeout)
[19:39:22] *** Quits: pongad (Mibbit@moz-831734D6.revip2.asianet.co.th) (Quit: http://www.mibbit.com ajax IRC Client)
[19:39:39] *** Quits: alan_andrade (alan_andra@2D866054.D1EB06A3.B7838CA6.IP) (Input/output error)
[19:41:43] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:41:50] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[19:42:27] <sfackler> SiegeLord: with is there as a convinience. It just wraps a borrow and get
[19:42:52] <SiegeLord> Yes, but I take it, as eddyb said, that RAII is more... idiomatic?
[19:42:56] <SiegeLord> If Rust has idioms
[19:43:26] <eddyb> do used to be idiomatic, but there has been a shift. pcwalton could explain better if he were here
[19:43:43] *** Joins: FreeFull (freefull@moz-EFA69230.as13285.net)
[19:44:02] <strcat> eddyb: rust didn't used to have destructors
[19:44:09] <strcat> it had 'resources'
[19:44:10] <strcat> it sucked
[19:44:18] <SiegeLord> I find it funny that there are idioms for new features :P
[19:44:43] <strcat> rust has had destructors for a long time now
[19:45:35] <benh> strcat: i'm curious, why did you close #10043?
[19:46:03] <strcat> benh: not a goal
[19:46:23] <strcat> I've opened various issues instead
[19:46:32] <benh> makes sense
[19:46:38] <strcat> some were accepted, some were rejected, some aren't really controversial
[19:47:48] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[19:48:21] <benh> https://github.com/mozilla/rust/issues/11227 isn't this double-ref, not double-deref?
[19:48:23] *** Joins: telotortium (rmi1@moz-46F0EE50.hsd1.ca.comcast.net)
[19:49:11] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[19:49:11] *** ChanServ sets mode: +ao pcwalton pcwalton
[19:50:09] <pcwalton> yay, rust bootstrapped with no @mut support in the typechecker
[19:50:16] <pcwalton> now time to remove it from the parser
[19:54:18] <bjz> \o/
[19:57:00] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[19:58:42] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[20:07:18] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[20:07:39] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[20:08:47] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Client exited)
[20:10:30] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[20:11:37] <pyon> So, Rust 0.9 will not have @ ?
[20:11:57] <strcat> it's not part of the non-gated language
[20:12:07] <strcat> still used heavily by old code
[20:12:18] <pyon> Ah! :-)
[20:12:22] *** Joins: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net)
[20:12:53] *** Quits: telotortium (rmi1@moz-46F0EE50.hsd1.ca.comcast.net) (Quit: telotortium)
[20:14:04] <FreeFull> Rc<T> and Gc<T>!
[20:19:37] <pcwalton> I am working on killing @ next
[20:19:39] <pcwalton> once all this junk lands
[20:19:43] <pcwalton> all this @mut junk
[20:20:03] <pcwalton> @ will be removed carefully, starting with the pattern form, then @self
[20:20:11] <pcwalton> then the expression form
[20:20:12] <pcwalton> then the type form
[20:22:47] <whitequark> Rc<T> is so verbose :/
[20:24:01] <strcat> whitequark: overloading for * is planned
[20:24:10] <strcat> and that includes auto-deref (foo_box.bar)
[20:24:21] <whitequark> nice!
[20:24:38] <whitequark> strcat: by the way, why did you close your rust-core issue?
[20:24:46] <strcat> because I opened other issues
[20:25:21] <whitequark> I see
[20:25:27] <strcat> there's an A-freestanding tag with 3 and then dozens of other things
[20:25:39] <whitequark> unrelated: can you take a look at #11173?
[20:25:53] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[20:25:59] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[20:26:03] <whitequark> I've fixed everything which has been pointed out
[20:26:24] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[20:26:30] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[20:27:04] *** Quits: ianj (ianjneu@moz-7BA002E.hsd1.ma.comcast.net) (Quit: leaving)
[20:28:25] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[20:29:45] <SiegeLord> pcwalton: Could I get a re-review of https://github.com/mozilla/rust/pull/11155 ? It bitrotted due to the @mut changes, and I've just fixed it
[20:29:59] <pcwalton> SiegeLord: sure thing!
[20:30:08] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[20:30:08] <pcwalton> r+ for you
[20:30:12] <SiegeLord> Thanks!
[20:30:14] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[20:30:52] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[20:32:04] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[20:33:13] <whitequark> strcat: thanks!
[20:33:40] * strcat really wants rustc to be able to output freestanding code itself...
[20:34:35] *** Quits: killerswan (kevincantu@moz-CC0DC654.hsd1.ca.comcast.net) (Ping timeout)
[20:35:02] <whitequark> strcat: I've been thinking to add support for triples with OS=none, doing exactly that
[20:35:16] <whitequark> but then I found an existing issue where this idea was shot down
[20:35:44] <strcat> there's the segmented stack issue, and it'd be nice to be able to disable position independent code
[20:36:26] <whitequark> I think rust should check for stack overflows either way; the perf hit is miniscule compared to the benefit
[20:37:02] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[20:37:10] <strcat> whitequark: gcc has -fcheck-stack which is a much saner way to do it
[20:37:26] <strcat> LLVM has it for windows as chkstk, and could have it elsewhere
[20:37:35] <whitequark> how does it differ from what LLVM inserts in prologues for __morestack?
[20:37:54] <strcat> whitequark: guard page + output a byte store per page in functions with large uninit frames
[20:38:07] <strcat> and then if there's no MMU you can fall back to __morestack style
[20:38:17] *** Quits: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP) (Quit: brb)
[20:38:19] <whitequark> well, for freestanding code there's usually no MMU
[20:38:30] *** Quits: FreeFull (freefull@moz-EFA69230.as13285.net) (Ping timeout)
[20:38:47] *** Joins: FreeFull (freefull@moz-D8B8D8D6.as13285.net)
[20:38:56] <whitequark> or MPU for that matter
[20:40:09] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:40:39] *** Joins: threecreepio (Adium@moz-9DA6CBAC.bredband.comhem.se)
[20:41:49] *** Quits: maxiepoo (Max@moz-D66F3D4E.atvci.net) (Quit: maxiepoo)
[20:43:31] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[20:44:19] *** Joins: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP)
[20:44:26] <brson> has 'do' been removed?
[20:47:08] *** Joins: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com)
[20:47:37] <eddyb> brson: it only works with procs
[20:47:46] <eddyb> (AFAIK)
[20:51:28] *** Quits: threecreepio (Adium@moz-9DA6CBAC.bredband.comhem.se) (Quit: Leaving.)
[20:52:44] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[20:52:44] *** ChanServ sets mode: +o jdm
[20:52:58] *** Joins: telotortium (rmi1@moz-46F0EE50.hsd1.ca.comcast.net)
[20:53:20] *** Quits: telotortium (rmi1@moz-46F0EE50.hsd1.ca.comcast.net) (Quit: telotortium)
[20:56:30] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[20:57:08] *** Quits: lenstr (lenstr@CD7D5ABA.83A99F98.85938D85.IP) (Quit: Leaving...)
[20:57:45] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[20:59:26] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[21:02:14] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[21:02:15] *** Joins: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP)
[21:02:36] <pyon> What is the difference between "&SomeTrait" and "&SomeType" where "SomeType: SomeTrait"?
[21:04:23] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[21:04:51] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[21:11:55] <benh> &SomeType is still the concrete type, &SomeTrait will box the value along with a vtable and erases the type
[21:14:07] <tomdale> so we have a ~T and we're currently doing &**s to convert it into a &T. We want to have a variant of our function that returns a &mut T, but &mut **s is saying "cannot borrow immutable dereference of ~ pointer as mutable"
[21:14:15] <tomdale> is there a mutable dereference?
[21:14:49] *** Joins: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[21:15:21] *** Quits: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[21:15:24] <tomdale> actually it's an &~T
[21:15:35] <benh> You might need a &mut ~T to begin with
[21:15:41] *** Joins: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[21:15:43] <tomdale> ahh
[21:15:45] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[21:15:54] <tomdale> nice
[21:16:01] <tomdale> as_mut() on the Option instead of as_ref()
[21:16:02] <tomdale> bingo
[21:16:08] <tomdale> thanks so much bro
[21:16:31] *** Quits: dogurness (dogurness@moz-1BF32EBD.pitbpa.fios.verizon.net) (Quit: dogurness)
[21:22:37] *** Joins: mr_wibble (Mibbit@moz-6FC202EE.adsl.highway.telekom.at)
[21:22:52] *** Quits: mr_wibble (Mibbit@moz-6FC202EE.adsl.highway.telekom.at) (Quit: http://www.mibbit.com ajax IRC Client)
[21:23:51] *** Joins: threecreepio (Adium@moz-9DA6CBAC.bredband.comhem.se)
[21:24:11] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[21:24:55] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[21:25:13] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[21:25:32] *** Joins: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de)
[21:26:56] <pyon> "<benh> &SomeType is still the concrete type, &SomeTrait will box the value along with a vtable and erases the type" --> that means that I should be able to convert from "&SomeType" to "&SomeTrait", right?
[21:27:37] <eddyb> pyon: yes, but not the other way around
[21:28:02] <eddyb> pyon: on master we have auto-coercion now, you can use "as" to force it (before we only had "as")
[21:28:54] <pyon> Ah!
[21:29:00] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[21:30:41] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[21:30:53] <eddyb> pyon: the Any trait actually allows casting in the other direction (using reflection to make it safe)
[21:31:10] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[21:32:03] <pyon> I am not really interested in downcasting. :-)
[21:32:25] <pyon> I want to make my code reflection-free, especially when using native languages.
[21:32:51] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[21:33:20] <eddyb> pyon: actually, it doesn't use the more magic reflection, just a virtual method call which returns an unique type ID
[21:33:52] <pyon> eddyb: What if the type ID does not match? Task failure?
[21:34:03] <eddyb> pyon: returns None instead of Some ;)
[21:34:33] <pyon> Ah, it downcasts to an option type. Nice.
[21:35:04] <eddyb> safer than C++'s dynamic_cast. and it requires no runtime support
[21:35:29] <tomdale> trace.rs:175:8: 175:53 error: type `&mut [~buffoon::annotation::Annotation]` does not implement any method in scope named `unshift`
[21:35:40] <pyon> Well, it requires keeping type IDs.
[21:35:45] <cmr> tomdale: that's correct. you can't modify the length ofa slice.
[21:35:51] <tomdale> hmmm
[21:36:01] <tomdale> but I don't want to change ownership either
[21:36:01] <eddyb> pyon: all "reflection" magic in Rust is just virtual methods (traits) and a tydesc structure hidden in the same vtable used for trait methods
[21:36:52] <eddyb> pyon: Any by itself doesn't require more runtime support than any (no pun intended) trait would do
[21:37:07] <eddyb> pyon: it uses an intrinsic to get an unique ID of the type *but that's at compile-time*
[21:37:32] *** Quits: eholk (eholk@moz-58C5EE6F.wavecable.com) (Quit: eholk)
[21:37:36] <eddyb> pyon: when you cast something to ~Any, for example, its vtable will contain a method which returns that type ID
[21:38:02] <cmr> tomdale: take &mut ~[...]
[21:38:23] <pyon> eddyb: If I never use downcasts, is the compiler smart enough to not include type IDs in the vtables?
[21:38:34] <strcat> pyon: no
[21:38:43] <pyon> :-(
[21:38:47] <tomdale> what's the point of a mutable slice then?
[21:38:55] <eddyb> tomdale: you can mutate elements
[21:38:55] <pyon> tomdale: mutating the elements
[21:39:08] <strcat> &[T] is a view, &mut [T] is a mutable view
[21:39:09] <cmr> tomdale: it's a non-owning view of memory that you can mutate the elements of.
[21:39:09] <pyon> tomdale: It's a slice of memory that you don't own, but you can edit.
[21:39:26] <eddyb> pyon: type IDs are actually returned from a regular trait method (in Any's case) - if you mean the tydesc structure, it's just const memory, like a string literal
[21:40:42] <eddyb> pyon: there's no visible runtime cost, unlike C++ where you need an entire library or so
[21:40:50] <pyon> eddyb: Ah, I just checked... Any is actually a trait, so the overhead is only for those types that implement it. :-)
[21:40:51] <tomdale> long live DST
[21:41:08] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[21:41:12] <cmr> pyon: all types implement Any.
[21:41:13] <eddyb> pyon: all types implement Any
[21:41:17] <pyon> Oh.
[21:41:21] <cmr> Or, rather, Any is implemented for all types.
[21:41:26] <cmr> impl<T> Any for T
[21:41:27] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[21:41:29] <strcat> pyon: all trait objects have a tydesc field
[21:41:37] <cmr> The compiler emitted tydescs long before Any existed
[21:41:41] *** Quits: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Ping timeout)
[21:41:44] <strcat> the vtable looks like [tydesc_ptr, method_ptr, method_ptr]
[21:41:52] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[21:42:03] <strcat> if you use traits dynamically instead of statically, you have runtime type information
[21:42:14] <eddyb> pyon: the overhead of Any::<for T>::vtable (including all methods pointed to by it) only appears if you *cast* a &T to &Any or ~T to ~Any
[21:42:48] <pyon> eddyb: So Any instances are optimized away if I don't use them?
[21:43:04] <cmr> pyon: I don't think you quite understand how trait objects work
[21:43:10] <cmr> There's no Any instance if you don't make it.
[21:43:11] <eddyb> pyon: Any instances *don't exist* before you use them
[21:43:15] <cmr> "instance"
[21:43:35] <eddyb> pyon: it's a generic impl, just like any other generic, it's not monomorphized without uses
[21:43:37] <pyon> Errr... I used the word "instance" in the Haskell sense.
[21:43:43] <pyon> I meant "impl".
[21:44:07] * pyon usually remembers to say "trait" instead of "type class", but forgets to say "impl" instead of "instance".
[21:44:24] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[21:44:54] <cmr> :)
[21:45:07] <cmr> I thought you meant it in the c++ sense
[21:45:25] <pyon> Heh. :-)
[21:46:03] *** Joins: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[21:46:07] *** Quits: DAddYE_ (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[21:46:10] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Connection reset by peer)
[21:46:29] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[21:47:01] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[21:47:21] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[21:47:22] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Connection reset by peer)
[21:48:51] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[21:54:13] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[21:54:15] *** Joins: eholk (eholk@moz-58C5EE6F.wavecable.com)
[21:54:20] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[21:55:15] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[21:56:22] *** Joins: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com)
[21:58:32] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[21:59:17] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[21:59:30] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[22:00:13] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[22:02:10] <tomdale> it would be nice to have Result as_option
[22:03:00] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Ping timeout)
[22:03:16] <cmr> .ok() and .err() return Option<T> and Option<E> respectively.
[22:04:33] *** Joins: pepper_chico (pepper_chi@E4B89D8C.3C9EA51F.F546FA5F.IP)
[22:05:32] <tomdale> nice
[22:06:38] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Connection reset by peer)
[22:06:44] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[22:07:30] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Client exited)
[22:12:27] *** Quits: pepper_chico (pepper_chi@E4B89D8C.3C9EA51F.F546FA5F.IP) (Quit: Ex-Chat)
[22:14:14] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[22:14:54] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[22:15:06] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Input/output error)
[22:16:26] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[22:20:19] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[22:20:20] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[22:20:25] *** Joins: sigma1 (sigma@moz-BFB7A653.range86-143.btcentralplus.com)
[22:23:54] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[22:24:36] *** Quits: sigma1 (sigma@moz-BFB7A653.range86-143.btcentralplus.com) (Ping timeout)
[22:29:30] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[22:31:12] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[22:32:58] *** Joins: dkeenaghan (dkeenaghan@A9F153F4.DDE28F19.986A907C.IP)
[22:34:19] *** Joins: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com)
[22:34:19] *** ChanServ sets mode: +o jdm
[22:37:50] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[22:38:47] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[22:38:49] *** Quits: jdm (jdm@moz-3FFA85CA.dsl.teksavvy.com) (Quit: Lost terminal)
[22:40:37] *** Joins: sigma1 (sigma@C91C7F36.70518F41.9D18269F.IP)
[22:43:47] *** Quits: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP) (Client exited)
[22:44:52] *** Joins: pyon (user@BCC41BDF.6C782DF8.1C8C8CE9.IP)
[22:45:02] *** Quits: twi (Adium@moz-174339A4.cust.dsl.vodafone.it) (Quit: Leaving.)
[22:47:51] *** Joins: twi (Adium@moz-174339A4.cust.dsl.vodafone.it)
[22:48:26] *** Quits: threecreepio (Adium@moz-9DA6CBAC.bredband.comhem.se) (Ping timeout)
[22:48:54] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[22:48:59] *** Quits: flaper87|afk (flaper87@moz-107AD163.redhat.com) (Ping timeout)
[22:50:38] *** Joins: ecl3ctic (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP)
[22:50:44] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[22:51:22] *** Joins: rsaarelm (rsaarelm@moz-D1CB7158.dhcp.inet.fi)
[22:51:54] *** Quits: ecl3ctic (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:51:56] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[22:52:02] *** Joins: ecl3ctic (Mibbit@578C64B6.F0F44EFA.76AE55C1.IP)
[22:52:28] *** Quits: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net) (Ping timeout)
[22:52:41] *** Joins: flaper87|afk (flaper87@moz-107AD163.redhat.com)
[22:52:42] *** Joins: Axord (xord@moz-C0D5F15A.lsanca.dsl-w.verizon.net)
[22:53:23] <dbaupp> brson: re removal of do, https://github.com/mozilla/rust/pull/10985
[22:56:34] *** Quits: maikklein (maik@moz-E748EB1A.dip0.t-ipconnect.de) (Ping timeout)
[22:56:40] *** Quits: bheylin (brianheyli@moz-8255E94E.adsl.online.nl) (Quit: bheylin)
[22:57:18] *** Quits: jzelinskie (sid17772@moz-A42E5B7B.irccloud.com) (Ping timeout)
[22:57:36] *** Joins: jzelinskie (sid17772@moz-A42E5B7B.irccloud.com)
[22:58:45] *** Joins: tikue_ (tkuehn@moz-C55F9DFF.hsd1.pa.comcast.net)
[22:59:15] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[22:59:37] <olsonjeffery> is 0.9 upon us?
[22:59:40] <olsonjeffery> \o/ ?
[23:00:20] *** Quits: sfackler (sfackler@moz-AEECCEBA.com) (Ping timeout)
[23:00:37] *** Joins: threecreepio (Adium@moz-9DA6CBAC.bredband.comhem.se)
[23:00:42] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[23:00:55] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[23:01:01] <brson> soon...
[23:01:07] *** Joins: sfackler (sfackler@moz-AEECCEBA.com)
[23:02:19] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:04:14] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[23:06:40] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[23:07:25] *** Joins: engla_ (engla@moz-F64E1B0F.cust.bredbandsbolaget.se)
[23:08:14] *** Quits: engla (engla@moz-F64E1B0F.cust.bredbandsbolaget.se) (Ping timeout)
[23:14:01] *** Quits: jlong (jlong@moz-6DFDE846.socal.res.rr.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:18:09] *** Quits: eholk (eholk@moz-58C5EE6F.wavecable.com) (Quit: eholk)
[23:18:38] *** Quits: bougyman (bougyman@moz-C8C4EF5D.uvs.rcsntx.sbcglobal.net) (Ping timeout)
[23:20:14] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[23:22:16] *** Joins: bougyman (bougyman@moz-C8C4EF5D.uvs.rcsntx.sbcglobal.net)
[23:24:32] *** Joins: samx (sami@moz-D9DA5773.dyn.optonline.net)
[23:25:38] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[23:25:38] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[23:27:31] *** Quits: samx (sami@moz-D9DA5773.dyn.optonline.net) (Quit: This computer has gone to sleep)
[23:28:38] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[23:28:41] *** Joins: jlong (jlong@moz-6DFDE846.socal.res.rr.com)
[23:29:05] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[23:29:09] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Client exited)
[23:29:51] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:31:33] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[23:36:59] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[23:37:39] *** Quits: tikue_ (tkuehn@moz-C55F9DFF.hsd1.pa.comcast.net) (Quit: tikue_)
[23:39:33] <whitequark> can there be extern statics?
[23:39:39] <strcat> whitequark: yep
[23:39:47] <whitequark> ... without initializers?
[23:39:51] <strcat> whitequark: yep.
[23:39:56] <whitequark> how do I make one?
[23:40:03] *** Quits: csherratt (csherratt@moz-CAF331EA.cable.teksavvy.com) (Quit: csherratt)
[23:40:05] <strcat> whitequark: extern { static mut x; } I think?
[23:40:11] <strcat> works like functions
[23:40:12] <whitequark> oh!
[23:40:15] <benh> might need a type
[23:40:19] <strcat> er, right
[23:40:27] <strcat> you can find fun bugs due to the assumption that static == constant expression
[23:40:35] <strcat> in lots of librustc
[23:40:50] <whitequark> strcat: I only need an address of the static, it's to communicate with the ldscript
[23:41:13] <whitequark> well, we'll find out soon
[23:41:47] <kkris> Happy New Year!
[23:41:47] <strcat> whitequark: well, they aren't blocking bugs, just fun stuff like trying to do 'static x: int = not_really_const_static + 2'
[23:42:26] <whitequark> how would you even do that with an extern static?
[23:42:26] <strcat> whitequark: because rust expects that the initializers are constant exprs and assumes statics must be constant
[23:42:40] <strcat> whitequark: error out ;p
[23:42:43] <whitequark> it'll need to pass the expression down to the linker
[23:42:44] <whitequark> right
[23:42:55] <whitequark> hm, this doesn't play well with appending globals...
[23:43:14] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[23:44:43] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:45:33] *** Joins: bheylin (brianheyli@moz-8255E94E.adsl.online.nl)
[23:46:54] *** Quits: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:49:17] <carter> pcwalton: i hope i've been vaguely constructive on that oh too long mailing list thread
[23:49:20] <carter> :)
[23:49:36] <pcwalton> carter: it's cool
[23:50:09] <carter> relatedly: i'd be happy to spend some time hacking out a few candidate concurrent queue data structures
[23:50:15] <carter> i need some for some of my own work anyways
[23:51:36] <pcwalton> feel free
[23:52:00] <carter> hrm, would http://static.rust-lang.org/doc/master/std/sync/deque/index.html be  viable backend for a dequeu like channel?
[23:52:42] <carter> it kinda has the right api ish already
[23:53:28] <carter> hrmm
[23:53:33] <strcat> carter: meant as a work-stealing deque though
[23:53:37] <strcat> not as a simple FIFO
[23:53:37] <carter> true
[23:53:48] <carter> so it could probably be simplified a wee bit
[23:54:12] <carter> hrmmm http://static.rust-lang.org/doc/master/std/sync/index.html i guess that may be subsumed by the others.
[23:54:59] *** Joins: Guest_ (textual@moz-30B6C3D1.lightspeed.rsbgtx.sbcglobal.net)
[23:55:50] <carter> ok, i've got some reading / learnign to do :)
[23:57:01] <strcat> the issue is that when you want blocking + multiple producers/consumers, you end up not being able to use any of those fancy data structures anyway
[23:57:18] <strcat> and that's the high-level, unrestricted type
[23:57:22] * pcwalton is amazed where http://togototo.wordpress.com/2013/07/23/benchmarking-level-generation-go-rust-haskell-and-d/
[23:57:27] <pcwalton> ended up
[23:57:29] <pcwalton> Scala beat GCC?
[23:57:46] <strcat> pcwalton: just dumb benchmarks
[23:57:48] <strcat> ;p
[23:57:50] <pcwalton> I know :)
[23:58:02] <strcat> ones that are strictly non-blocking or restrict the consumer/producers to 1 can be faster but I'd rather just switch to those as needed
[23:58:16] <carter> strcat: yeah
[23:58:24] <carter> theres different apis and they need different things
[23:58:40] <strcat> well atm rust has no multiple-consumer queue afaik
[23:58:48] <pcwalton> carter: try a version with locks and try a version with lock free queues if you want to experiment
[23:58:58] <pcwalton> keep in mind our mutexes are not quite as efficient as pthread mutexes
[23:59:01] <pcwalton> yet
[23:59:04] <pcwalton> but it'll still be interesting
[23:59:10] <carter> a version of which data structure?
[23:59:14] <pcwalton> of anything! :)
[23:59:16] <carter> ok
[23:59:17] <pcwalton> any channel thing
[23:59:17] <carter> good point
[23:59:38] * strcat only has 4 cores so the lock-free ones do not look good...
[23:59:52] <carter> relatedly: i was looking at the atomics module, and that looks like another example where the "compile time static args" stuff would be good

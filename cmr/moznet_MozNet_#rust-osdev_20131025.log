[00:08:45] *** Joins: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk)
[00:10:30] *** Quits: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk) (Ping timeout)
[00:14:34] *** Joins: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk)
[00:42:48] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:59:43] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Input/output error)
[00:59:53] *** Joins: geoffhill (geoffhill@moz-244CF33A.amazon.com)
[01:03:30] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Ping timeout)
[01:08:19] *** Joins: geoffhill (geoffhill@moz-244CF33A.amazon.com)
[01:33:28] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Ping timeout)
[01:51:23] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[02:01:52] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[02:15:47] *** Quits: kimundi (kimundi@moz-C410002E.dip0.t-ipconnect.de) (Ping timeout)
[02:19:17] *** Joins: kimundi (kimundi@moz-16FE982D.dip0.t-ipconnect.de)
[02:20:19] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[02:20:34] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:23:36] *** kimundi is now known as zz_kimundi
[02:30:38] *** zz_kimundi is now known as kimundi
[03:06:58] *** Quits: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net) (Ping timeout)
[03:08:56] *** Joins: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net)
[03:27:49] *** Joins: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP)
[03:29:22] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:37:16] *** Quits: Luqman (laden@moz-AB7945E9.csclub.uwaterloo.ca) (Ping timeout)
[03:57:49] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[04:05:41] *** Joins: Luqman (laden@moz-AB7945E9.csclub.uwaterloo.ca)
[04:08:06] *** Quits: eddyb9 (eddy@37F72125.9065A63B.FCAAE698.IP) (Ping timeout)
[04:12:57] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[04:13:12] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[04:20:16] *** Joins: eddyb9 (eddy@BF35C1DC.9A7C5F59.4A6B528C.IP)
[04:39:45] *** Quits: Thiez (thiez@moz-BF669398.student.utwente.nl) (Ping timeout)
[04:40:17] *** Joins: Thiez (thiez@moz-BF669398.student.utwente.nl)
[04:40:56] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[04:45:18] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[05:07:03] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[05:07:08] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:07:09] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[05:07:30] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:26:01] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Quit: jeffdb_)
[05:46:03] <pcmattman> is it possible to do #[link_args...] controlled with a #[cfg] ?
[05:47:20] <pcmattman> having tried it, it seems the answer is no, but I could've done it wrong
[05:47:26] <dbaupp> pcmattman: kinda
[05:47:49] <dbaupp> but you have to repeat the item with the #[cfg] and #[link_args] for each
[05:48:22] *** kimundi is now known as zz_kimundi
[05:48:49] <pcmattman> uh, okay
[05:48:57] <pcmattman> so I can't just do that at the top level?
[05:49:17] <dbaupp> you mean on a crate?
[05:49:22] <pcmattman> er right, sorry
[05:49:35] * dbaupp understood, was just checking
[05:49:56] <dbaupp> pcmattman: https://github.com/mozilla/rust/blob/master/src/libstd/std.rs#L81-L89
[05:50:13] * dbaupp doesn't think the `mod linkhack` is necessary, since 'extern' can get #[cfg]'s
[05:50:20] <pcmattman> o_o
[05:50:28] <pcmattman> that is awesome
[05:51:11] <dbaupp> "awesome"
[05:54:24] <pcmattman> to be fair, these tests that I'm working on are already seriously bending some of the normal assumptions
[05:54:34] <pcmattman> what's a little link hack on top of that :)
[05:55:00] <dbaupp> haha
[06:03:34] <pcmattman> just trying to convince osx's ld to ack like linux
[06:03:35] <pcmattman> act
[06:15:43] <pcmattman> "I noticed you're trying to build a shared library! Let me check for undefined references when I link all your objects and create this shared library, because clearly nothing else could possibly ever exist that might fix these references!"
[06:18:04] <pcmattman> I can't even turn it into a run-fail and wait for the "symbols not found" at runtime because run-pass and run-fail don't fail on signals
[06:27:07] *** Quits: canhtak (jeremy@moz-ABE51D61.wl.t.ulaval.ca) (Quit: canhtak)
[06:47:10] <Luqman> dynamic symbol resolution at runtime is magic
[07:14:37] *** zz_kimundi is now known as kimundi
[07:39:12] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[07:49:11] <pcmattman> Luqman: it's not that magic
[07:57:28] *** kimundi is now known as zz_kimundi
[08:00:24] *** zz_kimundi is now known as kimundi
[08:14:03] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Connection reset by peer)
[08:38:16] *** Quits: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk) (Quit: Ex-Chat)
[08:38:20] *** Joins: nielsle (nielsle@moz-C46DA772.boa.fiberby.dk)
[08:54:02] <pcmattman> ooh this rabbit hole has now led me to std::rt::uv::uvio
[08:54:19] <dbaupp> <3 rust's rabbit holes :P
[08:54:40] <pcmattman> the problem with this rabbit hole is now I'm questioning if it's a problem with Rust or if it's a libuv bug :|
[08:55:24] <dbaupp> ah :(
[08:56:05] <pcmattman> wondering if libuv's process exit callback is being called with a zero exit status because it has a term_signal passed in
[08:56:45] <pcmattman> oh.
[08:57:32] <pcmattman> https://github.com/joyent/libuv/blob/master/src/unix/process.c#L105
[08:57:54] <pcmattman> (that may not be the "real" fork of libuv but it's the one I picked)
[08:58:07] <dbaupp> that's upstream
[08:58:42] <pcmattman> WIFEXITED apparently returns true on normal termination, ie, not by signal
[08:59:04] <pcmattman> that is, if it called exit(), _exit(), or returned from main()
[08:59:20] <dbaupp> does WIFSIGNALED cover what you need?
[08:59:28] <pcmattman> yup!
[08:59:35] <pcmattman> but it sets term_signal, leaving exit_status zero
[08:59:50] <pcmattman> and we only use exit_status in libstd
[09:00:21] <pcmattman> so on osx, run-pass works with a SIGSEGV because the termination doesn't hit WIFEXITED
[09:00:22] <dbaupp> ah!
[09:00:38] * dbaupp wonders if any tests are currently segfaulting
[09:00:53] <pcmattman> on linux, signals must terminate differently as signals _do_ fail run-pass tests there
[09:01:31] <dbaupp> that's a little peculiar
[09:01:37] <pcmattman> interestingly, the same problem means I have a run-fail test I want to push upstream that will fail because it will get interrupted by a signal and then we'll get the exit status
[09:01:46] <dbaupp> leaky abstractions :(
[09:01:49] <pcmattman> and it'll be zero, so it'll say "hey, that didn't fail!"
[09:02:10] <dbaupp> can we make std check term_signal?
[09:03:02] <pcmattman> RioProcess::wait could perhaps check both self_.exit_status as well as term_signal
[09:03:11] <pcmattman> it's still unwrapping self.exit_status as its return
[09:03:34] <pcmattman> and I'm not sure you want to return an exit status that is the signal number if a signal was the cause of termination?
[09:05:14] <Leo`> hey there
[09:13:26] <pcmattman> hi Leo`! :)
[09:16:28] <pcmattman> what the hell
[09:19:29] <pcmattman> https://github.com/mozilla/rust/issues/10062 wooooo
[09:20:37] <pcmattman> Linux does exactly the same thing as OSX with WIFEXITED, but still manages to fail the test
[09:26:48] *** kimundi is now known as zz_kimundi
[10:04:02] <Seldaek> KokaKiwi: hey, did you see the comments on your makefile PR? just checking :)
[10:08:56] *** zz_kimundi is now known as kimundi
[10:27:28] <pcmattman> linux processes don't take the libuv sigchld exit path when they get terminated by a signal :)
[10:39:54] *** Quits: eddyb9 (eddy@BF35C1DC.9A7C5F59.4A6B528C.IP) (Ping timeout)
[10:55:24] <KokaKiwi> Seldaek: I'm checking it :)
[11:19:19] *** Joins: eddyb9 (eddy@37F72125.9065A63B.FCAAE698.IP)
[11:35:50] <Leo`> is there a way in the macro system to put one of the arguments inside a string ?
[11:36:21] <eddyb> prolly some stringify procedural macro
[11:36:53] <Leo`> naively, something like: macro_rules foo(($s:stmt) => (println("$s)))
[11:37:24] <dbaupp> rusti: stringify!(foo "quz" { 1 } : ^ % )
[11:37:25] -rusti- "foo \"quz\" { 1 } : ^ %"
[11:37:53] <Leo`> mhhhhhh
[11:38:25] <Leo`> on my code, it returns "an interpolated statement" o__o
[11:39:47] <dbaupp> hah
[11:39:49] <dbaupp> :(
[11:43:51] <Leo`> maybe it comes from the fact that I call stringify from within another macro expansion
[11:44:39] <KokaKiwi> Arrrgh, tabs in Makefile looks so bad on Github :( cc Seldaek
[11:45:06] <KokaKiwi> Oh, a build system written in Rust, idea.
[11:45:22] <KokaKiwi> A make-like, in Rust, with the Rust task system
[11:45:23] <Seldaek> anything that can replace make in any language, +1 :p
[11:45:33] <KokaKiwi> :
[11:45:35] <KokaKiwi> :D
[11:45:35] <Leo`> KokaKiwi: rustpkg ?
[11:46:36] <KokaKiwi> Leo`: Nope, rustpkg build Rust package, I want a build system (like make, waf, gyp or other), but with Rust task system :p
[11:46:53] <Leo`> mh
[11:51:35] *** Joins: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca)
[12:06:14] <eddyb> KokaKiwi: rustpkg lets you write a rust file that will be executed to build the package
[12:07:06] <eddyb> KokaKiwi: you can probably expand on that to create a nifty build system for everything
[12:16:51] <KokaKiwi> Ooh? :o
[12:21:46] *** kimundi is now known as zz_kimundi
[12:57:21] *** zz_kimundi is now known as kimundi
[13:14:12] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[13:16:49] *** Quits: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca) (Quit: canhtak)
[14:15:30] <kimundi> It would be cool if someone would add build system interface APIs for rustpkg to use
[15:00:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:17:02] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:44:10] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[15:57:50] *** kimundi is now known as zz_kimundi
[16:02:27] <Leo`> is there a way to have a detailed backtrace in Rustc ?
[16:02:39] <cmr> Leo`: gdb
[16:02:43] <Leo`> it fails because of unwrap() on a None value
[16:02:53] <Leo`> I don't know where at all
[16:03:35] <Leo`> cmr: no it won't work
[16:03:42] <cmr> ...why?
[16:04:05] <Leo`> because the failure is handled in rustc.rs
[16:04:11] <Leo`> the program exits properly
[16:04:17] <Leo`> so this gives me no trace at all
[16:04:27] <cmr> Did you `break rust_begin_unwind`?
[16:05:03] <Leo`> no
[16:05:26] <Leo`> ok it works
[16:05:28] <Leo`> thanks cmr 
[16:07:45] <Leo`> mh it fails in check_match
[16:07:52] <Leo`> don't really understand why
[16:23:51] <Leo`> can I cast an int to a C-like enum ?
[16:24:17] <cmr> Leo`: you can't, not safely.
[16:24:32] <cmr> THere's #[deriving(FromPrimtive)] though
[16:25:08] <Leo`> ok
[16:25:23] <Leo`> anyway casting the enum to int will be succifient in my case
[17:23:49] <Leo`> how can I borrow a &~foo as a &foo ?
[17:24:01] <Leo`> i've got an enum that contains ~foo
[17:24:15] <Leo`> I pattern match on it by doing 
[17:24:22] <Leo`> someCase(ref a) {  
[17:24:26] <Leo`> a is the ~foo
[17:24:29] <cmr> &**a ?
[17:24:34] <Leo`> so here it is a &~foo
[17:24:42] <Leo`> I want to pass it to a function that takes a &foo
[17:24:49] <Leo`> cmr: mh... isn't this quite... dirty ?
[17:25:01] <cmr> Leo`: not really?
[17:25:15] <Leo`> okay...
[17:25:32] <cmr> rusti: struct Foo;  let x = ~Foo; let y = &x; let z: &Foo = y; println("{:?}", z);
[17:25:33] -rusti- pastebinned 10 lines of output: http://sprunge.us/AKZJ
[17:25:47] <cmr> rusti: struct Foo;  let x = ~Foo; let y = &x; let z: &Foo = &**y; println("{:?}", z);
[17:25:48] -rusti- pastebinned 7 lines of output: http://sprunge.us/LhYh
[17:25:56] <cmr> rusti: struct Foo;  let x = ~Foo; let y = &x; let z: &Foo = &**y; println!("{:?}", z);
[17:25:57] -rusti- &main::Foo
[17:25:57] -rusti- ()
[17:26:06] <Leo`> :|
[17:26:14] <Leo`> okay
[17:26:26] <cmr> Leo`: why would it be dirty?
[17:26:31] <Leo`> dunno
[17:26:41] <Leo`> adress of dereference of dereference
[17:26:47] <Leo`> +d
[17:26:51] <cmr> you're taking a reference to a value behind two pointers.
[17:26:59] <Leo`> yeah...
[17:27:15] <Leo`> isn't there a cleaner way to borrow it that writing (mut ref) in the match case ?
[17:27:18] <Leo`> to avoid having 2 pointers
[17:27:22] <cmr> you should be able to say ref *a, I think
[17:27:42] *** zz_kimundi is now known as kimundi
[17:27:56] <Leo`> ok
[17:28:20] <Leo`> error: expected identifier, found path
[17:28:21] <Leo`> :|
[17:28:39] <Leo`> I wrote case(ref *a)
[17:29:17] <cmr> rusti: struct Foo;  let x = ~Foo; match x { x@ref &Foo => println!("{:?}", x); }
[17:29:18] -rusti- pastebinned 6 lines of output: http://sprunge.us/aZee
[17:29:28] <cmr> That's... quite weird
[17:29:54] <Leo`> :\
[17:48:06] <Luqman> can't do that, you can only have an identifier after ref in patterns
[17:50:17] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:52:21] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[17:59:32] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[18:06:20] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[18:30:49] <brson> how is OS development in Rust going? what's the state of things?
[18:31:19] <cmr> brson: I stopped my OS project to work on stack safety, due to the TLS and morestack hacks needed in a kernel.
[18:31:30] <cmr> I'd rather fix rust than workaround issues.
[18:32:19] <cmr> pcmattman's project is using rust-core
[18:35:22] <strcat> brson: one current thing that's blocking progress is generic dtors not working, so custom allocators aren't possible
[18:36:24] <strcat> and I guess rust needs some way to... disable exceptions? it wants to insert upcalls if you don't optimize
[18:40:43] <Leo`> strcat, brson: don't forget the issue about static too
[18:40:52] <Leo`> 9962, IIRC
[18:54:51] *** Joins: geoffhill (geoffhill@moz-244CF33A.amazon.com)
[19:52:00] <eddyb9> brson: I'm blocked on strcat (he also wants to rewrite atomic intrinsics in rustc) and... (oh dear I'm ranting too much about school, I should stop)
[20:33:00] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[20:52:02] *** Joins: sam113101 (sam113101@moz-83612DFD.us-west-2.compute.amazonaws.com)
[21:00:49] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[21:01:56] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[21:02:07] *** Joins: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com)
[21:15:45] <dbaupp> rusti: let ~ref a = ~1; println!("{:?}", a);
[21:15:46] -rusti- &1
[21:15:46] -rusti- ()
[21:16:04] <dbaupp> Leo`, cmr: you can pattern match through ~ ^
[21:16:37] *** Quits: pcwalton (pcwalton@moz-BBE3ABD.mv.mozilla.com) (Quit: pcwalton)
[21:26:19] *** Joins: pcwalton (pcwalton@moz-7B0110AD.mv.mozilla.com)
[21:27:56] *** Joins: canhtak (jeremy@moz-3BB8F.wl.t.ulaval.ca)
[21:46:08] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[21:47:04] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:47:07] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Connection reset by peer)
[21:47:32] *** strcat1 is now known as strcat
[21:47:45] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:53:05] <Leo`> are there things to implement a queue in the stdlib ?
[21:53:14] <Leo`> a queue or a stack in fact, I don't care
[21:53:22] <Leo`> all I foudn is PriorityQUeue
[21:53:24] <Leo`> Queue*
[21:53:28] <Leo`> in extra
[21:53:33] <Leo`> don't know how it's implemented ...
[21:54:42] <eddyb> a stack? vector + push/pop
[21:55:18] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[21:55:24] <Leo`> mhhh
[21:55:31] <Leo`> yeah I supposed that would do the job
[21:55:33] <Leo`> and for a queue ?
[21:56:19] <eddyb> C++'s std::deque or whatever is its name... that's pretty cool but maybe tricky to implement
[21:56:30] <strcat> there's extra::ringbuf
[21:56:36] <strcat> I want to rewrite it though
[21:56:44] <eddyb> a doubly-linked list of vectors, I guess
[21:56:51] <Leo`> oh nice I missed that
[21:56:51] <strcat> eddyb: it's just a vector
[21:56:57] <strcat> it has amortized O(1) prepend/append
[21:57:00] <strcat> it keeps track of the start/end
[21:57:04] <strcat> it just wraps with %
[21:57:12] <Leo`> mh
[21:57:20] <strcat> I find the C++ way really weird.
[21:57:27] <Leo`> a standard vector has push and pop in queue in amortized O(1) too right ?
[21:57:29] <strcat> although I can see why a chunked list is useful
[21:57:42] <strcat> Leo`: push and pop from the end are O(1), yes
[21:58:09] <strcat> ringbuf adds a little layer of abstraction and throws away the contiguous element invariant (by wrapping) to have it on both
[21:58:25] <strcat> PriorityQueue is just a heap on top of a vector
[21:58:28] <eddyb> strcat: does ringbuf expand properly?
[21:58:32] <strcat> eddyb: yes
[21:58:50] <strcat> lets say you have 
[21:58:55] <strcat> [1, 2, _, _]
[21:59:01] <eddyb> hmm. tempted to implement a deque and bench against ringbuf
[21:59:08] <strcat> you prepend 0, you push 3
[21:59:17] <strcat> [1, 2, 3, 0] will be the element part
[21:59:24] <strcat> it keeps track of the start/end
[21:59:24] <Leo`> strcat: yeah but PriorityQueue requires Ord
[21:59:28] <Leo`> that's not what I want
[21:59:28] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[21:59:46] <strcat> Leo`: yeah it has O(1) pop of the max element and O(logn) push of an element
[21:59:57] <strcat> (priority_queue)
[22:00:03] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[22:00:11] <eddyb> well, a deque will behave better in a pathological increasing capacity case
[22:00:45] <Leo`> strcat: in fact I don't give a fuck about "max element" in my case
[22:00:55] <Leo`> i think I will use a vector as a stack as eddyb said
[22:01:05] <Leo`> it's the simplest way for me I think
[22:01:49] <Leo`> it's stupid I didn't think of it though...
[22:02:12] <Leo`> maybe I did too much Caml recently, I was looking for some inductive structure or i dunno xD
[22:28:54] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[22:59:58] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[23:02:01] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[23:24:15] <pcmattman> rusti: use std::task; fn foo() { unsafe { *(0 as *mut int) = 0; } } let mut t = task::task(); t.name("foo"); t.spawn(foo)
[23:24:16] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[23:24:23] <pcmattman> yay
[23:24:31] <pcmattman> rusti: use std::task; fn foo() { unsafe { *(0 as *mut int) = 0; } } let mut t = task::task(); t.name("foo"); t.unlinked(); t.spawn(foo)
[23:24:32] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[23:25:18] <pcmattman> cool
[23:25:54] <pcmattman> rusti: use std::task; fn foo() { unsafe { *(0 as *mut int) = 0; } } let mut t = task::task(); t.name("foo"); t.spawn_unlinked(foo)
[23:25:58] -rusti- pastebinned 7 lines of output: http://sprunge.us/bfOT
[23:26:28] <pcmattman> ah.
[23:27:17] <pcmattman> rusti: use std::task; fn foo() { unsafe { *(0 as *mut int) = 0; } } let mut t = task::task(); t.name("foo"); t.unlinked(); let r = t.future_result(); t.spawn(foo); r.recv()
[23:27:18] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[23:27:20] <pcmattman> no wait
[23:27:27] <pcmattman> rusti: use std::task; fn foo() { 1 } let mut t = task::task(); t.name("foo"); t.unlinked(); let r = t.future_result(); t.spawn(foo); r.recv()
[23:27:28] -rusti- pastebinned 7 lines of output: http://sprunge.us/EhbZ
[23:27:42] <pcmattman> rusti: use std::task; fn foo() -> int { 1 } let mut t = task::task(); t.name("foo"); t.unlinked(); let r = t.future_result(); t.spawn(foo); r.recv()
[23:27:43] -rusti- pastebinned 7 lines of output: http://sprunge.us/cBSB
[23:28:09] <pcmattman> right.
[23:33:26] <erickt> hey #rust-osdev! would anyone be interested in giving a lightning talk at the SF Bay Area meetup on Nov 20? http://www.meetup.com/Rust-Bay-Area/events/143439552/
[23:43:41] * pcmattman would be, if I didn't live in Australia :(
[23:45:22] * erickt shakes fist at the Pacific Ocean
[23:46:37] <pcmattman> be less big, dammit!
[23:46:37] <erickt> pcmattman: you and dbaupp should organize an Australian rust meetup
[23:47:14] <erickt> and then fly me over to attend :D
[23:48:25] <pcmattman> I've been tempted, but I don't know if there's any interest in my city. I think dbaupp is in a different state.
[23:48:45] <pcmattman> well, there's probably plenty of interest, just whether that interest is in a meetup is the thing :)
[23:49:07] * erickt shakes fist at Australia

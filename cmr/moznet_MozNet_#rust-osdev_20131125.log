[00:13:26] *** Quits: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au) (Ping timeout)
[00:24:05] *** Joins: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP)
[00:52:27] *** Quits: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb_)
[00:53:20] *** Joins: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[01:12:26] *** Joins: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au)
[01:14:32] *** Quits: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au) (Ping timeout)
[01:20:30] *** kimundi is now known as zz_kimundi
[01:27:09] *** Joins: bjz (bjz@moz-6AF19015.lnse4.cha.bigpond.net.au)
[01:47:47] *** Quits: brson (brson@EDE430AA.CB84766B.D1E74241.IP) (Ping timeout)
[01:52:08] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[01:56:46] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[01:58:33] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[02:20:59] *** Quits: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP) (Ping timeout)
[02:28:29] *** Joins: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP)
[03:26:15] *** Quits: zz_kimundi (kimundi@moz-7ED39474.dip0.t-ipconnect.de) (Ping timeout)
[03:29:34] *** Joins: zz_kimundi (kimundi@moz-55BB9741.dip0.t-ipconnect.de)
[03:29:36] *** zz_kimundi is now known as kimundi
[03:35:03] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[04:50:55] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[04:54:11] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Ping timeout)
[05:04:51] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[05:33:10] *** Joins: tikue_ (tkuehn@7101C711.2ACBBF24.689607DE.IP)
[05:52:14] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[05:58:00] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[05:58:11] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[05:58:27] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[06:01:54] *** Joins: brson_ (brson@moz-BBE3ABD.mv.mozilla.com)
[06:02:44] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[06:16:44] *** Quits: dbaupp (Thunderbir@29619B56.D5A1DCF.37681C44.IP) (Ping timeout)
[06:52:17] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[07:19:50] *** Joins: dbaupp (Thunderbir@moz-3BE4086E.lns20.syd6.internode.on.net)
[07:35:19] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[07:47:56] *** Joins: teratorn (teratorn@moz-5363C32C.teratorn.org)
[08:03:00] *** Quits: brson_ (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[08:06:30] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[08:34:31] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:44:49] *** Quits: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb_)
[10:14:44] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[10:16:38] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[10:51:44] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Quit: leaving)
[12:20:05] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:16:59] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[13:17:26] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[13:17:36] *** Quits: tikue_ (tkuehn@7101C711.2ACBBF24.689607DE.IP) (Quit: tikue_)
[14:34:01] *** kimundi is now known as zz_kimundi
[15:07:32] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[15:11:07] *** zz_kimundi is now known as kimundi
[15:13:25] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:22:23] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[15:42:48] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[15:42:54] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:01:02] *** kimundi is now known as zz_kimundi
[16:55:27] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:00:49] *** Joins: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[17:27:55] *** Quits: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net) (Quit: jeffdb_)
[17:36:57] *** zz_kimundi is now known as kimundi
[17:52:56] *** Joins: jeffdb_ (jeff@moz-ED35AD97.hsd1.ca.comcast.net)
[18:02:23] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[18:03:30] *** Joins: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP)
[18:41:58] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[18:51:23] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[18:52:29] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[19:14:26] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[19:14:37] <sbalmos> Hrm. Never realized this existed.
[19:15:10] <eddyb> needs more activity. I guess I'm to blame
[19:15:17] <sbalmos> :P
[19:15:39] <sbalmos> Badly need to revisit all the paperwork and such I wrote up years back on the CLR OS
[19:15:53] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:16:08] <Leo`> eddyb: well hm
[19:16:25] <Leo`> eddyb: for the @T Rc<T>, I'm currently implementing traits on Rc<T>
[19:16:32] <Leo`> in libextra and libstd
[19:16:43] <Leo`> to be able to use it in palce of @T
[19:16:57] <Leo`> concerning the variadic tuple thing, no, I didn't write any code :(
[19:17:11] <eddyb> that's fine, I'll start from scratch anyway
[19:17:15] <Leo`> I'm afraid this is beyond my Rustc-hacking skills :P
[19:17:20] <eddyb> Rc<T> sounds cool :D
[19:17:22] <sbalmos> tiffany: Anyway...
[19:17:24] <Leo`> but if you want some help... :P
[19:17:42] <tiffany> I want to write an exokernel someday
[19:18:08] <eddyb> right now I'm trying to put together a memory reduction patch, halving the size of IDs on x86_64
[19:18:23] <cmr> as in NodeId?
[19:18:35] <Leo`> eddyb: great
[19:20:00] <eddyb> cmr: yeah, mentioned it in #rust-internals, trying to test right now :P
[19:20:20] <sbalmos> tiffany: *shrug*. In concept they're interesting. I'll stick with microkernels for now.
[19:28:22] <sbalmos> tiffany: I still like the idea, though, of isolating "unsafe" user languages (e.g. C/C++) to a Ring 3/syscall compat layer
[19:28:48] <sbalmos> tiffany: Still comes down to how to determine, from an LLVM IR / pnacl perspective, what is an unsafe binaryh
[19:29:27] <cmr> sbalmos: Don't let the kernel map pages as executable unless it translates them from pnacl itself.
[19:30:50] <sbalmos> cmr: Again, how is the backend compiler to know that the pnacl inside is unsafe? It's all LLVM IR at that point.
[19:31:34] <cmr> sbalmos: I'd have to refesh my understanding, but I was under the impression pnacl disallowed all unsafe operations.
[19:31:51] <sbalmos> cmr: Let me go re-read. I could be mistaken
[19:31:56] <sbalmos> (pretty easy to do)
[19:35:44] *** Quits: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca) (Quit: canhtak)
[19:36:29] <sbalmos> cmr: Duh, okay, yeah pnacl disallows syscall, int, etc unsafe. And this is done at the IR verifier level.
[19:36:36] <cmr> Yes
[19:36:46] <sbalmos> cmr: Maybe I'm really screwed up fundamentally. I didn't think LLVM IR had syscall support
[19:37:11] <cmr> sbalmos: it doesn't, but it has lots of things, and it's not portable
[19:37:16] <cmr> that's why pnacl had to be made in the first place
[19:37:20] <sbalmos> right
[19:38:18] <sbalmos> wait... hang on. Reading Google's FAQ. The verifier runs on the NaCl code, not the LLVM IR. O_O
[19:42:51] <sbalmos> cmr: Meh, first thing's first. Have to get the rustc middle end to emit pnacl. :)
[19:48:09] <kmc> sbalmos: yeah, I thought that was strange at first, but I'm convinced it's a good idea
[19:48:16] <kmc> if you already have native code NaCl working
[19:48:32] <kmc> this way you don't include all of LLVM in the trusted codebase
[19:49:32] <eddyb> why would middle::trans need to know about (P)NaCl?
[19:49:55] <eddyb> it can output LLV - oh, the verifier? ignore me
[19:49:55] <cmr> eddyb: trans emits IR. pnacl doesn't accept LLVM IR
[19:50:12] * eddyb goes back to his troubles
[19:57:56] <sbalmos> kmc: Well, the trusted base would have to at least have the platform-dependent part of the compiler.
[19:58:06] <sbalmos> kmc: That'd, in theory, have to be ported to Rust (eek!)
[20:01:54] <kmc> how do you figure?
[20:02:43] <kmc> i thought the way PNaCl works is, it compiles something LLVM-ish to native code, and then runs that through the original native-code NaCl verifier
[20:02:53] <kmc> so the trusted base is just the latter
[20:03:02] <kmc> i'm hardly knowledgable about PNaCl though...
[20:03:50] <sbalmos> kmc: Two parts - forked clang compiles to restricted subset of LLVM IR, which is the pnacl part that is distributed
[20:04:23] <sbalmos> kmc: Then there's a backend, a plugin version of the platform-specific part of LLVM, which runs inside Chrome and does the actual pnacl-to-nacl native compilation.
[20:04:56] <sbalmos> kmc: That LLVM platform-dependent backend would be running inside the theoretical RustOS, so it too would have to be written in Rust
[20:05:53] <kmc> but it's not part of the trusted base for ensuring the NaCl isolation properties, right?
[20:07:32] <sbalmos> actually, yes
[20:08:08] <sbalmos> In normal Chrome, the browser-based backend compiles to nacl, then runs the image in a normal nacl sandbox. That sandbox is what does the verification and isolation.
[20:08:31] <sbalmos> So, technically back to RustOS, either the backend or, in reality, the linker/loader, would do the verification.
[20:10:16] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[20:12:00] <kmc> what I'm saying is that you aren't trusting the LLVM-to-native translation to ensure memory safety
[20:12:35] <kmc> if there is a LLVM codegen bug that would break memory safety, the NaCl verifier catches it
[20:13:04] <sbalmos> In principle, correct. The verifier is, for all intents, outside of the compilation pipeline
[20:13:39] <sbalmos> Personally, I just don't know how Google does it right now, since all the verifier has is a plain-old machine binary image at that point. :D
[20:17:40] <kmc> well that's the problem NaCl solved before PNaCl existed
[20:17:57] <sbalmos> kmc: True. The rules are documented. http://www.chromium.org/nativeclient/design-documents/nacl-sfi-model-on-x86-64-systems
[20:18:41] <sbalmos> kmc: Just beyond my understanding at the moment how it's done. I guess the loader is literally reading the bitstream, reading opcodes directly
[20:19:00] <kmc> yeah, it disassembles the machine code and ensures that it fits this restricted form
[20:19:29] <kmc> so e.g. an indirect jump must be preceded by a particular instruction sequence (documented there under "nacljmp") which ensures that the jump target will be 32-byte aligned
[20:19:52] <sbalmos> kmc: Part of me would rather re-implement the verifier as a stage in the compiler pipeline, and store the final native image in a user-inaccessible filesystem cache.
[20:19:53] <kmc> and no instruction may span a 32-byte boundary
[20:20:11] <kmc> sbalmos: a stage before native-code generation, you mean?
[20:20:17] <sbalmos> kmc: As it is now, the nacl verifier runs on every load pre-execution. That would get nasty for any reasonly-large app
[20:20:20] <sbalmos> kmc: Ya
[20:20:26] <kmc> i mean, you can do that, but now you're talking about something completely different from NaCl
[20:21:03] <kmc> that's more like sandboxed Java or Safe Haskell
[20:21:10] <sbalmos> kmc: True. I was only ever referring to pnacl as an independent, "safe"(?) bytecode. NaCl was a whole other matter which I had no desire to implement
[20:21:37] <kmc> but PNaCl bytecode is not safe without NaCl
[20:22:28] <sbalmos> more generally, LLVM IR is not safe without a pre-native-compilation verifier
[20:22:41] <kmc> or a post-native-compilation verifier
[20:22:44] <kmc> which is how PNaCl works
[20:22:45] <strcat> kmc: anything is safe in userland with seccomp :P
[20:22:57] <sbalmos> kmc: Why waste compilation cycles if it's not safe? :P
[20:23:38] <kmc> ?
[20:23:56] <strcat> kmc: https://github.com/thestinger/rust-seccomp/blob/master/example.rs pragmatic security :P
[20:24:45] <sbalmos> o_O
[20:25:04] <strcat> seccomp == iptables for system calls
[20:25:10] <kmc> lol
[20:25:18] <strcat> (for real, it uses the berkeley packet filter infrastructure)
[20:25:37] * sbalmos table.insert(head)
[20:25:42] <kmc> bpf is something different from iptables, maybe there are iptables rules which use it though?
[20:26:09] <strcat> kmc: afaik it compiles them to it?
[20:26:12] * strcat shrugs
[20:26:36] <strcat> BPF in the context of the linux kernel means something else than actual BPF afaik
[20:27:14] <kmc> the BPF sense of "packet filter" is not firewalling but rather a way for individual userspace processes to specify which packets they are interested in receiving
[20:27:47] <strcat> kmc: yeah but they wrote a JIT compiler for it and afaik they reuse that infrastructure
[20:27:56] <kmc> for seccomp mode 2 yes
[20:28:10] <strcat> not for nftables/xtables or whatever it's called these days?
[20:28:34] <kmc> I don't think there would be any reason to use it for that
[20:28:59] <kmc> the point of the BPF VM is to let userspace upload little programs to run in the kernel without a context switch
[20:29:04] <kmc> iptables rules are already kernel code
[20:29:04] <strcat> ah
[20:30:11] <strcat> kmc: http://netfilter.org/projects/nftables/
[20:30:12] <kmc> but it sounds like nftables changes that
[20:30:20] <strcat> 'Pseudo-state machine in kernel-space: the userspace utility nftables interprets the rule-set provided by the user (using a new syntax), it compiles it into the pseudo-state machine bytecode and then it transfers it to the kernel via the nftables Netlink's API. Roughly, the idea behind nftables is similar to the Berkeley Packet Filters (BPF). '
[20:30:25] <strcat> yeah but I don't know if they reused code
[20:30:28] <strcat> I just assumed it
[20:31:42] <sbalmos> fun times
[20:31:54] <strcat> anyway linux is weird
[20:32:07] <strcat> I *still* haven't recompiled my kernel with CLONE_NEWUSER support
[20:32:32] * strcat should get on that
[20:32:40] <sbalmos> not heard of that one
[20:32:42] <strcat> rusti: "I want more security!"
[20:32:42] -rusti- "I want more security!"
[20:32:53] <strcat> sbalmos: do you know about namespaces? they are pretty darn cool
[20:33:09] <sbalmos> apparently not. :) Googling
[20:33:19] <strcat> sbalmos: are you on a fairly recent linux atm?
[20:33:32] <sbalmos> Running in a new OpenSUSE 13.1 VM currently
[20:34:07] <strcat> sbalmos: well, try running `unshare -f --mount-proc -p ps ax`
[20:34:10] <strcat> that's a PID namespace
[20:34:18] <strcat> the process lives in a world where there's a whole new process tree
[20:34:20] <strcat> it's PID 1
[20:34:28] <strcat> child processes simply inherit namespaces
[20:34:31] <sbalmos> oh WTF
[20:34:41] <strcat> there is also a mount namespace
[20:34:52] <strcat> but you can propagate changes between mount namespaces
[20:35:01] <strcat> if desired
[20:35:05] <strcat> there are network namespaces
[20:35:32] <sbalmos> argh. That could get interesting real work.
[20:35:40] <strcat> and the edge case ones (hostname/domainname, IPC) 
[20:35:47] <sbalmos> screw chroot
[20:35:55] <strcat> sbalmos: well it lets you do stuff like host an OS with the same kernel (container) inside a chroot
[20:36:02] <strcat> sbalmos: it's how the rusti bot here works :)
[20:36:11] <strcat> sbalmos: https://github.com/thestinger/playpen
[20:36:34] <strcat> anyway now there's CLONE_NEWUSER
[20:36:37] <strcat> it makes a new gid/uid namespace
[20:36:50] <strcat> and unlike the other namespaces, you don't need privs to create/enter one
[20:37:11] <strcat> it had a few security vulnerabilities because some stuff wasn't ported to the namespace stuff yet.
[20:37:24] <strcat> and with CLONE_NEWUSER you start off with uid/gid 0/0 :)
[20:37:40] <sbalmos> oh I'm sure that could create all kinds of nice hell
[20:37:53] <strcat> yeah but once you drop root privs inside the container it's strictly more secure
[20:39:39] <strcat> anyway Linux distros can enable USER_NS support now because XFS was finally updated to know about it
[20:39:48] <strcat> but they are scared to because of those issues :(
[20:40:04] <strcat> it looks like Fedora is going to (if they haven't already) enable it but *not* allow using it without privs
[20:40:04] <kmc> there have already been all kinds of security issues from allowing unprivileged namespaces
[20:40:08] <strcat> which is.... kind of 90% of the point
[20:40:10] <strcat> kmc: yeah
[20:40:12] <kmc> spender rants about this all the time
[20:40:20] <strcat> but it's cool! ;p
[20:40:23] <kmc> maybe eventually enough bugs will be worked out that it's no more buggy than the rest of the kernel ;P
[20:40:32] <strcat> chromium requires it for their linux sandbox
[20:40:56] <strcat> kmc: right, but the security issues are just the usual local root issues
[20:41:06] <strcat> I'm sure there are endless local root exploits if you can target the whole kernel surface area
[20:41:27] <strcat> in an actual sandbox where you're going to drop that 0/0 gid/uid *anyway*, it isn't less secure
[20:41:36] * strcat shrugs
[20:43:08] <strcat> kmc: I don't really understand why unpriv user ns can't just start you off as the same uid/gid you had before... but unrelated
[20:43:18] <kmc> what do you mean by "usual local root issues"
[20:43:47] <strcat> kmc: as in the kernel is an enormous surface area, and has local root exploits at a fairly regular pace, so private organizations are sure to have stockpiled some unpatched ones and it can be assumed to be insecure
[20:43:50] <sbalmos> strcat: Possibly because that could imply a leak of the global user ns into the new unpriv space?
[20:44:16] <sbalmos> Probably better if it was UID/GID 1 :P
[20:44:20] <strcat> (anyway I guess the point is that without gid/uid of 0, you can't enter other namespaces or anything)
[20:45:08] <strcat> kmc: I mean I definitely *would not* feel comfortable with rusti existing if it could access more than urandom and a relatively short list of reasonable system calls
[20:45:12] <strcat> I am still a bit paranoid about it
[20:45:15] <kmc> right
[20:45:16] <strcat> rust needs a lot of syscalls
[20:45:26] <kmc> but if that's your attitude then why do you care about namespaces anyway
[20:45:37] <kmc> a process inside a new namespace can still make all those hundreds of system calls
[20:45:47] <strcat> kmc: you can use both
[20:46:04] <strcat> rust issues tons of open calls, for example, so it can see a lot of the filesystem, and at least a PID ns is required
[20:46:11] <strcat> it looks in /proc
[20:46:28] <strcat> and evil dynamic linkers
[20:46:32] <strcat> they make 200000 syscalls :(
[20:46:42] <sbalmos> woo
[20:46:58] <strcat> oh look I'll access this file, stat it, mmap it, mprotect this, mprotect that, and so on
[20:48:02] <strcat> linkers are evil :(
[20:48:13] <strcat> you know that glibc only enables locking (for example, in stdio) when you link against libpthread.so?
[20:48:22] <kmc> wow
[20:48:31] <cmr> O_o
[20:48:32] <strcat> strace a hello world not compiled with -lpthread vs. compiled with it
[20:48:34] <sbalmos> o_o
[20:48:49] <kmc> that's evil
[20:48:52] <sbalmos> I'm sometimes not sure what's more evil, the Linux kernel itself, or glibc
[20:49:04] <kmc> they are partners in crime
[20:49:31] <sbalmos> kmc: Clearly glibc on Hurd would never commit such atrocities. :D
[20:49:35] <strcat> and yeah it doesn't set up a thread ID or TLS or anything without -lpthread
[20:49:36] <strcat> weird stuff.
[20:49:43] <sbalmos> (implicit insult)
[20:49:56] <strcat> I have close to no understanding about how dynamic linking can possibly work
[20:49:57] *** Quits: eddyb (eddy@336E3A7F.D51DAF03.FB866788.IP) (Ping timeout)
[20:50:00] <strcat> also the fact that it does weird lazy thunks
[20:50:03] <strcat> and binds stuff lazily
[20:50:09] <strcat> and relocates stuff for position independent code
[20:50:11] <strcat> blows my mind
[20:50:27] <strcat> debugging without good debug symbols is impossible
[20:50:31] <sbalmos> strcat: Oh that stuff is fun. Really twists my head when I read about Obc-J late binding
[20:50:36] <strcat> because 90% of the time, the dynamic linker is doing stuff
[20:50:44] <strcat> no, I want to debug my code, not the linker.
[20:50:46] * strcat sighs
[20:51:00] <cmr> yeah, modern linkers are pretty intense
[20:51:31] <kmc> well the point of PIC is that you mostly *don't* have to relocate it
[20:51:44] *** Joins: canhtak (canhtak@moz-6F820ACE.wl.t.ulaval.ca)
[20:51:51] <kmc> so you can share those pages even between processes that have it mapped at different places
[20:51:57] <strcat> kmc: ah right
[20:52:12] <kmc> by contrast Windows DLLs aren't PIC, they get relocated on load, and must be mapped at the same place in each process, or copied in memory
[20:52:24] <strcat> kmc: yeah this is why rust loads so slowly on windows
[20:52:31] <kmc> http://www.iecc.com/linker/ is a pretty cool book
[20:52:33] <strcat> afaik it's why we ended up with check-fast
[20:52:39] <cmr> ohh there's a book on linkers!
[20:52:41] <kmc> interesting
[20:52:49] * cmr has only read Ian Whateverhisnameis's blog about it
[20:52:57] <strcat> kmc: anyway I found out about the pthread thing trying to figure out why rust-core was slower than C
[20:53:15] <strcat> finally realized it's because linking against -lpthread makes I/O slower
[20:53:37] <strcat> seems pretty ridiculous to micro-optimize single-threaded cases like that...
[20:54:07] <strcat> oh well
[20:54:39] <sbalmos> switching topics... non-hierarchical filesystems :)
[20:56:26] <sbalmos> Found myself, a few years back, oddly intrigued by tagged-object "object pool filesystems", with relations between objects. Objects would be referred in the API by something kind of equivalent to an inode ID + version
[20:56:36] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Input/output error)
[20:57:12] <cmr> One of my friends started https://github.com/devyn/TPFS, which intrigued me at the time.
[20:58:12] <sbalmos> ya
[20:58:39] <sbalmos> Your "directory browsing" would basically be through searches. You could have persistent searches.
[21:00:09] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[21:01:21] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[21:01:26] <cmr> At an interface level, almost nobody interacts with trees directly either.
[21:01:52] <sbalmos> cmr: Agreed. Can't tell you how many symlinks I have in my trees because of things being categorized one way or another
[21:05:59] <sbalmos> cmr: Yet another different subject... "intelligent" command-line or text interface. Context-aware command and parameter completion, possibly a replay on the old Commander-like file navigation, Powershell-ish return data object introspection, etc.
[21:06:09] <sbalmos> Not everything is a file, and not everything is text. ;)
[21:06:16] <cmr> I've never looked into this seriously until you just brought it up. Just found http://c2.com/cgi/wiki?FileSystemAlternatives
[21:07:12] <sbalmos> cmr: I was heavily influenced by OS/400 and BeOS
[21:07:43] <cmr> sbalmos: http://inimino.org/~inimino/blog/shell_for_the_web
[21:07:50] <cmr> (Yet another of my acquaintences)
[21:08:08] <strcat> sbalmos: http://ipython.org/notebook.html
[21:08:11] <sbalmos> cmr: I used to know the guy who originally designed the Factor language. You should see its REPL
[21:10:51] <cmr> My problem currently is that while I know enough to be dangerous, I don't know enough to design good systems yet.
[21:11:59] <sbalmos> cmr: I've got enough time deisgning and integrating backend systems that I'm just reapplying those concepts to the OS level
[21:12:25] <sbalmos> cmr: The user realm, FS, CLI, etc are all just an amalgam of stuff I've experienced, read, desired, etc
[21:15:23] <sbalmos> cmr: The distributed stuff I'm heavily intrigued by Plan9. For that matter, making the GUI/input subsystem concurrently multi-user multi-input. Have multiple mouse and text cursors, etc in a single display session
[21:39:17] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[21:50:29] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Ping timeout)
[22:01:57] *** Joins: jstevans (Instantbir@moz-8DBF3BC4.washdc.fios.verizon.net)
[22:17:49] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[22:46:22] *** Quits: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP) (Client exited)
[23:04:26] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[23:07:25] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Ping timeout)
[23:46:03] *** Joins: sbalmos (quassel@CA5677B6.576D0C1.ED2EFC1B.IP)
[23:46:30] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[23:47:10] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)

[00:00:26] *** Quits: blaenk (blaenkdenum@moz-fsm6fc.n2pv.fsko.e000.2605.IP) (Ping timeout: 121 seconds)
[00:00:35] <GBGamer> anybody have any ideas where I could find someone who knows llvm
[00:00:37] <GBGamer> ?
[00:01:05] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Quit: Leaving.)
[00:01:21] <aatch> GBGamer, there is no umul or smul
[00:01:27] <aatch> there is just mul
[00:01:43] <GBGamer> aatch: one sec
[00:01:52] <aatch> http://llvm.org/docs/LangRef.html#mul-instruction
[00:02:19] <GBGamer> aatch: ah okay
[00:02:24] <aatch> There is signed/unsigned wrapping behaviour
[00:02:34] <GBGamer> smul and umul with overflow
[00:02:42] <GBGamer> those are different
[00:03:58] <GBGamer> thanks mcpherrin
[00:04:02] *** Joins: summerlight_ (summerlight@moz-99k.2mj.130.121.IP)
[00:04:24] <GBGamer> argh using two different windows in irssi is the worst
[00:05:09] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[00:08:32] <erickt> kwantam: ping
[00:09:14] <erickt> or SimonSapin: also-ping
[00:09:56] *** Quits: blaenk_ (blaenkdenum@moz-12e081.res.rr.com) (Ping timeout: 121 seconds)
[00:11:26] *** Joins: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP)
[00:16:33] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[00:18:02] <GBGamer> Does anyone have a good enough computer to compile rustc?
[00:18:25] <GBGamer> Because my little i3 with 4 gigs of ram, at least last time I tried, is not good enough
[00:18:43] <GBGamer> it fails to compile
[00:19:06] <GBGamer> Or, is there a good way to test compile rustc?
[00:19:13] <frewsxcv> i have a two year old macbook air that can compile it just fine
[00:19:22] <erickt> acrichto: also ping
[00:20:18] <GBGamer> hrrm, maybe I should just try again
[00:20:42] <GBGamer> wish me luck :)
[00:21:32] <aatch> I was able to on a 5-year old laptop that I ran into the ground.
[00:22:09] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[00:22:09] <GBGamer> perhaps it was just a fluke then
[00:22:24] <GBGamer> what's up with all the c++ files?
[00:23:05] <aatch> GBGamer, compiling LLVM?
[00:24:28] <GBGamer> oh, it compiles llvm?
[00:25:00] <aatch> GBGamer, yep
[00:25:12] <GBGamer> cool beans
[00:33:03] *** Quits: tamird (textual@moz-oii9i6.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[00:55:17] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[00:58:17] <GBGamer> dang, llvm takes a while to compile
[00:58:44] <GBGamer> (haha rhymes)
[01:01:37] *** Joins: anders (andars@moz-bsldst.sntcca.sbcglobal.net)
[01:03:52] *** Joins: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net)
[01:22:15] *** Joins: brson (brson@moz-h4f.m43.48.37.IP)
[01:22:16] *** ChanServ sets mode: +o brson
[01:25:52] <erickt> kwantam: thanks! is it possible to divorce fork status
[01:26:33] *** cMR is now known as cmr
[01:27:11] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[01:27:20] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[01:28:58] *** Quits: sprang (sprang@moz-d0kmvi.12d9.sm5v.0009.2601.IP) (Ping timeout: 121 seconds)
[01:31:20] *** Quits: chc4 (chc4@moz-pdo0at.ma.comcast.net) (Quit: AHHHHH BEES)
[01:37:29] <GBGamer> I figured out what was wrong
[01:38:15] <GBGamer> with my original compile
[01:38:57] <GBGamer> jemalloc does asm volatile (...)
[01:39:09] <GBGamer> instead of __asm__ __volatile__ (...)
[01:39:43] *** Joins: lfairy (lfairy@moz-7kfpdv.ihug.co.nz)
[01:40:09] <GBGamer> So my CFLAGS don't allow that
[01:43:44] <GBGamer> winding-lines: copy the impl out of std
[01:50:21] *** Quits: willem (willem@moz-facs2s.dynamic.upc.nl) (Quit: leaving)
[01:53:54] *** Quits: anders (andars@moz-bsldst.sntcca.sbcglobal.net) (Ping timeout: 121 seconds)
[01:57:35] *** Quits: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net) (Ping timeout: 121 seconds)
[02:04:06] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[02:04:46] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:05:46] *** Joins: nrc (nrc@moz-9v1svd.xtra.co.nz)
[02:05:47] *** ChanServ sets mode: +o nrc
[02:07:03] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[02:07:36] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[02:10:27] *** Quits: kimundi (kimundi@moz-jta.503.188.87.IP) (Ping timeout: 121 seconds)
[02:13:11] *** Joins: kimundi (kimundi@moz-7st4bq.dip0.t-ipconnect.de)
[02:15:55] *** kimundi is now known as zz_kimundi
[02:18:36] *** Quits: panitaliemom (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:20:27] <XMPPwocky> agh, can't manage to get rustc to build on this windows pc
[02:21:07] <XMPPwocky> trying to implement rfc#771 , murphy's law in full effect
[02:21:19] *** Quits: nrc (nrc@moz-9v1svd.xtra.co.nz) (Ping timeout: 121 seconds)
[02:22:32] <cmr> XMPPwocky: https://tools.ietf.org/html/rfc771 ? really?
[02:22:37] *** zz_kimundi is now known as kimundi
[02:28:29] * ChrisMorgan still doesn’t get why we don’t just impl IntoIterator for Option<T> instead of it having its own into_iter method, that would make once and empty just a little more superfluous
[02:29:17] <ChrisMorgan> *Sigh* Markdown…
[02:29:33] <GBGamer> holy cow
[02:29:49] <GBGamer> how long does it usually take for you guys to build the compiler?
[02:29:50] <ChrisMorgan> The first sentence of the detailed design section of that RFC: “`once` will return a new struct, `std::iter::Once<T>`, implementing Iterator<T>.” That <T> is an HTML tag in Markdown.
[02:30:40] <cmr> GBGamer: last I worked on it, only ~15 minutes for one stage.
[02:31:00] <cmr> the first time is the longest.
[02:31:06] *** Quits: kmcguire (kmcguire@moz-c955nf.res.rr.com) (Ping timeout: 121 seconds)
[02:31:07] <cmr> because llvm and some other assorted stuff.
[02:31:15] <aatch> Fortunately LLVM isn't rebuilt every time.
[02:32:01] <GBGamer> is it all rebuilt every time? or just the things that have changed
[02:32:21] <aatch> GBGamer, depends on what exactly you change.
[02:32:28] <GBGamer> So it uses make to the fullest, then?
[02:32:37] <XMPPwocky> it keeps running out of virtual address space for some reason
[02:32:59] *** Quits: brson (brson@moz-h4f.m43.48.37.IP) (Quit: leaving)
[02:33:03] <aatch> GBGamer, though there are some flags that allow you skip rebuilding some things.
[02:33:04] <GBGamer> hey, is librustdoc near the end?
[02:33:06] <ChrisMorgan> You can do things like `make -j8` which will speed some parts up.
[02:33:19] <GBGamer> because I'm hitting librustdoc right now
[02:33:31] <aatch> GBGamer, yeah, since nothing relies on librustdoc
[02:33:37] <GBGamer> hahaha yes!
[02:33:42] <GBGamer> so close
[02:33:59] <aatch> In fact, I don't think we even build rustdoc in stage1
[02:34:09] <GBGamer> building libcore
[02:34:11] <GBGamer> yesh
[02:34:29] <GBGamer> Yeah, I'm in stage 2 right now
[02:34:46] <GBGamer> so that probably means just all the libraries and then I'm done?
[02:35:15] <aatch> GBGamer, not sure.
[02:35:29] <GBGamer> ugh I just want to be done :P
[02:36:19] <aatch> GBGamer, no matter how much faster the compiler gets, the first time isn't likely to get that much faster.
[02:36:46] <aatch> There's a C++ project I've worked on that takes over half an hour for a full rebuild.
[02:37:06] <aatch> rustc is less slow, more... stupid.
[02:37:09] <GBGamer> oh god man
[02:37:16] <GBGamer> Big projects
[02:37:45] <GBGamer> 2 hours and 15 minutes so far
[02:38:14] <GBGamer> I can understand why tho
[02:38:24] *** Quits: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com) (Ping timeout: 121 seconds)
[02:38:49] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:39:15] <aatch> When we get incremental recompilation, most complaints about long build times will stop.
[02:39:37] <GBGamer> incremental recompilation?
[02:39:49] <GBGamer> Would you mind explaining that to me?
[02:40:53] *** Joins: nrc (nrc@moz-9v1svd.xtra.co.nz)
[02:40:53] *** ChanServ sets mode: +o nrc
[02:41:20] <aatch> GBGamer, well in C/C++ projects, you get .c -> .o, then .o -> <output>. When you change a .c file, only that file needs to be recompiled and the output relinked.
[02:41:49] <GBGamer> aatch: do we not do that?
[02:41:54] <aatch> GBGamer, header files throw a bit of a spanner in the works there, but the idea is mostly the same.
[02:42:08] <GBGamer> I do that in my projects
[02:42:13] <aatch> GBGamer, for the rustc build we do at the crate-level.
[02:42:19] <GBGamer> Just make every disparate file a crate
[02:42:33] <Mutabah> GBGamer: Harder than it sounds
[02:42:35] <GBGamer> It works really well for large projects
[02:42:47] <GBGamer> Well, I mean obviously not every file, but most files
[02:42:53] <GBGamer> It works really well with make
[02:43:03] <GBGamer> Not sure about cargo, tho
[02:43:10] <Mutabah> GBGamer: With C/C++ the headers provide the prototypes
[02:43:10] <aatch> GBGamer, sure, but's it not the best solution in the world.
[02:43:16] <Mutabah> and allow source files to be compiled separately
[02:43:27] <Mutabah> in rust, the prototypes are in the AST (with the code)
[02:43:39] <GBGamer> yeah, it could be easier
[02:43:49] <GBGamer> But it does work, just make every crate an rlib
[02:43:56] <Mutabah> Question - Could chunks of say borrowck be done in threads?
[02:44:02] <Mutabah> Move the paralellisim to rustc
[02:44:12] <GBGamer> that's what I'm doing with my kernel
[02:44:34] <aatch> Mutabah, sure, but the majority of the time spent in the compiler is in LLVM
[02:44:37] <huon> Mutabah: yes, but parallelising LLVM is a bigger gain
[02:44:47] <aatch> Mutabah, especially with optimisations.
[02:46:01] <aatch> A lot of what Rust does can be done on a per-function basis using a small number of shared datastructures.
[02:46:06] <GBGamer> Just a random thing: someone has (willingly) made an OS in BASIC
[02:46:18] <GBGamer> I felt like that was necessary to know
[02:46:27] *** Quits: nrc (nrc@moz-9v1svd.xtra.co.nz) (Connection closed)
[02:46:52] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[02:46:59] *** Joins: nrc (nrc@moz-9v1svd.xtra.co.nz)
[02:47:00] *** ChanServ sets mode: +o nrc
[02:48:04] *** Joins: c74d3 (c74d3a4ebb6@moz-67v3f5.mggc.hibn.4404.2002.IP)
[02:48:33] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[02:48:51] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[02:49:19] *** c74d3 is now known as c74d
[02:51:26] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[02:53:17] *** Quits: nrc (nrc@moz-9v1svd.xtra.co.nz) (Ping timeout: 121 seconds)
[02:54:22] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[03:00:22] *** Joins: marsel (user@moz-0fm.f56.180.94.IP)
[03:02:46] *** Quits: ytain (ytain@moz-ge9fgi.dsl.teksavvy.com) (Quit: Textual IRC Client: www.textualapp.com)
[03:03:14] <GBGamer> ooh, rust is now running rustdoc :)
[03:05:17] <GBGamer> HAHA YES IT IS COMPILED
[03:06:23] <frewsxcv> congrats!
[03:06:37] <GBGamer> now to test my additions
[03:09:01] *** Joins: genbattle (genbattle@moz-2qo6a1.xtra.co.nz)
[03:10:21] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:13:37] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[03:19:29] *** Quits: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP) (Connection closed)
[03:21:51] *** Joins: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP)
[03:23:45] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[03:24:06] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[03:24:44] *** Joins: p1start (p1start@moz-nftjhe.org)
[03:27:36] *** Joins: semarie (semarie@moz-l2n.lqk.61.185.IP)
[03:27:38] <GBGamer> arrrrrgh
[03:27:46] <GBGamer> how do I add intrinsics?
[03:28:10] <GBGamer> rustc is telling me that it can't find the intrinsics I just added to librustc_trans/trans/intrinsic.rs
[03:28:57] <cmr> you added it to that huge match in trans_intrinsic_call?
[03:29:03] <GBGamer> yeah I did
[03:29:28] <GBGamer> and I'm using the correct rustc
[03:30:04] <GBGamer> but libcore is saying: unrecognized intrinsic function: `i32_unchecked_div`
[03:30:09] <GBGamer> same for all of the rest
[03:30:46] <cmr> I'm going to guess that you did not add them behind a #[cfg(not(stage0))]
[03:30:59] <cmr> and so the bootstrap compiler is trying to use those intrinsics.
[03:30:59] <GBGamer> what? what would that matter?
[03:31:09] <cmr> and the bootstrap compiler doesn't know about those intrinsics yet.
[03:31:17] <GBGamer> but that's not what's complaining
[03:31:30] <GBGamer> what's complaining is my cross-compiled for i686 libcore
[03:33:18] <cmr> can you paste the build log?
[03:33:31] <cmr> without more precise information it's hard to guess at what the problem is
[03:34:01] <GBGamer> https://gist.github.com/GBGamer/1af7ac56efd8f8667a65
[03:34:23] <GBGamer> the compiler is held in https://github.com/GBGamer/rust
[03:35:07] *** Quits: jdm (jdm@moz-ilbt2e.cable.teksavvy.com) (Quit: )
[03:35:07] <cmr> the patch looks good. are you super sure you're using the right compiler?
[03:35:50] <GBGamer> yeah, I'm literally running it out of (target)/stage2/bin
[03:36:32] <GBGamer> and I'm compiling libcore from that same git
[03:39:55] *** Joins: anders (andars@moz-bsldst.sntcca.sbcglobal.net)
[03:41:33] *** Quits: Diggsey (diggsey@moz-o8tmhf.dsl.pipex.com) (Ping timeout: 121 seconds)
[03:41:43] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:45:41] *** Joins: kushal (kdas@moz-brdadn.103.sitibroadband.in)
[03:45:57] <GBGamer> I just restarted
[03:46:04] <GBGamer> (with NO_REBUILD)
[03:46:09] <GBGamer> see if that does anything?
[03:46:20] <cmr> I wouldn't expect it to.
[03:46:34] <GBGamer> neither would I, but I don't want to recompile rustc
[03:47:13] <GBGamer> I wish I didn't feel bad about kicking my brother off of League
[03:47:25] <GBGamer> then I could compile it on a reasonably fast computer
[03:54:35] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[03:55:42] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[03:56:52] *** Joins: mib_jbposx (Mibbit@moz-juv.9o3.252.72.IP)
[03:59:07] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Connection closed)
[03:59:35] *** Quits: kushal (kdas@moz-brdadn.103.sitibroadband.in) (Quit: Leaving)
[04:03:39] <GBGamer> It looks like the vast majority of compiler compiling time is spent compiling librustc
[04:04:41] *** Quits: Rusky (russell@moz-pob0l8.slkc.qwest.net) (Ping timeout: 121 seconds)
[04:04:42] <GBGamer> badum ching
[04:04:58] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[04:07:01] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[04:12:23] <Mutabah> Is there a way to emit LLVM IR in the same way as the asm! macro (I want to use the "va_arg" llvm 'instruction')
[04:13:38] <GBGamer> mutabah: nope
[04:13:46] <Mutabah> :(
[04:13:49] <GBGamer> Not without doing your own compiler plugin
[04:14:09] <GBGamer> I was asking earlier :P
[04:16:55] <richo> does thread::Builder *actually* let you set the writers for println! and panic! ?
[04:17:00] <richo> I can't spot anything that suggests it does
[04:17:53] *** Quits: Thorn (Thorn@moz-gfo.20c.107.217.IP) (Quit: Quit)
[04:19:21] <ebfull> richo: yes, they're hidden though
[04:19:44] *** Quits: mib_jbposx (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:19:52] <ebfull> richo: https://github.com/rust-lang/rust/issues/24099#issuecomment-89908401
[04:20:15] <ebfull> this isn't using builder but, you can do it
[04:20:49] <erickt> woohoo! Only one feature flag left for syntex! https://github.com/erickt/rust-syntex/blob/master/syntex_syntax/src/lib.rs#L23
[04:20:55] <richo> oho, right. In that case I still think https://github.com/rust-lang/rust/pull/24855 should be merged
[04:21:10] <richo> Sorry, to be clear I was asking about Builder, not "Is this possible"
[04:21:36] *** Joins: Rusky (russell@moz-pob0l8.slkc.qwest.net)
[04:22:19] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[04:22:36] <richo> once they're unhidden I'm happy to take actually adding the setters to builder though!
[04:22:42] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[04:25:20] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[04:25:27] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[04:28:00] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[04:29:36] *** Quits: Rusky (russell@moz-pob0l8.slkc.qwest.net) (Quit: Leaving.)
[04:30:56] *** Joins: Rusky (russell@moz-pob0l8.slkc.qwest.net)
[04:32:29] *** Quits: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP) (Ping timeout: 121 seconds)
[04:32:30] *** Quits: zxq9 (ceverett@moz-c1f1em.asahi-net.or.jp) (Quit: Konversation terminated!)
[04:34:01] *** Joins: nrc (nrc@moz-9v1svd.xtra.co.nz)
[04:34:01] *** ChanServ sets mode: +o nrc
[04:35:32] *** Joins: tamird (textual@moz-oii9i6.ca.comcast.net)
[04:36:17] *** Quits: nrc (nrc@moz-9v1svd.xtra.co.nz) (Quit: ChatZilla 0.9.91.1 [Firefox 40.0a1/20150401085108])
[04:46:28] *** Quits: marsel (user@moz-0fm.f56.180.94.IP) (Ping timeout: 121 seconds)
[04:48:10] <GBGamer> Please help, why aren't my intrinsics working :'(
[04:49:58] <Luqman> GBGamer: not working how so?
[04:51:10] <GBGamer> Luqman: I mean that they're not recognized
[04:51:19] <GBGamer> in extern "rust-intrinsic" blocks
[04:51:58] <GBGamer> I have added them to librustc_trans and everything :/
[04:52:07] <Luqman> did you add it in librustc_typeck/check/mod.rs (fn check_intrinsic_type) ?
[04:53:20] <GBGamer> I don't that's where I went wrong
[04:53:38] <GBGamer> it's unfortunate that there are two places you have to add compiler intrinsics :/
[04:53:48] <GBGamer> Now I know, I guess
[04:55:34] <Luqman> well, they serve different purposes :P
[04:55:47] <GBGamer> Yeah, I get why it is, just unfortunate
[05:01:56] <GBGamer> hopefully that works?
[05:02:41] *** Joins: zxq9 (ceverett@moz-c1f1em.asahi-net.or.jp)
[05:04:02] <Luqman> GBGamer: yep, just those two places you need to add to
[05:04:27] <GBGamer> Now I guess I just need to write an RFC?
[05:09:02] <GBGamer> IT BORKED!
[05:09:49] <GBGamer> hrmm interesting
[05:09:58] <GBGamer> It doesn't recompile everything
[05:10:03] <GBGamer> which is good, I guess?
[05:10:36] <GBGamer> what is, "libterm"?
[05:12:06] <GBGamer> hm, interesting
[05:13:33] *** Joins: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP)
[05:18:17] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[05:18:55] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[05:22:49] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[05:31:03] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[05:33:27] *** Quits: O01eg (o01eg@moz-i0qbdp.2u5i.3egh.2698.2a02.IP) (Client exited)
[05:34:23] *** Joins: c74d3 (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[05:35:27] *** Quits: c74d (c74d3a4ebb6@moz-67v3f5.mggc.hibn.4404.2002.IP) (Ping timeout: 121 seconds)
[05:35:47] *** c74d3 is now known as c74d
[05:37:02] *** Quits: tamird (textual@moz-oii9i6.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[05:38:58] *** Joins: genbattle_ (genbattle@moz-8e8gau.xtra.co.nz)
[05:39:44] *** Quits: genbattle (genbattle@moz-2qo6a1.xtra.co.nz) (Ping timeout: 121 seconds)
[05:42:08] *** Joins: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com)
[05:42:16] *** Joins: tamird (textual@moz-oii9i6.ca.comcast.net)
[05:48:28] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Client exited)
[05:48:45] *** Quits: genbattle_ (genbattle@moz-8e8gau.xtra.co.nz) (Ping timeout: 121 seconds)
[05:49:20] *** Quits: tamird (textual@moz-oii9i6.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[05:55:58] *** Quits: zxq9 (ceverett@moz-c1f1em.asahi-net.or.jp) (Ping timeout: 121 seconds)
[05:57:51] *** Joins: zxq9 (ceverett@moz-c1f1em.asahi-net.or.jp)
[06:01:02] *** Joins: squiddy (squiddy@moz-md4.pm3.19.178.IP)
[06:01:54] *** Joins: James (quassel@moz-9kp9p2.range86-148.btcentralplus.com)
[06:08:13] *** Joins: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP)
[06:09:09] *** Joins: ptalbot (ptalbot@moz-j4gnuh.fbx.proxad.net)
[06:12:24] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[06:12:53] <richo> did anything come of the discussion around the time it takes to build a debug-enabled compiler?
[06:13:24] <richo> I'm cross targeting, and building librustc has taken 15 mins so far..
[06:13:35] *** Joins: bugweiser (Mibbit@moz-juv.9o3.252.72.IP)
[06:13:43] <richo> (Cross targeting only relevant because it means I can't use snaps without spending some quality time with the build system)
[06:16:34] *** Quits: bugweiser (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:16:44] <Gankro> bstrie: reem: here's my piece on leakpocalypse: http://cglab.ca/~abeinges/blah/everyone-poops/
[06:16:58] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[06:19:48] *** Quits: squiddy (squiddy@moz-md4.pm3.19.178.IP) (Quit: Leaving)
[06:19:57] *** Joins: squiddy (squiddy@moz-md4.pm3.19.178.IP)
[06:22:49] *** Joins: c0170 (c0170@moz-bb29a4.cambridge.arm.com)
[06:25:08] *** Quits: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP) (Quit: Leaving.)
[06:27:30] *** Quits: ptalbot (ptalbot@moz-j4gnuh.fbx.proxad.net) (Ping timeout: 121 seconds)
[06:27:36] <lfairy> Gankro: I can get behind this
[06:32:53] *** Quits: squiddy (squiddy@moz-md4.pm3.19.178.IP) (Ping timeout: 121 seconds)
[06:33:04] *** Quits: Amaranth (travis@moz-1raqsl.cpe.cableone.net) (Ping timeout: 121 seconds)
[06:33:39] *** Joins: squiddy (squiddy@moz-md4.pm3.19.178.IP)
[06:34:00] <Manishearth> Gankro: finally what was the solution for scoped?
[06:34:10] <Manishearth> I got bored of following that thread
[06:35:32] <Mutabah> Manishearth: Still flowing iirc
[06:35:39] <Mutabah> Manishearth: But, afaik, scoped itself will use a closure
[06:35:54] <Mutabah> (... Maybe?... darnit)
[06:36:43] <Manishearth> whaddya mean a closure?
[06:36:47] <Manishearth> it already does that, no?
[06:37:02] <sfackler> the call that spawns the thread takes place inside of an outer closure
[06:37:10] <sfackler> which allows everything to be cleaned up propertly
[06:37:12] <sfackler> *properly
[06:37:26] *** Quits: James (quassel@moz-9kp9p2.range86-148.btcentralplus.com) (Ping timeout: 121 seconds)
[06:38:18] <Gankro> Mutabah: Yeah I think the winning solution for scoped is passing in a closure
[06:38:37] <Mutabah> Yeah
[06:38:52] <Manishearth> sfackler: cool
[06:38:56] <Mutabah> I kinda like the Leak trait, but it does present some implementation challenges
[06:39:00] <Manishearth> sfackler: wait, how?
[06:39:13] <Manishearth> oh you mean all the upvars should be within a closure
[06:39:27] <sfackler> https://github.com/aturon/rfcs/blob/scoped-take-2/text/0000-scoped-take-2.md#deferred-computation
[06:39:29] <Manishearth> and that closure is guaranteed not to run destructors
[06:39:34] <Manishearth> aha, thanks
[06:40:11] <Manishearth> ooh, fancy
[06:41:17] <GBGamer> agh fuck there are _three_ places you have to change to add an intrinsic
[06:41:26] <GBGamer> I need to, like, write a guide or something
[06:42:03] <Mutabah> GBGamer: Comments at the three sites?
[06:42:18] <GBGamer> ooh yeah that's good
[06:42:43] <GBGamer> I'll do that tomorrow, because I don't want to wait up for the compiler to finish compiling
[06:42:50] <GBGamer> it is sleep time for Nicholas
[06:42:54] <GBGamer> good night
[06:43:01] *** Quits: GBGamer (npm@moz-92sbjt.wa.comcast.net) (Quit: leaving)
[06:44:16] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:46:03] *** Joins: napolebn (Mibbit@moz-juv.9o3.252.72.IP)
[06:49:20] *** Quits: napolebn (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:58:33] *** Joins: sproul (Mibbit@moz-99ec4t.tpgi.com.au)
[07:01:23] *** Joins: genbattle (genbattle@moz-h2rr1j.xtra.co.nz)
[07:06:34] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[07:06:51] *** Quits: genbattle (genbattle@moz-h2rr1j.xtra.co.nz) (Ping timeout: 121 seconds)
[07:07:36] <Manishearth> It just occured to me  -- with all these plugins and type system magicks, Servo is effectively *teaching* Rustc about the SM GC
[07:07:40] <Manishearth> that is pretty enat
[07:07:42] <Manishearth> *neat
[07:08:00] <cmr> how's that smup going along? :)
[07:09:00] <Manishearth> no idea, mwu wa sworking on it last I heard
[07:09:37] <Manishearth> but with this Root-moving lint we're one step closer to safetyt for the smup
[07:09:48] <Manishearth> nox is shooting down some other issues we need to handle before the smup
[07:09:57] <Manishearth> cmr: btw, are temporaries *ever* moved?
[07:10:06] <cmr> Manishearth: what do you mean?
[07:10:10] <cmr> by temporaries
[07:10:11] <Manishearth> eg, if foo() returns some struct Foo {...}
[07:10:20] <Manishearth> and Foo is !Copy
[07:10:41] <Manishearth> Of the following, will any involve an in-memory move of Foo?
[07:11:06] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[07:11:15] <Manishearth> (s/will/can -- yesterdayAlex verified that the IR didn't move it for simple structs, but I'm not sure if that is the general case)
[07:11:20] <Manishearth>  - let x = foo();
[07:11:24] *** Joins: Skyler (Skyler@moz-rv949t.sd.cox.net)
[07:11:42] <Manishearth>  - let x = foo().bar(); bar() takes self by-value (by-move)
[07:11:52] <Manishearth> and bar(foo)
[07:12:19] <Manishearth> I made #[no_move] ignore rvalue moves, btut I might have to reevaluate that
[07:14:27] *** Joins: Amaranth (travis@moz-1raqsl.cpe.cableone.net)
[07:14:48] <sproul> if I want to make a syntax extension that expands to nothing, am I doing something horrendously wrong?
[07:15:20] <sproul> seems like I could impl MacResult and keep the default `None` return vals?
[07:15:32] <sproul> I want to dump diagnostic error metadata
[07:15:43] <sproul> but only once the whole crate has been compiled
[07:16:04] <sproul> (this is for librustc_{back, driver, typeck, etc})
[07:16:25] <cmr> sproul: seems fine.
[07:16:30] <cmr> Manishearth: I honestly don't know.
[07:16:34] <cmr> Manishearth: I *think* it can.
[07:17:00] <sproul> cmr: great, thanks! here goes!
[07:19:23] <Manishearth> cmr: any idea what sort of situation that would be?
[07:19:25] <Luqman> Manishearth: cmr smup?
[07:19:33] <cmr> Luqman: spidermonkey update for servo.
[07:19:41] <Manishearth> Luqman: smup = spidermonkey upgrade
[07:20:13] <Luqman> ah
[07:20:52] <Manishearth> sproul: a lint would be better, no?
[07:20:57] <Manishearth> to track diagnostic metadata?
[07:21:16] *** Joins: genbattle (genbattle@moz-h2rr1j.xtra.co.nz)
[07:21:30] <Manishearth> you only get an AST during expansion, but at lint time you get full resolve+typeck info
[07:21:37] *** Joins: kushal (kdas@moz-brdadn.103.sitibroadband.in)
[07:24:40] *** Joins: imperio (Mibbit@moz-opqtbe.abo.bbox.fr)
[07:26:12] <cmr> Manishearth: I'm not sure, the more I think about it the more I think it won't be possible, assuming our RVO is perfect.
[07:26:30] <Manishearth> cool
[07:27:06] <sproul> Manishearth: Err, at the moment I'm just doing use site and error description -> JSON files in tmp... didn't think of using a lint 'cause I don't really know how they work :P
[07:27:16] <Manishearth> ah okay
[07:27:27] <sproul> I'll look into it though
[07:27:46] <Manishearth> it might be hard getting a lint into the Rust build system without specifically making it part of libsyntax
[07:27:57] <Manishearth> though if you';re already using a plugin for expansion it shold be easy
[07:28:11] <sproul> yeah, I'm already running amok in libsyntax
[07:30:02] <Manishearth> cool
[07:30:04] <Manishearth> a lint is easy then
[07:30:17] <Manishearth> sproul: look at the lints guide
[07:30:26] <Manishearth> in the book
[07:30:27] <reem> Gankro: I’m still crestfallen about this whole deal because the new thread::scoped API is not nearly as nice or consistent, but with the lack of action as 1.0 gets closer and closer there’s almost no chance we’re going to do anything else. Part of me wants to be really upset that we’re doing this (imo) bad thing to the language for all eternity
[07:30:28] <reem> because someone picked May 15th, but I’m not the one who would get PR flak for derailing 1.0. I mostly just find all the non-1.0-related arguments against Leak pretty unconvincing, especially in the face of Reflect, but I’m feeling pretty defeated by now and I recognize that there’s almost no chance of Leak actually happening. This turned out a lot
[07:30:28] <reem> longer than I planned.
[07:31:08] <Manishearth> and know that middle::ty contains a lot of useful functions (esp. expr_ty) for messing with types
[07:31:14] <richo> reem: do you have a concrete alternate proposal?
[07:31:20] <reem> richo: Ya, the Leak RFC :P
[07:31:22] <reem> 1066
[07:31:25] <richo> not trying to sling mud or anything, just trying to gather state
[07:31:27] <richo> ah!
[07:31:54] <sproul> Manishearth: cheers :)
[07:31:59] <reem> there’s even an almost complete implementation (theme pointed out a flaw in my reasoning and I haven’t updated it yet)
[07:32:20] <reem> richo: I totally understand, I would ask the same question
[07:33:45] *** Quits: Amaranth (travis@moz-1raqsl.cpe.cableone.net) (Ping timeout: 121 seconds)
[07:34:11] <richo> thanks for understanding. Right now my horse is kiiiinda in the scope() side, but I'm totally biased
[07:34:21] *** Joins: munksgaard (munksgaard@moz-1i4.hq0.225.130.IP)
[07:34:33] <richo> (I'm trying to fix something I broke on ppc involving threads and holy crap is there a lot of plumbing between me and the bug :<)
[07:37:07] <Manishearth> reem: IMO we should have as many OIBITs as possible
[07:37:25] <reem> If we don’t have Leak, we really really shouldn’t have Reflect
[07:37:32] <Manishearth> exactly
[07:38:14] <reem> it has all the same problems and more, since you can’t even do Box<X + Reflect>
[07:38:29] <reem> (the Leak impl makes it a lang item so you can do Box<X + Leak>
[07:38:30] <reem> )
[07:39:40] <reem> Gankro: great blog post though; don’t let my moping detract :)
[07:41:32] <Manishearth> reem: I want to use a similar design for linear types later :)
[07:41:43] <Manishearth> unsafe impl Affine for .. {}
[07:41:55] <Manishearth> impl !Affine for whatevs
[07:42:05] <Manishearth> reem: .. impls get inherited, right?
[07:42:07] <reem> generics and trait objects specifically will ruin your day
[07:42:24] <Manishearth> reem: not necessarily
[07:42:35] <Manishearth> there are two ways to do this
[07:42:38] <Manishearth> either: 
[07:42:54] <Manishearth> by-default treat all type params as Affine
[07:43:02] <reem> ok sure
[07:43:08] <Manishearth> soryr, !Affine
[07:43:09] <reem> if you use the ?Sized thing it works
[07:43:13] <Manishearth> yeah
[07:43:20] <reem> which might actually be reasonable for Affine/Linear
[07:43:23] <Manishearth> but then you need to put a ?Affine bound everywhere
[07:43:24] *** Joins: ptalbot (ptalbot@moz-g2mokk.ircam.fr)
[07:43:37] <Manishearth> because a *lot* of APIs work fine with linear types
[07:43:37] <reem> Manishearth: not everywhere though, only places where you can actually guarantee linearness
[07:43:41] <Manishearth> so there are two solutions:
[07:43:53] <Manishearth>  - Use ?Affine on all APIs that allow linear types
[07:44:24] <Manishearth>  - use Affine on all APIs that *don't* allow linear types, and let Affine be impld by default elsewhere
[07:45:48] <reem> the thing is you can’t change the default
[07:45:54] <reem> so you can’t say <T> now means T is linear
[07:45:56] <cmr> I'm really not a fan of extending OIBITs, they seem fragile, unscalable, and impossible to reason about for actually proving properties about types when combined in any complex way.
[07:46:37] <reem> I sort of agree, they seem to be the frailest part of current rust, especially in combination with trait objects.
[07:47:16] <reem> note that impl for .. is not stable, so there is room to change them at least slightly
[07:47:35] <Manishearth> cmr: they could become solid in the future
[07:48:02] <Manishearth> linear types isn't somehting I want to work on in situ until post-1.0, probably much longer after that
[07:48:10] <Manishearth> for now, I'll just stick to humpty_dumpty
[07:48:14] <Manishearth> which is ... close enough
[07:48:45] <Manishearth> though I guess post-1.0 only the ?Affine solution would work
[07:49:03] *** Quits: sproul (Mibbit@moz-99ec4t.tpgi.com.au) (Quit: http://www.mibbit.com ajax IRC Client)
[07:49:07] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[07:49:18] <ChrisMorgan> Manishearth: remember, breaking changes are allowed in X.0.0 releases, though you’ll certainly have to justify them harder.
[07:49:50] <Manishearth> yep
[07:50:00] <Manishearth> linear types can't justify breaking changes
[07:50:51] <Manishearth> I don't think they will, anyway
[07:51:09] <Manishearth> unless Rust becomes the new haskell or something :p
[07:51:21] <Manishearth> then every type system under the sun would be possible :p
[07:52:52] *** Joins: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com)
[07:53:02] <Manishearth> reem: how much breakage would Leak cause?
[07:53:04] <reem> There’s always the opportunity to leverage a feature-like/language extension system to opt in to breaking changes in 1.X release
[07:53:14] <Manishearth> right
[07:53:29] <reem> Manishearth: turns out the changes in the compiler to add a Leak lang item are like twice as long as the breaking changes caused
[07:53:32] <reem> (in std + rustc)
[07:53:43] <reem> but std and rustc don
[07:53:51] <reem> don’t use very many trait objects
[07:53:54] <Manishearth> ah
[07:53:58] *** Joins: Amaranth (travis@moz-1raqsl.cpe.cableone.net)
[07:53:58] <Manishearth> what about ?Leak?
[07:54:08] <reem> Rc<RefCell<Box<Trait>>> will be the major cause of breakage
[07:54:11] <Manishearth> also, is ?Foo so,mething you can do with oibit, or is that only Sized?
[07:54:21] <Manishearth> oh right forgot that's common
[07:54:24] <reem> right now it’s only with ?Sized, because it’s sort of a ridiculous thing to do
[07:54:44] <reem> (add an implicit bound to every type parameter in the language)
[07:54:44] <Manishearth> reem: default !Leak bound on trait objects?
[07:54:56] <reem> The ?Leak solution doesn’t break.
[07:54:59] * Manishearth bonks trait objexts
[07:55:04] <reem> it could be introduced post-1.0
[07:55:13] <Manishearth> why can't you just compile time dispatch like everyone else
[07:55:22] <Manishearth> stupid vtables
[07:55:28] <reem> but at the cost of basically all generics requiring a ?Leak specification
[07:55:31] <reem> which would really suck
[07:55:38] <Amaranth> The ?Leak solution would be a breaking change in any API that added it, wouldn't it?
[07:55:38] <reem> s/specification/bound
[07:55:40] <Manishearth> yeah
[07:55:51] <Amaranth> As well as requiring everyone to sprinkle it around everywhere
[07:56:05] <reem> Amaranth: no, it accepts only strictly more types after you add the bound; the disadvantage is the necessity to sprinkle it everywhere
[07:56:28] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[07:56:50] *** Quits: Kxepal (Miranda@moz-pq39sj.pppoe.mtu-net.ru) (Ping timeout: 121 seconds)
[07:57:20] <reem> which imo is really too big of a price to pay for thread::scoped; introducing leak pre-1.0 would generate a little, fixable breakage for long term gain, introducing it post-1.0 gets you a nice feature (thread::scoped) at the cost of long term ?Leak bounds all over the place
[07:57:34] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[07:58:44] <reem> I’d rather deal with a backwards scoped API than get used to typing where Everything: ?Leak at the end of every function signature
[08:00:05] <Amaranth> Considering how much we built things on the idea that destructors will eventually run it seems sad to leave such a footgun in the language, regardless of scoped
[08:00:37] <ChrisMorgan> The whole issue is very sad‐making ☹
[08:00:43] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[08:00:50] <Amaranth> scoped is the only place in the stdlib where you end up violating memory safety but tomaka has hlua which has the same problem
[08:01:09] <Amaranth> And just because leaking a lock doesn't break memory safety doesn't mean that's something you ever want to have happen
[08:03:58] *** Quits: lfairy (lfairy@moz-7kfpdv.ihug.co.nz) (Connection closed)
[08:04:49] *** Joins: Thorn (Thorn@moz-gfo.20c.107.217.IP)
[08:05:08] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Client exited)
[08:05:15] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[08:07:20] *** Quits: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com) (Ping timeout: 121 seconds)
[08:07:26] *** Joins: laumann (thomas@moz-1f0.hq0.225.130.IP)
[08:10:10] *** Quits: kushal (kdas@moz-brdadn.103.sitibroadband.in) (Quit: Leaving)
[08:11:49] *** Joins: kushal (kdas@moz-brdadn.103.sitibroadband.in)
[08:14:51] *** Quits: summerlight_ (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[08:16:20] *** Joins: casey (casey@moz-v0ns05.tpgi.com.au)
[08:19:10] *** Joins: aepsil0n (eduard@moz-8h7njb.hsi8.kabel-badenwuerttemberg.de)
[08:20:28] *** Joins: cdidd_ (cdidd@moz-qa5fqk.broadband.corbina.ru)
[08:20:29] *** Quits: casey (casey@moz-v0ns05.tpgi.com.au) (Connection closed)
[08:20:51] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[08:21:00] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[08:23:19] *** Quits: cdidd__ (cdidd@moz-5107eh.broadband.corbina.ru) (Ping timeout: 121 seconds)
[08:28:51] *** Quits: kushal (kdas@moz-brdadn.103.sitibroadband.in) (Quit: Leaving)
[08:31:35] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[08:31:41] *** Quits: zxq9 (ceverett@moz-c1f1em.asahi-net.or.jp) (Quit: Konversation terminated!)
[08:31:45] *** Joins: erz (erz@moz-n2p94l.broadband.corbina.ru)
[08:36:03] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[08:36:05] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Connection closed)
[08:39:11] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[08:41:03] *** Joins: casey (casey@moz-v0ns05.tpgi.com.au)
[08:42:21] *** Quits: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[08:43:20] *** Joins: casey_ (casey@moz-v0ns05.tpgi.com.au)
[08:43:40] *** Quits: casey (casey@moz-v0ns05.tpgi.com.au) (Connection closed)
[08:48:28] *** casey_ is now known as casey
[08:49:00] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[08:51:10] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Connection closed)
[08:52:29] *** Joins: kushal (kdas@moz-brdadn.103.sitibroadband.in)
[08:54:52] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[08:56:14] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[08:59:26] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[09:00:26] *** Joins: genbattle_ (genbattle@moz-1s739j.xtra.co.nz)
[09:02:41] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[09:02:46] *** Quits: genbattle (genbattle@moz-h2rr1j.xtra.co.nz) (Ping timeout: 121 seconds)
[09:07:45] *** Joins: Tuba (Tobba@moz-6oh.7ki.21.217.IP)
[09:09:17] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:10:07] *** Quits: kushal (kdas@moz-brdadn.103.sitibroadband.in) (Quit: Leaving)
[09:11:42] *** Joins: summerlight_ (summerlight@moz-99k.2mj.130.121.IP)
[09:12:13] *** Joins: Tobba_ (Tobba@moz-6oh.7ki.21.217.IP)
[09:12:57] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[09:15:44] <cmr> 2.0 doesn't need to be in a forever, and the only breaking change could be, for example, changes to Rc (and removal of deprecated stuff)
[09:15:48] *** Quits: Tuba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:15:55] *** Joins: Tuba (Tobba@moz-6oh.7ki.21.217.IP)
[09:16:00] <cmr> it wouldn't be the end of the world if we fixed this in a year and released a 2.0
[09:16:17] *** Quits: Tobba_ (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:17:01] <simias> cmr: fragmenting the userbase is always risky business
[09:17:11] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:17:36] <aatch> It almost killed D
[09:18:23] <aatch> Though D1 -> D2 was a very large change.
[09:23:48] *** Joins: Tobba (Tobba@moz-65g.7ki.21.217.IP)
[09:25:19] *** Quits: Tuba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:28:28] *** Quits: Tobba (Tobba@moz-65g.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:30:24] *** Joins: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com)
[09:32:21] <richo> Hrm. (on a totally unsupported arch,) I'm getting an abort which looks to be a spurious free to an unallocated pointer, the backtrace shows it getting mad in the rt::unwind::try call in std::thread. Is there documeted wisdom in debugging this?
[09:32:49] <richo> for context, I've tried building a toy thing that just spawns a bunch of threads with my target compiler, which works fine. I'm trying to get a native rustc to go, but it explodes
[09:33:09] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[09:33:39] <aatch> richo, we may be making some incorrect assumptions about unwinding.
[09:34:01] *** Quits: summerlight_ (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[09:34:12] <richo> so, when you say unwinding, I guess that implies that something else went awry?
[09:34:30] <richo> what I'm driving at is while I'd totally buy that's where the invalid free call comes from, I'm not convinced it's actually the root cause
[09:35:03] <richo> eg, I would expect rustc to Just Work(tm). It works insofar as printing it's help text, but explodes horribly if I try to compile anything with it
[09:37:37] <aatch> richo, oh, actually, if it's in the try call, it might not be unwinding.
[09:41:20] <richo> well, it unwinds, and then explodes
[09:41:26] <richo> one sec, I'll just gist the backtrace
[09:42:54] <richo> aatch: https://gist.github.com/04322ed0af74adeb1606
[09:43:28] <richo> my read is that it definitely has a stab at unwinding, but I'm really unfamiliar with this part of the compiler
[09:43:38] <richo> it's definitely possible that I borked something when I did the port
[09:47:20] <aatch> richo, so I'm guessing it's the free of the exception itself in exception_cleanup.
[09:47:34] <aatch> richo, for now, you could try just leaking the exception object.
[09:48:22] <richo> oh interesting I'll have a look into that idea tomorrow
[09:48:32] <richo> it'll take several hours to rebuild :(
[09:48:39] <aatch> richo, fair enough.
[09:49:02] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[09:49:15] <richo> thanks for the idea hough, I've tried a few other things adn gotten no closer
[09:53:34] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[09:57:01] *** Joins: genbattle__ (genbattle@moz-dlitir.xtra.co.nz)
[09:59:04] *** Quits: genbattle_ (genbattle@moz-1s739j.xtra.co.nz) (Ping timeout: 121 seconds)
[10:04:08] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[10:04:09] *** ChanServ sets mode: +o pnkfelix
[10:05:59] *** Joins: kushal (kdas@moz-brdadn.103.sitibroadband.in)
[10:19:49] *** Joins: Tuba (Tobba@moz-65g.7ki.21.217.IP)
[10:22:49] *** Joins: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr)
[10:22:50] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[10:24:25] *** Quits: genbattle__ (genbattle@moz-dlitir.xtra.co.nz) (Ping timeout: 121 seconds)
[10:25:41] *** Tuba is now known as Tobba
[10:26:10] *** Quits: Tobba (Tobba@moz-65g.7ki.21.217.IP) (Quit: Leaving)
[10:26:13] *** Joins: Tobba (Tobba@moz-65g.7ki.21.217.IP)
[10:26:19] *** Quits: Tobba (Tobba@moz-65g.7ki.21.217.IP) (Connection closed)
[10:26:24] *** Joins: Tuba (Tobba@moz-65g.7ki.21.217.IP)
[10:26:46] *** Tuba is now known as Tobba
[10:43:09] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[10:47:43] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[11:04:50] *** Quits: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr) (Quit: )
[11:05:19] *** Quits: Kingsquee (kingsley@moz-qq7ns6.bchsia.telus.net) (Quit: Konversation terminated!)
[11:18:50] <doener> pnkfelix: ping
[11:18:57] <pnkfelix> doener: poing
[11:20:04] <doener> pnkfelix: a week or two ago, you had problems with the drop flag being in a bad state because of sizes for memcpys not being correct or something like that, right?
[11:20:44] <pnkfelix> doener: well, ... a week ago i think i was discussing a problem related to that with nrc
[11:21:00] <pnkfelix> doener: I'm actually having a problem with the drop flag today that could well be related to memcpy issues, not sure.
[11:21:08] <pnkfelix> doener: are you having problems?
[11:21:14] <doener> pnkfelix: I just commented on that issue (that's why I'm asking)
[11:21:23] <doener> gh24765
[11:21:23] <[o__o]> Inspect enum discriminant *after* calling its destructor: https://github.com/rust-lang/rust/pull/24765
[11:21:27] *** Joins: marsel (user@moz-nsf.g6r.180.94.IP)
[11:21:30] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[11:21:36] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[11:21:46] <pnkfelix> doener: oh interesting
[11:22:00] <doener> disabling lifetime intrinsics makes the problem go away, and I wondered if maybe the sizes used for them are wrong.
[11:22:23] <pnkfelix> doener: what is the way one disables lifetime intrinsics?  Can you link to the PR where they were added?
[11:22:23] <doener> though probably it's just a missing / misplaced intrinsic call
[11:23:20] <doener> pnkfelix: I modified call_lifetime_{start,end} to start with "if true || ..." so the calls just return. There's no option to disable them
[11:23:32] <pnkfelix> doener: ah i see
[11:23:58] <Luqman> doener: or possibly an llvm opt not handling lifetime intrinsics
[11:24:15] <doener> pnkfelix: there were a few PRs, incrementally adding more calls / fixing the existing ones
[11:24:23] <doener> Luqman: I don't think there is one
[11:29:28] <Yurume> pnkfelix: sorry for bothering, but would you continue to review gh24612 or not? I don't mind either, but I want to know if this is prioritized or not, and if some internal problem is hindering the review, I'm open to tweak the PR to ease the review.
[11:29:28] <[o__o]> New floating-to-decimal formatting routine: https://github.com/rust-lang/rust/pull/24612
[11:29:44] <pnkfelix> Yurume: I'm planning to continue reviewing it
[11:30:01] <pnkfelix> Yurume: I just haven't put it as high on my priority list since we decided not to cherry-pick it to beta
[11:30:06] <Yurume> aha.
[11:30:13] <pnkfelix> Yurume: but I do want to finish reviewing it, hopefully this week
[11:30:25] <Yurume> yeah, thank you! I can now stop holding my breath :)
[11:30:51] * Yurume was thinking about the possibility that the PR has some serious problem last weekend
[11:32:28] *** Quits: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au) (Ping timeout: 121 seconds)
[11:33:14] <pnkfelix> hmm. the fact that we do not emit the lifetime intrinsics when optimizations are off is a little troubling -- e.g. that makes it hard to try to duplicate the effects of optimizations by first compiling w/o optimizations to a .bc file
[11:33:28] <pnkfelix> (and then running the .bc file through llvm directly)
[11:34:02] <pnkfelix> (a technique i was unsuccessfully trying to employ when looking at gh24765 problem over the weekend)
[11:34:02] <[o__o]> Inspect enum discriminant *after* calling its destructor: https://github.com/rust-lang/rust/pull/24765
[11:34:20] *** Joins: ytain (ytain@moz-ge9fgi.dsl.teksavvy.com)
[11:36:27] *** Joins: Tuba (Tobba@moz-6oh.7ki.21.217.IP)
[11:37:19] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[11:38:55] *** Joins: Tobba_ (Tobba@moz-65g.7ki.21.217.IP)
[11:39:25] *** Quits: Tobba (Tobba@moz-65g.7ki.21.217.IP) (Ping timeout: 121 seconds)
[11:41:51] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[11:41:55] *** Quits: Tuba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[11:42:35] *** Joins: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr)
[11:44:45] *** Quits: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr) (Quit: )
[11:51:14] *** Joins: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au)
[11:51:15] *** Joins: willem (willem@moz-facs2s.dynamic.upc.nl)
[11:51:15] <pnkfelix> okay i see evidence that LLVM is deciding to remove the write of the drop-flag needed marker 0xd4, even though i emit code to check that the marker is either 0xd4 or 0x1d.  I do not yet know if this is due to the lifetime intrinsics
[11:53:32] <pnkfelix> does LLVM not include the calls to lifetime.start and lifetime.end in the output one gets for the LLVM IR? I do not see them there, at least...
[11:53:48] <pnkfelix> or wait, shoot
[11:54:08] <pnkfelix> (I was leaving out the `-O` flag in the rustc invocation to emit the IR)
[11:58:59] *** Joins: Rym (y@moz-rmaga4.range86-187.btcentralplus.com)
[11:59:46] *** Joins: Tobba (Tobba@moz-65g.7ki.21.217.IP)
[12:03:21] *** Quits: Tobba_ (Tobba@moz-65g.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:06:19] <pnkfelix> i wonder ... if the drop-flag initialization is coming before the call to lifetime.start ...
[12:12:50] *** kimundi is now known as zz_kimundi
[12:14:28] *** Quits: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[12:15:41] <pnkfelix> ah, cleanups are executed in reverse order from how they are pushed
[12:16:28] <pnkfelix> I wonder if that is a problem for this: https://github.com/rust-lang/rust/blob/master/src/librustc_trans/trans/_match.rs#L919
[12:17:35] <pnkfelix> (and I think many other places call `schedule_lifetime_end` first, before the drop call ... which is probably the correct thing)
[12:19:31] <pnkfelix> (actually we may have an invariant that every call to schedule_lifetime_end is immediately followed by some schedule_drop_xxx ;  an opportunity for refactoring there...)
[12:21:22] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[12:27:09] *** Joins: ChrisMorgan2 (ChrisMorgan@moz-g6osuq.tpgi.com.au)
[12:28:27] *** Quits: ChrisMorgan (ChrisMorgan@moz-g6osuq.tpgi.com.au) (NickServ (RECOVER command used by ChrisMorgan2))
[12:28:27] *** ChrisMorgan2 is now known as ChrisMorgan
[12:31:21] *** Quits: Tobba (Tobba@moz-65g.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:35:16] *** Joins: Tobba (Tobba@moz-65g.7ki.21.217.IP)
[12:36:59] *** Quits: Rym (y@moz-rmaga4.range86-187.btcentralplus.com) (Ping timeout: 121 seconds)
[12:39:14] *** Joins: srh (User@moz-4eo.olj.134.64.IP)
[12:42:04] *** Quits: Tobba (Tobba@moz-65g.7ki.21.217.IP) (Ping timeout: 121 seconds)
[12:43:44] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[12:45:43] <doener> pnkfelix: oh, yeah, that's definitely wrong
[12:48:38] *** Joins: awrush (awrush@moz-15s7c4.udtd.gaqb.04f8.2a01.IP)
[12:50:12] <pnkfelix> fixing that doesn't fix my problem unfortunately.  well I'll keep looking
[12:55:56] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.5.1)
[12:56:13] *** Joins: jdm (jdm@moz-ilbt2e.cable.teksavvy.com)
[12:59:24] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[13:05:27] *** Joins: bdero (bran@moz-mqs.7dh.189.18.IP)
[13:07:06] *** Joins: Diggsey (diggsey@moz-o8tmhf.dsl.pipex.com)
[13:17:44] *** Quits: anders (andars@moz-bsldst.sntcca.sbcglobal.net) (Ping timeout: 121 seconds)
[13:26:09] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[13:32:31] *** Joins: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP)
[13:32:31] *** ChanServ sets mode: +o pnkfelix
[13:35:07] <doener> pnkfelix: found it :-)
[13:35:37] <pnkfelix> doener: ah okay, I should have checked to see if you had updated the ticket
[13:35:53] <doener> only updated it a minute ago
[13:35:54] *** Quits: laumann (thomas@moz-1f0.hq0.225.130.IP) (Quit: leaving)
[13:38:35] <pnkfelix> doener: so, I admit I'm confused by this semantics
[13:39:52] <doener> pnkfelix: which?
[13:40:02] <pnkfelix> doener: oh wait, I'm re-reading the code and your comment
[13:40:33] <pnkfelix> doener: I thought you were saying that trans_drop_flag_ptr was doing the write-initialization of the drop flag
[13:40:37] <doener> https://gist.github.com/dotdash/b5d8aad185a5d85fb818 -- diff for the version I built that succeeded
[13:40:45] <pnkfelix> doener: but I am now thinking that I must have misinterpreted that
[13:41:15] <doener> it copies the drop flag to a stack slot, and uses the wrong datum type
[13:42:06] <pnkfelix> sort of amazing that this does not cause more problems...
[13:42:22] <doener> pnkfelix: the change in _match.rs is not required for your test cases to succeed, only the one in trans_drop_flag_ptr
[13:42:58] <doener> pnkfelix: I'm pretty sure this is the reason why my attempts at gh23657 failed
[13:44:00] <pnkfelix> doener: okay I'll try incorporating it, thanks for tracking this down.
[13:45:23] <pnkfelix> doener: but I'm still confused: in code like `Datum::new(ptr, ptr_ty, Rvalue::new(..)).store_to(..)`
[13:45:23] <pnkfelix> doener: is that just always wrong in general?
[13:45:33] <pnkfelix> doener: (because the Rvalue's lifetime won't be long enough, that is?)
[13:47:10] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[13:48:20] <[o__o]> Try not to copy outgoing arguments: https://github.com/rust-lang/rust/issues/23657
[13:49:43] <doener> pnkfelix: as I understood it, Rvalue datums are used only for things that move, i.e. the backing stack slot is dead after that `store_to`. But here, the drop_flag is just copied, not moved. AIUI this code should use an Lvalue datum. Rvalue datum + shallow_copy (instead of store_to) would also work, but since the drop_flag is in its "final home", Lvalue seems to be the correct choice.
[13:51:22] <doener> I think there are a few places where introducing an Rvalue datum like that is correct, like in some intrinsics, but here, it is wrong.
[13:52:23] <pnkfelix> doener: okay. Anyway I agree that the change you suggest seems like a strict improvement.
[13:54:02] <Manishearth> ohai pnkfelix. do "moved" rvalues ever really get moved?
[13:54:11] <Manishearth> eg if foo() returns a !Copy struct Foo
[13:54:14] <Manishearth> would:
[13:54:18] <Manishearth>  - let x = foo();
[13:54:24] <Manishearth>  - foo.bar();
[13:54:34] <Manishearth>  - bar(foo)
[13:54:38] <Manishearth> where bar takes by-move
[13:54:49] *** Quits: jgallagher (john@moz-6ge.dhn.131.24.IP) (Client exited)
[13:54:54] <Manishearth> would any of those cause an in-memory move of the returnvalue of foo()?
[13:55:11] <pnkfelix> Manishearth: they really get moved when their drop-flag is cleared without invoking the dtor
[13:55:43] <Manishearth> uhwha
[13:55:53] <pnkfelix> Manishearth: the question of whether one can observe changes to the in-memory representation is largely dependent on LLVM optimizations, I imagine
[13:56:05] <Manishearth> hmph
[13:56:30] <Manishearth> for simple structs alex and .. I think simukis .. verified yesterday that there is no inmemory move
[13:56:35] <Manishearth> but I'm not sure if that is the general case
[13:57:31] <pnkfelix> Manishearth: let me see if I can whip something up
[13:57:35] <Manishearth> thx
[13:57:52] <Manishearth> (context: https://github.com/Manishearth/rust-tenacious/, we need it for Servo because yay spidermonkey)
[13:59:04] <pnkfelix> Manishearth: you need to force an in-memory move?  Or you need to ensure no such move occurs?
[13:59:15] *** Joins: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com)
[13:59:33] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[13:59:57] <Manishearth> pnkfelix: ensure it never happens
[14:00:07] <Manishearth> for certain structs, and anything containing such a struct
[14:02:58] *** Quits: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net) (Ping timeout: 121 seconds)
[14:03:00] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[14:03:18] *** Quits: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com) (Ping timeout: 121 seconds)
[14:04:38] <pnkfelix> Manishearth: so consider a case like this: http://is.gd/r3Y75l
[14:05:11] <pnkfelix> Manishearth: you gave "simple examples" before; I am not clear whether you are okay with conditionalized cases like the one shown here.
[14:05:27] <pnkfelix> Manishearth: but the point of this example is to illustrate a case where an in-memory move cannot be avoided, I think.
[14:06:23] <pnkfelix> Manishearth: but maybe you are not including return-value-optimization in your worries?
[14:06:27] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Connection closed)
[14:06:44] *** Joins: summerlight_ (summerlight@moz-99k.2mj.130.121.IP)
[14:07:23] *** Quits: squiddy (squiddy@moz-md4.pm3.19.178.IP) (Quit: Leaving)
[14:08:05] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[14:09:13] <Manishearth> pnkfelix: those aren't rvalues being moved
[14:09:44] <pnkfelix> Manishearth: pretty sure this is the first time you said "rvalue"
[14:09:58] <Manishearth> 19:24 < Manishearth> ohai pnkfelix. do "moved" rvalues ever really get moved?
[14:09:59] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[14:10:02] <Manishearth> :)
[14:10:03] <pnkfelix> doh
[14:10:35] <pnkfelix> Manishearth: well, then, I don't have an answer for you.
[14:10:57] <Manishearth> I'm doing https://github.com/Manishearth/rust-tenacious/blob/master/src/lib.rs#L80 in tenacious, but I'm not sure if that will always work
[14:11:00] <pnkfelix> Manishearth: seems like one would need to audit trans to determine if its true.
[14:11:02] <Manishearth> pnkfelix: kay, thanks :)
[14:11:07] <Manishearth> bah humbug
[14:11:10] <Manishearth> that's what alex said
[14:11:25] <Manishearth> I don't *want* to audit trans
[14:12:11] <imperio> acrichto: on the RFC "Expand the scope of `std::fs`", on more precisely on this method: https://github.com/rust-lang/rfcs/pull/1044/files#diff-13b67af115a7cbb26e4874e1aa6da617R516, is it good to name it file_name ?
[14:12:28] <imperio> entry_name would seem more accurate, no ?
[14:12:48] <imperio> (I commented it just now since I just saw it)
[14:20:27] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[14:21:20] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[14:21:31] <SimonSapin> What happens when C code calls Rust code which panics?
[14:21:48] <steveklabnik> undefined to unwind through FFI
[14:22:04] <steveklabnik> you gotta std::rt::try or whatever it's called, if your rust may panic
[14:22:15] <steveklabnik> http://doc.rust-lang.org/nightly/std/rt/unwind/fn.try.html
[14:22:20] <SimonSapin> sounds like http://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html becomes much less useful
[14:22:41] * steveklabnik shrugs
[14:22:55] <imperio> SimonSapin: that's interesting that you ask since nical proposed to make the panic! segfault
[14:23:57] <imperio> I think it would solve your question
[14:24:41] <SimonSapin> Yes, removing unwinding (abort the process instead) is a long-standing but controversial request
[14:25:18] <imperio> I guess it's because, now, it's still possible to prevent the panic! ?
[14:25:29] <steveklabnik> well
[14:25:31] <imperio> (I mean from the user side)
[14:25:35] <steveklabnik> in that case, it _also_ takes down your Ruby process
[14:25:50] <steveklabnik> our current system, rust can panic, and you'd don't kill everything elese
[14:25:53] <steveklabnik> else
[14:26:32] <SimonSapin> But std has many things can potentially panic (Index for [T], Option::unwrap, …), so just saying "don’t do that when calling from C" isn’t particularly helpful
[14:26:44] <imperio> steveklabnik: you're talking to SimonSapin (just to be sure) ?
[14:27:05] <steveklabnik> both of you, really.
[14:27:41] <steveklabnik> SimonSapin: sure, to write bulletproof code you need to use a lot of try
[14:28:14] <SimonSapin> I don’t really have an opinion on abort-on-panic, but the status-quo doesn’t sound good either
[14:28:35] *** Joins: jgallagher (john@moz-d5e8oc.hfc.comcastbusiness.net)
[14:29:08] <imperio> steveklabnik: Then I don't get it, why rust panicking would kill the ruby process ? You're talking about a rust process _inside_ a ruby's, right ?
[14:31:26] <Manishearth> bluss: http://internals.rust-lang.org/t/all-types-are-equal-but-some-are-more-equal-than-others/1970
[14:31:36] <imperio> SimonSapin: for now, majority of rust project does exit when panicking. An abort-on-panic wouldn't change much and would put an end to this debate, no ?
[14:32:12] <steveklabnik> imperio: if panic == abort, and we're calling from ruby -> rust over ffi, then a rust panic = aborted ruby process
[14:32:49] <bluss> Manishearth: thanks. Full support would mean conflicts in two places: structs/enums and type parameters on functions/methods
[14:32:49] <SimonSapin> imperio: the argument against is that, even though it’s not the default, you can write more robust code that recovers on panic
[14:32:56] <bluss> Manishearth: the compiler can't tell those apart
[14:33:03] <imperio> steveklabnik: okay, I thought you were talking about a ruby program calling a rust program, not a rust function
[14:33:35] <steveklabnik> yeah, if it just shells out or something, no biggie
[14:33:56] <imperio> SimonSapin: then it means that a panic is not-well employed no ? A panic is supposed to mean "uncoverable error", am I wrong ?
[14:34:12] <SimonSapin> I don’t know
[14:34:25] <imperio> hum...
[14:34:40] <steveklabnik> it may mean 'unrecoverable error' in a purely-rust context
[14:34:57] <imperio> it would make the rust language questions the panic meaning I guess
[14:34:57] <steveklabnik> but when rust is part of a larger system, what makes the rust unrecover-able doesn't mean the system can't recover overall
[14:35:58] <Manishearth> steveklabnik: unrecoverable in a thread sense
[14:36:05] <steveklabnik> right
[14:36:34] <Manishearth> though *usually* a panic in a thread causes panics in other threads due to our good friend recv().unwrap()
[14:36:36] <imperio> steveklabnik: then, if you know a function might fail, why not launching it in context that _could ne_ recoverable ?
[14:37:30] <steveklabnik> that's what unwind::try does
[14:37:31] <Manishearth> if a function might fail, then simply do
[14:38:17] <Manishearth> thread::spawn(|| tx.send(f())); match rx.recv() {Ok(x) => return x; Err() => handle error neatly}
[14:38:49] *** Joins: mib_m0724f (Mibbit@moz-juv.9o3.252.72.IP)
[14:39:21] *** Joins: tamird (textual@moz-li31k6.ca.comcast.net)
[14:41:37] <SimonSapin> Manishearth: My point is that most code should never panic unless it’s buggy (we favor returning a Result), but bugs do happen. And avoiding scary undefined behavior when bugs happen is what Rust is about, to me.
[14:42:05] <Manishearth> yeah, so when doing FFI either do it in a separate thread, or write code that will never panic
[14:42:10] <imperio> SimonSapin: and in that very case, rust panic
[14:42:29] <imperio> I don't see the real problem here, I think I might miss something
[14:42:36] *** Joins: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net)
[14:42:41] <Tobba> SimonSapin: * or code that uses basic arithmetic
[14:42:47] <Manishearth> Rust gives you the easy way out via unwrap() and panic() and whatnot, but generally you should handle errors yourself
[14:43:00] <SimonSapin> Manishearth: writing Rust code that never panics is like writing C code that never has undefined behavior. You can try very hard, but never be sure.
[14:43:24] <SimonSapin> Manishearth: "Don’t do that" is not a satisfying answer
[14:43:58] <Manishearth> hm
[14:44:00] <imperio> SimonSapin: writing C code that never has undefined behavior is impossible you say ? O.o
[14:44:13] <imperio> my whole life was a lie then... :'(
[14:44:19] <Tobba> writing C is undefined behaviour.
[14:44:25] <SimonSapin> imperio: not impossible, just very hard
[14:45:02] <imperio> SimonSapin: once again, I don't agree. If you keep a good overview of what you're writting, it's not _that_ hard
[14:45:43] <SimonSapin> imperio: You have to follow subtle rules and never make a mistake, ever.
[14:45:44] <Tobba> imperio: if you're saying you've written C that doesn't involve any undefined behaviour you're probably wrong
[14:46:02] *** Quits: Diggsey (diggsey@moz-o8tmhf.dsl.pipex.com) (Ping timeout: 121 seconds)
[14:46:02] <Tobba> well, a big chunk of C, anyways
[14:46:12] <SimonSapin> imperio: then how come web browsers have so many memory-safety-related security issues all the time?
[14:46:36] *** Joins: Diggsey (diggsey@moz-o8tmhf.dsl.pipex.com)
[14:47:10] <imperio> Tobba: I've written in C languages more than any other languages. I really didn't see undefined behavior that much (except in concurrent programming, that's the most current issue)
[14:47:32] <SimonSapin> If it wasn’t "not that hard", shouldn’t code review have caught all these bugs?
[14:47:44] <SimonSapin> If it was* "not that hard"
[14:47:56] <imperio> SimonSapin: I think that's because the code just became too big and it becomes *nearly* impossible to see from where the probleme comes, I agree...
[14:47:59] <Tobba> imperio: I think you're simply not aware of the undefined behaviour, even though it exists
[14:48:09] <SimonSapin> imperio: My point exactly
[14:48:27] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[14:48:28] <imperio> SimonSapin: I didn't think of that, well see
[14:48:52] *** Quits: tamird (textual@moz-li31k6.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[14:49:10] <SimonSapin> Sure, if you have 10 lines of Rust you can look at it very carefully and be confident it never panics. But as the code becomes bigger and less trivial, that becomes much hard.
[14:49:37] <Tobba> especially as every single arithmetic operation can panic
[14:49:42] <imperio> no no, I was thinking of a software with thousand of lines, not millions
[14:50:01] <Tobba> (guess who wasn't a fan of that decision)
[14:50:10] <imperio> Tobba: just to be sure, could you give me some undefined behavior please ?
[14:50:16] <imperio> +example
[14:51:15] <Tobba> oh lets see
[14:51:16] *** Quits: srh (User@moz-4eo.olj.134.64.IP) (Ping timeout: 121 seconds)
[14:51:23] <Tobba> division by zero actually counts as UB, which is scary
[14:51:34] <Tobba> but most compilers deal with that sanely so you'll never notice it
[14:52:11] *** Quits: Jesin (Jesin@moz-t88s6v.cc.lehigh.edu) (Ping timeout: 121 seconds)
[14:54:01] <Tobba> out of bounds shifts
[14:54:13] <Tobba> and most memory bugs pretty strictly invoke UB
[14:54:45] <imperio> Tobba: I don't think that's a good example. It's a good habit to _always_ check before doing a division (I took the habit after I had a SIGFPE for the nth time)
[14:55:07] <bluss> Tobba: I love this example  int add_one(int x) { return x + 1 }  // potential UB
[14:55:09] <imperio> Tobba: however, memory undefined behavior is a very good example =D
[14:55:13] <bluss> forgot ;
[14:55:24] <Tobba> bluss: hah
[14:55:35] <Tobba> yeah I couldn't think of any fun hidden UB
[14:55:39] <imperio> bluss: that's a great example haha
[14:55:50] <Tobba> my personal favorite is int foo() { }
[14:55:57] <Tobba> but that actually triggers a warning on any sane compiler
[14:55:58] <imperio> let's just use char* to make mathematic operations ! =D
[14:56:25] <bluss> Tobba: nice, I don't think x + 1 triggers a warning :)
[14:56:34] <Tobba> heh
[14:56:42] <Tobba> those bugs get REALLY fun if you don't get the warning though
[14:56:58] <Tobba> in clang it'll leave out the return instructions and fall over into whatever function is next
[14:57:12] <Tobba> debug that motherfucker
[14:57:32] * Zoxc debugs that motherfucker
[14:57:43] <Tobba> dang
[14:58:24] *** Joins: npm (npm@moz-92sbjt.wa.comcast.net)
[14:58:29] *** npm is now known as GBGamer
[14:59:03] <frewsxcv> http://www.rust-lang.org/conduct.html
[15:00:42] <GBGamer> does anyone know where the llvm translation is for arithmetic operators
[15:00:47] <GBGamer> ?
[15:01:04] <imperio> frewsxcv: why are giving the conduct code ? (didn't see anything outrageous yet...)
[15:01:08] <GBGamer> (like librustc_trans/trans/intrinsic.rs for arithmetic operators)
[15:02:25] <frewsxcv> imperio: the latest messages by Tobba and Zoxc 
[15:02:50] <imperio> oh right, didn't even pay attention... I'm getting old
[15:04:33] *** Quits: c0170 (c0170@moz-bb29a4.cambridge.arm.com) (Ping timeout: 121 seconds)
[15:05:22] *** Quits: imperio (Mibbit@moz-opqtbe.abo.bbox.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[15:06:37] *** Joins: eibwen (eibwen@moz-33cegi.dip0.t-ipconnect.de)
[15:07:53] <kmc> what, we can't say "motherfucker" now?
[15:08:05] <GBGamer> just not to anyone else
[15:08:17] <kmc> well you can't *call* someone a motherfucker
[15:08:23] <GBGamer> yeah
[15:08:30] <GBGamer> you can just say it tho
[15:08:30] <kmc> which I don't think happened above?
[15:08:38] <GBGamer> I don't know, I can't read it :P
[15:09:49] <Luqman> GBGamer: librustc_trans/trans/expr.rs
[15:10:13] <GBGamer> Luqman: thanks :)
[15:10:22] <GBGamer> I ended up just using grep
[15:10:41] <GBGamer> I came into this channel at a bad time :/
[15:10:50] <Manishearth> kmc: I'd still prefer we didn't though :)
[15:10:56] <kmc> okay
[15:11:03] <kmc> but the CoC is not meant to cover all behavior that someone might object to
[15:11:08] <Manishearth> It's not against the CoC, correct
[15:11:13] <kmc> that directly conflicts with the goal of it being something we all agree on and enforce
[15:11:16] <kmc> okay
[15:11:41] <Manishearth> oh also, since you're here, r?https://github.com/servo/servo/pull/5855
[15:11:56] <Manishearth> needs a review of https://github.com/Manishearth/rust-tenacious/
[15:12:02] <Manishearth> (pretty small library)
[15:12:06] <kmc> yeah, i'm going to look later
[15:12:15] <Manishearth> yay
[15:13:25] <Manishearth> Gankro: well played
[15:15:01] <Gankro> Manishearth: I don't know what you could *possibly* be referring to ;)
[15:15:07] <Manishearth> lol
[15:26:38] *** Quits: mib_m0724f (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:27:55] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Client exited)
[15:31:30] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[15:33:51] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[15:36:04] *** Joins: O01eg (o01eg@moz-vo3hvq.pku3.4n8f.2698.2a02.IP)
[15:37:50] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[15:38:19] *** Joins: c0170 (c0170@moz-4stj9o.cable.virginm.net)
[15:43:50] *** Joins: Nosprawls (Mibbit@moz-74t0cs.virginmediabusiness.co.uk)
[15:45:15] *** Joins: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net)
[15:48:34] *** Joins: c0170_ (c0170@moz-4stj9o.cable.virginm.net)
[15:50:12] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[15:50:38] *** Quits: c0170 (c0170@moz-4stj9o.cable.virginm.net) (Ping timeout: 121 seconds)
[15:52:14] *** Quits: GBGamer (npm@moz-92sbjt.wa.comcast.net) (Ping timeout: 121 seconds)
[15:54:01] <erickt> acrichto / burntsushi / sfackler / everyone-who-cares: syntex now compiles on beta 3!
[15:54:20] <erickt> now to actually get it to work on non-toy macro and syntax extensions!
[15:54:22] *** Quits: casey (casey@moz-v0ns05.tpgi.com.au) (Connection closed)
[15:55:01] <aturon> erickt: \o/
[15:57:31] <Yurume> oh, wow!
[15:57:48] <erickt> first question is now how am I going to handle codegen-ing the tests in https://github.com/erickt/rust-quasi...
[15:58:33] *** Quits: marsel (user@moz-nsf.g6r.180.94.IP) (Ping timeout: 121 seconds)
[16:05:45] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[16:06:16] *** Quits: c0170_ (c0170@moz-4stj9o.cable.virginm.net) (Connection closed)
[16:06:27] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Client exited)
[16:07:43] *** Joins: GBGamer (npm@moz-lnfabr.tmodns.net)
[16:08:09] <GBGamer> is it at all possible to compile rustc, starting at stage 2?
[16:08:49] <GBGamer> I'm making minor, non breaking changes, and it still takes forty minutes to compile from stage 0
[16:09:03] <XMPPwocky> there's make check-stage1 iirc
[16:09:09] <XMPPwocky> which builds stage1 and runs tests on it
[16:09:32] <XMPPwocky> stage 2 is sort of like stage1 but built *with* stage1 instead of stage0
[16:09:41] <XMPPwocky> you can't have stage2 without an up-to-date stage1
[16:09:54] <GBGamer> so I still get a working compiler out of it?
[16:11:18] *** rovar is now known as Guest6710
[16:11:18] *** rovar_ is now known as rovar
[16:11:21] <XMPPwocky> right
[16:11:32] <XMPPwocky> you can even skip the tests depending on what you want
[16:11:33] <GBGamer> cool, thanks :)
[16:13:05] <GBGamer> how would I do that?
[16:13:45] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[16:14:01] *** Joins: scott (uid25790@moz-e5ok1n.brockwell.irccloud.com)
[16:14:34] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[16:15:14] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[16:17:05] *** Quits: jdm (jdm@moz-ilbt2e.cable.teksavvy.com) (Connection closed)
[16:21:21] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[16:24:29] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[16:25:12] *** Joins: arielb1 (Ariel@moz-4fcn2m.red.bezeqint.net)
[16:25:41] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[16:26:01] *** Joins: marsel (user@moz-nsf.g6r.180.94.IP)
[16:32:06] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[16:34:46] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[16:39:16] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[16:41:31] <larsberg> Is there anybody familiar with codemap stuff who could look at: https://github.com/rust-lang/rust/issues/24687 ? 
[16:41:46] <larsberg> We believe it's blocking our Servo upgrade (to a build from Saturday morning).
[16:43:13] <pnkfelix> larsberg: If someone else does not take it then I can do it.  (The only reason I'm qualifying my response is that its already almost 7pm here)
[16:43:25] <pnkfelix> (and so someone else might resolve it e.g. before tomorrow morning for me)
[16:44:07] <larsberg> pnkfelix: thanks! I'll definitely take you up on that if it comes to it, though I suspect SimonSapin will see you tomorrow before I will :-)
[16:45:51] *** Joins: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com)
[16:46:32] <SimonSapin> larsberg: we’re sitting a few meters from each other right now, but I doubt looking sternly over his shoulder will make a fix appear faster :)
[16:47:00] <pnkfelix> ... especially since I tend not to notice someone standing over my shoulder when my earphones are on
[16:47:16] <larsberg> SimonSapin: I was thinking more of shameless bribery in the form of fromage or whatever else is Paris-appropriate (feel free to expense)
[16:48:59] *** Joins: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr)
[16:50:34] *** Quits: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr) (Connection closed)
[16:50:41] *** Quits: munksgaard (munksgaard@moz-1i4.hq0.225.130.IP) (Ping timeout: 121 seconds)
[16:50:56] *** Joins: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr)
[16:53:03] *** Quits: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr) (Connection closed)
[16:53:04] *** Joins: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr)
[16:56:18] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[16:56:52] *** Joins: npm (npm@moz-urd.pod.125.50.IP)
[16:56:59] *** Quits: GBGamer (npm@moz-lnfabr.tmodns.net) (Connection closed)
[16:58:03] *** Joins: GBGamer (npm@moz-lnfabr.tmodns.net)
[16:58:55] *** Joins: Rym (y@moz-cfe.mso.205.31.IP)
[17:00:54] *** Quits: npm (npm@moz-urd.pod.125.50.IP) (Ping timeout: 121 seconds)
[17:02:11] *** Quits: ptalbot (ptalbot@moz-g2mokk.ircam.fr) (Ping timeout: 121 seconds)
[17:02:48] *** Joins: brson (brson@moz-dgk.73s.245.63.IP)
[17:02:48] *** ChanServ sets mode: +o brson
[17:03:45] *** Joins: npm (npm@moz-urd.pod.125.50.IP)
[17:04:30] *** Quits: GBGamer (npm@moz-lnfabr.tmodns.net) (Ping timeout: 121 seconds)
[17:05:56] *** Joins: pcwalton (pcwalton@moz-nh2.o1i.216.216.IP)
[17:05:56] *** ChanServ sets mode: +o pcwalton
[17:07:31] <bluss> aturon: I sent a message to you on the internals discourse to ask if you can change my username there.
[17:08:26] *** Joins: GBGamer (npm@moz-urd.pod.125.50.IP)
[17:09:45] <aturon> bluss: got it
[17:10:15] <aturon> bluss: done
[17:10:59] <bluss> thank you! <3
[17:13:28] *** Quits: Murarth (Murarth@moz-mpmr8r.phnx.qwest.net) (Quit: Screw you guys. I'm going home.)
[17:13:50] *** Quits: summerlight_ (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[17:13:54] *** Joins: Murarth (Murarth@moz-vhel0j.dyn.nltelcom.net)
[17:14:41] *** zz_kimundi is now known as kimundi
[17:15:47] *** Joins: scialex (scialex@moz-j5mi8i.cs.brown.edu)
[17:20:16] *** Joins: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk)
[17:30:16] <steveklabnik> whoah http://scialex.github.io/reenix.pdf
[17:30:41] <erickt> woah
[17:31:54] <GBGamer> nice...
[17:31:57] <scialex> yeah. That took a long time.
[17:31:59] *** Joins: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net)
[17:32:13] <GBGamer> Is it implemented?
[17:32:37] <scialex> Not fully. Has processes, TTY,  and Disk driver.
[17:32:47] <scialex> Some of the stuff needed for a virtual file system is done.
[17:32:52] <GBGamer> damn.
[17:32:55] * GBGamer claps
[17:33:14] <scialex> \me bows
[17:34:00] <frewsxcv> scialex: excellent work
[17:34:18] <GBGamer> I'll be out for a little while, I've got a paper to read
[17:34:22] <GBGamer> :P
[17:36:55] *** Joins: mib_y6hi4z (Mibbit@moz-p11.01r.90.95.IP)
[17:37:47] *** Joins: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net)
[17:39:34] *** Quits: pcwalton (pcwalton@moz-nh2.o1i.216.216.IP) (Client exited)
[17:43:07] *** Quits: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP) (Quit: rcirc on GNU Emacs 24.5.1)
[17:44:07] *** Quits: marsel (user@moz-nsf.g6r.180.94.IP) (Ping timeout: 121 seconds)
[17:44:33] *** Joins: tamird (textual@moz-5v5pe2.ca.comcast.net)
[17:44:58] *** Quits: filsmick (filsmick@moz-ekfnpo.abo.wanadoo.fr) (Ping timeout: 121 seconds)
[17:46:33] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[17:49:56] *** Joins: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net)
[17:51:04] *** Parts: posix4e (sid82101@moz-rol03c.uxbridge.irccloud.com) ("")
[17:53:40] *** Joins: avikpal (avikpal@moz-7e5.2rc.232.117.IP)
[17:57:50] <doener> kimundi: ping
[17:57:56] <kimundi> doener: pong
[17:58:24] <doener> kimundi: did you check the perf with a rustc compiled with that patch or did you just try with cttz16?
[17:59:15] <kimundi> doener: As far as I could see your patch did not actually change anything in rustc, so I just did try with cttz16
[17:59:18] *** Joins: Kxepal (Miranda@moz-p58ma4.pppoe.mtu-net.ru)
[17:59:26] <doener> kimundi: you missed the "| 0x100" part :-)
[17:59:29] *** Joins: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP)
[17:59:33] <kimundi> Well I did that too
[17:59:49] <kimundi>     unsafe {
[17:59:49] <kimundi>         ::std::intrinsics::cttz16(n as u16 | 0x100) as u8
[17:59:49] <kimundi>     }
[17:59:57] <doener> hrm...
[17:59:57] <GBGamer> scialex: you may want to check out my libcore for kernels
[18:00:14] <doener> kimundi: is this on x86_64?
[18:00:18] <kimundi> yes
[18:00:29] <GBGamer> It solves a few of the problems that you run into
[18:01:57] <kimundi> doener: Some older i3 laptop if that helps. I can also push what I'm experimenting with locally to a branch on github if it helps
[18:03:18] <doener> kimundi: objdump -S target/release/bench-* | grep -A5 or.*0x100,
[18:03:31] <doener> kimundi: what does that print?
[18:04:54] <kimundi> doener: No matches for wildcard 'or.*0x100'.
[18:05:36] <scialex> GBGamer: I just compiled libcore myself. There was nothing that really needed to be modified. What's in yours?
[18:05:41] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[18:05:48] <doener> kimundi: hmm, is that your shell complaining? Try quoting "or.*0x100,"
[18:06:02] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[18:06:11] <GBGamer> I just took out all panicking code, basically
[18:06:25] <GBGamer> It returns options instead of panicking for most cases
[18:06:29] <kimundi> doener: ah, okay now I get stuff. let me pastebin it...
[18:06:37] <GBGamer> For indexing, it doesn't panic anymore (although it's unsafe)
[18:06:53] <GBGamer> And there's an extra function which returns an option
[18:06:57] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[18:07:05] <kimundi> doener: https://gist.github.com/Kimundi/5d634c90caaa9c06c1ea
[18:07:43] <doener> kimundi: hm, that's the better codegen...
[18:07:44] <GBGamer> Unfortunately, it's not legal rust yet, as I need to add intrinsics for division and modulus without panicking
[18:07:53] <GBGamer> But I'm working on it currently
[18:07:57] <kimundi> doener: hm...
[18:09:03] <GBGamer> but goddamn does building compilers take forever
[18:10:50] <XMPPwocky> can we make StaticMutex safe now?
[18:11:21] <kimundi> doener: maybe its the zero_undef thing after all?
[18:11:26] <XMPPwocky> .destroy() must be called manually, but Mutex's destructor is also not guaranteed to be called
[18:11:37] <XMPPwocky> so any underlying OS safety issues are also present w/ Mutex
[18:11:49] <doener> kimundi: all that would do is removing the "or" instruction
[18:11:50] <XMPPwocky> "Note that this is a separate type because using a Mutex correctly means that it needs to have a destructor run. "
[18:13:30] <kimundi> doener: I have the feeling that I should probably start comparing the assembly output of the C++ and the Rust version then, though I haven't really experience with that...
[18:14:47] <GBGamer> kimundi: also, if you're using clang, check out the llvm-ir
[18:15:13] <kimundi> GBGamer: THe llvm-is is already near-identical as far as I could see
[18:15:55] <kimundi> which is what confuses me, as that  means the difference either lies in the assembly codegen or in subtle differences I didn't notice yet
[18:16:18] *** Joins: stomper (Mibbit@moz-kpb.qco.26.69.IP)
[18:16:42] *** Parts: stomper (Mibbit@moz-kpb.qco.26.69.IP) ()
[18:16:44] <GBGamer> are you optimizing?
[18:16:50] <GBGamer> Also, upload them both to a gist
[18:19:52] *** Quits: Rym (y@moz-cfe.mso.205.31.IP) (Ping timeout: 121 seconds)
[18:19:56] <scialex> GBGamer: Cool. Most of this is stuff you'd want to panic on anyway though...
[18:20:12] <GBGamer> Well yeah, but I'd rather have the choice.
[18:20:34] <GBGamer> And did you have all of std?
[18:20:48] <GBGamer> Because if you did, that's why you had an issue with size :P
[18:21:10] <doener> kimundi: perf stat -r3 ./target/release/bench-* --bench cpp_naive_big
[18:21:16] <doener> kimundi: perf stat -r3 ./target/release/bench-* --bench rust_unsafe_big
[18:21:27] <doener> kimundi: could you run these and gist the results?
[18:24:48] *** Joins: dpc__ (dpc@moz-t6gr4b.ca.comcast.net)
[18:25:17] <doener> kimundi: oh, another thing, I think clang defaults to the native target cpu, while rustc defaults to basic x86_64
[18:26:10] <scialex> GBGamer: No but i did have a lot of it. Most of the stuff that doesn't need OS support.
[18:27:03] <kimundi> doener, GBGamer: ir https://gist.github.com/Kimundi/d2e3d7244e8d91ab3da1 perf https://gist.github.com/Kimundi/1bea7fcbfff5bd226773 and that clang/rustc native feature difference seems like a possibility
[18:27:40] <doener> kimundi: try adding -mcpu=x86_64 to the clang invocation
[18:28:00] *** Joins: sprang (sprang@moz-d0kmvi.12d9.sm5v.0009.2601.IP)
[18:30:12] <kimundi> doener: adding that option in my build.rs did not result in a slower library
[18:30:29] <doener> kimundi: with "cargo clean"?
[18:30:33] <kimundi> yes
[18:30:35] <doener> ok
[18:31:23] <doener> kimundi: did you try with the old patch that used the unsafe intrinsic?
[18:31:30] <doener> s/unssafe/undef/
[18:32:14] *** Joins: jdm (jdm@moz-ilbt2e.cable.teksavvy.com)
[18:32:49] <kimundi> doener: I haven't benchmarked it with your patch that made it use the zero_undef intrinsics
[18:32:58] *** Quits: arielb1 (Ariel@moz-4fcn2m.red.bezeqint.net) (Quit: Ex-Chat)
[18:33:11] <kimundi> this is all just with a recent nightly
[18:33:17] <doener> kimundi: ok
[18:34:02] <kimundi> thanks for the effort so far btw :)
[18:34:16] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[18:34:52] *** Quits: Murarth (Murarth@moz-vhel0j.dyn.nltelcom.net) (Quit: brb, washing the cat)
[18:35:06] *** Joins: Murarth (Murarth@moz-mpmr8r.phnx.qwest.net)
[18:35:20] <brson> i wonder how many '... of the week' sections twir can bear
[18:35:50] <brson> looking at quote of the week, crate of the week, tip of the week
[18:35:51] <kimundi> just add a "twir section of the week" ;)
[18:36:10] <brson> lol
[18:36:44] <doener> kimundi: perf record cargo bench rust_unsafe_big; perf report --stdio --percent-limit 1
[18:37:14] *** Joins: chc4 (chc4@moz-pdo0at.ma.comcast.net)
[18:38:04] *** Quits: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net) (Ping timeout: 121 seconds)
[18:38:38] *** Quits: joneshf-laptop (joneshf@moz-l4h.b5s.208.98.IP) (Ping timeout: 121 seconds)
[18:39:09] *** Quits: mib_y6hi4z (Mibbit@moz-p11.01r.90.95.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:41:05] <kimundi> doener: https://gist.github.com/Kimundi/1a4467b4497185a13c63
[18:41:41] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[18:41:41] *** ChanServ sets mode: +o pnkfelix
[18:42:40] <bluss> brson: time to start the Rust magazine
[18:42:55] <bluss> for the literate rustie
[18:47:30] *** Joins: Rym (y@moz-cfe.mso.205.31.IP)
[18:47:33] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[18:52:00] *** Quits: Rym (y@moz-cfe.mso.205.31.IP) (Ping timeout: 121 seconds)
[18:54:31] <steveklabnik> hehe
[18:57:11] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[18:57:13] *** Quits: Thorn (Thorn@moz-gfo.20c.107.217.IP) (Quit: Quit)
[18:57:25] *** Joins: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net)
[18:57:29] <doener> kimundi: perf annotate --stdio -s rust_unsafe::lswr::h08779a75009cdf9amg
[18:57:49] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[18:59:20] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[18:59:21] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[19:00:47] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Ping timeout: 121 seconds)
[19:01:33] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[19:02:01] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[19:02:49] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Client exited)
[19:05:05] <Manishearth> munksgaard: hey, around?
[19:05:40] <Manishearth> doener: think you can give me a review on https://github.com/Manishearth/rust-tenacious/ ?
[19:05:47] <Manishearth> uses ExprUseVisitor
[19:05:59] <Manishearth> or anyone else here who wants to read some plugins code
[19:07:08] <munksgaard> Manishearth: Yeah, whats up?
[19:07:50] <munksgaard> Manishearth: tenacius looks cool! But I'm not sure we can use exprusevisitor for humpty, I've tried :(
[19:08:09] <Manishearth> munksgaard: wanna give me a review on it?
[19:08:29] <Manishearth> since you've already probably understood most of ExprUseVisitor
[19:08:39] <Manishearth> need it to land https://github.com/servo/servo/issues/5724
[19:08:51] <munksgaard> Manishearth: Sure, I'll give it a look later tonight :)
[19:08:56] <Manishearth> cool, thanks
[19:09:03] <Manishearth> leave a comment on that PR when done :)
[19:10:55] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[19:10:57] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[19:12:51] *** Joins: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP)
[19:16:39] <doener> Manishearth: could you ask me again in about 20-24 hours?
[19:16:45] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[19:17:15] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[19:17:22] <Manishearth> doener: munksgaard already got it :)
[19:17:32] <Manishearth> and I know he understands EUV already 
[19:17:33] <doener> ah, ok
[19:17:55] *** Joins: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net)
[19:18:05] <reem> aturon: ping
[19:19:15] <seanmonstar> woah! associated constants!
[19:19:28] <reem> wow what!?
[19:19:33] <bluss> inlined code from libstd now may panic from overflow. Is this just overflow or debug assertions too?
[19:19:42] <seanmonstar> reem: just merged 30 mins ago https://github.com/rust-lang/rust/pull/23606
[19:19:55] <bluss> wow
[19:19:59] <seanmonstar> i assume this will be in 1.1, not cherrypicked?
[19:20:09] <seanmonstar> not a bug fix
[19:20:18] <aturon> reem: pong
[19:21:47] <reem> aturon: sort of a response to your r/rust post on leak stuff: I think we should not be raising “add ?Leak post 1.0” as a possible solution. The tradeoff of having to write T: ?Leak on almost every generic in the entire language is imo clearly not worth it; it gives people a false sense of security that we could fix this later. 
[19:22:33] <reem> even as the PR-maker for the Leak RFC I would much rather deal with a new scoped API than add ?Leak all over all code
[19:22:58] <aturon> reem: i would not be raising it if i didn't consider it a feasible approach, though I certainly agree that if we had to write ?Leak on every type parameter that would be a non-starter
[19:23:43] <reem> Do you see a strategy which doesn’t require that?
[19:24:03] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[19:24:03] *** ChanServ sets mode: +o pcwalton
[19:24:42] <aturon> i mean, both Leak approaches suffer from composability problems
[19:24:50] <aturon> one in the case of trait objects, the other, generics
[19:24:57] <aturon> in the case of ?Leak, 
[19:24:58] <kimundi> doener: sorry, was afk. I get "perf.data file has no samples"
[19:25:21] <aturon> if generics aren't labeled with the bound, that limits the cases in which certain RAII guards can be used
[19:25:29] <Manishearth> aturon: can't we add a default Leak bound on trait objects?
[19:25:39] <reem> Manishearth: that’s what adding ?Leak would do
[19:25:46] <reem> (and to generics as well)
[19:25:53] <Manishearth> true
[19:25:57] <aturon> right, that's the variant we're discussing
[19:26:18] <reem> aturon: The thing is these problems aren’t unique to Leak, Send, Sync, and especially Reflect already have this issue.
[19:27:02] <aturon> i certainly agree re: Send/Sync!
[19:27:13] <aturon> i don't think Reflect suffers from the trait object problem particularly
[19:27:18] <reem> if Leak doesn’t pull its weight, Reflect *really* doesn’t
[19:27:22] <aturon> since it's inherited by the relevant traits, as we discussed the other days
[19:27:40] <aturon> i feel like we're reiterating the discussion we had the other day?
[19:27:55] <aturon> anyway, i'm not trying to give people a "false sense of security", is my main point
[19:28:01] <reem> Absolutely
[19:28:05] <reem> I never meant to suggest you’re doing it on purpose
[19:28:30] <Manishearth> aturon: I haven't been able to follow the rfcs properly, currently which way is consensus leaning?
[19:28:40] <aturon> Manishearth: there is not currently a consensus :)
[19:28:42] <Manishearth> safe leaking, or Leak?
[19:28:47] <Manishearth> aturon: leaning :)
[19:28:49] <aturon> at least, not community-wide
[19:28:57] <Manishearth> what about within the CT?
[19:28:59] <reem> aturon: My main point with Reflect is that if I have some type X and it contains a trait object, and I want to put X in an Error, I am out of luck.
[19:29:15] <reem> unless the trait in X happens to inherit from Reflect (relatively unlikely)
[19:29:40] <aturon> within the core team, the consensus remains as it has been: that leaking should continue to be safe, and we can start by exploring APIs/implementations that work around that -- and then perhaps, if absolutely needed later, explore something like ?Leak
[19:29:45] <reem> but anyway, we’re ideally going to avoid stabilizing Reflect so we can deal with this later
[19:30:11] <aturon> reem: yeah, agreed; i would not be strongly opposed to removing Reflect and am glad we can avoid stabilizing it for now 
[19:30:28] <aturon> Manishearth: sorry, see above ^
[19:30:37] <XMPPwocky> could we just say "you can only leak 'static things"
[19:30:42] <aturon> Manishearth: in particular, you still need unsafe code to produce unsafety
[19:30:58] *** Quits: Diggsey (diggsey@moz-o8tmhf.dsl.pipex.com) (Ping timeout: 121 seconds)
[19:31:05] <reem> XMPPwocky: The problems arise when you try to actually enforce that
[19:31:23] <XMPPwocky> how so
[19:31:34] *** Joins: arielb1 (Ariel@moz-4fcn2m.red.bezeqint.net)
[19:31:45] <reem> XMPPwocky: well, you’d have to bound Rc by ‘static, for instance, which is pretty problematic since there are many legitimate use cases for Rc on non-‘static data.
[19:31:50] *** Joins: Diggsey (diggsey@moz-urivu8.dsl.pipex.com)
[19:31:53] <aturon> Manishearth: so unsafe code does need to be careful around this issue; safe code, on the other hand, can largely ignore the potential for RAII leaks, given that (1) they are rare (assuming we fix the dtor panicking issue -- then you really have to work at it) and (2) they represent *existing* bugs
[19:31:54] <Manishearth> aturon: what about a middle ground here? Lay some backcompat groundwork for ?Leak, *keep* mem::forget as unsafe, and plan to make leaks safe in the future?
[19:32:16] <aturon> XMPPwocky: that's one possibility, yes
[19:32:25] <aturon> XMPPwocky: that's been one of the main alternatives to Leak being discussed
[19:32:35] <reem> aturon: the hlua example worries me, since it indicates that this is not just a std problem
[19:32:48] <Manishearth> aturon: I'm also a tad wary of marking a dangerous API as "safe" -- why can't we use `unsafe` for things which are footguns or might possibly be considered unsafe in the future
[19:33:01] <aturon> Manishearth: so, a couple things :)
[19:33:31] <doener> kimundi: hm, maybe I copied the wrong symbol name?
[19:33:42] *** Joins: rkruppe_ (chatzilla@moz-3nj.rnu.131.95.IP)
[19:33:44] <reem> I think we should keep mem::forget unsafe just for the “might be unsafe in the future” reason, forget the footgunness, there’s just no reason to rush that change for 1.0
[19:33:51] <aturon> Manishearth: let me start with the second question. with respect to various kinds of bugs, there is a really crucial distinction: Rust *promises* never to produce memory unsafety in safe code; no other class of bugs gets that kind of guarantee
[19:34:08] <aturon> Manishearth: that's part of the key value proposition for Rust, and so i think it's important to be as crisp about it as we can
[19:34:32] <aturon> Manishearth: now, if there's a function that guarantees memory safety today, but we don't want to promise that it always will, unsafe can make sense
[19:34:44] <XMPPwocky> Then StaticMutex should be merged with Mutex.
[19:34:47] <aturon> Manishearth: however, if we keep Rc in roughly its current form, you can already write your own mem::forget in safe code
[19:34:51] <XMPPwocky> because if we don't guarantee destructors run...
[19:35:11] *** Joins: p1start (p1start@moz-nftjhe.org)
[19:35:22] <Manishearth> aturon: we can add some hackish compiler internals that prevent those loops, and promise to make them nicer with ?Leak later
[19:35:38] <aturon> Manishearth: "loops" == Rc cycles?
[19:35:42] *** Joins: GBGamer_ (npm@moz-71q.g5g.156.168.IP)
[19:35:48] <Manishearth> aturon: yeah
[19:35:55] <reem> if we’re going to make changes pre-1.0 we should just land Leak..
[19:36:00] <Manishearth> aturon: basically, add a rough internal ?Leak
[19:36:00] *** Quits: GBGamer_ (npm@moz-71q.g5g.156.168.IP) (Connection closed)
[19:36:09] <Manishearth> which makes this thingy impossible
[19:36:10] *** Quits: npm (npm@moz-urd.pod.125.50.IP) (Connection closed)
[19:36:13] *** Quits: GBGamer (npm@moz-urd.pod.125.50.IP) (Connection closed)
[19:36:16] <Manishearth> post-1.0, polish it up
[19:36:22] <aturon> reem: that assumes that there is much more consensus around that particular proposal than i think there is :)
[19:36:45] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[19:36:50] <aturon> Manishearth: ruling out Rc cycles is not that easy. also note that things like Leak don't actually prevent cycles
[19:36:52] *** rkruppe_ is now known as rkruppe
[19:37:01] <aturon> Manishearth: rather, they acknowledge the possibility of those cycles
[19:37:19] *** Joins: npm (npm@moz-urd.pod.125.50.IP)
[19:37:25] <aturon> XMPPwocky: I believe there were other reasons for StaticMutex, but I'm not sure (but note that it's unstable)
[19:37:58] <reem> I just mean that if we’re going to land breaking changes surrounding this, basically only Leak can actually happen without derailing 1.0. Banning cycles is either impossible or too restrictive, banning non-‘static data is extremely restrictive, etc. Leak introduces far fewer breaking changes then either of those.
[19:38:05] <Manishearth> aturon: yeah, fine
[19:38:09] <aturon> Manishearth: so, the backcompat version we were discussing basically says that leaks are allowed, but gives you a way to mark a particular type as "must not leak"
[19:38:15] <arielb1> Manishearth: it seems like Leak is the only sane option
[19:38:26] <kimundi> doener: the symbol is mangled, isn't it?
[19:38:42] <arielb1> we need Rc cycles
[19:38:49] <arielb1> we need non-static Rc
[19:38:56] <doener> kimundi: I copied that from the `perf report` output. Worked for me locally
[19:39:01] <kimundi> huh
[19:39:03] <Manishearth> aturon: I'm having a hard tiem communicating it (partially because I'm also in two other conversations :P) but i'm saying that we can land a rough version of ?Leak that forbids more than it should now
[19:39:04] <arielb1> this means we can't get immediate Gc
[19:39:14] <arielb1> Manishearth: adding Leak is easy
[19:39:20] <arielb1> it is just a big [breaking-change]
[19:39:21] <Manishearth> arielb1: what's the hard part?
[19:39:23] <reem> (I already have a patch doing it)
[19:39:25] <Manishearth> ah okay
[19:39:32] <Manishearth> what does it break, exactly?
[19:39:35] <aturon> reem: have you gotten it running against crates.io yet?
[19:39:35] <reem> trait objects, mostly
[19:39:42] <aturon> do you have data outside of std?
[19:39:47] <aturon> (and rustc)
[19:40:04] <reem> aturon: Unfortunately no.
[19:40:13] <reem> We know exactly what’s going to break
[19:40:43] *** Joins: GBGamer (npm@moz-urd.pod.125.50.IP)
[19:41:10] <reem> aside: I actually think many trait will end up inheriting from Leak, especially if their primary purpose is to sit behind Rc/Arc, e.g. in iron and hyper I’ll just make Handler/all the middleware stuff inherit from Leak and be done.
[19:41:16] <kimundi> doener: ah, my terminal cut of the last symbol char
[19:41:21] <Manishearth> reem: can you list the cases it will break? in the rfc or here
[19:42:24] <aturon> arielb1: do you consider the status quo (with mem::forget marked safe) untenable?
[19:42:26] <reem> Manishearth: the breaking changes to std are: add Leak bounds to {Arc, Rc}::new with unsafe alternatives ({Arc, Rc}::new_leak), add Leak bounds to `channel` and `sync_channel` (which is really just propagating the Arc changes).
[19:42:37] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[19:42:38] <arielb1> aturon: I prefer that mem::forget be unsafe
[19:42:48] <arielb1> even if it can't cause memory-unsafety
[19:42:52] <kimundi> doener: https://gist.github.com/Kimundi/b94ded09c7dbe1a583c3
[19:43:05] <arielb1> given that use of it is a bug
[19:43:11] <arielb1> outside of unsafe code
[19:43:34] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[19:43:35] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[19:43:36] <arielb1> just add documentation to the effect of "you can achieve this in safe code via Rc cycles"
[19:43:43] <reem> Manishearth: this caused almost no breakage within std and rustc, with basically the only thing being affected were the impls of serialize for Rc and Arc. This isn’t a great measure of the crates.io ecosystem though, since trait objects are far more popular in the wild.
[19:44:02] <reem> Manishearth: and this would break (in particular) Rc<RefCell<Box<Trait>>>> which is (unfortunately :P) relatively common
[19:44:03] <aturon> arielb1: hm, i'm not sure that it never has uses in safe code, but i'm also wary of using `unsafe` to mean "beware" rather than specifically "can cause memory unsafety"
[19:44:06] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[19:44:07] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[19:44:08] <aturon> arielb1: but, putting that aside for a moment,
[19:44:41] <aturon> arielb1: i wanted to understand whether you believe treating leaks as safe, and not introducing Leak, is viable (at least for now)
[19:44:46] <Manishearth> reem: oh, I see
[19:44:55] <arielb1> I think it is
[19:45:02] *** Quits: semarie (semarie@moz-l2n.lqk.61.185.IP) (A TLS packet with unexpected length was received.)
[19:45:04] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[19:45:10] <arielb1> I'm afraid Leak won't be backwards-compatible through
[19:45:28] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[19:45:30] <reem> Manishearth: the fix is really quick though, either Trait: Leak or Box<Trait + Leak> (for which I added support in the compiler, which was a much larger change than actually introducing Leak itself :))
[19:45:39] <Manishearth> aturon: can we get brson to run the taskcluster magic?
[19:45:45] <aturon> hm. i feel reasonably confident that there is a back-compat version, but i do agree with reem that it could lead to ?Leaked hell :)
[19:46:04] <aturon> Manishearth: yep, just been waiting for the go-ahead from reem on a branch
[19:46:17] <Manishearth> reem: what if Box<Trait> is by default Box<Trait+Leak> and you have to do Box<Trait+!Leak> to get the othe rone?
[19:46:35] <aturon> reem: that's a quick fix for today's code, but the worry is that it's a breaking change to APIs in the future, so you have to anticipate
[19:46:40] <reem> Manishearth: That’s basically the ?Leak proposal, but only for trait objects
[19:46:41] <Manishearth> it's like the default 'static bound
[19:46:45] <Manishearth> reem: yeah
[19:46:47] <aturon> Manishearth: that's a plausible mix of the two Leak approaches,
[19:47:03] <aturon> but it would mean having to write T: Leak more often
[19:47:05] <Manishearth> reem: I assume ?Leak would cause breakages of the form <T: ?Leak> eeeeverywhere
[19:47:09] <Manishearth> gah
[19:47:10] <reem> aturon: this is already true with Send/Sync (and isn’t so bad in practice), so I don’t really consider that a problem
[19:47:15] <Manishearth> I hate you all
[19:47:18] <Manishearth> (not you, the compiler)
[19:47:48] <Manishearth> (and the issues it causes)
[19:47:51] <Manishearth> reem: hmm
[19:47:55] <arielb1> We need trait aliases
[19:47:56] <aturon> reem: maybe, i'm just saying, the concern isn't wholly about the breakage today, it's about the future complexity that API designers have to face
[19:48:02] <aturon> arielb1: +1000
[19:48:02] <arielb1> or bound aliases
[19:48:08] <reem> arielb1: agree completely
[19:48:10] <arielb1> bound PythonLike = Sync+Send+Leak;
[19:48:15] *** Joins: Rym (y@moz-cfe.mso.205.31.IP)
[19:48:20] <arielb1> also +'static
[19:48:31] <aturon> 'static at least you often get for free today
[19:48:46] <Manishearth> reem: wait, what happens with Send/Sync exactly?
[19:49:10] <Manishearth> T is by default ?Send. Box<T> is Box<T+Send>?
[19:49:11] <aturon> Manishearth: you need to say Box<YourTrait + Send> if you want to be able to send across threads (and YourTrait doesn't inherit from Send already)
[19:49:12] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[19:49:19] <Manishearth> aturon: ah right
[19:49:21] <reem> Manishearth: it has the same poor interaction with trait objects that it’s a breaking change to add + Send or + Sync so you have to anticipate it when designing the API
[19:49:23] <aturon> Manishearth: you're thinking of 'static i think
[19:49:24] <Manishearth> that works for me
[19:49:27] <Manishearth> aturon: right
[19:49:34] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[19:49:41] <aturon> Manishearth: the problem is if you have some "middleman" API working with a trait object,
[19:49:44] <reem> see e.g. discussion on io::Error
[19:49:48] <aturon> and you don't know whether that object will eventually be sent between threads
[19:49:58] <aturon> you are forced to choose whether to tick on an additional +Send bound,
[19:50:04] <aturon> and either choice has downsides
[19:50:31] <arielb1> trait objects conceptually should be Leak by default
[19:50:38] <aturon> analogously, with Leak, you may not know whether some object you are producing/consuming may eventually be put into an Rc
[19:50:44] <reem> arielb1: should they?
[19:50:45] <arielb1> I think maybe also type parameters
[19:51:17] <cmr> To be honest I almost consider trait objects a lost cause. They're super verbose and can't easily express a lot of the dynamic patterns you'd want if making a Java-like object model. Plus, you're essentially forced, for complex APIs, to either have a nice API, or an API that is object-safe, and not both (ie, you need to use trait objects everywhere, and generics nowhere). It seems that
[19:51:20] <cmr> they're only useful for very small interfaces such as how std::fmt uses them, or https://github.com/cmr/rust-cc/blob/master/src/lib.rs#L4
[19:52:10] <aturon> cmr: i'm curious which java-style dynamic patterns you have in mind?
[19:52:32] <XMPPwocky> if trait objects had stuff like optional, uh
[19:52:34] <arielb1> cmr: I think Rust just has ADTs, so nobody uses trait objects
[19:52:37] <cmr> aturon: you can't downcast to another trait object.
[19:52:38] <XMPPwocky> not upcasting, not downcasting
[19:52:40] <XMPPwocky> leftcasting
[19:52:41] <XMPPwocky> there we go
[19:52:45] <XMPPwocky> to another trait
[19:52:46] *** Quits: Rym (y@moz-cfe.mso.205.31.IP) (Ping timeout: 121 seconds)
[19:52:51] <arielb1> *you don't need to
[19:52:51] <aturon> cmr: ah, yes :)
[19:52:53] <XMPPwocky> i guess you could just write that as part of the trait, but still
[19:52:56] <cmr> or sidecast, yeah.
[19:53:20] <reem> arielb1: Well, you can’t write Vec<Box<Trait>> using enums if you want people outside your crate to be able to add to it.
[19:53:33] <cmr> aturon: so you can only go straight to a concrete type, you can't get to anywhere else in the trait heirarchy.
[19:53:41] <aturon> FWIW, i think the issue with Send is somewhat endemic to obect-style abstraction, which is why down/side-casting ends up being such an important tool
[19:53:44] <XMPPwocky> so for example, in a lot of game engines
[19:54:07] <XMPPwocky> you'll have like IEntity, and then you might try and cast that over to IPhysical or IRenderable or whatever
[19:54:10] <cmr> Yes, I agree that in Rust it's not *nearly* as useful.
[19:54:23] <XMPPwocky> you can debate whether that's a good pattern but it seems to work out reasonably well in practice
[19:54:30] <cmr> And that there are better ways to structure your code than trait objects. But... that's basically the point I'm making :)
[19:54:55] <arielb1> cmr: trait objects are decent objects when you need them
[19:55:11] <arielb1> they are not an all-purpose data structure
[19:55:21] *** Joins: rkruppe_ (chatzilla@moz-3nj.rnu.131.95.IP)
[19:56:08] <reem> I will say that there are basically two major places where I have used trait objects and I want to replace them in one and the second is a giant hack with a better solution.
[19:56:22] <arielb1> through I would like enums with differently-sized variants
[19:56:31] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[19:56:31] *** rkruppe_ is now known as rkruppe
[19:57:33] <XMPPwocky> http://is.gd/ZnaUwZ nope
[19:57:35] <XMPPwocky> can't even put it on the trait
[19:57:40] <XMPPwocky> arielb1: box everything?
[19:57:53] <arielb1> XMPPwocky: you have to double-box then
[19:58:05] <XMPPwocky> arielb1: how so
[19:58:08] <XMPPwocky> if every variant is boxed
[19:58:16] <arielb1> you pass around &Enum
[19:58:16] <cmr> So, my point is, making some usecases of trait objects more annoying isn't really a loss in my book because they're already so limited in when they are useful.
[19:58:19] <XMPPwocky> then  the enum is the size of the smallest member + discriminantnte
[19:58:23] <XMPPwocky> ... discriminant, even
[19:58:40] <XMPPwocky> i feel like the biggest usecase of trait objects is just closures
[19:58:59] <arielb1> or Rc<Enum> or whatever
[19:59:10] *** Joins: srh (User@moz-tvc5sp.sntcca.sbcglobal.net)
[19:59:24] <XMPPwocky> arielb1: how else would enumss with differing sizes work
[19:59:26] <reem> cmr: I agree almost entirely, well stated.
[19:59:28] <XMPPwocky> monomorphization?
[19:59:40] <arielb1> XMPPwocky: that's how they work
[19:59:44] <XMPPwocky> Maybe we should just destabilize trait objects.
[19:59:45] <reem> the problems Leak brings up with trait objects already exist, and the solutions to them are applicable even if we don’t add Leak
[19:59:49] <reem> hahaha
[19:59:55] <Manishearth> aturon: why can't APIs tick on a hypothetical ?Send bound?
[19:59:58] <arielb1> I mean, differently-sized enums are for when you pass Rc<Enum> around
[20:00:03] <Manishearth> wait I get the issue
[20:00:04] <Manishearth> nvm
[20:00:11] <XMPPwocky> arielb1: ah, so it would be unsized
[20:00:17] *** Quits: dpc__ (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[20:00:18] <arielb1> XMPPwocky: sure
[20:00:19] *** Quits: bdero (bran@moz-mqs.7dh.189.18.IP) (Ping timeout: 121 seconds)
[20:00:20] <Manishearth> I agree with cmr. trait objects should be used rarely in Rust, no need to make them easy to use
[20:00:22] <XMPPwocky> makes sense
[20:00:37] <XMPPwocky> Manishearth: trait objects are hard to use in Rust, so they are used rarely.
[20:00:54] <cmr> I disagree with that. Trait objects are not very useful in Rust, so they are used rarely.
[20:01:13] <cmr> They *are* useful in very limited cases, but that's the case where they're already easy to use, pretty much.
[20:01:13] <arielb1> XMPPwocky: kind of like vtables in C
[20:01:44] <arielb1> you don't use them often, but they aren't particularly ugly
[20:01:44] <reem> I’m willing to bet >90% of trait object usage falls into “collection of heterogenous types with a common interface”
[20:02:31] <XMPPwocky> yeah, like an IRC bot that has a plugin system
[20:02:36] <XMPPwocky> can just have Vec<Box<Plugin>>
[20:02:39] <arielb1> reem: I think also "pointer to type with unknown interface"
[20:02:51] <arielb1> *to unknown type with known interface
[20:02:54] <Manishearth> XMPPwocky: no, trait objects aren't used much because there is an overhead and usually static dispatch is awesome
[20:03:04] <Manishearth> reem: yes
[20:03:11] *** Joins: Guest63 (textual@moz-ttd.2as.255.109.IP)
[20:03:26] <reem> arielb1: Ya, like in io::Error, though I do find that much less common than the heterogenous collection case. Those two probably make up almost all use.
[20:03:27] <Manishearth> reem: trait objects are generally when you want to plug something into an API
[20:03:29] <XMPPwocky> re: enum stuff, i had a weird idea around when DST was starting to get tossed around
[20:03:48] *** Quits: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net) (Ping timeout: 121 seconds)
[20:03:56] <XMPPwocky> specifically, enums could contain themselves, but that would make the entire thing unsized
[20:03:57] *** Joins: joneshf-laptop (joneshf@moz-ks14r2.ucdavis.edu)
[20:04:01] <arielb1> reem: I think the borrow checker makes you use indices for pointers
[20:04:09] <arielb1> or just not use pointers
[20:04:32] <reem> what do you mean?
[20:04:51] <arielb1> in Java pointers are the primitive data type
[20:05:04] <arielb1> sure you have ints
[20:05:09] <arielb1> but everything is a pointer
[20:05:21] <XMPPwocky> i mean, language design shapes what people use
[20:05:26] <XMPPwocky> it's possible to do Rust-style generics in C++
[20:05:46] <XMPPwocky> via templates; but the error messages you get if you mess something up, oh god
[20:06:16] <arielb1> XMPPwocky: C++ templates are just a type-level dynamic language
[20:06:36] <XMPPwocky> even though static dispatch is usually "the right thing", you don't see that as often in C++ because it's a giant pain
[20:08:03] <XMPPwocky> similarly, you use dictionaries / "arrays" (PHP) in languages that have them built in.... much more than you would in Rust/C/C++
[20:08:23] *** Quits: brson (brson@moz-dgk.73s.245.63.IP) (Ping timeout: 121 seconds)
[20:08:41] <XMPPwocky> so the idea that trait objects should be made second-class citizens because they aren't used that often is a little concerning. (see also: fixed-size arrays)
[20:08:51] <arielb1> XMPPwocky: rustc does like its HashMap-s
[20:09:56] <cmr> XMPPwocky: that's not the point I made whatsoever.
[20:10:37] *** Joins: genbattle (genbattle@moz-4v0.gkd.16.182.IP)
[20:10:43] <arielb1> XMPPwocky: and PHP attracts stringly-typed programs
[20:10:46] <reem> cmr: Could I bug you to summarize your points on the Leak RFC? If you don’t have time that’s fine, I can do it.
[20:10:49] <arielb1> which are held together by strings and hash
[20:11:09] <cmr> reem: I really don't have time right now as I finish up a compiler for class.
[20:11:31] <reem> that’s cool, I’ll pm you what I write before I post it?
[20:11:34] <arielb1> reem: which points
[20:11:40] <cmr> sure
[20:11:54] <reem> arielb1: about trait objects, and why making them slightly less ergonomic with Leak is not a new or really important problem
[20:12:00] <XMPPwocky> Is it safe to access a value as two different types at the same time?
[20:12:03] <XMPPwocky> oh yeah it must be
[20:12:10] <cmr> No, because values can only have one type.
[20:12:10] <XMPPwocky> because .downcast_ref()
[20:12:14] <arielb1> XMPPwocky: C rules
[20:12:31] <XMPPwocky> cmr: i meant type-erased and as-actual-tye
[20:12:36] <XMPPwocky> immutably, obviously
[20:12:38] *** Joins: GBGamer_ (npm@moz-71q.g5g.156.168.IP)
[20:12:44] <arielb1> XMPPwocky: sure
[20:12:47] <arielb1> also two type-erased's
[20:12:52] * scialex is away: I'm busy
[20:13:07] *** Quits: scialex (scialex@moz-j5mi8i.cs.brown.edu) (Quit: Leaving)
[20:13:08] <XMPPwocky> in other news, rustdoc has betrayed me once again :(
[20:13:10] <arielb1> type-eraseds don't actually access the contained objects
[20:13:14] <XMPPwocky> http://doc.rust-lang.org/std/index.html?search=downcast_ref 
[20:13:19] <arielb1> you just call via them
[20:13:26] <XMPPwocky> none of the links work :||
[20:13:37] <XMPPwocky> arielb1: hmm, that's a reasonable way to think about it
[20:13:52] <XMPPwocky> (the question of why rustc_unicode exports Any will be left for another day)
[20:13:54] <reem> arielb1: Wow I never thought about it that way, that’s such a nice way to frame it.
[20:14:54] <arielb1> I mean, unsized objects can't be rvalues
[20:15:10] <XMPPwocky> ack, more rustdoc bugs
[20:15:13] <arielb1> and trait objects don't come with "elimination forms"
[20:15:19] <XMPPwocky> http://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref methods showing up twice :(
[20:15:28] *** Quits: GBGamer (npm@moz-urd.pod.125.50.IP) (Ping timeout: 121 seconds)
[20:15:46] <Manishearth> paging acrichto for broken rustdoc
[20:15:51] <arielb1> except for the vtable impl
[20:15:51] <XMPPwocky> hmm, interesting
[20:15:54] *** Quits: npm (npm@moz-urd.pod.125.50.IP) (Ping timeout: 121 seconds)
[20:15:58] <Manishearth> <@cmr> reem: I really don't have time right now as I finish up a compiler for class.
[20:16:01] *** Quits: GBGamer_ (npm@moz-71q.g5g.156.168.IP) (Connection closed)
[20:16:03] <XMPPwocky> there is a specific " impl Any+Send"
[20:16:04] <bluss> it used to not show up at all
[20:16:09] <Manishearth> there are so many jokes I could make about that that it's hard to choose :P
[20:16:10] <XMPPwocky> i guess for trait objects
[20:16:17] *** Joins: acharles (acharles@moz-ulbdcn.ca.comcast.net)
[20:16:36] *** Quits: arielb1 (Ariel@moz-4fcn2m.red.bezeqint.net) (Quit: Ex-Chat)
[20:16:45] *** Joins: npm (npm@moz-urd.pod.125.50.IP)
[20:17:06] <XMPPwocky> clearly, we should destabilize everything, and then only stabilize the asm! macro. in 1.0, all code must be compiled by hand
[20:17:38] *** Joins: GBGamer (npm@moz-urd.pod.125.50.IP)
[20:20:20] <XMPPwocky> XSS on doc.rust-lang.org isn't security-critical, just a normal bug, right
[20:22:58] *** Quits: untitaker_ (untitaker@moz-d47ul3.highway.telekom.at) (Ping timeout: 121 seconds)
[20:24:22] *** Quits: npm (npm@moz-urd.pod.125.50.IP) (Connection closed)
[20:25:21] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[20:25:22] *** ChanServ sets mode: +o brson
[20:25:41] *** Joins: npm (npm@moz-urd.pod.125.50.IP)
[20:25:59] *** Joins: untitaker (untitaker@moz-v5462d.highway.telekom.at)
[20:26:23] *** Joins: James (quassel@moz-9kp9p2.range86-148.btcentralplus.com)
[20:29:36] <XMPPwocky> http://doc.rust-lang.org/std/trait.Any.html#method.hullo"><img src="bad" onerror="alert('hi')">
[20:31:10] <Manishearth> XMPPwocky:  brson ^^
[20:32:05] <steveklabnik> Manishearth: XMPPwocky brson it's documented behavior
[20:32:21] <steveklabnik> http://doc.rust-lang.org/nightly/book/documentation.html#security-note
[20:33:54] <Manishearth> steveklabnik: that's from the side of whoever is uploading code
[20:33:58] <Manishearth> *docs
[20:35:22] <Manishearth> wait, no xss for me
[20:35:25] *** Quits: James (quassel@moz-9kp9p2.range86-148.btcentralplus.com) (Ping timeout: 121 seconds)
[20:36:02] <XMPPwocky> Manishearth: chrome?
[20:36:04] <XMPPwocky> chrome blocks it
[20:36:06] <tamird> huon did you end up figuring out how the snapshot process works these days?
[20:36:11] <XMPPwocky> no it totally doesn't, nvm
[20:36:59] <Manishearth> XMPPwocky: firefox
[20:37:19] <XMPPwocky> hm, maybe firefox's xss guard is better
[20:37:37] <XMPPwocky> you can check out the developer inspect element thing (view source won't work, it's constructed via JS)
[20:37:54] <XMPPwocky> works in chrome & IE, at least
[20:37:56] <steveklabnik> so wait, is this on doc.rust-lang.org right now?
[20:38:07] <XMPPwocky> steveklabnik: yeah
[20:39:11] <steveklabnik> where?
[20:39:19] <XMPPwocky> follow the link?
[20:39:24] <XMPPwocky> it's the 404 page
[20:39:29] <bstrie> Gankro: it is my most fervent dream that one day PPYP is as ubiquitous an acronym as RAII
[20:39:34] <XMPPwocky> it constructs a link dynamically via... string concatenation for some reason
[20:39:37] <XMPPwocky> and just sets .innerHTML
[20:39:52] <steveklabnik> hmmm
[20:39:58] <steveklabnik> yeah i can't get the alert to come up
[20:39:59] <steveklabnik> Firefox here
[20:40:06] <XMPPwocky> steveklabnik: check the dev console?
[20:40:32] <steveklabnik> nope
[20:40:32] <steveklabnik> nothing
[20:40:41] <steveklabnik> http://doc.rust-lang.org/std/trait.Any.html#method.hullo%22%3E%3Cimg%20src=%22bad%22onerror=%22alert%28%27hi%27%29%22%3E is what you're talking about, right?
[20:41:25] <XMPPwocky> firefox has a xss filter
[20:41:32] <steveklabnik> ah
[20:41:35] <XMPPwocky> as does chrome, but chrome's doesn't trigger here
[20:41:38] *** Quits: avikpal (avikpal@moz-7e5.2rc.232.117.IP) (Ping timeout: 121 seconds)
[20:41:42] <XMPPwocky> for some reason, possibly because it's in the fragment
[20:41:44] <steveklabnik> anyway, yeah, you're right, i misunderstood. that's certainly a bug
[20:42:02] <XMPPwocky> which is probably a chrome bug
[20:43:52] *** Joins: nrc (nrc@moz-9v1svd.xtra.co.nz)
[20:43:52] *** ChanServ sets mode: +o nrc
[20:44:02] <tamird> hi folks, i'm trying to use associated constants in bitflags! but this change doesn't compile. any hints as to why? https://gist.github.com/tamird/d4882cd2597a14364a19
[20:44:13] <steveklabnik> are associated constants implemented yet?
[20:44:19] <tamird> yeah merged earlier today
[20:44:19] <cmr> steveklabnik: no.
[20:44:25] <tamird> https://github.com/rust-lang/rust/pull/23606/files
[20:44:25] <cmr> wait what
[20:44:37] <steveklabnik> oh wow
[20:44:38] <steveklabnik> neat
[20:44:38] <cmr> whoaa
[20:44:50] <steveklabnik> :D
[20:44:55] <steveklabnik> okay, brb again
[20:45:00] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Connection closed)
[20:45:00] <XMPPwocky> This 5 Minutes In Rust
[20:45:40] <tamird> so...any insight as to why `#[cfg(not(stage0))]` seems not to work in that macro?
[20:46:21] <tamird> ugh looks like you need two different macros
[20:47:56] <XMPPwocky> https://github.com/rust-lang/rust/blob/31ba21228e0e539a665ce14ab3a176e30e57f822/src/doc/not_found.md the culprit
[20:49:02] *** Joins: Rym (y@moz-cfe.mso.205.31.IP)
[20:49:16] <tamird> hey acrichto, any chance you could help me get a snapshot made?
[20:49:44] *** Joins: avikpal (avikpal@moz-bbs.dv5.232.117.IP)
[20:53:02] <XMPPwocky> btw steveklabnik if the URL is URL-encoded it doesn't work
[20:53:14] <XMPPwocky> but if you actually C&P into the url bar, or click a link on another site, it does
[20:53:19] <XMPPwocky> browsers are weird
[20:53:30] *** Quits: Rym (y@moz-cfe.mso.205.31.IP) (Ping timeout: 121 seconds)
[20:53:57] *** Quits: jgallagher (john@moz-d5e8oc.hfc.comcastbusiness.net) (Client exited)
[20:56:52] *** Quits: sprang (sprang@moz-d0kmvi.12d9.sm5v.0009.2601.IP) (Ping timeout: 121 seconds)
[20:56:55] *** kimundi is now known as zz_kimundi
[20:57:21] *** Quits: avikpal (avikpal@moz-bbs.dv5.232.117.IP) (Connection closed)
[20:58:06] *** Joins: Codenator (Mibbit@moz-d18.qnr.198.81.IP)
[20:58:58] *** Quits: genbattle (genbattle@moz-4v0.gkd.16.182.IP) (Connection closed)
[20:59:39] *** Quits: srh (User@moz-tvc5sp.sntcca.sbcglobal.net) (Quit: Leaving)
[21:00:19] *** Parts: Codenator (Mibbit@moz-d18.qnr.198.81.IP) ()
[21:02:13] *** Quits: joneshf-laptop (joneshf@moz-ks14r2.ucdavis.edu) (Connection closed)
[21:03:14] *** Quits: aepsil0n (eduard@moz-8h7njb.hsi8.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[21:03:57] *** Quits: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net) (Ping timeout: 121 seconds)
[21:04:40] *** Joins: genbattle (genbattle@moz-4v0.gkd.16.182.IP)
[21:05:43] *** Joins: gen_battle (genbattle@moz-4v0.gkd.16.182.IP)
[21:06:01] *** Joins: genbattle_ (genbattle@moz-4v0.gkd.16.182.IP)
[21:08:38] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[21:08:55] *** Joins: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com)
[21:09:11] *** Quits: genbattle (genbattle@moz-4v0.gkd.16.182.IP) (Ping timeout: 121 seconds)
[21:09:47] *** Quits: gen_battle (genbattle@moz-4v0.gkd.16.182.IP) (Ping timeout: 121 seconds)
[21:10:22] <steveklabnik> XMPPwocky: oh interesting.
[21:13:24] *** Quits: akawaka (akawaka@moz-0bb8q8.irvnca.sbcglobal.net) (Ping timeout: 121 seconds)
[21:14:27] *** Joins: akawaka (akawaka@moz-0bb8q8.irvnca.sbcglobal.net)
[21:16:31] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[21:19:21] *** Joins: srh (User@moz-qmcpes.unps.r1c6.fb90.2607.IP)
[21:20:28] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[21:22:33] *** Quits: richo (richo@moz-0r0.lsm.199.198.IP) (Quit: WeeChat 1.0.1)
[21:24:04] *** Joins: richo (richo@moz-slrmp8.fs1g.619c.a880.2604.IP)
[21:27:03] *** Quits: Guest63 (textual@moz-ttd.2as.255.109.IP) (Quit: My Mac has gone to sleep. ZZZzzz…)
[21:27:07] <tamird> steveklabnik (or anyone) could you push current master to snap-stage3 (source: https://github.com/rust-lang/rust-wiki-backup/blob/master/Note-compiler-snapshots.md)? a new snapshot would make it possible to implement bitflags with associated constants, which is just too messy to do with conditional compilation
[21:28:29] *** Quits: npm (npm@moz-urd.pod.125.50.IP) (Ping timeout: 121 seconds)
[21:28:35] *** Quits: GBGamer (npm@moz-urd.pod.125.50.IP) (Ping timeout: 121 seconds)
[21:28:51] <steveklabnik> acrichto: brson ^ ?
[21:29:14] *** Joins: npm (npm@moz-og1.mg6.56.172.IP)
[21:30:26] <brson> tamird: ok
[21:31:58] <brson> tamird: your snaps are building now. you can follow along here http://buildbot.rust-lang.org/builders
[21:32:06] *** Quits: kmcguire_ (kmcguire@moz-pg1gb9.biz.rr.com) (Ping timeout: 121 seconds)
[21:32:21] <tamird> thanks!
[21:33:49] *** zz_kimundi is now known as kimundi
[21:34:58] *** Joins: Kingsquee (kingsley@moz-qq7ns6.bchsia.telus.net)
[21:37:52] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[21:44:45] <acrichto> aturon: r? https://github.com/rust-lang/rust/pull/24873
[21:44:53] <acrichto> turns out windows process spawning has been broken for awhile...
[21:44:56] *** Joins: Rym (y@moz-cfe.mso.205.31.IP)
[21:45:02] <acrichto> we may want to backport that
[21:46:34] <sfackler> acrichto: had a chance to look at https://github.com/rust-lang/rust/pull/24847 ?
[21:46:45] <acrichto> sfackler: ah not yet
[21:47:04] <acrichto> sfackler: I'll try to get to it soon though
[21:47:11] <sfackler> cool
[21:47:59] <munksgaard> Manishearth: tenacious looks good! I can only envy how clean and simple it is compared to humpty ^^ 
[21:48:44] <munksgaard> You're not concerned about mutations though?
[21:49:54] *** Quits: Rym (y@moz-cfe.mso.205.31.IP) (Ping timeout: 121 seconds)
[21:50:38] <reem> Manishearth: will tenacious catch swaps and replaces?
[21:50:46] <reem> (if so: WOW)
[21:52:32] *** Quits: burntsushi (burntsushi@moz-t92kn9.ma.charter.com) (Ping timeout: 121 seconds)
[21:52:45] <munksgaard> reem: Are you talking about std::mem::swap? If so, they only take references, so no.
[21:52:47] *** Joins: burntsushi (burntsushi@moz-t92kn9.ma.charter.com)
[21:53:08] <XMPPwocky> i thuoght thou ponitn of tenacious was that it knew about swap, too?
[21:53:11] <XMPPwocky> er, the point*
[21:54:10] <munksgaard> Well, maybe it should?
[21:55:37] <Manishearth> munksgaard: cool, could you leave a comment on the PR for the record?
[21:55:48] <Manishearth> munksgaard: https://github.com/servo/servo/issues/5724
[21:56:29] <Manishearth> reem: no, it has trouble with generic functions
[21:57:42] <Manishearth> munksgaard: sorry, this PR https://github.com/servo/servo/issues/5855
[21:57:45] <Manishearth> thanks a million!
[21:57:46] <Manishearth> :)
[21:58:00] <Manishearth> reem: the use case of tenacious is a bit different -- see https://github.com/servo/servo/pull/5855/files for what I mean
[21:58:05] <Manishearth> we don't use mem::swap on Root
[21:58:18] <Manishearth> lints are rarely perfect
[22:01:15] *** Joins: Jesin (Jesin@moz-t88s6v.cc.lehigh.edu)
[22:01:34] <Manishearth> reem: shouldn't be hard to teach it about the few stdlib functions which do move-through-ptr though
[22:02:48] *** Joins: kmcguire (kmcguire@moz-c955nf.res.rr.com)
[22:03:20] <Manishearth> munksgaard: actually it turns out we do handle generics well
[22:03:35] <Manishearth> because wven with a generic, if the function can move it must take a value in by-move
[22:03:43] <Manishearth> *even
[22:03:45] <brson> WindowsBunny: I see a bunch of 'timestamp is in the future' errors extracting winapi http://docs.taskcluster.net/tools/task-inspector/#vFsCvtPPRM2DzVkqC8LQ8w/0
[22:03:49] <Manishearth> the only issue is swap and replace
[22:03:56] <Manishearth> which are both generic and internally unsafe
[22:03:59] <munksgaard> Manishearth: http://is.gd/LT2M73 this doesn't error, but it should, right?
[22:04:49] <Manishearth> munksgaard: no, it shouldn't, Foo is a temporary. do let x = Foo and then bar(x)
[22:05:02] <Manishearth> the readme mentions that it ignores temporaries, that's an explicit choice :)
[22:05:16] *** Quits: erz (erz@moz-n2p94l.broadband.corbina.ru) (Quit: My Mac has gone to sleep. ZZZzzz…)
[22:05:27] <Manishearth> I'll later add cargo features to control that part
[22:05:31] <munksgaard> But I'm moving it around inside `bar`, right?
[22:06:03] <munksgaard> http://is.gd/uxRKZM
[22:06:13] <WindowsBunny> brson: wut
[22:06:17] <Manishearth> munksgaard: ohhhh
[22:06:18] <Manishearth> right
[22:06:21] <Manishearth> good catch
[22:06:29] <WindowsBunny> timestamp in the future?
[22:07:10] <brson> WindowsBunny: your tarball is from 2112!
[22:07:15] <WindowsBunny> brson: How does that even?
[22:07:25] * brson shrug 'tar: src/vadefs.rs: time stamp 2112-01-13 07:37:56 is 3051941737.982940751 s in the future '
[22:07:40] *** Joins: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP)
[22:07:58] *** Joins: sprang (sprang@moz-bb96om.6d5c.910g.0470.2001.IP)
[22:08:00] <WindowsBunny> wat
[22:08:15] <WindowsBunny> brson: Cargo is broken at creating archives then
[22:08:26] <WindowsBunny> I'm going through my winapi .crates in my cargo cache
[22:08:30] <WindowsBunny> some are from 1970
[22:08:32] <WindowsBunny> some from 2112
[22:08:45] <WindowsBunny> acrichto: Why did you do this to me? D:
[22:08:52] <brson> lol
[22:08:55] <steveklabnik> lol
[22:09:07] <sfackler> are any in between?
[22:09:21] <WindowsBunny> 0.1.17 2112
[22:09:24] <acrichto> hm, not sure what would cause that
[22:09:28] <WindowsBunny> 0.1.6 2112
[22:09:31] <WindowsBunny> *16
[22:09:38] <munksgaard> Manishearth: Yeah, there's the same problem in humpty. My current thinking is to do an extra traversal of the function, with the argument types replaced by whatever protected type. It just seems so arduous...
[22:09:39] <WindowsBunny> 0.1.15 1970
[22:09:50] <WindowsBunny> 0.1.14 1970
[22:10:00] <WindowsBunny> 0.1.13 1970
[22:10:13] <WindowsBunny> all the way back to 0.0.5 which is 1970
[22:10:19] *** Joins: srh_ (User@moz-7hrfs3.unps.r1c6.fb90.2607.IP)
[22:10:19] <Manishearth> munksgaard: yeah :(
[22:10:45] <WindowsBunny> acrichto: So its always been broken as 1970, but recently in cargo it changed to 2112
[22:10:55] <WindowsBunny> A recent bug
[22:11:01] <WindowsBunny> And an older bug
[22:11:02] <acrichto> WindowsBunny: how are you extracting tarballs?
[22:11:07] <bstrie> but 2112 was released in 1976, not 1970
[22:11:10] <Manishearth> munksgaard: for sessions how bad would it be if we had to wrap every API we wished to use for humpty types?
[22:11:16] <WindowsBunny> acrichto: I'm opening them in 7-zip
[22:11:19] <Manishearth> I'm thinking to OIBIT this
[22:11:33] <WindowsBunny> acrichto: http://i.imgur.com/XHFodhB.png
[22:11:48] <munksgaard> Manishearth: What do you mean, exactly?
[22:11:48] <bstrie> OIBIT all the things
[22:12:01] <WindowsBunny> acrichto: http://i.imgur.com/4hCu03P.png
[22:12:27] <Manishearth> munksgaard: huehuehuehuehue
[22:12:37] <Manishearth> munksgaard: impl Affine for .. {}
[22:12:42] <Manishearth> impl !Affine for Foo {}
[22:12:43] *** Quits: srh (User@moz-qmcpes.unps.r1c6.fb90.2607.IP) (Ping timeout: 121 seconds)
[22:12:45] <Manishearth> trait Affine {}
[22:12:57] <acrichto> WindowsBunny: it's almost guaranteed to be a bug in tar-rs
[22:13:05] <acrichto> WindowsBunny: archives on windows may just have a different meaning?
[22:13:08] <acrichto> or at least that field
[22:13:26] <Manishearth> wait no
[22:13:29] <WindowsBunny> Well, tar-rs is creating them incorrectly
[22:13:30] <Manishearth> I guess we need ?Affine
[22:13:39] <munksgaard> Manishearth: Not too bad I guess? It would be absolutely amazing to just be able to say impl !Affine for Chan {}
[22:13:50] <WindowsBunny> But since brson on non-windows and me on windows agree about the interpretation of the archives
[22:13:55] <Manishearth> munksgaard: the magic is that the .. impl handles self-propagation
[22:14:10] <WindowsBunny> so tar-rs is interpreting the modified timestamp on files incorrectly on windows
[22:15:07] <Manishearth> munksgaard: hold on, let me try something
[22:15:10] <munksgaard> Manishearth: It has been discussed at length already though: https://github.com/rust-lang/rfcs/pull/776
[22:15:21] <munksgaard> http://internals.rust-lang.org/t/pre-rfc-linear-type-modifier/1225
[22:15:27] <acrichto> WindowsBunny: oh no windows times are relative to 1601
[22:15:32] <acrichto> WindowsBunny: unix times are relative to 1970
[22:15:33] <WindowsBunny> octal(&mut header.mtime, stat.modified() / 1000);
[22:15:38] <WindowsBunny> :|
[22:16:04] <Manishearth> munksgaard: we have OIBIT now
[22:16:14] <Manishearth> munksgaard: we can do this without compiler support
[22:16:34] <munksgaard> Manishearth: Where can I read about OIBIT?
[22:16:54] <WindowsBunny> acrichto: Oh I know, before it returned a time relative to 1601 in ms
[22:17:06] <WindowsBunny> acrichto: So it would always end up before 1970
[22:17:21] <WindowsBunny> so the timestamp would always effectively be the beginning of the epoch
[22:17:35] <WindowsBunny> acrichto: But then the impl for metadata changed to return the raw u64 on windows
[22:17:42] <WindowsBunny> which is in 100ns increments....
[22:17:48] <Manishearth> munksgaard: see this, http://is.gd/ukswaM
[22:17:54] <WindowsBunny> which... takes us to 2112 :|
[22:18:05] <Manishearth> munksgaard: there's an rfc ... somewhere :)
[22:18:11] <Manishearth> Let me just figure this out first
[22:18:25] <acrichto> WindowsBunny: no it hasn't changed yet
[22:18:38] <WindowsBunny> acrichto: Then how is it reporting 2112
[22:18:40] <WindowsBunny> overflow?
[22:18:45] <acrichto> maybe, dunno
[22:18:53] <WindowsBunny> Actually, that seems reasonable
[22:19:04] <Manishearth> acrichto: is it possible to make something that behaves like ?Sized wrt type params?
[22:19:07] <Manishearth> or is Sized special?
[22:19:08] <WindowsBunny> We end up with a timestamp before 1970 which overflows
[22:19:32] <acrichto> Manishearth: I believe Sized is very special
[22:19:40] <Manishearth> acrichto: could it be made ... not-special?
[22:19:43] <Manishearth> like oibit
[22:20:03] <acrichto> I'd be the wrong person to ask :(
[22:20:08] <WindowsBunny> acrichto: Maybe it was when we abandoned Duration, and Duration would handle that overflow for us
[22:20:09] <Manishearth> default trait Sized; impl Sized for .. {}
[22:20:21] <Manishearth> munksgaard: okay, oibit is not the way to go
[22:20:43] <WindowsBunny> Regardless, interpretation of the modified timestamp is wrong, so that needs to be fixed
[22:21:05] <Manishearth> munksgaard: oibit lets us specify a default propagating trait that can be opted out of, but it does *not* let us create types that can't be fed into a fully generic <T>
[22:21:32] <Manishearth> we could, of course, go your route and lint whenever it's passed to a generic fn that we don't control :)
[22:21:38] <WindowsBunny> brson: Thanks for catching this bug
[22:21:55] <Manishearth> and then within Servo use <T: Linear> everywhere
[22:21:56] <Manishearth> (ick)
[22:22:03] <Manishearth> that doesn't sound fun
[22:22:16] <munksgaard> Manishearth: No :(
[22:22:56] <Manishearth> munksgaard: alternatively, 
[22:22:58] <aturon> Manishearth: are you asking about having an additional marker that is bounded by default?
[22:23:12] <Manishearth> aturon: I'm asking for a way to create one as an external library :)
[22:23:57] <aturon> Manishearth: hm, i'm not sure whether that makes sense, since it would presumably impact the meaning of generics globally
[22:24:02] <Manishearth> how?
[22:24:24] <aturon> Manishearth: like with sized, if I write `fn foo<T>(t: T)`, i implicitly get T: Sized
[22:24:28] <Manishearth> yep
[22:24:33] <aturon> now suppose i have a crate `upstream`
[22:24:43] <Manishearth> this would mean that you can specify types which cannot be passed to any function defined in an older crate
[22:24:52] <Manishearth> which is pretty neat
[22:24:52] <aturon> and in my other crate that depends on it, `downstream`, i introduce a trait
[22:24:58] <Manishearth> but I guess that would not be too great
[22:25:02] <aturon> (that i want to work like Sized)
[22:25:04] <WindowsBunny> acrichto: Anyway, opened an issue https://github.com/alexcrichton/tar-rs/issues/19
[22:25:15] <aturon> what happens with signatures like `foo` in `upstream`?
[22:25:17] <acrichto> WindowsBunny: thanks
[22:25:40] <Manishearth> acrichto: they can't take the downsteam types that are !Affine. I know :)
[22:25:43] <Manishearth> sort of what I want :)
[22:26:14] <Manishearth> aturon: why doesn't this cause an error?
[22:26:14] <Manishearth> http://is.gd/lH7tEI
[22:26:16] <aturon> hm, not sure i understand the proposal. anyway, it's definitely not part of OIBIT today
[22:26:27] <Manishearth> aturon: yeah
[22:27:17] <aturon> Manishearth: i believe there are some special rules about concrete impls (positive or negative) overriding ones using ..
[22:27:27] <Manishearth> munksgaard: new plan. generics are evil. *if* a chan is being moved into a non-whitelisted func that takes that parameter as a generic parameter:
[22:27:37] *** Quits: sprang (sprang@moz-bb96om.6d5c.910g.0470.2001.IP) (Ping timeout: 121 seconds)
[22:27:37] <Manishearth>  - if the func is local, check for an annotation on it and proceed
[22:27:38] <aturon> but it's also possible there is a bug, i didn't even know you could do `!Trait for ..`
[22:27:43] <Manishearth>  - if the func is non-local, bail
[22:27:52] *** Quits: npm (npm@moz-og1.mg6.56.172.IP) (Connection closed)
[22:27:56] <Manishearth>  - for annotated local funcs, treat all Ts as if they are nodrop
[22:28:02] <Manishearth> aturon: ah
[22:28:07] <Manishearth> *shrug*
[22:29:13] <Manishearth> aturon: we basically want linear types as a plugin (for rust-sessions), but it's hard :)
[22:29:14] <munksgaard> Manishearth: Yeah, that's similar to what I've been thinking :)
[22:29:34] <aturon> Manishearth: heh, sounds fun :)
[22:29:35] <Manishearth> munksgaard: in the end, linting on okay things isn't as bad as not linting on nonokay things
[22:29:48] <Manishearth> (false positive > true negative)
[22:29:49] <munksgaard> Right, good point :)
[22:32:18] <munksgaard> Anyway, I off to bed. G'night
[22:33:58] <nrc> is there no println function any more?
[22:36:31] <bstrie> nrc: what does println! use internally?
[22:36:39] *** Quits: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk) (Ping timeout: 121 seconds)
[22:36:43] <nrc> bstrie: io::_print
[22:36:47] <nrc> via print!
[22:37:08] *** Joins: c0170 (c0170@moz-4stj9o.cable.virginm.net)
[22:37:09] <bstrie> is there a writeln function? would make sense, since writeln! is like println! except you can actually handle errors
[22:37:56] <nrc> doesn't seem to be, only write
[22:38:21] <bstrie> oh, well that's still fine :P
[22:39:32] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[22:40:02] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[22:40:03] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[22:40:07] *** Joins: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net)
[22:40:55] <nrc> argh, everything takes fmt args
[22:41:22] <nrc> I just want a function that works on strins
[22:41:26] <nrc> *strings
[22:42:01] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[22:42:26] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[22:43:20] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:43:46] *** Joins: larhat (Adium@moz-tb1ulb.cable.virginm.net)
[22:44:12] *** Quits: eibwen (eibwen@moz-33cegi.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[22:44:47] <nrc> so, is this the easiest way to 'hello world' without using macros?
[22:44:49] <nrc> ::std::io::stdout().write("hello world!\n".as_bytes());
[22:45:03] <nrc> acrichto: ^
[22:45:06] <sfackler> probably want write_all to be safe
[22:45:33] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Connection closed)
[22:45:34] *** Joins: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr)
[22:45:39] <acrichto> nrc: I'd use write_all + b"..." instead, but otherwise yeah I believe so
[22:46:04] <nrc> thanks!
[22:47:28] <bstrie> nrc: do you need the leading :: in ::std::io::stdout ?
[22:47:50] *** Quits: larhat (Adium@moz-tb1ulb.cable.virginm.net) (Ping timeout: 121 seconds)
[22:48:33] *** Quits: filsmick (filsmick@moz-bar7fk.abo.wanadoo.fr) (Quit: )
[22:48:49] <nrc> bstrie: no
[22:49:11] <nrc> why don't I, is std in the prelude?
[22:49:22] <nrc> I thought non-import paths were always relative
[22:53:05] <sfackler> std's imported into every module iirc
[22:53:30] <nrc> ah, right
[22:54:03] <cmr> I don't think so? I feel like I have to do ::std all the time.
[22:54:17] <bluss> then you are in a submodule cmr
[22:54:25] <cmr> yes.
[22:54:37] <cmr> std is only imported in the root module.
[22:56:23] <nrc> so std is automatically imported to the root module of each crate?
[22:56:36] <cmr> yes.
[23:01:29] <brson> the prelude is imported into every module, not std
[23:04:57] <bstrie> am I correct in that the actual "unsafe" bit of note in the old thread::scoped API is at https://github.com/rust-lang/rust/blob/master/src/libstd/thread/mod.rs#L624-L626 ?
[23:05:07] <bstrie> aturon: ^
[23:06:22] <aturon> bstrie: it's more spawning the thread at all - the os ffi call
[23:06:36] <Gankro> agreed
[23:06:39] <aturon> bstrie: on phone so I can't point you right at it
[23:06:44] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[23:07:28] <bstrie> aturon Gankro: you're not exactly making it easy for me to soothe people with the line "if you don't write unsafe code in destructors, you're a-ok" :\
[23:07:38] <Gankro> bstrie: https://github.com/rust-lang/rust/blob/master/src/libstd/thread/mod.rs#L313
[23:07:48] <Gankro> bstrie: It's not unsafe in destructors that matters
[23:08:09] <aturon> bstrie: it's more, if you don't write unsafe code that relies on dtors for safety you're ok
[23:08:13] <bstrie> then there's a few stealth edits that I need to make :(
[23:08:16] <aturon> Unsafe is always like that
[23:08:24] <Gankro> unsafe isn't a local property, it's a stateful one. e.g. Vec ops are only "safe" assuming the Vec's memory is in a consistent state
[23:08:33] <aturon> The place where you mark it is rarely the only one that matters
[23:08:41] <aturon> What gankro said
[23:09:22] <acrichto> WindowsBunny: ping
[23:09:42] <aturon> The key here is just that it's part of the contract when writing any unsafe code. There's a section in the ref manual about this that even mentions leaks
[23:09:59] <aturon> If only I had read that in proximity to adding scoped....!
[23:10:09] <WindowsBunny> acrichto: pong
[23:10:23] <Gankro> aturon: :O you're the troublemaker who had to go and expose this problem!?
[23:10:34] <acrichto> WindowsBunny: so on windows if I execute intrinsics::abort() in a child thread, the entire process exits with a 0 exit code (instead of something nonzero), do you know why this might be?
[23:10:50] <acrichto> WindowsBunny: also if the main thread hits intrinsics::abort(), the process exits with a nonzero exit code
[23:10:53] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[23:10:57] <bluss> learning about good patterns to use when writing unsafe code blocks.. that's a topic we'll explore for the next 10 years, I'm sure
[23:11:06] <WindowsBunny> acrichto: how is intrinsics::abort() implemented?
[23:11:07] <aturon> Gankro: guilty!
[23:11:15] <acrichto> WindowsBunny: it lowers to a `ud2` instruction
[23:11:24] <acrichto> WindowsBunny: which generates an "illegal instruction" exception from the hardware basically
[23:11:50] <aturon> bluss: yep! Fortunately gankro is interning this summer with that as at least part of the focus
[23:11:54] <WindowsBunny> :|
[23:11:59] <bluss> oh wow cool Gankro 
[23:12:04] <WindowsBunny> acrichto: That's not really a good way to do that
[23:12:05] *** Joins: sprang (sprang@moz-d0kmvi.12d9.sm5v.0009.2601.IP)
[23:12:15] <acrichto> WindowsBunny: well that's not really related to my question
[23:12:30] * Gankro should really stop slacking off and start working on *anything* again
[23:12:59] <WindowsBunny> acrichto: I'm not sure how illegal instruction exceptions are handled
[23:13:12] <aturon> Gankro: btw niko is in town this week, maybe we can have a joint skype? I'll be in touch
[23:13:20] <Gankro> aturon: Oh, that'd be cool!
[23:13:24] *** Joins: reedlepee (Mibbit@moz-juv.9o3.252.72.IP)
[23:13:39] <acrichto> WindowsBunny: ah well, was worth a shot :(
[23:14:43] <WindowsBunny> acrichto: If you want the exit code to be well defined, then you need to exist yourself
[23:14:52] <WindowsBunny> 8exit
[23:14:59] <WindowsBunny> /s/8/*/
[23:15:02] <WindowsBunny> I give up at typing
[23:15:55] <bstrie> aturon: niko is in town? for how long?
[23:16:43] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[23:16:49] <brson> I've made some compatibility improvements to crater and it should be able to bulid a lot more now
[23:18:21] <WindowsBunny> acrichto: I'd recommend using TerminateProcess if you want to ensure the process dies hard and fast and with an exit code
[23:19:10] <aturon> bstrie: tomorrow through Friday
[23:22:09] <bstrie> aturon: is he in the office? do I get to meet him?!
[23:23:14] <aturon> He'll be in SF, yeah
[23:23:21] * bstrie swoons
[23:23:59] <Gankro> Has there ever been an RFC/issue for reinstating some form of typestate?
[23:24:06] <cmr> I don't think so.
[23:25:01] <Gankro> http://pcwalton.github.io/blog/2012/12/26/typestate-is-dead/ is still the canonical resource on it?
[23:25:35] <cmr> I believe so.
[23:25:41] <bstrie> Gankro: what feature would you want that the blog post doesn't let you do?
[23:25:51] <Gankro> bstrie: It's mostly an ergonomics thing
[23:25:59] <bstrie> phantom types make you reassign, I suppose
[23:26:03] <Gankro> Yeah
[23:26:17] <Gankro> fieldwise, no less
[23:26:25] <Gankro> Unless you make a wrapper, I suppose
[23:26:44] *** Quits: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net) (Client exited)
[23:27:37] <Manishearth> Gankro: isn't that just a session type?
[23:27:46] <Gankro> Manishearth: example?
[23:28:35] <Manishearth> struct Open; struct Closed; struct Unused; and then just impl things on File<Open>, File<Closed>, File<Unused>,, and File<T>
[23:29:13] <Manishearth> hyper does this for the request api
[23:29:19] <Manishearth> or was that response
[23:29:24] <Gankro> rust-media has this annoying case of basically having Box<MediaStream> where MediaStream can be AudioStream, VideoStream, or OtherStream. All three are memory-wise identical, it's just a promotion of an integer field to a part of the type. You either have to transmute (which then rquires repr C), or you have to make a new box, move out the old, and then move
[23:29:25] <Gankro> back in. 
[23:29:53] *** Joins: erz (erz@moz-n2p94l.broadband.corbina.ru)
[23:30:16] <bstrie> does it optimize down to the same thing, I hope?
[23:30:28] <bstrie> IOW is phantom types a perf hazard or just an API hazard
[23:30:28] <Gankro> We ahve optimizations for that, but I haven't checked
[23:30:48] <Gankro> Just a pain in the neck
[23:31:11] <Gankro> Have to implement the same API 3 times for every codec
[23:31:48] <Gankro> btreemap does something similar with the nodes. Nodes are "unknown" type until you ask if it's a leaf or internal
[23:32:36] *** Quits: jdm (jdm@moz-ilbt2e.cable.teksavvy.com) (Quit: )
[23:34:35] <Gankro> Basically it'd be nice if there was a more ergonomic way to go from a type erasure to discovering the type (from a known subset). Any doesn't really fit with that
[23:35:09] <Gankro> And as far as I can tell typestate enabled that pretty cleanly
[23:36:14] <bstrie> I can't tell, I honestly never used typestate back when we had it
[23:36:55] <cmr> Gankro: the thing with typestate is that it was dynamic checks.
[23:37:03] <bstrie> it's funny how one of the biggest selling points back then was "we have typestate!" and then we had literally zero docs to tell you when or why you'd actually want to use it, so it just never got used by anyone
[23:37:47] <Gankro> cmr: that's exactly what this system is.
[23:37:50] <bstrie> cmr: I think one of the ideas of typestate is that it actually lets you elide the dynamic checks by understanding that a certain invariant has already been checked
[23:39:13] <bstrie> you have a predicate function, you use the `check` keyword to test a value with that predicate function, and until you do ~something~ any code deeper in the stack that checks the same predicate just becomes a no-op
[23:40:01] <Gankro> Foo<Unknown> is like struct Foo { type: SomeTypeEnum, ..other_data }. Everything stores Foo<Unknown>, but you can call like .get_type() -> Foo<TypeA> | Foo<TypeB> | Foo<TypeC> that you match on
[23:41:14] <Gankro> Maybe I should just repr(C) and transmute
[23:42:03] <bstrie> we need to sneak a fullmetal alchemist reference into the transmute docs
[23:42:23] *** Quits: erz (erz@moz-n2p94l.broadband.corbina.ru) (Connection closed)
[23:42:28] <Eridius> Gankro: maybe it should be an enum with 3 variants?
[23:42:35] <Eridius> or do you need to avoid the discriminant field?
[23:42:40] <bstrie> something something both types must be of the same size something something equivalent exchange
[23:42:41] *** Joins: erz (erz@moz-n2p94l.broadband.corbina.ru)
[23:42:45] <steveklabnik> bstrie: hahaha
[23:42:47] <Eridius> (well, if you had restrictions on memory layout you'd be using repr(C) already)
[23:42:47] <steveklabnik> i'm down
[23:43:12] <bstrie> steveklabnik: I wonder if you have your IRC client set to ping you any time the word "doc" is mentioned :P
[23:43:15] * WindowsBunny uses repr(D)
[23:43:24] <WindowsBunny> What's up doc?
[23:43:37] <bstrie> WindowsBunny: not much, what's up with you?
[23:43:49] <WindowsBunny> bstrie: Just hoping a rustup will cure this ICE
[23:43:57] <bstrie> rustup doc
[23:44:42] <Gankro> Eridius: The thing is these things are behind a Box and need to be moved, so I don't think matching will work well.
[23:44:44] <WindowsBunny> Okay, I really don't like this
[23:44:45] <WindowsBunny> https://gist.github.com/7dd5f15bfb06e5fa0781
[23:44:59] <Gankro> I suppose if you could have variables that store a specific variant of an enum
[23:45:09] <WindowsBunny> While building Rust, jemalloc telling me there were attempts to access invalid memory
[23:45:11] <WindowsBunny> That's bad
[23:45:14] <Gankro> e.g. foo: Option::<T>::Some
[23:45:28] <bstrie> WindowsBunny: wut
[23:45:43] <WindowsBunny> bstrie: http://i.imgur.com/QGummp2.png
[23:46:48] <Eridius> Gankro: why do you have 3 distinct-but-layout-identical types? Why not just use one type, StreamImpl, and 3 newtype structs around it? (I assume you use 3 different types because they implement methods differently)
[23:47:05] <Eridius> you can then inspect the impl's integer field to determine the correct type, wrap it in the newtype struct, and use that
[23:48:07] <WindowsBunny> bstrie: 1. Rust not being memory safe 2. Errors being printed without things actually crashing
[23:48:19] <WindowsBunny> Both leave me very worried
[23:51:02] <Gankro> Eridius: So this is what we do right now: https://github.com/pcwalton/rust-media/blob/nightly/containers/mp4.rs#L434-L608
[23:51:04] <Eridius> WindowsBunny: it appears to be inspecting the return value of a call to VirtualFree(), which from context appears to be the Win32 equivalent of munmap()
[23:51:33] <Eridius> WindowsBunny: so I'm not concerned that it's not crashing; the API obviously detects whether the address is valid or not, as opposed to doing something janky like installing a SIGSEGV handler and "recovering" from the access
[23:52:14] <Gankro> Eridius: Notably the user only ever sees boxed trait objects
[23:53:42] <Eridius> Gankro: so it looks like you're going from TrackImpl to e.g. VideoTrackImpl
[23:53:57] *** Quits: reedlepee (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[23:54:03] <Eridius> why not make VideoTrackImpl be a newtype struct around Box<TrackImpl>? So instead of using a Box<VideoTrackImpl> you just use a VideoTrackImpl
[23:54:13] <Eridius> you're wrapping it in the container::TrackType anyway
[23:55:35] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[23:55:59] <Gankro> Eridius: There are many modules that provide *TrackImpls. Users of the library never see these types, only the trait objects 
[23:56:00] <Eridius> ah hmm, judging from line 494, TrackType explicitly wants a Box<TraitObject> as its value
[23:56:42] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[23:56:42] *** ChanServ sets mode: +o pcwalton
[23:57:21] *** Quits: bdero (bran@moz-216hqv.oo5r.e4su.0006.2601.IP) (Ping timeout: 121 seconds)
[23:57:37] <Gankro> oh hey pcwalton. Do you think something like typestate would be desirable to make rust-media Track stuff cleaner?
[23:58:01] <pcwalton> you're not going to like this answer, but typestate as a language feature is not desirable ever as far as I'm concerned :)
[23:58:20] <Eridius> Gankro: does TrackType need to have an owning reference? Could you get away with having it have a &Trait instead of a Box<Trait>?
[23:58:20] <pcwalton> typestate-like patterns using the language features we already have, perhaps
[23:58:49] <Eridius> after all, by using Box<Trait>, you're requiring that the Track be moved into the TrackType, and what happens if you want to call methods from Track after you've fetched the TrackType?
[23:58:51] <Gankro> Eridius: Box<Trait> is definitely necessary to get the ownership right iirc
[23:59:08] <Eridius> I looked at the master branch and TrackType there was just an enum, so calling .track_type() didn't move the receiver
[23:59:13] <Eridius> *was just a C-like enum
[23:59:37] <Gankro> Eridius: Yeah I changed it to reduce the amount of "check what type it is and then hard-cast it"
[23:59:40] <Eridius> ah hmm, ok, looking again, the TrackType traits inherit from Track

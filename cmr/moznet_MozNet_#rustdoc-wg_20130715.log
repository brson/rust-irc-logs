[06:34:58] <Seldaek> cmr: ok I see, sad to hear
[09:41:25] <Seldaek> cmr: one thing I wasn't sure about yesterday.. should the doc frontend support multiple crates? I'd think yes, but I'm not sure if they can be rendered at once or not
[09:41:53] <Seldaek> like can you dump a json for libstd & libextra at once where all modules have their owning crate available in the json?
[09:42:11] <cmr> Seldaek: hm, not sure
[09:42:14] <cmr> Will need to think about it
[09:42:22] <cmr> the only thing it would be useful for is cross-crate hyperlinking
[09:42:29] <Seldaek> yes exactly
[09:42:46] <Seldaek> and well, for larger projects such as the language itself, that ship many crates
[09:42:57] <Seldaek> it makes sense that the doc tool documents all of them at once
[09:43:07] <Seldaek> with crosslinking and links to all crates on top or whatever
[09:43:19] <cmr> but that would require reworking how we handle type resolution, we'd need to do an extra pass to look for Paths that are to an external crate, and make sure the type IDs don't clash and soforth
[09:43:37] <Seldaek> oh I see
[09:43:48] <Seldaek> well, I could make it work so that you can provide multiple jsons I think
[09:44:31] <Seldaek> like: rustdoc.js std std.json extra extra.json
[09:44:50] <cmr> that would probably be best
[09:45:00] <cmr> and add a different object for "types that aren't in this crate"
[09:45:45] <Seldaek> hu?
[09:47:37] <Seldaek> if possible, types that are not part of the crate you analyze should be reported with their fully qualified name, like a vec in extra should refer to "type":{ "type":"fqn", "value":"std::vec" }
[09:47:47] <cmr> So right now we have a {type: "resolved", value: "35"}
[09:47:49] <cmr> right
[09:47:54] <cmr> that's what I'm saying
[09:47:58] <Seldaek> ok good :)
[09:48:28] <Seldaek> that way it could even link back to rust-lang.org docs for std/extra types when rendering docs of third party libs
[09:48:35] <Seldaek> that would be very nice
[09:49:16] <cmr> yes
[09:49:22] <cmr> this is a very elegant way to solve the problem
[09:49:55] <Seldaek> another small question because I'm not so clear on the language yet, is it possible to have two impl for Struct {} blocks?
[09:50:06] <Seldaek> besides the impl for traits that is
[09:50:17] <Seldaek> well, impl of traits for X
[09:50:45] <cmr> so like "impl Foo { ... } impl Foo { ... }"?
[09:50:50] <Seldaek> yes
[09:50:53] <cmr> yes
[09:51:16] <Seldaek> but  Iguess we could just list it as one list of Foo's method in the docs
[09:51:24] <cmr> yup that'd be best
[09:51:40] <Seldaek> ok, so if you can already resolve that at your level it's a win
[09:51:47] <Seldaek> but I don't know how that looks yet in json form
[09:53:16] <cmr> I'm thinking structs will get an additional property "traits" listing the traits they implement, where each trait is {"name": "", "methods": [...], "generics": [...]}
[09:53:44] <Seldaek> ok but there is the base impl as well no? Not all methods on a struct belong to a trait?
[09:53:58] <cmr> it'd be an empty name for that one, just to unify the representation
[09:54:05] <Seldaek> ah ok
[09:54:56] <Seldaek> I'd rather see it separated because it isn't quite the same, but not a huge deal either way
[09:59:13] <cmr> latest set of json: https://gist.github.com/cmr/618b3ab622215e6ac0be
[09:59:29] <cmr> enums are missing an "attrs" property, that is a bug
[10:00:25] <Seldaek> cool thanks
[10:00:36] <Seldaek> on the downside, crap I forgot all about enums :p
[10:00:42] <cmr> heh :)
[10:01:01] <Seldaek> where can I find one in the current docs?
[10:01:10] <cmr> http://static.rust-lang.org/doc/std/option.html
[10:01:23] <Seldaek> oh and there are types too 
[10:01:28] <Seldaek> Type VecMutRevIterator
[10:01:32] <Seldaek> crap
[10:01:35] <cmr> Yep, typedefs
[10:01:56] <cmr> https://github.com/cmr/rustdoc_ng/issues/3 has a list of everything afaik
[10:02:52] <Seldaek> ok I got the rest I think
[10:02:57] <Seldaek> apart from enum variants(?)
[10:03:02] <Seldaek> and reexports
[10:03:08] <Seldaek> but I don't know if we care about that in docs
[10:03:18] <cmr> reexports should just be listed
[10:03:30] <Seldaek> jsut make them look like they exist in two places?
[10:03:45] <Seldaek> well rather link the re-export to the original I guess
[10:04:16] <cmr> I imagine "Reexports: std::foo::*, ..." with links to the original, yeah.
[10:04:26] <cmr> Also re: cross-crate hyperlinking
[10:04:29] <Seldaek> enum variants are just the values of the enum right?
[10:05:12] <cmr> If the json has fully qualified names, we should try and standardize it so that we can give a root URL for the external docs, and be able to do like "root/std/foo" for like std::foo
[10:05:22] <cmr> Yes, and enum variants are in the JSON I just gave
[10:06:56] <Seldaek> yes obviously the external docs should be configurable somehow
[10:07:14] <Seldaek> but for std/extra we can have good defaults
[10:07:45] <cmr> As soon as we have a working-enough frontend and issue #3 is solved I think we can replace the current rustdoc.
[10:08:07] <cmr> I'd like to do it sooner rather than later because it just gets worse and worse as free functions are replaced with methods and traits.
[10:08:17] <cmr> Especially the Iterator docs are impossible to navigate
[10:08:30] <Seldaek> yeah 
[10:13:46] <Seldaek> cmr: ok just a few more idiotic questions to be sure I am on the right track
[10:14:16] <Seldaek> typedefs are they related to the type in impls? where it says impl of <trait> for <struct> where <...?>
[10:14:29] <Seldaek> is that the type of a typedef or is that just a random string 
[10:14:35] <cmr> not really
[10:14:40] <cmr> typedefs are "type foo = bar"
[10:15:13] <Seldaek> I see 
[10:15:17] <cmr> Used all over the place especially in std::libc
[10:15:27] <cmr> You get stuff like "type c_int = u32;"
[10:15:27] <Seldaek> so just aliasing of sorts
[10:15:33] <cmr> yep
[10:15:43] <cmr> gives a different name for the same type
[10:15:55] <Seldaek> ok for impls then we just show the where thing as text
[10:16:10] <cmr> the "where" is:
[10:16:22] <cmr> impl<T> Foo<T> for Bar { .. }
[10:16:27] <Seldaek> and the for <struct> part, I don't know yet how well my concept will work because it seems that for complex things like iterators/vec you can have many different representation of the struct
[10:16:32] <cmr> it's the type parameterization on the impl
[10:17:15] <Seldaek> yeah I'm just completely not 100% clear on how this stuff works yet though, never had to deal with it really in higher level dynamic languages
[10:17:30] <Seldaek> I have a vague concept in my head but I'm sure it's deeply flawed:)
[10:17:56] <cmr> I think haskell is the language most of this stuff is inspired from
[10:18:07] <cmr> which is a really really high level static language :p
[10:18:23] <Seldaek> yeah well, I didn't do any haskell :)
[10:18:30] <cmr> neither have I
[10:18:49] <Seldaek> but I especially never did anything where writing <T> is part of your daily business
[10:18:57] <Seldaek> or yearly business for that matter
[10:19:11] <cmr> formalized duck typing is how I think of it
[10:20:51] <Seldaek> ok I shall ponder that over lunch :p
[12:27:01] <cmr> I've updated the `master` branch, wip is no longer in use
[12:28:57] <Seldaek> ok though I haven't actually looked at your code at all so far
[12:29:02] <Seldaek> just interested in the json :)
[12:29:13] <cmr> that's fine ;p
[12:29:27] <Seldaek> gf started on a design earlier
[12:30:02] <cmr> any mockups you can upload somewhere? :D
[12:30:21] <Seldaek> and to get back to your timeline issue of earlier, I hope to have something usable in two weeks, given that we'll be in holidays 19-24th
[12:30:51] <Seldaek> not really no not yet
[12:31:03] <Seldaek> maybe tomorrow or later today not sure
[12:45:09] <Seldaek> cmr: another question that just came to mind.. right now I saw that the docblocks are very free-form, essentially it's a blob of markdown, and h1's are # headings and that's that
[12:45:35] <Seldaek> should we take the chance to structure this a bit more and enforce some heading names or should we just rely on common sense to sort this out?
[12:46:02] <cmr> Seldaek: I haven't come up with a good solution yet.
[12:46:13] <cmr> Having a more sturctured markup would be nice.
[12:47:12] <Seldaek> well, I don't know if we want to enforce a structure or if we just want to enforce the name of headings so that we can extract those reliably and order them consistently for example in the docs
[12:47:23] <Seldaek> depends for what obviously
[12:48:16] <cmr> not really for us to decide though, should ask the ML what it thinks
[12:48:41] <Seldaek> fair enough
[12:48:49] <Seldaek> should I write something up?
[12:49:12] <cmr> please do!
[12:59:57] <Seldaek> cmr: https://gist.github.com/Seldaek/ebb6d6745e5c9c00cfe1 any blatant omission before I send?
[13:02:40] <cmr> Seldaek: looks good to me
[13:02:52] <Seldaek> alright then
[13:04:33] <Seldaek> let's see what the collective thinks
[20:43:20] <Seldaek> cmr: if all else fails (i.e. nobody actually cares about docs, which would only half surprise me from past experience), what would be your prefered way to go forward from my email?
[21:13:12] <cmr> Seldaek: lightweight formatting conventions, but only that, conventions
[21:13:18] <cmr> I don't want full-on javadoc
[21:15:23] <Seldaek> yeah I'd rather avoid it
[21:15:25] <cmr> Although I'd like something like python's doctests
[21:15:35] <cmr> What we have now with ~~~ delineated blocks is good for that I think
[21:15:47] <Seldaek> people go nuts with doc annotations that serves no purpose with javadoc-style
[21:16:05] <Seldaek> python's doctests? are those running code samples to test the function?
[21:16:12] <cmr> Exactly
[21:16:21] <cmr> Only way to make sure your code examples in your docs actually work :)
[21:16:43] <Seldaek> indeed
[21:17:04] <Seldaek> though it means that for complex things that need a lot of bootstrap you essentially can't have trimmed down examples
[21:17:22] <Seldaek> but for simple core stuff that makes a lot of sense
[21:17:39] <Seldaek> nothing worse than trying a doc example and have it blow up in your face :)
[21:17:48] <cmr> Solution for that:
[21:17:54] <cmr> ~~~ {.before}
[21:17:57] <cmr> ~~~ {.after}
[21:18:03] <cmr> Basically pandoc's annotation format
[21:18:13] <cmr> but you can setup stuff that goes before/after a code snippet
[21:18:17] <cmr> not included in docs by default
[21:19:16] <Seldaek> oh I see
[21:19:17] <Seldaek> nice
[21:38:56] <Seldaek> cmr: err, from your sample json from before.. am I missing something or are the enums missing a name? :)
[21:39:18] <cmr> might be! jedestep added that code
[21:39:30] <Seldaek> there's just a list of variants
[21:39:35] <Seldaek> which have names
[21:39:39] <Seldaek> but the enum itself is empty
[21:39:41] <cmr> yikes
[21:39:48] <cmr> he also forgot enum attributes
[21:40:08] <Seldaek> and I'm not sure what to do with typarams & co in generics
[21:40:15] <Seldaek> but that's not a huge deal for now
[21:40:53] <cmr> they will be hard to deal with I think
[21:41:18] <cmr> in a cohesive and clear way, at least...
[22:08:13] <Seldaek> cmr: also enums have no id, I guess that's fine or can they be referenced somewhere else?
[22:10:50] <Seldaek> ah well, the variants have ids
[22:10:56] <Seldaek> so maybe it's just missing on the enum itself as well
[22:12:17] <Seldaek> anyway typarams why not but if it's a pub enum Foo<T> { Lala, } is that valid? does it make sense? Or should the typarams be present on the enum variants too?
[22:12:22] <Seldaek> I think the latter
[22:12:37] <Seldaek>  /end complaints :)
[22:16:13] <Seldaek> gotta run anyway

[00:00:07] <bjz> aatch_: maybe we need dependant types x)
[00:00:12] <bblum> maybe spawn_joining()
[00:00:15] <aatch_> since I know that `let a = b % 4;` a must be 0-3
[00:00:18] <strcat> tjc: we have an 'enum Void {}' in std::util now, and that seems like bottom
[00:00:39] <strcat> except I don't really understand what the use case is ;p
[00:00:53] <cmr> steven_is_false added it, muttering something about phantom types
[00:00:59] <cmr> none of which I understood :p
[00:01:03] <bjz> :)
[00:01:11] <tjc> strcat: Yeah, that's a good point. I added your suggestion as a comment on #7538
[00:01:11] <strcat> well I like using 'enum Opaque {}' for opaque types with FFI
[00:01:25] <tjc> I think that might actually work, since the compiler can always look up an enum to see whether it's uninhabited
[00:01:33] <tjc> and then we wouldn't need ! to be a special thing
[00:03:04] <bjz> rusti: enum ‚ä• {} fn bottom_out() -> ‚ä• { fail!() } bottom_out()
[00:03:04] -rusti- <anon>:9:14: 9:14 error: unknown start of token: 8869
[00:03:05] -rusti- <anon>:9          enum ‚ä• {} fn bottom_out() -> ‚ä• { fail!() } bottom_out()
[00:03:05] -rusti-                        ^
[00:03:05] -rusti- application terminated with error code 101
[00:03:14] * strcat wonders how clever it is
[00:03:25] <strcat> rusti: enum Foo {} let x: Option<Foo> = None; x
[00:03:26] -rusti- None
[00:03:30] <strcat> rusti: enum Foo {} let x: Option<Foo> = None; match x { None => 3 }
[00:03:30] -rusti- <anon>:9:48: 9:69 error: non-exhaustive patterns: Some not covered
[00:03:31] -rusti- <anon>:9          enum Foo {} let x: Option<Foo> = None; match x { None => 3 }
[00:03:31] -rusti-                                                          ^~~~~~~~~~~~~~~~~~~~~
[00:03:31] -rusti- error: aborting due to previous error
[00:03:31] -rusti- application terminated with error code 101
[00:03:37] <strcat> not very
[00:03:44] <cmr> Some(????)
[00:03:54] <strcat> but anyway it seems like it could treat those uninhabited enums as bottom
[00:04:31] <tjc> strcat: Yeah, it doesn't do that reasoning at all
[00:04:45] <dbaupp> rusti: enum Foo {} let x: Option<Foo> = None; match x { None => 3, Some(_) => 4 }
[00:04:46] -rusti- 3
[00:05:03] <bjz> Rust's derri√®re
[00:05:44] <nmatsakis> strcat: plan is to someday add types to represent subset of enums...
[00:06:13] <nmatsakis> strcat: http://smallcultfollowing.com/babysteps/blog/2012/08/24/datasort-refinements/
[00:06:15] <strcat> nmatsakis: so, 'enum inheritance'? ;p
[00:06:19] <nmatsakis> strcat: whereby plan I mean "something I would like to do"
[00:06:27] <nmatsakis> strcat: no, not enum inheritance. we did consider that approach (like scala)
[00:06:30] * strcat reads
[00:06:55] <bjz> how would higher order types and dependant types help these things?
[00:06:56] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[00:08:31] * bjz has no clue (yet) about those thingys
[00:08:42] <tjc> bjz: dependent types would help because you can say "this function takes a c:Color, where c is built with Red or Green"
[00:08:43] *** Quits: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:08:45] <cmr> nmatsakis: it'd be cool if you went through your older posts and modernified them
[00:08:46] <tjc> that is a very big hammer, but it works :-)
[00:09:06] <bjz> tjc: neat!
[00:09:13] <cmr> nmatsakis: updated the syntax etc
[00:09:22] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:09:35] <strcat> nmatsakis: ah this would be very neat
[00:10:08] <nmatsakis> cmr: yes, I suppose I will do so if/when we get to the point that it's worth re-proposing that idea :)
[00:10:17] <bblum> brson: if i said spawn_parented and spawn_supervised, which of those do you think better refers to 1-way failure propagation and which to the exit code propagation?
[00:10:32] <bblum> trying to decide whether to replace what spawn_supervised means today with spawn_parented or what
[00:11:15] *** Joins: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net)
[00:12:40] * strcat thinks those APIs would be clearer with a flag type
[00:13:22] <cmr> I've been thinking about flag types on and off, I don't think rust can express them properly right now
[00:13:22] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[00:13:25] *** Quits: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net) (Ping timeout)
[00:13:29] <strcat> cmr: it can
[00:13:32] <strcat> struct with a priv field
[00:13:34] <strcat> overload |
[00:13:35] <cmr> I want to be able to express that two flags are mutually exclusive etc
[00:13:50] <strcat> well you can do that dynamically
[00:14:03] <aatch_> nmatsakis, so my interpretation of that post would mean that we would just need to make sure that a given value is definitely some set of variants?
[00:14:04] <cmr> If I wanted dynamic checks, I never would have left python :p
[00:14:19] *** Quits: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de) (Ping timeout)
[00:14:27] <brson> bblum: i guess parented sounds like 'exit code propagation' and supervised sounds like 1-way
[00:14:29] <cmr> I think this is what dependent types are, but I'm not sure, not enough knowledge of that field of knowledge
[00:14:36] <brson> bblum: I'd rather not have even more ways to link tasks though
[00:14:39] <strcat> cmr: but if you have MagicFlag, and you want to OR in another flag
[00:14:46] <strcat> how do you handle the case where a conflicting flag is set?
[00:14:51] <aatch_> cmr, I'm not sure you can statically check something like that.
[00:15:05] <aatch_> not without making it obscenely complicated to use.
[00:15:11] <strcat> cmr: https://github.com/thestinger/rust-magic/blob/master/magic.rs#L17 it at least works well when none of them conflicts
[00:15:15] <cmr> right
[00:15:21] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[00:15:23] <cmr> strcat: there's also enum_set which was recently added
[00:15:24] <bblum> brson: well, they're kind of orthogonal behaviours
[00:15:31] <cmr> strcat: I think this is what it handles
[00:15:38] <bblum> brson: aaron came up with "spawn_watched" for the join latch behaviour, which i currently like best
[00:15:54] * strcat wants his flags to be magical though
[00:16:32] <strcat> and magic cookies
[00:16:40] <strcat> libmagic <3
[00:16:48] <cmr> https://github.com/mozilla/rust/blob/6fcd8bf5677652f31008cde5f9f9f00fe67d90b8/src/librustc/util/enum_set.rs
[00:17:58] *** Joins: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de)
[00:18:06] <nmatsakis> aatch_: the idea would be to extend the type system to let you express that, right
[00:18:13] <aatch_> nmatsakis, cool
[00:18:19] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (NickServ (GHOST command used by aatch_))
[00:18:20] <bblum> brson: you're missing a great discussion here
[00:18:27] *** aatch_ is now known as aatch
[00:18:31] <bblum> ew're talking about task::hatch, task::birth, task::hemmorhage, etc
[00:18:34] *** Joins: aatch_ (aatch@moz-B437F499.pocketrent.com)
[00:18:46] <aatch> bah, stupid work computer.
[00:19:14] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[00:19:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d1b95f3 to 14e482856: 02http://git.io/N3iJvQ
[00:19:14] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[00:19:16] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:19:17] <ghrust> 01[13rust01] 15bors pushed 20 new commits to 06auto: 02http://git.io/4UrIvQ
[00:19:17] <ghrust> 13rust/06auto 1471f186a 15Niko Matsakis: Update existing tests to account for stricter, more correct handling of irrefutable patterns
[00:19:17] <ghrust> 13rust/06auto 14bc73057 15Niko Matsakis: Add new tests for irrefutable patterns used in various tricky ways
[00:19:17] <ghrust> 13rust/06auto 14e9469b6 15Niko Matsakis: update ptr intrinsics and rewrite vec routines to be more correct....
[00:19:19] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:20:18] *** Quits: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de) (Ping timeout)
[00:20:37] <cmr> I think the buildbots are broken again
[00:21:15] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[00:22:22] <aatch> bah, screw it, I'll do another snapshot once the bots are fixed again.
[00:22:43] <brson> i don't think we'll be able to get 0.7 released tomorrow
[00:22:45] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[00:22:47] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[00:22:55] <bstrie> brson: code snippet status: strcat objected to featuring iterators in their half-baked state, so I'm back to the drawing board
[00:23:15] <bstrie> s/drawing board/key board
[00:23:45] <strcat> well I think you could show an iterator example
[00:23:56] <strcat> but that one showcases all the current warts :(
[00:23:59] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[00:24:15] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[00:25:19] <brson> bblum: I can't come up right now, but I'm excited to hear the pitch tomorrow
[00:25:30] <bblum> i don't think those are the names we are going to use :P
[00:25:36] <bblum> i'm going with spawn_watched for now
[00:26:00] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[00:26:07] <strcat> bstrie: and there are some at http://static.rust-lang.org/doc/tutorial-container.html#iterators already
[00:26:10] <toddaaro> as long as we get pheonixing into the future actor library I'll be happy
[00:26:11] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[00:26:48] <nmatsakis> brson: was there an issue with the task ring benchmark?
[00:27:47] <brson> nmatsakis: it was ooming for a while, yes
[00:28:08] <nmatsakis> brson: ok, because I'm encountering some issues with it on my branch all of a sudden :)
[00:28:18] <nmatsakis> brson: though it worked before...
[00:28:26] <strcat> nmatsakis: un-inline the exchange alloc stuff
[00:28:31] <strcat> nmatsakis: it seems like it would be simpler to not bubble up the annotation though
[00:28:45] * strcat shrugs
[00:29:06] <nmatsakis> strcat: I think I must be missing some context
[00:29:33] <nmatsakis> strcat: what did we change?
[00:29:36] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Ping timeout)
[00:29:37] <strcat> nmatsakis: I stopped the initialization/reading/writing of exchange alloc headers, and at the same time I inlined the rt::global_heap stuff
[00:29:57] <cmr> btw someone linked to http://static.rust-lang.org/doc/core/files/vec-rs.html#vec.reverse earlier today, and I think I quite like how it looks, design-wise
[00:29:59] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[00:30:02] <strcat> so currently, codegen ends up putting the libc::free call (right now to the wrapper) and malloc call directly in the code
[00:30:19] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[00:30:53] <strcat> nmatsakis: https://github.com/mozilla/rust/blob/master/src/libstd/rt/global_heap.rs#L79
[00:31:52] <nmatsakis> strcat: I see. And what do you mean "not bubbling up the annotation"?
[00:32:01] <nmatsakis> strcat: we can't call malloc without giving it enough stack...
[00:32:06] <strcat> nmatsakis: could the fixed_stack_size annotation just be on the foreign call, I mean
[00:32:20] <nmatsakis> strcat: well, it IS, but that doesn't really address the problem, at least not on my branch.
[00:32:37] <nmatsakis> strcat: or maybe I don't get what you mean
[00:32:46] <strcat> so if you called malloc twice in row it would just grab and release a stack segment twice
[00:32:49] <strcat> in a lightweight task
[00:32:52] <nmatsakis> strcat: I mean, the annotation is on the *caller*
[00:33:23] <nmatsakis> strcat: I see, well, that's really no different in the end from marking malloc_raw as inline(no)
[00:33:38] <strcat> nmatsakis: except that LLVM knows what the malloc symbol is
[00:33:50] <nmatsakis> strcat: well, you can't actually "annotate a call",
[00:33:54] <nmatsakis> strcat: so what would wind up happening in LLVM land,
[00:33:59] *** Quits: mcstar (mcstar@moz-D7A16997.monradsl.monornet.hu) (Ping timeout)
[00:34:01] <nmatsakis> strcat: is that we would call a C helper fn that does the stack switch,
[00:34:03] <strcat> nmatsakis: well we output a signature for malloc
[00:34:09] <nmatsakis> strcat: and it would invoke malloc indirectly,
[00:34:12] <strcat> couldn't we just add fixed_stack_size to that signature?
[00:34:14] <nmatsakis> strcat: which would ultimately obscure far more
[00:34:38] <nmatsakis> strcat: no, fixed_stack_size must be applied to a function that we are *generating*, since it just affects what the fn requests from more stack 
[00:34:44] <strcat> ah
[00:35:00] <strcat> I thought it tricked LLVM into doing a big alloca
[00:35:08] <strcat> well
[00:35:11] <strcat> assuming there was a big alloca*
[00:35:36] <cmr> tjc: so to get the sysroot it seems you do os::self_exe_path().get().pop(), and when I run that in rusti I get ~/.local, but when I use that code from rustdoc2 I get $PWD/.. :\
[00:36:03] <strcat> nmatsakis: it seems to me that when you have a lightweight task, you value memory usage over perf, and that we'll need an API to spawn tasks without them
[00:36:14] <tjc> cmr: Hmm, it should give you the directory-part of the path to the executable that's running
[00:36:22] <tjc> so if you have rusti installed in ~/.local
[00:36:25] <tjc> that's what it would be
[00:36:28] <nmatsakis> strcat: well, it sort of tricks llvm into making an alloca, but that's not literally what it does
[00:36:32] <cmr> tjc: ohhh, and rustdoc2 is in the current working dir... right
[00:36:45] <brson> nmatsakis: it was xfailed for a long time and I only turned it back on recently. I would expect it to oom on your ffi branch because of the reasons we've discussed
[00:36:58] <cmr> tjc: but that doesn't help me resolve paths to crates :( should I just copy it into ~/.local/bin for testing?
[00:36:59] <tjc> cmr: Yeah, I was kind of assuming that everything would be in the rust tree, rather than installed somewhere arbitrary -=-
[00:37:03] <tjc> that's true on the bots, anyway
[00:37:17] *** Quits: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net) (Ping timeout)
[00:37:18] <cmr> tjc: well, it's a logical assumption :)
[00:37:26] <tjc> cmr: if you have all of Rust (including libraries) installed in ~/.local, then yes, I'd say so
[00:37:26] <nmatsakis> brson: and indeed it does, though it's not ... entirely clear to me why to be honest, unless it's the calls to malloc as strcat indicated, though when I examined the assembly with -S it was not evident that any of the imp't fns were requesting a big stack,
[00:37:41] <nmatsakis> brson: but perhaps I needed to compile with -O or something to trigger the inlining
[00:38:01] <cmr> tjc: and that was the missing key to the puzzle! yay, it works :)
[00:38:04] <strcat> nmatsakis: if it's inlinealways, it inlines at -O0
[00:38:08] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[00:38:10] <tjc> cmr: \o/
[00:38:21] <strcat> inlinehint (#[inline]) is only -O2 and above
[00:38:25] <strcat> so, rustc's -O
[00:38:25] <cmr> ETA of rustdoc2: a week ;)
[00:38:28] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[00:39:00] <strcat> (and at -O2 and above it's doing inlining itself, inlinehint just skews the cost)
[00:39:33] <sully> strcat: hm, I'm not sure how I feel about ZipIterator silently ending if the two iterators are different lengths
[00:40:05] <strcat> sully: well it's what it does in haskell and python and I don't really know what else it would do
[00:40:13] <brson> nmatsakis: just speculating, but what happened last time was because the spawn function itself uses the ffi and also sends messages. so spawn is holding onto a big stack while yielding
[00:40:28] <sully> strcat: well, the previous behavior of rust's zip function was to fail
[00:40:50] <sully> strcat: and there were bugs of mine in the compiler that this caught that I think would have been nightmares to find otherwise
[00:40:55] <cmr> Does anyone else think a println!() would be a good idea? I use println(fmt!(...)) almost constantly when debugging
[00:40:56] <sully> strcat: honestly, I think both behaviors are useful, though
[00:40:57] <nmatsakis> brson: I see, perhaps that is it. I was looking at the *spawned* functions,
[00:41:04] <nmatsakis> brson: but I didn't look at the spawn function 
[00:41:10] <strcat> sully: well python also has zip_longest
[00:41:19] <strcat> where it returns (1, None) once it's past the end of one
[00:41:21] <strcat> but it's painful in rust
[00:41:34] <engla> cmr: of course
[00:41:38] <strcat> (Option<T>, Option<U>)
[00:41:51] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[00:42:42] <bblum> ok can someone help me with this
[00:42:55] *** Quits: bjz (brendanzab@moz-D2E3CABC.lns6.cha.bigpond.net.au) (Quit: Bye!)
[00:43:00] <bblum> i'm trying to make check-stage0-std and whenever it tries to build the stdtest binary i get
[00:43:01] *** Joins: bjz (brendanzab@moz-D2E3CABC.lns6.cha.bigpond.net.au)
[00:43:03] <bblum> /home/bblum/rust/src/libstd/std.rs:1:0: 1:0 error: can't find crate for `extra`
[00:43:10] <bblum> i can build stage1 stdtest just fine
[00:43:22] <strcat> bblum: it needs to be stage1 afaik, so it has libextra
[00:43:27] <strcat> because the test runner uses it
[00:43:34] <bblum> why can't it just use stage0 extra
[00:43:41] <acrichto> bblum: build a stage1 compiler and then modify libstd and run 'make check-stage1-std NO_REBUILD=1'
[00:43:52] <bblum> hmm sigh
[00:44:03] <bblum> yeah that works acrichto 
[00:44:06] <strcat> bblum: don't really understand our makefile at all so I can't give you a real answer :)
[00:44:20] <strcat> it just barely works for the regular use cases ;p
[00:44:40] <acrichto> bblum: also I think the metadata changed recently, so it's looking for 0.7 extra and the snapshot may only have 0.7-pre
[00:46:41] <strcat> vec.rs is really a pain
[00:47:18] <strcat> starting to think I should give up for now and make vectors not call exchange_malloc
[00:47:22] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[00:47:47] <bblum> acrichto: but make clean usually solves that
[00:48:00] <strcat> easy to generate different code for unique-managed and unique in trans but not so much when dealing with it in the lib :(
[00:48:14] <cmr> tjc: will you be available tomorrow? I'd like to use rustpkg with rustdoc2 but I'm sure I'm going to stumble around a lot trying to figure it out :)
[00:48:24] <acrichto> bblum: that's when you're building libraries, but you're using stage0 libraries that aren't cleaned (stdtest-stage0 wants 0.7 libextra, but the snapshot only has 0.7-pre)
[00:48:30] <tjc> cmr: Sure, I'll be around 10-5 Pacific time tomorrow, at least
[00:48:32] <acrichto> bblum: at least maybe, it could also just be broekn make
[00:48:36] <cmr> tjc: cool, thanks
[00:48:40] <tjc> I'd be happy to help with rustpkg
[00:48:52] <bblum> acrichto: oh, i see
[00:48:55] <bblum> that is a good guess
[00:49:23] <cmr> tjc: you're still designing rustpkg with the goal of it being the build tool used for rustc, right?
[00:50:13] <tjc> cmr: Yes, that's the goal
[00:50:37] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[00:50:51] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[00:51:36] <dbaupp> strcat: that just puts the header on the vector, not the individual elements, right?
[00:51:56] <dbaupp> strcat: (so the cost of the header is amortised across the whole thing, i.e. it's not that bad.)
[00:51:59] <strcat> dbaupp: yeah ~[] is an exchange_alloc call
[00:52:21] <strcat> I could make ~T a separate allocator for now... :(
[00:52:21] *** Quits: bjz (brendanzab@moz-D2E3CABC.lns6.cha.bigpond.net.au) (Quit: Leaving...)
[00:52:31] <strcat> I already had to split ~fn
[00:52:35] <strcat> it's just a mess
[00:54:18] <strcat> brson: hm, why do we have both create_stack and create_exchange_stack? what's an exchange stack?
[00:56:40] <strcat> oh it's the C FFI stack
[00:56:48] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[00:57:47] <sully> hm, it would be sort of nice if there was a way to do a... partial type annotation
[00:57:56] <sully> like, I want to say "hey, this is an array"
[00:58:08] *** Joins: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca)
[00:58:39] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[00:58:57] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[00:59:39] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[00:59:47] <strcat> rusti: type Foo<T> = std::hashmap::HashMap<T, int>;
[00:59:48] -rusti- ()
[00:59:54] <strcat> sully: not really what you want but...
[00:59:58] <strcat> similar
[01:00:09] *** Joins: BL1969 (chatzilla@moz-D5AEE09B.torservers.net)
[01:00:42] *** Parts: BL1969 (chatzilla@moz-D5AEE09B.torservers.net) ()
[01:00:43] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:00:59] <strcat> I guess you want 'let xs: Foo<int, _> = ...' where it infers the _
[01:01:04] *** Joins: BL1969 (chatzilla@moz-D5AEE09B.torservers.net)
[01:01:13] <bblum> brson: hm, i just realized that depending on what exact functionality you want out of spawn_watched, you might not have to use arc unwrap at all
[01:01:23] <BL1969> #b
[01:01:28] *** Parts: BL1969 (chatzilla@moz-D5AEE09B.torservers.net) ()
[01:01:37] <bblum> by this i mean: currently, i have a parent task block on all children, and deal with its own failure status, which includes killing other tasks in the taskgroup
[01:02:06] <bblum> but if all you care about is sending the return status (over the notify_port), you can just put the notifier in the ARC itself, and have the arc's destructor send the accumulated value over the port
[01:02:12] <bblum> and the destructor will be run by any of the children
[01:03:11] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Client exited)
[01:03:37] <dbaupp> strcat: that'd be really nice for .collect()
[01:03:50] <strcat> dbaupp: true
[01:04:02] <strcat> .collect::<~[_]>
[01:04:10] <strcat> .collect::<HashSet<_>>
[01:04:12] <bblum> brson: the new runtime doesn't have a story for tasks getting each other's exit statuses yet, does it? seems like JoinLatch is just used for the main task setting the process exit code atm
[01:04:44] <dbaupp> strcat: yeah
[01:06:53] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:07:01] <cmr> aatch: ping
[01:07:07] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[01:07:07] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1483f8138 to 14e482856: 02http://git.io/N3iJvQ
[01:07:07] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[01:07:09] <aatch> cmr, pong
[01:07:11] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[01:07:11] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/SXK30Q
[01:07:11] <ghrust> 13rust/06auto 149e6d5e1 15Niko Matsakis: Defer reasoning about region relationships until after regionck....
[01:07:11] <ghrust> 13rust/06auto 1442344af 15Niko Matsakis: Correct handling of if/match, and make explicit computation of...
[01:07:11] <ghrust> 13rust/06auto 1479ea266 15Niko Matsakis: move docs into doc.rs
[01:07:12] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[01:07:40] <cmr> aatch: Is the trait-based ast visitor in a working-enough state that it could go into the tree, albeit in a minorly-used state?
[01:08:04] <bblum> brson: i think we should probably figure out the story for task::try before deciding the particulars of this... do we just wanna use a notify port?
[01:08:04] <aatch> cmr, it works perfectly in the cases I've used it in so far.
[01:08:07] <bblum> like before?
[01:08:21] <aatch> though it needs a snapshot to be usable in the compiler
[01:08:38] <cmr> aatch: that's fine for me, I'd be using it out-of-tree for rustdoc2 for a while to come
[01:08:42] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[01:08:58] <aatch> cmr, I think my visitor_new branch still 1. exists and 2. has it.
[01:09:25] <cmr> https://github.com/aatch/rust/tree/new_visitor, yup
[01:10:08] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[01:11:02] <aatch> cmr, it's just the visit_new.rs file.
[01:11:18] <cmr> aatch: I'll cherry pick it over for new
[01:11:21] <aatch> you'll have to edit the imports etc, but that's it.
[01:11:31] <cmr> *now
[01:12:49] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[01:13:05] <Thad> Hi guys !
[01:13:10] <brson> bblum: JoinLatch takes an on_exit closure that can be used to send a message right before a task is terminated. this is used to implement task::try on my branch
[01:13:12] <aatch> Hey, is there any reason for the current way we handle command-line arguments, other than legacy reasons?
[01:13:45] <strcat> aatch: which quirk in particular?
[01:13:46] <brson> aatch: 'the current way we handle command-line arguments' is rather vague?
[01:13:51] <strcat> -W vs -Z is especially bad
[01:13:52] <cmr>  
[01:14:03] <strcat> -W takes a comma-separated list and can be passed once
[01:14:13] <strcat> -Z doesn't take a comma-separated list, and can be passed multiple times ;p
[01:14:25] <aatch> I know, I meant in general for executables.
[01:14:42] <strcat> aatch: as in argc/argv/envp in rust_start?
[01:14:45] <strcat> or whatever it has
[01:14:48] <aatch> strcat, yep
[01:14:58] <strcat> oh because you want that aux thing
[01:15:18] <aatch> partially, partially because I think the current way is insane
[01:16:16] <aatch> I was wondering what reason, if any, there was for it.
[01:16:29] <strcat> seems like it should leave them alone and os::args should just be &'static [u8] slices
[01:16:49] * strcat hopes it isn't currently str, but it probably is
[01:16:53] <aatch> strcat, that's kinda what I was thinking.
[01:17:07] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[01:17:07] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Client exited)
[01:17:07] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[01:17:14] <cmr> I'd r+ that
[01:17:18] <bblum> brson: on the io branch? i don't see it
[01:17:28] <bblum> i see the on exit handler being separately stored in the task
[01:17:54] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[01:18:26] <dbaupp> strcat: os::args() -> ~[~str], yes
[01:18:47] <strcat> should be &'static [&'static [u8]]
[01:18:49] <dbaupp> rusti: let x: ~[~str] = std::os::args(); x
[01:18:51] -rusti- ~[~"./out"]
[01:18:59] <dbaupp> strcat: yes
[01:19:04] <strcat> assuming it can make a static slice in the scheduler thread
[01:19:08] <strcat> I think that makes sense
[01:19:21] <strcat> depends on what static is supposed to mean ;p
[01:19:35] <cmr> always valid I thought
[01:19:40] <strcat> it will be
[01:19:42] <aatch> strcat, well, on 64-bit linux anyway, it's just on the stack
[01:19:45] <cmr> right
[01:19:58] <cmr> I see no problems using &'static
[01:19:59] <strcat> aatch: yes they're mutable too
[01:20:09] <strcat> aatch: but if you mutate them you ruin the info in /proc :D
[01:20:15] <aatch> strcat, so, we can pretend they're not.
[01:20:19] <strcat> avahi mutates them
[01:20:30] <strcat> playpen does too because I'm lazy :)
[01:20:30] <cmr> why
[01:20:35] <strcat> cmr: because it's convenient
[01:20:42] <strcat> cmr: getopt mutates argv too
[01:20:44] <strcat> it reorders them
[01:20:57] <strcat> it puts switches first
[01:21:06] <strcat> so it can let you have an argv array with arguments at the end
[01:21:11] <aatch> at any rate, I was thinking that os::args should just be an extern static
[01:22:50] <dbaupp> aatch: that'd work too... but is it actually possible to implement atm?
[01:23:10] <strcat> you can fake a lifetime, yes
[01:23:14] <strcat> if you mean 'static
[01:23:28] <aatch> strcat, yep
[01:23:46] <brson> bblum: it's spawn_raw_newsched. on_exit sends a message on notify_chan
[01:23:51] *** Joins: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca)
[01:23:59] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[01:24:16] <brson> I'm going to disable rusti tests again because they are failing on dist-snap
[01:24:43] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[01:24:51] <bblum> ohhh
[01:24:52] <steven_is_false> What happens if one fails while in a with block for the Exclusive datatype? I know in the docs it says that though people are working to change it it's a bad idea to do any sort of scheduling like recv.
[01:24:55] <bblum> spawn_raw_newsched has gotten bigger
[01:27:31] <strcat> aatch: we should figure out how to tag all function pointers (traits, closures, extern fn) as llvm.invariant
[01:27:38] <strcat> so we get devirtualization
[01:28:07] <cmr> http://rustlog.octayn.net/post/54389887000/status-update, good night all
[01:28:25] <aatch> yeah, not sure how you do that. I haven't actually checked the docs for it yet.
[01:28:35] <strcat> aatch: I think it's an instruction you have to emit
[01:28:47] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[01:29:03] <aatch> well an intrinsic.
[01:29:11] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[01:31:09] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[01:31:31] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130625125232])
[01:34:38] *** Quits: eholk (eholk@moz-BF0BB923.uconnect.utah.edu) (Quit: eholk)
[01:36:39] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[01:36:39] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/pt8X-g
[01:36:39] <ghrust> 13rust/06master 1477b9824 15Brian Anderson: Ignore all rusti tests. #7541
[01:36:39] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[01:36:55] <aatch> Grr, the scheduler is a problem...
[01:36:59] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[01:36:59] <ghrust> 01[13rust01] 15brson merged 06master into 06dist-snap: 02http://git.io/5cbOHg
[01:36:59] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[01:37:13] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:37:14] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[01:37:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143b966d4 to 1477b9824: 02http://git.io/N3iJvQ
[01:37:14] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[01:37:16] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[01:37:16] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/HQAPKQ
[01:37:16] <ghrust> 13rust/06auto 149e6d5e1 15Niko Matsakis: Defer reasoning about region relationships until after regionck....
[01:37:16] <ghrust> 13rust/06auto 1442344af 15Niko Matsakis: Correct handling of if/match, and make explicit computation of...
[01:37:16] <ghrust> 13rust/06auto 1479ea266 15Niko Matsakis: move docs into doc.rs
[01:37:17] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[01:38:13] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[01:41:14] <strcat> meh a bunch of builders are stuck
[01:42:07] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[01:43:44] <acrichto> aww the dist-snap branch is gonna fail
[01:43:49] <acrichto> brson modified the wrong rusti file
[01:43:59] <acrichto> he's not around to merge https://github.com/mozilla/rust/pull/7542 either :(
[01:44:45] <tjc> acrichto: I approved it instead :-)
[01:44:56] <acrichto> tjc: thanks! although is bors wedged?
[01:45:02] <tjc> acrichto: not sure
[01:45:04] <acrichto> bors doesn't seem to like forced pushes to master
[01:45:49] <tjc> seems like some builds got interrupted but it's re-running
[01:46:05] <strcat> acrichto: it's buildbot's fault
[01:46:10] <strcat> it lost 4 buildslaves
[01:46:19] <strcat> as in they got wedged on git clones
[01:46:19] <acrichto> oh dear that's a lot
[01:46:23] <strcat> it fails at killing them
[01:46:30] <strcat> acrichto: well lost 4 builds*
[01:46:41] <strcat> the buildslaves are capped at a # of builds so it wastes them
[01:47:04] <strcat> acrichto: https://github.com/mozilla/rust/issues/7515
[01:47:13] <sully> oh no, it is an llvm rebuild
[01:47:14] <strcat> I guess graydon isn't around because it's canada day
[01:47:28] <acrichto> yeah it looked like there were some other ones wedged in git updating
[01:47:30] <acrichto> sully: my bad
[01:47:42] <sully> eh
[01:47:51] <strcat> acrichto: so there are at least 4 wedged mac builds
[01:47:52] <sully> it was about time to call it a day anyways
[01:47:55] *** Joins: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net)
[01:48:00] <strcat> and they are capped at 3 or 4 builds each
[01:48:15] <strcat> anyway going to take 2x or 3x as long for stuff to land
[01:48:51] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[01:48:54] <strcat> unless something (tjc?) can restart buildbot
[01:49:06] <tjc> strcat: If I can remember how...
[01:49:13] <strcat> flimsiest software ever ;p
[01:49:36] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[01:50:01] <strcat> tjc: or just restart the mac3 and mac4 builders? dunno
[01:50:34] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[01:50:58] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[01:51:13] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[01:51:24] <tjc> strcat: hmm, not sure whether I have a username for buildbot
[01:51:32] <tjc> sorry, will have to wait until brson or graydon is back
[01:51:34] <acrichto> tjc: shouldn't it be rust/rust ?
[01:51:41] <tjc> acrichto: ah, maybe!
[01:51:46] <acrichto> at least that works for cancelling builds
[01:51:56] <tjc> ...nope
[01:52:01] <tjc> maybe I can ssh in
[01:52:23] <btipling> so a pointer is word size? on a 64bit machine a pointer takes up 8 bytes?
[01:52:38] <SiegeLord> rusti: fn test(a : int,) {}
[01:52:38] -rusti- <anon>:9:25: 9:26 error: unexpected token: `)`
[01:52:38] -rusti- <anon>:9          fn test(a : int,) {}
[01:52:39] -rusti-                                   ^
[01:52:39] -rusti- application terminated with error code 101
[01:52:50] <strcat> btipling: not always, depends on the OS
[01:52:58] <tjc> nope, apparently my SSH key isn't on mac3 or mac4
[01:53:02] <tjc> good time to go home =P
[01:53:12] <strcat> a pointer on a 64-bit machine is usually 8 bytes though. if the OS/program is 64-bit
[01:53:17] <btipling> ok
[01:53:32] <SiegeLord> Hmm, maybe it'd be nice if trailing comma was accepted in function parameter lists
[01:53:41] <SiegeLord> It's accepted pretty much everywhere else
[01:53:46] <strcat> but you can have an x86 or x32 (a quirky new linux ABI) programs on x86_64 machines
[01:54:01] <btipling> ah
[01:54:11] <strcat> btipling: https://en.wikipedia.org/wiki/X32_ABI
[01:54:13] *** Quits: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca) (Quit: lmandel)
[01:55:17] *** Joins: fabiand_ (fabiand@moz-DA383042.adsl.alicedsl.de)
[01:56:08] *** Quits: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de) (Ping timeout)
[01:56:09] <btipling> I can see the benefit of having smaller pointer sizes
[02:01:43] <mark_edward> but there are benifits to bigger ones to
[02:01:50] <mark_edward> more memory addresses possible
[02:06:16] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Quit: )
[02:07:28] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[02:08:00] <jmgrosen> is there a reduce function?
[02:08:55] <strcat> fold
[02:09:08] <jmgrosen> ah, thanks
[02:09:35] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().fold(|a, &b| a + b)
[02:09:36] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jFgW
[02:09:39] <btipling> hrm, the borrowed pointer lets you take the address to something on the stack, I don't remember that in C
[02:09:48] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().fold(0, |a, &b| a + b)
[02:09:49] -rusti- 6
[02:10:01] <btipling> I think I've always assumed pointers meant data is on the heap
[02:10:06] <strcat> btipling: you can take an address of anything in C that's not 'register'
[02:10:12] <btipling> ah
[02:10:16] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[02:10:26] <sanxiyn> r? https://github.com/mozilla/rust/pull/7543
[02:10:41] <sanxiyn> This is a rebase of a pull request that got closed in incoming->master transition
[02:11:11] <btipling> then you can tell it's on the stack or heap by the address?
[02:11:16] <strcat> btipling: no
[02:11:41] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[02:12:09] <strcat> the "stack" is just address space allocated by the application to put the call stack on
[02:12:20] <strcat> it's not actually a real thing, it's just a usage pattern
[02:13:30] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Quit: Leaving)
[02:13:44] <sanxiyn> strcat: Well it is as real as any?
[02:13:52] <strcat> I mean it's just memory
[02:14:01] <sanxiyn> Ah
[02:16:20] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[02:17:05] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[02:17:41] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:21:44] *** Joins: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de)
[02:24:30] *** Quits: tjc (tjc@2557E599.66715431.D25A875A.IP) (Quit: Places to go, people to annoy)
[02:25:48] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:28:35] <MaikKlein> does anyone know what zeromq really is?
[02:29:17] <dcolish> what do you mean?
[02:29:58] <sanxiyn> MaikKlein: ZeroMQ is a networking library?
[02:31:00] <MaikKlein> that's what I don't know. it seems it is only good for passing messages between processes or sth similar
[02:31:16] <MaikKlein> so it a fully featured networking library?
[02:31:21] <dcolish> yes
[02:31:35] <dcolish> well its an abstraction for message passing architectures
[02:32:02] <MaikKlein> something that could be used for games?
[02:32:13] <dcolish> i dont see why not
[02:32:21] <sanxiyn> MaikKlein: If you mean whether you can use it between different machines, I think yes
[02:32:39] <dcolish> you absolutely can use it between machines
[02:33:04] <dcolish> that's its primary purpose
[02:33:21] <MaikKlein> I wanted to build some actors in rust. But I really want to have some remote actors
[02:33:25] <MaikKlein> ok then I do some digging
[02:33:27] <MaikKlein> thanks!
[02:33:44] <dcolish> Ah cool, I'd really recommend reading the zmq guide
[02:33:52] <dcolish> its well written and has a lot of examples
[02:33:58] <MaikKlein> yeah I hear that a lot
[02:40:24] *** Parts: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Leaving)
[02:42:07] <sully> hm, weird build failure
[02:42:09] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:42:09] *** ChanServ sets mode: +o dherman
[02:43:11] *** Joins: cr (anonymous@moz-25A98384.dip0.t-ipconnect.de)
[02:43:19] <MaikKlein> haha thats a long guide
[02:44:17] <MaikKlein> what lib does rust just for message passing?
[02:44:29] <MaikKlein> if I saw correctly it uses something from node.js?
[02:46:16] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[02:49:29] <roo> I am really liking once functions, I hope they don't disappear or something
[02:49:47] <MaikKlein> for what are they good?
[02:50:04] <roo> high order functions
[02:50:52] *** Quits: kimundi (kimundi@moz-58389D08.dip0.t-ipconnect.de) (Ping timeout)
[02:50:57] <MaikKlein> ?
[02:51:15] <MaikKlein> when would I want to use a once function?
[02:52:06] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[02:53:11] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[02:54:21] *** Joins: kimundi (kimundi@moz-D2CF7906.dip0.t-ipconnect.de)
[02:58:05] *** Joins: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net)
[02:58:05] *** kimundi is now known as zz_kimundi
[02:58:28] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Client exited)
[02:59:17] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[02:59:55] *** Quits: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de) (Ping timeout)
[03:01:04] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[03:01:07] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[03:04:37] <bblum> roo: can you tell me about your use case
[03:04:49] <bblum> do you wanna use them for heap closures (like task spawn) or for stack closures?
[03:04:59] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[03:05:13] <bblum> unfortunately, the plan is for them to not be enabled on stack closures, and for heap closures to be replaced with something else
[03:05:25] <roo> heap closures
[03:05:55] <roo> hmm
[03:06:41] <roo> Well I am writing a parser combinator a similar to parsec
[03:07:26] <bblum> the plan is for heap closures to be replaced by traits that can be generated by a macro
[03:07:44] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[03:07:44] *** ChanServ sets mode: +o brson
[03:07:48] <bblum> the 'once' functionality will instead be fulfilled by the option to have by-value self
[03:10:20] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[03:14:09] <roo> Well i guess that is kind of a bummer. I like that currently I can express this sort of thing in terms of high order functions. Does not seem like I could do that with stack-only closures.
[03:14:19] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:15:02] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[03:15:10] <roo> My current understanding of 'returning something owned' is allocating it on the heap
[03:15:31] <bblum> that's correct
[03:15:47] <bblum> i don't mean higher-order heap functions will be impossible; they will just look different
[03:15:51] *** Joins: sankha93 (Instantbir@4C1B4135.A5E24E6D.8B6C1D65.IP)
[03:16:06] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:16:13] <bblum> something like "lambda_once!(a, b, c => ... closure body ...)"
[03:16:44] <bblum> which will expand to a struct that fulfills the trait ClosureOnce<ArgType, ReturnType>
[03:16:54] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[03:17:31] <roo> Ah, well then that is a net 0. As long as something gets me to the ballpark of the same sort of thing
[03:17:53] <bblum> yeah
[03:18:06] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[03:19:11] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[03:19:58] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[03:22:30] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Ping timeout)
[03:25:16] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[03:25:16] *** ChanServ sets mode: +o brson
[03:26:15] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[03:33:06] *** Joins: pauls_ (paul@moz-9B39917C.c3-0.smr-ubr2.sbo-smr.ma.cable.rcn.com)
[03:33:53] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[03:36:06] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Ping timeout)
[03:40:03] *** Quits: indirect (indirect_m@moz-770AB053.hsd1.ca.comcast.net) (Ping timeout)
[03:42:13] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[03:43:28] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[03:43:33] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Quit: Leaving)
[03:43:41] *** Quits: heftig (heftig@moz-71A49FFB.dip0.t-ipconnect.de) (Ping timeout)
[03:43:52] <bblum>  6 files changed, 38 insertions(+), 707 deletions(-)
[03:44:09] <bblum> just hafta hope the tests still pass
[03:45:47] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[03:46:01] <btipling> test as you develop?
[03:46:02] <btipling> :\
[03:46:51] <bblum> that's what i'm doing
[03:47:26] <Luqman> bblum: but first you must build the compiler :P
[03:47:44] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[03:48:02] *** Joins: heftig (heftig@moz-AA4684.dip0.t-ipconnect.de)
[03:50:02] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[03:50:22] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[03:52:53] <btipling> the destructor and the destructuring pattern are separate things right, one cleans up memory, the other binds data to a variable
[03:54:33] *** Quits: cowboyd (cowboyd@moz-DD0FF83.lightspeed.austtx.sbcglobal.net) (Client exited)
[03:55:37] <bblum> btipling: true, and in fact you can't use the latter on a type that has the former
[03:58:37] <btipling> I read the destructor section in the tutorial, still reading it on vectors section
[03:58:58] <btipling> the destructors section didn't actually provide an example of a destructor I think
[03:59:35] <btipling> http://static.rust-lang.org/doc/tutorial.html#destructors
[04:01:52] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[04:02:02] <strcat> btipling: it's covered in the ffi tutorial
[04:02:03] <btipling> I don't see an example of a destructor in http://static.rust-lang.org/doc/rust.html neither
[04:02:07] <btipling> hrm
[04:02:21] <btipling> http://static.rust-lang.org/doc/tutorial-ffi.html#destructors
[04:02:21] <btipling> ah
[04:02:42] <strcat> needs to be updated a bit
[04:03:25] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:03:44] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:04:19] <btipling> is it rare to create destructors?
[04:04:47] <btipling> like I'd only write my own if I were using C libraries or the like?
[04:05:12] <btipling> or also when I create owned boxes?
[04:06:36] <btipling> looks like owned boxes are freed when the owning variable goes out of scope
[04:06:44] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:07:24] <strcat> btipling: yes, ~ has a destructor
[04:08:00] <btipling> hrm, so if I were to build a large application with rust, would I be using managed boxes a lot to store things on the heap?
[04:08:10] *** Joins: bytbox (s@moz-588B96FF.washdc.fios.verizon.net)
[04:08:10] <strcat> ideally no
[04:08:18] <strcat> btipling: you can move ~
[04:08:23] <strcat> any type with a destructor moves
[04:08:30] <strcat> it's not limited to staying in a scope
[04:08:41] <btipling> when you move those, the previous variables no longer can reference those variables though right
[04:08:53] <strcat> the previous variable is dead, can't be used anymore
[04:09:17] <btipling> if I pass in an owned box as a variable to a function, is that a move?
[04:09:41] <strcat> if you pass it by-value, yeah
[04:10:04] <btipling> ok so I can return and move from a function to then
[04:10:30] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[04:10:33] <btipling> so I could maybe do something like  x = my_func(x);
[04:10:52] <strcat> that'd be weird though
[04:10:53] <btipling> x moves it into my_func and then my_func returns it back to x?
[04:11:02] <strcat> yes
[04:11:04] <strcat> that would work
[04:11:07] <strcat> but you wouldn't do it
[04:11:11] <btipling> right so maybe instead I should use borrowing?
[04:11:14] <strcat> yes
[04:11:17] <btipling> cool
[04:11:20] <strcat> pass ~T as &mut T or &T
[04:11:35] <strcat> although you shouldn't be using owned pointers much explicitly
[04:11:40] <btipling> oh I see
[04:11:45] <strcat> you should generally just be allocating things on the stack
[04:11:47] <strcat> and using borrows
[04:11:51] <btipling> hrm
[04:12:09] <btipling> hrm but like say I made a prime number sieve
[04:12:12] <btipling> that's really big
[04:12:15] *** Quits: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net) (Ping timeout)
[04:12:20] <btipling> a really big list of numbers with markers
[04:12:28] <strcat> so you would have a vector
[04:12:39] <strcat> a dynamically sized vector is 1 word on the stack
[04:13:00] <btipling> because it's a pointer to data stored on the heap?
[04:13:05] <strcat> yes
[04:13:14] <btipling> " vectors can be stored on the stack, the local heap, or the exchange heap"
[04:13:15] <btipling> hrm
[04:13:17] <strcat> you should very rarely need explicit ~ pointers in your own code
[04:13:31] <btipling> ok I was looking at a rust irc client
[04:13:37] <btipling> and I was seeing all kinds of ~ @ and *
[04:13:44] <btipling> in fact I saw a  ~[~str]
[04:13:52] <btipling> https://github.com/pcwalton/rust-irc-client/blob/master/irc_client.rs#L282
[04:14:17] <btipling> ok maybe it's mostly borrowing
[04:15:25] <strcat> btipling: that's really old
[04:15:29] <strcat> it's not how you would write rust today
[04:15:34] <btipling> ah
[04:15:42] <aatch> btipling, depending on how old the code is, it probably pre-dates the expressive region system we have now.
[04:15:45] * sully submits a PR for another default method fixes
[04:16:43] *** Joins: indirect (indirect_m@moz-22FDA25B.hsd1.ca.comcast.net)
[04:17:20] <btipling> I see
[04:17:35] <enix> Kinda related, if I write a function: fn() -> [u8, ..16]; does that involve any copies, or does it write the result directly to the stack frame of the caller?
[04:17:58] <strcat> enix: the caller passes an output pointer
[04:18:03] <strcat> and it writes to that, but codegen is bad atm
[04:18:09] <strcat> so it's not necessarily going to be efficient
[04:18:09] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[04:18:29] <strcat> only small values are *not* returned by-output-pointer
[04:18:34] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[04:18:39] <enix> ok
[04:19:08] <btipling> rust is a lot more complicated than go, at least that's my impression so far, seems more lower level
[04:19:12] <btipling> which is fine
[04:19:16] <btipling> I want to learn
[04:19:18] <btipling> :)
[04:19:23] <aatch> it's dependent on the architecture, but we follow the C abi when deciding whether or not to return by value
[04:19:53] <enix> i'm playing around with writing an AES library, and I can't decide if I should define functions as fn encrypt(in: &[u8], out: &mut [u8]) or as fn encrypt(in: &[u8, ..16]) -> [u8, ..16]
[04:20:11] <enix> i'm not too concerned about what is efficient right now, but what might become efficient in a few months or so
[04:20:49] <aatch> btipling, it's great. I'm currently investigating trying to kill as much libc stuff as I can and re-implementing it in rust.
[04:20:53] <enix> the the advantage of the 2nd form, is that i can assign directly into the stack of the caller; the first form requires that I allocate a buffer somehwere and set all the values in the array, only to pass it to a function that then overwrites all of those values
[04:20:57] <enix> which seems inneficient
[04:21:02] <strcat> enix: &mut
[04:21:13] <aatch> enix, the second form
[04:21:22] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[04:21:43] <btipling> aatch: nice 
[04:21:44] <strcat> well is this the user-facing API or internal?
[04:22:11] <strcat> enix: AES can be in-place
[04:22:16] <strcat> I don't think you want an input or output at all
[04:22:23] <btipling> I guess free and malloc would have to come from libc though yeah
[04:22:26] <strcat> just encrypt(block: &mut [u8])
[04:22:34] <aatch> btipling, yep, one big advantage is that ffi calls need to be conservative about stack usage.
[04:22:36] <btipling> unless there's some really non-portable low level syscall involved
[04:22:42] <enix> internal. user facing API would be all &[u8] and &mut [u8]. internally it would use an unsafe function to cast those forms to [u8, ..16] to work on
[04:22:51] *** Joins: hjr3 (hradtke@A01051A9.6F669779.3D1CA460.IP)
[04:22:56] <aatch> btipling, we're not actually using [g]libc's malloc/free
[04:23:02] <aatch> we're actually using jemalloc.
[04:23:03] <strcat> aatch: we are now
[04:23:07] <strcat> jemalloc is off
[04:23:09] <aatch> strcat, oh right
[04:23:11] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[04:23:12] <strcat> segmented stacks break it
[04:23:22] <strcat> they are too small
[04:23:24] <aatch> strcat, even more of a reason to port it to rust!
[04:23:29] <strcat> aatch: won't fix it
[04:23:36] <strcat> aatch: the allocator has to be able to run in the red zone
[04:23:47] <strcat> if jemalloc doesn't work in C it's definitely not going to work in rust
[04:23:50] <strcat> ;\
[04:23:52] <aatch> strcat, urg
[04:23:58] <btipling> it's cool being able to reference libc directly in rust, with go I'd have to compile it differently, I can take advantage of syscall stuff on the platform
[04:24:31] <enix> my concern about doing an encrypt in place operation is that i'm wondering if that will force callers to do copies of memory they don't want to lose before encrypting which seems awkward
[04:24:41] <aatch> btipling, what do you have to do in Go to use libc?
[04:25:37] <strcat> enix: if you use an input and output it can't be done in-place at all
[04:25:55] <btipling> aatch: well compile with cgo instead of go I believe
[04:26:03] <btipling> aatch: http://golang.org/cmd/cgo/
[04:26:10] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[04:26:10] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/w6KIeA
[04:26:10] <ghrust> 13rust/06master 14451c943 15Brian Anderson: Ignore all rusti tests harder. #7541
[04:26:10] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[04:26:15] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:26:16] <ghrust> 01[13rust01] 15brson merged 06master into 06dist-snap: 02http://git.io/LBdUfw
[04:26:16] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:26:31] *** Joins: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com)
[04:26:54] <aatch> btipling, ah.
[04:26:55] <enix> yeah, buts thats what I'm wondering - do callers really want to do inplace encryption or will that pose more issues for them? I mean, in-place AES by itself is probablynot a burdon
[04:27:12] <btipling> using cgo has various effects though on go in general
[04:27:28] <strcat> enix: well I don't think callers are going to pass you a block to encrypt
[04:27:29] <btipling> I like that in rust it's pretty interchangeable 
[04:27:37] <enix> but, no one uses AES directly - you use it as part of a mode like CBC or CTR which sometimes require that the inputs be buffered until you have a full block to work on
[04:27:50] <strcat> enix: yes so this is your internal API
[04:27:53] <strcat> so you should do it efficiently
[04:28:06] <strcat> so why use arrays at all?
[04:28:14] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:28:14] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143e6242b to 14451c943: 02http://git.io/N3iJvQ
[04:28:14] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:28:17] <strcat> for blocks
[04:29:12] <strcat> passing a slice passes a ptr and a size
[04:29:31] <strcat> you could do 
[04:29:52] <strcat> fn encrypt(block: [u8, ..16]) -> [u8, ..16]
[04:29:57] <strcat> but I don't think you want &[T]
[04:31:41] <enix> ok, yeah, using fixed lenght arrays like that is what i'm currenlty playing around with
[04:33:08] <enix> I have AES itself working fine, but its currently pretty useless without any encryption modes implemented ontop of it
[04:33:13] <btipling> would I have to use a c library to make an https request at this point?
[04:33:59] <btipling> like use curl
[04:34:01] <btipling> libcurl
[04:34:02] <enix> and i'm trying to make all the internal workings as efficient as possible with an eye toward submitting toward libextra, if i can make it all work.
[04:34:20] *** Quits: hjr3 (hradtke@A01051A9.6F669779.3D1CA460.IP) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[04:35:04] <enix> and what i'm really trying to avoid is unecessary copies or initializing vectors just to immediately overwrite there contents; i just wanted to make sure I wasn't going off in a completely wrong directly
[04:35:05] <btipling> I wonder what servo uses
[04:35:08] <enix> *direction
[04:35:26] <strcat> enix: I don't really think AES is a good thing to implement ourselves
[04:35:33] <strcat> preventing timing attacks is hard
[04:36:01] <bstrie> yes, please let's not go implementing crypto libraries
[04:36:16] <Thad> QUESTION: What possibly could be the issue the this SRWLOCK error when I'm trying to build with "make VERBOSE=1 CFLAGS=-m32" ? (still hacking on 64bit build for Win7)  http://pastebin.mozilla.org/2584785
[04:36:18] <bstrie> we still need every other kind of library
[04:36:58] <strcat> we could have stuff like aes but it really needs to be reviewed well
[04:37:06] <Luqman> Thad: mingw64?
[04:37:08] <aatch> hey, anybody know why the unistd fns in libc all have #[link_name="_<name>"]?
[04:37:12] <btipling> https://github.com/mozilla/servo/blob/master/src/components/util/url.rs
[04:37:21] <btipling> I don't think servo has https support yet
[04:37:33] <Thad> Luqman: yeah still hacking on it.  pulled latest from master and cleaned llvm and rebuilt...well trying.
[04:37:37] <Luqman> aatch: i think some platforms have a leading underscore
[04:37:45] <Luqman> Thad: ya, i ran into that too
[04:37:59] <Thad> Luqman: Oh your a Win user also ?
[04:38:11] <Luqman> Thad: no, just experimenting in vm :P
[04:38:16] <Thad> lol
[04:38:27] <aatch> Oh right, that's on the windows-cfg'd bit
[04:38:32] <aatch> I missed that...
[04:38:34] <Thad> i'll open the issue then....
[04:39:00] <enix> strcat: so, wrap something written in another language?
[04:39:17] <Luqman> Thad: change line 40 in uv/include/uv-private/uv-win.h to: void* srwlock_;
[04:39:29] <Thad> Luqman: why do that ?
[04:40:02] <Luqman> Thad: mingw64 doesn't seem to have SRWLOCK. also the comment right above that explains
[04:40:23] <strcat> enix: would be too slow as it is right now
[04:40:28] <Luqman> looking at libuv's git history seems like it used to be SRWLOCK then void* then someone changed it back
[04:41:25] *** Joins: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca)
[04:41:36] <Thad> Luqman: you sure about that path ?  didn't find it.
[04:42:01] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:42:17] <Luqman> Thad: src/libuv/include/uv-private/uv-win.h
[04:42:31] <Thad> line 40 is a linefeed
[04:43:16] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:43:25] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[04:43:27] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[04:43:35] <Luqman> Thad: sorry, meant 240 :P
[04:44:24] <Luqman> Thad: also, to fix the winsock2.h error in src/rt/rust_uv.cpp move the #include "uv.h" to before the other includes
[04:44:29] *** Joins: TransGuy (...@5977DF83.707E87AC.C9F645CD.IP)
[04:44:31] <Thad> void*  srwlock_;
[04:45:14] <Luqman> yep
[04:45:30] <aatch> strcat, oh, I think that my weird segfault with static mut was actually unrelated, and was more to do with incorrect assembly
[04:45:45] <aatch> so I'll try getpid again later.
[04:45:59] <Thad> Luqman: before ALL the other includes ? or just rust_globals.h ?
[04:46:46] <Luqman> Thad: right, above rust_globals.h works
[04:46:55] <Thad> Luqman: OK
[04:48:41] <Luqman> Thad: so that should let you get farther
[04:48:53] <Thad> Luqman: it does...building fast
[04:49:22] <Luqman> after that i ran into problems build llvm :(
[04:49:39] <Luqman> though i guess it could be cause i used gcc > 4.6
[04:51:21] <Thad> Luqman: same here... I have 4.8.1 with the latest mingw-builds download
[04:52:02] *** Quits: TransGuy (...@5977DF83.707E87AC.C9F645CD.IP) (Quit: )
[04:52:17] <Luqman> ya, i tried with gcc 4.8.1, x64, win32 threads, sjlj exceptions
[04:52:58] <Thad> Luqman: same here.
[04:53:28] <Thad> Luqman: OK, calling it a night.... thanks, a bit further.  will you issue a PR for those 2 fixes yourself please ?  thanks.
[04:53:30] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:53:57] <Luqman> Thad: sure. good night
[04:54:01] <Thad> thanks man
[04:54:06] *** Quits: Thad (chatzilla@moz-C35F90AE.tx.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130625125232])
[04:56:16] <enix> if rust is to grow a strong network stack, it needs crypto libraries of some sort. there are advantage and disadvantages of a native crypto library like what i'm currently working on. if such a library has minimal chance of being accepted, though, i'll stop working on it. i'm not really sure what rust's intended direction is on that type of stuff.
[04:57:23] <strcat> enix: we can have a native crypto library but that means we're assuring people it's secure
[04:57:29] <strcat> not vulnerable to side channel attacks
[04:58:27] <Jeaye> Rust is meant to be a multi-purpose, system-level language; a native crypto lib suits it, as does some strong networking support.
[04:59:55] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[05:00:05] <enix> ok, well, my main goal is to try to get the higher level interfaces right
[05:00:31] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[05:02:02] <strcat> http://golang.org/src/pkg/crypto/subtle/constant_time.go for an idea of what you have to consider (LLVM would ruin this with optimizations though)
[05:02:35] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[05:03:01] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[05:03:33] *** Joins: mcstar (mcstar@moz-D7A16997.monradsl.monornet.hu)
[05:05:48] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[05:06:23] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[05:06:35] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:08:46] <Jeaye> Do we've trait inheritance yet?
[05:09:00] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:09:13] <Jeaye> Or default functions? (what's the syntax?)
[05:10:17] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[05:11:32] <strcat> there are default methods and trait inheritance
[05:11:38] <strcat> they aren't very solid yet
[05:12:46] <strcat> default methods are just a method in a trait with a body
[05:12:54] <strcat> and if they aren't overriden it uses the default
[05:13:00] <Jeaye> Ahh
[05:13:01] *** Quits: bytbox (s@moz-588B96FF.washdc.fios.verizon.net) (Ping timeout)
[05:13:25] <Jeaye> I'm interested in a way to refer to a type that implements two traits, yet without using generics.
[05:14:12] <strcat> Jeaye: why?
[05:14:15] *** Quits: sankha93 (Instantbir@4C1B4135.A5E24E6D.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[05:14:20] <strcat> trait objects don't really work well
[05:14:31] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:15:11] <Jeaye> I'm passing in an object that I want to subscribe to two event handlers, both wanting different trait types. I could merge the traits, but was seeing if that could be avoided first.
[05:16:13] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[05:16:23] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[05:29:15] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[05:30:14] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[05:30:46] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:34:05] *** Joins: mr_fribble (Mibbit@B4104EBB.3CC170B1.1E14B209.IP)
[05:35:06] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[05:37:50] <aatch> Wow... strcat, I re-did the getpid test using actual working assembly (what I had before was broken), ffi comes in at 36 ns/iter, syscall comes in a 6 ns/iter.
[05:38:02] <aatch> that's using the same optimization as glibc
[05:38:36] <aatch> without it, it's only twice the speed.
[05:38:49] <aatch> twice the time sorry.
[05:42:54] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[05:42:59] *** Joins: snadon_ (chatzilla@moz-3BC727E8.mc.videotron.ca)
[05:43:00] *** snadon_ is now known as snadon
[05:44:35] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:47:13] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Client exited)
[05:49:49] <aatch> what's `long long` in C again?
[05:49:57] <aatch> always 64bits?
[05:50:18] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[05:51:27] <klutzy> aatch: at least 64bits
[05:51:45] <aatch> klutzy, ah, cool. thanks
[05:52:18] <mcpherrin> If only C had long long long
[05:52:20] <mcpherrin> et cetera
[05:52:39] <doener> very long, damn long, too long
[05:52:49] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[05:53:16] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[05:54:32] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:56:35] <aatch> trying to implement various libc calls in rust using the syscall interface...
[05:57:37] <aatch> took a while to figure out the weird code that was splitting a long long into two halves.
[06:00:09] *** Quits: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[06:00:33] *** Quits: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu) (Ping timeout)
[06:00:36] *** Quits: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu) (Ping timeout)
[06:00:41] *** Quits: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu) (Ping timeout)
[06:00:41] *** Quits: acrichto (acrichto@moz-B63D64BD.res.cmu.edu) (Ping timeout)
[06:01:31] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[06:01:45] *** Joins: bblum (bblum@moz-2B41ACB5.andrew.cmu.edu)
[06:02:11] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[06:05:58] *** Joins: mjrosenb (mjrosenb@moz-B3592BDA.club.cc.cmu.edu)
[06:06:09] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[06:06:47] *** Joins: rntz (rntz@moz-C76A8D96.sp.cs.cmu.edu)
[06:10:02] <roo> I worked out how a OnceClosure trait would work, and you can _almost_ implement ugly syntax for it as a macro. almost.
[06:10:50] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[06:12:06] <xenocons> who was talking about esoteric programming languages the other day
[06:12:07] <xenocons> haha
[06:12:10] <xenocons> http://torso.me/chicken
[06:12:36] <xenocons> the quine is hillarious
[06:14:06] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[06:14:30] <doener> I like how the JS implementation has a vertical chicken in it
[06:14:38] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[06:14:44] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[06:17:34] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (No route to host)
[06:19:19] *** Quits: bstrie (ben@moz-D5A1D0F5.members.linode.com) (Ping timeout)
[06:19:20] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[06:19:20] *** Joins: bstrie (ben@moz-D5A1D0F5.members.linode.com)
[06:20:44] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[06:22:32] <xenocons> heh
[06:31:15] *** zz_kimundi is now known as kimundi
[06:31:25] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:31:31] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:31:32] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:37:10] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[06:37:26] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[06:37:27] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:45:15] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[06:46:58] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[06:53:38] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[06:53:56] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[06:55:31] *** Joins: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be)
[06:56:11] *** Joins: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au)
[06:58:37] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[07:00:35] *** Quits: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net) (Ping timeout)
[07:00:37] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[07:01:02] *** Joins: roo (jesse.rudo@moz-447A642A.dynamic.ip.windstream.net)
[07:04:44] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[07:10:01] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[07:15:18] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[07:18:33] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[07:19:16] <roo> https://gist.github.com/jessopher/5907314 not sure if this would run into any ~Trait breakage
[07:19:59] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[07:20:27] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[07:25:35] *** Joins: Voomer__ (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:25:35] *** Quits: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:31:07] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[07:33:08] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[07:37:57] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[07:47:08] <doomlord> the .clone stuff i was finding one needs to implement - is this because at the minute rust is trying to warn you when a large object is going to be duplicated
[07:48:08] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:49:06] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[07:54:25] *** Quits: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au) (Quit: z0w0)
[07:55:39] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[07:56:25] *** Quits: fabiand_ (fabiand@moz-DA383042.adsl.alicedsl.de) (Quit: Verlassend)
[07:56:53] *** Joins: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au)
[07:58:57] *** Joins: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP)
[08:01:00] *** Joins: fabiand (fabiand@moz-DA383042.adsl.alicedsl.de)
[08:11:00] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[08:13:17] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[08:14:53] *** Joins: paupau_ (paul@moz-D6583788.hsd1.ca.comcast.net)
[08:15:15] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[08:15:35] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[08:16:12] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[08:16:28] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[08:16:59] <sanxiyn> rusti: struct Point { x: int, y: int } let p = Point { x: 1, y: 2}; p.x
[08:17:00] -rusti- 1
[08:17:28] <sanxiyn> rusti: struct Point { x: int, y: int } enum MyPoint { MyPoint(Point) } let p = MyPoint(Point { x: 1, y: 2}); p.x
[08:17:28] -rusti- 1
[08:17:45] <sanxiyn> It seems that newtype enum still works, and moreover, rustc seems to rely on it
[08:17:54] *** Quits: paupau_ (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[08:18:05] <sanxiyn> This probably should be fixed?
[08:18:44] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[08:26:53] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:28:27] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[08:29:38] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:30:19] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[08:31:35] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Ping timeout)
[08:32:16] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:33:09] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[08:34:45] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Connection reset by peer)
[08:35:07] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[08:41:19] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[08:42:22] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[08:44:44] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:49:08] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:55:43] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[08:56:12] <bjz> Jeaye: ping
[08:56:25] <bjz> jack: ping
[08:56:50] *** Quits: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP) (Quit: pyrac)
[08:58:18] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Input/output error)
[09:04:12] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:08:15] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[09:11:07] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[09:16:54] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz‚Ä¶)
[09:18:13] *** Quits: cr (anonymous@moz-25A98384.dip0.t-ipconnect.de) (Ping timeout)
[09:22:08] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[09:22:43] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[09:22:48] <cmr> awasdfdsf
[09:22:50] <cmr> whoops
[09:22:59] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:26:19] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[09:27:32] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[09:27:32] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[09:29:22] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[09:32:06] *** Joins: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP)
[09:33:35] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: anri)
[09:38:30] *** Quits: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au) (Quit: z0w0)
[09:43:52] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[09:44:52] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[09:45:08] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[09:45:24] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[09:47:59] *** Joins: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au)
[09:49:26] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[09:52:06] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[09:54:37] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Ping timeout)
[09:57:37] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:04:56] *** Joins: glandium (glandium@moz-A09032B1.kimsufi.com)
[10:07:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[10:09:17] *** kimundi is now known as zz_kimundi
[10:12:47] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[10:16:28] *** zz_kimundi is now known as kimundi
[10:16:54] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[10:19:49] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[10:22:52] *** Parts: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au) ()
[10:30:04] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[10:38:52] *** Joins: nano (nano@moz-972880B.superkabel.de)
[10:46:05] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:54:53] *** Joins: mib_62hl5k (Mibbit@D03DD482.78560ED1.F7A61E88.IP)
[10:56:23] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[10:59:23] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:00:41] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Ping timeout)
[11:01:07] *** Joins: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au)
[11:06:06] <cmr> doomlord: aiui, sorta. it's more of a "we don't want implicit copies, we want to be able to look at the code and know what is going on"
[11:06:30] *** Quits: nef (andor@moz-B1384951.neferty.in) (Quit: WeeChat 0.4.1)
[11:06:32] *** Joins: andor (andor@moz-708868D.neferty.me)
[11:06:53] *** Quits: mib_62hl5k (Mibbit@D03DD482.78560ED1.F7A61E88.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:07:39] *** Quits: andor (andor@moz-708868D.neferty.me) (Quit: WeeChat 0.4.1)
[11:07:47] *** Joins: andor (andor@moz-708868D.neferty.me)
[11:13:34] <cmr> btipling: yes, rust is a systems language, go... not really suitable for the purpose IMO, even though they advertise it as one. can't avoid the GC.
[11:14:16] <btipling> cmr: hi
[11:14:32] *** Joins: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP)
[11:14:36] <btipling> cmr: is it possible at this point to make an https request with rust without using c?
[11:14:57] <cmr> btipling: I don't really see rust as lower level overall though, it offers more higher level constructs with the ability for efficient lowlevel code
[11:15:09] <cmr> btipling: no, there's no complete or robust networking package
[11:15:13] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:15:13] <btipling> ah
[11:15:22] <btipling> thanks
[11:15:30] <btipling> TLS is kind of hard
[11:16:20] <Ms2ger> Want to write one? ;)
[11:16:34] <btipling> :P
[11:17:57] <cmr> btipling: Rust is going to be very painful for you if you want to do networking or lots of IO
[11:18:02] <cmr> (atm)
[11:18:12] <btipling> ah
[11:18:32] <cmr> the libraries just aren't there yet, and the io code is being entirely overhauled
[11:18:46] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[11:19:29] <doomlord> an excercise left to the user..
[11:20:33] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[11:24:44] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[11:25:14] <etw> I'd love to build a reactor (ala event machine) if that'd be useful
[11:25:56] <cmr> etw: get in touch with brson, he's spearheading the new io/runtime
[11:26:49] <aatch> etw, right now we're using libuv for evented io
[11:29:54] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[11:32:07] <doomlord> libuv rings a bell as what i blocked me on my iOS port attempt, i didn't know what it was
[11:32:28] <cmr> doomlord: cross-platform async io
[11:34:08] <SimonSapin> What does "Illegal anonymous lifetime: anonymous lifetimes are not permitted here" mean? I‚Äôd trying to have a & pointer in a struct, and methods on that struct
[11:34:22] <doomlord> ( https://github.com/joyent/libuv/pull/243 <<< googleing libuv/ios .. maybe i'd have to make a dummy implementation to get support .. )
[11:34:25] *** Quits: mr_fribble (Mibbit@B4104EBB.3CC170B1.1E14B209.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:35:33] <aatch> That said, I definitely think that cutting as much dependency from any C code is a worthwhile long-term goal.
[11:35:47] <aatch> (bah, bad sentence.
[11:35:48] <aatch> )
[11:36:15] <doomlord> i like pcwaltons' suggestion for splitting the standard libraries into a minimal core and "full runtime" layered on top
[11:36:39] <aatch> doomlord, yeah. I have some ideas about that too.
[11:36:57] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Client exited)
[11:36:58] <cmr> doomlord: it looks like it supports iOS
[11:37:08] <cmr> most recently: https://github.com/joyent/libuv/commit/f22163c
[11:37:32] <Ms2ger> If your packaging system is good enough, I guess you don't really need much of a standard library
[11:38:49] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[11:40:47] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[11:42:52] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:45:04] *** Quits: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP) (Quit: pyrac)
[11:45:15] <engla> SimonSapin: your struct needs a type parameter for the lifetime. like   struct Foo<'self, T> { obj: &'self T }
[11:46:49] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:47:56] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[11:48:12] *** Joins: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP)
[11:51:07] <orshem> the default for structs / anything is public or private?
[11:51:25] <cmr> orshem: visibility is inherited.
[11:51:44] <cmr> by default it's priv
[11:52:12] <orshem> cmr: but i want some method on a struct to be private and some public
[11:52:15] <orshem> same for fields
[11:52:32] <cmr> orshem: so add visibility modifiers
[11:52:48] <cmr> rusti: struct foo { priv a: uint }
[11:52:49] -rusti- ()
[11:53:13] <orshem> cmr: oh i thought you meant like mutability you can only have one or the other...
[11:53:29] <orshem> priv by default is sensible
[11:53:51] <cmr> struct fields aren't priv by default
[11:54:12] <cmr> I don't know exactly how it works...
[11:54:35] <orshem> so the defaults change based on the type?
[11:54:39] <cmr> I have no idea
[11:54:47] <orshem> structs - priv, methods - pub?
[11:54:52] <orshem> oh ok
[11:54:55] <dbaupp> orshem: fields are pub by default, everything else is priv
[11:55:07] <dbaupp> (including types, methods, functions, traits)
[11:55:21] <orshem> dbaupp: what's the reasoning behind this?
[11:56:07] <dbaupp> orshem: in what sense?
[11:56:44] <dbaupp> (if you're asking why only fields are pub by default, I don't know.)
[11:56:56] <orshem> dbaupp: why are fields different? did somebody look over the codebase of rust and count which occur more?
[11:57:00] <orshem> ah ok
[11:57:09] <cmr> I almost never want a priv field
[11:57:31] <dbaupp> yeah, same
[11:57:56] <doomlord> immutable is more useful than pub/priv
[11:58:02] <orshem> dbaupp, cmr: to hide implementation details
[11:58:08] <orshem> hashmap is private
[11:58:12] <orshem> the fields
[11:58:22] <cmr> orshem: yes, but I very infrequently want to do that.
[11:58:27] <dbaupp> orshem: right, but you can "hide" implementation details by convention
[11:58:31] <dbaupp> (like python does)
[11:58:46] <orshem> yep i'm familiar with python :)
[11:58:58] <dbaupp> i.e. along the lines of "don't touch this unless you know what you're doing"
[11:59:41] <orshem> i won't say rust is more complicated than python
[11:59:47] <orshem> but certainly more arcane
[11:59:58] <orshem> i'm not used to functional programming
[12:00:04] <orshem> match is new for me
[12:00:05] <dbaupp> (and, the region stuff is pretty complicated until you get the hang of it)
[12:00:17] <doomlord> i dont think rust is really functional .. its functional-inspired
[12:00:26] <orshem> trying to structure my code in a tree with unique and references is hard
[12:00:35] <doomlord> its hybrid 
[12:00:38] <cmr> orshem: yes, memory safety is hard
[12:00:59] <orshem> and the syntax while not ugly, is heavy
[12:01:12] <cmr> You think so? I think the syntax is quite light
[12:01:25] <doomlord> the syntax is mostly more elegant than C++, which is the only real comparison
[12:01:38] <orshem> why are attributes #[attr] when they can be either #[attr] or [attr]?
[12:02:29] <cmr> orshem: [attr] would require lookahead or context sensitivity
[12:02:30] <orshem> small thing like this makes me think the designer of rust was a perl inspired punctualitist
[12:02:46] <cmr> I'd be fine with #attr though
[12:02:57] <orshem> is that a word? in love with all the signs ~@#
[12:03:01] *** Joins: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de)
[12:03:09] <orshem> cmr oh i don't care i get used to it
[12:03:09] <dbaupp> heh
[12:03:26] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:03:54] <orshem> same when i tried using explicit life time. the code gets cluttered really fast. specially with 'self
[12:03:57] <roo> yeah, there are lots of little squiggley things peppered throughout, but they arent generally in large clumps
[12:05:47] <orshem> cmr: how does c# do this?
[12:05:54] <cmr> orshem: do what?
[12:05:56] <orshem> using look ahead?
[12:06:03] <orshem> [attr]
[12:06:07] *** Quits: mcstar (mcstar@moz-D7A16997.monradsl.monornet.hu) (Quit: mcstar)
[12:06:45] <cmr> I don't know what C#'s parser is like
[12:07:24] *** Quits: quvarxa (chatzilla@moz-978E4C31.static.tpgi.com.au) (Quit: ChatZilla 0.9.90 [Firefox 23.0/20130625125232])
[12:07:47] <doomlord> i prefer #[attr]
[12:08:24] <orshem> cmr: my ignorance regarding parsing is profound, but from googling a bit it seems that a fixed look ahead is par the course in programming languages
[12:08:49] <doomlord> i like the decisions taken to simplify parsing. especially fn ...
[12:08:55] <doomlord> easy to grep
[12:09:13] <dbaupp> "Unfortunately, C# has a very complex grammar. As a result, considerable time was required to write a LALR(1) compliant version"
[12:09:15] <dbaupp> http://code.google.com/p/bsn-goldparser/wiki/CSharpGrammar
[12:09:21] <doomlord> dont have to wait for advanced IDE support to get going with the language.
[12:09:35] <dbaupp> (Rust is aiming for a LL(1) grammar, which is very simple.)
[12:09:38] <cmr> orshem: rust can be parsed with 2 tokens of lookahead atm I think
[12:10:00] <cmr> Did whoever was working on it get an LL(2) parser?
[12:11:27] *** Joins: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP)
[12:11:29] <dbaupp> https://mail.mozilla.org/pipermail/rust-dev/2013-April/003753.html
[12:11:41] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[12:11:49] <dbaupp> https://gist.github.com/anonymous/5457664 is possibly LL(2)
[12:12:04] <orshem> doomlord: the attribute syntax isn't important (to me). but the lifetime syntax.... code that is both lifetime and generics heavy is hard for me to parse
[12:12:15] <dbaupp> (specifically, https://mail.mozilla.org/pipermail/rust-dev/2013-April/003764.html)
[12:12:20] <dbaupp> (so it's actually LL(1))
[12:12:42] <orshem> orshem: ofc i'm not used to it. i only play with the language a bit in the evenings...
[12:13:06] <doomlord> maybe i'll think different when i've run into that more
[12:13:51] <dbaupp> https://github.com/mozilla/rust/blob/master/src/libstd/str.rs#L304
[12:14:11] <dbaupp> (I was very unhappy when I ended up writing that :( )
[12:14:36] <SimonSapin> engla: I‚Äôm getting errors on impl Foo
[12:15:03] <orshem> dbaupp: if only you didn't need 'self. 'a would be shorted and easier to read
[12:15:03] <cmr> SimonSapin: impl<'self> Foo<'self>
[12:15:09] <dbaupp> SimonSapin: you probably need `impl<'self> Foo<'self>'
[12:15:18] <dbaupp> orshem: yeah, I'm hanging out for that change
[12:15:36] <SimonSapin> I tried to looks for docs about this and didn‚Äôt find it
[12:15:44] <orshem> dbaupp: from the link you posted: "fn bar(&int, &int)" is that like in c when you omit parameters name in declarations?
[12:15:48] <doomlord> is there a default lifetime that works intelligently
[12:15:54] <dbaupp> orshem: yep
[12:16:01] <dbaupp> (it only works in traits)
[12:16:09] <SimonSapin> "wrong number of type arguments: expected 1 but found 0, impl<'self> InputStream<'self>"
[12:16:58] <dbaupp> SimonSapin: is InputStream parameterised?
[12:17:03] *** Joins: Sergio965 (sergiobz@1B3BBE83.33D83D78.3A99D594.IP)
[12:17:07] <cmr> doomlord: afaik you usually don't need explicit lifetimes, only when writing data structures or returning pointers into one of your arguments
[12:17:08] <dbaupp> i.e. struct InputStream<T> { ... }?
[12:17:35] <SimonSapin> hum, I had struct InputStream<'self, ErrorReporter> as you said, but struct InputStream<'self> seems to work
[12:17:39] <orshem> dbaupp: doesn't seem all that necessary. leave that option and keep ll(1)
[12:17:50] <dbaupp> SimonSapin: (if so, then you need `impl<'self, T> InputStream<'self, T>`)
[12:17:56] <dbaupp> (or a concrete type for T)
[12:18:40] <dbaupp> SimonSapin: right, if ErrorReporter is a concrete type, then it shouldn't be a parameter (that is creating a generic with the name "ErrorReporter")
[12:18:48] <SimonSapin> no, it‚Äôs a trait
[12:18:48] <dbaupp> orshem: yeah, I'm not sure what came of that
[12:18:52] <dbaupp> oh
[12:18:56] <orshem> there should be a zen of rust
[12:19:03] <cmr> SimonSapin: then you'd want T: ErrorReporter, no?
[12:19:19] <orshem> if it doesn't work: stick a @ in front or @~
[12:19:22] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[12:19:23] <orshem> see rustc
[12:19:27] <SimonSapin> can‚Äôt I just pretend that a trait is a type?
[12:19:35] <dbaupp> SimonSapin: then you need `struct InputStream<'self, T> { ... } impl<'self, T: ErrorReporter> InputStream<'self, T> { ... }`
[12:19:52] <cmr> orshem: the zen of python was only written 10 years after python was created. rust is still young.
[12:20:21] <orshem> cmr: i know, i'm not knocking rust
[12:20:23] <dbaupp> SimonSapin: you can, with @Trait or ~Trait, which makes a trait object... essentially a (data ptr, vtable ptr) like a C++ class
[12:20:39] <orshem> i think it'll end up supplementing c++
[12:20:42] <orshem> or hope
[12:20:44] <SimonSapin> dbaupp: but not &Trait?
[12:20:50] <dbaupp> SimonSapin: oh, that too
[12:20:57] <orshem> but it's a large language
[12:21:00] <cmr> SimonSapin: Trait objects are hugely buggy though (except @)
[12:21:06] <dbaupp> SimonSapin: trait objects are a little bit broken in various ways
[12:21:16] <dbaupp> (well, a lot broken.)
[12:21:18] <cmr> SimonSapin: you almost always want trait bounds.
[12:21:28] <cmr> SimonSapin: they are static, rather than dynamic, dispatch.
[12:21:30] <dbaupp> e.g. you can't borrow [@~]Trait to &Trait yet
[12:21:32] <orshem> with lots of @
[12:21:43] <cmr> orshem: idiomatic rust code has little to zero @
[12:21:52] <dbaupp> orshem: was that "it's a large language with lots of @"?
[12:21:52] <Sergio965> When's the Rust book coming?
[12:22:02] <dbaupp> Sergio965: when you write it? :P
[12:22:04] <cmr> Sergio965: what rust book? :)
[12:22:05] <orshem> yep
[12:22:10] <SimonSapin> I think I‚Äôm just gonna give up on genericity for now :)
[12:22:13] <orshem> i'm reading the rustc code
[12:22:15] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[12:22:21] <orshem> but not understanding it
[12:22:22] <cmr> orshem: the rustc code is awful
[12:22:24] <orshem> not yet anyhow
[12:22:25] <dbaupp> orshem: don't! (it's very old and not idiomatic)
[12:22:27] <engla> ~Trait doesn't implement Trait either, not sure if it can
[12:22:32] <roo> lol yeah don't do that
[12:22:36] <Sergio965> dbaupp: Ha. Maybe when I finish my thesis. :)
[12:22:49] <cmr> orshem: did you see the warnings in http://cmr.github.io/blog/2013/06/23/how-i-got-started-with-rust/ ?
[12:23:04] <Sergio965> cmr: The Rust book, of course.
[12:23:07] <dbaupp> engla: the trait objects implement Trait, except if they mention Self in any of the methods
[12:23:17] <orshem> cmr: yes i'm following your blog
[12:23:19] <engla> hm ok
[12:23:20] <dbaupp> engla: (or is it specifically a bug with ~Trait?)
[12:23:35] <orshem> still it's the only source of rust that i can read
[12:23:38] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[12:23:45] <engla> don't know :-) I've only tried ~Iterator<A> 
[12:23:56] <engla> you can still call the methods manually of course
[12:23:58] <cmr> orshem: there's servo
[12:24:12] <dbaupp> rusti: trait Foo { fn foo(&self) -> uint; } impl Foo for uint {fn foo(&self) -> uint {0}} let x = ~1u as ~Foo; x.foo()
[12:24:12] <cmr> https://github.com/mozilla/servo/tree/master/src/components
[12:24:13] -rusti- 0
[12:24:13] <orshem> if i'd take rules from the zen of python to rust i'd take only two:
[12:24:17] <orshem> There should be one-- and preferably only one --obvious way to do it
[12:24:22] <orshem>  Explicit is better than implicit.
[12:24:27] <orshem> that's all
[12:24:37] <orshem> cmr: servo is better?
[12:24:39] <dbaupp> rusti: trait Foo { fn foo(&self) -> uint; } impl Foo for uint {fn foo(&self) -> uint {0}} fn bar<F:Foo>(f:F){f.foo()} let x = ~1u as ~Foo; bar(x)
[12:24:41] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/ZLEQ
[12:24:45] <cmr> orshem: much
[12:24:57] <dbaupp> engla: seems that you're right
[12:25:08] <orshem> i'e seen pcwalton sprocket which is nice
[12:25:10] <dbaupp> rusti: trait Foo { fn foo(&self) -> uint; } impl Foo for uint {fn foo(&self) -> uint {0}} fn bar<F:Foo>(f:F){f.foo()} let x = @1u as @Foo; bar(x)
[12:25:12] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/DGBY
[12:25:17] <engla> orshem: errors should not pass silently, fits with rust. As does namespaces.
[12:26:02] <dbaupp> orshem: unfortunately there's very little modern Rust code around... because "modern" = "less than 2 weeks old", as Rust moves so fast
[12:26:16] <Sergio965> Rust moves too fast.
[12:26:28] <cmr> Sergio965: THe faster it moves, the quicker it gets there
[12:26:47] <Sergio965> Looking at some of the discussion, however, I feel that "there" is currently undefined.
[12:27:26] <dbaupp> I think the core devs have various ideas about where "there" is, at least with respect to their specialities
[12:27:27] <cmr> the core devs have a pretty solid idea of what the language is going to be, minus a few fuzzy details here and there
[12:28:08] <cmr> most of the problem with rust isn't necesarily language, but buggy + incomplete compiler
[12:28:10] <orshem> engla: yep. i really like the safety aspect of rust. the option type, match...
[12:28:41] <orshem> dbaupp: yes it's amazing watching the activity on github
[12:29:26] <Sergio965> That's fair. I certainly don't mean to imply that the language has no direction; this is evident from the discussion as well. Simply, it seems that the destination target simply to be constantly in motion.
[12:29:28] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[12:29:55] <Sergio965> IE, after reading though much of the rust-dev mailing list, it's unclear when features will stop being introduced and the language will be stabilized.
[12:30:09] <Sergio965> introduced/reworked, ala internal vs. external iterators.
[12:30:09] <dbaupp> (and features being removed.)
[12:30:28] <orshem> dbaupp: features being removed is always good
[12:30:29] <cmr> Sergio965: https://github.com/mozilla/rust/issues?milestone=14&state=open
[12:30:46] <cmr> plus the backwards-compat and well-defined issues
[12:30:53] <dbaupp> orshem: yes
[12:30:58] <Sergio965> 0.7 is past due. :(
[12:31:09] <dbaupp> Sergio965: various problems with getting tests to pass
[12:31:10] <Sergio965> Oh, there's only 8 left.
[12:31:18] <orshem> dbaupp: i'd love to read a blogpost from a rust expert/dev on obsolete features and why were they removed, what didn't work aout them
[12:31:18] <cmr> Sergio965: 0.7 has already been cut
[12:31:24] <Sergio965> Oh.
[12:31:24] <cmr> just releng stuff
[12:31:42] <Sergio965> What do you mean cut? Skipping past 0.7 to 0.8?
[12:31:58] <dbaupp> Sergio965: as in, the release is attempting to be built now
[12:32:20] <dbaupp> orshem: there's a bug along those lines somewhere... just trying to find it now
[12:32:34] <nano> lets hope the 0.7 windows binaries will work for me
[12:32:38] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Ping timeout)
[12:32:45] <Sergio965> The GC is being built in Rust? That's crazy.
[12:33:02] <orshem> nano: you need a very specific version of mingw
[12:33:04] <cmr> Sergio965: why? rust is a perfectly suitable low level language.
[12:33:16] <dbaupp> Sergio965: the whole runtime of Rust being in Rust... that's pretty crazy ;P
[12:33:24] <dbaupp> orshem: https://github.com/mozilla/rust/issues/4632
[12:33:27] <Sergio965> cmr: Indeed, I'm aware of this. It's simply a big undertaking.
[12:33:37] <dbaupp> orshem: (and https://github.com/mozilla/rust/issues/2172)
[12:33:42] <Sergio965> dbaupp: That's one of the most appealing features, to me.
[12:34:04] <cmr> Sergio965: it's already done, too. the compiler just uses too much memory for it to be released yet, uses more than the 32bit address space
[12:34:17] <dbaupp> Sergio965: same, I'm really keen for Rust to have little-to-no non-pure-Rust/asm dependencies
[12:34:48] <orshem> dbaupp: wow they really removed lots of stuff
[12:34:57] <nano> orshem, oh thats why
[12:35:03] <Sergio965> cmr: Does it actually use > 4GB of memory, or just somehow allocate 2^32 bytes of address space?
[12:35:14] <cmr> SimonSapin: actually uses > 4GB memory
[12:35:17] <dbaupp> Sergio965: yes, when building librustc
[12:35:19] <cmr> erm, Sergio965
[12:35:25] <nano> does the last mingw version still not work with rust?
[12:35:26] <Sergio965> :|
[12:35:29] <Sergio965> Where does it all go?...
[12:35:34] <orshem> dbaupp: what is const really? i'm still not clear
[12:35:49] <cmr> Sergio965: the compiler is very inefficient, and our runtime code isn't very space efficient
[12:36:01] <dbaupp> orshem: 'const' == 'not mutated through this reference'
[12:36:04] <bstrie> nano: I doubt it
[12:36:14] <Sergio965> Someone should start a new mini-rustlibc project.
[12:36:17] <dbaupp> (assuming we're talking about the same const)
[12:36:38] <cmr> Sergio965: A fine idea in theory, but 1. there's no spec, 2. various things are very difficult to get right
[12:36:47] <cmr> name resolution, borrow check, type check
[12:36:57] <cmr> It's not a simple language to compile
[12:37:06] <cmr> Lots of reasoning that needs to be done to reject invalid code
[12:37:23] <orshem> nano: see here: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust
[12:37:23] <dbaupp> Sergio965: there's also a whole pile of legacy crap in librustc (i.e. the actual code is bad)
[12:37:31] <nano> orshem, ty
[12:37:58] <orshem> dbaupp: then const is not really a good name for it. was it taken because of c++?
[12:38:16] <orshem> also, what is the const trait?
[12:38:17] <dbaupp> orshem: don't know
[12:38:20] *** Quits: Sergio965 (sergiobz@1B3BBE83.33D83D78.3A99D594.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz‚Ä¶)
[12:38:43] <dbaupp> orshem: "* Freeze - types that are deeply immutable."
[12:38:47] <nano> >This is a requirement on Windows 64 bit for LLVM to compile correctly, according to their docs.
[12:38:56] <dbaupp> orshem: (I think Const got renamed to Freeze)
[12:38:56] <nano> so its just an issue of llvm -.-
[12:38:56] *** Joins: SingingBoyo (brandon@moz-EAC7E73D.bchsia.telus.net)
[12:39:40] <dbaupp> orshem: that is, if T: Freeze, then `let x: T = something;` means that the whole structure that `x` can refer to is immutable (i.e. no @mut's or &mut's)
[12:40:07] <orshem> dbaupp: so that's not like a const type at all
[12:40:21] <orshem> you said: " 'const' == 'not mutated through this reference'"
[12:40:30] <dbaupp> orshem: right, they're separate
[12:40:48] <dbaupp> (and probably the part of the reason that the trait got renamed to Freeze)
[12:40:58] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[12:43:48] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[12:45:23] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:45:36] *** Joins: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu)
[12:46:00] <Sergio965> In other news, when are we having that Boston meetiup?
[12:46:02] <Sergio965> meetup*
[12:47:06] *** Quits: SingingBoyo (brandon@moz-EAC7E73D.bchsia.telus.net) (Ping timeout)
[12:47:41] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[12:48:59] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[12:56:59] <SimonSapin> Can I move a field out of a struct in an expression, and also "consume" the struct to avoid the "cannot move out of field" error?
[12:57:30] <SimonSapin> maybe a destructuring match
[12:57:54] <dbaupp> SimonSapin: yeah, match foo { A { x, y, z } => .. } should work
[13:00:53] <SimonSapin> ow, * for ignoring the remaining fields does not work in a struct pattern
[13:01:02] <cmr> it's _ in structs
[13:01:18] <cmr> no there is no reason for this, yes there is an issue open about it :p
[13:01:43] <SimonSapin> I mean, so I don‚Äôt have to write each remaining field with _
[13:01:57] <cmr> You should be able to use a single unnamed _
[13:02:39] <SimonSapin> oh, right
[13:02:45] *** Joins: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca)
[13:02:56] <SimonSapin> It didn‚Äôt work because of another mistake
[13:02:58] <dbaupp> rusti: struct Foo { bar: u8, baz: u8, qux: u8 } match Foo{bar:1,baz:2,qux:3} { Foo{bar, _} => bar }
[13:02:59] -rusti- 1
[13:04:49] <SimonSapin> Is it a bug if vec::map(foo, ‚Ä¶) works but not foo.map(‚Ä¶)?
[13:05:36] <SimonSapin> "type `~[T]` does not implement any method in scope named `map`"
[13:06:20] <dbaupp> SimonSapin: do you happen to have #[no_std] somewhere at the top of the crate?
[13:06:29] <SimonSapin> no
[13:06:31] <dbaupp> hm
[13:06:50] <Ms2ger> SimonSapin, map is something terrible...
[13:06:51] <ross> I had that same problem. but it was back in 0.6
[13:06:52] <SimonSapin> but rustc from June 20
[13:07:10] <ross> haven't tried since then
[13:07:14] <engla> yeah it changed lately SimonSapin 
[13:07:21] <Ms2ger> v.iter().transform(f).collect::<~[SomeType]>()
[13:07:25] <dbaupp> engla: way after June 20 though
[13:07:33] <dbaupp> .map should still exist
[13:07:53] <engla> dbaupp: you added .map on Sat Jun 29 15:05:50 
[13:07:57] <engla> I think
[13:08:00] <dbaupp> (and, in fact, I only removed vec::map, the method still exists the latest rust)
[13:08:03] <dbaupp> engla: I don't think so?
[13:08:14] <engla> no just switching it around
[13:08:15] <Ms2ger> Ah, hmm
[13:08:16] <engla> yeah
[13:08:17] * Ms2ger misread
[13:08:18] <engla> sorry
[13:08:46] <dbaupp> engla: (I was going to, but replacing .map with .iter().transform().collect::<typehint>() is horrible :/ )
[13:09:03] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[13:09:04] <engla> yes
[13:09:09] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[13:09:19] <Seldaek> yeah it's nice to have a strong iterator concept but helper methods for common tasks are nice too
[13:09:22] <Seldaek> because this is insanity
[13:09:45] <ross> I haven't kept up with the new iterator plans and stuff. is a call to filter or map methods going to return the same type? so we can chain them
[13:10:15] <bstrie> engla: eventually the .iter() bit should be unnecessary
[13:10:21] <bstrie> and .transform will get named to .map
[13:10:26] <dbaupp> Seldaek: yeah, I think we're resisting adding more methods until we really understand what's going on/how they're used
[13:10:31] <SimonSapin> ross: AFAIU .transform() is map for iterators, and returns an iterator
[13:10:41] <engla> bstrie: yes. so it seems fine to just keep vec.map around until the switchover to iterator-based vec.map
[13:10:51] <bstrie> the name "transform" is just because of that dumb generics bug
[13:10:52] <kimundi> well, ulimatly it's just going to be "let x = vec.map(...)" -> "let x: ~[T] = vec.map().collect()"
[13:11:01] <dbaupp> Seldaek: (since all the standard APIs in std are unnecessarily huge, with a lot of silly repeats.)
[13:11:04] <engla> ross: not the same type, but it implements the same traits.. so you can chain them
[13:11:11] <SimonSapin> bstrie: what bug is that?
[13:11:19] <ross> ah ok cool
[13:11:21] <dbaupp> SimonSapin: #5898
[13:11:25] <Seldaek> dbaupp: fair enough, I just hope it doesn't stay forever like this :)
[13:11:27] * dbaupp has that number memorised
[13:11:33] <dbaupp> Seldaek: I hope not too
[13:12:10] <engla> ross: types are going to be tricky if you have to type out the type of a long chain of iterator combinators. hopefully you don't.
[13:12:15] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[13:12:17] *** Quits: igl (igl@moz-D83316AC.adsl.alicedsl.de) (Ping timeout)
[13:12:37] <kimundi> "let v2 = v1.map(...).filter(...)" // allocates twice, hardcoded to vector
[13:13:30] * dbaupp is removing filter now
[13:13:33] <kimundi> "let v2: ~[T] = v1.map(...).filter(...).collect()" // with iterator, just allocates once for the result, wich can be any type that implements FromIterator
[13:13:48] *** Joins: igl (igl@moz-FB10C277.adsl.alicedsl.de)
[13:14:15] <ross> that's great
[13:14:52] <ross> in the second example, does ": ~[T]" indicate that type inference wouldn't work?
[13:14:59] <ross> or just being explicit?
[13:15:02] <engla> also you can add your own combinators with the same method IteratorUtil is using. so if you really don't like to give .collect() hints, just implement .to_vec()
[13:15:10] <kimundi> well, collect() is generic
[13:15:22] * dbaupp wishes there was a briefer way to write functions that take iterators and return transformations of those iterators
[13:15:35] <engla> yes dbaupp
[13:15:47] <dbaupp> ross: yes, type inferences doesn't work for .collect()
[13:15:49] <kimundi> it can result in a ~[T] but also a HashSet<T> or whatever else implements the trait
[13:15:50] <dbaupp> it's very annoying
[13:16:29] <bstrie> that's kind of the point
[13:16:37] <bstrie> you can collect anything into anything else
[13:16:38] <kimundi> so, you need to make a decission somewhere WHICH type of container you want to construct... I'm not sure if it is possible to infere that
[13:16:52] <bstrie> you can collect a vector into a hash table if you want
[13:17:02] <SimonSapin> so, method dispatch depends not just on the type of self but also the return type?
[13:17:29] <bstrie> we can parameterize over return type, if that's what you mean
[13:17:30] <engla> right it should be simple to just say  let m: HashMap<..> = v.zip(u).collect()
[13:17:39] <bstrie> engla: yes, that's how it works
[13:17:58] <bstrie> assuming that you put the right types in for ..
[13:17:58] <dbaupp> bstrie: unfortunately, it requires filling in the <>
[13:18:35] <kimundi> problem is that anything you could do to to the result of a collect() call in your code you could also do to any type that implements the right things, so the inference algorithm can't constrain it to one specicfic type
[13:19:09] <ross> github keeps going down :\
[13:19:26] <cmr> https://status.github.com/
[13:19:33] <engla> fortunately a lot of the collect calls go directly to the return value, where there already is a mandatory type "hint".
[13:19:51] <dbaupp> engla: or straight into a struct/enum field
[13:27:06] *** Quits: BigEndian (hurp@moz-1B6DD81E.members.linode.com) (Ping timeout)
[13:27:43] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[13:29:06] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:30:28] *** Joins: BigEndian (hurp@moz-1B6DD81E.members.linode.com)
[13:34:16] <ross> ok here's a tiny example of this linker error I keep getting
[13:41:05] <cmr> RE: the most recent post to the ML, is it possible to write a macro that would do that? (it would expand to a bunch of foo.insert(k, v) calls)
[13:41:55] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[13:41:58] <doy> i don't think that's what the ml post is asking for
[13:42:02] <SimonSapin> cmr: I think the point is to have the result static, shared between tasks
[13:42:05] <dbaupp> cmr: yeah, in fact, bjz had one
[13:42:06] <doy> yeah
[13:42:33] <bjz> ?
[13:42:35] <SimonSapin> I‚Äôve wanted that too
[13:42:41] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:42:45] <dbaupp> bjz: your hashmap! macro?
[13:42:54] <dbaupp> (that was you?)
[13:43:18] <doomlord> scrolling up - iter().map().filter().collect() ....
[13:43:32] <cmr> SimonSapin: then hashmaps would need to be a language construct, wouldn't they?
[13:43:35] <doomlord> ... i implementeed something similar in C++ with lazy templates.  i finished it off with a .do()
[13:43:38] <bjz> https://gist.github.com/bjz/821a6d00b2ef6d5450e7
[13:43:42] <ross> ok. github finally responded
[13:43:44] <ross> https://github.com/rossmurray/r-link-test
[13:43:53] <ross> can somebody pull that and try to build it?
[13:43:54] <SimonSapin> cmr: I don‚Äôt know
[13:43:57] <ross> it's a tiny example
[13:44:14] <bjz> hashmap macro -> https://gist.github.com/bjz/821a6d00b2ef6d5450e7
[13:44:44] <SimonSapin> cmr: what if modules could have "initialization" code that results in task-shared immutable stuff?
[13:44:53] <dbaupp> ross: "test.rc:(.text+0x30): undefined reference to `libb::init::_bff2288732198b79::_001'"
[13:44:54] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:45:04] <dbaupp> ross: (that's what you see too?)
[13:45:29] <ross> yes
[13:45:45] <ross> I've been getting that error trying to use brson's rust-sdl for a few days
[13:45:50] <cmr> Actually I think it could be implemented with unsafe code, just make a &'static
[13:45:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:46:16] <ross> I updated the readme.md with the error. but yeah, same one
[13:46:30] <dbaupp> cmr: a macro that expanded to the actual HashMap { .. } struct, would probably work
[13:46:36] <dbaupp> (except the fields are private)
[13:46:55] <dbaupp> cmr: (that would work without unsafe code, since it'd just be a literal)
[13:47:13] <dbaupp> hm, actually... it requires ~[] internally, so maybe not.
[13:47:21] <cmr> And you'd need CTFE for that, to hash the values.
[13:47:31] <SimonSapin> dbaupp: to get a litteral you‚Äôd need to re-implement the hashing in macros, right'
[13:47:33] <SimonSapin> ?
[13:47:48] <dbaupp> cmr, SimonSapin: not with an actual syntax extension
[13:47:54] *** Quits: reyre (rick@B2D8AB09.33EE9F8A.1139E686.IP) (Ping timeout)
[13:47:56] <dbaupp> (i.e. one written in Rust)
[13:48:15] *** Joins: reyre (rick@B2D8AB09.33EE9F8A.1139E686.IP)
[13:48:18] <SimonSapin> dbaupp: so, make hashmap special in the language
[13:48:19] <ross> should I open an issue for that? or am I doing something wrong
[13:48:19] <cmr> dbaupp: right, but you still need to hash the value... using the specific struct's Hash implementation
[13:48:24] <dbaupp> SimonSapin: right
[13:48:33] <dbaupp> cmr: oh, I see, yeah, that'd get tricky
[13:48:41] <dbaupp> ross: it's not obvious if you are
[13:48:52] <dbaupp> ross: (although, .rc is deprecated)
[13:48:57] <ross> oh really
[13:49:07] <ross> can I put that stuff in the .rs file
[13:49:07] <dbaupp> ross: but it shouldn't make a difference
[13:49:08] *** Quits: roo (jesse.rudo@moz-447A642A.dynamic.ip.windstream.net) (Ping timeout)
[13:49:14] <cmr> ross: yes
[13:49:14] <dbaupp> yeah
[13:49:20] <SimonSapin> dbaupp: I would have hopped for arbitrary static immutable types :)
[13:49:56] <dbaupp> SimonSapin: any struct / enum can be a static
[13:50:08] <dbaupp> (assuming it doesn't have ~/@ pointers in it)
[13:50:36] <dbaupp> rusti: struct Bar { x: uint } static b: Bar = Bar { x: 1 } b
[13:50:36] -rusti- <anon>:9:61: 9:62 error: expected `;` but found `b`
[13:50:36] -rusti- <anon>:9          struct Bar { x: uint } static b: Bar = Bar { x: 1 } b
[13:50:37] -rusti-                                                                       ^
[13:50:37] -rusti- application terminated with error code 101
[13:50:40] <dbaupp> rusti: struct Bar { x: uint } static b: Bar = Bar { x: 1 }; b
[13:50:42] -rusti- {x: 1}
[13:52:11] <dbaupp> ross: I thought that having a submodule with the same name as the crate might be confusing it, but apparently not
[13:52:33] <dbaupp> ross: wait...
[13:52:39] <ross> http://pastebin.com/qakkYSQX
[13:52:51] <dbaupp> ross: you need `pub mod libb;`
[13:53:32] <dbaupp> ross: that code is recursively importing itself with the `mod libb`
[13:53:36] <ross> heh
[13:53:43] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[13:53:47] <dbaupp> ross: (my previous comment is referring to your original code)
[13:53:55] <ross> gotcha
[13:54:17] <dbaupp> also, it's unusual to have a submodule with the same name as the crate, because then the users write foo::foo:: all the time
[13:54:26] <SimonSapin> So I have some data (in this case JSON files) distributed with the code, that I want to read from the code. Is there some kind of "well known filename" mechanism, or should I embed string literals?
[13:54:31] <ross> I see
[13:54:41] <dbaupp> (or import `foo::*` and use then `foo::...` which is strange.)
[13:54:52] <ross> yeah good point
[13:55:54] <dbaupp> ross: (that bug with recursive modules appears to be an unfiled bug, would you like to file it? :) )
[13:55:59] <ross> sure
[13:56:18] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[13:57:01] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[13:57:13] <dbaupp> recursive_mod.rs 'mod recursive_mod;' is a minimal testcase :)
[13:57:38] <dbaupp> (well, I guess a.rs 'mod a;' is truly *the* minimal testcase)
[13:58:09] <dbaupp> SimonSapin: i.e. a convention for carrying data around? I'm not sure there is one
[13:58:50] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:59:00] <dbaupp> (although, you can use include_bin! and include_str! to load data from files at compile time)
[13:59:15] <SimonSapin> dbaupp: ah, interesting
[13:59:30] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:59:44] <dbaupp> SimonSapin: (I think they are slightly unreliable though... large-ish files might crash the compiler(?))
[14:00:34] <dbaupp> rusti: include_bin!("/bin/true").len()
[14:00:34] -rusti- <anon>:9:34: 9:35 error: unexpected token: `.`
[14:00:35] -rusti- <anon>:9          include_bin!("/bin/true").len()
[14:00:35] -rusti-                                            ^
[14:00:35] -rusti- application terminated with error code 101
[14:00:36] <SimonSapin> my largest file is ~20k
[14:00:44] <dbaupp> rusti: (include_bin!("/bin/true")).len()
[14:00:46] -rusti- 27208
[14:00:54] <dbaupp> SimonSapin: I guess that's fine then
[14:01:00] <dbaupp> rusti: (include_bin!("/bin/cat")).len()
[14:01:02] -rusti- 47944
[14:01:08] <dbaupp> rusti: (include_bin!("/bin/sh")).len()
[14:01:09] -rusti- Killed
[14:01:09] -rusti- application terminated with error code 137
[14:03:40] <bstrie> rusti: include_bin!("/etc/passwd")
[14:03:42] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/Khef
[14:04:05] <dbaupp> rusti: println(include_str!("/etc/passwd"))
[14:04:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TRBD
[14:04:33] <bstrie> rusti: println(include_str!("/etc/shadow"))
[14:04:33] -rusti- <anon>:9:17: 9:45 error: error opening /etc/shadow
[14:04:33] -rusti- <anon>:9          println(include_str!("/etc/shadow"))
[14:04:33] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[14:04:33] -rusti- application terminated with error code 101
[14:04:41] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[14:09:20] *** Quits: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de) (Ping timeout)
[14:10:03] *** Joins: mib_0ufh9s (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:12:16] *** kimundi is now known as zz_kimundi
[14:13:18] <ross> hm, do you have to fork a repo on github to create a pull request?
[14:13:28] <cmr> yes
[14:13:35] <cmr> well, not entirely true
[14:13:42] <cmr> you can crate pull requests between branches of the same repo
[14:13:44] <cmr> but otherwise,y es
[14:15:26] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:19:29] <SimonSapin> oh sh**
[14:19:38] <SimonSapin> I‚Äôve been using an older version of rust than I though for days
[14:21:01] *** Quits: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net) (Input/output error)
[14:21:06] *** Joins: jack (jack@moz-F1B36F9F.hsd1.nm.comcast.net)
[14:21:20] <dbaupp> SimonSapin: how much older?
[14:21:27] <jack> bjz: pong
[14:21:30] <SimonSapin> not sure, I just nuked it
[14:21:34] <SimonSapin> but it had libcore
[14:21:48] <SimonSapin> and allowed "pub impl"
[14:22:23] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[14:24:09] <jedestep> sounds like around beginning of june
[14:24:42] <SimonSapin> but I lost colored output
[14:24:44] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[14:24:55] <cmr> on which commit?
[14:25:07] <dbaupp> what version are you on now?
[14:25:17] <SimonSapin> 0.6 (f348465 2013-06-20 11:35:34 -0700)
[14:25:23] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[14:25:25] <cmr> has since been fixed
[14:25:42] <dbaupp> Is that the "blessed" current version for servo?
[14:25:57] <SimonSapin> yes
[14:26:00] <jack> dbaupp: no. servo is on HEAD from friday
[14:26:20] <dbaupp> jack: woah! modern! :)
[14:26:22] <SimonSapin> well, since last time I pulled and rebuilt
[14:26:24] <SimonSapin> doing that now
[14:26:36] <jack> brson: upgraded us late last week
[14:26:47] <jack> s/://
[14:26:56] <dbaupp> nice (must've been a bit of a herculean effort.)
[14:28:36] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:28:58] *** Joins: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de)
[14:30:10] *** cadecairos is now known as cade
[14:34:42] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[14:36:44] <jedestep> does @[T] really do anything?
[14:36:58] <dbaupp> jedestep: in what sense?
[14:37:12] <jedestep> it doesn't implement any useful vector methods
[14:37:36] <dbaupp> the ones on &[T] should work for @[T]
[14:37:45] <jedestep> hmm
[14:37:53] <dbaupp> (in theory)
[14:38:09] <dbaupp> (but it is a bit of a neglected child.)
[14:38:33] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:39:00] *** Joins: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP)
[14:40:03] <mark_edward> is there anyway to only compile a part of librustc if you're hacking on it?
[14:40:11] <cmr> mark_edward: no
[14:40:19] <mark_edward> :-(
[14:40:28] <cmr> yup
[14:41:34] <MaikKlein> did you guys also had/have to do homework for your university in order to get an approval to write the exam?
[14:42:06] <dbaupp> MaikKlein: nope
[14:42:12] <jedestep> with += removed, there doesn't appear to be any way to add elements to a @ vector
[14:42:45] <dbaupp> jedestep: .push
[14:42:52] <jedestep> not implemented for @[T]
[14:43:00] <dbaupp> hm, actually, at_vec::raw::push
[14:43:19] <dbaupp> however, anything that mutates @[T] is pretty bad, since @[T] is meant to be immutable
[14:44:08] <mark_edward> i don't understand the rational of traits like Const, Freeze, etc. 
[14:44:21] <mark_edward> in my moronic opinion, you're either mutable or immutable
[14:44:32] <mark_edward> can someone correct me?
[14:44:34] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:44:44] <nmatsakis> mark_edward: (a) Const and Freeze are the same trait,
[14:45:00] <dbaupp> mark_edward: (just checking, have you read the description at the top of std::kinds? :) )
[14:45:05] <nmatsakis> mark_edward: and (b) in rust, mutability is inherited from context.
[14:45:19] <nmatsakis> mark_edward: consider "let mut x = 3" --> x has type integer, but that integer is mutable.
[14:45:23] <doomlord> so you need both const and mut to change it one way or the other?
[14:45:29] <mark_edward> okay, but what's their purpose when you've got mut/immutability?
[14:45:41] <jedestep> @mut [T] also does not seem to implement push. only way to effectively deal with them is through unsafe code
[14:45:41] <nmatsakis> mark_edward: nonetheless, the type `int` is not inherently mutable, hence it's freezable. if you put an int in an immutable variable, it becomes immutable.
[14:45:51] <doomlord> if you inherited 'mut ' and you want to mark something as immutable again..
[14:46:03] <bstrie> never use @mut
[14:46:04] <nmatsakis> jedestep: you cannot resize an @mut [T]. it is only safe if you KNOW the value is unaliased.
[14:46:07] <bstrie> never ever
[14:46:08] <SimonSapin> Hum, now I‚Äôm getting "unresolved import. maybe a missing `extern mod extra`?" while `extern mod extra;` is exactly the previous line
[14:46:54] <mark_edward> nmatsakis: so freeze is to refer to types that may be put into an immutable slot?
[14:47:01] <jedestep> ah, that makes sense
[14:47:15] <mark_edward> what types are inherently mutable?
[14:47:54] <dbaupp> jedestep: essentially, @(mut) [T] is bad, and the only safe construction is ~ -> @ and immutable after that
[14:48:00] <nmatsakis> mark_edward: @mut, &mut.
[14:48:22] <nmatsakis> mark_edward: anything can be put into an immutable slot, it's just that putting it in such a slot does not render the value immutable.
[14:48:41] <mark_edward> but, couldn't they just be put into mutable/immutable slots?
[14:49:11] <nmatsakis> mark_edward: I'm saying: "let x = @mut 3" gives you a pointer to a mutable int.
[14:49:21] <dbaupp> SimonSapin: what's the line that gives that?
[14:49:34] <SimonSapin> use extra::json;
[14:49:35] <nmatsakis> mark_edward: or rather, a mutable box containing an int. this despite the fact that `x` itself is immutable.
[14:50:02] <mark_edward> in my ideal situation &T = immutable pointer to immutable T. &mut T = immutable pointer to mutable T . mut &mut T = mutable pointer to mutable T
[14:50:08] <mark_edward> do i have it wrong?
[14:50:20] <dbaupp> no
[14:50:40] <nmatsakis> mark_edward: nothing, that's about right, it's just you could have T == @mut 3
[14:50:45] <nmatsakis> mark_edward: er, T = @mut int
[14:50:50] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[14:50:57] <nmatsakis> mark_edward: in which case, you have an immutable pointer to a mutable box 
[14:51:05] *** Joins: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP)
[14:51:06] <mark_edward> so then... why do you need const? isn't everything you need to know about whether the value changes or not right there?
[14:51:15] <jedestep> is there a reason that @[T] exists then? it seems like it is useful in a very fringe case at best
[14:51:31] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[14:51:38] <nmatsakis> mark_edward: point is, sometimes you want to rule out mutable boxes, and guarantee that if you have an &T, the value is deeply immutable.
[14:51:58] <mark_edward> i thought that in Rust mutability was transitive
[14:52:21] <jedestep> for owned types it is
[14:52:25] <mark_edward> if you have an immutable struct, then all members are immutable right?
[14:52:40] <nmatsakis> mark_edward: it is, through ownership, but not through @ (which permits aliasing)
[14:52:53] <nmatsakis> mark_edward: you can think of @ values as being owned by the garbage collector
[14:53:00] <nmatsakis> mark_edward: point is, mutability is determined by the owner.
[14:53:13] <dbaupp> mark_edward: (and not through & either, since these aren't owned)
[14:54:46] <nmatsakis> mark_edward: you probably don't care about Freeze, tbh, unless you're building something for sharing between threads (like ARC)
[14:55:48] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[14:56:45] <mark_edward> ok. thanks for the explanations guys. i'm not sure i get it, but i'll try and do some reading on my own
[14:56:54] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[14:58:14] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[14:58:41] <SimonSapin> Shouldn‚Äôt "use std::str;" and others be in the prelude?
[14:59:49] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[14:59:50] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[15:00:04] <dbaupp> SimonSapin: it was actually removed, since `std::from_bytes(foo)` works, but `use str::from_bytes;` doesn't (i.e. it's inconsistent)
[15:00:24] <SimonSapin> ok
[15:00:33] <dbaupp> SimonSapin: (`use std::*;` works though ;) )
[15:01:53] <engla> it's cleaner to just have std by default
[15:02:08] <SimonSapin> fair enough
[15:02:31] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[15:02:52] *** zz_kimundi is now known as kimundi
[15:04:12] <SimonSapin> Does a June 20 rustc have external iterators?
[15:04:19] <SimonSapin> (or how can I test?)
[15:05:04] <engla> it has
[15:05:49] <engla> it's been gradually implemented, but you could test if vec has an .iter() method
[15:06:53] <dbaupp> (external iterators have been around for months now, but it's only recently that they've been good enough to actually start using.)
[15:08:56] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[15:09:40] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[15:10:36] <SimonSapin> dbaupp: didn‚Äôt the for loop change semantics?
[15:10:43] <cmr> not yet
[15:11:03] <SimonSapin> oh ok, that‚Äôs why we have .advance
[15:13:18] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[15:16:10] *** Joins: bent (chatzilla@moz-C8597CF0.vc.shawcable.net)
[15:22:40] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[15:24:01] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[15:27:56] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:34:22] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[15:38:40] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[15:38:40] *** ChanServ sets mode: +qo graydon graydon
[15:39:42] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[15:40:10] <SimonSapin> is there a replacement for range_step() ?
[15:40:36] <dbaupp> SimonSapin: it still exists?
[15:40:43] *** Quits: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be) (Ping timeout)
[15:40:53] <SimonSapin> oh, I‚Äôm probably not looking at the right module
[15:41:15] <dbaupp> if you're looking at the docs, it's not listed
[15:41:20] *** Quits: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP) (Quit: pyrac)
[15:41:39] <dbaupp> but all the integer modules have range_step.
[15:41:45] <SimonSapin> uhm, ok
[15:41:52] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[15:43:04] *** Quits: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de) (Ping timeout)
[15:43:18] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:44:56] *** Quits: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP) (Ping timeout)
[15:45:35] *** Joins: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP)
[15:47:10] *** Quits: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP) (Ping timeout)
[15:47:17] <cmr> this will be fixed by rustdoc2 I think
[15:47:22] <cmr> it does macro expansion
[15:50:20] *** Parts: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) ()
[15:50:22] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[15:50:22] *** Joins: nano (nano@moz-972880B.superkabel.de)
[15:50:28] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[15:50:57] <SimonSapin> the .rc files for libstd and libextra are still called core.rc and std.rc :)
[15:51:19] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:51:32] *** Joins: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP)
[15:55:44] <doener> SimonSapin: no, they were renamed a week ago
[15:56:04] <SimonSapin> old versions strike again
[15:56:28] *** Joins: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP)
[15:57:29] <SimonSapin> So, for some reason extern mod extra; then use extra::json; gives me an error "unresolved import. maybe a missing `extern mod extra`?"
[16:00:38] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[16:00:38] *** ChanServ sets mode: +o dherman
[16:00:45] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:00:55] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[16:01:26] *** Joins: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP)
[16:01:41] *** Joins: brson (brson@C261DB39.6E5482D7.8DDCAE07.IP)
[16:01:41] *** ChanServ sets mode: +o brson
[16:01:44] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[16:02:05] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:03:42] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:03:49] *** Quits: pyrac (pyrac@485A97CA.73C89388.AD05C589.IP) (Ping timeout)
[16:03:52] <graydon> https://etherpad.mozilla.org/Meeting-weekly-2013-07-02
[16:05:43] <jedestep> I have a struct which contains an iterator. why does the self pointer get moved when I call skip_while on the iterator?
[16:08:10] <bstrie> jedestep: strcat is the one to ask, when he's on
[16:09:20] <jedestep> i'm not sure if it's an iterator specific problem or if i just am still failing to understand anything
[16:09:36] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[16:09:36] *** ChanServ sets mode: +o pcwalton
[16:10:03] <jedestep> but i call self.it.skip_while(|c| *c == 'a') and it tells me that self can't be moved out of dereference of & pointer
[16:10:23] <engla> jedestep: skip_while takes the iterator and creates a new one
[16:10:32] <doener> jedestep: take_while just wraps the iterator in a TakeWhileIterator, thus it is moved into that wrapper struct
[16:10:33] <bstrie> can you do self.clone() ?
[16:10:37] <engla> so you move the iterator into  SkipWhileIterator{ iter: it }
[16:10:37] <bstrie> this is blowing my mind
[16:10:52] <brson> https://etherpad.mozilla.org/Meeting-weekly-2013-07-02
[16:12:10] <jedestep> hmm i think i see how this works
[16:12:32] <jedestep> suppose i expected calling skip_while to actually just skip while the predicate was true
[16:13:17] *** Joins: bytbox (s@moz-75D4B5A8.wireless.umd.edu)
[16:13:18] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[16:13:32] <engla> jedestep: actually, nothing happens until you ask for the next element of the iterator
[16:13:41] <engla> so it's lazy in that sense
[16:16:05] <engla> so you can skip_while on an infinite iterator
[16:16:36] <jedestep> seems that what i'm looking for is
[16:17:03] <jedestep> for self.it.clone().skip_while(foopredicate).advance |_| { }
[16:18:05] <engla> yes. if you want to use self.it  many times you'll have to clone it anyway
[16:18:29] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:18:39] <engla> uh if you leave that { }  empty, no you don't want that
[16:18:51] <engla> unless the iterator is only there for side effects
[16:19:07] <jedestep> it is
[16:19:10] <strcat> graydon: did you see that buildbot broke?
[16:19:23] <jedestep> i literally want to skip every element for which foopredicate is true
[16:19:26] <jedestep> and do nothing with them
[16:19:36] <strcat> graydon: https://github.com/mozilla/rust/issues/7515
[16:19:38] <cmr> jedestep: it's take_while or sth isn't it?
[16:19:39] <bstrie> jedestep: how about .filter ?
[16:19:44] <engla> jedestep: and then?
[16:19:49] <bstrie> filter out all the falses, then iterate over that
[16:20:03] <brendanc> looks like the mac slaves have somehow gotten wedged
[16:20:03] <engla> jedestep: if you're skipping on a clone, then the original self.it will be unaffected.
[16:20:17] <jedestep> ugh
[16:20:26] <jedestep> i should just filter it
[16:20:47] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[16:20:57] <engla> you have a conceptual problem.. because skip_while will have to examine the last value where the predicate is suddenly false
[16:20:59] <cmr> iterators are just a view, filtering one doesn't modify the original vector
[16:21:05] <engla> and you have to use that value right after that
[16:21:26] <engla> you can't push it back into the iterator.. unless you use the normal skip_while wrapper
[16:22:28] <brendanc> all the mac builds are stuck in an uninterruptible git clone/reset/rm -rf loop
[16:22:56] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[16:23:01] <jedestep> this is very unfortunate, i was hoping to move my parsing over to iterators
[16:23:32] <strcat> what's the problem?
[16:23:42] *** Quits: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP) (Ping timeout)
[16:23:45] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[16:24:29] <jedestep> doing some text parsing, trying to use iterators, the nature of things like filter and skip_while not meshing with how i was approaching it
[16:25:23] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[16:25:53] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[16:27:09] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:27:59] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:28:15] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[16:28:21] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[16:28:21] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/3dv_4A
[16:28:21] <ghrust> 13rust/06master 14a2db7c1 15Brian Anderson: doc: Update links to 0.7
[16:28:21] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[16:29:18] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[16:29:18] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:30:33] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:30:33] <ghrust> 01[13rust01] 15brson merged 06master into 06dist-snap: 02http://git.io/zW10ww
[16:30:33] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:30:47] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[16:31:21] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:31:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1498f0e85 to 14a2db7c1: 02http://git.io/N3iJvQ
[16:31:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:31:23] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:31:23] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/dRSMSw
[16:31:23] <ghrust> 13rust/06auto 149e6d5e1 15Niko Matsakis: Defer reasoning about region relationships until after regionck....
[16:31:23] <ghrust> 13rust/06auto 1442344af 15Niko Matsakis: Correct handling of if/match, and make explicit computation of...
[16:31:24] <ghrust> 13rust/06auto 1479ea266 15Niko Matsakis: move docs into doc.rs
[16:31:25] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:31:45] <kmc> so I know the syntax ¬´&'a str¬ª but what's @Foo:'a or foo<A:'a> ?
[16:32:09] <cmr> kmc: eh? where have you seen those?
[16:32:12] <engla> lifetime bounds similar to trait bounds
[16:32:36] <jack> cmr: rust meeting notes
[16:32:40] <engla> there are discussing that in the meeting, way over my head
[16:32:46] <cmr> oh
[16:36:23] <bblum> kmc: that syntax is... similar to the syntax StructName<'a>
[16:36:59] <bblum> it means the trait contains data which may not outlive the lifetime 'a
[16:37:21] <kmc> ok
[16:37:26] <bblum> fn:'a() is the same
[16:37:35] <bblum> the difference is that it's a bound on the existential data, whereas <'a> is more of a forall-instantiation
[16:37:36] <kmc> this is a trait as an object right?
[16:37:39] <bblum> yes
[16:37:43] <bblum> trait-as-type
[16:37:46] <engla> you can require a type parameter to only have 'static pointers by  <T:'static>
[16:38:00] <bblum> this syntax currently doesn't exist
[16:38:03] <bblum> well
[16:38:07] <bblum> you can do Trait:'static
[16:38:13] <bblum> but not yet with arbitrary lifetimes
[16:38:17] <kmc> ok
[16:38:29] <bblum> but you should be able to do it
[16:38:42] <engla> bblum: did you figure out if &'static fn:'static(..) should be static?
[16:38:53] <bblum> engla: it seems like it should
[16:38:58] <engla> maybe it's just ~Trait that's the problem
[16:39:05] <bblum> what's the problem?
[16:40:34] *** Joins: eholk (eholk@moz-F6BEA424.uconnect.utah.edu)
[16:40:55] <engla> we discussed it some days ago.. I'll find a testcase
[16:41:30] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[16:44:00] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:44:56] <SimonSapin> Lifetime syntax is hard. What am I missing in this code? http://pastebin.mozilla.org/2586141
[16:45:00] <bblum> ecr: http://buildbot.rust-lang.org/bors/bors.html
[16:45:29] <SimonSapin> trying to make an iterator which contains a & pointer to the object
[16:45:39] *** Joins: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be)
[16:46:03] <bblum> SimonSapin: impl <'self> Parser<'self>
[16:46:17] <bblum> maybe just impl <'self> Parser?
[16:46:19] <engla> bblum: like this I think   https://gist.github.com/anonymous/ada489c2d3f4ac60d705
[16:46:38] *** Joins: jviereck (Adium@moz-5295735C.adsl.alicedsl.de)
[16:47:01] <bblum> SimonSapin: in general, when it says "declared" it means you need a forall introduction on the fn or impl item
[16:47:33] <kmc> since i've just jumped in, is there some background reading on these write guard bits for mutable boxes?
[16:47:45] <SimonSapin> bblum: " no region bound is allowed on `tokenizer::Parser`, which is not declared as containing region pointers"
[16:48:07] <SimonSapin> I want a pointer to Parser, not in
[16:48:11] <bblum> engla: https://github.com/mozilla/rust/issues/7268 that's this issue, which should be fixed, and would make that program legal with no changes necessary
[16:48:23] <strcat> kmc: you can look at extra::rc::RcMut for a simple implementation as a library
[16:48:29] <bblum> SimonSapin: yeah hm, that's kind of interesting
[16:48:40] <engla> ok bblum!
[16:48:47] <SimonSapin> for some values of interesting ? :)
[16:49:05] <engla> bblum: do you think I can put the testcase in that issue?
[16:49:10] <strcat> kmc: owned data inherits mutability, types like @mut/RcMut are inherently mutable since they aren't owned
[16:49:11] <bblum> engla: please do
[16:49:15] *** Joins: ecr1 (ereed@2557E599.66715431.D25A875A.IP)
[16:49:28] <bblum> SimonSapin: for the value of interesting that's like "hm, i didn't think about that case, i don't know how you could do it"
[16:49:45] *** Joins: ecr2 (ereed@2557E599.66715431.D25A875A.IP)
[16:49:46] <bblum> it seems like we should allow "phantom" <'self> introductions (i.e., on types that don't make use of it)
[16:49:56] <strcat> kmc: and it's pretty simple to break memory safety with & and &mut if you can get &mut at the same time as another pointer
[16:49:56] *** Quits: ecr (ereed@2557E599.66715431.D25A875A.IP) (Ping timeout)
[16:50:11] <bblum> SimonSapin: in the meantime, if you want to hack around it, put a field inside your Parser struct that's an Option<&'self ()> and just fill it with None
[16:50:25] *** Joins: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net)
[16:50:31] <SimonSapin> hmokay
[16:50:43] <kmc> strcat: I believe it, but can you give a concrete example so I understand the details?
[16:51:02] <strcat> kmc: take an & inside a sum type or a container, change the type stored in the sum type or the size of the container
[16:51:05] *** Quits: ecr1 (ereed@2557E599.66715431.D25A875A.IP) (Ping timeout)
[16:51:07] <strcat> bam, dangling/invalid pointer
[16:51:33] <kmc> ah right
[16:51:34] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[16:51:46] <strcat> rust can statically prevent that with all owned types
[16:51:47] <kmc> and lifetime analysis doesn't catch this because the object is still alive, it's just changed shape
[16:52:24] <strcat> kmc: the issue is only with shared mutable data though, because the compiler can't statically know all the places with access to it (by definition of not being owned)
[16:52:33] <bblum> kmc: let mut x = Some(~"hello"); let y: &~str = x.get_ref(); x = None; println(*y);
[16:52:40] <strcat> so rather than freezing things statically, it uses a write barrier to do it dynamically
[16:52:47] <kmc> *nod*
[16:52:53] <strcat> and it can fail dynamically, since the write barrier is dynamic
[16:53:00] <bblum> kmc: what you said is exactly the boundary between the lifetime analysis and the borrow-check
[16:53:02] <kmc> oh yes I remember reading about this, now
[16:53:02] <strcat> borrow &mut and then another &mut or & - it fails
[16:53:08] <strcat> borrow & and then &mut - it fails
[16:53:16] <strcat> borrow & and mutate it - it fails
[16:53:18] <strcat> etc
[16:53:31] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[16:53:35] <strcat> good reason to avoid @mut/RcMut except as an absolute last resort
[16:53:42] <strcat> and if you do use them, pass them by-value
[16:54:01] <bblum> i hate how the dynamic borrow thing has relegated @mut to a type that you should basically never use :(
[16:54:06] <strcat> ofc there are other things you can do wrong with @mut
[16:54:19] <strcat> @mut int as a key in a hashmap
[16:54:23] <strcat> modify it externally
[16:54:25] <strcat> invalid hashmap
[16:54:28] <kmc> eep
[16:54:38] <strcat> these problems aren't really specific to rust
[16:54:43] <strcat> it's just a general problem with shared mutable data
[16:54:48] <SimonSapin> Now my iter() method typechecks, but the iterator doesn‚Äôt http://pastebin.mozilla.org/2586159
[16:54:54] <strcat> it usually implies issues like invalidating containers and iterators
[16:54:55] <kmc> presumably hashmap could force its key type parameter to be immutable; is that something Rust can express?
[16:55:00] <strcat> kmc: yes
[16:55:05] <SimonSapin> bblum: ?
[16:55:06] <strcat> kmc: it could require K: Freeze 
[16:55:13] <strcat> Freeze means immutable or inherits mutability
[16:55:27] <kmc> ok
[16:55:28] <bblum> SimonSapin: &'self Parser<'self>
[16:55:37] <strcat> and inherited mutability implies if the owner (the map) doesn't mutate it or give an &mut to it, no one else can
[16:55:45] *** Quits: bytbox (s@moz-75D4B5A8.wireless.umd.edu) (Ping timeout)
[16:55:59] <SimonSapin> I have no idea what I‚Äôm doing
[16:56:09] <strcat> kmc: can't require Freeze right now because so much uses @mut though
[16:56:14] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[16:56:19] *** Joins: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt)
[16:56:21] <strcat> python essentially solves this specific issue by doing an equivalent thing
[16:56:28] <strcat> they only define __hash__ on immutable types
[16:56:40] <strcat> but there are plenty of other issues
[16:56:42] <bblum> SimonSapin: so, if you have a lifetime-parameterized datatype, e.g. Parser<'a>, if you just write its name without an explicit lifetime
[16:56:45] <bblum> ("Parser")
[16:56:52] <strcat> you can invalidate iterators in python/ruby/java
[16:57:01] <kmc> and they let you use objects without __hash__ as dict keys
[16:57:16] <bblum> SimonSapin: it means the compiler will try to infer the best lifetime that works, so that you don't have to write it explicitly as often
[16:57:22] <strcat> kmc: afaik they don't
[16:57:38] <strcat> it's why python has tuples and frozenset
[16:57:54] <strcat> tuples and lists in python are the same except that tuples are immutable and have __hash__
[16:58:04] <strcat> frozenset is an immutable set with __hash__
[16:58:05] <bblum> SimonSapin: i don't think there's any inherent limitation to this situation... it could feasibly be able to figure out that you meant Parser<'self>
[16:58:10] <kmc> you can do x[C()] = 0 where C is an empty class
[16:58:28] <kmc> in that case I think it keys by object identity, so it's not very useful, or at least not very advisable
[16:58:37] <strcat> kmc: an empty class has __hash__ though
[16:58:40] *** Quits: jviereck (Adium@moz-5295735C.adsl.alicedsl.de) (Quit: Leaving.)
[16:59:00] <kmc> oh, I understand what you mean now
[16:59:08] <SimonSapin> It seemed a pretty basic use case of iterators to me, but maybe I‚Äôm doing it wrong?
[16:59:33] <thiez> rusti: struct S<T>{ val: T } impl<T:Freeze> S<T>{ fn new(val:T)->S<T>{S{val:val}}} S::new(@mut 8);
[16:59:34] -rusti- <anon>:9:85: 9:91 error: instantiating a type parameter with an incompatible type `@mut int`, which does not fulfill `Freeze`
[16:59:34] -rusti- <anon>:9          struct S<T>{ val: T } impl<T:Freeze> S<T>{ fn new(val:T)->S<T>{S{val:val}}} S::new(@mut 8);
[16:59:34] -rusti-                                                                                               ^~~~~~
[16:59:34] -rusti- error: aborting due to previous error
[16:59:35] -rusti- application terminated with error code 101
[16:59:39] <thiez> very nice
[16:59:45] <thiez> didn't expect it to be this easy :)
[17:00:36] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:00:47] <kmc> what are "once functions"?
[17:01:04] <bblum> kmc: a closure that can only be called once
[17:01:09] <SimonSapin> http://pastebin.mozilla.org/2586190 ‚Ä¶
[17:01:10] <strcat> kmc: moving data into heap closures isn't really possible because it can only move into them once
[17:01:17] <strcat> so once functions are a way to make that easier to deal with
[17:01:24] <strcat> well, moving data into closures*
[17:01:27] <bblum> strcat: problem is moving out from the closure, not in
[17:01:27] <strcat> in general
[17:01:41] <strcat> bblum: well maybe I'm thinking about it differently but...
[17:01:57] <ecr2> both directions are a problem
[17:01:59] <strcat> if you moved ~T into a closure, where do you get the ~T on the second run? the first one can be consumed
[17:02:01] <sp3d> strcat: couldn't that be fixed by removing all side-effects and using continuations or such?
[17:02:04] <sp3d> :P
[17:02:13] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[17:02:21] <bblum> strcat: you simply can't destruct the ~T inside the closure's execution; you can only reference it
[17:02:24] *** Quits: ecr2 (ereed@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:02:30] <strcat> bblum: ah
[17:02:32] <bblum> strcat: it gets destructed when the closure gets destructed
[17:02:38] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:02:39] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[17:02:46] <Eridius> we don't have once functions yet, do we?
[17:02:51] <strcat> bblum: I think I'll actually comprehend those errors now
[17:02:57] <bblum> strcat: good :P
[17:03:04] *** Joins: tjc (tjc@2557E599.66715431.D25A875A.IP)
[17:03:04] *** ChanServ sets mode: +o tjc
[17:03:48] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[17:04:15] <brson> graydon: I started yet another dist-snap. eta 3.5 hours. the last one timed out after 11 hours though so I'm not hopeful
[17:04:37] <strcat> brson: there are no mac builders atm
[17:04:38] <strcat> if you need one
[17:05:08] <strcat> they all got stuck :(
[17:05:36] <strcat> maybe related to me getting you to clean them to fix that other problem, I dunno.
[17:05:47] <strcat> they worked for a while after that though
[17:06:33] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[17:06:48] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[17:06:59] *** Joins: eschweic1 (Adium@2557E599.66715431.D25A875A.IP)
[17:07:02] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[17:07:06] <brson> we don't need a mac bot to do the dist-snap, but I'll log into them and start nuking things
[17:07:09] <bblum> toddaaro: http://pastebin.mozilla.org/2586218
[17:07:16] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[17:07:20] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[17:07:31] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Quit: Ex-Chat)
[17:07:43] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[17:08:03] *** Joins: brson_ (brson@2557E599.66715431.D25A875A.IP)
[17:08:23] *** Joins: ecr1 (ereed@2557E599.66715431.D25A875A.IP)
[17:08:24] <strcat> brson: they might need a reboot, or at least a restart of whatever slave process runs on them for buildbot
[17:08:26] <strcat> it thinks they are stuck
[17:08:37] <doomlord> yikes, i find  OOP actually makes sense with traits
[17:08:43] * strcat wouldn't be surprised if they weren't stuck and they just never sent a message saying they stopped
[17:08:47] *** Quits: brson (brson@C261DB39.6E5482D7.8DDCAE07.IP) (Ping timeout)
[17:09:03] *** brson_ is now known as brson
[17:09:15] <strcat> doomlord: not really OOP ;p, trait impls are associated with the trait
[17:09:23] <strcat> not the object
[17:09:43] *** Quits: ecr (ereed@2557E599.66715431.D25A875A.IP) (Ping timeout)
[17:10:02] *** Joins: novabyte (Instantbir@19FD28C4.EDC9F9F3.3EB8DDB5.IP)
[17:10:02] *** Quits: novabyte (Instantbir@19FD28C4.EDC9F9F3.3EB8DDB5.IP) (Input/output error)
[17:10:57] <strcat> bors has built/tested this PR 3 times now ;p
[17:11:30] *** Quits: bent (chatzilla@moz-C8597CF0.vc.shawcable.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[17:11:34] <graydon> shall I turn off bors?
[17:11:39] <strcat> graydon: no
[17:11:42] <strcat> graydon: it's buildbot's fault
[17:11:48] <graydon> oh?
[17:11:57] <graydon> I don't mean as _punishment_ :)
[17:11:59] <strcat> graydon: I opened https://github.com/mozilla/rust/issues/7515 about it
[17:12:02] <mark_edward> i have a question
[17:12:10] <mark_edward> how many of you guys are mozilla employees?
[17:12:10] <strcat> graydon: well bors isn't doing anything bad atm ;p
[17:12:17] <strcat> graydon: it's just timing out and restarting it I guess
[17:12:21] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[17:12:23] <cmr> mark_edward: just the people with @ I think
[17:12:51] *** Quits: mib_0ufh9s (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:12:55] <graydon> strcat: hum, what exactly is happening in that bug?
[17:12:56] <mark_edward> really! so Rust isn't just a Mozilla project then
[17:13:01] <cmr> mark_edward: no, not at all.
[17:13:04] <strcat> graydon: it seems like interrupts sent during the git phase make the builder lock
[17:13:22] <strcat> graydon: so the early interrupts on quick fails are losing builders
[17:13:29] <strcat> it only seems to happen on mac ones though...
[17:13:29] <graydon> oh dear
[17:13:33] <cmr> mark_edward: samsung is in on the fun as well, but the community is quite large
[17:13:43] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[17:13:44] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:14:02] <strcat> graydon: I think I caused it on a windows bot a few weeks ago though, but those build quickly so it didn't cause anything noticeable
[17:14:14] <strcat> I never checked to see if that actually finished
[17:14:57] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[17:15:02] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[17:15:41] <strcat> graydon: there was another issue with the mac bots and I got brson to clean the workspaces so.... that might have primed them to fail during the git phase by making it take longer than usual
[17:16:20] <cmr> rusti: struct Foo { a: ~Foo }
[17:16:21] -rusti- <anon>:9:9: 9:31 error: this type cannot be instantiated without an instance of itself; consider using `Option<main::Foo>`
[17:16:21] -rusti- <anon>:9          struct Foo { a: ~Foo }
[17:16:21] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~
[17:16:21] -rusti- error: aborting due to previous error
[17:16:21] -rusti- application terminated with error code 101
[17:16:43] <strcat> rusti: struct Bar { a: ~Foo } struct Foo { b: ~Bar }
[17:16:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RbeK
[17:16:48] <Eridius> that's a mildly confusing error message
[17:17:11] <strcat> an error that works!
[17:17:30] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Client exited)
[17:17:40] <Eridius> it's also suggesting using Option<Foo>. Don't you need Option<~Foo>?
[17:17:48] <strcat> Eridius: yes
[17:18:18] <graydon> strcat: ok. I read the stdio logs and the mac just keeps retrying to fetch and checkout
[17:18:28] <cmr> Ok.. so how does the AST work? I see... enum ty_ { ... ty_box(mt) ... } -> struct mt { ty: @Ty ... } -> struct Ty { node: ty_ ... } -> enum ty_ ......
[17:18:29] <graydon> strcat: each time reclobbering
[17:18:35] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[17:18:38] <graydon> strcat: but the revision has disappeared in the meantime
[17:18:44] <Eridius> I'm kind of surprised you can't construct the type Foo { a: ~Foo }, since the size of Foo depends on the size of a pointer, not the size of Foo. You'd never be able to construct a value of course...
[17:18:58] <graydon> strcat: maybe I should change it to not clobber on failure on mac builders
[17:19:03] <graydon> er, auto builders
[17:19:07] <cmr> Eridius: you can't make an uninitialized struct, so it's impossible to construct
[17:19:14] <bblum> come ON, patch, you could have applied that hunk
[17:19:48] <strcat> bblum: use 'git diff --no-index' and 'git apply --no-index'
[17:19:53] <strcat> never need diff and patch again ;p
[17:20:15] <bblum> strcat: oh really? is it smarter?
[17:20:18] <strcat> bblum: yeah
[17:20:20] <Eridius> cmr: yeah you can't actually use the type, I'm just surprised you can't even declare the type
[17:20:23] <bblum> strcat: hmm
[17:20:37] <strcat> bblum: patch often has really terrible bugs, Arch uses the most recent version and we often find them first
[17:20:40] <strcat> breaks everything \o/
[17:20:41] <SimonSapin> I gave up on iterators for now
[17:21:00] <Eridius> why?
[17:21:12] <SimonSapin> I couldn‚Äôt get the lifetimes right
[17:21:15] <mnemotic> strcat: you're an Arch user too?
[17:21:29] <cmr> There is some important detail I am missing, but it seems like the AST should be impossible to construct.
[17:21:34] <strcat> mnemotic: yes
[17:21:41] <SimonSapin> and even when making the Parser itself the iterator there was another error, and I spent enough time on this already
[17:21:46] <strcat> mnemotic: maybe you even use some of my packages in [community] ;p
[17:21:57] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[17:21:57] *** ChanServ sets mode: +o pcwalton
[17:21:59] <bblum> strcat: i dunno, git apply --no-index is telling me patch does not apply
[17:22:17] <mnemotic> strcat: maybe I do :)
[17:22:20] *** Joins: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com)
[17:22:26] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:22:29] *** Joins: elly (elly@18D20C19.2A2E1A6B.EA806F19.IP)
[17:22:36] <strcat> bblum: aw :(
[17:22:39] <elly> you guys mailed me a really cute shirt :) thanks!
[17:22:43] <bblum> strcat: what do i do
[17:22:45] <bblum> elly: isn't it great
[17:22:55] *** Joins: mib_wjt0nq (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:22:55] *** Quits: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com) (Connection reset by peer)
[17:22:57] <cmr> Does anyone have a picture of the shirts yet?
[17:22:57] <Eridius> you have a shirt?
[17:22:57] <elly> it is
[17:23:20] <bblum> strcat: i wanna make this work
[17:23:30] <bblum> 'patch' at least took most of the hunks
[17:23:50] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[17:24:00] <strcat> bblum: any idea what's wrong with it?
[17:24:02] <elly> I can't take a photo of it that doesn't make me look hugely dorky
[17:24:10] <Eridius> dorky is bad?
[17:24:18] <cmr> elly: well you don't have to wear it in the picture :p
[17:24:19] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[17:24:29] <bblum> strcat: no clue
[17:24:30] <tjc> cmr: lindsey posted a picture of the shirt on Twitter
[17:24:43] <bblum> strcat: oh, it doesn't have as much fuzz
[17:24:53] <tjc> cmr: https://twitter.com/lindsey/status/351759158619537410
[17:24:57] <bblum> strcat: so it's searching for some context text that has Freeze but only found Owned
[17:25:09] <strcat> bblum: --unidiff-zero ?
[17:25:13] * kimundi wonders if/when his shirt will arrive
[17:25:17] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[17:25:19] <cmr> whoa that's an awesome design
[17:25:23] <Eridius> wow that's an awesome shirt
[17:25:23] <strcat> I guess the context it has might be wrong
[17:25:43] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[17:25:44] <brson> rust-mac3 workspaces wiped and buildslave restarted
[17:25:52] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[17:25:53] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:26:04] <kimundi> woha, nice design
[17:26:21] <bblum> strcat: that's kind of gross
[17:26:26] <bblum> i wanna be able to configure the fuzz
[17:26:34] *** Joins: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com)
[17:26:39] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Textual IRC Client: http://www.textualapp.com/)
[17:27:20] <mnemotic> sweet shirt
[17:27:20] *** Quits: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com) (Connection reset by peer)
[17:27:32] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:27:38] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:27:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[17:27:47] <strcat1> bblum: well, patch lets you do that but I guess git-apply doesn't
[17:27:56] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[17:27:59] *** strcat1 is now known as strcat
[17:28:07] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:28:10] <bblum> strcat: :<
[17:28:11] <jdm> woah
[17:28:11] <cmr> jclements: ping
[17:28:13] <jdm> hsirt is hot
[17:28:15] <jdm> *shirt
[17:28:35] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[17:29:16] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Ping timeout)
[17:29:17] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[17:29:18] <mnemotic> q: does it make sense to flag an entire impl as not-stage0 if at least on of its functions must be?
[17:29:48] <mnemotic> instinctively, i think yes
[17:29:57] <strcat> brson: still stuck :(
[17:30:11] <bstrie> the shirt design looks so good, I'm anxiously awaiting a confirmation email
[17:30:13] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[17:30:34] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[17:30:35] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:30:42] <bblum> mnemotic: i feel like you should be able to do it per-function
[17:31:04] <jclements> cmr: pong
[17:31:15] <Eridius> how did people get this shirt?
[17:31:18] <strcat> mnemotic: it doesn't matter if stuff is missing in stage0 and nothing needs it
[17:31:22] <strcat> so just do the laziest thing
[17:31:44] <strcat> I had #[cfg(not(stage0))] on entire modules like treemap before to avoid needing a dozen
[17:32:12] <cmr> jclements: I'm building up a kinda-AST for rustdoc2, basically taking what I need from the real ast, and I'm wondering how the AST works at all. I see a cyclic dependency like: enum ty_ { ... ty_box(mt) ... } -> struct mt { ty: @Ty ... } -> struct Ty { node: ty_ ... } -> enum ty_ -> ......
[17:32:30] <mnemotic> strcat: lazy it is, then\
[17:32:30] *** Quits: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:32:44] <brson> strcat: ok i'll try harder
[17:32:48] <jclements> cmr: hang on a second...
[17:33:10] <jclements> cmr: let me make sure I understand what you're saying.
[17:33:17] <bblum> i don't get why this hunk fails even with fuzz 3 :(
[17:33:31] <jclements> cmr: are you surprised by the fact that the ty_ enum is self-referential?
[17:33:42] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:34:04] <cmr> jclements: yeah. I figured you'd need an Option somewhere in there for that to be possible
[17:34:07] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Connection reset by peer)
[17:34:25] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[17:34:45] <jclements> cmr: as long as there are options that are not self-referential, you're fine.  The canonical case (stop me if you've heard this one before) is that of a linked list. Let me give you some code:
[17:34:58] <bblum> oh i see
[17:35:08] *** Joins: cp (cp@moz-993078EE.plus.com)
[17:35:12] <bblum> strcat: do you know if there's a way to make "git show" split the patch into smaller hunks than default?
[17:35:23] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:35:25] <bblum> I have some "intermediate context" and i'd like there to be a hunk boundary there
[17:35:29] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:35:35] <strcat> bblum: if you're getting it from git you could probably be using 'git cherry-pick COMMIT_ID' instead
[17:35:44] <bblum> strcat: two different git repos
[17:35:48] <strcat> bblum: ah
[17:35:52] <sully> hm
[17:36:18] <sully> graydon: if I was interested in trying to help reduce buildbot cycle times, is there anything for me to do?
[17:36:24] <Eridius> bblum: you can shrink the number of unified lines of context with -U<n>
[17:37:00] <Eridius> there's also some other diff algorithms you can ask it to try
[17:37:08] <Eridius> basically, check the `git diff` manpage. Those options should work with `git show`
[17:37:14] <strcat> bblum: well if you use git diff you can use -U
[17:37:36] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:37:43] <jclements> cmr: https://gist.github.com/jbclements/5911358
[17:37:50] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:38:02] <jclements> cmr: let me know if this doesn't make sense. Apologies if I've misunderstood your question!
[17:38:31] <bblum> strcat: Eridius: that did the trick; thanks
[17:38:32] <cmr> jclements: that makes sense
[17:38:47] <bblum> strcat: Eridius: in the same amount of time i could have fixed the reject hunks by hand, but now i feel more leet
[17:38:52] <Eridius> hehe
[17:39:09] <cmr> jclements: thanks!
[17:39:13] <bblum> i wish patch fuzz ignored "intermediate" context :(
[17:39:54] <Eridius> eh, far too easy to create distinct patches with the same patch-id that way
[17:40:14] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:40:23] <bblum> patch id?
[17:40:38] <Eridius> `git patch-id`. generates an identifier for a diff
[17:40:48] <Eridius> it's used by `git cherry`, etc. to decide if a patch has been merged in
[17:40:56] <Eridius> even if the particular sha1 of that commit isn't prsent
[17:41:20] <bblum> i don't follow why intermediate context changes things
[17:42:09] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:43:05] <graydon> sully: metabug https://github.com/mozilla/rust/issues/6819 is collecting stuff. I would suggest having a look at #7462 and #7349 if dotdash is not looking at them.
[17:43:23] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:43:23] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148894f6e to 14a2db7c1: 02http://git.io/N3iJvQ
[17:43:23] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:43:25] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[17:43:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/cE1rfA
[17:43:25] <ghrust> 13rust/06auto 14056a42b 15Tim Chevalier: rustpkg: Make rustpkg commands work without a package ID...
[17:43:25] <ghrust> 13rust/06auto 146eec615 15bors: auto merge of #7419 : catamorphism/rust/default-package, r=catamorphism...
[17:43:25] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[17:43:40] <bblum> brson: why does your branch have this AtomicUint imitation in unstable/sync.rs when there's already a perfectly good one in unstable/atomics.rs
[17:44:10] <brson> bblum: it was written before the ones in unstable/atomics
[17:44:13] <bblum> i see
[17:44:14] <sully> graydon: ok
[17:44:44] <brson> graydon: I can't figure out how to make buildbot remove these builds: http://buildbot.rust-lang.org/buildslaves/mac3
[17:44:56] <brson> graydon: I've shutdown the slave and deleted directories, clicked lots of buttons
[17:45:15] <graydon> brson: define "remote"
[17:45:17] <graydon> remove
[17:45:20] <graydon> you want them to stop?
[17:45:49] <brson> graydon: yes
[17:46:18] <graydon> brson: shall I restart buildbot?
[17:46:45] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:46:47] <sully> graydon: are we considering anything on the buildbot side to speed things up there?
[17:47:03] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[17:47:17] <graydon> sully: I am not, no. I don't think it's buildbot's problem.
[17:47:44] <brson> graydon: yeah, I guess. It will force us to restart the dist-snap again though :(
[17:47:50] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[17:47:50] *** ChanServ sets mode: +o dherman
[17:48:08] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[17:48:14] <graydon> brson: you're ssh'ed into mac3? shall I?
[17:48:31] *** Quits: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net) (Quit: Computer has gone to sleep.)
[17:48:33] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:48:43] <brson> graydon: I've already restarted the slave several times and it didn't help
[17:48:44] <sully> what is being done that is taking ~3 hours, though? make check runs quite a bit faster than that on my machine
[17:48:49] <graydon> oh weird. so .. nothing at all is running on the slave, eh?
[17:48:49] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Ping timeout)
[17:48:51] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[17:48:51] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:48:57] <brson> graydon: that's right, both macs are offline
[17:48:58] <cmr> sully: valgrind, nopt builds
[17:49:00] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[17:49:02] <cmr> sully: cross compile
[17:49:10] <graydon> sully: try building a cross config, a non-opt and/or valgrinding
[17:49:13] <graydon> those 3 are the long cycles
[17:49:17] <graydon> the others are much faster
[17:50:08] <graydon> brson: I'll try reconfig'ing the buildbot. maybe it'll notice the macs disconnected.
[17:50:22] <graydon> (might not damage the running snap)
[17:50:53] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:51:29] * sully nod
[17:51:34] <bblum> think i'm gonna need arc::try_unwrap for this too
[17:51:37] <sully> are those three run on different machines?
[17:52:16] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[17:52:46] <pcwalton> have I mentioned #[deriving(Clone)] is awesome?
[17:52:50] <pcwalton> #[deriving(Clone)] is awesome.
[17:52:58] <bblum> deriving is pretty great
[17:53:11] <pcwalton> the implementation is beautiful too
[17:53:18] * bblum looks
[17:53:45] <pcwalton> all the derivings are abstracted out
[17:53:56] <strcat> pcwalton: I think dbaupp did most of that
[17:53:56] <graydon> do we actually have deriving(Rand) like the release notes say?
[17:54:03] <Eridius> I tried looking at how deriving(Eq) works one time. It was kind of confusing. I didn't actually see any equality comparisons
[17:54:03] <pcwalton> I think so yeah
[17:54:06] <graydon> if so, that is .. um .. I want to ask whoever did that how it works
[17:54:10] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[17:54:13] <graydon> since it's a Research Problem to do correctly
[17:54:18] <pcwalton> Eridius: it's all abstracted out
[17:54:29] <pcwalton> so one piece of code works with multiple derivable traits
[17:54:32] <pcwalton> making it easy to add more
[17:54:34] <strcat> pcwalton: auto-deref screws it up a bit
[17:54:42] <strcat> it doesn't work exactly as expected atm
[17:54:46] <pcwalton> graydon: I think it just recursively calls Rand::rand() or whatever it is
[17:54:49] <strcat> like deriving(Clone) on a struct containing &
[17:54:59] <pcwalton> and it's up to the type to construct a reasonable value for rand()
[17:55:05] <graydon> pcwalton: what does it do on [] and enums?
[17:55:05] <pcwalton> deriving doesn't really have any logic in it
[17:55:17] <strcat> #[deriving(Clone)] struct Foo<'self> { x: &'self int }
[17:55:19] <Eridius> pcwalton: right, but ext/deriving/cmp/eq.rs doesn't actually contain any equality comparisons, which is what confused me
[17:55:21] *** Joins: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net)
[17:55:25] <strcat> rusti: #[deriving(Clone)] struct Foo<'self> { x: &'self int }
[17:55:27] -rusti- ()
[17:55:29] <pcwalton> Eridius: I think it just calls the .eq() method
[17:55:30] <graydon> brson: huh. no dice, still there.
[17:55:32] <pcwalton> not ==
[17:55:43] <graydon> brson: next try, restarting buildbot? that will likely lose some stuff
[17:55:49] <strcat> rusti: #[deriving(Clone)] struct Foo<'self> { x: &'self int } let i = 5; let f = Foo { x: &i };
[17:55:50] -rusti- <anon>:9:79: 9:80 warning: unused variable: `f` [-W unused-variable (default)]
[17:55:50] -rusti- <anon>:9          #[deriving(Clone)] struct Foo<'self> { x: &'self int } let i = 5; let f = Foo { x: &i };
[17:55:50] -rusti-                                                                                         ^
[17:55:50] -rusti- ()
[17:55:50] <pcwalton> graydon: for [] it's up to libstd to provide an implementation; for enums it probably randomly picks an enum variant and calls rand() on each variant
[17:56:01] <strcat> rusti: #[deriving(Clone)] struct Foo<'self> { x: &'self int } let i = 5; let f = Foo { x: &i }; fmt!("%?", f.clone())
[17:56:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WILF
[17:56:16] <strcat> yeah it can't deal with borrowed pointers because of auto-deref
[17:56:16] <Eridius> pcwalton: the only "eq" in there is the declaration of the TraitDef. I don't see where it's called recursively on the fields, unless part of the abstract machinery just knows to recursively call the same method
[17:56:24] <pcwalton> ah
[17:56:25] <doomlord> ctags ... what to do to enable this
[17:56:26] <graydon> pcwalton: I guess. that .. is potentially dangerous, but whatever. it might not be so bad.
[17:56:45] <pcwalton> Eridius: probably it's the latter, the abstract machinery knows to call the same method
[17:56:54] <doomlord> oh i think i have it working
[17:57:00] <graydon> (there's a system of equations you're supposed to solve to find the weighting per enum-variant if you want to randomly sample uniformly, is all)
[17:57:23] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[17:57:26] <Eridius> pcwalton: I was initally looking because I wanted to make deriving(Eq) work on unit structs, but it wasn't obvious what was going on (probably because I've never looked at libsyntax before)
[17:57:30] <bstrie> graydon: oh good, now you can call the people working on the deriving(Rand) research and tell them to work on something else :)
[17:57:44] <pcwalton> Eridius: ah
[17:57:55] <pcwalton> the build:: stuff is bad and should be rewritten
[17:58:01] <graydon> bstrie: it was flajolet, and he's dead.
[17:58:16] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:58:17] <graydon> bstrie: though one of his grad students took over
[17:58:24] <doomlord> oh , no.  its just picking up struct.. from c
[17:58:33] <Sergio965> Woo for C!
[17:59:00] <brson> brson: yeah, restarting is fine
[17:59:45] *** Joins: ahsanulhaque (Adium@moz-9BF875A5.banglalionwimax.com)
[17:59:52] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[18:00:00] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[18:01:07] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[18:01:52] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[18:03:04] *** Quits: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP) (Ping timeout)
[18:03:17] *** Quits: fabiand (fabiand@moz-DA383042.adsl.alicedsl.de) (Quit: Verlassend)
[18:05:38] <brson> toddaaro: on the io branch I'm seeing test_stress_homed_tasks iloop on mac. can you investigate?
[18:05:52] <brson> toddaaro: this is before merging your latest changes, which I'm going to look at today
[18:06:04] <brson> toddaaro: i don't see the problem on linux strangely
[18:06:12] <brson> though I'm still trying to reproduce it
[18:06:47] <toddaaro> really, that sounds odd
[18:06:50] *** Joins: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP)
[18:07:01] <toddaaro> I'm not sure how to go about debugging, no clue how to make anything do anything on a mac
[18:07:54] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[18:08:15] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:08:19] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[18:08:49] <bblum> brson: is it deterministic?
[18:09:41] <bblum> I,I noah's ARC
[18:09:45] <bblum> (credit aaron)
[18:10:15] <brson> bblum: no, I have to run the test repeatedly
[18:10:38] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[18:10:43] <bblum> architecture-dependent races are the best kind of races
[18:11:00] <strcat> ooooo, cgroups are getting better
[18:11:08] <bblum> delicious cgroups
[18:11:15] <bblum> strcat: in what way?
[18:11:19] <strcat> http://thread.gmane.org/gmane.comp.sysutils.systemd.devel/11381
[18:11:20] <brson> toddaaro: there are some sparse notes on building rust for os x here: https://github.com/mozilla/rust/wiki/Note-getting-started-developing-Rust
[18:11:35] <toddaaro> brson: ok, I'll take a look
[18:11:38] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:12:38] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:12:40] <strcat> heh
[18:12:47] <strcat> I think this means the end of cgroups outside of systemd though
[18:12:59] *** Joins: int3_ (int3_@moz-62FF5C5C.subnet-207.amherst.edu)
[18:13:00] <strcat> without a patched kernel
[18:13:07] <brson> toddaaro: it does repro on linux
[18:13:10] <strcat> yeah it does
[18:13:12] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:13:20] <brson> toddaaro: this is what i'm doing: for i in {0..100000}; do x86_64-unknown-linux-gnu/stage1/test/stdtest-x86_64-unknown-linux-gnu homed || break; done
[18:13:24] *** Joins: int3__ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:13:47] <toddaaro> brson: ohhhh, I realized what went wrong, my virtualbox vm is still single core due to a usb bug!
[18:14:08] <toddaaro> brson: so I forgot my tests weren't actually testing any parallel cases
[18:14:10] <toddaaro> that is kinda bad
[18:14:15] <bblum> you dumbass
[18:14:34] <ecr1> bblum: +1
[18:14:37] <toddaaro> it didn't cross my mind that a single core environment still existed
[18:14:45] *** Quits: int3_ (int3_@moz-62FF5C5C.subnet-207.amherst.edu) (Ping timeout)
[18:15:28] <brson> I am having a much harder time reproing in linux, but I swear I did once
[18:15:40] <strcat> although this means I have to rewrite half of playpen so...
[18:15:43] <strcat> -5 points due to laziness
[18:16:01] <toddaaro> ok, I'll fling stuff at it
[18:16:09] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:16:12] <brson> toddaaro: oh, RUST_RT_STRESS=anything makes it happen much more reliably
[18:16:34] <toddaaro> yea, that should be scaling number run really aggressively
[18:16:54] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[18:17:12] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:17:18] *** Joins: eschweic1 (Adium@2557E599.66715431.D25A875A.IP)
[18:17:19] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:18:06] *** Joins: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net)
[18:19:09] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[18:19:15] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[18:19:15] <ghrust> 01[13rust01] 15brson pushed 2 new commits to 06try: 02http://git.io/ieQFaA
[18:19:15] <ghrust> 13rust/06try 140e07c8d 15Brian Anderson: rt: Add global_args_lock functions to rustrt.def.in
[18:19:15] <ghrust> 13rust/06try 146fd15ff 15Brian Anderson: std::rt: Ignore homed task tests
[18:19:15] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[18:19:19] <Eridius> going back to an earlier conversation, is it possible to get one of those awesome rust shirts?
[18:19:37] <nmatsakis> so what happened with the bots this morning?
[18:19:42] <nmatsakis> graydon: ^?
[18:20:01] <strcat> nmatsakis: https://github.com/mozilla/rust/issues/7515
[18:20:06] <tjc> Eridius: currently we are giving the shirts to people who have made "substantial" contributions to Rust; if we print more shirts, that could change :-)
[18:20:09] <strcat> nmatsakis: interrupt during the git phase makes them get stuck
[18:20:19] <strcat> and they get interrupted when another buildslave fails
[18:20:22] <bstrie> Eridius: the shirts were ordered a while ago, for consistent contributors
[18:20:33] <bstrie> Eridius: so if you want in on the next round of shirts, you need to submit more patches :)
[18:20:34] <tjc> in the meantime, contribute and maybe you'll get a shirt sometime :-)
[18:20:49] <Eridius> hah. I'm trying!
[18:20:55] <tjc> :-)
[18:21:12] <graydon> strcat: I think it's not _quite_ interrupt=>stuck so much as interrupt => retry, but bors gives up and removes the rev. or something.
[18:21:17] <Eridius> at least I have my Go shirt and Go Gopher to keep me company
[18:21:21] <graydon> strcat: I removed clobber-on-fail from the git step
[18:21:21] <brendanc> I suppose it would be possible to make the interrupter wait until a git step finishes
[18:21:31] <brendanc> complicates it a bit though
[18:21:37] <nmatsakis> strcat: ok, so I am wondering whether to @bors: retry this PR https://github.com/mozilla/rust/pull/7187
[18:21:43] <nmatsakis> strcat: I don't see any actual failure there?
[18:21:48] <strcat> nmatsakis: yeah no actual failure
[18:21:55] *** Quits: mib_wjt0nq (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:22:02] <bstrie> Eridius: you should start a museum of programmng language memorabilia
[18:22:04] <strcat> nmatsakis: it passed everything but 2 bots were gone
[18:22:07] * nmatsakis wants to land *something*
[18:22:32] <Eridius> bstrie: ooh I could my "Programming for the Newton" book in there!
[18:22:35] <bstrie> close the tree, have all the devs land the important 0.7 patches, then run the tests once and release
[18:23:45] *** Parts: ahsanulhaque (Adium@moz-9BF875A5.banglalionwimax.com) ()
[18:24:04] *** Joins: bytbox (s@moz-75D4B5A8.wireless.umd.edu)
[18:24:14] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[18:24:52] *** Quits: eholk (eholk@moz-F6BEA424.uconnect.utah.edu) (Quit: eholk)
[18:25:25] <brendanc> seems like a bug in the git step really
[18:26:21] <pcwalton> cmr: interested in running compiler perf tests on https://github.com/mozilla/rust/pull/7543 ?
[18:26:25] <pcwalton> this may be a decent win
[18:26:27] <pcwalton> not sure
[18:26:42] <cmr> pcwalton: sure
[18:27:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:27:54] *** Quits: bytbox (s@moz-75D4B5A8.wireless.umd.edu) (Ping timeout)
[18:28:04] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:28:19] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:28:25] *** Quits: duckinator (nick@moz-74B346B5.mostlyincorrect.info) (Ping timeout)
[18:29:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:30:05] <strcat> pcwalton: I started on the work to rm headers from exchange allocs btw
[18:30:11] <pcwalton> strcat: awesome!
[18:30:13] <strcat> pcwalton: they are never initialized, read from, written to or copied now
[18:30:24] <strcat> pcwalton: I had to give ~fn an allocator to itself
[18:30:26] <pcwalton> that could be a nice perf improvement right there
[18:30:28] <strcat> because it uses tydesc
[18:30:30] <pcwalton> that's fine
[18:31:02] <cmr> (not initializing the headers is a miniscule perf win, if that's what you're refering to.)
[18:31:04] <strcat> pcwalton: https://github.com/mozilla/rust/blob/master/src/libstd/rt/global_heap.rs#L79 the new one
[18:31:15] <pcwalton> cmr: ah, ok
[18:31:23] <strcat> no more tydesc at all, changed the signature too
[18:31:23] <cmr> (was like 700ms shaved off the librustc build)
[18:31:28] <pcwalton> oh, it landed?
[18:31:32] <strcat> pcwalton: yep
[18:31:33] <pcwalton> hey, I'll take 700ms.
[18:31:57] <strcat> pcwalton: so I had to split out ~fn to a closure_exchange_malloc and also add contains_managed as an intrinsic to stop vectors reading ref_count
[18:31:59] <strcat> but it works :)
[18:32:31] <strcat> removing the headers is probably going to be hard though. there's a box_body thing in trans but I'm sure a lot of other stuff assumes there are headers
[18:32:39] <strcat> like vectors.
[18:32:46] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[18:32:51] <strcat> vectors could have their own vector_exchange_malloc for a while
[18:33:32] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[18:34:34] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[18:36:04] <bblum> oh, Self is only a type name in traits, not impls?
[18:36:06] <bblum> that's kind of annoying
[18:37:21] <graydon> brson: shall I kill the builds running on master presently? they don't seem to be terribly important.
[18:38:28] <brson> graydon: sure
[18:38:45] <bblum> error: failed to find an implementation of trait sys::FailWithCause for [type error]
[18:38:48] <bblum> c.c
[18:39:07] <cmr> I love those errors
[18:39:29] <brson> probably passed an unusual type to fail!. fwiw I really want to change the internal failure API. FailWithCause is an odd way to factor this
[18:39:45] <graydon> brson: should I just .. disable buildbot's master builds altogether? does it do anything more than just delay auto at this point?
[18:39:55] *** Quits: eagen (eagen@8737942B.7A99C13A.B7961A98.IP) (Quit: Leaving)
[18:40:02] <brson> graydon: yeah, I think turning off master is worth trying
[18:40:10] <graydon> it builds bsd ...
[18:40:16] <brson> oh :-/
[18:40:20] <brson> screw bsd!
[18:40:35] <cmr> move the bsd builder over to auto :p
[18:40:40] <graydon> hey now. bsd is a fine platform.
[18:41:05] <graydon> (and .. if we had it running on fast hardware, actually a very good proxy for "works on mac" coverage, but one we can virtualize)
[18:41:10] *** Quits: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt) (Ping timeout)
[18:41:17] <cmr> graydon: Oh that reminds me
[18:41:21] <graydon> did I see win64 land recently?
[18:41:25] <cmr> graydon: Couldn't we stand up a generic Darwin VM?
[18:41:34] <brson> graydon: I don't think so, but thad has been working on it
[18:41:40] <cmr> not exactly OS X, but very close to it.
[18:41:56] <chandler> there hasn't really been a runnable "darwin" for a while
[18:42:46] <graydon> I didn't think so. unless it's' something newly revived.
[18:42:46] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[18:43:01] <chandler> nope. dead as a doornail
[18:43:20] <cmr> darn, that's a shame
[18:44:01] <brendanc> mac virtualizes just fine. too bad it's against the rules.
[18:45:00] <chandler> yeah. one can find some interesting things by searching for "vmware unlocker", but I can't endorse anything you might find by doing so
[18:45:10] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Quit: Leaving.)
[18:45:13] <Luqman> graydon: no, some issues with building llvm on mingw64 :(
[18:45:14] *** Joins: RMF (RMF@6152834E.A3AF135E.823A4631.IP)
[18:45:18] *** Joins: cp (cp@moz-993078EE.plus.com)
[18:45:21] <graydon> chandler: puredarwin.org perhaps?
[18:45:30] <graydon> Luqman: huh. sad to hear :(
[18:45:37] <brendanc> third party buildslaves might buy plausible deniability too :)
[18:45:55] <chandler> graydon: the last release of puredarwin corresponds to 10.4 or 10.5
[18:46:13] <graydon> we'll have new macs soon
[18:46:35] <toddaaro> brson: huh, how do I make failing an assert fail a test?
[18:46:50] <toddaaro> brson: it seems the test is actually failing, it just isn't failing
[18:47:14] <cmr> toddaaro: does it have a #[should_fail] attached to it? I've lost some dozen+ minutes because of that
[18:47:14] <graydon> given that .. it seems like bsd is cycling in about 30 minutes most of the time
[18:47:21] <graydon> I think I'll just move it into auto
[18:47:25] <graydon> and shut down master
[18:47:25] <graydon> fair?
[18:47:30] <cmr> sounds good to me
[18:47:47] <toddaaro> cmr: the test should pass, so a fail in this assert should be a fail for the test
[18:47:49] <cmr> I don't see master as much of a benefit, it's a subset of the auto builds (besides bsd, previously)
[18:47:56] <kmc> what does the unsafe_no_drop_flag attribute do
[18:48:09] <strcat> kmc: omits the drop flag, calls the destructor multiple times
[18:48:30] <kmc> drop flag is used to prevent double destruction?
[18:48:33] <strcat> yes
[18:48:36] <kmc> ok
[18:48:49] <kmc> so if you have an idempotent destructor you can apply this attribute and save some memory
[18:49:02] <kmc> but from the name, I'm guessing that "typical" code isn't supposed to use it
[18:49:12] <graydon> does bsd 32bit work? shall we include that?
[18:49:15] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:49:33] <strcat> kmc: for example, a pointer type with a destructor
[18:49:43] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:49:43] *** ChanServ sets mode: +o brson
[18:49:48] <strcat> if it's a non-nullable pointer type, it can use null to represent 'destroyed'
[18:49:52] <strcat> so it doesn't need a drop flag
[18:49:59] <strcat> #[unsafe_no_drop_flag] just zeroes all the fields
[18:50:06] <strcat> and the destructor can check self.ptr.is_null()
[18:50:08] <sully> hm, how does scoping on static methods work now?
[18:50:15] <sully> I implemented them, but it seems to have changed
[18:50:32] <strcat> sully: any luck getting inline + default methods to work btw?
[18:50:52] <sully> oh, argh, I haven't even looked at that
[18:50:54] <sully> did you open a bug?
[18:50:57] <strcat> sully: yeah
[18:50:58] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[18:51:15] <strcat> sully: https://github.com/mozilla/rust/issues/7481
[18:51:26] <strcat> it's the only thing I've really run into stopping widespread use in the stdlib
[18:51:34] <strcat> since we can't really use it on Eq, Ord, etc. yet
[18:51:45] <strcat> well unless everything overrides the default... hm
[18:52:00] <sully> ok, I will look at that today
[18:52:10] <toddaaro> brson: ok, it turns out my "mystery failed assert" was a missing '!' in a testing helper inside task, so it was a test-bug not code bug, but I'm still perplexed by why that didn't result in a failed test case
[18:52:44] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().size_hint()
[18:52:44] -rusti- (Some(3), Some(3))
[18:53:02] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().chain_(xs.iter()).size_hint()
[18:53:03] -rusti- (Some(6), Some(6))
[18:53:26] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().transform(|x| x).size_hint()
[18:53:27] -rusti- (Some(3), Some(3))
[18:53:29] <strcat> hrm
[18:53:49] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().take_(2).size_hint()
[18:53:50] -rusti- <anon>:9:29: 10:5 error: internal compiler error: method not found in AST map?!
[18:53:50] -rusti- <anon>:9          let xs = [1, 2, 3]; xs.iter().take_(2).size_hint()
[18:53:50] -rusti- <anon>:10     };
[18:53:50] -rusti- application terminated with error code 101
[18:54:13] <strcat> sully: ok it's weird
[18:54:24] <strcat> sully: if they actually override the default method with an #[inline] one, it works fine
[18:54:36] <strcat> if they use the default method and have #[inline] on *another* method, it breaks
[18:54:51] <strcat> so #[inline] on the next implementation makes it look for an inlined size_hint
[18:54:59] * strcat shrugs
[18:55:20] <sully> that is really weird
[18:55:21] <strcat> the default size_hint isn't actually inlined
[18:55:36] <strcat> don't know if that works
[18:56:01] <strcat> rusti: trait Foo { #[inline] fn foo(&self) {} }
[18:56:02] -rusti- ()
[18:56:13] <strcat> rusti: trait Foo { #[inline] fn foo(&self) {} } impl Foo for int {} 5i.foo()
[18:56:14] -rusti- ()
[18:56:44] <strcat> rusti: trait Foo { fn bar(&self); fn foo(&self) {} } impl Foo for int { fn bar(&self) {} } 5i.foo()
[18:56:45] -rusti- ()
[18:56:51] <strcat> rusti: trait Foo { fn bar(&self); fn foo(&self) {} } impl Foo for int { #[inline] fn bar(&self) {} } 5i.foo()
[18:56:51] -rusti- ()
[18:56:57] <strcat> only happens cross-crate though...
[18:57:20] <brson> toddaaro: that is alarming. there have been some issues around failure in test tasks while we're getting linked failure working. can talk more about it later perhaps. in meeting now
[18:57:34] <toddaaro> brson: ok
[18:58:55] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[18:59:40] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[19:00:37] <graydon> ok, master builders are disabled and bsd is added to auto
[19:01:26] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[19:02:44] <bstrie> is it a bug that the compiler stops you from doing `1.foo()` if there are multiple applicable methods in scope, but it *doesn't* stop you from defining those methods in the first place?
[19:02:56] <cmr> bstrie: no
[19:03:06] <strcat> bstrie: the bug is that integer inference doesn't work
[19:03:13] <bstrie> well forget the int thing
[19:03:15] <strcat> but I don't think it should ever fall back to 'int'...
[19:03:17] <bstrie> this works for all generic types
[19:03:25] <bstrie> just using 1 as an example
[19:03:27] <strcat> rusti: 5.clone()
[19:03:28] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MNcQ
[19:03:29] <strcat> thought you meant this
[19:03:32] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:03:33] <graydon> they have unambiguous constructors
[19:03:41] <graydon> the problem is that 1 is an ambiguous constructor
[19:03:42] <bstrie> I can do `impl Foo for T { ... } impl Foo for T { ... }` and rust doesn't bat an eye
[19:03:47] <bstrie> that's what I'm asking about
[19:03:49] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[19:03:52] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[19:03:57] <strcat> and oh boy __extension__ is a bad name to give to impls ;p
[19:04:10] * strcat wishes it was ::Trait::
[19:04:12] <graydon> it predates impls being the only way
[19:04:21] <graydon> feel free to rename it, I don't think anyone minds
[19:04:35] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[19:04:35] <bstrie> strcat: this bug happens just the same as if I said `"asdf".foo()`
[19:04:53] <graydon> (indeed, I think "general cleanup of synthetic symbols" would be a lovely between-tests task)
[19:05:13] <bstrie> actually, hm
[19:05:18] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[19:05:19] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[19:05:26] <bstrie> the compiler *does* stop me from defining it when I don't give T a Copy bound
[19:05:28] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:05:33] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[19:05:35] <bstrie> but when I do T:Copy, it accepts it
[19:06:22] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[19:06:27] *** Joins: hatman (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[19:07:25] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[19:07:25] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 146eec615 to 14a2db7c1: 02http://git.io/N3iJvQ
[19:07:25] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[19:07:30] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[19:07:30] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/zLpn1g
[19:07:30] <ghrust> 13rust/06auto 149e6d5e1 15Niko Matsakis: Defer reasoning about region relationships until after regionck....
[19:07:30] <ghrust> 13rust/06auto 1442344af 15Niko Matsakis: Correct handling of if/match, and make explicit computation of...
[19:07:30] <ghrust> 13rust/06auto 1479ea266 15Niko Matsakis: move docs into doc.rs
[19:07:31] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[19:08:35] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[19:08:49] *** Joins: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca)
[19:08:52] <graydon> aw dang
[19:09:06] <bblum> i just realized what was going on with the CellNull talk at the meeting
[19:09:10] <bblum> i didn't really get it during the meeting
[19:09:22] <bblum> imo, having a distinct Cell and CellNull would be kind of bad
[19:09:24] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[19:09:28] <engla> strcat: your Unique<T> thing.. as experiment, does it really require T: Send? What are the real requirements for storing elements in manual malloc?
[19:09:35] <bblum> Cell<Option<T>> would be better
[19:09:37] <strcat> engla: it requires T: NonManaged
[19:09:39] <bblum> and you could have something like
[19:09:40] <strcat> but we don't have NonManaged
[19:09:42] <strcat> so I used Send
[19:09:49] <bblum> impl <T> Cell<Option<T>> { fn take() -> T }
[19:10:08] <strcat> engla: can't put managed pointers in memory that's not from vectors, the stack or unique/managed pointers
[19:10:12] <engla> aha. but NonManaged is only conceptual? I mean the current gc doesn't care
[19:10:36] <engla> I thought it was just reference counting at this point
[19:11:18] <strcat> engla: still not right to allow it
[19:11:22] <strcat> it won't break atm
[19:12:38] <engla> ok, cool. so that's the thing blocking implementing containers without using recursive types or ~[]
[19:12:50] <engla> you can scratch out blocking
[19:12:54] <graydon> brson: did you want me to (re)start a snap on the dist builders?
[19:13:16] <graydon> oh, one's already running
[19:14:29] <cmr> pcwalton: do you expect it to be a win in time, space, or both?
[19:14:48] <pcwalton> cmr: time
[19:14:57] <strcat> graydon: did you remove the master ones intentionally since auto covers it well?
[19:15:01] <pcwalton> cmr: but removing the headers entirely may be a large win in both
[19:15:06] <graydon> strcat: yes
[19:15:18] <graydon> strcat: auto is now a strict superset of what master was testing
[19:15:22] <strcat> yeah
[19:15:32] <pcwalton> oh boy, you can use emoticons in commit messages now
[19:15:45] <strcat> pcwalton: you could for a while ;p
[19:15:49] <strcat> some of our namespaces turn into them
[19:16:03] <strcat> like :link: from ::link::
[19:16:45] <bblum> aatch_: ping
[19:17:01] *** Joins: jpochyla (jpochyla@moz-DDB6BA4E.broadband9.iol.cz)
[19:17:09] *** Quits: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net) (Quit: You think I'm not online. But I'm always here. Even if I'm not typing. I'm here. Reading. Judging.)
[19:17:13] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:17:16] <engla> mixing code and emoticons usually has very :[ results
[19:17:29] *** Quits: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net) (Quit: Computer has gone to sleep.)
[19:17:34] <strcat> graydon: http://buildbot.rust-lang.org/console?branch=auto&refresh=15 weird, one isn't building
[19:17:39] <strcat> maybe things queued up from before
[19:18:01] <bstrie> pcwalton: it's not that you *can* use them, it's that github will interpret emoticons in your commit messages (and has for a while) even if you didn't intend to use them :)
[19:18:07] <graydon> both macs are at their limit
[19:18:11] <graydon> lemme see if any of it is stale
[19:18:18] <graydon> ah, a try build
[19:18:21] <bstrie> could rename the macs to fhqwgads
[19:18:30] <graydon> srsly
[19:18:58] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:19:01] <graydon> I mean, they're 8-way machines. if memory use permitted running 8 builds ...
[19:19:15] <strcat> graydon: it's down to 1.5GiB or something
[19:19:35] <strcat> and I could probably get the headers off ~ soon...
[19:19:42] <strcat> non-managed-unique ~
[19:19:51] <cmr> I don't think that will really help rustc
[19:19:58] <cmr> @ is everywhere
[19:20:20] <cmr> Linux is down under 1.2GiB right now
[19:20:27] <cmr> most of the build is around 950MiB
[19:21:21] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[19:21:23] <jedestep> i don't suppose there's a way to inspect a trait at runtime
[19:21:24] <brendanc> I only count 4 running mac builds
[19:21:24] <graydon> completely dropping the AST -- like doing all the pre-LLVM work in a subtask and killing it before running LLVM -- would help, as patrick suggested
[19:21:29] <cmr> graydon: if you could stagger builds by a minute or so, you should be fine
[19:21:35] <bstrie> pcwalton: re: emoticons, I hope you've seen https://github.com/mozilla/rust/commit/eb627817206aa0ca5faf4ffb68f53da0f5ddbde5
[19:21:48] <brendanc> oh, try
[19:21:51] <graydon> cmr: only if they take the same amount of time. which they don't
[19:21:56] <pcwalton> yeah
[19:21:58] <cmr> graydon: oh, right
[19:21:59] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:22:05] <pcwalton> bstrie: that was what spurred my comment
[19:22:39] <brendanc> could take a lock on the compile if the memory usage drops during test
[19:23:51] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[19:24:47] <bstrie> so currently, in order to denote that a type is noncopyable, we impl an empty destructor on it. in the bold new world of .clone(), does it suffice to simply not implement Clone to denote noncopyable types?
[19:24:57] <strcat> bstrie: use util::NonCopyable
[19:25:07] <strcat> impl of Drop adds a byte, NonCopyable is free now
[19:25:17] <bstrie> you have to stick that in your struct?
[19:25:21] <strcat> or you could impl Drop and use #[unsafe_no_drop_flag] yourself
[19:25:23] <strcat> bstrie: yes
[19:25:54] <bstrie> strcat: ok, but would it still be necessary? if you provide a library with a type that you didn't impl Clone on, no users can ever clone that type
[19:26:31] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:26:37] *** Joins: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net)
[19:26:40] <strcat1> bstrie: I doubt we will lose the concept of implicitly copyable
[19:26:42] <strcat1> just 'copy'
[19:26:47] <bstrie> ok
[19:27:06] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:27:09] <bstrie> I guess if POD is implicitly copyable, and structs count as POD, then it's still needed
[19:27:16] <bstrie> though I could be misunderstanding
[19:27:17] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[19:27:25] <strcat1> bstrie: if something has a destructor, it moves
[19:27:28] <strcat1> that's the only rule
[19:27:36] *** strcat1 is now known as strcat
[19:27:47] <strcat> if it doesn't have a destructor, it implicitly copies
[19:27:47] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:28:03] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:28:27] <bstrie> strcat: so you think util::Noncopyable is a production-ready solution? can I close https://github.com/mozilla/rust/issues/4069 ?
[19:28:56] <strcat> yes
[19:29:05] <strcat> but atm due to a bug you can't use NonCopyable outside of libstd
[19:29:17] <bstrie> haha
[19:29:20] <bstrie> well that's a different bug
[19:29:22] *** Joins: paupau_ (paul@moz-D6583788.hsd1.ca.comcast.net)
[19:29:22] <strcat> unit structs can't be created in other crates even if they are pub
[19:29:27] *** Joins: eholk (eholk@moz-F6BEA424.uconnect.utah.edu)
[19:29:50] *** Quits: eholk (eholk@moz-F6BEA424.uconnect.utah.edu) (Quit: eholk)
[19:29:53] <strcat> rusti: let a: Option<std::util::NonCopyable> = None; a
[19:29:54] -rusti- None
[19:30:01] <strcat> rusti: let a = NonCopyable; a
[19:30:02] -rusti- <anon>:9:17: 9:28 error: unresolved name `NonCopyable`.
[19:30:02] -rusti- <anon>:9          let a = NonCopyable; a
[19:30:02] -rusti-                           ^~~~~~~~~~~
[19:30:02] -rusti- error: aborting due to previous error
[19:30:02] -rusti- application terminated with error code 101
[19:30:07] <strcat> rusti: let a = std::util::NonCopyable; a
[19:30:07] -rusti- <anon>:9:17: 9:39 error: unresolved name `std::util::NonCopyable`.
[19:30:08] -rusti- <anon>:9          let a = std::util::NonCopyable; a
[19:30:08] -rusti-                           ^~~~~~~~~~~~~~~~~~~~~~
[19:30:08] -rusti- error: aborting due to previous error
[19:30:10] -rusti- application terminated with error code 101
[19:30:25] <bstrie> though I'm sad that it lives in a module named "util"
[19:30:28] <strcat> rusti: struct Foo; let a = Foo; a
[19:30:29] -rusti- {}
[19:30:30] <bstrie> maybe we can find a better home for it
[19:30:35] <strcat> prelude
[19:30:38] <strcat> just shove it in prelude
[19:30:41] <strcat> and swap/replace too
[19:30:50] <bstrie> is that all that's left?
[19:30:57] <strcat> no but the other stuff is pretty useless
[19:31:02] <bstrie> haha
[19:31:17] <strcat> id and ignore
[19:31:22] <strcat> |x| x
[19:31:37] *** Joins: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de)
[19:31:42] <strcat> and .drop() being allowed explicitly could zap ignore
[19:31:54] <strcat> or let _ = x; dropping immediately
[19:31:57] *** Quits: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net) (Input/output error)
[19:32:11] <strcat> also Void, but we can put that in prelude
[19:32:23] *** Quits: paupau_ (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[19:32:25] <strcat> it could replace ! maybe, based on that issue tjc reported
[19:33:38] <bstrie> I've forgotten entirely about -> !
[19:33:54] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:34:15] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[19:34:22] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:36:01] <hatman> is ! a trait that can be implemented, out of curiosity?
[19:36:09] *** Quits: paupau (NEAT@moz-C616DA0A.hsd1.ca.comcast.net) (Ping timeout)
[19:36:24] <strcat> hatman: no, it should be
[19:36:26] <sp3d> i.e. bottom? how /does/ bottom work in Rust?
[19:36:35] <strcat> sp3d: well he means the ! operator
[19:36:38] <sp3d> ok
[19:36:42] <hatman> strcat awww so if I have an enum I can't actually apply ! to it?
[19:36:51] <cmr> strcat: it's BitNot isn't it?
[19:36:55] <cmr> Or just Not?
[19:37:03] <strcat> hatman: well you won't ever be able to apply ! to an enum without giving it a weird meaning
[19:37:06] <sp3d> I just had noticed ~ in some type printing stuff and wondered what that was all about
[19:37:10] <sp3d> !*
[19:37:13] <Ms2ger> I guess you can't really use ~ for a bitnot
[19:37:17] <hatman> strcat: oh, if the enum values were actually just ints, say
[19:37:18] <strcat> cmr: we don't have that
[19:37:20] <hatman> or bools
[19:37:23] <strcat> hatman: doesn't matter
[19:37:33] <strcat> you can't store 5 in an enum that only lists 2 and 3
[19:37:41] <cmr> rusti: !4u8
[19:37:41] -rusti- 251
[19:37:43] <cmr> rusti: !false
[19:37:43] -rusti- true
[19:37:45] <cmr> Ms2ger: ^
[19:37:58] *** Joins: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net)
[19:37:58] <hatman> aaah well :P strcat thanks
[19:38:37] <Ms2ger> cmr, that feels really weird to me
[19:38:44] <thiez> strcat: surely id isn't useless
[19:38:52] <thiez> we'd have an identity crisis without it.
[19:38:52] <hatman> thiez flip the bits, add one... seems legit
[19:38:57] <hatman> haha
[19:39:10] <bstrie> strcat: wait, do you mean that everything in std::util should become std::prelude, or do you want to leave util as an implementation detail and just reference Noncopyable etc. in the prelude
[19:39:19] <strcat> bstrie: move it into prelude
[19:39:25] *** Quits: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP) (Quit: Leaving)
[19:39:32] <strcat> if a function is in prelude there's no reason for it to be also somewhere else
[19:39:33] <bstrie> ok, that seems cleaner even if it's currently unprecedented
[19:39:51] <bstrie> there's lots of stuff in prelude, like println and Option :P
[19:39:55] <strcat> the precedence is every other language
[19:39:57] <strcat> ;p
[19:40:02] <bstrie> *stuff in prelude that's not defined in prelude
[19:40:12] <engla> it's better if prelude is easy to read
[19:40:25] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:40:30] <strcat> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html easy enough to read
[19:40:46] <Ms2ger> Ugh, haskell docs :)
[19:41:02] <engla> I'm sure we can do better
[19:41:19] <Ms2ger> I'd hope so
[19:41:41] <engla> haskell docs are nice because it always links to the source
[19:41:43] <bstrie> tell that to cmr :)
[19:41:53] <engla> and then you are astonished how simple it looks
[19:41:59] <Ms2ger> cmr, that
[19:42:02] <Ms2ger> bstrie, like that? :)
[19:42:05] <bstrie> like that
[19:42:10] <bstrie> that that that
[19:42:44] <engla> http://static.rust-lang.org/doc/std/prelude.html
[19:42:52] <engla> it's easy to read allright
[19:42:58] <bblum> brson: can you tell me about the difference between task::destroy and its finalizer?
[19:42:58] <bstrie> minimalist, some would say
[19:43:13] <bblum> brson: the comment mentions "calling it unsafely" but in fn run() i see nothing unsafe
[19:43:34] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[19:45:26] *** Joins: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP)
[19:46:11] *** Quits: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de) (Ping timeout)
[19:46:12] <bstrie> graydon: how timely: https://github.com/blog/1547-release-your-software
[19:48:09] <lkuper> is today release day?
[19:48:14] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[19:48:21] <bstrie> sometime this week
[19:48:24] <bstrie> having bot troubles
[19:48:30] <cmr> pcwalton: very slight win, LLVM time difference is within noise (http://i.imgur.com/s7XYj8C.png)
[19:48:36] <bstrie> skynet conspires against us
[19:48:43] <pcwalton> cmr: ok, cool
[19:48:47] <pcwalton> that's what I would have guessed
[19:48:49] *** Joins: Jesin (Jessin_@moz-1B1307FF.eecs.lehigh.edu)
[19:49:21] <doener> cmr: which PR is that?
[19:49:29] <cmr> https://github.com/mozilla/rust/pull/7543
[19:49:30] <bstrie> newtype structs as immediates
[19:49:34] <bstrie> which I thought landed months ago
[19:50:19] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[19:51:31] *** Quits: pnathan (Adium@B9840254.2CD8A5F8.477B877D.IP) (Ping timeout)
[19:54:07] *** Quits: igl (igl@moz-FB10C277.adsl.alicedsl.de) (Ping timeout)
[19:56:18] <toddaaro> has anyone had problems running into a max file descriptor limit running the rust test suite?
[19:56:46] <brson> toddaaro: yes
[19:56:49] <toddaaro> I tried it on a beefy IU server I have access to hoping to use it for more robust parallelism testing, but it has a fd limit 0f 1024 which a library test hit
[19:57:07] <toddaaro> brson: ok, so that is expected, is it a bug of some sort or does the test suite just test a lot of stuff?
[19:57:37] <doener> :-/ no I've gone from double free to bogus "borrowed" failures
[19:57:42] <doener> s/no/now/
[19:57:49] <strcat> toddaaro: whoa, 1024 is a low number
[19:57:54] <strcat> the default is 373940
[19:58:07] <brson> toddaaro: I think it's a bug specific to the io branch. I've only seen it while trying to test io on the bots
[19:58:27] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[19:58:55] <strcat> toddaaro: is it the per-user limit that's 1024?
[19:59:00] <toddaaro> strcat: yea
[19:59:39] *** Quits: jpochyla (jpochyla@moz-DDB6BA4E.broadband9.iol.cz) (Ping timeout)
[19:59:47] <strcat> that's really not a lot of files
[19:59:50] <strcat> git could hit that
[19:59:54] <strcat> if you didn't run a gc for a while
[20:00:19] <toddaaro> brson: hm, ok, I put in a service request to get my ulimit modified, once that goes through I can start doing tests on various 32 core machines
[20:00:28] <toddaaro> strcat: yea, it seems stunningly low to me too
[20:03:47] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[20:03:48] *** Joins: jmgrosen (jmgrosen@moz-BF80C818.sbcc.edu)
[20:05:34] *** Quits: jmgrosen (jmgrosen@moz-BF80C818.sbcc.edu) (Quit: jmgrosen)
[20:05:46] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[20:05:54] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[20:06:10] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[20:07:33] *** Joins: fabiand (fabiand@moz-DA383042.adsl.alicedsl.de)
[20:12:47] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:14:08] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[20:14:35] <sully> strcat: hm, it isn't clear to me that inline actually has anything to do with it
[20:14:51] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:14:51] *** ChanServ sets mode: +o brson
[20:15:08] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[20:15:27] *** Joins: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP)
[20:16:11] <bblum> we still don't have a cacheline_aligned flag do we
[20:16:22] <cmr> does llvm do that?
[20:17:08] *** Quits: tjc (tjc@2557E599.66715431.D25A875A.IP) (Quit: zzzzzzzzzz)
[20:19:08] *** Parts: jesse98 (jjones@6251EDC2.15651213.B46B86FA.IP) ()
[20:19:16] <strcat> we don't have -march=native anyway
[20:19:18] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[20:20:22] <cmr> does clang do detection for -march=native, is it separate from the target features feature?
[20:22:02] *** Joins: jesse98 (jjones@6251EDC2.15651213.B46B86FA.IP)
[20:22:05] <bstrie> we still only support 32-bit windows, right?
[20:22:11] <cmr> bstrie: yes
[20:23:33] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[20:25:14] <bstrie> so, question... would running the full test suite on windows still take *less* time than our valgrind builds?
[20:25:34] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Quit: victorporof)
[20:25:53] <cmr> would need to be tested
[20:26:03] *** Quits: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca) (Quit: lmandel)
[20:26:06] <cmr> would also need to go through and fix all the tests that are assuredly failing on windows :p
[20:26:30] <cmr> graydon: that sounds like a worthwhile effort to me
[20:26:35] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[20:28:36] *** Joins: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca)
[20:29:42] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[20:30:16] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[20:30:26] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[20:30:42] <bstrie> strcat: is there a bug for the new `for` semantics?
[20:30:44] <sully> strcat: ok, so, I removed all of the inline annotations, and it still happens
[20:30:57] <sully> strcat: currently my biggest confusion is how default methods /ever/ work
[20:31:03] <cmr> heh
[20:31:25] <bstrie> as the maintainer of default methods, this is a worrisome confession
[20:33:41] <sully> how they ever survive privacy checking, that is
[20:34:20] <nmatsakis> strcat: pcwalton: was there ever discussion on a new `for` syntax?
[20:34:45] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[20:34:50] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[20:34:55] <cmr> nmatsakis: not a serious one afaik
[20:35:05] <cmr> a bit on reddit, some in here the other day
[20:37:37] <cmr> nmatsakis: https://botbot.me/mozilla/rust/msg/4197868/
[20:38:41] *** Joins: eholk (eholk@77910EB7.BEBDB225.ABD5273E.IP)
[20:39:21] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[20:42:28] <jedestep> correct me if I'm wrong, but safe rust code should be unable to leak memory?
[20:42:28] *** Quits: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be) (Quit: nn)
[20:43:02] <bblum> ok, time for swap_map
[20:43:12] <bblum> jedestep: it should be unable to leak *unreachable* memory
[20:43:21] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[20:43:31] <bblum> it is entirely possible to leak other resources
[20:43:34] <nmatsakis> cmr: thanks
[20:43:40] <bblum> like you could spawn two tasks that deadlock, and forget about them
[20:44:42] <jedestep> my code seems to be leaking 17KB of unreachable memory
[20:45:07] <cmr> jedestep: says valgrind?
[20:45:15] <jedestep> yeah
[20:45:25] <cmr> what's the code?
[20:45:33] <jedestep> definitely lost: 16,280 bytes in 41 blocks
[20:45:50] <jedestep> cmr: it's a little much, 1500 lines would rather not post it all now
[20:46:00] <cmr> heh
[20:46:04] <jedestep> in general though
[20:46:14] <cmr> jedestep: afaik rustc is valgrind clean
[20:46:18] <cmr> and all the tests
[20:47:05] <Eridius> is it expected that the test harness doesn't flush "test name::of::test ..." until after the test is done?
[20:49:12] <sully> strcat: ah, got it
[20:49:24] <jedestep> i make unsafe calls to transmute in about 10 places. how likely is this to cause an issue?
[20:50:01] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[20:50:13] *** Joins: tjc (tjc@2557E599.66715431.D25A875A.IP)
[20:50:13] *** ChanServ sets mode: +o tjc
[20:50:59] <graydon> hah
[20:51:41] <graydon> I .. would not at all have predicted the symmetry between RAII and once functions
[20:51:42] <sully> hm, do we have documentation explaining how privacy is supposed to work?
[20:51:48] <graydon> yet here I am
[20:51:54] <graydon> sully: hm, not sure. refman maybe?
[20:52:07] <bblum> graydon: i don't think it's a direct correspondence
[20:52:19] <bblum> it's certainly common
[20:52:28] <graydon> no, not direct
[20:53:12] <graydon> just a "this use case works both ways" thing I just hit, again. it's basically the "cases you would use closures to bracket a scope" with.
[20:53:26] <strcat> nmatsakis: I think a new syntax would be fine but it's a lot harder than changing the semantics to use external iterators
[20:53:36] <strcat> for pattern in iterator { } is fine
[20:53:44] <strcat> for iterator |pattern { } is fine imo too though
[20:53:48] <strcat> I don't really care either way
[20:53:58] <strcat> for iterator |pattern| { } *
[20:54:12] <strcat> python actually has an 'in' keyword
[20:54:18] <strcat> so it's a contextual reuse of that
[20:54:21] <nmatsakis> strcat: yeah, just curious if this had been discussed, I am not able to monitor #rust in detail these days
[20:54:48] <nmatsakis> strcat: does seem a shame to add a keyword just for this.
[20:54:57] <nmatsakis> but I don't really want to get into the details...
[20:54:57] <cmr> C# also uses 'in'
[20:55:07] <strcat> nmatsakis: maybe it doesn't need a keyword since it's only in a certain context
[20:55:15] <strcat> but I really think the current syntax is fine
[20:55:17] <cmr> yeah, I don't see why it would need to be a keyword
[20:55:20] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[20:55:23] <nmatsakis> strcat: well, we've been trying to avoid the "contextual keyword" notion
[20:55:33] <nmatsakis> let's just use `if`. it's *almost* `in`
[20:55:42] <nmatsakis> ;)
[20:55:51] <bblum> c.c
[20:56:12] <strcat> I don't think it's actually confusing to use |x, y| for two things
[20:56:27] <engla> we don't need for, it can be a macro. (rust will give worst possible first impression to learners)
[20:57:22] <Eridius> my only issue with the current `for` syntax is iterators will always be |(...)| instead of the simpler |...|
[20:57:41] <bblum> |(...)| isn't great
[20:57:41] <strcat> but iterators don't necessarily return a tuple
[20:57:48] <strcat> they can return a tuple struct, a struct, an enum
[20:57:49] <Eridius> strcat: well they return a single value
[20:57:52] <bblum> strcat: but if they do, you couldn't use |a,b|
[20:57:59] <Eridius> so yeah you can have |a|, but you can't have |a,b|
[20:57:59] <bblum> like if you were doing a fold
[20:58:12] <bblum> i kind of like for val in iterator
[20:58:16] <doener> for iter as bla { ... }?
[20:58:17] <bblum> it distinguishes it from the closure syntax
[20:58:25] <strcat> bblum: in python, tuples don't need parens
[20:58:26] <Eridius> for a : iter { ... } ?
[20:58:27] <strcat> x = 1, 2
[20:58:30] <strcat> a, b = 1, 2
[20:58:32] <bblum> strcat: well, we're not python
[20:58:33] <strcat> for a, b in foo: pass
[20:58:35] <strcat> bblum: well I mean
[20:58:41] <strcat> that's why python's for loop has no parens
[20:58:45] <strcat> when there are multiple things
[20:58:46] <bblum> right
[20:58:51] <bblum> basically my opinion is just we shouldn't reuse the closure syntax
[20:58:52] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:58:59] <bblum> but i don't feel very strongly
[20:59:07] <SiegeLord> Many languages use the assignment operator... like for pattern = iterator {}
[20:59:11] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[20:59:20] <strcat> first I really want the changed semantics to land
[20:59:29] <strcat> changing the for syntax is going to be awful
[20:59:30] <Eridius> SiegeLord: I find that ugly
[20:59:30] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Max SendQ exceeded)
[20:59:36] <cmr> strcat++
[20:59:41] <strcat> I guess you have to land it as another keyword
[20:59:42] <engla> we can use symbols if a keyword is bad... for x <- iterator {... }
[20:59:43] <strcat> migrate them all to it
[20:59:45] <SiegeLord> Eridius: I agree, just going by commonality
[20:59:46] <strcat> remove the old keyword (for)
[20:59:48] <strcat> and rename it all
[20:59:51] <strcat> not going to be fun ;p
[21:00:00] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[21:00:11] <SiegeLord> 'in' is also very common
[21:00:20] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Max SendQ exceeded)
[21:00:32] <Eridius> I dislike reserving another keyword just for this
[21:00:58] <doomlord> i wouldn't mind losing 'in'
[21:01:08] <cmr> Eridius: I don't think it needs to be a keyword..
[21:01:20] <doomlord> i would rather a language reserves more keywords than has ambiguous/cryptic syntax
[21:01:31] <doomlord> we can always capitalize things to differentiate
[21:01:39] <cmr> or trailing underscore
[21:02:00] <bblum> hmm, unwrap_select would be cool, but quite difficult
[21:02:08] <doomlord> maybe you guys should reserve a load speculatively :)
[21:02:10] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:02:50] <strcat> the only new keyword I want is 'yield' ;p
[21:03:10] <SiegeLord> The : syntax is nice as it comes over from C++ (if that's the target demographic for C++)
[21:03:18] <SiegeLord> *for Rust
[21:03:43] <strcat> #[generator(Foo)] fn foo(&self) { foo(self.left); yield self.value; foo(self.right) }
[21:04:10] <strcat> but that'd be hard to write.
[21:04:15] <bblum> strcat: what extra expressiveness is given by generators
[21:04:19] <bblum> they always seemed gimmicky to me
[21:04:25] <strcat> bblum: writing recursive traversals sanely
[21:04:31] <kmc> doomlord: i agree, C++ has a lot of readability problems from too much keyword reuse
[21:04:32] <bblum> sanely?
[21:04:42] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[21:04:45] <kmc> but then they also reserved a few that are almost never used
[21:05:02] <jedestep> recursive traversals generally seem sane to me
[21:05:02] <strcat> bblum: https://github.com/mozilla/rust/blob/master/src/libextra/treemap.rs#L209 there it is written by hand
[21:05:15] <strcat> jedestep: not when you can save the state
[21:05:22] <strcat> as in, you can use them as iterator objects and zip them
[21:05:22] <SiegeLord> I kind of like the '=' myself though... Go uses it too, and we steal stuff from Go all the time
[21:05:37] <doomlord> i can't beleive how excited i am to be able to grep for definitions easily
[21:05:39] <strcat> bblum: it gets worse if it's more complicated than 2 children though.
[21:05:43] <strcat> quickly
[21:05:56] <Sergio965> strcat: Every time I see your name, I giggle.
[21:06:01] <strcat> heh
[21:06:35] <Sergio965> strcat: First I think of the libc function. Then, I think of a cat made of ASCII running around. The latter makes me giggle. :)
[21:06:55] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[21:07:04] <kmc> cats like to play with strs as well
[21:07:19] <Sergio965> If I have a cat, I'm gonna name him/her strcat!
[21:07:19] <cmr> That reminds me
[21:07:20] <strcat>        The  strfry()  function  randomizes  the  contents of string by using rand(3) to randomly swap characters in the
[21:07:21] <strcat>        string.  The result is an anagram of string.
[21:07:23] <strcat> that's better
[21:07:40] <cmr> strcat: I think void is among the only names worse than 'string', I'd much rather keep !
[21:07:43] <Eridius> SiegeLord: go also uses the `range` keyword. You don't say `for x = foo { ... } `, you say `for x = range foo { ... } `
[21:07:51] <strcat> cmr: Bottom then
[21:08:07] <strcat> cmr: the name is important, making uninhabited enums act as bottom is
[21:08:10] <strcat> isn't important*
[21:08:12] <strcat> urgh
[21:08:21] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[21:08:28] <strcat> Eridius: go doesn't have iterators though.
[21:08:28] <Sergio965> Eridius: For x, y := range bla.
[21:08:35] <paupau> is there documentation about the 'self lifetime (even if it is merely convention)?
[21:08:42] <SiegeLord> Eridius: Oh, I missed the 'range'
[21:08:43] <doomlord> re keywords some text editors have abreviation with symbols  (emacs pretty mode)
[21:08:44] <Eridius> strcat: yes. My point is that saying "go uses =" isn't very relevant
[21:08:53] <Sergio965> strcat: But you can "invent" them using channels.
[21:08:58] <strcat> Sergio965: no
[21:09:04] <strcat> you can't have a generic iterator lib in go
[21:09:07] <strcat> try to write a generic map/fold
[21:09:12] <Sergio965> Oh, iterator. I read generator.
[21:09:18] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[21:09:18] <Eridius> you can "invent" them using channels, except trying to shut down a generator before it's complete is hairy
[21:09:21] <SiegeLord> Anyway, it's either ':', 'in' or '=' or invent a new syntax... I don't think the world needs a new for loop syntax :P
[21:09:22] <strcat> I do mean iterator
[21:09:27] <strcat> you can use an iterator pattern in go
[21:09:27] <kmc> strfry isn't even uniform! http://sourceware.org/bugzilla/show_bug.cgi?id=4403
[21:09:28] <Eridius> if you ditch your "generator" early you'll leak a goroutine
[21:09:33] <strcat> can't write an iterator library though
[21:09:42] <Eridius> strcat: because Go doesn't have generics
[21:09:44] <strcat> kmc: it's okay, ulrich fixed it wrong :D
[21:09:47] <engla> you can use go-style iterators in rust too, except they rely on shared memory to be useful
[21:09:56] <Sergio965> You can write a bad one using interface {}
[21:10:00] <Eridius> I mean, you could do it entirely at runtime with reflection by requiring `chan interface{}` as your generator
[21:10:08] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[21:10:08] *** ChanServ sets mode: +o pcwalton
[21:10:10] <strcat> Sergio965: don't think you can
[21:10:17] <doomlord> what are you considering 'in' for ?
[21:10:20] <strcat> it needs to take a closure
[21:10:26] <cmr> doomlord: iteration, for loop
[21:10:32] <cmr> doomlord: `for x in y { ... } `
[21:10:38] <strcat> how will it pass along types based on the closure's parameter types?
[21:10:44] <SiegeLord> Or how about this... do x for y {} XD
[21:10:45] * strcat shrugs
[21:10:57] <Sergio965> strcat: So?
[21:11:04] <Sergio965> How does taking a closure change things?
[21:11:05] <doomlord> oh i would definitely prefer to see in reserved rather than reusing :
[21:11:21] <Sergio965> It could just be an external iterator.
[21:11:21] <Eridius> in/out is a nice pair of variable names. It would be a shame to reserve in
[21:11:25] <Sergio965> In which case channels would suffice.
[21:11:34] <doomlord> in/out .. src/dst
[21:11:36] <strcat> Sergio965: map(fn(a -> b)).filter(fn(a) -> bool)
[21:11:38] <doomlord> inp/out
[21:11:47] <strcat> Sergio965: talking about writing a generic iterator lib
[21:11:50] <strcat> as in using iterators generically
[21:11:56] <cmr> I don't think `in` needs to be reserved, its only use would be between a pattern and an expression, following a `for` token
[21:11:58] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[21:12:13] <SiegeLord> Or for y do x {}
[21:12:19] <Eridius> strcat raised a good point about being able to attach types to the closure args
[21:12:27] <strcat> hm?
[21:12:30] <doomlord> do makes less sense IMO
[21:12:43] <SiegeLord> The meaning is flipped
[21:12:45] <Sergio965> strcat: I'm fairly certain you could do it using interface{} and reflection.
[21:12:52] <SiegeLord> for iterator do pattern {}
[21:12:52] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[21:12:54] <strcat> Sergio965: you can't reflect on function parameter types
[21:13:01] <Eridius> all these different for syntaxes don't really provide a way to specify the type of the args
[21:13:06] <strcat> Sergio965: there's no way to get 'b'
[21:13:07] <doomlord> is this for thing some sugar for something that is still block based?
[21:13:17] <doomlord> (block/lambda whatever you call it)
[21:13:25] <cmr> Eridius: you won't be able to do that anyway, they aren't closures with the new semantics.
[21:13:39] <strcat> map(fn(a -> b)).filter(fn(b) -> bool).fold(fn(c, b) -> c) -> c
[21:13:45] <Eridius> cmr: that's.. actually a good point. Although being able to specify the type you expect the args to be could be useful
[21:14:22] <strcat> Eridius: I don't think you need to
[21:14:27] <strcat> the type of the args comes from the last adaptor
[21:14:34] <strcat> so you can just use the ::<> syntax
[21:14:45] <Sergio965> strcat: You could still do it. It's not pretty. The JSON library does stuff like this. Basically, the closure would have inputs of type interface(), and you would supply the types of the inputs to the map function itself.
[21:14:52] <SiegeLord> rusti: let (a : int, b : int) = (1, 2);
[21:14:52] -rusti- <anon>:9:16: 9:17 error: expected `,` but found `:`
[21:14:52] -rusti- <anon>:9          let (a : int, b : int) = (1, 2);
[21:14:52] -rusti-                          ^
[21:14:52] -rusti- application terminated with error code 101
[21:15:03] <Eridius> strcat: but I'd have to provide every arg that way, including all the previous iterator adaptors if I have a long chain
[21:15:08] <strcat> SiegeLord: so now the *calling code* needs reflection
[21:15:17] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (Input/output error)
[21:15:17] <SiegeLord> rusti: let (a, b) : (int, int) = (1, 2);
[21:15:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ASOO
[21:15:25] <strcat> Sergio965: *
[21:15:36] <Eridius> rusti: let (_a, _b) : (int, int) = (1, 2);
[21:15:37] -rusti- ()
[21:15:39] <SiegeLord> Won't you be able to do that ^?
[21:15:41] <Sergio965> strcat: No. It just needs to specify the types.
[21:16:00] <strcat> Sergio965: so I pass a closure returning a type B, how does that get picked up?
[21:16:17] <strcat> do I have to return something else with the type?
[21:17:09] <Sergio965> strcat: No, you'd say you're expecting a map[B] and the caller would take care of it.
[21:17:18] <Sergio965> A pointer to it, rather.
[21:17:40] <Sergio965> http://golang.org/pkg/encoding/json/#Marshal
[21:17:50] <Sergio965> http://golang.org/pkg/encoding/json/#Unmarshal
[21:17:56] <Sergio965> This is what the JSON library does.
[21:18:30] <strcat> so every closure you pass to map/filter/fold has to be passed with a interface{} explaining the types
[21:18:35] <Sergio965> Yes.
[21:18:41] <Sergio965> Like I said, not pretty, but possible.
[21:18:55] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: leaving)
[21:19:30] <cmr> doomlord: you said f16 would be useful for gpgpu, right?
[21:19:42] <doomlord> well useful for graphics
[21:20:17] <doomlord> half float they call it usually
[21:20:24] <bstrie> pcwalton: wondering if I can close https://github.com/mozilla/rust/issues/2619
[21:20:34] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[21:20:50] <strcat> cmr: an array of them will be half as small as an array of floats, that's why
[21:20:57] <pcwalton> bstrie: close it
[21:20:59] <bstrie> ok
[21:21:37] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:21:44] <Eridius> hmm, is const gone now?
[21:21:51] <strcat> &const still exists
[21:21:58] <pcwalton> Const is now Freeze
[21:22:00] <pcwalton> as a type parameter
[21:22:07] <Eridius> vec::bytes::copy_memory is no longer annotated with it, and vec::const_slice is gone
[21:22:21] <doomlord> (some SIMD units have half-float support)
[21:22:37] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[21:22:45] <Eridius> is there any replacement whatsoever for the ability to say vec::bytes::copy_memory(buf, vec::const_slice(buf, i, j), j)
[21:22:56] *** Quits: hatman (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:22:56] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[21:24:28] <eschweic1> what is the replacement for eachi?
[21:24:34] <strcat> eschweic1: enumerate
[21:24:42] <eschweic1> strcat: thanks!
[21:24:54] <strcat> iter().enumerate, until there's an Iterable trait
[21:24:58] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[21:25:15] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[21:25:39] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[21:26:07] *** Joins: jgilbert (jgilbert@43CB6079.66715431.D25A875A.IP)
[21:26:48] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Quit: out)
[21:27:41] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[21:28:23] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[21:28:23] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144347db1 to 14a2db7c1: 02http://git.io/N3iJvQ
[21:28:23] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[21:28:24] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[21:28:24] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/ZOwn2w
[21:28:24] <ghrust> 13rust/06auto 14056a42b 15Tim Chevalier: rustpkg: Make rustpkg commands work without a package ID...
[21:28:24] <ghrust> 13rust/06auto 141c47b9b 15bors: auto merge of #7419 : catamorphism/rust/default-package, r=catamorphism...
[21:28:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[21:28:50] <cmr> graydon: seems bsd is broken? http://buildbot.rust-lang.org/builders/auto-bsd-64-opt/builds/1/steps/configure/logs/err.html
[21:28:51] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[21:29:20] <graydon> cmr: that's build 1. 0 and 1 both had that. I fixed it. see build 2.
[21:29:27] <graydon> http://buildbot.rust-lang.org/builders/auto-bsd-64-opt/builds/2
[21:29:30] <cmr> oh
[21:29:46] <cmr> Why did bors reject the PR though? It looks like everythiong passed
[21:29:50] <graydon> I am not _just_ looking up obscure details of hardware floating point here :)
[21:30:52] <graydon> grr bors I taught you to ignore exception results, what gives?
[21:31:06] <strcat> can we just merge that one manually?
[21:31:29] <strcat> it's the most tested PR ever ;p
[21:32:23] <kmc> in rust, what are the norms as far as using RAII vs. 'with' functions that take a closure
[21:32:28] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[21:32:42] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[21:32:48] <cmr> kmc: newer code seems to be using RAII more often than with closures
[21:32:53] <graydon> kmc: shifting. we did more with-functions in the past. we have better &-logic now so RAII will work better.
[21:34:25] <graydon> strcat: I'd be fine with that if you want me to kill and restart the one currently testing
[21:34:35] <strcat> graydon: afaik it will do that itself
[21:34:37] <strcat> we'll see
[21:34:38] <kmc> what improved regarding &?
[21:34:46] <SiegeLord> I wonder if C++ code, now that they have closures, will switch away from RAII
[21:34:50] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[21:34:50] <ghrust> 01[13rust01] 15thestinger pushed 9 new commits to 06master: 02http://git.io/ujnEgw
[21:34:50] <ghrust> 13rust/06master 149e6d5e1 15Niko Matsakis: Defer reasoning about region relationships until after regionck....
[21:34:50] <ghrust> 13rust/06master 1442344af 15Niko Matsakis: Correct handling of if/match, and make explicit computation of...
[21:34:50] <ghrust> 13rust/06master 1479ea266 15Niko Matsakis: move docs into doc.rs
[21:34:51] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[21:34:53] <toddaaro> brson: hm, I ran a lot of test runs on multi-core setups and never managed to replicate on linux, so I guess I'll get osx rust set up
[21:34:57] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[21:35:04] <kmc> SiegeLord: interesting question
[21:35:19] <kmc> but RAII lets you acquire resources with a non-stack discipline, too
[21:35:27] <kmc> which is useful in C++ and I expect in Rust
[21:35:33] <strcat> graydon: ah I think bors is going to re-push and a build will start but the old ones won't be cancelled
[21:35:40] * strcat remembers now
[21:35:42] <Eridius> does nobody here ever use vec::bytes::copy_memory()? The removal of const_slice is giving me issues here :/
[21:35:45] <graydon> strcat: ok. I'll kill 'em.
[21:36:10] <kmc> the thing that bugs me about RAII is just how much boilerplate is needed to make a resource-acquirer class for something
[21:36:17] *** Quits: shachaf (shachaf@moz-F37E0395.members.linode.com) (Ping timeout)
[21:36:22] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Client exited)
[21:36:25] <kmc> but that's probably better in Rust, too
[21:37:19] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[21:37:26] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[21:37:31] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[21:37:32] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141c47b9b to 14ab34864: 02http://git.io/N3iJvQ
[21:37:32] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[21:37:34] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[21:37:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KHpw4w
[21:37:34] <ghrust> 13rust/06auto 14056a42b 15Tim Chevalier: rustpkg: Make rustpkg commands work without a package ID...
[21:37:34] <ghrust> 13rust/06auto 14ec06fc8 15bors: auto merge of #7419 : catamorphism/rust/default-package, r=catamorphism...
[21:37:34] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[21:37:35] *** Joins: shachaf (shachaf@moz-F37E0395.members.linode.com)
[21:37:43] <strcat> kmc: well you don't need to implement operator= and the move constructor in rust
[21:37:50] <kmc> right
[21:37:56] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:37:57] <kmc> also you don't need to mess around with header files :)
[21:38:30] <doomlord> r.e. RAII, I didn't think you had constructors as such, just named functions that intialize an instance... but do you still call them constructors ?
[21:39:09] <strcat> 'clone(&self) -> Self' is essentially a copy-constructor, just from the definition
[21:39:21] <kmc> not sure what you mean
[21:39:33] <strcat> let x = foo(); x = foo(); is equivalent to a move-assign in C++
[21:40:00] <strcat> and anything returning an object but not starting from it could be called a 'constructor'
[21:40:21] <kmc> in C++ you would e.g. have a class Lock with a constructor that takes Mutex&
[21:40:22] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:40:47] <strcat> in rust you would probably stick a lock method on Mutex returning Lock
[21:40:56] <kmc> mm
[21:41:02] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[21:41:03] <kmc> well, I guess you can do either in C++ too
[21:41:06] <strcat> although you *could* write Lock::new(&mutex), it'd just be weird ;p
[21:41:15] <strcat> kmc: yeah the annoying part in C++ is that means you need friends everywhere
[21:41:17] *** Joins: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net)
[21:41:23] <kmc> but people don't like returning objects, especially pre-move-semantics?
[21:41:54] <strcat> kmc: well they don't like returning objects when the objects have a non-trivial copy constructor *but* all real compilers do RVO
[21:42:01] <strcat> clang does, icc does, gcc does, MSVC does
[21:42:19] <kmc> *nod*
[21:42:27] <strcat> return temporary(); will never call the copy/move constructor
[21:42:30] <strcat> just returns it directly
[21:42:37] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:42:40] <strcat> at least with optimizations on...
[21:42:55] <strcat> even in the move/copy constructor has side effects, it's allowed explicitly
[21:43:02] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:43:28] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[21:44:04] <strcat> if you name it, it doesn't always work
[21:44:50] <sully> strcat: ok, I have a fix for the size_hint problem
[21:44:56] <strcat> sully: \o/
[21:45:00] <strcat> sully: so what was the real cause?
[21:45:48] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:46:17] <Eridius> sigh. Only way to use vec::bytes::copy_memory() to copy within a single vector, that I can see, is to use unsafe code
[21:46:22] <sully> strcat: privacy checking just never worked on default methods
[21:46:34] <kmc> why does Rc<T> replace the RcBox<T> with uninit() before freeing it?  is this to make T's dtor run?
[21:46:40] <sully> strcat: but the way that privacy checking works on methods is really funky
[21:46:44] <sully> strcat: I think it is probably bogus
[21:47:25] <sully> strcat: but it only does the privacy check if the type of the reciever is a struct...
[21:47:32] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:47:36] <pcwalton> I'm responsible
[21:47:40] <pcwalton> it's entirely possible that it's messed up
[21:49:08] <cmr> indutny: can https://github.com/mozilla/rust/pull/7351 be closed?
[21:49:26] <indutny> yes
[21:49:27] <indutny> sorry
[21:51:22] <mnemotic> ack! these changes to atomic intrinsics are worming all through std and extra >_<
[21:52:05] <cmr> pcwalton: How is a rustc::middle::resolve::CrateMap supposed to be used? (working on rustdoc)
[21:52:18] <pcwalton> a...crate map?
[21:52:24] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:52:27] <pcwalton> I'm not sure
[21:52:30] <pcwalton> off the top of my head
[21:52:44] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[21:52:47] <Eridius> why did we remove the ability to use mut with multiple bindings?
[21:53:14] <pcwalton> Eridius: so that you can say "let (mut a, mut b) = ..." in the future
[21:53:23] <Eridius> but you can't now :/
[21:53:24] <pcwalton> this was the backwards incompatible part which I front loaded
[21:53:46] <pcwalton> in general I try to front load backwards incompatible changes
[21:56:06] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:56:19] <strcat> kmc: yeah, it is
[21:56:47] <kmc> ok
[21:58:31] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[22:02:05] *** Joins: jviereck (Adium@moz-46FC95AD.adsl.alicedsl.de)
[22:03:04] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[22:03:04] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (Ping timeout)
[22:03:14] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[22:04:04] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[22:07:04] *** Quits: jviereck (Adium@moz-46FC95AD.adsl.alicedsl.de) (Quit: Leaving.)
[22:09:16] *** Joins: Ralith (ralith@moz-5B3C1C13.wireless.sfu.ca)
[22:10:17] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[22:10:30] <cmr> Once we have a Default trait, we could even have syntax sugar for settings certain fields and taking the default for the rest: Foo { field: val, ..super }
[22:10:35] <pcwalton> we have Zero
[22:10:39] <pcwalton> but I guess that's different
[22:10:42] <cmr> Zero is a hack :p
[22:10:57] <cmr> https://github.com/mozilla/rust/issues/7312
[22:11:08] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Client exited)
[22:11:28] *** Quits: sankha93 (Instantbir@73CCD62.549EE3E8.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[22:12:47] <pcwalton> I'm removing as many bad copies as I can from rustc as I remove all use of "copy"
[22:12:52] <pcwalton> got at least a dozen probably
[22:12:58] *** Quits: dylukes (dylukes@moz-13611DF9.hsd1.ma.comcast.net) (Quit: Computer has gone to sleep.)
[22:12:58] <pcwalton> might improve perf, who knows
[22:12:59] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[22:13:11] <pcwalton> once this is done I can rip out a lot of take-glue-generating code
[22:14:07] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[22:14:13] <cmr> I have a fix bitrotting locally that doesn't copy the source of every file for filemap/codemap (can't remember which), which was a ~25% memory win for that part of the code
[22:14:21] <pcwalton> sweet
[22:14:26] <pcwalton> there are still a *ton* of bad copies in the parser
[22:14:30] <pcwalton> copying tokens and stuff, it's just awful
[22:14:36] <pcwalton> those are next on my list
[22:14:50] <cmr> good luck
[22:14:57] <cmr> well, you have a lint pass for it now, so that's good
[22:15:01] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[22:15:38] <strcat> how much information does lint have access to?
[22:15:53] <strcat> can it use liveness, etc.?
[22:16:27] <cmr> I'd have to look again but iirc lints can run whenever
[22:16:31] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:16:34] <pcwalton> they run quite late
[22:16:36] <strcat> rusti: let _xs = ~[1, 2, 3]; /* warning: heap allocated array does not escape */
[22:16:37] -rusti- ()
[22:16:39] <strcat> etc.
[22:16:51] <cmr> Ok, they're run right before trans
[22:17:13] <strcat> well I guess that would need to check that you don't change the size too...
[22:17:14] <strcat> bad example :P
[22:17:18] <strcat> pretend it was ~T
[22:17:57] <strcat> would be nice if it checked if you passed it *as* ~T anywhere, and if you didn't warn about it
[22:17:59] *** Joins: igl (igl@moz-FB10C277.adsl.alicedsl.de)
[22:18:17] <strcat> and for @T too
[22:19:00] <cmr> strcat: can you think of anything to add to https://github.com/mozilla/rust/issues/7532 ?
[22:19:31] <strcat> allocator benchmarks in general
[22:19:48] <strcat> contention when doing ffi/allocation too
[22:20:11] <strcat> and we could have in-tree versions in C++ of the same code
[22:20:58] <cmr> Would also be a good candidate for the IR tests
[22:21:10] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[22:21:25] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[22:22:49] <pcwalton> yay, rustc building without any "copy" in it
[22:22:54] *** Joins: themgt (themgt@moz-22EF716.baf.movistar.cl)
[22:23:09] <pcwalton> on to libsyntax when/if it finishes bootstrapping
[22:24:16] *** Quits: themgt (themgt@moz-22EF716.baf.movistar.cl) (Quit: Pogoapp - http://www.pogoapp.com)
[22:24:42] <brson> another dist-snap failed
[22:25:52] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[22:26:05] <cmr> rusti: let x = ~[1u, 2, 3]; x.clone()
[22:26:07] -rusti- ~[1, 2, 3]
[22:26:15] <cmr> rusti: let x = ~[@1u, @2, @3]; x.clone()
[22:26:16] -rusti- ~[@1, @2, @3]
[22:27:04] <cmr> rusti: let x = ~[@1u, @2, @3]; let y = x.clone(); std::managed::ptr_eq(x[0], y[0])
[22:27:05] -rusti- true
[22:28:02] <engla> lol. I rewrote a deque using malloc to make it more compact. didn't expect this when finally testing the performance compared to extra::Deque    https://gist.github.com/anonymous/f1fbc29a033a150cf600
[22:28:15] <engla> I didn't want to discover extra::Deque was broken but it seems like it
[22:28:20] *** Quits: jdm (jdm@92FB48CA.8B5E9DF.9A8C35B4.IP) (Quit: Lost terminal)
[22:28:22] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[22:28:32] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[22:31:24] <bblum> brson: ping
[22:31:43] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:31:48] <engla> rusti: let mut dq = extra::deque::Deque::new(); for 32.times { dq.add_front(0); }
[22:31:49] -rusti- rust: task failed at 'left: 31 does not equal right: 32', /build/rust-git/src/rust/src/libextra/deque.rs:239
[22:31:49] -rusti- rust: domain main @0x1a041b0 root task failed
[22:31:49] -rusti- application terminated with error code 101
[22:32:12] <strcat> heh
[22:33:01] <engla> I'll see if I can fix the bugs in that module
[22:33:23] <cmr> engla: or just rewrite it :p
[22:33:26] <engla> because then my dicking around paid off
[22:33:26] <cmr> rusti: let x = ~[@1u, @2, @3]; let y = x.deep_clone(); std::managed::ptr_eq(x[0], y[0])
[22:33:27] -rusti- <anon>:9:41: 9:56 error: type `~[@uint]` does not implement any method in scope named `deep_clone`
[22:33:27] -rusti- <anon>:9          let x = ~[@1u, @2, @3]; let y = x.deep_clone(); std::managed::ptr_eq(x[0], y[0])
[22:33:27] -rusti-                                                   ^~~~~~~~~~~~~~~
[22:33:27] -rusti- error: aborting due to previous error
[22:33:28] -rusti- application terminated with error code 101
[22:34:05] <engla> cmr: well.. the deque impl I wrote was using malloc so it is not fit for libextra I think
[22:34:25] <engla> it was just to dick around. and because Deque wastes memory (for some T) with Option
[22:34:47] <strcat> yeah you can't use malloc in that
[22:34:52] <strcat> because it will break with gc
[22:35:04] <strcat> and you should be able to put @ things in containers
[22:35:10] <engla> right
[22:35:22] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[22:35:49] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[22:35:49] *** ChanServ sets mode: +o brson
[22:36:50] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[22:37:40] <engla> but I think the grow rule for that Deque is really slow
[22:38:00] <strcat> engla: it should be doubling in size when it fills
[22:38:09] <strcat> dunno what it got changed to after all the refactors
[22:38:14] <engla> I think it is
[22:38:46] <engla> maybe vec::grow_fn is slow
[22:38:54] <pcwalton> macros are way better at generating code than trans is
[22:38:56] <engla> I'll bench it now
[22:39:02] <strcat> engla: it's not marked #[inline]
[22:39:04] <cmr> pcwalton: I've been thinking about that actually.
[22:39:04] <strcat> that's the problem
[22:39:19] <engla> it can't make this big a difference
[22:39:23] <strcat> engla: sure it can
[22:39:28] <cmr> pcwalton: Is there a subset of rust we can use that we can actually implement the features in rustc with a macro, for desugaring?
[22:39:32] <pcwalton> cmr: I much prefer the #[deriving(Clone)] world to the take-glue world
[22:39:38] <strcat> closures are incredibly slow without being inlined and removed by llvm
[22:39:47] <pcwalton> in general I would love for the language to be simple enough that we barely even need an IR
[22:39:49] <strcat> when used in place of loops
[22:39:55] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[22:40:15] <pcwalton> simple in the sense of mapping to basic machine instructions
[22:40:20] <engla> which closure is the slow one? the one passed to grow_fn?
[22:40:28] <pcwalton> not in the Go sense of "having few user-level constructs"
[22:40:42] <strcat> engla: yes, it will do 4000 function calls with 2000 elements
[22:40:56] <brson> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-07-02
[22:40:56] <strcat> it's not much of a loop
[22:41:27] <engla> stunning discovery then being that realloc is faster
[22:41:50] <engla> anyway, first I'll fix the assertion
[22:42:02] <strcat> ugh
[22:42:22] <strcat> we actually have an inline(never) in vec
[22:42:34] <strcat> we should stop second guessing LLVM
[22:46:40] *** Joins: napoleon (Mibbit@moz-1FEAB537.ucsf.edu)
[22:49:05] *** Quits: napoleon (Mibbit@moz-1FEAB537.ucsf.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[22:50:56] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[22:51:39] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[22:57:09] <bblum> how come we never saw the need to have an option::take
[22:57:15] <bblum> (&mut self) -> Option<T>
[22:59:01] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[23:00:14] <bblum> "woohoo", writing a 3-deep nested closure where all of them need to be once closures
[23:00:19] * bblum cell cell cell
[23:00:34] <bblum> (two of them are stack closures)
[23:00:44] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:01:04] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Max SendQ exceeded)
[23:01:18] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[23:01:56] <engla> ~Thunk
[23:02:16] <bblum> that will only solve one of the layers
[23:02:42] <engla> hmmm.. you should be able to move into and then move into the next closure
[23:03:23] <bblum> moving into the next closure requires moving out of the enclosing closure
[23:03:34] <bblum> moving out is the thing which is not allowed without once fns
[23:03:48] <engla> yeah
[23:04:41] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[23:05:02] <engla> the lazy list I wrote did that using thunk objects. but it's a hacky solution
[23:05:29] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[23:05:55] <kimundi> Hmm... The discussion moved on, but re 'for' syntax: 'for pattern = expr {}' would nicely mirror 'let pattern = expr;'
[23:06:15] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[23:06:35] <strcat> seems pretty weird to me
[23:07:18] <Eridius> kimundi: that was already suggested. Looks weird to me too
[23:07:45] <bblum> i know! we should do "for expr { pattern => { ... } }"
[23:07:55] <kimundi> right, saw it suggested, just wanted to note the symmetry to let
[23:09:07] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:10:07] *** Joins: roo (jesse.rudo@moz-FB1A29EA.dynamic.ip.windstream.net)
[23:10:17] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[23:10:18] <strcat> [master ccb005e] add a temporary vector_exchange_malloc lang item
[23:10:20] <strcat>  5 files changed, 67 insertions(+), 41 deletions(-)
[23:10:22] <strcat> ;p
[23:10:27] <strcat> anyway now an attempt at removing ~T headers for non-managed
[23:10:50] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Input/output error)
[23:10:56] * strcat needs contains_managed snapshotted to do vec sanely
[23:11:04] <kimundi> I think most proposals so far look weird in one way or another, that's the problem :P
[23:11:11] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:11:34] <Eridius> for x ‚òÉ foo { ... }
[23:12:08] *** Quits: RMF (RMF@6152834E.A3AF135E.823A4631.IP) (Quit: Textual IRC Client: www.textualapp.com)
[23:12:33] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[23:12:42] *** Quits: jgilbert (jgilbert@43CB6079.66715431.D25A875A.IP) (Ping timeout)
[23:13:19] <brson> bstrie: do you have a new front-page sample?
[23:13:34] <Eridius> for!(a, b <- foo { ... })
[23:13:43] <kimundi> 'for p do e {}' => "do? is there a closure?"; 'for p = e {}' => "equal sign looks weird there, you do more then one assignment" 'for e |p|  {}' => "why does it look like a closure?"; 'for p in e {}' => "blocks in as a keyword!" ... etc
[23:14:12] <strcat> really lets not use 'do'
[23:14:23] <strcat> or =
[23:14:30] <strcat> that's no less confusing than ||
[23:14:44] <strcat> it's only worth changing if it's an improvement...
[23:14:50] <kimundi> well, but closer to tho truth
[23:15:39] <Eridius> `iter v with a, b { ... }`
[23:15:54] <engla> for x in v {}  is very close to other languages
[23:16:00] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:16:17] *** Quits: Ralith (ralith@moz-5B3C1C13.wireless.sfu.ca) (Ping timeout)
[23:16:18] <kimundi> Let's just do what we did for lifetimes: 'for pattern " expr {...}'
[23:16:22] <kimundi> ;)
[23:16:33] <pcwalton> what's wrong with "for x in v { ... } ?"
[23:16:35] <Eridius> I still want a way to put type annotations on the iterator variables though
[23:16:37] <pcwalton> seems like the easiest thing
[23:16:37] <kmc> i like "in"; is making the keyword contextual not an option?
[23:16:38] *** Quits: Sergio965 (sergiobz@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[23:16:47] <pcwalton> just eat the "in" keyword
[23:16:55] <pcwalton> one more keyword won't kill us
[23:16:59] <kmc> "in" is a kw in enough other langs that people avoid it as a variable name anyway
[23:17:21] <strcat> pcwalton: that's fine
[23:17:24] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Connection reset by peer)
[23:17:31] <kimundi> Then again, 'in' could be usefull to cram into other places of the syntax if it comes to that :)
[23:17:45] <strcat> pcwalton: you could use 'in' for @ patterns
[23:17:50] <strcat> ;p
[23:17:58] <pcwalton> if we got rid of @ then the @ pattern thing isn't an issue
[23:18:01] <Eridius> I like being able to use in as a variable :/
[23:18:03] <pcwalton> so I'm derferring it
[23:18:11] <pcwalton> deferring*
[23:18:17] <Eridius> Obj-C manages to have `for (x in y)` syntax without making "in" a keyword
[23:18:27] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[23:18:27] <pcwalton> graydon doesn't want contextual keywords
[23:18:38] <pcwalton> for syntax highlighting/tooling reasons
[23:18:40] <kimundi> in place allocation syntax: 'alloc foo', 'alloc foo in bar'
[23:18:44] <jclements> Eridus: glurg, neither do i
[23:18:47] <graydon> yes please, none of those
[23:18:48] <paupau> so for now I need to use myvec.iter().advance in for loops?
[23:18:50] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[23:18:54] <kmc> how about monkeypatch every type to support a method named 'in'
[23:18:58] <Eridius> pcwalton: how about `for x <- y { ... }`
[23:19:04] <strcat> paupau: yes
[23:19:17] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Ping timeout)
[23:19:25] <paupau> okay, thanks. also "use std::vec" etc everywhere?
[23:19:30] <strcat> no
[23:19:43] <pcwalton> if we really don't want the keyword then probably "for x : y" and requiring parens if you want type annotations seems best to me
[23:19:52] <pcwalton> anything else is straying far from precedent
[23:19:55] <paupau> should just do std::vec::build |push| { /*etc*/ } then
[23:19:58] <strcat> only if you want to refer to free functions in the vec module with vec::foo instead of std::vec, but you shouldn't need many of those
[23:20:04] <pcwalton> but my first choice would be the keyword
[23:20:06] <strcat> paupau: build is deprecated
[23:20:15] <strcat> the only useful one is probably with_capacity
[23:20:22] *** Joins: judder (maradukewa@5B9E91E7.2C8A8E2E.78E362FE.IP)
[23:20:23] <paupau> strcat: ah, okay
[23:20:30] <strcat> pcwalton: or <- or ->
[23:20:35] <Eridius> strcat: what was the point of build anyway?
[23:20:40] <pcwalton> are there other languages that use <-?
[23:20:46] <Eridius> pcwalton: reminds me of haskell list comprehensions
[23:20:52] <engla> kmc: add infix functions, start with in()
[23:20:52] <Eridius> [x | x x <- [1,2,3]]
[23:20:55] <strcat> yeah
[23:21:04] <Eridius> oops didn't mean to duplicate the x
[23:21:15] <sully> oof, static methods and default methods are not looking like they are going to want to play nicely
[23:21:30] <paupau> strcat: what's current style for allocating a vector of N Bucket structs then
[23:21:46] <Eridius> paupau: with_capacity?
[23:21:51] <Eridius> and then push push push
[23:22:00] <paupau> in my own loop, ok
[23:22:10] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[23:22:15] <paupau> I guess I already had a loop for build anyway
[23:22:40] <strcat> pcwalton: scala uses it
[23:22:48] <Eridius> paupau: you can also use vec::from_fn
[23:22:52] <pcwalton> mmm
[23:22:54] <Eridius> which does the loop for you
[23:23:02] <strcat> for (a <- range) { }
[23:23:13] <strcat> we wouldn't need the () though
[23:23:15] <pcwalton> I still prefer ':' just for C++11/Java/D but I could be convinced otherwise
[23:23:21] *** Joins: MaikKlein (maik@moz-3925DFD2.dip0.t-ipconnect.de)
[23:23:28] <strcat> pcwalton: I think we have too many uses of : already, it'd look like a type hint
[23:23:28] <bblum> how about we bring back the # sigil for for-loops
[23:23:35] <strcat> pcwalton: since you can use type hints in patterns
[23:23:37] <strcat> in some places
[23:23:38] <pcwalton> but really I prefer 'in'
[23:23:39] <strcat> well
[23:23:45] <bblum> or maybe we can just call them alt statements?
[23:24:12] <pcwalton> we already have fewer keywords than almost any other language say lua or go
[23:24:15] <pcwalton> save lua or go
[23:24:23] <pcwalton> or scheme
[23:24:27] <strcat> let xs = [1, 9, 2, 3]; for (x, &y) in xs {}
[23:24:34] <strcat> let xs = [1, 9, 2, 3]; for (x, &y) <- xs {}
[23:24:36] <pcwalton> any other algol-like language
[23:24:37] <strcat> I like either of those
[23:24:49] <paupau> it would be nice to have Python's `in` predicate as an operator
[23:24:54] <strcat> well that pattern isn't right
[23:24:55] * strcat is silly
[23:25:01] <strcat> let xs = [1, 9, 2, 3]; for (x, &y) <- xs.enumerate {}
[23:25:02] <cmr> fwiw lua does 'for x in y do ....'
[23:25:18] <kmc> engla: why stop at infix, we should have arbitrary mixfix a la agda
[23:25:18] <strcat> cmr: but we use 'do' for something else
[23:25:27] <strcat> lua/bash use 'do' as a contextual thing after 'for'
[23:25:29] <cmr> strcat: I'm not advocating we use do, I quite like curly braces
[23:26:16] <pcwalton> how do I make the makefiles stop turning on -Z no-debug-borrows?
[23:26:20] <kmc> i agree that : looks like a type hint, and its meaning is less clear in general
[23:26:58] <pcwalton> DEBUG_BORROWS=1, found it
[23:27:36] <SiegeLord> D actually uses ; not :
[23:28:07] <strcat> ugh I screwed up the LLVM build
[23:28:11] <pcwalton> oh hmm
[23:28:23] <engla> paupau: yes... that's also why they think in is nice because of the symmetry..  if key in set; for key in set
[23:28:25] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[23:28:53] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[23:29:08] <strcat> it would be '&key in set' most of the time ;p
[23:29:44] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[23:29:47] <cmr> I've often wanted a shorter way of writing `match foo { a | b | c => ..., _ => ....}` (which is if foo in (a, b, c) { ... } else { ... })
[23:30:08] <strcat> tuples are iterables in python
[23:30:14] <cmr> Right
[23:30:17] <strcat> cmr: you mean 'if foo in [a, b, c]'
[23:30:19] <cmr> Tuples are really weird in rust
[23:30:22] <strcat> no
[23:30:26] <strcat> tuples are weird in python.
[23:30:34] <strcat> they only exist in python because lists aren't hashable
[23:30:38] <strcat> the *only* reason
[23:30:43] <strcat> they aren't actual tuples
[23:31:02] <Luqman> just running configure takes so long on windows :(
[23:31:24] <strcat> python's __hash__ implementations are always constant for an object
[23:31:36] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Client exited)
[23:31:43] <Eridius> cmr: what's wrong with `if [a,b,c].contains(&foo)`
[23:31:59] <cmr> Eridius: it'd need an allocation
[23:32:04] <cmr> I think?
[23:32:06] <strcat> it wouldn't
[23:32:13] <strcat> it's the same thing
[23:32:14] <Eridius> [1,2,3] is a nice [int, ..3]
[23:32:19] <MaikKlein> brson, I really like your design patterns project, super awesome <3
[23:32:26] <cmr> is contains implemented for fixed length vectors?
[23:32:34] <strcat> cmr: it will be when we have default methods
[23:32:41] <strcat> it will come from Iterable
[23:32:42] <Eridius> ImmutableEqVector has it
[23:32:48] <Eridius> implemented on &'self [T]
[23:32:50] <strcat> shouldn't have it though
[23:32:55] <strcat> deprecated as it is atm
[23:32:59] <cmr> Eridius: that's a &[], not a [,..n]
[23:33:17] <strcat> any method on &[T] works on [T, ..n]
[23:33:21] <cmr> oh it does?
[23:33:23] <Eridius> cmr: rust should slice it for you
[23:33:23] <cmr> I was unaware of that
[23:33:28] <strcat> yes all vectors can be borrowed as slices
[23:33:29] <Eridius> rusti: [1,2,3].contains(&3i)
[23:33:32] <strcat> and they coerce implicitly
[23:33:32] -rusti- true
[23:33:40] <cmr> well then, nevermind!
[23:33:44] * cmr goes back to rustdoc
[23:33:53] <strcat> iter()/mut_iter() are actually only on &mut [T] and &[T] atm
[23:33:58] <strcat> since they aren't generic yet anyway
[23:35:20] * strcat is not really looking forward to rewriting half of playpen
[23:35:31] *** Quits: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net) (Quit: Leaving.)
[23:35:57] <MaikKlein> haha "In Rust we Trust"
[23:36:01] <cmr> indentation in vim is quite broken
[23:36:04] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[23:36:05] <cmr> (for rust)
[23:36:10] <strcat> cmr: it has no indent file
[23:36:16] <strcat> no one has written one
[23:36:21] <strcat> so it's using C indent rules ;p
[23:36:24] <cmr> well that would do it
[23:36:35] <bblum> option swap_map makes this function so much prettier
[23:36:49] <bblum> it's really surprising i never thought to add it before
[23:37:04] <engla> rustc builds on a swapless 4GB RAM laptop now.
[23:37:10] <engla> that's nice at least..
[23:37:15] <strcat> it takes a bit over 1GiB now
[23:37:17] <pcwalton> yay
[23:37:27] <pcwalton> should be easy to get it under 1GB
[23:37:35] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:37:39] <engla> yeah it never took more than 2.5GB here. but it still needed swap to get through
[23:37:40] <pcwalton> I wonder how much clang uses for a file that size
[23:37:55] *** Quits: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net) (Connection reset by peer)
[23:38:00] <strcat> pcwalton: 100MiB? ;p just a wild guess but the linker is usually the peak
[23:38:19] <pcwalton> the IR-level optimizations take more than that
[23:38:26] <pcwalton> but I guess we generate comparatively bad IR
[23:38:26] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[23:38:29] <strcat> pcwalton: well at -O0
[23:38:37] *** Joins: eevee (eevee@moz-58058235.evrt.wa.frontiernet.net)
[23:38:40] <strcat> pcwalton: rusti (the bot) uses 60MiB at minimum
[23:38:41] <pcwalton> what does their AST look like?
[23:38:53] <pcwalton> most of our memory usage is the AST, no?
[23:38:53] *** Parts: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) ()
[23:38:56] <cmr> yes.
[23:39:00] <pcwalton> I've long been skeptical of spanned<>, btw
[23:39:07] <pcwalton> just throw it in a compressed side table
[23:39:29] <strcat> pcwalton: it looks pretty close to optimized AST without inlining/unrolling/sroa/vectorizing - it gets the basics right and drops dead branches
[23:39:34] <cmr> Well, half of our memory usage is the ast, roughly
[23:39:42] <pcwalton> strcat: I mean the memory management
[23:39:47] <pcwalton> I imagine everything is not reference counted
[23:39:53] <pcwalton> does it ever fold? I suppose it must, to expand templates
[23:40:04] <strcat> pcwalton: they use small vectors/strings for almost everything
[23:40:11] <pcwalton> so do we, well, OptVec
[23:40:14] <strcat> and a custom arena allocator
[23:40:17] <pcwalton> aha
[23:40:20] <pcwalton> so it cannot free AST nodes?
[23:40:21] <strcat> bump allocation
[23:40:29] <strcat> pcwalton: probably not, I don't know how much they use it
[23:40:32] <pcwalton> I've been thinking perhaps we should do the same
[23:40:37] <pcwalton> our macro expander will leak memory
[23:40:39] <pcwalton> if we do that
[23:40:48] <pcwalton> but it sounds like clang's template expander must *also* leak memory
[23:40:53] <pcwalton> if it is using a bump allocator
[23:41:07] <strcat> pcwalton: since they have small vectors/strings they end up with a nice contiguous arena for a lot of stuff
[23:41:27] <pcwalton> it would be relatively simple to remove all the @ from our AST and switch it to &'static
[23:41:32] <pcwalton> unsound, but whatever, it's a compiler
[23:42:04] <strcat> pcwalton: hm, maybe clang doesn't use the bump ptr one much
[23:42:09] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[23:42:25] *** Joins: pnathan (Adium@moz-E3C3FAF2.hfc.comcastbusiness.net)
[23:42:46] <pcwalton> strcat: that's what I would think
[23:42:49] <pcwalton> due to template expansion
[23:43:01] <pcwalton> you really want to destroy AST nodes for unexpanded templates and whatnot
[23:43:02] <strcat> template expansion is weird, they memoize it
[23:43:06] <strcat> to deal with recursion
[23:43:12] <pcwalton> yeah
[23:43:25] <graydon> "When processing large keyword sets it helps greatly to have over 8 megs of RAM" awww SO CUTE
[23:43:31] <pcwalton> a good generational GC would be ideal for storing the AST (but maybe not)
[23:43:34] <pcwalton> actually hmm
[23:43:44] <pcwalton> the bump pointer in the nursery actually is worse than just malloc
[23:43:52] <pcwalton> because AST nodes are almost always tenured :)
[23:44:29] <pcwalton> probably the best you can do for AST nodes is either a leaky bump allocator or a fast GCing malloc implementation without headers
[23:44:51] *** kimundi is now known as zz_kimundi
[23:45:16] <pcwalton> or try to remove the AST map and switch to ~ boxes
[23:46:07] <pcwalton> we could make a UniqueWeakPtr<> which allows you to make weak references to it
[23:46:10] <pcwalton> err
[23:46:14] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[23:46:16] <pcwalton> WeakablePtr<>
[23:46:27] <pcwalton> whatever you call "a pointer that supports weak references"
[23:46:31] <graydon> oh
[23:46:33] <graydon> tjc: ping
[23:46:40] <tjc> graydon: pong
[23:46:44] <graydon> I meant to ask, can you switch the git tests to use a local git repo, not a remote one?
[23:46:48] <strcat> pcwalton: then you need a list of weak pointers to kill them all off though
[23:46:55] <tjc> graydon: ok
[23:46:58] <pcwalton> strcat: yeah, probably worse than just RC-ing it
[23:46:59] <graydon> I think having git fire in the middle of a test run is likely to cause a bunch of periodic test failures
[23:47:05] <graydon> or, having it connect remotely
[23:47:10] <pcwalton> strcat: maybe it could be something that knows about the AST map and will nuke all references
[23:47:13] <tjc> it would be nice to have a test that remote ones work, though
[23:47:17] <graydon> yeah, it would
[23:47:18] <graydon> hmm
[23:47:23] <pcwalton> but probably graydon's GC is good enough
[23:47:26] <graydon> is it possible to set up a git in serve-mode?
[23:47:31] <cmr> #[can_fail_its_ok] ;P
[23:47:34] <pcwalton> just get the GC pauses fast enough
[23:48:21] <bblum> you can't impl TypeOutsideModule<TypeInsideModule> can you?
[23:48:25] <brendanc> is the git url not just delegated to a git command? not sure what additional coverage you're getting there
[23:48:28] <bblum> you have to newtype it?
[23:51:13] <graydon> brendanc: yeah, it'd just be things like making sure we don't clobber your terminal when git asks you for an ssh passphrase or such
[23:51:21] <strcat> rustc is not happy about me removing ~ headers ;p
[23:51:28] * strcat wonders what else uses an offset
[23:52:04] <bblum> i don't need a semicolon after a newtype struct, do i?
[23:52:10] <brendanc> didn't think you'd have a tty for buildbot tests
[23:52:13] <strcat> rusti: struct Foo Foo
[23:52:13] -rusti- <anon>:9:20: 9:23 error: expected `{`, `(`, or `;` after struct name but found `Foo`
[23:52:13] -rusti- <anon>:9          struct Foo Foo
[23:52:14] -rusti-                              ^~~
[23:52:14] -rusti- application terminated with error code 101
[23:52:22] <strcat> rusti: struct Foo(int) Foo(5)
[23:52:22] -rusti- <anon>:9:25: 9:28 error: expected `;` but found `Foo`
[23:52:22] -rusti- <anon>:9          struct Foo(int) Foo(5)
[23:52:22] -rusti-                                   ^~~
[23:52:23] -rusti- application terminated with error code 101
[23:52:45] <strcat> rusti: type x = int 5
[23:52:46] -rusti- <anon>:9:22: 9:23 error: expected `;` but found `5`
[23:52:46] -rusti- <anon>:9          type x = int 5
[23:52:46] -rusti-                                ^
[23:52:46] -rusti- application terminated with error code 101
[23:53:20] * strcat is surprised it actually says <anon> instead of crashing
[23:53:41] <bblum> i see
[23:54:17] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[23:54:43] *** Quits: paupau (paul@moz-D6583788.hsd1.ca.comcast.net) (Ping timeout)
[23:58:15] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:59:26] <pnathan> hey, what did std/core get renamed to? I can't remember off the top of my head.
[23:59:40] <MaikKlein> core to std and std to extra
[23:59:53] <pnathan> thanks, much appreciated

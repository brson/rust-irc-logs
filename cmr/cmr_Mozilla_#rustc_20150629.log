[01:49:08] *** Joins: eddyb (eddyb@moz-l3g.mv7.25.188.IP)
[02:34:03] *** Quits: kimundi (kimundi@moz-7l900c.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:36:14] *** Joins: kimundi (kimundi@moz-9b6hhf.dip0.t-ipconnect.de)
[03:53:56] *** Quits: stl (stl@moz-511.ict.15.176.IP) (Connection closed)
[04:04:19] *** Joins: stl (stl@moz-511.ict.15.176.IP)
[04:05:13] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[04:33:59] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[05:26:44] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[05:34:52] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Connection closed)
[05:57:33] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[06:22:07] *** Joins: aatch (james@moz-is4j4r.cable.telstraclear.net)
[06:47:49] *** Joins: laumann (thomas@moz-poa.3kq.109.2.IP)
[07:14:31] *** Quits: laumann (thomas@moz-poa.3kq.109.2.IP) (Quit: leaving)
[07:31:44] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[07:48:12] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[09:56:36] *** Joins: arielby (Mibbit@moz-cmi.jfj.114.192.IP)
[10:19:22] <arielby> wtf type_needs_unwind_cleanup
[10:24:18] <arielby> ah, this function comes from the dark ages of alt
[10:26:01] *** Joins: laumann (thomas@moz-poa.3kq.109.2.IP)
[10:28:10] <aatch> arielby, oh wow. That is *OLD*
[10:28:30] <aatch> arielby, I'm pretty sure alt was gone when I join the Rust community.
[10:45:57] <doener> alt?
[10:47:26] <arielby> doener: before match
[10:47:31] <arielby> there was alt
[10:47:37] <doener> ah
[10:47:39] <arielby> and @dinosaurs roamed the earth
[10:48:28] <doener> I still witnessed those, but alt was way before my time
[10:48:32] <aatch> Once upon a time, pattern matching didn't have to be exhaustive.
[10:48:50] <aatch> Then you could opt-in, now you don't have a choice.
[10:49:06] <arielby> and "aliasable, mutable data" was the borrow-checker's complaint
[11:06:44] <eddyb> arielby: type_needs_unwind_cleanup is a favorite of mine
[11:06:57] <arielby> why does it exist?
[11:07:06] <eddyb> I keep stumbling on it and wanting to remove it
[11:07:12] <eddyb> trans::cleanup still uses for something
[11:07:56] <arielby> eddyb: it is the equivalent of type_needs_drop
[11:08:22] <arielby> hey, its not needed
[11:08:47] <arielby> I am going to remove it
[11:09:15] <arielby> eddyb: in the @old days it was different from type_needs_drop
[11:21:13] <eddyb> I know
[11:21:15] <eddyb> wait what
[11:21:22] <eddyb> arielby: it's not actually used?
[11:21:56] <eddyb> it was annoying me on every refactor but when I looked trans::cleanup did something depending on it
[11:25:06] <arielby> eddyb: its useless
[11:25:22] <arielby> it is the same as type_needs_drop
[11:25:24] <arielby> but less precise
[11:25:29] <arielby> and is called only when type_needs_drop
[11:25:37] <eddyb> ah, I missed that last part
[11:25:50] <eddyb> well, if nothing breaks, we'll look the other way
[11:26:09] <arielby> its supposed to always return true
[11:26:11] <arielby> *it should
[11:27:21] <arielby> actually, its broken
[11:27:42] <arielby> http://is.gd/e0SCVx
[11:28:11] <arielby> observe the lack of "Dropping"
[11:28:55] <aatch> arielby, ._.
[11:29:38] <aatch> arielby, I wonder if that's why my likely/unlikely branch keeps running into similar issues with destructors.
[11:30:39] <arielby> this occurs only on unwinding
[11:41:31] *** Quits: aatch (james@moz-is4j4r.cable.telstraclear.net) (Ping timeout: 121 seconds)
[14:19:26] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[14:24:54] *** Quits: arielby (Mibbit@moz-cmi.jfj.114.192.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:14:02] *** Quits: laumann (thomas@moz-poa.3kq.109.2.IP) (Ping timeout: 121 seconds)
[16:15:58] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[16:21:00] *** Joins: arielb1 (Ariel@moz-1sjtp8.red.bezeqint.net)
[16:32:32] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[17:39:54] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Connection closed)
[18:06:01] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[19:44:40] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[20:44:27] *** Joins: sigma (sigma@moz-l8bauc.range217-44.btcentralplus.com)
[20:51:21] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Quit: leaving)
[20:52:10] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[21:30:40] *** Quits: sigma (sigma@moz-l8bauc.range217-44.btcentralplus.com) (Connection closed)
[22:04:55] <huon> given code like `trait Foo { fn bar(&self) { something.bar(); } }` is it easy to answer the question "is the trait's Self the type of the receiver of the nested .bar() call?"
[22:05:18] <huon> (that is, is the call self-recursive?)
[22:08:04] <eddyb> huon: you mean, whether something.bar() is <Self as Foo>::bar(self)?
[22:09:11] <eddyb> that should be possible to verify, after typeck, by looking at the MethodCall associated with the `something.bar()` ExprMethodCall
[22:11:08] <eddyb> huon: I guess this would be an useful lint for all of those forwarding impls that do not deref enough or do not qualify the source of the method enough
[22:12:15] <eddyb> only caveat I can think of is that autoref might result in <&Self as Foo>::bar being used and that could be proxying back to <Self as Foo>::bar
[22:14:15] <huon> eddyb: I'm fixing the lint that we have for that already
[22:14:34] <huon> eddyb: I can't protect against proxying, yeah, it's just the <Self as Foo>::bar ones
[22:17:42] <huon> eddyb: MethodCallee.ty?
[22:18:53] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[22:28:55] <eddyb> huon: that's the type of the method. I *believe* you can just extract subt- no
[22:29:01] <eddyb> huon: let me look
[22:29:51] <eddyb> huon: MethodCallee's substs - check if they have a SelfSpace
[22:30:33] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[22:31:39] <eddyb> if that type .is_self() and the MethodCallee ty field is a TyFn(Some(this_method_def_id), _), then that's it
[22:32:01] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[22:34:12] <huon> so... .get_self().map_or(false, |t| ...)
[22:34:16] <huon> hm, what's a TyFn?
[22:34:26] <eddyb> TyBareFn, sorry
[22:35:01] <huon> oh, neat
[22:35:29] <eddyb> actually, the origin might be easier to use
[22:35:58] <eddyb> but I'm not sure what values that can take in practice
[22:36:28] <huon> I already use the origin
[22:37:17] <eddyb> it's going to be MethodStatic only for InherentImplPick
[22:38:05] <eddyb> which means you don't get a DefId to the method in other cases, so the TyBareFn DefId is the most direct path to a trait method call
[22:39:23] <huon> what thing has the type TyBareFn?
[22:39:32] <huon> oh, methodcallee.ty?
[22:40:26] <eddyb> yeah
[22:41:04] <eddyb> hahahaha what
[22:41:35] <eddyb> huon: trans uses method_num to get the DefId of a method from the trait
[22:41:48] <eddyb> so the DefId of the method should be stored instead of method_num, you would think
[22:41:59] <eddyb> but then that DefId is *only* used to get the name of the method
[22:48:13] <eddyb> nrc: trans::save::dump_csv code looks broken: it thinks ty::MethodStatic can refer to a trait impl
[22:49:11] <eddyb> nrc: nevermind, the variants just have odd names (ty::MethodTraitItem can refer to either an impl or a trait method)
[22:49:48] <nrc> didn't you make those names when you refactored trait/impl items? :-p
[22:51:40] <eddyb> nrc: I didn't touch middle::ty
[22:51:56] <eddyb> ast has MethodTraitItem and MethodImplItem
[22:52:03] <nrc> oh right, that was the ast ones
[22:52:15] <arielb1> nrc: we won't want MethodTraitOrImplItem
[22:52:17] <arielb1> *don't
[22:52:29] <eddyb> MethodTOII
[22:52:32] <eddyb> :P
[22:52:46] <nrc> MethodItem?
[22:52:57] <arielb1> nrc: then we would also have TypeItem
[22:53:03] <arielb1> and ConstItem
[22:53:11] <nrc> bleugh
[22:53:17] <eddyb> oh, great, comments in middle::ty don't reflect what the functions actually do
[22:53:27] <arielb1> e.g.?
[22:53:53] <eddyb> actually, they do, it's just subtle
[22:54:08] <arielb1> which ones?
[22:54:24] <eddyb> trait_item_of_item and trait_of_item
[22:54:40] <eddyb> they use "an implementation of a trait method" to speak about "a method in an impl of the trait"
[22:56:38] <arielb1> "either a default method or an implementation of a trait method"
[23:02:42] <huon> eddyb: thanks for your help
[23:03:17] <eddyb> I am going to whack method_num so that should let you use .origin, but I'm not sure how long it's going to take
[23:05:57] <eddyb> technically the ty field is redundant if you can get the DefId from any of the possible origins. although, MethodClosure is special
[23:07:42] <arielb1> eddyb: the ty field is important for other kinds of associated items
[23:07:46] <arielb1> it is not to be found in the tcx
[23:07:57] <eddyb> arielb1: MethodCallee's ty?
[23:08:03] <arielb1> wrong one
[23:08:23] <arielb1> ty of TraitItem is the important one
[23:08:32] <eddyb> yeah, I was talking about MethodCallee's
[23:10:28] <eddyb> huon: oh, you're already using method_num and you didn't touch that, I see what's going on
[23:11:20] <eddyb> huon: you should use TyBareFn for ExprCall though, so that you can catch let f = main; f();
[23:14:08] <jroesch> nrc: I already have another medium sized PR brewing can I get some feedback on it later today? or maybe tomorrow just trying to get this last piece compiling   
[23:16:06] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[23:58:07] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)

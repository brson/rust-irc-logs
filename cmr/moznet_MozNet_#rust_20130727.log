[00:00:02] <Eridius> cmr: only if libstd re-exports all of libcore..
[00:00:09] <strcat> xenocons: split_iter is a lazy stream though, and rust doesn't have first-class laziness
[00:00:23] <kyle2000> oh my gosh more changes to the layout of the libraries?!?! a poor fellow like me who is only an occasional ruster just can't keep up!
[00:00:24] <xenocons> ahh yeh
[00:02:14] *** Quits: tjc (tjc@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: zzzzzzzzzz)
[00:02:51] <kmc> xenocons: I don't really understand judging all of Boost as a unit; it's a huge collection of different libraries by different people
[00:03:00] <kmc> many of which are just headers you can copy into your project
[00:03:13] <kmc> so I think the size and complexity is pay-what-you-use to some degree
[00:03:22] <kmc> some of the Boost libs are fairly ridiculous though
[00:03:27] <strcat> the only real problem is that they write for C++98 as a baseline
[00:03:34] <xenocons> kmc: yes, my experience with it to date has mostly been: 'Dependency, libboost-all' or something and needing to get some giant codebase
[00:03:36] <strcat> and therefore they reinvent all the stdlib and a lot of the language
[00:03:36] <brson> cmr: i don't think it's possible without serious magic
[00:03:37] <xenocons> to compile something tiny
[00:03:44] <kmc> yeah
[00:04:44] <brson> cmr: primarily because of interdependencies between the segmented stack prologue and the runtime
[00:04:46] <Klaufir_> what should I use for GUI programming in Rust?
[00:04:49] <brson> also logging interdeps
[00:05:15] <cmr> Klaufir_: there is nothing atm
[00:05:24] <cmr> Klaufir_: well, maybe grust (https://github.com/mzabaluev/grust)
[00:05:57] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:06:07] <doomlord> cn rust use c++ gui libraries through swig?
[00:06:25] <cmr> doomlord: it could use C bindings I think, sure.
[00:06:26] <brson> cmr: my current thinking is to partition std into 'profiles' for different purposes
[00:06:31] <brson> using cfg
[00:06:34] <kyle2000> does anyone know how the work on the new io library is going?
[00:06:38] <cmr> brson: Ok, that'd probably be ideal.
[00:06:44] <cmr> brson: And better than splitting it into multiple.
[00:06:58] *** Quits: yonran (yonran@moz-962F33EB.acuitus.com) (Ping timeout)
[00:06:59] <doomlord> i've been writing a C++ binding generator (filling in shims both sides), however i haven't tried it with a complex gui library yet..
[00:06:59] <aatch> Hah, awesome. I can start a process, then immediately raise SIGSTOP to suspend it while the parent process does stuff that needs it's PID
[00:07:26] <cmr> doomlord: I imagine any GUI library would be rather complex and lean heavily upon templates and inheritance and such?
[00:07:33] <bblum> aatch: that sounds race-prone
[00:07:34] <doomlord> i dont handle as much as swig by a long way
[00:07:42] <brson> cmr: I did want to create a std/rt split (in the opposite layering as rustrt/core) for a while, but it's pretty difficult
[00:07:58] <brson> actually probably core/rt/std, with std reexporting from both core/rt
[00:08:00] <bblum> brson: ok, don't actually approve my select PR yet; i added another test and am tracking down a bug it exposes
[00:08:07] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[00:08:09] <bblum> but feel free to review it before i fix it on monday :P
[00:08:22] <doomlord> i've been able to get a representation of templated colllection classes acors, i'm confident i can get enough working to use *my own* c++  code from rust, because i can re-work it..
[00:08:46] <steven_is_false> Currently there is no support for static, and global synchronization primitives. What should I do?
[00:08:50] <doomlord> but yes how to represent overloading..
[00:09:01] <brson> bblum: ok. it's going to take me time to digest the subtleties here anyway. looks nice
[00:09:07] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[00:09:12] <Klaufir_> cmr: so to wrap c++ code, I would have to write a c interface and then use that interface from rust
[00:09:18] <cmr> lahwran: yes.
[00:09:22] <cmr> erm, Klaufir_ yes
[00:09:22] <bblum> brson: thanks, i'm pretty proud of how concise the external iterators make select() itself
[00:09:37] <bblum> brson: but i should not speak too soon because something is wrong with it :P
[00:09:40] * bblum ->
[00:09:43] <aatch> bblum, probably. Thinking about it, I should probably use waitpid instead.
[00:10:01] <doomlord> if swig generates naming conventions for the c++ stuff, maybe you can work backwards from those to make impls' to make the calls look more like the original
[00:10:02] <strcat> aatch: I think waitpid is basically deprecated ;p
[00:10:06] <bblum> aatch: if you just need the PID, fork returns it to you directly
[00:10:28] <bjz> doomlord: yes, overloading would be a pain for C++ bindings
[00:11:14] <aatch> bblum, yeah, but I need to set stuff up that needs the PID, and the child shouldn't start properly until that's done.
[00:11:22] <bblum> brson: in particular, i am adding a cfg(test) version of optimistic_check() that randomly returns false, to compensate for the difficulty of getting asynchronous sends to race around that point
[00:11:36] <strcat> aatch: use a pipe
[00:11:40] <strcat> aatch: signals are inherently racy
[00:11:54] <bblum> what strcat said, yes
[00:11:56] * bblum -> for real
[00:12:12] <aatch> strcat, oh true. I forgot about pipes.
[00:12:16] <cmr> dbaupp: ping
[00:12:32] <doomlord> i thought perhaps i could put all the arguments into a tuple , and call it that way? foo(a,b,c,d) --->  (a,b,c,d).foo()     trait Foo{foo(&self)} impl Foo for (A,B,C,D) { foo(&self){ let (a,b,c,d)=self; foo_A_B_C_D(a,b,c,d);}...
[00:12:48] <bjz> doomlord: yeah I was trying that
[00:12:48] <kyle2000> i keep getting so excited about the new runtime library and the new io. does anyone know how it is progressing?
[00:12:59] <steven_is_false> Can someone give me an r+ for https://github.com/mozilla/rust/pull/7978 (, or feedback if you think it's still not good enough obviously?)
[00:13:00] <cmr> kyle2000: it's progressing quite well afaict
[00:13:10] <graydon> kyle2000: someone needs to take up files, imo.
[00:13:17] <bjz> doomlord: (x, y, vec2).to_vec4()
[00:13:18] <cmr> kyle2000: see http://hg.chrismorgan.info/rusthttpserver/ for an HTTP server using it
[00:13:21] <graydon> networking is working somewhat; files are not-really-started
[00:13:38] <doomlord> nice
[00:13:40] <bjz> doomlord: unfortunately the tuple impls conflict
[00:13:43] <kyle2000> well i am happy to hear that there is some progress then! that is goodest news.
[00:13:47] <doomlord> ahhh.
[00:13:51] <bjz> doomlord: :(
[00:14:06] <doomlord> tuple-struct somewhere perhaps ?
[00:14:42] <bjz> doomlord: no, as in for all the variants
[00:15:31] <bjz> impling traits on tuples causes ambiguities in the current system
[00:15:50] <doomlord> i thought about making a custom name-mangling scheme, making a guess at a 'default' from all the overloads, and adding abreviated trailing type prefixes for differences to the default
[00:16:21] <doomlord> but that will change if the source API changes.. (which is the default?)
[00:16:31] <bjz> heh
[00:16:34] *** Quits: kyle2000 (kyle2000@6EDB4D7A.341FCD98.3031298E.IP) (Quit: Leaving)
[00:16:36] <bjz> yikes
[00:16:37] *** Quits: eholk (eholk@moz-E654C98C.uconnect.utah.edu) (Quit: eholk)
[00:17:26] <doomlord> starting with number of args as a numerical postfix might not be so bad (.. then its just a case of picking a 'default' per arg-count..)
[00:17:26] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:17:33] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[00:17:51] *** Quits: mschifer (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:20:09] <bjz> doomlord: I guess it's usually the case that you'd make an ideomatic wrapper for C++ apis
[00:20:36] <bjz> doomlord: C ones are easier to use out of the box
[00:21:10] <doomlord> yes i can see that. itss funny how a 3d engine is easier than gui :)
[00:21:36] <bjz> hm?
[00:21:41] <bjz> :P
[00:22:19] <Klaufir_> sorry for the noob question, but I don't know which MingW version to use with the windows version of rust
[00:22:42] *** Joins: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com)
[00:23:40] <bjz> Klaufir_: that's not a noob question
[00:23:41] <pcwalton> aaaaargh
[00:23:46] * pcwalton wants to rm lint.rs
[00:23:50] <bjz> Klaufir_: it baffles the best of us
[00:24:07] <bjz> pcwalton: hum?
[00:24:16] <pcwalton> it's very confusing code
[00:24:21] <bjz> oh
[00:24:40] <bjz> so just nuke the current one
[00:25:02] <bjz> (are you saying?)
[00:25:09] <dbaupp> cmr: pong
[00:25:12] <bjz> (not getting rid of lint)
[00:25:17] <bjz> (entirely)
[00:25:20] <bjz> (bleh)
[00:25:29] <aatch> (parentheses)
[00:25:31] <dbaupp> pcwalton: I looked at your trait visitor, and it seems that you weren't using default methods?
[00:25:43] <pcwalton> dbaupp: I wasn't because I don't know if they work
[00:25:43] * dbaupp renames this channel to #lisp
[00:25:45] <cmr> dbaupp: https://gist.github.com/cmr/1fc40c054d5110da61f9
[00:26:15] <bjz> (aatch (, yes (that is what they are)))
[00:26:24] <dbaupp> pcwalton: they should be pretty stable now (at least, after the next snap lands), sully says he knows of no more bugs with them
[00:26:31] <pcwalton> even for @Trait?
[00:26:35] <pcwalton> and we need the snap
[00:26:50] <dbaupp> oh, yeah, you're using trait objects.
[00:26:57] * dbaupp doesn't know about them
[00:27:04] *** Quits: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP) (Quit: Leaving.)
[00:27:06] <sully> oh, well, hm
[00:27:14] <sully> I think they work for trait objects.
[00:27:25] <dbaupp> (fwiw, it seems possible to do it without trait objects.)
[00:28:12] <dbaupp> cmr: I'm pretty sure that's "just" general badness with auto-deref :(
[00:28:26] <sully> oh man, I remember, back in the day
[00:28:31] <sully> when autoderef was really agressive
[00:28:33] <sully> and you could do things like
[00:28:38] <sully> @@@@@@4 + @@@2
[00:28:40] <sully> and get 6
[00:29:05] <dbaupp> cmr: although, I don't know why it's specific to Total{Ord,Eq}, even though, e.g. Clone does a similar thing
[00:29:10] *** Quits: devinus (devinus@DAEC7122.372FE49C.29F95E0F.IP) (Quit: Computer has gone to sleep.)
[00:29:19] <dbaupp> sully: that's awesome.
[00:29:33] <sully> I think I got rid of that my first summer
[00:29:58] <sully> back in the days when interns could make breaking language changes without anybody noticing :P
[00:30:15] <dbaupp> making it so it's controlable would be nice (or at least disableable)
[00:30:41] <cmr> I don't even understand autoderef *now*
[00:31:51] <cmr> Is there anyone interested in taking the helm on rustdoc_ng?
[00:32:08] <bjz> sully: from personal experience? :P
[00:35:33] <strcat> cmr: this is the only thing I really run into...
[00:35:46] <strcat> rusti: let x = &5; let y = x.clone(); *y
[00:35:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EYUc
[00:35:54] <strcat> rusti: let x = &5i; let y = x.clone(); *y
[00:35:55] -rusti- <anon>:7:41: 7:43 error: type int cannot be dereferenced
[00:35:55] -rusti- <anon>:7          let x = &5i; let y = x.clone(); *y
[00:35:55] -rusti-                                                   ^~
[00:35:55] -rusti- error: aborting due to previous error
[00:35:55] -rusti- application terminated with error code 101
[00:36:00] <strcat> rusti: let x = &5i; let y = (&x).clone(); *y
[00:36:01] -rusti- 5
[00:36:14] <strcat> rusti: let x = 5i; let y = (&x).clone(); y
[00:36:15] -rusti- 5
[00:36:18] <strcat> rusti: let x = 5i; let y = (& &x).clone(); y
[00:36:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HiDf
[00:36:22] <strcat> rusti: let x = 5i; let y = (& &x).clone(); *y
[00:36:23] -rusti- 5
[00:36:29] <strcat> auto-deref is kinda weird
[00:36:38] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[00:36:42] <aatch> man C stuff hard to work with sometimes.
[00:36:58] <pcwalton> we need to reform autoderef on methods
[00:37:05] <pcwalton> it's blocked by lack of dynamically sized types
[00:37:06] <aatch> but I know have pipe(2)
[00:38:00] <strcat> signals are the worst thing ever
[00:38:05] <kmc> yes
[00:38:14] <aatch> strcat, agreed.
[00:38:18] <kmc> pretty much everything in UNIX that isn't represented by a file descriptor is a disaster
[00:38:25] <strcat> well, linux has signalfd
[00:38:27] <strcat> so signals are files
[00:38:29] <strcat> but they're still awful
[00:38:30] <kmc> yep signals would be better if they worked like signalfd
[00:38:32] <cmr> kmc: yes
[00:38:34] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[00:38:40] <strcat> kmc: still pretty racy and painful though
[00:38:50] <strcat> just avoid the awful switch to some signal handling land
[00:39:07] <cmr> sem_timedwait is my personal pet peeve
[00:39:15] <cmr> and by 'pet peeve' I mean 'drives me stark-raving mad'
[00:39:36] <strcat> every little utility I try to make using signals ends up with an incomprehensible epoll/signalfd loop ;p
[00:39:49] <strcat> much better than incomprehensible signal handler hacks I guess
[00:40:21] <strcat> aatch: https://github.com/thestinger/playpen/blob/master/playpen.cc#L451 the heart of rusti ;p
[00:41:07] <strcat> since it has to time out...
[00:41:40] <olsonjeffery> brson: ping
[00:42:54] <strcat> luckily it doesn't have to free any resources ;p
[00:42:59] <strcat> just happily leaks
[00:43:13] <strcat> it doesn't have permission to call munmap before exec anyway
[00:43:34] <brson> olsonjeffery: pong
[00:45:57] <cmr> bjz: ping
[00:46:05] <bjz> cmr: pong
[00:46:08] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[00:46:17] <cmr> What are the current limitations for loading an extern fn at runtime?
[00:46:21] <cmr> Is it just extern "C" that is broken?
[00:46:32] <cmr> (this is related to 6661 I think)
[00:46:45] <cmr> reason: implementing dynamic-library plugin system for rustdoc_ng as semi-proof-of-concept
[00:46:59] <bjz> cmr: you need to talk to nmatsakis for the details
[00:47:04] <cmr> nmatsakis: ping
[00:47:22] <bjz> cmr: extern "C" fns are actually *u8s atm
[00:47:31] <bjz> (I think)
[00:47:36] *** kimundi is now known as zz_kimundi
[00:48:29] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[00:49:26] *** Joins: alisdair (textual@F511297F.DC0F4EDA.115CE8E4.IP)
[00:49:42] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:49:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148ac860f to 1444808fc: 02http://git.io/N3iJvQ
[00:49:42] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:50:04] *** Joins: alicedare (textual@1E3F14AE.29819A33.115CE8E4.IP)
[00:50:32] <dbaupp> cmr: fwiw, I think I know why it fails for Total* only: they don't have impls for ~T or @T.
[00:51:07] *** Quits: alisdair (textual@F511297F.DC0F4EDA.115CE8E4.IP) (Ping timeout)
[00:55:11] <strcat> hm, Writer uses u8
[00:55:43] <strcat> maybe we do need an output "iterator"
[00:56:02] <strcat> it could be a specific type of that
[00:56:12] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[00:56:21] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[00:56:28] <olsonjeffery> brson: do you have time to talk about, for lack of a better term, std::rt::io::future ?
[00:56:44] <engla> I think there should be a StringWriter that only accepts str and char input. It would be useful for both Json and ToStr
[00:57:00] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:57:28] <strcat> engla: yeah that makes sense
[00:57:32] <brson> olsonjeffery: yes, a little
[00:57:48] <dbaupp> cmr: is the bencher in time-machine-only mode?
[00:58:05] <ChrisMorgan> \o/ Rebooted another time (several updates and package fixing things) and now HTTP server perf is up again: it had been 2,400 rps, had gone down to 800 mysteriously, now it's almost 3,500! (No, I didn't rebuild Rust in the mean time.)
[00:58:06] <strcat> engla: I'm thinking we need Writer<T>, or at least a set of traits
[00:58:15] <brson> olsonjeffery: i have some things i'd like to discuss with you re: async i/o too
[00:58:27] <olsonjeffery> brson: yes. i want to talk about future in the context of that
[00:58:35] <cmr> dbaupp: it's just building right now, not benching. I'll turn on benching when I go to bed and whent he machine is otherwise idle, to have noise-free benchmarks.
[00:58:38] <olsonjeffery> i was *this* close to making it to portland, too :/
[00:58:45] <olsonjeffery> then got caught up at work and now traffic is horrible
[00:58:56] <dbaupp> cmr: oh, that's an awesome idea.
[00:59:11] <olsonjeffery> brson: anyways.. i wanted to talk about futures in the context of the async api.
[00:59:11] <cmr> dbaupp: it's archiving all the builds too
[00:59:17] <brson> olsonjeffery: I actually, don't have much time :-S
[00:59:25] <strcat> engla: I mostly just want a generic way to append to strings/vectors + reserve space ;p
[00:59:43] <olsonjeffery> bummer. hm. well then maybe next week. otherwise i'll be hanging about this weekend, here and there.
[00:59:49] <brson> olsonjeffery: how is it going so far?
[01:00:07] <olsonjeffery> brson: ive just been digging into std::rt and trying to grasp the potential
[01:00:23] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[01:00:25] <olsonjeffery> i imagine a sort of low level, "no batteries included" approach to a future that couples with rt::io
[01:00:45] <olsonjeffery> that async impls of TcpStream, etc could use to put together a future value that integrates with the scheduler
[01:00:48] <engla> strcat: I haven't thought about that. I think a String Writer is kind of orthogonal to Writer<T>
[01:01:11] <strcat> engla: strings could just accept Writer<char> and Writer<&str> though
[01:01:20] <olsonjeffery> but the details are fuzzy. but the way you can do reentrant functions/coroutines w/ the scheduler seems really powerful
[01:01:27] <strcat> engla: er, I mean they'd be those
[01:01:28] <olsonjeffery> and we can do better than just msg sends. does this sound crazy?
[01:02:00] <pcwalton> ChrisMorgan: are those good numbers?
[01:02:10] *** Quits: mye (mye@moz-FFDA3A47.dip0.t-ipconnect.de) (Quit: mye)
[01:02:11] <engla> I understand
[01:02:26] <bstrie> ChrisMorgan: 3500 rps, but what sort of requests?
[01:03:04] <ChrisMorgan> bstrie: very simple one, http://hg.chrismorgan.info/rusthttpserver/file/a889c24b3f84/src/examples/apache_fake.rs
[01:03:20] <pcwalton> hmmm
[01:03:24] <pcwalton> we should be at like 500,000
[01:03:35] <pcwalton> http://lowlatencyweb.wordpress.com/2012/03/20/500000-requestssec-modern-http-servers-are-fast/
[01:03:58] <ChrisMorgan> That's with `ab`, known to be fairly poor at benchmarking such things, and with a concurrency level of 1.
[01:04:53] <ChrisMorgan> A trivial Go server doing basically the same stuff is hitting just over 3,600.
[01:04:53] <brson> ChrisMorgan: i'm glad you're benchmarking
[01:05:32] <ChrisMorgan> Alas, my benchmarks are very rudimentary. I need to formalise them and run them from Go.
[01:05:45] *** Quits: pcwalton (pcwalton@moz-F35A8539.hsd1.or.comcast.net) (Quit: pcwalton)
[01:05:58] <ChrisMorgan> One problem I've experienced with the Rust stuff is that with concurrency > 1 it will segfault sometimes. Rare, but rather undesirable.
[01:06:15] <brson> ChrisMorgan: yes, it's not correct with multithreading yet
[01:06:21] <ChrisMorgan> I gathered as much!
[01:07:25] *** Quits: brendan (brendaneic@moz-BBE3ABD.mv.mozilla.com) (Quit: brendan)
[01:07:31] <ChrisMorgan> My HTTP code is also not _really_ well tuned yet. It's not at all bad code, but there's significant scope for improvement.
[01:07:48] <cmr> ChrisMorgan: is it correcet/compliant?
[01:07:50] <brson> ChrisMorgan: have to go now, but I'm interested in your results. node is also something we want to compare with since we're using their backend. if you can come up with some tests we can benchmark I imagine there's a *lot* of low hanging fruit we can start picking off
[01:08:02] *** Quits: brson (brson@C0559334.C30B3942.8DDCAE07.IP) (Quit: leaving)
[01:08:11] <dbaupp> ChrisMorgan: is that using the buffered wrappers?
[01:08:21] <ChrisMorgan> dbaupp: yes
[01:08:47] <ChrisMorgan> cmr: I haven't implemented connection keep-alive yet, but it's comparatively compliant at the fundamental level. Certainly not fully HTTP/1.1 compliant, though.
[01:09:15] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:09:28] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[01:10:23] <bstrie> hm, typo on the rust job page
[01:10:28] <bstrie> "Rust is rapidly progressing towards being production readiness"
[01:11:10] *** Quits: lkuper (lkuper@E0D3ECD7.A402E718.C082B7DC.IP) (Quit: lkuper)
[01:14:08] <ChrisMorgan> Just realisedâ€”I was making a mistake in my Go test (requesting a 404 page rather than the right 200 page). Real rate is only 3,000â€”Rust wins!
[01:15:05] <ChrisMorgan> Node example gets 3,200â€”Rust wins!
[01:15:22] <cmr> ChrisMorgan: ok, node actually has a mostly-correct implementation though
[01:15:23] <dbaupp> ChrisMorgan: is GCCGo faster?
[01:15:41] <ChrisMorgan> Not sure, I just used `go run` with whatever I had, which I presume will be 6g.
[01:16:16] <ChrisMorgan> cmr: yeah, I know, but there's actually very little that will slow it down much to be added
[01:16:26] <cmr> ChrisMorgan: chunked encoding?
[01:16:28] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[01:17:00] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[01:17:20] <ChrisMorgan> cmr: this example doesn't use chunked encoding
[01:17:24] <cmr> ok
[01:17:26] <cmr> cool, then!
[01:18:09] <ChrisMorgan> You're right, though; my code doesn't yet support chunked encoding.
[01:18:09] <cmr> rusti: Path("~/foo").normalize()
[01:18:13] -rusti- {is_absolute: false, components: ~[~"~", ~"foo"]}
[01:19:26] <kmc> ~[~"~"  the joys of rust
[01:24:34] *** Joins: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP)
[01:25:09] <paupau> just curious, did a decision ever get reached on segmented stacks?
[01:25:30] <cmr> paupau: afaik the discussion ended at "we just need a way to make them optional"
[01:25:55] <aatch> In the choice between "on" and "off", we picked "yes"
[01:26:06] <paupau> I guess it's pretty hairy huh
[01:26:35] <kmc> I think people pretty much agree that they aren't needed on 64-bit, at least
[01:27:26] <ChrisMorgan> Rust server is faster than Node and Go at concurrency of 1, but slower at 2 and 3 (quite apart from typically crashing within a few thousand requests)
[01:31:42] <ChrisMorgan> With performance back up, request parsing is back up to 47% of the elapsed time. And that's good, because that's a place I *know* can be optimised.
[01:32:00] <cmr> afaik the new runtime isn't exactly optimized either
[01:32:47] *** Quits: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP) (Ping timeout)
[01:33:11] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[01:35:20] *** Quits: alicedare (textual@1E3F14AE.29819A33.115CE8E4.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:38:14] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[01:40:14] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:42:54] <bstrie> ChrisMorgan: have you tried running this with the new runtime?
[01:43:05] <ChrisMorgan> bstrie: it'll only run with the new runtime.
[01:43:12] <cmr> bstrie: you are very behind the curve :P
[01:43:17] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[01:43:48] * ChrisMorgan is pleased that performance is as good as it is given the unoptimised state of various things
[01:44:23] <ChrisMorgan> There, added the performance comparisons to the repositoryâ€”http://hg.chrismorgan.info/rusthttpserver/rev/58ab0568beb6
[01:45:03] <toddaaro> is there a good blog post somewhere to read on how to implement destructors?
[01:45:18] <cmr> toddaaro: no but I would appreciate one
[01:45:26] <cmr> I have no idea what the responsibilities of the destructor are
[01:45:48] <toddaaro> I just wrote my first and it triggers twice on one destruct
[01:45:52] <toddaaro> so apparently I did it wrong
[01:46:29] * ChrisMorgan implemented his first destructor yesterday, found an ICE and had to remove the destructor after all
[01:46:36] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[01:51:06] <toddaaro> apparently you can infinite loop destructors really easily too
[01:51:53] *** Quits: heftig (heftig@6835D69C.6FC4DE2F.FEC4A986.IP) (Quit: Quitting)
[01:52:19] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[01:53:50] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:54:12] <engla> sully: found a def method bug https://github.com/mozilla/rust/issues/8068
[01:57:02] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[01:57:52] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[02:00:51] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[02:02:04] <xenocons> strcat: pstr=strtok(str, " "); while (pstr) { f(pstr); strtok(NULL," "); } // hillarious
[02:03:11] *** Joins: jclements (jclements@moz-3024F22B.port.east.myfairpoint.net)
[02:04:56] <Klaufir_> should I worry about my stack blowing up when using recursing in Rust?
[02:05:01] <cmr> Klaufir_: no
[02:05:17] <cmr> the task will safely abort before hitting the stack limit
[02:06:03] <ChrisMorgan> Just don't ever try using fmt! on a cyclic structure like I did yesterday.
[02:06:22] <Klaufir_> I see, can rust do tail call optimization?
[02:06:36] <cmr> Not always. It can do sibling call optimization iirc
[02:07:16] <strcat> it will always do sibling call optimization with internal functions
[02:07:31] <strcat> since rust uses cdecl and not fastcc as the external ABI, it's restricted to internal ones
[02:07:43] <strcat> although it could be clever and hoist the body out, but I don't think it will
[02:08:15] <strcat> we should probably use fastcc again.
[02:09:17] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[02:11:19] *** Joins: lkuper (lkuper@3AE931C6.A402E718.C082B7DC.IP)
[02:11:59] <Klaufir_> I don't really understand why cdecl would restrict sibling call optimizations to internal functions
[02:12:15] *** Joins: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP)
[02:12:56] <doomrobo> hello peoplez
[02:13:15] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[02:14:12] <doomrobo> how do I declare a file-wide global variable? I'm getting an error "expected item, got `let`". I might be doing something else wrong
[02:14:21] <Klaufir_> "LLVM requires the fastcc convention to implement tail calls" I see
[02:14:25] <cmr> doomrobo: there is no such thing.
[02:14:30] <strcat> fastcc might not be required for sibling call opt
[02:14:32] <strcat> Klaufir_: ^
[02:14:34] <strcat> not sure
[02:14:47] <strcat> it might only be needed to do TCO when the signatures aren't matching
[02:14:54] <dbaupp> doomrobo: `static`
[02:14:58] <ChrisMorgan> doomrobo: reconsider your requirements. You don't need a global variable.
[02:15:04] <dbaupp> rusti: static x: uint = 1; x
[02:15:04] -rusti- 1
[02:15:08] <cmr> doomrobo: it's module local, not file local, though.
[02:15:14] <dbaupp> (although that's an immutable constant.)
[02:17:11] <doomrobo> cmr what if I'm not declaring a module in my file?
[02:17:26] <doomrobo> dbaupp and can I make it mut?
[02:17:27] <cmr> doomrobo: files are implicitly a module
[02:17:32] <doomrobo> oh, ok
[02:17:34] <cmr> `static mut` exists but it's unsafe code.
[02:17:50] <dbaupp> doomrobo: yes, but as ChrisMorgan says: you (probably) don't need a global variable.
[02:17:54] <doomrobo> also, when do you guys sleep? I've been here at all times of the day and you're always here
[02:18:01] <doomrobo> ok, I'll do it another way
[02:18:09] *** Quits: jclements (jclements@moz-3024F22B.port.east.myfairpoint.net) (Ping timeout)
[02:18:12] <cmr> doomrobo: geographic distribution!
[02:18:19] <aatch> doomrobo, well it's 2:30pm here, so It'd be strange if I was asleep
[02:18:29] <dbaupp> doomrobo: normal times :P
[02:18:31] <ChrisMorgan> i.e. there's a reason `static mut` is unsafe
[02:18:37] *** Joins: jclements (jclements@moz-72D93F6A.ptldme.east.myfairpoint.net)
[02:19:21] <doomrobo> cmr dbaupp no I mean I was here from 14:00-16:00, 21:00-6:30 and maybe another time range
[02:19:31] <ChrisMorgan> As it happens, aatch is NZ, dbaupp and I are eastern AU
[02:19:32] <dbaupp> doomrobo: what timezone?
[02:19:44] <doomrobo> I'm on Pacific time
[02:19:52] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[02:20:02] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[02:20:03] <dbaupp> US, right?
[02:20:08] <doomrobo> yup
[02:20:10] *** Quits: henrikhodne (henrikhodn@moz-87E975F1.dsl.static.sonic.net) (Ping timeout)
[02:20:16] *** Quits: Ralith (ralith@moz-93655DD2.wireless.sfu.ca) (Ping timeout)
[02:20:17] <aatch> No, I'm on Pacific Time, 'Pacific/Auckland' :O
[02:20:19] <aatch> :P*
[02:20:28] <doomrobo> PST
[02:20:35] <engla> hehe the pacific spans a date line and a lot of timezones
[02:20:41] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:20:43] <doomrobo> yeah, my bad :P
[02:21:59] <doomrobo> dbaupp I have a lookup table that needs to be initialized at the beginning of the application but doesn't change after that. There is a particular function that needs acess to it. Where do I put it?
[02:23:28] <dbaupp> doomrobo: well, yeah, if you're on during your night, then you'll be seeing all us oceania people a lot.
[02:23:47] <doomrobo> but I'm on from mid-afternoon to early morning
[02:23:54] <doomrobo> it just seems like you guys sleep even less than me :P
[02:24:04] <dbaupp> doomrobo: there's not really a good solution for that other than putting it in task local storage, or passing it around explicitly
[02:24:19] <doomrobo> task local storage?
[02:25:05] <dbaupp> yeah... NZ/AU's night is the morning/midday in the US, so we're not-sleeping during the US's afternoon/night.
[02:25:07] <doomrobo> when you say "good solution" do you mean it as "I understand that it's a problem that needs fixing" or do you mean "your design is the thing that needs fixing"?
[02:25:18] *** Quits: jclements (jclements@moz-72D93F6A.ptldme.east.myfairpoint.net) (Ping timeout)
[02:25:28] <cmr> `static mut` is as good a solution as any
[02:25:33] <dbaupp> http://static.rust-lang.org/doc/std/local_data.html
[02:25:36] <cmr> but I'd wrap its access into a safe function
[02:25:44] <cmr> TLS is only relevant if you do all your stuff in one task
[02:25:53] <dbaupp> doomrobo: I mean that Rust doesn't really have a decent way of doing it yet (that I know of.)
[02:26:03] <doomrobo> ok
[02:26:23] <doomrobo> cmr how do I wrap access to make it safe? Mutex?
[02:26:31] *** Joins: jclements (jclements@moz-C45FF481.ngn.east.myfairpoint.net)
[02:26:38] <ChrisMorgan> "Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic." Delightful.
[02:26:43] <cmr> doomrobo: if it's never mutated except at program start, you don't need to worry about it
[02:26:54] <cmr> doomrobo: but you'd use an... ARC object I think
[02:26:58] <cmr> (in other circumstances)
[02:27:18] <doomrobo> yeah, I wasn't planning on actually wrapping it. I was just curious
[02:27:48] <cmr> http://static.rust-lang.org/doc/extra/arc.html
[02:28:38] *** Quits: jclements (jclements@moz-C45FF481.ngn.east.myfairpoint.net) (Quit: jclements)
[02:28:39] <cmr> arc uses `static mut` (or some other equivalent) behind the scenes I think
[02:29:04] <strcat> write_once is a safe pattern you could do without a lock
[02:29:10] <strcat> some_thing + a bool
[02:29:25] * strcat shrugs ;p
[02:29:54] <doomrobo> strcat do you have a link to it?
[02:30:07] <strcat> no I just mean it's something you could write in unsafe code with a safe API
[02:30:17] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:30:21] <doomrobo> oh, ok
[02:30:28] <strcat> you only need a lock of some sort for the first (only) write
[02:31:23] <dbaupp> rusti: static mut x: uint = 0; let y: &'static mut uint = &mut x; *y = 1;
[02:31:23] -rusti- <anon>:7:65: 7:66 error: use of mutable static requires unsafe function or block
[02:31:23] -rusti- <anon>:7          static mut x: uint = 0; let y: &'static mut uint = &mut x; *y = 1;
[02:31:24] -rusti-                                                                           ^
[02:31:24] -rusti- error: aborting due to previous error
[02:31:24] -rusti- application terminated with error code 101
[02:31:34] <dbaupp> rusti: static mut x: uint = 0; let y: &'static mut uint = unsafe {&mut x}; *y = 1;
[02:31:35] -rusti- ()
[02:34:42] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:34:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/4Il81Q
[02:34:42] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:37:20] <doomrobo> rustc is telling me "illegal anonymous lifetime" when I declare something of the type HashMap<~str, @MyEnumType>. It errors on the shared pointer
[02:37:42] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:37:42] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/ATjpiA
[02:37:42] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:37:44] <engla> do you mean &MyEnumType?
[02:37:45] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[02:37:45] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/f48WQA
[02:37:45] <ghrust> 13rust/06auto 148582fde 15Michael Sullivan: Improve the camel case warning a bit.
[02:37:45] <ghrust> 13rust/06auto 14f5721c9 15Michael Sullivan: Eliminate unused variable warnings.
[02:37:45] <ghrust> 13rust/06auto 1420c46fa 15Michael Sullivan: Register snapshots.
[02:37:46] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[02:38:21] <doomrobo> engla that's the weird part. It's @
[02:39:13] <engla> for @T, you need the bound  T: 'static  now, it's a recent change
[02:39:26] <engla> not sure what the error messages around that look like
[02:39:33] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[02:40:26] <tautologico> so are the numeric traits working now?
[02:40:27] <doomrobo> it says "requires 'static" for my exchange pointers, but not my shared pointers :/
[02:40:41] <cmr> tautologico: which?
[02:40:50] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:41:06] <Klaufir_> rusti: for i16::range(0,10) |i| { print(fmt!("%?",i)) }
[02:41:07] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FGaA
[02:41:23] <ChrisMorgan> Hmm... it's not just my rust web server which has magically sped up, it's _everything_. I have something which converts 33 pages of HTML to PDF and instead of taking five-ten seconds it takes scarcely one. Wonder what made that happen.
[02:41:52] <cmr> ChrisMorgan: your box sounds like it's in a horrific superposition of broken
[02:42:01] <dbaupp> rusti: for std::i16::range(0,10) |i| { print(fmt!("%?",i)) } // Klaufir_
[02:42:02] -rusti- 0123456789()
[02:42:12] <ChrisMorgan> cmr: an interesting way of putting it. Does that make it a quantum computer?
[02:42:36] <dbaupp> doomrobo: what do you mean by "exchange pointers", ~ right?
[02:42:42] <tautologico> cmr: operator overloading and stuff related to numbers, last time I checked a few months ago it seemed things were not right there
[02:42:55] <Klaufir_> why the nil at the end?
[02:42:56] <doomrobo> dbaupp yeah, what's the accepted terminology?
[02:43:21] <cmr> Klaufir_: didn't print a newline, and rusti prints the result of the things you give it
[02:43:25] <dbaupp> doomrobo: they're normally called owned or just ~, I guess. (but exchange is understood.)
[02:45:47] <dbaupp> rusti: for std::i16::range(0,2) |i| { print(fmt!("%?",i)) } "foo"
[02:45:48] -rusti- 01"foo"
[02:45:52] <Klaufir_> thanks
[02:46:12] <Klaufir_> so, nil is just the value of the whole expression
[02:46:38] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:46:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149300979 to 145c4cd30: 02http://git.io/N3iJvQ
[02:46:38] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:46:39] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[02:46:40] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/PXltpw
[02:46:40] <ghrust> 13rust/06auto 147fd23e4 15Alex Crichton: Convert uses of transmute which don't need it
[02:46:40] <ghrust> 13rust/06auto 145aaaca0 15Alex Crichton: Consolidate raw representations of rust values...
[02:46:40] <ghrust> 13rust/06auto 144989799 15bors: auto merge of #7986 : alexcrichton/rust/raw-repr, r=brson...
[02:46:42] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[02:47:06] <dbaupp> Klaufir_: yeah
[02:47:47] <doomrobo> Alright, here's my code. I'm getting a lot a "Illegal anonymous lifetime" issues. https://gist.github.com/doomrobo/83b5704fa6563b834cc8
[02:48:22] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[02:50:27] <dbaupp> doomrobo: the easiest solution is to not use a Rust function for `Function`
[02:50:39] <doomrobo> what should I use?
[02:50:48] <dbaupp> just have it all pure lisp.
[02:50:56] <dbaupp> but I guess you need intrinsics.
[02:50:56] <cmr> doomrobo: fwiw it might be worth looking at the prior art for inspiration: https://github.com/bjz/rusp
[02:51:05] <doomrobo> SHIT
[02:51:17] *** Joins: jclements (jclements@moz-E7102064.ptldme.east.myfairpoint.net)
[02:51:30] <engla> doomrobo: Function(&fn  this needs a lifetime
[02:52:00] <dbaupp> doomrobo: assuming none of your intrinsics need to be closures, you can just use `extern fn() -> ...` so you use normal functions defined with `fn`, rather than closures defined with `|...|`
[02:52:16] *** Quits: zz_kimundi (kimundi@moz-320FAC37.dip0.t-ipconnect.de) (Ping timeout)
[02:52:26] <doomrobo> yeah, that would work
[02:52:54] <dbaupp> rusti: use std::hashmap::*; static mut foo: HashMap = HashMap::new();
[02:52:54] -rusti- <anon>:7:46: 7:54 error: wrong number of type arguments: expected 2 but found 0
[02:52:54] -rusti- <anon>:7          use std::hashmap::*; static mut foo: HashMap = HashMap::new();
[02:52:54] -rusti-                                                        ^~~~~~~~
[02:52:55] -rusti- application terminated with error code 101
[02:52:55] *** Quits: jclements (jclements@moz-E7102064.ptldme.east.myfairpoint.net) (Quit: jclements)
[02:52:59] <doomrobo> cmr you just ruined my week
[02:53:05] <dbaupp> rusti: use std::hashmap::*; static mut foo: HashMap<~str, ~str> = HashMap::new();
[02:53:05] <cmr> doomrobo: why?
[02:53:05] -rusti- <anon>:7:68: 7:83 error: function calls in constants are limited to struct and enum constructors
[02:53:05] -rusti- <anon>:7          use std::hashmap::*; static mut foo: HashMap<~str, ~str> = HashMap::new();
[02:53:05] -rusti-                                                                              ^~~~~~~~~~~~~~~
[02:53:06] -rusti- error: aborting due to previous error
[02:53:06] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[02:53:07] -rusti- application terminated with error code 101
[02:53:24] <dbaupp> doomrobo: also, you can't call functions in static initialisers ^
[02:53:34] <dbaupp> doomrobo: (you're allowed to write your own lisp.)
[02:53:42] <cmr> The more the merrier!
[02:53:45] <cmr> Plus it's a great exercise
[02:53:58] <aatch> doomrobo, rusp is "on hold" at the moment
[02:54:02] *** Joins: jclements (jclements@moz-E7102064.ptldme.east.myfairpoint.net)
[02:54:16] <doomrobo> cmr I suppose :(
[02:55:01] <dbaupp> cmr: hurry up and go to bed! I wanna see some benchmarks! :P
[02:55:12] <cmr> dbaupp: it's friday! RPG night!
[02:55:29] <dbaupp> cmr: no! it's definitely bedtime!
[02:55:32] <cmr> heheh
[02:55:33] <doomrobo> which RPG?
[02:55:40] <cmr> doomrobo: Dark Heresy
[02:55:47] <doomrobo> hm, never heard of it
[02:55:54] <cmr> Warhammer 40k RPG
[02:56:01] <cmr> very dark, very fun
[02:56:03] <doomrobo> oh, ok
[02:56:10] *** Joins: zz_kimundi (kimundi@moz-9D73DE18.dip0.t-ipconnect.de)
[02:56:10] <doomrobo> I just got into Bit.Trip Runner 2
[02:56:15] <doomrobo> there goes my month
[02:56:26] *** zz_kimundi is now known as kimundi
[02:56:34] <doomrobo> hey kimundi
[02:58:54] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[02:59:31] <bjz> dbaupp: is a Scalar also a Module? (for lmath)
[02:59:45] <doomrobo> dbaupp what did you mean by "extern fn ->" ? How would that look in my case?
[02:59:56] <dbaupp> bjz: any ring is a module over itself, yes.
[03:00:14] <dbaupp> doomrobo: `extern fn(&[LispType]) -> LispType`
[03:00:28] <dbaupp> bjz: (was that what you were asking?)
[03:00:35] <bjz> dbaupp: aye
[03:00:50] *** Quits: lkuper (lkuper@3AE931C6.A402E718.C082B7DC.IP) (Quit: lkuper)
[03:03:31] <bjz> dbaupp: I'm wondering if I should make a lib similar to haskell's numeric prelude
[03:03:59] <bjz> dbaupp: you can have an attribute like #[no_prelude]; right?
[03:03:59] <tautologico> can I use the master branch now? I remember it wasn't the case sometime ago
[03:04:05] <dbaupp> bjz: yeah, take that pull request and break it out separately
[03:04:06] <bjz> tautologico: yup
[03:04:06] <cmr> tautologico: yes
[03:04:14] <dbaupp> bjz: #[no_implicit_prelude], yeah
[03:04:14] <bjz> tautologico: that is reccomended
[03:04:21] <tautologico> ok thanks
[03:04:23] <dbaupp> bjz: (it can even go on specific submodules.)
[03:04:32] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[03:04:39] <shachaf> Hah. #[no_implicit_prelude].
[03:04:46] * dbaupp took it from GHC
[03:04:56] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[03:05:02] <bjz> dbaupp: we could even stupidify the current numerics
[03:05:49] <bjz> dbaupp: ie. get rid of Real and Fractional - just have Float
[03:06:05] <bjz> same with Int
[03:06:48] <bjz> and if folks want more advanced numerics, they use the extensible abstract algebra lib
[03:06:59] *** Quits: jclements (jclements@moz-E7102064.ptldme.east.myfairpoint.net) (Quit: jclements)
[03:07:05] <cmr> THat sounds just fine to me
[03:08:33] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:08:52] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[03:09:04] *** Joins: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP)
[03:09:04] <bjz> #[no_implicit_prelude]; extern mod numeric; use numeric::prelude::*;
[03:09:25] <doomrobo> alright, enough mashing my head against the keyboard for now
[03:09:34] <bjz> doomrobo: wassup?
[03:09:34] <dbaupp> bjz: should work
[03:09:39] <doomrobo> see ya guys later. And again, thanks!
[03:09:50] <shachaf> I,I #[generalized_algebraic_data_types]
[03:09:51] <doomrobo> bjz not much, I'm gonna go enjoy life
[03:09:54] *** Quits: doomrobo (doomrobo@EC9C662A.161AAEB2.58B1C2DD.IP) (Quit: bye)
[03:09:55] *** Joins: Kag (Mibbit@503ECD3.C1B840DD.76F66111.IP)
[03:10:10] <bjz> dbaupp: I think the abstract algebra probably be more flexible going into the future, as it could evolve
[03:10:10] <dbaupp> bjz: ... hm, not keen about removing the differences between plain fractional and real.
[03:10:18] <bjz> dbaupp: ok
[03:10:23] *** Parts: Lovot (root@AE31FB56.8153C3BF.F3C9A2D9.IP) ()
[03:10:26] <bjz> dbaupp: maybe that's a bit far
[03:10:37] <dbaupp> shachaf: that'd be awesome
[03:10:49] <bjz> shachaf: yep
[03:10:53] * dbaupp dares shachaf to implement gadts in rust
[03:11:00] <shachaf> dbaupp: GADTs with Rust's type system is a pretty scary notion.
[03:11:10] <bjz> we want higher order types as well!
[03:11:12] <bjz> :D
[03:11:18] * dbaupp wants GADTs anyway
[03:11:32] <shachaf> Higher-order meaning higher-rank or higher-kinded or what?
[03:11:33] <bjz> dbaupp: should it be a separate lib?
[03:11:35] <engla> I've thought that maybe generic Vectors would be useful anyway. They occur in a lot of places and you don't want to reimplement the operators each time
[03:11:48] <shachaf> dbaupp: I want them too but I'm not quite sure what it would mean.
[03:12:10] <dbaupp> shachaf: at the very least, higher-kinded (i.e. "partially applying" Option, [], etc.) 
[03:12:12] <bjz> engla: I'm currently redoing my Vectors (again!)
[03:12:26] <dbaupp> bjz: to begin with, probably?
[03:12:27] <shachaf> Someone should implement rank-n types for Rust with a JIT that instantiates a polymorphic thing at a particular type at runtime.
[03:12:30] <dbaupp> bjz: (or in extra?)
[03:12:31] <bjz> engla: much more mathematical
[03:12:37] <shachaf> dbaupp: Yes, I see no real reason those shouldn't be supported.
[03:12:37] <bjz> dbaupp: not sure
[03:12:50] <bjz> dbaupp: it sould be nice to have the attribute
[03:12:52] <tautologico> bjz: you do lmath right?
[03:12:53] <engla> bjz: ok
[03:12:55] <shachaf> Rank-2 types and so on I'm not sure are compatible with Rust at all, as it is.
[03:13:01] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:13:20] <dbaupp> shachaf: there isn't a reason they aren't supported (for HKT), just it's not implemented, and not planned by the core devs (for 1.0)
[03:13:50] <shachaf> Is the language going to continue to evolve post 1.0?
[03:13:55] <dbaupp> they have said that they'd take a patch (which is glossing over the amount of coordination required, I assume.)
[03:14:01] <dbaupp> shachaf: I believe so
[03:14:19] * shachaf thinks higher-kinded types are a pretty important thing when there's nothing technically preventing them in your type system.
[03:14:28] <dbaupp> 1.0 = "minimum" to be considered a usable language
[03:14:46] <erickt> anyone want to do a quick review of https://github.com/mozilla/rust/pull/8069? I fixed up MaikKlein's #7969 to compile on head, and I was hoping to merge it in before it bitrotted
[03:15:03] * shachaf doesn't know who counts as core devs.
[03:15:17] <shachaf> (Is it people who are ops in here?)
[03:15:28] <dbaupp> yeah, essentially the mozilla people
[03:15:55] <olsonjeffery> shachaf: graydon, brson, nmatsakis, pcwalton & tjc
[03:16:02] <sully> engla: that bug is bizarre.
[03:16:37] <engla> that makes me proud
[03:17:14] <engla> to have found it. I think autoderef is known to have corner cases
[03:17:16] <shachaf> olsonjeffery: OK.
[03:17:54] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[03:17:57] <bjz> tautologico: aye
[03:18:02] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Ping timeout)
[03:18:06] <sully> engla: what version of the compiler are you using
[03:18:15] <tautologico> bjz: I was trying to find the repo url, but I got it
[03:18:26] <bjz> tautologico: I'm planning now to redefine things in terms of proper VectorSpaces etc.
[03:18:36] <sully> engla: the code in that bug works just fine as far as I can tell
[03:18:40] <bjz> tautologico: the API shouldn't change much though
[03:19:28] <tautologico> bjz: cool
[03:19:30] <bjz> tautologico: the lib has gone through many iterations as Rust has evolved, and I've come to grips with how best to express things using Rust
[03:19:39] <bjz> tautologico: are you interested in it?
[03:19:41] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:20:16] <tautologico> bjz: yes I looked at your lmath and scirust sometime agoâ€¦ scirust fits better for what I want (scientific computing) but it's severely outdated
[03:20:38] <bjz> tautologico: believe me, the initial ICEs with generics were so so painful. be gald I went through the pain for you guys
[03:20:59] <bjz> tautologico: sure.
[03:21:58] <bjz> tautologico: originally it started off more general. but I could head back in that way again. Geometric algebra would be amazing.
[03:22:28] <bjz> tautologico: maybe it could just be called 'algebra'
[03:22:31] <engla> sully: it's version 15ab6fd
[03:23:25] <sully> ok, well, it seems to work for me?
[03:23:34] <bjz> tautologico: the difficulty is the tension between graphics/game needs and scientific/maths
[03:23:43] <bjz> doomlord: what do you think? ^
[03:23:53] <tautologico> bjz: sure, it's hard to do both well, I think
[03:23:58] <engla> sully: ok, that's good news, I must be doing something wrong
[03:24:15] <bjz> tautologico: but by the same token, games need physics and collisions
[03:24:32] <sully> but I also don't think I made any /recent/ changes that could have fixed this bug
[03:24:45] <sully> oh, and it seems to work with my stage0 compiler... so
[03:24:49] <bjz> tautologico: I guess the challenge is that sci is less real time and more precision based
[03:24:56] <sully> could you put the whole file that you are testing with in the bug?
[03:25:10] <bjz> tautologico: for cg speed is paramount, precision is secondary
[03:25:22] <jensnockert> bjz: Mostly that scientific computing is memory limited, and gaming is usually compute-limited.
[03:25:30] <tautologico> bjz: yes
[03:25:58] <tautologico> bjz: and scientific computing often deals with huge systems in thousands of dimensions
[03:26:00] <bjz> tautologico: but if I create a generic abstract algebra module, that could be shared between maths libs
[03:26:27] <engla> sully: it's only broken in rusti (the program). It's an incorrect reduction of some kind of similar issue I found with Newtype (can't reproduce it with newtype right now either)
[03:26:47] <bjz> tautologico: ie. a prelude replacing the basic types in the Rust core
[03:26:57] <bjz> *traits
[03:27:19] <tautologico> bjz: maybe
[03:27:37] * jensnockert currently does simulations in single-precision, like a boss.
[03:27:54] <bjz> tautologico: but that might be too constraining to manage between multiple libs
[03:28:03] <bjz> tautologico: politics and stuffs
[03:28:16] <bjz> :)
[03:28:16] <engla> sully: the origin of the issue is that the type RemotePath in ./src/librustpkg/package_path.rs  doesn't work with .to_str() after some changes I did to ToStr. this seems to be an incorrect reduction of the test case..
[03:28:18] <sully> engla: ok, well, if you can find an input to rustc that exercises it...
[03:28:35] <sully> you made to_str() a default method?
[03:28:41] <engla> yes
[03:28:48] <bjz> jensnockert: what say ye?
[03:29:11] <jensnockert> bjz: I mean that scientific computing isn't always focused on precision in that sense.
[03:30:00] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[03:30:14] <sully> engla: and it was failing with stage1?
[03:30:15] <jensnockert> bjz: There are other properties that are more important, like stability.
[03:30:34] <bjz> jensnockert: stability?
[03:30:46] <jensnockert> bjz: As in a small perturbation to the input values, should only have a minor impact on the output.
[03:30:48] <tautologico> numerical stability
[03:30:48] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[03:30:58] <bjz> jensnockert: thought that was what you meant
[03:31:18] <dbaupp> <3 chaotic systems
[03:31:21] <engla> sully: yes. I made more changes than that to ToStr, I'll try to make a reproducer again
[03:32:02] <graydon> dbaupp: worse if the chaos stems from your algorithm interacting with floating point not-real-number-ness.
[03:32:25] <dbaupp> graydon: yeah, floating point isn't fun (sometimes)
[03:32:34] <jensnockert> Floating-point is always fun.
[03:32:47] <dbaupp> haha
[03:32:49] <tautologico> I tried updating scirust before but it was a nightmare
[03:32:50] <bjz> graydon: thoughts on my current line of thinking?
[03:33:02] <bjz> graydon: https://github.com/mozilla/rust/pull/8049#issuecomment-21658649
[03:33:04] <dbaupp> jensnockert: you're a madman.
[03:33:10] * jensnockert hugs dbaupp.
[03:33:22] * jensnockert should memorise IEEE 754, just to be annoying.
[03:33:46] <sully> engla: and it was failing when being built by the stage1 compiler, not by the stage0?
[03:34:08] * dbaupp hugs jensnockert
[03:34:16] <jensnockert> I wish I had the cash to get a IEEE 754-2008 compatible x86 processor :(
[03:34:32] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:35:20] <bjz> dbaupp: symbol manipulation ftw
[03:35:27] <engla> sully: failing in librustpkg, I don't think that's built in stage0
[03:35:35] <dbaupp> bjz: hm?
[03:35:43] <sully> oh, right
[03:36:29] <graydon> bjz: well, I think "outrageous" might be a bit harsh for describing that library; but I do share brson's concern that too much math in the stdlib will scare people more than it makes them feel welcome. getting that balance right is tricky.
[03:36:41] <bjz> graydon: yep
[03:36:48] <graydon> bjz: I did a math undergrad so I kinda get warm fuzzies thinking of groups, rings and fields
[03:36:55] <graydon> but most people did not and it's just cognitive load
[03:37:07] <Jeaye> Is the size of a C-style enum compatible with C and family?
[03:37:09] <bjz> graydon: My mind has just been opened to the wonders
[03:37:14] <cmr> Jeaye: nope
[03:37:23] <Jeaye> cmr: Is it predictable?
[03:37:23] <cmr> Jeaye: not generally.
[03:37:31] <bjz> graydon: hence my naive insanity
[03:37:33] <cmr> Jeaye: I think so, but that can change
[03:37:33] <Jeaye> Or customizable?
[03:37:34] <dbaupp> Jeaye: there's no defined C-enum size, so it's impossible to be compatible
[03:37:38] <cmr> Jeaye: nope, not yet
[03:37:39] <dbaupp> bjz: yay! <3 maths
[03:37:45] <cmr> I want a #[layout="C"] type thing for enums
[03:37:45] <Jeaye> Shit
[03:37:51] *** Quits: arete (arete@moz-CE1DC602.xen.prgmr.com) (Quit: leaving)
[03:37:56] <cmr> Jeaye: C doesn't specify the representation of enums
[03:37:57] <dbaupp> Jeaye: kemurphy is working on making it customisable
[03:37:58] <Jeaye> enum Foo : i32 { }
[03:37:59] * graydon unsure. I also worry about the "put it in a scalaz-like thing" direction, in that ... I worry about important stuff winding up in "often mandatory" secondary libraries that get out of control
[03:38:07] <graydon> scalaz is one case but, for example, boost is another
[03:38:09] <Jeaye> I'd really like that syntax.
[03:38:11] <cmr> or, at least, not the ABIs I'm familiar with
[03:38:14] <graydon> boost _really_ divides the C++ community
[03:38:14] <dbaupp> Jeaye: yeah, that's the syntax he's going for, I think.
[03:38:15] <Jeaye> Like C++11, really.
[03:38:19] <engla> sully: ok here is a testcase with trait A and B representing the new and old ToStr versions respectively. It seems to only be Newtype, this testcase is very similar to the remotepath case.  https://gist.github.com/anonymous/c31177e69daccb391fcf
[03:38:21] <Jeaye> Perfect. :)
[03:38:29] <engla> sully: since it's newtype, it's probably nothing to worry about
[03:38:31] <jensnockert> graydon: The most important part IMHO, is that rings and groups and stuff confuses everyone.
[03:38:50] <jensnockert> graydon: Since they are not actually rings and groups for floats etc.
[03:39:00] <graydon> are they not?
[03:39:13] <dbaupp> no inverse for + NaN, for instance.
[03:39:25] <dbaupp> (or + inf, for that matter.)
[03:40:24] <graydon> ah. well, they're _close_ :)
[03:40:30] <graydon> but yeah
[03:41:06] <graydon> you can't really expect f64 to behave as algebraically reasonable in any sense
[03:41:25] <graydon> if someone wants to have a go at a constructive reals or arbitrary rationals library, go for it :)
[03:41:36] <dbaupp> erickt: ping
[03:41:45] <erickt> dbaupp: pong
[03:41:50] *** Quits: seth (seth@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[03:41:56] <dbaupp> graydon: extra::bigint + extra::rational gives us the arbitrary rationals
[03:42:03] * jensnockert is working on fixed-point \o/
[03:42:10] <Luqman> r? https://github.com/mozilla/rust/pull/8070
[03:42:11] <dbaupp> erickt: for https://github.com/mozilla/rust/pull/8073, I thought const was deprecated?
[03:42:26] <erickt> was it? I must have missed that
[03:42:27] *** Joins: vodik (simon@moz-CBE4BB13.cable.teksavvy.com)
[03:42:54] <dbaupp> at least, some people have been removing uses of &const
[03:43:30] <graydon> I .. am not seeing extra::bigint or rational in my workspace
[03:43:33] <graydon> did they go away?
[03:43:40] <erickt> dbaupp: oh, I added `*const T` here to remove a cast::transmute
[03:43:51] <dbaupp> graydon: hm, they maybe in extra::num::*;
[03:44:02] <tautologico> computable reals would be nice
[03:44:20] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[03:44:21] <erickt> graydon: do you know the status of `*const T`? Is it deprecated?
[03:44:50] <dbaupp> graydon: right, yeah, directory structure is extra/num/bigint.rs (etc), but import-structure is extra::bigint (etc)
[03:45:02] <graydon> zomg we seriously have rull rationals and bignums? I didn't put 2 and 2 together to realize that. that's great!
[03:45:30] <graydon> BigRational, there it is
[03:45:33] <graydon> \o/
[03:45:56] <strcat> graydon: they're very slow, though
[03:46:32] <engla> sully: doesn't look like a default methods bug, just newtype bug
[03:46:44] <engla> sully: or possibly an engla bug
[03:46:52] <dbaupp> rusti: use std::num::*; use extra::rational::*; let one: BigRational = One::one(); let two = one + one; one / two
[03:46:53] -rusti- {numer: {sign: Plus, data: {data: ~[1]}}, denom: {sign: Plus, data: {data: ~[2]}}}
[03:47:05] <dbaupp> rusti: use std::num::*; use extra::rational::*; let one: BigRational = One::one(); let two = one + one; two / (two + two)
[03:47:06] -rusti- {numer: {sign: Plus, data: {data: ~[1]}}, denom: {sign: Plus, data: {data: ~[2]}}}
[03:47:24] <dbaupp> rusti: use std::num::*; use extra::rational::*; let one: BigRational = One::one(); let two = one + one; (two / (two + two)).to_str()
[03:47:25] -rusti- ~"1/2"
[03:47:45] <strcat> gmp's algorithms have better time complexities, and they're a hundred times faster even comparing apples to apples
[03:47:59] <strcat> it'd be hard to make it competitive
[03:48:16] <dbaupp> strcat: stop being such a party-pooper! :P
[03:48:53] <dbaupp> strcat: (you have gmp bindings somewhere, don't you?)
[03:49:00] <strcat> yes but they're pretty incomplete
[03:49:00] <graydon> strcat: gmp is also the product of decades of tuning.
[03:49:02] <jensnockert> strcat: Just reimplement the algorithms they said, cannot be that hard they said.
[03:49:04] <cmr> https://github.com/cmr/rustdoc_ng/blob/master/plugins.rs
[03:49:06] <cmr> This seems to easy
[03:49:11] <strcat> jensnockert: but they have many algorithms
[03:49:15] <cmr> it's going to explode as soon as I give it a plugin, I'm sure of it
[03:49:28] <strcat> it basically does a switch on the size, and dispatches to ones with better time complexities (but higher constant factors) as the numbers scale
[03:49:32] <jensnockert> strcat: Rust just need more interns then.
[03:49:35] <strcat> and it's all highly tuned SIMD.
[03:49:50] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[03:49:56] <Jeaye> I really like seeing people working on OpenGL projects with Rust, but if they copy my code, why remove the license from the top? :(
[03:49:56] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[03:49:57] <cmr> I don't see why not wrapping gmp is desirable.
[03:49:58] <dbaupp> jensnockert: if you came to australia, we could spend 6 months porting gmp to rust.
[03:50:00] <cmr> Less work is always better
[03:50:12] <graydon> cmr: my main concern with that is the same as the one in syntax extension dynamic loading: that we're not exposing symbol mangling, so there's no way to check dynamically that it's typesafe (and it's very likely not)
[03:50:16] <jensnockert> dbaupp: May need to get some cash for that.
[03:50:27] <erickt> Jeaye: that's not cool at all
[03:50:31] * jensnockert cannot afford a 6-month trip to Australia without income :(
[03:50:41] <cmr> graydon: Yes, metadata needs to be split out from from librustc and made better for a proper system.
[03:50:44] <Jeaye> erickt: I mean, it's BSD-3 clause. It's not like it's GPL!
[03:50:58] <strcat> cmr: gmp isn't permissively licensed
[03:51:00] <bjz> graydon: yeah, that's the scary thing about having a separate numeric prelude
[03:51:03] <cmr> strcat: oh that's unfortunate.
[03:51:07] <strcat> cmr: it's LGPL
[03:51:16] <cmr> silly people with their silly licenses
[03:51:29] *** Quits: joone (joone@moz-D3B2E195.jf.intel.com) (Ping timeout)
[03:51:38] <strcat> well it's fortunate for gmp, because it's *the best* library so people have to use it and contribute back
[03:51:46] <erickt> Jeaye: why even copy your code? we support linking in libraries...
[03:51:49] <dbaupp> graydon: fwiw, I've though long and hard about that, and I think we'll essentially need to move metadata reading/writing to libsyntax to get it to work.
[03:51:49] <bjz> jensnockert: stop by Melbourne for RustCon!
[03:51:56] *** Joins: joone (joone@3CCE8CB5.2160464A.A34EC3BB.IP)
[03:52:07] <cmr> dbaupp: it seems like it would belong next to the AST
[03:52:08] <Jeaye> erickt: To change some of it.
[03:52:16] <bjz> jensnockert: consisting on of aatch, dbaupp, xenocons and myself!
[03:52:16] <dbaupp> graydon: but I have no idea how that will work with any side tables that get written (assuming that some do?)
[03:52:17] <cmr> dbaupp: it's basically encoding properties of the AST, isn't it?
[03:52:19] <graydon> cmr: I think the simplest form would be to expose an intrinsic that type-mangles a given symbol to have a given type suffix
[03:52:35] <cmr> graydon: that would be simplest yes
[03:52:37] <dbaupp> cmr: right, with some extra stuff (I think.)
[03:52:38] <graydon> mangle_symbol::<symboltype>("foo")
[03:52:50] <cmr> graydon: I would really like to be able to *scan* a library though
[03:53:01] <graydon> scan for what?
[03:53:19] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[03:53:33] <cmr> imagine a plugin system where your plugin could hook into multiple things. rather than having a single entry pointish thing, you scan for the functions that would hook into a given place
[03:54:14] <dbaupp> cmr: so, essentially query for everything that has a given attribute?
[03:54:14] <erickt> Jeaye: If they copied it on github, I'd be happy to file a "don't strip out licenses" bug for you. What's the repository?
[03:54:16] <cmr> Of course, that would work with just multiple mangle_symbols
[03:54:23] <cmr> dbaupp: yeah, querying is a better word for it
[03:55:12] *** Quits: lmandel (lmandel@94C96733.C1F57925.ADB88A9.IP) (Quit: lmandel)
[03:55:15] <Jeaye> erickt: I'm not going to shame him just yet; I think I'll shoot him a message first. I really appreciate the offer. :)
[03:55:19] <dbaupp> is there any particular reason we aren't using the #[deriving(Encodable, Decodable)] for writing metadata? (other than history?)
[03:55:31] <erickt> Jeaye: k
[03:57:29] <cmr> I would start using Rust for real projects relevant to my non-Rust interests if the static linking and windows stories were better, if anyone is interested in what's stoping realistic use of rust (at least for me)
[03:57:43] <cmr> I can work around compiler bugs (they're not that bad at this point) and rapid changes.
[03:58:10] <cmr> I think I might anyway ;)
[03:58:14] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Client exited)
[03:58:42] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[03:59:45] <jensnockert> bjz: I guess I'll just have to go looking for a real job then, and then we'll have the first RustCon!
[04:00:49] <jensnockert> Soâ€¦ anyone hiring part-time remote workers around here..?
[04:01:40] <dbaupp> jensnockert: https://careers.mozilla.org/en-US/position/oKiEXfwn
[04:01:50] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[04:01:54] <dbaupp> (it doesn't satisfy either, but whatever.)
[04:02:01] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[04:02:31] <jensnockert> dbaupp: Yeah, that's kind of the problem :S
[04:02:51] <jensnockert> It gets 9001 bonus points for being Rust-related though.
[04:09:12] <kemurphy> hm
[04:09:29] <kemurphy> rust: task failed at 'borrowed', /home/kemurphy/rust/src/librustc/middle/resolve.rs:5466
[04:09:45] <kemurphy> what would cause that?
[04:09:57] <aatch> kemurphy, dynamic borrow failure
[04:09:58] <Jeaye> rusti: ~1
[04:09:59] -rusti- ~1
[04:10:03] <aatch> not fun to track down.
[04:10:17] <dbaupp> rusti: let x = @mut 1; let y = &*x; *x = 1;
[04:10:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MIAJ
[04:10:26] <kemurphy> aatch: ugh. that's what i thought
[04:11:10] <dbaupp> doesn't -Z debug-borrows help with that, or something?
[04:11:17] *** Joins: lmandel (lmandel@94C96733.C1F57925.ADB88A9.IP)
[04:11:22] <Jeaye> Gah, I always forget the operator for bitwise complement in Rust.
[04:11:34] <Jeaye> Since ~ means something entirely different. :P
[04:11:58] <dbaupp> rusti: !1
[04:11:59] -rusti- -2
[04:12:21] <Jeaye> Yeah, makes sense when you see it. "not"
[04:12:24] <Jeaye> Just breaks habit.
[04:12:38] <dbaupp> yup
[04:12:48] <kemurphy> any way to capture a mutable in a stack closure?
[04:13:02] <Jeaye> @ makes it easy :P
[04:13:15] <kemurphy> Jeaye: that's what led to the dynamic borrow failure :(
[04:13:24] <Jeaye> oh, haha
[04:13:28] <dbaupp> rusti: let mut i = 1i; let f = || { i += 1; }; println(i.to_str()); f(); f(); i
[04:13:29] -rusti- 1
[04:13:29] -rusti- 3
[04:13:36] <dbaupp> kemurphy: ^ ?
[04:13:52] <kemurphy> maybe it's a managed closure then *shrug*
[04:13:54] <kemurphy> i get this:
[04:14:14] <dbaupp> oh, is this in one of the syntax::fold functions?
[04:14:25] <kemurphy> yeah
[04:14:54] <dbaupp> yeah, those are @fn. :(
[04:15:25] *** Quits: Kag (Mibbit@503ECD3.C1B840DD.76F66111.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[04:16:05] <kemurphy> /home/kemurphy/rust/src/librustc/middle/resolve.rs:5466:59: 5466:69 error: mutable variables cannot be implicitly captured
[04:16:07] <kemurphy> /home/kemurphy/rust/src/librustc/middle/resolve.rs:5466                 match fold_expr(e, fld, self.def_map, &mut replace_id) {
[04:16:21] <dbaupp> yup :(
[04:16:23] <dbaupp> code?
[04:17:10] <kemurphy> dbaupp: https://gist.github.com/kemurphy/6093683
[04:17:30] *** Quits: lmandel (lmandel@94C96733.C1F57925.ADB88A9.IP) (Quit: lmandel)
[04:17:56] <dbaupp> kemurphy: what's the version with @mut?
[04:18:47] <kemurphy> dbaupp: https://gist.github.com/kemurphy/6093683#file-mutable-sadness-rs
[04:19:09] <kemurphy> er, https://gist.github.com/kemurphy/6093683#file-managed-mut-sadness-rs
[04:19:12] <dbaupp> kemurphy: and fold_expr?
[04:19:35] <kemurphy> the param on fold_expr is &mut; should i change it to @mut and see what happens?
[04:19:56] <dbaupp> yup
[04:20:31] <cmr> dbaupp: alright so in theory it will now 1. save builds, 2. use already-saved builds if it can to rerun benchmarks, 3. not explode
[04:20:42] <cmr> all highly theoretical of course
[04:20:47] <dbaupp> cmr: awesome!
[04:21:09] <kemurphy> (the relevant line was just *rid = Some(f.id))
[04:21:22] <dbaupp> cmr: the not-exploding would be convenient, but I guess it's not that important. :P
[04:21:25] <dbaupp> kemurphy: it's fixed?
[04:21:47] <kemurphy> dbaupp: compiling
[04:21:51] <kemurphy> will know in a few
[04:21:52] <cmr> dbaupp: ok, seems to be working for the case where it finds the build cached
[04:22:01] <cmr> there are 47 cached builds right now, so I'm just going to bed :p
[04:22:17] <dbaupp> cmr: does it keep building if it finishes all the cached ones?
[04:22:23] <cmr> dbaupp: yes
[04:22:26] <cmr> and caches the new builds
[04:22:32] <dbaupp> cool
[04:22:40] <cmr> I wiped all the old data btw
[04:22:58] <dbaupp> cmr: so, I should clear it after it collects for a bit?
[04:23:03] <cmr> yeah
[04:23:12] <dbaupp> will do.
[04:23:13] <cmr> Iunno, give it an hour or two? should be all caught up
[04:23:28] <cmr> a single run on librustc is like 2 minutes I think
[04:23:33] <cmr> so ~5 minutes per cached bench
[04:23:35] <cmr> pretty good :D
[04:23:48] <cmr> per cached build that is
[04:23:59] <dbaupp> does it use the appropriate version of librustc for each cached build?
[04:24:02] <cmr> yup
[04:24:34] <dbaupp> you're awesome! :D
[04:25:27] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[04:26:14] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[04:26:17] <cmr> alright it's on autopilot, good night
[04:26:43] <dbaupp> night
[04:27:42] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[04:28:41] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[04:28:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/PXltpw
[04:28:41] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[04:29:42] <aatch> Ok, I now have a strange version of `time`
[04:30:52] *** Joins: Nefzaoui (chatzilla@429AD06F.4FBEB140.D9343D67.IP)
[04:30:57] <dbaupp> strange?
[04:31:39] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[04:31:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/q1ETpw
[04:31:39] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[04:31:40] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:31:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/u04rdQ
[04:31:40] <ghrust> 13rust/06auto 14ba8fe12 15Graydon Hoare: Revert "De-share ast::Ty"...
[04:31:40] <ghrust> 13rust/06auto 147de44d7 15bors: auto merge of #8072 : graydon/rust/syntax-deshare, r=graydon...
[04:31:41] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[04:31:47] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Connection reset by peer)
[04:31:48] <cmr> aatch: can libstd's dependance on libc (at least on linux) be replaced with your amalgam? that'd be pretty sweet
[04:32:04] <aatch> cmr, partially, yes.
[04:32:20] <aatch> cmr, I've only got what I need implemented.
[04:32:35] <aatch> or what I thought I needed and ended up changing method
[04:32:45] <kemurphy> dbaupp: well, i have a more different error now, but i think that seems to have fixed it
[04:32:50] <kemurphy> rust: task failed at 'assertion failed: sub != sup', /home/kemurphy/rust/src/librustc/middle/region.rs:97
[04:33:15] <dbaupp> kemurphy: cool. (or not.. that sounds strange.)
[04:33:31] <kemurphy> dbaupp: actually, wait, i didn't touch that.... hm
[04:34:25] <aatch> dbaupp, what resolution is the current benchmarker at?
[04:34:29] *** Joins: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com)
[04:34:37] <dbaupp> aatch: no idea
[04:34:42] <dbaupp> aatch: I'll check
[04:35:05] *** Quits: Nefzaoui (chatzilla@429AD06F.4FBEB140.D9343D67.IP) (Ping timeout)
[04:35:23] <aatch> Also, what data do you get?
[04:35:51] <cmr> I busy loop-pool memory_usage_in_bytes from the cgroup
[04:36:00] <cmr> with  clock_gettime(CLOCK_MONOTONIC)
[04:36:03] *** Joins: Nefzaoui (chatzilla@731DB383.57775605.80E43DAF.IP)
[04:37:09] <aatch> cmr, just busy loop? What kind of time do you get on that?
[04:37:16] <cmr> https://github.com/cmr/rust-bench/blob/master/benchlib.py
[04:37:24] <cmr> aatch: quite good actually
[04:37:34] <cmr> I think it's something like 3us?
[04:37:45] <aatch> cmr, because I output grab ~6M a second without a wait
[04:37:48] <cmr> much better than I was expecting from python
[04:37:58] <cmr> ok wow
[04:38:07] <cmr> aatch: I also merge adjacent memory measurements
[04:38:16] <aatch> And that's just a CSV with gettime, memusage
[04:38:19] <cmr> so if prev_usage==cur_usage, write nothing
[04:38:41] <cmr> benchlib.py is quite clean code, should beeasy to understand
[04:39:03] <cmr> I defer parsing of the collected memory.stat file until after memory collection
[04:39:08] <cmr> because python is slow
[04:39:12] <cmr> but you don't seem to have thatproblem
[04:39:14] <cmr> :p
[04:39:26] *** Joins: Mindless` (mindless@moz-9C38D3B4.net)
[04:39:26] <kemurphy> dbaupp: weird, the region checker broke on one of the rewritten bits
[04:39:58] * kemurphy does not particularly want to dive into the region checker
[04:40:18] <dbaupp> aatch, cmr: fwiw, the minimum difference in time-of-sample I can see is 78us
[04:40:43] <cmr> dbaupp: ok
[04:40:56] <cmr> that doesn't directly reflect what is actually collected becauseof the merging
[04:40:58] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[04:41:00] <dbaupp> yeah
[04:41:06] <cmr> but thatseemsto be a very useful resolutoin
[04:41:40] <cmr> aatch: I collect memory usage like section 5.5 in https://www.kernel.org/doc/Documentation/cgroups/memory.txt describes
[04:41:50] <cmr> aatch: (also,you're awesomefor working on this!
[04:43:22] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[04:43:40] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[04:43:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147de44d7 to 144989799: 02http://git.io/N3iJvQ
[04:43:40] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[04:43:40] *** Quits: Nefzaoui (chatzilla@731DB383.57775605.80E43DAF.IP) (Connection reset by peer)
[04:44:39] <aatch> cmr, heh. I might just write a good general benchmarking tool and hand it over to you to automate everything.
[04:44:48] <Mindless`> is there a reason I can't mutate an element of a destructured enum, but I can put it in a mutable slot and mutate it? e.g. http://codepad.org/GI9oROgD
[04:44:58] <cmr> aatch: that's basically what I didwith dbaupp..
[04:45:15] <cmr> aatch: mem-bench.py is pretty good standalone
[04:45:26] <mark_edward> are there alignment things in Rust? like #[align(32)]?
[04:45:28] <kemurphy> anyone know what it means when sup == sub in record_parent in the region checker?
[04:45:28] <engla> Mindless`: good question
[04:45:32] <cmr> and dbaupp wrote auto-bench.py that  drives it all
[04:45:47] <cmr> mark_edward: not afaik
[04:45:54] <dbaupp> nmatsakis: kemurphy's question ^
[04:45:54] <cmr> mark_edward: there is #[packed] though
[04:46:10] <mark_edward> cmr: what does #[packed] do?
[04:46:16] <Eridius> Mindless`: well you can't mutate it because it's not a mutable slot. But I don't know why you can't say `Branch(~Leaf(mut l), r)`
[04:46:19] <cmr> mark_edward: no padding in structs
[04:46:20] <aatch> cmr, well either way. I'm quite interested in a general benchmarker atm.
[04:46:27] <mark_edward> cmr: ah i see
[04:47:00] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[04:47:05] <dbaupp> Mindless`: if you write `let mut l = l;` in the top of that match, it should work
[04:47:15] <sfackler> what's the right Rust type for a C function pointer void(*)(void *) in an ffi declaration? I thought *fn(*c_void), but rustc doesn't like that.
[04:47:16] <dbaupp> Eridius: I think that's just a bug
[04:47:39] <cmr> sfackler: extern "C" fn(*v_void)
[04:47:43] <dbaupp> sfackler: probably `extern "C" fn()
[04:47:46] <sfackler> ah, thanks
[04:48:00] <Mindless`> Eridius: it can be assigned to a mutable slot, so I would have expected it to already be a mutable slot
[04:48:19] <dbaupp> Mindless`: variables are immutable by default, this is just a reflection of that.
[04:48:48] <engla> Mindless`: the syntax  let (mut a, b) = (1,2) will be added, maybe that will allow you to fix this too, with a 'mut' in the pattern
[04:49:10] <engla> It looks like it should be the same thing
[04:49:13] <Mindless`> that sounds like what I want :)
[04:50:41] <cmr> engla: mut is already allowed in irrefutable patterns, letis just special
[04:50:49] <cmr> rusti: fn foo(mut x: int) {}
[04:50:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UXDQ
[04:51:06] <engla> cmr: not allowed in match
[04:51:16] <cmr> oh
[04:51:43] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[04:51:47] <enix> I've got a big change to the Sha2 code almost ready which reduces memory usage and speeds it up by 30-40% (almost as fast as hand written assembly). Should I submit it as a series of changes or as one big change? Regardless, almost every single line is changed.
[04:51:55] <dbaupp> cmr: it's not allowed in irrefutable patterns, I think let and function args are special cases
[04:52:10] <dbaupp> enix: one pull request, several commits if they are distinct
[04:52:17] <cmr> dbaupp: let and function args *are* irrefutable patterns I thought
[04:52:18] <dbaupp> enix: (but nice work! :D )
[04:52:29] <dbaupp> cmr: yes, but `mut` in them is a special case.
[04:52:33] <cmr> oh
[04:52:35] <cmr> ok
[04:52:46] <dbaupp> cmr: e.g. mut used to not work in default methods
[04:52:56] <strcat> enix: I think you should submit it as one pull request, but a series of commits makes sense if each one can stand alone
[04:53:08] <strcat> if it needs all the commits to actually compile/work, might as well squash them into one
[04:53:14] <enix> thanks!
[04:53:50] <enix> the changes can be split up into smaller ones and each one should compile along the way, just wanted to confirm if that would be helpful to reviewers before starting on the task of breaking it up
[04:55:18] <graydon> enix: can I see the change? I'm just curious
[04:55:44] <cmr> enix: being almost as fast as hand-written assembly  is very impressive
[04:55:52] <cmr> worthy of an ML post :)
[04:56:08] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[04:57:24] <enix> well, i'm not trying to be too over the top; i've got it running about about 11 cycles/byte for Sha-512. Intels paper on optimizing Sha-512 managed to get about 9.4 cycles/byte.
[04:58:25] <enix> so, its not exactly as fast, but, its getting close to the limit. I don't know what a typical C implementation generally runs at.
[04:58:38] <enix> graydon: i'll make a branch available on Github in a few minutes
[04:58:44] <graydon> cool, thanks
[04:59:13] <strcat> enix: are you using --opt-level=3? I'm curious if any of it is auto-vectorized
[04:59:31] <enix> yup, opt-level 3
[05:00:02] <enix> i believe it it vectorizing much of the code. i didn't look into the assembly too closely, but i did notice that there are a bunch of xmm registers being used
[05:00:03] <dbaupp> enix: same output, and everything?
[05:00:14] <sfackler> rusti: static foo: extern "C" fn(*std::libc::c_void) = unsafe { std::cast::transmute(-1) };
[05:00:15] -rusti- <anon>:7:57: 7:92 error: constant contains unimplemented expression type
[05:00:15] -rusti- <anon>:7          static foo: extern "C" fn(*std::libc::c_void) = unsafe { std::cast::transmute(-1) };
[05:00:15] -rusti-                                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[05:00:15] -rusti- error: aborting due to previous error
[05:00:16] -rusti- application terminated with error code 101
[05:00:28] <dbaupp> sfackler: no function calls in statics
[05:00:41] <sfackler> is there a way to do a compile time cast?
[05:00:42] <enix> yeah, its passing all of the #tests as well as my "test suite" where i'm running a few thousand inputs against it and comparing the output against Java's implementation of Sha2
[05:00:59] <dbaupp> sfackler: for some things, `as` works
[05:01:07] <dbaupp> enix: awesome.
[05:01:15] <cmr> sfackler: transmute is compile time,but not allowed in static
[05:01:34] <strcat> you can use 'as'
[05:01:37] <strcat> in constant exprs
[05:01:52] <strcat> that's likely the only reason it exists as a keyword ;p
[05:02:13] <sfackler> 'as' unsurprisingly isn't willing to cast from an int to a function pointer though :(
[05:02:33] <strcat> because it doesn't consider extern fn to be a pointer
[05:02:58] <strcat> hm
[05:03:14] <dbaupp> sfackler: you may need `static mut foo: Option<extern "C" fn(...)> = None;`
[05:05:00] <sfackler> seems like it'd be easier to do
[05:05:25] <sfackler> pub fn foo() -> extern "C" fn(*c_void) { unsafe { cast::transmute(-1) }}
[05:05:46] <dbaupp> cmr: http://octayn.net/benches/4c4cf003ea32d7617602fdbd1b2ebc8099633f06/ 29 bytes?
[05:06:21] <mark_edward> are there any docs on fmt!? I can't figure out all the formats and stuff
[05:06:53] <cmr> dbaupp: feh I'll handle it in the morning. are they all empty? (empty == 29byte)
[05:06:59] <mark_edward> how do you print hex? and can you specify a minimum width?
[05:07:02] <dbaupp> cmr: that's the only one so far
[05:07:08] <cmr> ok
[05:07:11] <dbaupp> mark_edward: it's the same as printf
[05:07:19] <dbaupp> cmr: (i.e. the only one on the website.)
[05:07:25] <dbaupp> mark_edward: (for most things)
[05:07:28] <mark_edward> dbaupp: you mean C's printf?
[05:07:31] <dbaupp> mark_edward: right
[05:07:38] <mark_edward> ok cool
[05:07:57] <dbaupp> mark_edward: but if you look in libstd/unstable/extfmt.rs, there's a little description
[05:11:48] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[05:11:53] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[05:13:26] <jmgrosen> aatch: have any more ideas as to why std.o is referencing libcrt?
[05:13:59] <aatch> jmgrosen, well it's not referencing it, it's that the linker is pulling it in.
[05:14:03] <aatch> I don't know why though.
[05:14:23] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[05:14:47] <jmgrosen> aatch: could it be because we're using `cc` instead of ld?
[05:14:54] <aatch> jmgrosen, maybe.
[05:17:10] <enix> graydon: https://github.com/DaGenix/rust/tree/sha2-improvements
[05:17:15] <jmgrosen> aatch: yeah, that's it, but now `ld` is giving me all sorts of undefined symbols :(
[05:17:47] <enix> the biggest improvements came from doing less copying on the input buffers; the old implementation wasn't very efficient and did alot of stuff byte-by-byte
[05:17:50] <aatch> jmgrosen, you probably need to supply the libraries libstd needs.
[05:18:15] <enix> part of optimizing that was a small set of unsafe functions, but, they are all really simple and easy to audit
[05:18:23] <jmgrosen> aatch, probablyâ€¦ so what, libc?
[05:18:25] *** Quits: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com) (Quit: WeeChat 0.3.8)
[05:18:41] <aatch> jmgrosen, and rustrt and libuv
[05:18:49] <jmgrosen> aatch: ah, right
[05:19:04] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:19:24] <aatch> jmgrosen, if you compile and pass -Z print-link-args then you'll see the flags that get passed to cc
[05:19:40] <jmgrosen> aatch: thanks
[05:19:55] <enix> the next biggest set of speed improvements came from combing the message schedule calculations and the rest of the compression function into a single loop where I could which LLVM seems to take advantage of
[05:19:57] <graydon> enix: nice
[05:20:30] <enix> the branch i sent has only been very lightly tested - i've been doing most of my work out-of-tree for faster compilations
[05:20:45] <enix> and the branch above won't be the one I submit for a final pull request - its still missing documentation and such
[05:20:52] <enix> thanks!
[05:21:20] <graydon> eventually we should have IO memory-stream-readers that can pull be/le x64s out of a buffer like this "normally" but for now the helper functions will do
[05:21:22] <graydon> thanks
[05:21:51] <strcat> enix: btw there's a set_memory method on u8 vectors
[05:22:00] <jmgrosen> aatch: how does one build rustrt statically?
[05:22:04] *** Quits: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[05:22:09] <aatch> jmgrosen, not sure.
[05:22:19] <jmgrosen> aatch: well, i'll mess around with it :P
[05:22:19] <dbaupp> enix: (and range(0, x) |_| { .. } = x.times { .. })
[05:22:53] <enix> strcat: thanks, i did not know that
[05:22:58] <aatch> though I just remembered that you need to use `ar` for static linking. `ld` can't actually do it (not without *a lot* of massaging anyway)
[05:23:03] <strcat> enix: and a vec::bytes::copy_memory function too
[05:23:15] <strcat> aatch: well that's why you might as well ask gcc/clang ;p
[05:23:38] <aatch> strcat, yeah, but that seems to be part of the problem here.
[05:23:42] <enix> dbaupp, strcat: thanks, I will make those updates
[05:24:18] <dbaupp> enix: and .slice(0, x) == .slice_to(x) (and v.slice(x, v.len()) == v.slice_from(x))
[05:25:05] *** Joins: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr)
[05:25:07] <jmgrosen> aatch: is it possible to build just rustrt? (as a shared library for starters)
[05:25:26] <aatch> jmgrosen, probably. I don't know the exact incantation though.
[05:25:31] <strcat> dbaupp: going to see if Iterable can actually be implemented atm ;p
[05:25:41] <dbaupp> strcat: awesome
[05:26:04] <strcat> ugh I broke the rust-git package
[05:26:11] <strcat> well not horribly
[05:26:20] <enix> woah, all sorts of useful methods I was unaware of
[05:26:36] <strcat> enix: rustdoc isn't great at presenting them
[05:26:47] <strcat> especially the iterator stuff
[05:28:20] <dbaupp> enix: that stuff looks pretty cool though, yay for macros in inner loops! :)
[05:28:25] <enix> I had mostly been reading through the vec.rs code looking for the methods I needed, and I guess I stopped looking a little to early
[05:29:11] <enix> thanks! yeah, macros are pretty handy
[05:29:22] <dbaupp> haha, there is several thousands lines of it :)
[05:33:22] <enix> thanks everyone for the feedback! i'll make sure to incorporate it before submitting an actual pull request.
[05:34:54] <strcat> dbaupp: annoying borrowck errors ofc
[05:34:55] <strcat> ;[
[05:35:09] <strcat> oh it's from slices not working with auto-deref
[05:35:57] <strcat> http://ix.io/6Td uh
[05:41:12] *** Quits: duckinator (nick@moz-74B346B5.mostlyincorrect.info) (Quit: Nickname collision due to Services enforced nickname change, your nick was overruled)
[05:42:02] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[05:43:52] <strcat> dbaupp: fold is going to conflict ;p
[05:43:54] <strcat> the method name
[05:49:05] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[05:50:36] <dbaupp> strcat: just move all the Util methods to default methods, maybe?
[05:50:51] <strcat> dbaupp: well just the ones not returning an iterator for now
[05:51:06] <strcat> anyway called it foldl
[05:51:12] <Luqman> r? https://github.com/mozilla/rust/pull/8070
[05:56:44] <strcat> now I have to go replace all the iter().fold()
[05:58:28] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[06:00:15] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[06:01:44] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:03:38] <sfackler> any idea what's up with this?
[06:03:41] <sfackler> rusti: trait Foo {} impl<T: Num> Foo for T {} impl Foo for ~str {}
[06:03:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OESM
[06:04:47] <strcat> rusti: trait Foo {} trait Test {} impl<T: Test> Foo for T {} impl Foo for ~str {}
[06:04:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ifGi
[06:05:09] <strcat> dbaupp: ICE from default methods
[06:05:11] <strcat> ;p
[06:05:47] <sfackler> rusti: trait Foo {} trait Test {} impl<T: Test> Foo for T {} impl Foo for int {}
[06:05:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/McaB
[06:06:11] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[06:10:37] <strcat> yay dummy type params
[06:10:41] <strcat> need a snapshot ;[
[06:10:58] <aatch> I like the fact that I can write code that forces me to check for errors.
[06:11:39] *** Joins: darithorn_ (darithorn@moz-97BAE36D.dhcp.knwc.wa.charter.com)
[06:12:55] <strcat> dbaupp: https://paste.xinu.at/AQVq/ seems to work
[06:13:00] <strcat> as a default method it ICEs
[06:13:19] *** Joins: thesnowdog (doug@32E338DF.CDB23781.6F17036B.IP)
[06:13:36] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:14:54] <mark_edward> strcat: what does this mean? error: obsolete syntax: `mut` with multiple binding
[06:15:16] <strcat> you're using a feature that was removed
[06:15:33] <strcat> not sure exactly what
[06:15:57] <Jeaye> ~mut perhaps?
[06:16:08] <mark_edward> strcat: this was the line `let mut (i_byte, i_bit) = (0, 0);`
[06:16:22] <strcat> mark_edward: need to make them mutable separately for now
[06:16:27] <strcat> until mut is allowed in patterns
[06:16:36] <mark_edward> strcat: ah, i see
[06:16:46] <strcat> as in let (mut a, mut b) = (1, 1) should work, but won't atm
[06:20:45] <strcat> meh it falls apart when trying to use the lifetime
[06:20:55] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:22:54] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[06:25:47] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[06:25:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/h88DOA
[06:25:47] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[06:26:11] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[06:27:44] <Jeaye> I know of cmp::min and cmp::max, but do we have clamp?
[06:28:11] <Jeaye> rusti: clamp(1, 3, 5)
[06:28:12] -rusti- <anon>:7:9: 7:14 error: unresolved name `clamp`.
[06:28:12] -rusti- <anon>:7          clamp(1, 3, 5)
[06:28:12] -rusti-                   ^~~~~
[06:28:12] -rusti- error: aborting due to previous error
[06:28:12] -rusti- application terminated with error code 101
[06:28:35] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[06:28:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8wPn3w
[06:28:35] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[06:28:38] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[06:28:38] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/wL-81w
[06:28:38] <ghrust> 13rust/06auto 141933df6 15Steven Stewart-Gallus: Change concurrency primitives to standard naming conventions...
[06:28:38] <ghrust> 13rust/06auto 144bc45a0 15Steven Stewart-Gallus: Fix nits.
[06:28:38] <ghrust> 13rust/06auto 14dcc75d1 15bors: auto merge of #7978 : sstewartgallus/rust/rename_arc, r=bblum...
[06:28:40] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[06:29:01] <bjz> rusti: 2i.clamp(&0, &1) // Jeaye
[06:29:02] -rusti- 1
[06:29:11] <Jeaye> Oh, too easy
[06:29:15] <Jeaye> <3 bjz 
[06:29:29] <bjz> Jeaye: should probs be a default method on ord
[06:29:52] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[06:29:53] <bjz> I was having trouble with the not(test) stuff though
[06:29:54] <Jeaye> The docs for i32 seem whacky http://static.rust-lang.org/doc/std/i32.html
[06:30:18] <bjz> yup
[06:30:26] <bjz> it's all wcky
[06:30:29] <bjz> *wacky
[06:30:44] <bjz> have you looked at the code from std::num?
[06:31:04] <bjz> the int/uint modules are generated using macros
[06:31:38] <Jeaye> yeah
[06:31:54] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:32:52] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[06:38:32] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[06:44:39] <acrichto> graydon: could you take a look at https://github.com/mozilla/rust/pull/8035 ?
[06:44:45] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[06:45:32] <graydon> I don't think we can do that
[06:45:42] <graydon> the gc doesn't know what it's looking at
[06:45:46] <acrichto> which gc?
[06:46:11] <acrichto> the current one or the pending one that is
[06:47:48] <graydon> the pending one
[06:47:55] <graydon> there is no current gc
[06:47:59] <graydon> there's refcounting and annihilation
[06:48:11] <graydon> cycles leak, nothing traces through managed-unique
[06:48:13] <graydon> the pending one does
[06:48:14] <acrichto> yeah, I guess "gc"
[06:48:41] <acrichto> does it use the tydesc to trace through?
[06:48:48] <graydon> to trace it just gets an allocation that it knows is in the managed heap, and it skips over the header (which all things in the managed heap have) and scans the body for pointers
[06:48:51] <graydon> it's very simple minded
[06:49:00] <graydon> it will use the tydesc when it is changed to be heap-precise
[06:49:04] <graydon> at the moment it's conservative everywhere
[06:49:21] <graydon> so it assumes the header presently (size-wise); and will _need_ the header when it switches to heap-precise
[06:50:07] <acrichto> hmm... ok I'll close that for now
[06:50:11] <acrichto> thanks for looking at it!
[06:50:23] <mark_edward> if I implemented a hash function in native Rust instead of making C bindings, is that preferred? The context is that I'd like to get it into extra::digest
[06:51:19] <graydon> sorry :(
[06:51:38] <acrichto> oh no problem! I'd rather an actual gc than smaller allocations :)
[06:51:39] <graydon> mark_edward: yeah, if possible. we are usually "nearly as fast" in rust, and safer, and avoid FFI
[06:51:51] *** Joins: tikue (tkuehn@moz-9FA353EF.hsd1.ca.comcast.net)
[06:52:06] *** Quits: tikue (tkuehn@moz-9FA353EF.hsd1.ca.comcast.net) (Quit: tikue)
[06:52:18] <graydon> acrichto: re fmt!, I think I like your plan but can't quite see how the types are verified at compile time
[06:52:35] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:52:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14dcc75d1 to 14300ba1c: 02http://git.io/N3iJvQ
[06:52:35] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:52:49] <graydon> acrichto: but also want to point out that the facility should support runtime-variable strings fetched from gettext(), in addition to anything it does statically
[06:53:37] <acrichto> graydon: something along the lines of https://gist.github.com/alexcrichton/6094034 will enforce compile-time checks that a value is formattable and that there's a function to format it, and at runtime they're just passed opaquely through
[06:54:09] <acrichto> could you elaborate on the gettext() thing though? I've heard stuff about using it for i18n but I don't understand enough about it to make sure it fits
[06:54:17] <graydon> I have no idea what that function does
[06:54:25] <Luqman> hmm, how can I manually compile a foo.ll from --emit-llvm so I can test something i've changed?
[06:54:42] <acrichto> oh, sorry, the compiler will generate calls to that function in place of fmt!
[06:54:53] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[06:55:15] <graydon> acrichto: the gettext thing is that you pass a string to a library and it looks up the current locale translation for that string in a runtime-loaded hashtable of strings, basically
[06:55:23] <graydon> acrichto: and then formats into that
[06:55:27] <acrichto> hmm... I guess it's kinda hard to explain without lots of code, although it is all verified at compile-time and it should be typesafe
[06:55:50] <acrichto> graydon: oh yeah that would totally work
[06:55:59] <acrichto> actually that would work surprisingly well
[06:56:55] <graydon> so you ask for (say) ifmt!("current status: {s}") and it goes and says "aha, you are in a spanish locale, I will format that into the translated string "estado actual: {s}"
[06:57:07] <graydon> there are some sneaky parts though
[06:57:16] <graydon> to do with gender and plurality
[06:57:38] <graydon> (potentially other things, but those are the parts that really matter, that the facilities are designed for)
[06:57:54] <graydon> so that, say, a string like "there are %d file(s)" gets turned into something more suitable
[06:58:45] <acrichto> graydon: so this translates the entire string and not just portions of the string?
[06:59:02] <acrichto> as in there's not like a '%t' placeholder for "translate this argument"
[06:59:13] <mark_edward> graydon: thanks for the advice!
[07:00:04] <dbaupp> acrichto: have you seen the work that aatch and I did previously?
[07:00:19] <acrichto> dbaupp: oh no I haven't, where's it located?
[07:00:26] <graydon> "{1,choice,=0{there are no files},=1{there is one file},=N{there are {1} files}}" or some such
[07:00:55] <dbaupp> acrichto: there's a metabug here https://github.com/mozilla/rust/issues/2249
[07:00:59] <graydon> acrichto: there is essentially a little (very minor) switch-statement form built into the format-string language
[07:01:21] <dbaupp> acrichto: and https://github.com/mozilla/rust/issues/1651#issuecomment-18670661
[07:01:31] <graydon> acrichto: such that a formatter has to do a little bit of data-evaluating and branching. this is to permit different translations to _provide the logic for their language_ in their translated string.
[07:01:46] <graydon> acrichto: it can't be factored out of the string, because it _comes from_ the translator, not the programmer
[07:02:12] <dbaupp> acrichto: also, https://github.com/mozilla/rust/wiki/Lib-fmt (extremely bare bones.)
[07:02:30] <acrichto> graydon: so for the "there are %d file(s)" case, what would the macro in theory look like?
[07:02:33] <acrichto> dbaupp: thanks!
[07:02:55] <dbaupp> acrichto: also, https://mail.mozilla.org/pipermail/rust-dev/2013-May/003999.html
[07:02:58] <graydon> acrichto: http://permalink.gmane.org/gmane.comp.lang.rust.devel/4765 contains the last solid email I wrote
[07:03:13] <graydon> acrichto: it wouldn't involve using %d anymore
[07:03:20] <acrichto> graydon: dbaupp: oh excellent, I'll read all that stuff, thanks!
[07:03:27] <graydon> acrichto: it'd involve first using {} forms because they permit nesting
[07:04:10] <graydon> acrichto: and then a translated string could be _either_ the simple and crappy form like: "there are {1} file(s)"
[07:04:39] <graydon> acrichto: or the more complex (but only discovered at runtime!) format string: "{1,choice,=0{there are no files},=1{there is one file},=N{there are {1} files}}"
[07:05:14] <dbaupp> acrichto: also, we can use newtype structs to control behaviour, e.g. we don't need a separate %e formatter, just use `std::fmt::Scientific(my_float)` (or whatever)
[07:05:19] <dbaupp> (as an idea.)
[07:05:52] <acrichto> graydon: so that big string is the format string, and then there's an integer argument passed in which selects which one should be chosen, but the format string is selected at runtime?
[07:05:52] <graydon> acrichto: note that those _both_ represent a single formatting specification for a number. one is just a better message (and in some languages, "better message" may be mandatory in order to avoid looking completely ridiculous)
[07:06:39] <graydon> acrichto: yes. the format string is selected by locale. and then _some_ format strings may wind up providing data-dependent branching-logic inside the string.
[07:06:53] <graydon> but we will only discover which ones at runtime, when the locale hands us back a string
[07:06:55] <graydon> that has branching logic in it
[07:07:02] <graydon> (for some language we presumably don't even speak)
[07:07:10] <graydon> there's no way the programmer can forsee these rules
[07:07:50] <graydon> acrichto: that email i sent has pointers to prior art that's considered more or less "the way you do it" in terms of interface design now by i18n people
[07:07:55] <acrichto> so you first translate a format string, and it's guaranteed that the format string has the same number of variables (things to print) as the original format string, it's just that some format strings could have some funky logic while others don't
[07:08:07] <graydon> https://github.com/SlexAxton/messageformat.js is a minimal implementation
[07:08:34] <graydon> it's not guaranteed the format string has the same number of variables. it might ignore some. but it has ... well, at least a proper subset of the set of variables.
[07:08:57] <graydon> (it might also pick them in a different order than you thought, so using {1}, {2}, {3} etc. is better for this reason)
[07:09:15] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[07:09:20] <acrichto> would it still be possible to validate at compile-time?
[07:09:31] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[07:09:39] <acrichto> you'd have to ensure each format string when translated was another valid format string
[07:09:43] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:09:54] <graydon> I think possibly so. or at least, I think you could do this:
[07:09:56] *** Quits: victorporof (victorporo@AF497F7E.60E0D239.9B1E38F4.IP) (Quit: victorporof)
[07:10:19] <graydon>  - derive a type signature at compile time that the args must match
[07:10:43] <graydon>  - derive a translation-string-verifier at runtime that, if handed a non-conforming string, will switch back to the one that was compiled-in originally
[07:11:50] <graydon> so if you ask for a translation of "there are {1,number} file(s)" and it makes reference to 12 arguments, all strings, you can say "that's nice translator but there is only a single numeric argument incoming so I will not bother trying to format your string, and go back to the one I found in the source code"
[07:12:10] <graydon> does that make sense?
[07:12:22] <acrichto> kinda yeah, the implementation seems like it would be difficult
[07:12:43] <acrichto> if each fmt! generated a validator function that would generate a lot of extra code real fast
[07:13:27] <graydon> I don't think it needs to be a validator _function_
[07:14:03] <graydon> you were going to pass the string down to the formatting engine for runtime interpretation, yes?
[07:14:35] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[07:15:09] <acrichto> so this would be a generic function that takes a valid formatting string, the translated formatting string, and if they both agree on what kind of arguments each takes (both types and positions), then uuse the translated format string, otherwise use the original
[07:15:18] <acrichto> generic function as in implemented in a library
[07:15:35] <graydon> so you'd just, in ifmt!(), have it call a runtime interpreter that asks gettext() for a translation of the string, makes sure the translation takes a subset of the (typed) variables specified in the original string, and uses either the translation (if it's ok) or the original (if it's not) either way 
[07:15:48] <graydon> yes
[07:15:59] <acrichto> oh excellent
[07:16:16] <acrichto> so for designing fmt!, it basically needs to be able to support whatever operations i18n needs
[07:16:23] <acrichto> which includes things like conditionals, switches, etc.
[07:16:33] <acrichto> simply as a building block for i18n later on
[07:16:44] <graydon> in designing the format-language you mean?
[07:16:49] <acrichto> yeah
[07:18:04] <graydon> really no need to get creative. the unicode CLDR folks have really nailed down the problem space. that messageformat.js thing I mentioned above is quite ... it's like a couple decades of struggling with the problem.
[07:18:53] <acrichto> so we essentially want to have the same format-string language as one of those which already exists
[07:20:38] <graydon> I think .. pretty close to one. I posted a few examples of languages that have made variants of {}-style in the lib-fmt page
[07:21:47] <acrichto> graydon: this page https://github.com/mozilla/rust/wiki/Lib-fmt ?
[07:21:56] <graydon> yeah, I'm just updating it
[07:22:02] <graydon> because I realize now those are not so clear-cut
[07:22:28] <graydon> since I made those notes my sense of the problem space has sharpened and I think the MessageFormat style (used by java and ICU) is important to handle for just this reason
[07:23:51] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[07:24:13] <acrichto> graydon: do you know if there's a page which has just a spec of the messageformat.js syntax?
[07:25:02] <graydon> the java pages are pretty concise, sec.
[07:25:16] <graydon> http://docs.oracle.com/javase/1.4.2/docs/api/java/text/MessageFormat.html
[07:25:43] <graydon> erk, no, sorry
[07:25:55] <Yurume> rusti: let x = std::str::from_bytes([0xe0, 0x80, 0x80]); let y: ~[char] = x.iter().collect(); println(fmt!("%?", y));
[07:25:56] -rusti- ~['\x00']
[07:25:56] -rusti- ()
[07:26:12] <Yurume> overlong UTF-8 sequence FTW?
[07:26:14] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[07:26:17] <graydon> http://www.icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html
[07:26:33] <Yurume> oh, there it is: https://github.com/mozilla/rust/issues/3787
[07:27:01] <acrichto> graydon: perfect, also would you be opposed to supporting both {} and % forms?
[07:27:01] <graydon> acrichto: ^^ that's the canonical reference I think?
[07:27:16] <acrichto> or perhaps that's just too much going on
[07:27:36] <graydon> acrichto: I don't think it'll work well to do so, but if there's an obvious way ...
[07:27:51] <graydon> acrichto: (keep in mind that format string reference above has 3 sub-pages)
[07:27:51] <ChrisMorgan> Who is Doug Kearns?
[07:28:46] <dbaupp> Yurume: that's not even close to the worst problem with our utf8 :P
[07:29:16] <Yurume> dbaupp, what's worse?
[07:29:17] <dbaupp> rusti: let mut s = ~""; s.push_char((-1) as char); s
[07:29:18] -rusti- rust: task failed at 'assertion failed: c as uint <= 1114111', /build/rust-git/src/rust/src/libstd/str.rs:2089
[07:29:18] -rusti- rust: domain main @0x1a27100 root task failed
[07:29:18] -rusti- application terminated with error code 101
[07:29:39] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[07:29:41] <dbaupp> Yurume: we can freely make a char with any code-point value
[07:29:58] <dbaupp> (I guess push_char is resistant to it though, which is nice.)
[07:30:11] <Yurume> hmm.
[07:30:20] <acrichto> graydon: well this seems a bit more difficult to use than printf-style formatting. For the everyday use case when you just want to print values now you have to do "{N, type}" whereas before it was just %X with an implicit ordering. That seems like a bit of a drawback?
[07:30:37] <graydon> I think you can just do {n} and it'll call a default for the type
[07:30:45] <graydon> and I think you can also do {} and it'll do "the next one"
[07:31:07] <acrichto> I guess that wouldn't be too bad
[07:31:07] <Yurume> dbaupp, IMHO `as char` conversion is similar to `as u8` (or similar) that both require some strategy for out-of-range values
[07:31:10] <graydon> so like fmt!("there are {} files", v) ought to work
[07:31:41] <graydon> which is, 90% of the time, going to show something quite reasonable.
[07:31:49] <Yurume> although for `char` simple masking doesn't work
[07:31:50] <dbaupp> Yurume: yeah, I think `as char` is non-sensical though, we should just have char::from_uint(x) or something.
[07:32:03] <dbaupp> rusti: 'a' + ' '
[07:32:04] -rusti- '\x81'
[07:32:12] <Yurume> that is either pos... WHAT?
[07:32:22] <dbaupp> rusti: 'a' * ' '
[07:32:23] -rusti- '\u0c20'
[07:32:30] <Yurume> haha
[07:32:35] <aatch> one thing that we should do is stop characters from being integer expressions.
[07:32:40] <dbaupp> rusti: 'a' << '\x10'
[07:32:40] -rusti- '\U00610000'
[07:32:49] <acrichto> graydon: alright, thanks for explaining all this! This'll take longer than I initially anticipated, but it doesn't look too bad to implement, just some super-fancy parsing
[07:32:51] <Yurume> rusti: 'a' << '\x1f'
[07:32:51] -rusti- '\x00'
[07:33:05] <ChrisMorgan> Python documents its advanced string formatting well in PEP 3101.
[07:33:44] <ChrisMorgan> Anyone know who Doug Kearns is? I received an email from him suggesting that I submit the Rust Vim files to Bram Moolenar for inclusion in the upcoming 7.4 release, and before responding to him I'd prefer to know who he is. (Contributor, user, something else?)
[07:34:02] <graydon> acrichto: somewhat, yeah
[07:34:11] <graydon> ChrisMorgan: I don't know
[07:34:30] <aatch> in the AST, we have a ty_char variant under the `int_ty` enum. So not only is 'char' considered an integer, it's a signed integer to boot.
[07:34:33] <dbaupp> ChrisMorgan: google suggests he's the maintainer of a ruby mode
[07:34:42] <graydon> nobody with that name in the git logs or AUTHORS.txt
[07:34:45] <dbaupp> ChrisMorgan: (among other things, maybe.)
[07:34:58] <dbaupp> aatch: it's awesome.
[07:35:33] <aatch> dbaupp, we have characters that in most respects are treated identically to u32
[07:35:37] <aatch> i32*
[07:35:54] <Luqman> the Region bit of ty::AutoBorrowVec indicates the Region being converted *from* right?
[07:36:04] <aatch> rusti: 'a' as i32
[07:36:05] -rusti- 97
[07:36:11] <ChrisMorgan> I know he's a Pentadactyl developer, but not much more than that.
[07:36:12] <dbaupp> aatch: yup, so we should just remove i32. characters are far more human readable (by definition).
[07:36:18] <aatch> rusti: -('a') as i32
[07:36:18] -rusti- -97
[07:36:31] <aatch> rusti: -('a')
[07:36:32] -rusti- '\x9f'
[07:36:38] <aatch> WHY
[07:36:48] <aatch> rusti: !('a')
[07:36:49] -rusti- '\x9e'
[07:37:02] <aatch> rusti: !('a') & -('a')
[07:37:02] -rusti- '\x9e'
[07:37:10] <aatch> rusti: !('a') ^ -('a')
[07:37:10] -rusti- '\x01'
[07:38:51] <graydon> acrichto: the python format strings are, as ChrisMorgan points out, also pretty fancy: http://docs.python.org/3/library/string.html#formatstrings
[07:39:01] <ChrisMorgan> And http://www.python.org/dev/peps/pep-3101/
[07:39:09] *** Quits: slaren (slaren@moz-89461CF2.red-83-38-70.dynamicip.rima-tde.net) (Ping timeout)
[07:39:18] <graydon> as are the old common lisp ones http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm
[07:41:15] <acrichto> there's definitely a lot of directions this can go...
[07:41:46] <graydon> I think there's probably leeway in the "how to format numbers most pleasantly" design sub-dimension. I left links to the leading systems in the lib-fmt page
[07:43:26] <graydon> C# has good stuff too. basically you need to be able to do plural and gender switching in messages; and then the message has to have a few specifier-codes that punt back to a few default "stock" culture-specific formatting routines for dates and times, currency, and large values with place-separators
[07:43:49] <graydon> like you don't want every translator having to put the entire ruleset for "how to format dates in my language" in every message
[07:44:05] <graydon> so they have to be able to say {1:date} to get a date stuck in there
[07:44:07] <graydon> or something
[07:45:05] <acrichto> this {} syntax is kinda growing on me
[07:45:06] <graydon> I figure if microsoft, IBM, oracle and google can agree on the shape of the problem and solution space, it's likely a pretty solid consensus.
[07:45:17] <acrichto> yeah that's a good point :)
[07:46:00] *** Joins: slaren (slaren@moz-F50885B.red-88-18-148.staticip.rima-tde.net)
[07:47:08] <graydon> ok, it's super late and I have another branch to land since I promised cmr
[07:54:44] *** Joins: zebr (zebr@moz-87CB2D2A.kent.ac.uk)
[07:55:06] *** Joins: victorporof (victorporo@3A55AFE3.1C233438.79933D60.IP)
[07:56:18] <zebr> hi all. a newbie question - if this is the right place. i have s : ~str, and i want in two places to assign to it (1) literal "y", and (2) args[1]. i get a type error. how would i fix that?
[07:56:21] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[07:56:44] <zebr> alternatively, is there a link that explains how to convert between different pointer types and all that?
[07:59:22] <graydon> comments on reorganizing the mess of compile_upto in the driver welcome: https://github.com/mozilla/rust/pull/8077
[07:59:30] <graydon> (anyone who's used the driver, it's pretty horrible)
[07:59:39] <graydon> zebr: hi
[07:59:46] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[08:00:16] <graydon> zebr: (1) call "y".to_owned()
[08:00:57] <graydon> zebr: (2) args[1].clone()
[08:01:10] <graydon> (or args[1].to_owned(), it should be a no-op?)
[08:02:01] <graydon> zebr: converting between different pointer types is not always possible. you have to think a bit about what you're doing. there's no way to convert (say) a cyclic type to an acyclic one, and many types have their ownership model baked firmly into them (eg. the contents of hashmaps is going to be owned by the hashmap, not @-shared with clients)
[08:02:29] <graydon> but for strings (and some other cases) the methods you want are usually .to_owned(), .to_managed()
[08:02:42] <graydon> borrowing (forming an &-ptr from a ~ or @) happens automatically
[08:02:44] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:02:47] <graydon> that's the whole point of borrowing
[08:02:59] <graydon> it's a temporary hold on a pointer owned by some other slot
[08:03:00] *** Joins: nano (nano@moz-972880B.superkabel.de)
[08:03:04] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:03:09] <graydon> zebr: does that help?
[08:04:40] <zebr> graydon: that does, thanks. wrt borrowed ptrs, is it possible to convert ~str -> &str? that seems like an alternative solution, but autoborrowing seems to get me &~str.
[08:05:01] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[08:05:24] <graydon> auto-borrowing happens without applying the &-operator
[08:05:28] <graydon> & is explicit borrowing
[08:05:39] <graydon> you can explicitly borrow it like &*s
[08:05:53] <graydon> but the auto borrow would be like "let x : &str = s;"
[08:06:04] <graydon> i.e. just provide the type context of needing-a-borrow
[08:06:19] <graydon> and the ~ or @ will be borrowed when in an auto-borrow context
[08:06:31] <graydon> (method arguments at least, I _think_ assignment RHSs as well, but I never remember)
[08:06:49] <graydon> auto-borrow is designed for method arguments. especially self, on objects that take &self
[08:07:38] <zebr> hmm, the assignment 's = args[1]', where args : ~[~str], seems to expect &str but find ~str.
[08:07:42] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[08:08:10] <graydon> you can't move out of a ~[~str]
[08:08:13] <graydon> that would leave a hole behind
[08:08:26] <graydon> I'd need to see the code
[08:08:27] <graydon> gist it?
[08:08:35] <zebr> sure, one second
[08:08:40] <graydon> (actually .. I'm kinda falling asleep, but .. I'll try)
[08:08:49] <graydon> it's 1am here. 10pm is my normal bedtime.
[08:08:58] <graydon> yay coding on a friday night (sigh)
[08:09:13] <zebr> ah ^^; don't worry if you're too tired. the code's pretty simple, though. (i've only just started.)
[08:09:18] <zebr> graydon: http://sprunge.us/DKIG
[08:09:48] <zebr> i suspect i'm drastically misunderstanding something
[08:09:57] <Eridius> zebr: it's expecting &str because `s = "y"` assigns &'static str to s
[08:10:01] <Eridius> you want `s = ~"y"` in that case
[08:10:09] <Eridius> well also, you declared s to be &str
[08:10:29] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[08:10:36] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[08:10:45] <zebr> ahh, ok, it works if i add that ~ and put it back as a ~.
[08:11:08] <Eridius> the assignment from args[1] is fine because args is owned locally and never referenced again
[08:11:38] <aatch> zebr, try doing let s = match args.len() { ... } and instead of doing `s == <expr>` just have `<expr>`
[08:11:39] <Eridius> if you add, say, `println(args[0]);` after the match, you get "error: use of partially moved value: `args`"
[08:12:18] <aatch> (I mean `s = <expr>`)
[08:12:40] <zebr> aatch: oh, you can do that? nice, i always miss that in C.
[08:12:51] <Eridius> OwnedStr really needs an .as_slice() method
[08:13:03] <aatch> Eridius, has one.
[08:13:08] <graydon> it has one
[08:13:10] <Eridius> where?
[08:13:19] <Eridius> oh gee it's on Str, not OwnedStr
[08:13:28] <graydon> https://gist.github.com/graydon/c62b7b3c251a566096e6 works
[08:13:33] <aatch> rusti: let a = ~"string"; println!(a.as_slice());
[08:13:33] -rusti- <anon>:7:28: 7:35 error: macro undefined: 'println'
[08:13:33] -rusti- <anon>:7          let a = ~"string"; println!(a.as_slice());
[08:13:33] -rusti-                                      ^~~~~~~
[08:13:33] -rusti- application terminated with error code 101
[08:13:39] <aatch> rusti: let a = ~"string"; print!(a.as_slice());
[08:13:39] -rusti- <anon>:7:28: 7:33 error: macro undefined: 'print'
[08:13:39] -rusti- <anon>:7          let a = ~"string"; print!(a.as_slice());
[08:13:39] -rusti-                                      ^~~~~
[08:13:40] -rusti- application terminated with error code 101
[08:13:45] <graydon> as does leaving out the & on &"y"
[08:13:49] <graydon> that's autoborrow
[08:14:06] <aatch> rusti: let a = ~"string"; println(a.as_slice());
[08:14:07] -rusti- string
[08:14:07] -rusti- ()
[08:14:18] <graydon> zebr: generally &*(args[1]) would also work but str is a dynamic sized type, not a normal type. this will be fixed at some point, likely.
[08:14:26] <Eridius> rusti: let a = ~"string"; printfln!(a.as_slice())
[08:14:27] -rusti- "string"
[08:14:27] -rusti- ()
[08:14:47] *** Joins: xraycat (Adium@moz-3D118ADE.pool.mediaways.net)
[08:14:47] <graydon> zebr: anyway https://gist.github.com/graydon/c62b7b3c251a566096e6 works
[08:15:33] <graydon> gotta head to bed. 'night all
[08:15:41] *** Quits: graydon (graydon@moz-F14EE0DB.cable.teksavvy.com) (Quit: Leaving.)
[08:15:42] *** Joins: nano (nano@moz-972880B.superkabel.de)
[08:20:41] *** Joins: farnoy (farnoy@moz-526BE964.neoplus.adsl.tpnet.pl)
[08:25:39] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[08:26:34] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:30:14] *** Joins: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net)
[08:31:08] <farnoy> hi, can a function that's given a borrowed pointer with certain lifetime return a newly created object with the same lifetime?
[08:33:48] <Eridius> farnoy: how would it construct a new object, and return a borrowed pointer to it? The new object wouldn't be owned by anything
[08:34:13] <Eridius> I mean, maybe you could construct an @-box and borrow from that? But I don't know if that would actually work
[08:34:39] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[08:34:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gylxjw
[08:34:39] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[08:34:47] <sebcrozet> Eridius: It wont work since the lifetimes wont match.
[08:35:00] <Eridius> sebcrozet: well you could unsafely transmute the lifetime
[08:35:17] <Luqman> rusti: struct Foo { x: int } fn foo<'a>(f: &'a Foo) -> &'a int { &'a f.x } let x = Foo { x: 21 }; foo(&x)
[08:35:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fGJU
[08:35:57] <sebcrozet> Eridius: but thatâ€™s uggly.
[08:36:05] <Eridius> rusti: struct Foo { x: int } fn foo<'a>(f: &'a Foo) -> &'a int { &'a f.x } let x = Foo { x: 21 }; printfln!(foo(&x))
[08:36:06] -rusti- &21
[08:36:06] -rusti- ()
[08:36:29] <aatch> sebcrozet, what's the problem?
[08:36:30] <Eridius> this only works because you're returning a field of self. Which isn't what farnoy asked for, they wanted a brand new object
[08:37:18] <aatch> It depends on what you're asking for... Lifetime here can mean either &'r foo, or Foo<'r>
[08:37:25] <farnoy> well, motivation is, that I want one object to have a c++ style const& to another
[08:37:33] <farnoy> but I'm not sure how it can be done in rust
[08:37:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[08:37:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/lsEedg
[08:37:37] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[08:37:40] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[08:37:40] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/6_135g
[08:37:40] <ghrust> 13rust/06auto 1484eac6b 15James Deng: ast::Lifetime contains ast::Name instead of ast::ident.
[08:37:40] <ghrust> 13rust/06auto 1425ea625 15James Deng: Rewrite an expansion of quote_item to manual ast construnction.
[08:37:40] <ghrust> 13rust/06auto 14f576d07 15James Deng: Added a note about the deletion of a quote_item.
[08:37:42] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[08:37:42] <aatch> farnoy, very likely can't
[08:37:58] <aatch> farnoy, C++ lets you get away with some terrible things.
[08:38:12] <farnoy> brb
[08:38:20] <sebcrozet> aatch: doesnâ€™t transmuting a @-box to a &'r pointer breaks some garbage-collection stuffs?
[08:38:42] <aatch> sebcrozet, yes, it also won't work because the runtime representations are different
[08:39:06] <Eridius> sebcrozet: I was suggesting you borrow the @-box first, and then merely transmute the lifetime of the resulting pointer
[08:39:35] <aatch> an @-box has 4-word header before the actual data.
[08:41:09] <Eridius> rusti: fn foo<'a, T>(v: &'a T) -> &'a int { let x = @5; unsafe { std::cast::transmute_region(&*x) } } let x = (); printfln!(foo(&x))
[08:41:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jdGH
[08:41:23] <Eridius> ok so it doesn't even work
[08:41:54] <Eridius> I guess the caller doesn't know that the pointer is borrowed from a @-box so it can't return it
[08:42:05] <Eridius> I'm glad that rustc can actually catch that though
[08:42:36] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[08:43:23] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[08:44:33] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:46:30] *** Joins: heftig (heftig@6573ED45.9A77AED9.3663C14F.IP)
[08:47:04] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[08:49:37] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[08:49:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14261a52e to 14c519474: 02http://git.io/N3iJvQ
[08:49:37] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[08:49:39] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[08:49:39] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/VQZZIA
[08:49:39] <ghrust> 13rust/06auto 1461e741c 15Luqman Aden: libstd: Implement {peer, socket}_name for new rt tcp & udp.
[08:49:39] <ghrust> 13rust/06auto 14ac40d53 15Luqman Aden: libstd: Fix errors when rtdebug! is not a noop.
[08:49:40] <ghrust> 13rust/06auto 14e2bb32b 15Luqman Aden: libstd: Handle IPv4-Mapped/Compatible IPv6 addresses.
[08:49:42] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[08:54:44] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[08:54:55] <farnoy> so if I want one object to have a reference to some parent object, then @Parent is the way to go?
[08:55:41] <farnoy> and if only Parent can construct a Child, I would need the method in Parent to have a @self receiver?
[08:56:08] <farnoy> doesn't this lead to restricting types to be usable only when created in the managed box?
[08:57:27] *** Quits: darithorn_ (darithorn@moz-97BAE36D.dhcp.knwc.wa.charter.com) (Quit: Konversation terminated!)
[08:59:04] <aatch> dbaupp, I have a benchmarking tool!
[08:59:24] <Luqman> farnoy: do you mean something like this? https://gist.github.com/luqmana/b265a600d6e5a23a13de
[09:00:16] <farnoy> Yes, does this work like that? and does the compiler check the lifetime of the returned Child object?
[09:01:30] <farnoy> so it doesn't outlive the Parent? in the caller of the function?
[09:02:58] <Luqman> farnoy: yes, so for example this fails https://gist.github.com/luqmana/6094308
[09:03:28] *** Joins: Ms2ger (Ms2ger@E39D6ADF.6D359A20.187A1082.IP)
[09:03:49] <aatch> dbaupp, The shortest gap between two samples is <6us
[09:04:21] <farnoy> Luqman, this is perfect and exactly what I was looking for, thank you
[09:10:02] *** Quits: KindOne (KindOne@moz-43947C0.dynamic.ip.windstream.net) (Ping timeout)
[09:10:07] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Client exited)
[09:10:57] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[09:12:33] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:13:56] *** Joins: KindOne (KindOne@420E3FC9.B11A32F.EC6A1518.IP)
[09:16:47] <Luqman> r? https://github.com/mozilla/rust/pull/8078
[09:19:27] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[09:24:19] <aatch> Luqman, done
[09:24:53] <doener> for the unknowing me, why is that the right thing to do?
[09:25:42] <doener> (would be awesome if the commit message told me ;-))
[09:28:53] <aatch> doener, I know why, I'm just trying to find the words.
[09:29:00] <doener> heh
[09:29:26] <doener> my usual feeling when writing a commit message
[09:29:33] <aatch> basically, it didn't treat &[T] and [T] differently.
[09:29:51] <aatch> (~[T] and @[T] don't matter because they aren't constant expressions)
[09:29:55] <doener> (except for the cases where thinking about it makes me realize that I actually have no clue)
[09:30:16] <doener> (... and probably messed things up)
[09:30:30] <aatch> more accurately, it treated &[T] like [T], so it wrapped &[T] in the slice structure.
[09:31:00] <aatch> this makes sure to only do it to [T], since &[T] is already a slice.
[09:31:39] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[09:36:58] *** Joins: nano (nano@moz-972880B.superkabel.de)
[09:39:41] <kemurphy> hm, i think it is time to stop trying to make this work tonight
[09:39:55] * kemurphy just wrote debug!("ring ring motherfucker")
[09:40:39] <Luqman> aatch: thanks
[09:43:56] <doener> ok, to make sure I got that right, it's basically: "Fix auto borrowing of static slices in constant expressions. --- When borrowing a vector in a constant expression, we have either a constant vector or a slice that we're borrowing from. When we already have a slice, we must not try to wrap that in yet another slice, it already is one and can be used as is." Yeah?
[09:44:12] <Luqman> doener: yep
[09:44:36] <Luqman> finding the right words to describe that is hard at 5 in the morning :P
[09:44:46] <aatch> (I tried to fix it a while ago, but the auto-ref stuff confused me so I gave up)
[09:45:13] *** Parts: vegai (vegai@moz-84E87CA5.kapsi.fi) ()
[09:45:43] <Luqman> anyways, off to bed now
[09:45:51] <doener> Luqman: good night
[09:51:46] <doomlord_> heh i tried use foo::*::*; but it doesn't like that 
[09:52:10] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[09:52:41] <farnoy> so it doesn't outlive the Parent? in the caller of the function?
[09:52:50] <farnoy> wrong, sry
[09:53:21] <farnoy> why can't we, having ~Test:Send, invoke methods on Test that take &mut self?
[09:54:37] <aatch> farnoy, you can. As long as the owner is mutable.
[09:54:37] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[09:56:24] *** Joins: Guest (textual@moz-A3295542.nycmny.fios.verizon.net)
[09:57:12] <farnoy> aatch, and who would be the owner here? https://gist.github.com/farnoy/209fb3969196f9191223
[09:57:52] <aatch> farnoy, `t`. In the argument list, put `mut t` instead of just `t`
[09:58:45] <farnoy> aatch, thank you, was not aware of this in function parameters
[09:58:56] <aatch> farnoy, no problem
[09:59:08] <aatch> It didn't actually work until fairly recently
[09:59:31] <aatch> so you'd see a lot `let mut foo = foo` at the beginning of some functions.
[10:00:51] <Klaufir_> "The ~ sigil represents a unique handle for a memory allocation on the heap", why is this under the "Destructors" section in the tutorial?
[10:05:54] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[10:09:48] <farnoy> aatch, can Send trait affect method resolution? I keep getting "type `~A:Send` does not implement any method in scope named `test`
[10:10:02] <farnoy> test's signature is fn update(&mut self, time: uint);
[10:10:36] <aatch> farnoy, huh? Are you calling `test` or `update`?
[10:10:38] <farnoy> fn name should be test instead of update
[10:10:49] <farnoy> let's call it test here, bad copying on my part
[10:11:19] <aatch> the Send bound won't make a difference btw.
[10:11:37] <aatch> is this all in the same module?
[10:12:21] <farnoy> no, two separate, but I'm importing it with `use module_name::*`
[10:12:44] <doener> hm, type ~A:Send can only call methods of Send
[10:12:56] <aatch> farnoy, is `~A` a trait object?
[10:13:09] <farnoy> aatch, yes, it is
[10:13:18] <farnoy> forgot t o mention, sorry
[10:13:21] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:13:24] <aatch> so `A` is a trait?
[10:13:29] <farnoy> yes
[10:13:55] <doener> oh, took that as a type parameter
[10:13:56] <aatch> ok, try importing the `A` trait explicitly.
[10:14:53] <farnoy> aatch, replaced `use module_name::*` with `use module_name::A`, still the same
[10:15:06] <aatch> farnoy, is the method `pub`?
[10:15:31] <farnoy> aatch, the trait is pub, the method inside is not
[10:15:58] <aatch> doener, have there been any signficant memory improvements in the past few days?
[10:16:37] <doener> aatch: according to irfy there was one in a rollup PR
[10:16:43] <doener> http://huonw.github.io/isrustfastyet/mem/#766eb95,f132401
[10:16:51] <aatch> doener, I saw, but after that.
[10:17:03] <farnoy> aatch, A is a trait composed of few others in the module (all public traits), could that affect it?
[10:17:35] <aatch> doener, because I'm getting ~600M peak usage for compilation
[10:17:43] <doener> o.O
[10:17:44] <aatch> farnoy, possibly.
[10:18:28] <aatch> doener, exactly
[10:19:17] <farnoy> aatch, yes, changing it to use a single trait, not a compound one works
[10:20:19] <farnoy> is this intended or a bug? will casting to a certain sub trait of A and then using the method `test` bite mi further?
[10:20:35] *** Quits: kertap (kertap@moz-D50677C9.b-ras3.mvw.galway.eircom.net) (Quit: kertap)
[10:20:42] <aatch> farnoy, how old is your version of rustc?
[10:20:51] <farnoy> aatch, 0.7 release
[10:20:59] <aatch> There were a ton of bugs related to traits that were fixed very recently
[10:21:32] <farnoy> aatch, compiled latest from git, but it gave me errors about `std` crate not found
[10:22:02] <farnoy> displayed some info about ambiguous paths when gave it -L, but both were exactly the same
[10:22:18] <aatch> farnoy, did you try doing a make clean first?
[10:22:50] <farnoy> aatch, it was a clean clone, configure && make
[10:22:59] <aatch> farnoy, that's very odd.
[10:23:58] <farnoy> aatch, error from the compileer here https://gist.github.com/farnoy/dfcdebe69f2a021c07f0
[10:23:59] <aatch> for those interested in what it looks like when I stop caring about code quality: https://github.com/Aatch/grease-bench
[10:25:42] <doener> aatch: hm, nothing obvious stands out since the last IRFY sample that would explain the drop
[10:25:55] <aatch> doener, that's what I was thinking.
[10:26:41] <doener> though maybe it was just a stupid cycle somewhere that got eliminated by accident
[10:26:49] <doener> well, a happy little accident ;-)
[10:28:02] <aatch> I'm also wondering if cmr's script is inflating the number. My benchmarking code only adds the child pid to the cgroup
[10:29:28] <doener> aatch: here, top reported RSS values that match cmr's values
[10:29:51] <doener> and yeah, master compiling librustc is up at 1.3G RSS right now
[10:30:02] <doener> 1 minute into the compilation
[10:30:25] <doener> stage 0 though, not quite the right thing... d'oh
[10:30:29] <aatch> doener, strange, because I was watching htop and it peaked at 600M.
[10:30:43] <doener> 64bit?
[10:30:48] <aatch> doener, yep
[10:31:06] <doener> well, let's see what stage 1 and 2 say
[10:31:36] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[10:33:11] <doener> stage1, up to 1G within the first few seconds
[10:34:38] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[10:34:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/VQZZIA
[10:34:38] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[10:36:52] <doener> same in stage2
[10:37:36] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[10:37:37] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/kQyIDw
[10:37:37] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[10:37:37] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[10:37:37] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/DixySA
[10:37:37] <ghrust> 13rust/06auto 14203f96f 15Michael Woerister: debuginfo: Implemented support for destructured locals....
[10:37:37] <ghrust> 13rust/06auto 14c9e51ce 15Michael Woerister: debuginfo: Support for function arguments. (WIP)
[10:37:37] <ghrust> 13rust/06auto 1402a0f28 15Michael Woerister: debuginfo: Support for destructured function arguments.
[10:37:39] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[10:37:56] <aatch> doener, well this is my graph (the sample rate isn't very good because otherwise I get too much data): https://docs.google.com/spreadsheet/oimg?key=0Ars-4P5Hlv0RdG5FRlFHWFptR2tiYVZLU0htVk9KQnc&oid=2&zx=sxgzqehigh2f
[10:38:31] <aatch> doener... I was compiling libstd...
[10:38:38] * aatch is an idiot
[10:39:40] * jensnockert hugs aatch.
[10:41:40] <aatch> And this time I got a peak of ~1.5G
[10:43:45] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Ping timeout)
[10:47:31] *** Joins: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP)
[10:48:56] *** Joins: farn (farnoy@moz-9F3E690F.neoplus.adsl.tpnet.pl)
[10:49:52] *** Quits: farnoy (farnoy@moz-526BE964.neoplus.adsl.tpnet.pl) (Ping timeout)
[10:51:05] *** Parts: farn (farnoy@moz-9F3E690F.neoplus.adsl.tpnet.pl) (Leaving)
[10:51:09] *** Joins: farn (farnoy@moz-9F3E690F.neoplus.adsl.tpnet.pl)
[10:51:30] *** farn is now known as farnoy
[10:52:41] <farnoy> aatch, pulled down most recent revision, `make` & still happens
[10:52:54] <farnoy> should I try make clean as you said?
[10:52:58] <aatch> farnoy, I got not idea then.
[10:53:24] <farnoy> I'm not installing it though, not sure if it changes anything
[10:54:36] <kimundi> farnoy: What happens?
[10:55:37] <farnoy> kimundi, https://gist.github.com/farnoy/dfcdebe69f2a021c07f0 on most recent revision
[10:56:28] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:56:36] <doener> aatch: why did you wrap TypeRef in Type instead of adding methods to TypeRef?
[10:57:18] <kimundi> farnoy: do you have a 'extern mod std' somewhere in test.rc or rsfml.rc?
[10:58:03] <farnoy> kimundi, only `extern mod extra` in rsfml.rc
[10:58:08] <aatch> doener, because I wanted to keep stuff separate from llvm as much as I could.
[10:58:11] <kimundi> hmm
[10:58:53] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[10:58:59] <farnoy> kimundi, if I remove extern mod rsfml (unused in my code), it still matches multiple crates `std`
[10:59:41] <farnoy> reconfigured with local PREFIX, maybe it's different somehow after installing
[10:59:55] <doener> aatch: k
[11:00:35] <kimundi> It's just strange because it complains about finding the same file twice... I'm guessing it's a bug somewhere thet causes it to link to std twice, but...
[11:00:47] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[11:01:44] <farnoy> kimundi, yeah, it is strange :D
[11:02:41] <kimundi> what exactly are you doing anyway? trying to compile rustc, or trying to compile something with rustc?
[11:02:59] * kimundi should maybe read scrollback...
[11:03:05] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[11:03:11] <farnoy> trying to compile something with locally compiled rustc
[11:03:31] <Ms2ger> Hmm, why is join called connect?
[11:04:30] <kimundi> Ms2ger: Usually because of conflicting method names due to bugs and/or different naming philosophies :P
[11:05:32] <kimundi> farnoy One thing I could still think of is that you're trying to link to rust libraries that have been compiled with an old version of the compiler
[11:05:45] <kimundi> but you said you removed all exter mod's?
[11:06:18] *** Joins: nano (nano@moz-972880B.superkabel.de)
[11:06:39] <farnoy> kimundi, yes, removed them a few minutes ago, after you were talking about rsfml
[11:07:41] <kimundi> hmm
[11:08:46] <kimundi> maybe try to 'sudo make uninstall', 'sudo make install' your rust installation?
[11:08:54] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:09:17] <farnoy> will do once `make` finishes
[11:09:35] <aatch> That's more like it: https://docs.google.com/spreadsheet/oimg?key=0Ars-4P5Hlv0RdEMyTTBXdVlXcl9rZ05yTHB1TllQOUE&oid=2&zx=jjzrqkynkyah
[11:11:01] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[11:16:02] *** Quits: Guest (textual@moz-A3295542.nycmny.fios.verizon.net) (Quit: Textual IRC Client: www.textualapp.com)
[11:20:36] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:24:13] <dbaupp> aatch: you have a benchmarker!
[11:24:31] <dbaupp> aatch: and it's pure Rust!
[11:25:15] <aatch> dbaupp, I do. currently it outputs a csv with the timestamp, memory usage and max memory usage
[11:25:33] <dbaupp> aatch: max memory usage at each sample point?
[11:25:41] <aatch> dbaupp, yep
[11:25:49] <dbaupp> ok
[11:27:02] <aatch> dbaupp, 
[11:27:04] <aatch> http://aatch.net/mem.csv
[11:27:11] <dbaupp> aatch: `File {     pub fn close(self) { } }`, that's awesome
[11:27:22] <aatch> dbaupp, it works...
[11:27:23] <dbaupp> aatch: oh, wow.
[11:27:45] <dbaupp> aatch: I know. destructors are cool. :D
[11:27:47] <farnoy> kimundi, ok, compiled&install. turns out my code does depend on rsfml, but it was designed for 0.7
[11:27:50] <aatch> dbaupp, that's with the adjacent combining.
[11:27:55] <farnoy> error: unresolved name `str::as_c_str`, is there a replacement?
[11:28:06] <aatch> dbaupp, without it, I get ~130MB of data.
[11:28:19] <aatch> farnoy, "str".as_c_str
[11:28:43] <farnoy> thanks, will replace & see if it compiles then
[11:28:48] <dbaupp> aatch: oh, cmr gets ~80000 samples for librustc
[11:28:58] <dbaupp> (i.e. 8x as much as that.)
[11:29:01] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:29:21] <dbaupp> (with the combining.)
[11:29:30] <aatch> dbaupp, that seems odd.
[11:29:40] <dbaupp> it does
[11:30:03] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[11:30:24] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[11:30:33] <dbaupp> aatch: $ python -c 'import json; print len(json.load(open("mem.json"))["memory_data"])' => 66468
[11:30:58] <dbaupp> (that appears to be a short one.)
[11:31:37] <aatch> dbaupp, hang on, how long does it take?
[11:31:51] <farnoy> aatch, kimundi I don't think method dispatching into compound traits does not work on edge
[11:32:03] <dbaupp> aatch: 209.35482587800652
[11:32:09] * dbaupp likes being precise
[11:32:14] <kimundi> farnoy: Hm?
[11:32:15] <farnoy> also, can't really cast a trait into a subtrait, so no workaround possible?
[11:32:33] <kimundi> traitobjects in general are still buggy
[11:32:33] <aatch> Hmm, not enough to make up the difference.
[11:32:59] <farnoy> should I report this?
[11:33:06] <aatch> dbaupp, do you have many samples during the LLVM codegen passes?
[11:33:17] <dbaupp> aatch: no idea?
[11:33:28] <aatch> because I get like 3
[11:33:36] <kimundi> sure, but a code snipped to show what exactly doesn't work would also be nice :)
[11:33:38] <dbaupp> aatch: which are the LLVM codegen passes?
[11:33:44] <dbaupp> aatch: (are you compiling with -O?)
[11:33:46] <aatch> dbaupp, that big long flat big.
[11:33:48] <aatch> dbaupp, I am
[11:34:01] <farnoy> kimundi, of course, will produce a simple example now
[11:34:05] <aatch> s/big/bit
[11:34:13] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[11:34:27] <dbaupp> aatch: irsy shows the passes, and it looks like there are several samples there.
[11:36:41] <dbaupp> aatch: estimating with some crappy python: 4K samples in that section
[11:36:47] <aatch> dbaupp, I get this: http://aatch.net/chart.html
[11:38:06] <dbaupp> aatch: looks very similar to http://huonw.github.io/isrustfastyet/mem/#766eb95
[11:38:27] <dbaupp> so I don't know... :(
[11:38:52] <aatch> dbaupp, I'm just thinking that the lack of samples is because my data is less noisy.
[11:39:12] <aatch> this is on my new desktop still so it's not swapping or anything like that.
[11:39:38] <dbaupp> hm, I don't think any of cmr's computers would've been swapping
[11:39:55] *** Joins: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net)
[11:40:48] <dbaupp> aatch: I guess we'll have to get cmr to test, so we have a comparison on the same computer
[11:41:13] <doener> error: found value name used as a type
[11:41:16] <doener> what does that mean?
[11:41:25] <dbaupp> aatch: (also, csv is most useful if it doesn't have spaces as a comma ;) )
[11:41:27] <aatch> dbaupp, yeah. There's a bunch of factors that could affect it.
[11:41:28] <dbaupp> *after the
[11:41:30] <doener> it complains about UseRef here: pub fn get_first_use(self) -> Option<UseRef>
[11:41:36] <doener> UseRef is a newtype struct
[11:41:50] <dbaupp> doener: I've seen that too... I can't remember how/why.
[11:42:06] <doener> err, a plain type.. I meant to put the Use newtype there
[11:42:16] <smvv> is there a irsy website? google gives no result (only rust prevention). i know there's a irfy website
[11:42:27] <dbaupp> smvv: same one
[11:42:31] <smvv> ok
[11:42:48] <dbaupp> ir-Slim-y: http://huonw.github.io/isrustfastyet/mem/ 
[11:43:03] <dbaupp> ir-Fast-y: http://huonw.github.io/isrustfastyet/buildbot/
[11:43:12] <dbaupp> although irfy is "deprecated"
[11:43:22] <smvv> ah i see :)
[11:43:29] *** Quits: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net) (Quit: jclements)
[11:43:31] <dbaupp> (i.e. irsy normally give more accurate timing data anyway.)
[11:44:17] <dbaupp> smvv: at the moment, the more interesting irsy is http://huonw.github.io/isrustfastyet/mem/old/
[11:44:37] <dbaupp> we're currently in the process of finding a new and longer term bench runner.
[11:44:38] <smvv> dbaupp: what makes it old?
[11:44:38] *** Joins: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[11:44:43] <smvv> ok
[11:44:51] <dbaupp> smvv: that computer is no longer usable
[11:45:26] <dbaupp> so we have to "chuck out" the result, at least, until I put some effort into making them cross-comparable.
[11:45:33] <dbaupp> *the old results
[11:47:40] <smvv> dbaupp: the graphs are a bit hard to read. have you considered using arewefastyet's graphs?
[11:47:55] <dbaupp> smvv: in what way?
[11:48:32] <dbaupp> (also, .../buildbot copied some of awfy's js/css ;P )
[11:48:34] <smvv> s/read/click/. there's only a small space where a line is clickable
[11:49:11] <farnoy> kimundi, what's the proper way to obtain a &Trait type from a struct that implements Trait?
[11:49:53] <smvv> dbaupp: on arewefastyet, you get visual feedback when you hover a data point in the graph (commit info)
[11:49:56] <dbaupp> smvv: yeah, I haven't really put much effort in usability; focusing on getting the data up there atm. (although, if you zoom in, you can click on the text hash which appears).
[11:50:07] <kimundi> farnoy: In theory, if `foo` is a type that inmplements `Trait`, then `&foo as &Trait` should do it
[11:50:10] <aatch> dbaupp, http://aatch.net/mem-c5194740.csv better?
[11:50:25] <dbaupp> smvv: yup, awfy was my inspiration.
[11:50:28] <kimundi> farnoy: In practice, it might not yet work properly
[11:50:37] <kimundi> because of bugs
[11:50:39] <dbaupp> aatch: heh, yeah :)
[11:51:06] *** Joins: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net)
[11:51:21] <dbaupp> aatch: (although, the max-memory-usage column seems a little pointless, cause it can be "trivially" computed from the other column?)
[11:51:58] <aatch> dbaupp, probably. I was worried about missing peaks, but I don't think that's going to be an issue.
[11:52:18] <dbaupp> aatch: yeah, I think cmr just reads from the cgroup max at the end
[11:52:55] <aatch> dbaupp, I was thinking of that too, but I wanted to keep the CSV format.
[11:53:23] <dbaupp> surprisingly, json is easier to read.
[11:53:31] <doener> can I match against * pointer NULL values?
[11:53:46] <aatch> doener, in a match { ... }?
[11:54:03] <farnoy> kimundi, should this work then? https://gist.github.com/farnoy/d778b9228076da0903ae
[11:54:09] <doener> aatch: yeah
[11:54:13] <dbaupp> aatch: because #[deriving(Decodable)] struct FooWithAppropriateFields {  ... } just works
[11:54:17] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[11:54:22] <doener> aatch: tried "0 as UseRef", but it complains about "as"
[11:54:35] <dbaupp> aatch: (I guess with #[deriving(Encodable)] we could share the schema too.)
[11:54:41] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[11:54:46] <dbaupp> doener: 'x if x == NULL' ?
[11:55:04] <dbaupp> aatch: unless you're trying to avoid extra?
[11:55:11] <aatch> doener, You could just have x.is_null()
[11:55:21] <kimundi> farnoy: It should work, yeah. But trait inheritance is another thing where there are still bugs ;)
[11:55:22] <aatch> dbaupp, extra is lousy with `@`
[11:55:22] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[11:55:38] <dbaupp> aatch: yeah
[11:55:46] <aatch> And I've managed to avoid the runtime completely so far.
[11:55:56] <dbaupp> yeah, I saw. pretty cool.
[11:56:08] <farnoy> kimundi, :<, I'll report this, thanks
[11:56:09] <kimundi> In this case it doesn't yet see the methods of supertraits even thoug it should
[11:56:14] <aatch> I think HashMap needs to not use the task-local rng though.
[11:56:33] <aatch> since I think it's the only thing that ties it to the runtime
[11:56:43] <dbaupp> or at least, the task-local rng shouldn't use @
[11:56:58] <aatch> dbaupp, but it's still task local
[11:57:07] <dbaupp> oh, right, runtime.
[11:57:08] *** Quits: homa_rano (edre@moz-223EA699.csail.mit.edu) (Ping timeout)
[11:57:09] <aatch> which means it still needs the runtime.
[11:57:11] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[11:57:17] <dbaupp> (task == runtime, yup)
[11:57:19] * dbaupp forgot
[11:57:29] <doener> dbaupp: yeah, that's good. Using "x if x != 0 as UseRef => Some(x), _ => None" now
[11:57:46] <dbaupp> doener: aatch suggested ptr.is_null(), which is better.
[11:58:20] <kimundi> farnoy: Curious, do you need traitobjects and trait inheritance right now, or are you just exploring the language?
[11:58:33] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[11:58:53] <farnoy> kimundi, I'm experimenting a bit, wanted to compose a trait from few others
[11:59:00] <farnoy> seemed like a clean solution to me
[11:59:10] <dbaupp> aatch: yeah, json doesn't use @, except for @~str for an error message (!) and the bloody std::io crap :/ ... so it's almost useable.
[11:59:21] <kimundi> It certainly would be, if it worked yet :D
[11:59:27] <dbaupp> aatch: it even uses TreeMap instead of HashMap now.
[12:00:00] <farnoy> yeah it would :D
[12:00:08] <doener> dbaupp, aatch: ah, nice. Using is_not_null in the guard now
[12:00:31] <dbaupp> doener: there's an is_not_null function as well as is_null? yuck
[12:01:07] <kimundi> farnoy: can you try using trait inheritance in a generic function? `fn foo<T: Test>() { ....}` and see if that finds method1 ?
[12:02:55] *** Joins: homa_rano (edre@moz-223EA699.csail.mit.edu)
[12:03:17] <farnoy> kimundi, will do
[12:04:01] *** Quits: xraycat (Adium@moz-3D118ADE.pool.mediaways.net) (Ping timeout)
[12:04:24] *** Joins: xraycat (Adium@moz-3D118ADE.pool.mediaways.net)
[12:09:11] <farnoy> kimundi, am I using generics wrong, because even basic traits don't work here https://gist.github.com/farnoy/39d43134b7c4f0ff3549 ?
[12:10:03] <kimundi> farnoy: yeah `fn generic<T: Method1Able>(a: &Method1Able) ` should be `fn generic<T: Method1Able>(a: &T) `
[12:10:45] <farnoy> kimundi, ah, right
[12:10:52] <farnoy> generics works for compound traits too
[12:12:46] <kimundi> so, trait inheritance is only buggy with trait objects atm... interesting
[12:14:13] <kimundi> farnoy: Are you aware of the difference betkeen trait objects and generics with trait bounds? (dynamic vs static dispatch, etc)
[12:14:26] <farnoy> kimundi, reported in https://github.com/mozilla/rust/issues/8079
[12:14:53] <farnoy> kimundi, I know from c++, when the compiler's sure about the type, it doesn't use the vtable, right?
[12:15:03] <farnoy> don't know how it works here exactly
[12:15:33] <dbaupp> farnoy: looks similar to https://github.com/mozilla/rust/issues/4100
[12:15:49] <kimundi> farnoy: In rust you basically can decide between static and dynamic by using generics or trait objects
[12:16:09] <dbaupp> farnoy: (in fact, I think they're identical, closing as a duplicate. :) )
[12:16:57] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:17:06] <farnoy> dbaupp, ok
[12:17:40] <farnoy> kimundi, so which is which? are generics like a type switch + static dispatch? or the other way around?
[12:17:53] <kimundi> generics have the advantage that they are faster because of static dispatch, but have the disadvantage that the generic type T is idertical everywhere in such a function.
[12:18:58] <dbaupp> farnoy: generic functions are monomorphised at compile time, so are entirely static dispatch
[12:19:16] <kimundi> trait objects allways use a vtable, which makes them dynamic dispatch. but they have the advantage that you can treat different types identical through their common interface.
[12:20:02] <farnoy> interesting
[12:20:11] <farnoy> let me rewrite everything to use generics :D
[12:20:18] <dbaupp> farnoy: i.e. each type you call a given generic function with gets its own specialisation of that function in the final binary.
[12:20:40] <kimundi> fn draw<T: Shape>(list: ~[T]) {...} // can be a list of Boxes that implement Shape, or a list of Circles that implement Sharp, but not a mix between them.
[12:20:50] <farnoy> I understand, it's just like c++ I guess
[12:21:23] <kimundi> fn draw(list: ~[&Shape]) {...} // can be a mixed list of any type that implements Shape
[12:21:48] <kimundi> Sorry, wanted to finish that example :P
[12:22:36] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[12:22:36] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DixySA
[12:22:36] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[12:23:05] <farnoy> and the generic one is check compile-time?
[12:23:32] <farnoy> so that ~[&Shape] does not work, but ~[&Circle] does?
[12:23:42] <farnoy> checked*
[12:24:12] <kimundi> Both would work if Circle is a type that implements trait Shape
[12:24:58] <dbaupp> farnoy: what do you mean by "checked"? both are type-safe
[12:25:11] <kimundi> a &Shape is just a fat pointer to a vtable+the underlying type (a Circle, Box or whatever else), while a &Circle is just a pointer to a Circle
[12:25:36] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[12:25:36] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/nC44LQ
[12:25:36] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[12:25:37] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[12:25:37] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FEOjjg
[12:25:37] <ghrust> 13rust/06auto 142a18c29 15Philipp BrÃ¼schweiler: syntax: fix span for obsolete extern visibility error
[12:25:37] <ghrust> 13rust/06auto 14ed20fcc 15bors: auto merge of #8060 : Blei/rust/fix-obsolete-extern-visibility-span, r=pcwalton
[12:25:37] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[12:25:53] <farnoy> but if I take ~[&Shape] as a parameter to a non-generic function, I can't pass it to fn draw<T: Shape>(), right?
[12:26:14] <farnoy> because the vector I've received in the function can contain a mix of Circles and Boxes?
[12:26:20] <kimundi> farnoy: Ah, that... Is a bit tricky
[12:26:31] <dbaupp> sometimes trait objects can implement their own trait... sometimes not.
[12:26:35] <farnoy> does the compiler refuse such action completely?
[12:26:44] <dbaupp> (at the moment, none do by default.)
[12:27:09] <dbaupp> farnoy: only because &Shape doesn't implement the Shape trait (by default)
[12:27:39] <dbaupp> rusti: trait Foo {} impl Foo for uint {} fn foo<T: Foo>(_: T) {} let x: uint = 1; foo(x)
[12:27:41] -rusti- ()
[12:27:47] <dbaupp> that's ok, but
[12:27:59] <dbaupp> rusti: trait Foo {} impl Foo for uint {} fn foo<T: Foo>(_: T) {} let x: uint = 1; foo(&x as &Foo)
[12:27:59] -rusti- <anon>:7:84: 7:87 error: failed to find an implementation of trait main::Foo for &main::Foo<no-bounds>
[12:28:00] -rusti- <anon>:7          trait Foo {} impl Foo for uint {} fn foo<T: Foo>(_: T) {} let x: uint = 1; foo(&x as &Foo)
[12:28:00] -rusti-                                                                                              ^~~
[12:28:00] -rusti- application terminated with error code 101
[12:28:08] <dbaupp> requiers
[12:28:10] <dbaupp> *requires
[12:28:17] <kimundi> farnoy: Basically, becausee a &Shape is a own type in it's own you can `impl Shape for &Shape`, and pass that to a generic function if you want.. The generic funtcion gets then specialised for the type &Shape, wich uses dynamic dispatch internally in it implementation
[12:28:25] <farnoy> so it's working, but not in the way best way?
[12:28:26] <dbaupp> rusti: trait Foo {} impl Foo for uint {} impl<'self> Foo for &'self Foo {} fn foo<T: Foo>(_: T) {} let x: uint = 1; foo(&x as &Foo)
[12:28:27] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AhdW
[12:28:29] <farnoy> is that what you're saying?
[12:28:59] <kimundi> farnoy: Depending on the trait it can work or it can not
[12:29:04] <dbaupp> rusti: trait Foo {} impl Foo for uint {} impl<'self> Foo for &'self Foo {} fn foo<T: Foo>(_: T) {} static x: uint = 1; let f = &x as &Foo; foo(f)
[12:29:05] -rusti- ()
[12:29:14] <dbaupp> so that also works ^
[12:29:16] <kimundi> I'm not sure if we currently dissalow it in general
[12:29:34] <dbaupp> kimundi: no trait objects implement their own trait by default at the moment.
[12:30:11] <farnoy> and the side effect of that is rejecting them for use with generic functions?
[12:30:13] <kimundi> is that "no trait objects do..." or "no, trait objects do..." ? :P
[12:30:15] <dbaupp> however, I'm pretty sure this can be restricted so that only traits mentioning the `Self` type don't implement themselves yet.
[12:30:51] <dbaupp> kimundi: the set of trait object automatically impl'ing themselves is empty
[12:31:06] <kimundi> ah okay, great
[12:31:07] <dbaupp> (err, s/ yet//)
[12:31:19] <dbaupp> farnoy: normally, yes
[12:32:00] <cmr> aatch: I only add the child PID to the cgroup as well
[12:32:03] <cmr> (I use cgexec)
[12:32:10] <dbaupp> farnoy: but the current restrictions are stronger than necessary, so in the future some traits may be useable with generic functions
[12:32:33] <dbaupp> cmr: https://github.com/Aatch/grease-bench
[12:32:37] <aatch> cmr, ok. As I said, I'm not sure what might cause it.
[12:33:00] <dbaupp> cmr: can you run it on your desktop, so we can compare output?
[12:33:25] <aatch> It should just compile with rustc, nothing fancy needed.
[12:33:33] <aatch> bench.rs is the "entry module"
[12:33:40] <cmr> aatch: no, none of the swap either
[12:33:55] <cmr> aatch: yes, I read the cgroup max at the end
[12:34:03] <cmr> ok that's the backlog
[12:34:24] <dbaupp> aatch: <3 pure rust
[12:34:36] <farnoy> dbaupp, kimundi but in the use case of a Manager that's drawing Entity-ies, it's not possible or even logical to make Manager generic, right?
[12:34:51] <dbaupp> farnoy: why not?
[12:35:09] <farnoy> wouldn't Entity be a complex trait?
[12:35:13] <kimundi> farnoy: Depends on how you model Entitities
[12:35:16] *** Joins: igl (igl@moz-9A09347.adsl.alicedsl.de)
[12:35:20] <dbaupp> if there was a Manager trait with a .draw_entity<E: Entity>(e: E) method, it should be fine?
[12:35:47] <dbaupp> (or, method on Entity with fn draw<M: Manager(m: M)
[12:35:55] <cmr> I miss .rc files
[12:36:09] <cmr> it was obvious which one was the crate file
[12:36:21] <dbaupp> cmr: rustpkg should solve that... main.rs etc.
[12:36:34] <kimundi> farnoy: If you modell Entitiy as "any type that implements Enitity", then yes your manager has to use trait objects either directly or indirectly through &Entity implementing Entity.
[12:36:37] <farnoy> dbaupp, kimundi, but does it give us performance, when (having .draw() on Entity) has to use dynamic dispatch, right?
[12:36:56] <dbaupp> farnoy: why does it have to use dynamic dispatch?
[12:37:15] <dbaupp> farnoy: (also, e.g. C++ uses dynamic dispatch for many things, so it can't be that slow.)
[12:37:24] <kimundi> farnoy: However, if your set of possible Entitys is limited, you could instead use enums to achieve the same without needing generics or trait objects
[12:37:30] <farnoy> because manager mixes circles and boxes
[12:37:32] <dbaupp> farnoy: this might be easier if we had a concrete code example to discuss :)
[12:37:36] <cmr> farnoy: parameterization (ie, <E:Entity>) is always static dispatch
[12:38:07] <aatch> The speed of dynamic dispatch depends somewhat on the implementation.
[12:38:14] <farnoy> but if we have hundreds of entities, we would need to instantiate Manager N times?
[12:38:24] <dbaupp> aatch: and Rust's?
[12:38:33] <aatch> dbaupp, vtables, so it's fast.
[12:38:36] <dbaupp> farnoy: depends on the implementation
[12:38:58] <dbaupp> aatch: you're comparing to python's hashtables, right?
[12:39:03] <dbaupp> (for example)
[12:39:13] <aatch> dbaupp, or java's double dispatch
[12:39:24] <dbaupp> aatch: oh
[12:39:25] <dbaupp> ?
[12:39:33] * dbaupp hasn't had to use Java much at all
[12:39:56] <aatch> dbaupp, double dispatch calls a method, which then figures out what method to call next. It's pretty mad.
[12:39:56] <doomlord_> ( entities for a game engine? in mamy situations the c++ vtables are quite a  bit slower than you'd expect , and many engines use alternatives.. sort by type.. for each type (process entities of that type) .. and breaking things up into components and handling the components in a homogeneous way)
[12:40:08] <dbaupp> aatch: sounds awkward
[12:40:23] <aatch> doomlord_, dammit, I was going to say that only game programmers worry about the speed of vtables.
[12:40:26] <doomlord_> (one reason for liking rust is it makes compile-time polymorphism more natural to write, less cluttered syntax for generics)
[12:40:31] <doomlord_> :)
[12:41:03] <farnoy> let's assume that `trait Entity { fn draw(&self /*, target: Whatever */); fn update(&self, time: uint) }`
[12:41:07] <farnoy> simple two functions
[12:41:08] <aatch> because it's mostly true. I've only ever seen game devs bitching about newbies putting `virtual` everywhere in C++ code.
[12:41:36] <doomlord_> heh. although rust trait objects fix the coupling problems that also make C++ classes breakdown for entities
[12:41:37] <farnoy> if we store `~[~Entity]` in the Manager and doing update() for every entity
[12:41:41] <farnoy> it's vtables here?
[12:41:48] <aatch> Nobody else cares, because as far as I can tell it's only a drain on optimization.
[12:41:48] <dbaupp> farnoy: yes
[12:41:51] <kimundi> right
[12:42:05] <farnoy> but if we use generics, then what happens?
[12:42:17] <aatch> (both compile-time optimization and runtime branch prediction/pipeline stalls)
[12:42:19] <farnoy> beside the binary that probably will grow by much
[12:42:19] <kimundi> than you can't express the same funtcion in this case
[12:42:20] <doomlord_> if you have class Car { Update(); Render() } .. your Car class now couples dependancy on physics & rendering systems , if you stick to "one class per file".. if you split the class between files, thats also messy
[12:42:36] <dbaupp> farnoy: then you can only store one type of entity per manager, but you don't have the vtable look ups
[12:42:38] <doomlord_> i think traits/impls will be better at that sort of organizational problem
[12:43:18] <farnoy> so generics can't really be applied here for Manager, when there's lots of Entity implementations
[12:44:13] <cmr> doomlord_: do traits easily express components a la component-based architecture?
[12:44:13] <dbaupp> cmr: you turned off the bencher overnight, right?
[12:44:17] <cmr> dbaupp: nope
[12:44:27] <dbaupp> cmr: oh... it hasn't updated at all.
[12:44:37] <cmr> ok, sounds like it exploded
[12:44:39] <dbaupp> cmr: it appears you had explosions
[12:44:39] <cmr> unfortunate :(
[12:44:40] <dbaupp> haha
[12:44:58] <dbaupp> farnoy: right
[12:45:28] <doomlord_> haven't thought that through yet, i'd guess they can, but in the above example, i think "trait Renderable" "trait Updateable" -->  impl Renderable for Car  ... impl Updateable for Car" is a step forward compared to C++
[12:45:59] <farnoy> and what happens when doing `match { .. }` on a complex enum?
[12:46:06] <farnoy> is it always a runtime typeswitch?
[12:46:06] <doomlord_> .. i think trait objects would make it easier to swtich between the same code being implemnted as runtime and compile-time polymorphism
[12:46:15] <farnoy> and by complex enum i mean one with tuples
[12:46:26] <dbaupp> farnoy: unless LLVM does some inlining & constant folding, then yes it's always a runtime switch
[12:46:57] <dbaupp> farnoy: although, it is on the enum discriminant (a plain old integer from 0 to number of variants), not some fancy type thing
[12:47:18] <farnoy> I've heard somewhere that JITing can optimie some vtable lookups, but I don't get it at all
[12:47:40] <doomlord_> cmr - on the subject of components based architecture, i was wondering about what i was trying to do with the AST, and my situation where i made a universal wrapper node .. is components analogous, i.e. i could avoid that by working from the Node ID and querying the whole AST object to get 'components' of the node instead...
[12:48:13] <doomlord_> ast->GetParentOf(nodeId)->nodeId  ast->GetNameOf(nodeId) ... that sort of thing
[12:48:23] <doomlord_> oops ast.get_parent_of(node_id) etc :)
[12:48:30] *** Joins: zoek (Mibbit@84A78AAC.5BB77DD2.3F0F84F7.IP)
[12:48:43] <dbaupp> farnoy: https://speakerdeck.com/dherman/rust-low-level-programming-without-the-segfaults#9 for a example of rust's enum layouts (next slide for the equivalent in C/C++)
[12:48:48] <cmr> doomlord_: yeah I think so, it makes sense
[12:48:59] <cmr> doomlord_: you'd basically need something like com's IUnkown though
[12:49:06] <aatch> cmr, any comments on my cgroups usage?
[12:49:08] <cmr> to take any given Node and ask it what it supports
[12:49:30] <doomlord_> right fair enough
[12:49:41] <aatch> I'm still finding my way around them.
[12:49:46] <doomlord_> ***resisting urge to NIH ast implementation **
[12:49:48] <farnoy> dbaupp, and enum in rust is the size of that discriminant + the size of the biggest tuple it can have??
[12:49:58] <dbaupp> farnoy: yup
[12:49:58] <farnoy> is of size* ...
[12:50:04] <aatch> farnoy, most of the time.
[12:50:16] <dbaupp> aatch: ?
[12:50:25] <aatch> but there are a few optimizations, like nullable-pointers
[12:50:32] <aatch> so Option<~T> is a single word.
[12:50:59] <dbaupp> right, it's at most discrim + max(variants) though
[12:51:10] <kimundi> Basically, the memory layout of an enum is unspecified so that the compiler can do optimisation that reduce the size of it.
[12:51:18] <doomlord_> trait HasSubNodes { .. fn visit_sub_nodes(&self); fn get_sub_nodes(&self)->~[nodeId]; }
[12:51:33] <aatch> enums are more-or-less implemented like tagged unions.
[12:51:39] *** Quits: xraycat (Adium@moz-3D118ADE.pool.mediaways.net) (Quit: Leaving.)
[12:51:56] <cmr> doomlord_: that'd be more easily expressed as `Container` than  HasSubNodes I think
[12:52:25] <zebr> hey. if i want an n-byte buffer (for read), do i have to use [0,..8192], or is there a nicer way?
[12:52:27] <doomlord_> fair enough.   trait NodeInterface { fn getContainer(&self)->Option<Container>;   fn .... } 
[12:52:57] *** Joins: true_droid (Adium@E3D4334F.209E8896.EBC99ECD.IP)
[12:53:13] <cmr> zebr: that is the nice way!
[12:53:31] <cmr> zebr: you could use &[u8] but that is of unspecified size
[12:53:39] <kimundi> zebr: I'd be baffled if the is a nicer way ;D
[12:53:55] *** Quits: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net) (Quit: jclements)
[12:53:59] <zebr> ah :p i was hoping there was a way that didn't require necessarily nullifying everything
[12:54:12] <cmr> oh, sure
[12:54:18] <kimundi> &mut [u8], but he still needs a [u8,..8192] or ~[u8] somewhere
[12:54:24] <cmr> you can use vec::with_capacity
[12:54:52] <cmr> or any variety of unsafe functions
[12:55:16] <kimundi> vec::with_capacity gives ysu a ~[] with preallocated memory that doesn't get nulled
[12:56:51] <dbaupp> zebr: [unsafe{std::unstable::intrinsics::uninit()}, .. 8192] won't zero the memory
[12:57:20] * aatch has a soft spot for uninit
[12:57:26] <kimundi> dbaupp: But it's unsafe! People, please stop recommending unsafe code to everyone xD
[12:57:28] <dbaupp> (but you have to be careful to only use uninit for POD types, where being filled with junk won't break destructors etc, later.)
[12:57:43] <dbaupp> kimundi: live life on the edge
[12:57:54] <cmr> aatch: https://github.com/Aatch/grease-bench/blob/master/src/cgroup.rs#L22
[12:58:00] * dbaupp thinks we need a POD kind so we can have safe versions of uninit
[12:58:01] <kimundi> dbaupp: Sure, if there is a railing
[12:58:09] <cmr> aatch: if you're just going to be calling to_owned, take a ~str
[12:58:23] <aatch> cmr, I guess.
[12:58:37] <cmr> makes the caller do the extra allocation if they need it
[12:59:01] <farnoy> dbaupp, so, summarizing, for the draw function in Manager, one could use an enum containing different kind of Shapes that I support and a `match { ... }`
[12:59:15] <farnoy> dbaupp, in which procedures can be specialized for every shape or so
[12:59:53] <dbaupp> farnoy: yup, it's either that (probably faster) or using trait objects (more flexible)
[13:00:14] <farnoy> dbaupp, that should be faster than vtable? let's assume that draw() in entity referenced by vtable would do the same procedure as in match block
[13:00:18] <farnoy> ok, but the question is
[13:00:32] <farnoy> how do I obtain this enum instance from the entity
[13:00:46] <aatch> Oh! don't forget about closures and similar
[13:01:00] <dbaupp> farnoy: yeah, it's faster: a plain switch is faster than a virtual call.
[13:01:15] <farnoy> because in the end, it's the Entity that gives this enum
[13:01:16] <dbaupp> aatch: manually wrolling a vtable, you mean? (like visit/fold?)
[13:01:26] <dbaupp> farnoy: I'm not sure I understand the question.
[13:01:38] *** Joins: sigma (sigma@moz-BE11A887.range109-151.btcentralplus.com)
[13:02:02] <farnoy> dbaupp, I mean that I would need to look in the vtable for the Entity to return a Shape instance (Shape being an enum)
[13:02:06] <kimundi> farnoy: Do you want to go &Entity -> EntitiesEnum ?
[13:02:06] <aatch> dbaupp, yep, if you only have a small amount of only-known-at-runtime code, then it might give you the best of both.
[13:02:35] <aatch> At the expense of being a little more complex
[13:02:37] *** Quits: true_droid (Adium@E3D4334F.209E8896.EBC99ECD.IP) (Quit: Leaving.)
[13:02:50] <farnoy> kimundi, I need the entity to retrieve some kind of information on what to render
[13:02:56] <farnoy> even when using a match block
[13:03:31] <kimundi> farnoy: That information is contained in the enum variants or not?
[13:03:43] <farnoy> kimundi, yes
[13:03:49] <zebr> thanks for the help, everyone. if it's not too much trouble, could you see if there's anything here i could do simpler or more idiomatically? http://sprunge.us/IKAI
[13:04:01] <kimundi> So, where is the problem?
[13:04:33] <dbaupp> zebr: `let mut buf = [0u8, ..  8192];` no need to allocate it on the heap there.
[13:04:40] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[13:05:08] <dbaupp> zebr: also, the Path(arg.to_owned()) probably doesn't need the to_owned() (don't quote me on that though :P )
[13:05:09] <farnoy> kimundi, the problem is that get_rendering_detail() call on Entity has to be done, there's no way to implement it without a vtable lookup
[13:05:26] <aatch> and now the timestamps start at 0
[13:05:45] <kimundi> farnoy: I think you need to explain khat you want to do, we're talking about a system where there are not trait objects in place
[13:05:58] <dbaupp> zebr: also, you can drop the type annotations on the `let`'s (usually/if you want)
[13:06:07] <engla> zebr: you'd use a method on the Result<> value (or a match {}), something like  result.map(|r| cat(r))
[13:06:08] <farnoy> kimundi, brb
[13:06:20] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[13:06:24] <zebr> dbaupp: it seems to need .to_owned(), or it complains it wants &str not &~str
[13:06:25] <engla> zebr: instead of .is_ok -> .unwrap
[13:06:50] <dbaupp> zebr: oh, then: `match file_reader(&Path(*arg)) { Ok(rdr) => cat(rdr), Err(_) => {} }`
[13:06:51] <zebr> dbaupp: what's the type of buf if you do that? (i like having the types explicit while i'm still learning :p)
[13:06:58] <dbaupp> zebr: [u8, .. 8192]
[13:07:14] <dbaupp> zebr: a fixed length vector allocated on the stack
[13:07:16] <kimundi> If you want to have both trait objects and a enum for all possible trait objects, you need a conversion function on &Entity for going &Entity -> EntityEnum in wich each type return the right enum variant
[13:07:24] <zebr> ah, i see
[13:08:05] <dbaupp> zebr: also, you could do `match args { [] => cat(stdin()), _ => { for args.iter() ... } }`
[13:08:26] <dbaupp> zebr: (although, you probably want `args.len() == 1` or `[_] =>`.)
[13:09:12] <zebr> ah, i do. ;p
[13:09:26] <dbaupp> engla: https://github.com/mozilla/rust/pull/8080
[13:09:27] <dbaupp> engla: \o/
[13:10:34] <engla> that was fast
[13:10:35] <engla> :-)
[13:10:49] <cmr> aatch: Looks good to me
[13:11:20] <aatch> cmr, cool. making sure I dealt with errors helped.
[13:12:04] <cmr> aatch: https://www.kernel.org/doc/Documentation/cgroups/memory.txt see section 5.5 though
[13:12:25] <cmr> I don't know how much it skews thingsat all, but I don't use usage_in_bytes
[13:12:54] <aatch> cmr, yeah, I know. Getting the data out of "memory.stat" instead. I don't think it skews it much.
[13:13:05] <cmr> ok
[13:13:22] <zebr> dbaupp: what does the * operator on *arg do?
[13:13:23] <aatch> cmr, given that using usage_in_bytes produces this: http://aatch.net/chart.html
[13:13:33] <aatch> zebr, de-reference
[13:13:47] <zebr> ah, that's simpler than normal. :p
[13:13:50] <dbaupp> zebr: derefences it, so from &~str -> ~str which gets auto-borrowed to &str
[13:13:56] <zebr> ah, makes sense.
[13:13:59] <dbaupp> *references
[13:14:24] <dbaupp> aatch: that would explain the difference in the amount of data
[13:14:44] <dbaupp> aatch: because I think cmr and I found that .stat gave much finer readings
[13:14:51] <cmr> yes
[13:15:02] <aatch> dbaupp, yep. since it's "fuzzed" according the docs.
[13:15:07] <dbaupp> aatch: (also, why -1*foo, rather than -foo?)
[13:15:16] <aatch> dbaupp, habit.
[13:15:30] <dbaupp> coolio :)
[13:16:32] * aatch is making the assumption that they are the same thing
[13:17:34] <dbaupp> aatch: probably not for floating point :P
[13:17:47] <aatch> Oh, and btw, I got that list of error messages by writing a C program that looped from 1-133 and calling perror on each one.
[13:17:58] <aatch> No wait, strerror
[13:18:01] <dbaupp> that's pretty cool
[13:18:10] <dbaupp> (what happens outside of that range?)
[13:18:14] <aatch> printf("\"%s\"", strerror(e))
[13:18:18] <kimundi> I just realized I need a very specific book
[13:18:25] <aatch> dbaupp, "Uknown Error"
[13:18:26] <kimundi> "C++ for Rust programmers"
[13:18:30] <cmr> kimundi: hahah
[13:19:01] <aatch> kimundi, A book that has a market of 2? (I could probably do with a copy tbh)
[13:19:28] <cmr> me too
[13:20:01] <kimundi> See? Market grew to 300% in the last few seconds!
[13:20:06] <dbaupp> 400%!
[13:20:09] <aatch> Theres an error: "Attempting to link in too many shared libraries"
[13:20:21] <dbaupp> aatch: have you tried to trigger it?
[13:20:22] <sigma> that would actually be really useful.
[13:20:31] <dbaupp> kimundi: 500%!
[13:20:36] *** Quits: farnoy (farnoy@moz-9F3E690F.neoplus.adsl.tpnet.pl) (Quit: Leaving)
[13:20:36] <kimundi> xD
[13:20:48] *** Joins: farnoy (farnoy@moz-9F3E690F.neoplus.adsl.tpnet.pl)
[13:21:04] <aatch> dbaupp, no, I just saw it and wondered what might
[13:21:10] <engla> "Not a XENIX named type file"
[13:21:51] <dbaupp> aatch: dlopen'ing millions of files? or just linking against millions of libraries?
[13:22:08] * dbaupp considers attempting to trigger it
[13:23:21] *** Joins: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de)
[13:23:32] <aatch> I also discovered that `tee` is actually a syscall.
[13:24:09] *** Joins: Blub\w (wry@moz-15A7CC54.vps.tuwien.ac.at)
[13:24:49] <dbaupp> we could rewrite coreutils in glibc and coreutils in Rust
[13:25:32] <aatch> dbaupp, we could. Whether we should is a different question.
[13:25:44] <dbaupp> aatch: but clearly the answer is 'yes' to that one
[13:26:08] <dbaupp> *clearly* more productive than fixing bugs in the compiler.
[13:26:09] *** Joins: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net)
[13:26:54] *** Quits: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com) (Client exited)
[13:27:43] <aatch> dbaupp, heh. I'm actually quite interested in improving Rust's "runtimeless" mode.
[13:27:55] <dbaupp> yeah, same
[13:28:19] <dbaupp> I wanna go through libstd and just stick #[cfg(not(no_runtime))] on everything that requires the runtime
[13:28:24] <dbaupp> (and libextra too)
[13:28:26] *** Joins: victorporof_ (victorporo@3A55AFE3.1C233438.79933D60.IP)
[13:28:57] <dbaupp> so you can run zero.rs-style without loosing the std lib
[13:29:03] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[13:29:19] <dbaupp> losing
[13:29:22] <dbaupp> I guess.
[13:29:31] *** Quits: victorporof (victorporo@3A55AFE3.1C233438.79933D60.IP) (Ping timeout)
[13:29:51] <aatch> dbaupp, we'll almost definately need something to deal with IO sans runtime.
[13:30:14] <dbaupp> aatch: yeah, that can be an extra shim on top of std/extra though.
[13:30:53] *** Joins: victorporof (victorporo@3A55AFE3.1C233438.79933D60.IP)
[13:31:10] <dbaupp> aatch: (although, it would be nice if we could reuse the traits and so reuse most of (the new) std::io.)
[13:31:36] <aatch> dbaupp, yep. I think the traits should be fine to implement.
[13:31:48] * Ms2ger wonders what this runtimeless is
[13:31:58] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[13:32:02] *** Quits: victorporof_ (victorporo@3A55AFE3.1C233438.79933D60.IP) (Ping timeout)
[13:32:02] <dbaupp> Ms2ger: do you know zero.rs?
[13:32:05] <cmr> Ms2ger: runing without the scheduler etc
[13:32:13] <aatch> Ms2ger, normally you get a scheduler and all sorts of stuff started up before main.
[13:32:29] <dbaupp> aatch: (you override #[start], right?)
[13:32:31] <aatch> but you can annotate a function with #[start] to make it entry point.
[13:32:48] <aatch> it has to be fn (int, **u8, *u8) -> int
[13:33:11] <Ms2ger> Interesting
[13:34:10] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[13:34:13] <dbaupp> aatch: in any case, we should be trying to make sure as much of the stdlib is runtimeless-friendly as possible
[13:34:18] <aatch> Ms2ger, take a look at https://github.com/Aatch/grease-bench/blob/master/src/bench.rs for an example
[13:34:23] <farnoy>  what are the differences under that mode?
[13:34:29] <aatch> dbaupp, like HashMap for example
[13:34:33] <aatch> farnoy, can't use @
[13:34:36] <cmr> farnoy: can't spawn tasks
[13:34:45] <farnoy> owned boxes work?
[13:34:49] <aatch> farnoy, yep
[13:35:18] <farnoy> those can't be the only restrictions?
[13:35:20] <aatch> I've written an entire program without the runtime, so it's perfectly feasible.
[13:35:22] <dbaupp> aatch: yeah, we just need to expose the functions for making it without taking the initialisation from the task rng
[13:35:41] <dbaupp> farnoy: you can write OS's and memory allocators in that mode
[13:35:56] <aatch> farnoy, well the issue is that a lot stdlib code uses `@` or other task-local stuff
[13:35:59] <dbaupp> (owned boxes don't work for that use case, but it still mostly works.)
[13:36:13] <cmr> farnoy: Rust is a low level language, the only thing the language itself requiers a runtime for is @
[13:36:34] <cmr> everything else is a construct of the standard library
[13:36:36] <farnoy> so it's basically C with move semantics?
[13:36:43] <dbaupp> and traits
[13:36:47] <cmr> and ADTs
[13:36:50] <aatch> farnoy, any ownership semantics
[13:36:51] <cmr> and pattern matching
[13:36:53] <aatch> and*
[13:36:55] <cmr> ... etc
[13:36:55] <dbaupp> and all sotrs of general niceness
[13:36:56] <engla> and pointer lifetimes
[13:36:58] <cmr> it's full rust
[13:36:58] <dbaupp> *sorts
[13:37:14] <kimundi> AND MY AXE!
[13:37:22] <kimundi> ...
[13:37:23] <dbaupp> heh
[13:37:27] <farnoy> is the performance expected to be close to C maybe?
[13:37:31] <farnoy> in the finished version, that is
[13:37:38] <cmr> farnoy: or better, yes.
[13:37:39] <aatch> farnoy, depends on the C
[13:37:41] <dbaupp> it's already close to C for some things
[13:37:45] <engla> I think C will still have more gimli-looking people than C
[13:37:48] <engla> than Rust
[13:37:54] <kimundi> farnoy: In general yeah. Some thnigs will be allways a bit faster, others can be faster, etc...
[13:37:55] <cmr> gimli-looking?
[13:38:03] * dbaupp 's head explodes from engla paradox
[13:38:08] <kimundi> slower*
[13:38:10] <dbaupp> *engla's
[13:38:33] <farnoy> well, that is interesting
[13:38:39] <engla> the double negative in #[cfg(not(no_runtime))]  was enough for my head :)
[13:38:42] <aatch> There's some things that you can do in C that Rust won't let you do.
[13:38:49] <cmr> aatch: such as?
[13:39:07] <aatch> cmr, questionable pointer-related stuff mostly.
[13:39:15] <cmr> aatch: unsafe code can't express it?
[13:39:23] <aatch> cmr, it probably can.
[13:39:36] <farnoy> how many people are working on rust anyway?
[13:39:42] <farnoy> i mean dedicated ones
[13:40:23] <cmr> the 5 core devs (although nmatsakis does a lot of non-rust stuff), the interns, the samsung people..
[13:40:58] <aatch> farnoy, I'm not sure if there are any full-time rust-lang-only devs
[13:41:13] <farnoy> samsung? let me guess, tizen?
[13:41:17] <aatch> most of the core devs also work on servo (which is a rust project)
[13:41:19] <cmr> yes, they also work on servo
[13:41:26] <cmr> farnoy: servo
[13:42:19] <cmr> Although I think graydon is full-time-rust?
[13:42:23] <farnoy> and what's servo's status?
[13:42:33] <aatch> farnoy, "exists"
[13:42:38] <cmr> farnoy: almost acid1 compliant, apparently.
[13:42:44] *** Joins: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP)
[13:43:03] <cmr> Although some of the interns are also full-time-rust too I think?
[13:43:16] <farnoy> is mozilla planning to replace gecko at some point?
[13:43:17] <cmr> bblum, toddaaro, sully, (maybe others?)
[13:43:26] <aatch> farnoy, not really.
[13:44:03] <farnoy> so what's the use case for servo?
[13:44:05] <aatch> Servo is an experiment.
[13:44:06] <farnoy> mobile os-es?
[13:44:07] <cmr> there was a meeting between the platform team and the servo team recently
[13:44:13] <cmr> farnoy: it's a research project
[13:44:30] <aatch> Exploring the design space for parallel rendering engines.
[13:44:32] <cmr> in parallel rendering enings
[13:44:58] <farnoy> isn't WebKit paralell?
[13:45:09] <cmr> not where it counts
[13:45:15] <dbaupp> farnoy: not parallel like servo is
[13:45:21] <farnoy> how do they differ then?
[13:45:43] <cmr> webkit doesn't have parallel layout or rendering
[13:45:44] <aatch> farnoy, think 1000 tasks vs 4 threads
[13:46:14] *** Quits: Blub\w (wry@moz-15A7CC54.vps.tuwien.ac.at) (Ping timeout)
[13:46:28] <farnoy> oh, by the way, tasks are 'green threads'
[13:46:38] <farnoy> or something like that, but how does it work really?
[13:46:46] <aatch> farnoy, yes. Multiplexed onto OS threads
[13:46:48] <Ms2ger> Gecko has some parallelism too, fwiw
[13:46:49] <cmr> farnoy: N:M scheduling onto OS threads
[13:47:11] <aatch> anyway. Time for me to sleep, its almost 2am
[13:47:13] *** Quits: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net) (Quit: Leaving)
[13:47:14] <dbaupp> night
[13:47:33] <dbaupp> Ms2ger: not like servo, though, presumably?
[13:47:48] <Ms2ger> No, not at all
[13:48:02] <Ms2ger> It's C++, after all :)
[13:48:32] <farnoy> and rust's tasks right now use os threads?
[13:48:49] <cmr> farnoy: N rust tasks are mapped onto M OS threads
[13:48:59] <cmr> the scheduler handles the details, and I don't know the specifics
[13:49:06] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[13:49:31] <dbaupp> farnoy: no, the scheduler actually does it's job wrt multiplexing
[13:49:52] <dbaupp> farnoy: (unusually, it's actually a part of Rust that mostly works now :) )
[13:50:16] <cmr> ...but is being fully rewritten in the new runtime
[13:50:31] <dbaupp> yup, "almost" done, though.
[13:50:32] <cmr> oncewe have file io i think rustc can be fully ported
[13:50:38] <dbaupp> just pesky little things like file io
[13:50:39] <cmr> and use RUST_NEWRT=1
[13:50:51] <cmr> and tear out all the oldcode
[13:51:09] *** Quits: paupau (textual@417F0514.289B9BF9.F20F0C5A.IP) (Ping timeout)
[13:51:10] <dbaupp> that'd be cool! basically LLVM would be the only non-Rust part of the code.
[13:51:20] <cmr> and linenoise and libuv
[13:51:28] <cmr> and miniz
[13:51:31] <cmr> but ye
[13:51:33] <cmr> s
[13:51:34] <kimundi> and jmalloc once it can be used
[13:51:35] <cmr> :p
[13:51:47] <cmr> and MPS if we integrate that
[13:51:51] <farnoy> libuv is used for tasks communication?
[13:52:03] <farnoy> or do we have async io too?
[13:52:06] <cmr> farnoy: and networking and everything else
[13:52:09] <cmr> yes, we have async io
[13:52:11] <kimundi> farnoy: all io and multithreading stuff
[13:52:37] <farnoy> awesome
[13:52:53] <farnoy> so there's much going on it would seem
[13:53:11] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[13:53:22] <cmr> yes
[13:53:33] <farnoy> and managed boxes use reference counting?
[13:53:38] <farnoy> like c++11's shared_ptr?
[13:53:46] <farnoy> or is it all garbage collected periodically?
[13:53:54] <cmr> it will be a task-local GC
[13:54:06] <cmr> but right now it's using the only-partly-correct reference counting
[13:54:12] <farnoy> isn't reference counting more accurate and efficient?
[13:54:15] <thpickert> xD
[13:54:15] <cmr> no
[13:54:32] <Ms2ger> As long as you don't have cycles... :)
[13:54:32] <dbaupp> farnoy: for some uses cases, yes
[13:54:39] <thpickert> I'm trying to pass a closure around.
[13:54:40] <engla> there is a reference counting box in extra::rc
[13:54:52] <kimundi> farnoy: ref counting has a few problems: cycles, code bloat due to the actual counting, etc
[13:54:57] <thpickert> rustc tells me "note: `encryption_oracle` moved here because it has type `&fn<no-bounds>(&[u8]) -> ~[u8]`, which is moved by default (use `copy` to override)"
[13:55:03] <farnoy> I've seen the phrase "... with cycles detection" somewhere in the manual
[13:55:09] <dbaupp> thpickert: https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ#noncopyable-stack-closures
[13:55:09] *** Quits: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net) (Quit: jclements)
[13:55:16] <cmr> farnoy: we don't actuallydo cycle collection anymore
[13:55:23] <cmr> farnoy: that code rotted on the vine long ago
[13:55:31] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[13:55:36] <farnoy> so task-local GC will be better?
[13:55:39] <cmr> yes
[13:55:39] <dbaupp> farnoy: cycles just get collected in one big go at the end of the task
[13:55:40] <farnoy> how does it work?
[13:55:41] <thpickert> dbaupp: Wow, before I even finished asking my question. :D You guys are getting faster and faster.
[13:56:05] <dbaupp> thpickert: haha, that page was written exactly because that change is non-intuitive and the error message unclear atm
[13:56:08] <cmr> farnoy: tracing. will hopefully use MPS (http://www.ravenbrook.com/project/mps/)
[13:56:18] *** Joins: Blub\w (wry@moz-6F93A9F3.vps.tuwien.ac.at)
[13:56:26] <thpickert> dbaupp: It even has an acceptable workaround!
[13:56:36] <dbaupp> thpickert: (so I just needed to type "und" into the awesomebar to get the link ;P )
[13:56:39] <cmr> farnoy: when the task is yielded to the scheduler or does a @-allocation, the GC can run
[13:57:13] <farnoy> cmr, but it seems to me that a proper reference-counting & cycles detection  algorithm would perform better on long referenced boxes
[13:57:17] <cmr> farnoy: since we can't have pointers into other tasks, the GC pause will be very short, and could take place when the task isn't even running
[13:57:26] <farnoy> that is, where all the gc pause times could be removed
[13:57:39] <cmr> farnoy: you'd be wrong. there's lots of research in this area
[13:57:41] <dbaupp> farnoy: you can use extra::rc::Rc
[13:57:48] <cmr> farnoy: reference counting isn't free
[13:57:53] <kimundi> farnoy: The intersting thing is, ref counting+cycle collectinf and tracing garbage collection are actually both identical two sides of the same "garbage collect" coin
[13:58:03] <dbaupp> farnoy: (if you actually want deterministic shared pointers)
[13:58:11] <kimundi> There is a paper that shows both are basically the same: http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf
[13:58:33] <farnoy> dbaupp, I'm good with the default, I'm just researching, but thanks
[13:58:46] <dbaupp> farnoy: (fwiw, extra::rc even disallows cycles at the type level, which is pretty neat.)
[14:00:02] <farnoy> I've heard about generational garbage collectors also
[14:00:06] *** Quits: Blub\w (wry@moz-6F93A9F3.vps.tuwien.ac.at) (Quit: bb)
[14:00:30] <farnoy> but I guess  they wouldn't be so fast as more assumptions can be made with rust's memory model
[14:00:32] <thpickert> dbaupp: It works! \o/ Thanks to your powers of premonition and answering!
[14:00:39] <dbaupp> farnoy: there's no particular reason that wouldn't be possible in Rust
[14:01:13] <dbaupp> farnoy: (it would require a little trickery wrt to borrowing and not moving data under the feet of users.)
[14:01:17] <dbaupp> thpickert: haha :)
[14:01:27] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[14:01:41] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[14:01:50] <olsonjeffery> bacon-garbage? bacon *never* goes in the garbage!
[14:02:11] <dbaupp> olsonjeffery: bacon - garbage, clearly ;P
[14:03:35] <farnoy> seems like Rust will be packing years of research that was not available 20 years ago
[14:03:41] <farnoy> I wonder how it will turn out
[14:06:55] <sigma> farnoy: one of the design goals is to only use ideas that have been proven in other languages
[14:07:03] <sigma> but yes, it's a novel mix, it's very interesting
[14:07:39] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[14:07:39] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/FEOjjg
[14:07:39] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[14:08:43] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[14:09:45] <farnoy> are there synchronization primitives that ensure that two tasks will always wait for each other at one point?
[14:09:58] *** Joins: Everyday (chatzilla@74EEAD8D.3353FE78.24655E4E.IP)
[14:10:00] <farnoy> because posix conditional variable seems one-directional to me
[14:10:16] <farnoy> like, if the thread that notifies is faster than the one that waits
[14:10:35] <farnoy> it will go without waiting
[14:10:35] *** Quits: Everyday (chatzilla@74EEAD8D.3353FE78.24655E4E.IP) (Connection reset by peer)
[14:10:38] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[14:10:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xK3HFg
[14:10:38] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[14:10:39] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[14:10:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/7QQdqA
[14:10:39] <ghrust> 13rust/06auto 14b782d42 15Alex Crichton: Deny all warnings by default in doc tests...
[14:10:39] <ghrust> 13rust/06auto 14aa8f79d 15bors: auto merge of #8067 : alexcrichton/rust/issue-3636, r=huonw...
[14:10:39] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[14:12:34] <dbaupp> farnoy: there's a pile of task-communication-related things in std::comm, extra::comm, extra::sync (this one is probably most relevant)
[14:15:32] *** Quits: slaren (slaren@moz-F50885B.red-88-18-148.staticip.rima-tde.net) (Ping timeout)
[14:20:19] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[14:21:04] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[14:22:54] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Ping timeout)
[14:25:08] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[14:27:50] <farnoy> is there sleep() somewhere?
[14:28:17] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[14:28:58] <kimundi> farnoy: There might be one  in the c bindings
[14:29:23] *** Joins: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net)
[14:31:11] <Yurume> codec\ascii.rs:110:19: 110:43 error: cannot call a generic method through a boxed trait
[14:31:11] <Yurume> codec\ascii.rs:110         assert_eq!(d.feed([0xa0], Replace), Ok(~"\ufffd"));
[14:31:14] <Yurume> aargh...
[14:31:16] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[14:31:52] <dbaupp> kimundi: that sleeps the whole OS-thread, not the task
[14:32:05] <dbaupp> farnoy: in the new runtime yes, but not really in the old one.
[14:32:13] <kimundi> sure, but we don't have a tash sleep yet, right?
[14:32:20] <Yurume> yeah, I *do* know that a generic method is not visible to the vtable so the error is obvious, but can't think of other design
[14:32:25] <dbaupp> kimundi: for newrt, we do
[14:32:26] *** Joins: alisdair (textual@BB0336C3.D2943E17.C579BC3E.IP)
[14:32:43] <kimundi> Oh we have? Then that should be used definitly
[14:33:07] <dbaupp> kimundi: right, but using newrt means you can't read/write files, etc :P
[14:33:30] <kimundi> ...once it's finished of course
[14:33:39] <farnoy> uhm
[14:33:46] <farnoy> so which would be the new one?
[14:34:17] <dbaupp> you just run your program with RUST_NEWRT=1 and that will automatically use the new runtime
[14:34:18] <kimundi> farnoy: The new one is disabled per default because it's not done yet
[14:34:41] <farnoy> is this it ? https://github.com/mozilla/rust/blob/master/src/test/run-pass/pipe-sleep.rs
[14:34:55] <farnoy> there's no doc generated for extra::uv
[14:35:35] <engla> Why is there no .write_str() in std::rt::io?  Can I add one that matches the old version, or are there design issues (encodings, layers, complexities)
[14:35:49] <farnoy> dbaupp, and why can't we do io on files with newrt?
[14:36:05] <dbaupp> farnoy: not implement yet
[14:36:08] <dbaupp> *implemented
[14:36:10] *** Joins: mye (mye@moz-E0C102A6.dip0.t-ipconnect.de)
[14:36:32] <dbaupp> engla: I'd guess it's just not been implemented, but I don't know.
[14:36:34] <engla> I'd like to add string writing to std::rt::io, then convert all in-memory @Writers to the new io in std/extra
[14:37:14] <dbaupp> wouldn't that break them when using the old rt?
[14:37:43] <dbaupp> farnoy: yeah, extra::uv got recently deleted
[14:37:46] <engla> the memory writers are just using the io traits to build strings, so no
[14:37:48] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[14:37:56] <dbaupp> engla: oh, right.
[14:38:09] <engla> for example repr.rs or extra::json
[14:38:26] *** Quits: StarLight (StarLight@moz-6063D8AE.pppoe.avangarddsl.ru) (Ping timeout)
[14:38:28] <farnoy> dbaupp, the docs you mean? is this the usage you recommended on newrt ?
[14:38:48] <dbaupp> engla: (it would break them when trying to use them in functions taking @std::io::Writer, right? or only ones that are internal to those libraries?)
[14:38:58] *** Quits: alisdair (textual@BB0336C3.D2943E17.C579BC3E.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[14:39:00] <dbaupp> farnoy: the whole extra::uv module got removed, replaced by newrt
[14:39:31] <engla> dbaupp: sure, no mixing is possible
[14:39:40] <dbaupp> farnoy: so, atm, you either have sleep() or you have file io, can't have both.
[14:40:12] <farnoy> dbaupp, extra::newrt::sleep()? what signature does it have?
[14:40:16] <dbaupp> no
[14:40:21] <engla> dbaupp: I'm just trying to find an angle where I can help the migration to std::rt::io
[14:40:46] <dbaupp> farnoy: I have no idea how you actually call it, but it's in `std::rt::something::...`
[14:41:00] <dbaupp> farnoy: (you may have to read the source to find it.)
[14:41:10] <farnoy> dbaupp, ok, will do, thx
[14:41:14] <dbaupp> engla: file io is the big blcoker, I imagine?
[14:41:24] <dbaupp> farnoy: (well, grep the source for 'fn sleep')
[14:41:42] <engla> dbaupp: I guess newrt is the big blocker
[14:42:23] *** Joins: StarLight (StarLight@moz-A8098C85.dynamic.avangarddsl.ru)
[14:42:27] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Connection reset by peer)
[14:42:45] <dbaupp> engla: right, but I've been getting the feeling that file-io is one of the last major hurdles to switching it on by default (from general IRC conversations I've overheard, I might be wrong)
[14:42:54] <engla> I'm mainly interested in all the soft issues, i.e. the abstractions we can do with Reader/Writer traits
[14:43:19] *** Joins: xraycat (Adium@moz-3D118ADE.pool.mediaways.net)
[14:43:24] <dbaupp> yeah... but switching half the readers/writers to use different traits seems like it'll make things hard
[14:43:30] <engla> there's a lot of soft porting to be done since the conventions will change, probably from @Writer into   func<W: Writer>(&mut W)
[14:43:32] <farnoy> dbaupp, two definitions, rt/io/timer.rs, rt/uv/uvio.rs
[14:43:43] <dbaupp> farnoy: rt::io::timer I guess.
[14:43:44] <engla> dbaupp: it's not supposed to enter public api
[14:43:50] <engla> yet
[14:44:24] *** Quits: jclements (jclements@moz-F43DF0BE.ngn.east.myfairpoint.net) (Quit: jclements)
[14:44:40] <engla> dbaupp: example, repr.rs uses @Writer internally. Could be ported to std::rt::io::Writer  without change visible to the outside
[14:44:41] <dbaupp> engla: so these are only for "hidden" users of the in-memory io?
[14:44:48] <engla> that's the starting point
[14:44:49] <dbaupp> engla: right, yeah
[14:55:56] <cmr> dbaupp: ahh rsync got stuck
[14:56:04] <cmr> well, gzip did
[14:56:06] <cmr> `gzip: ./4c4cf003ea32d7617602fdbd1b2ebc8099633f06/mem.json.gz already exists; do you wish to overwrite (y or n)? 
[14:56:14] <dbaupp> haha
[14:56:26] <dbaupp> yes | while true ... 
[14:56:32] <cmr> heh
[14:57:05] <cmr> or gzip -f :p
[14:57:12] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:05:19] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[15:05:39] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:07:36] <cmr> dbaupp: 63 benchmark results uploading.
[15:07:47] <cmr> I'm turning off the bencher and putting it back into build-only mode.
[15:08:06] <cmr> but that is a week worth's of PRs in a day
[15:08:19] <cmr> not bad B)
[15:08:22] <dbaupp> cmr: haha, awesome. :D
[15:09:29] <dbaupp> cmr: I'm currently updating rustc on that computer... at stage1 rustc, so it'll be 20 minutes before results start flowing.
[15:10:01] <cmr> I'll transition to aatch's bencher.. eventually
[15:10:15] <cmr> That is the most solid part of my setup, I'm hesitant to touch it :p
[15:11:00] <dbaupp> cmr: understandable... but there's no possible excuse for anything non-network related to not be in Rust.
[15:11:24] <cmr> dbaupp: well, plumbum is quite pleasant, std::run is not really comparable yet
[15:11:39] <dbaupp> cmr: pssh, no excuses
[15:11:43] <cmr> also my excuse is laziness
[15:12:06] <dbaupp> cmr: incidentally, I don't see a way for Rust to get something as slick as plumbum.
[15:12:37] <cmr> dbaupp: it advertises itself as a "shell combinator", whatever that means.
[15:12:53] <dbaupp> cmr: it allows you to combinate shells
[15:13:03] <cmr> but afaict it's just magic on the the __getitem__ magic method
[15:13:28] <dbaupp> yeah
[15:13:36] <cmr> (well, plus redirection with > and <, and &FG/&BG, but those aren't as important)
[15:13:43] <dbaupp> (and some magic to make import work too.)
[15:14:00] <dbaupp> gah! an ice.
[15:14:03] * dbaupp gives up for the day
[15:14:07] <dbaupp> *night
[15:14:12] <cmr> heh
[15:16:30] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[15:17:10] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[15:18:26] <cmr> dbaupp: it's all uploaded
[15:18:48] <cmr> 52MiB of delicious gzipped json
[15:19:28] <dbaupp> cmr: awesome. I'm just waiting for this new rustc to build, and then it should be reuploaded as a lot less ungzipped json :P
[15:19:34] <cmr> heh
[15:20:03] <dbaupp> wooo, stage2 std \o/
[15:20:20] * dbaupp appreciates his new computer when waiting for the old one to build rust like this
[15:20:28] <cmr> dbaupp: just curious; does your line simplification thinger remove detail from the long line during LLVM?
[15:20:37] <dbaupp> cmr: I assume so
[15:21:01] <dbaupp> cmr: don't actually know where it removes stuff, just that the simplified vs non-simplified lines look pretty similar
[15:21:09] <cmr> ok that's all that matters then
[15:21:31] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[15:21:39] <cmr> was just wondering if it removed any important spikes or wobble
[15:21:42] <cmr> but sounds like not
[15:22:07] <cmr> dbaupp: it'd be nice if rust could link statically like go so you could just push a binary
[15:22:18] <dbaupp> yeah, I imagine that it removes a lot on the linear up/down sections, where the remove-if-equal doesn't work, but letting the "outer" points interpolate does
[15:23:02] <dbaupp> cmr: yeah, if/when we get static linking that should work, given it's supposedly got cross-compiling built in
[15:23:18] <cmr> it does (and the buildbots make sure it doesn't break)
[15:23:40] <dbaupp> yup
[15:23:54] * dbaupp tried using it once
[15:24:03] * dbaupp couldn't get it to work properly
[15:24:37] <cmr> I've gotten a working android cross-compiler and 32-bit linux cross compiler
[15:24:59] <dbaupp> cool!
[15:25:38] <dbaupp> I think I was just transferring libstd/extra wrong. (or the libc on the other computer was too old. I can't remember the exact problems)
[15:37:26] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[15:41:24] *** Joins: ipc (ipc@moz-76ED5036.lightspeed.cicril.sbcglobal.net)
[15:41:50] <ipc> howdy
[15:41:54] <dbaupp> cmr: done, running it now!
[15:42:04] <ipc> is bors source code available/documented?
[15:42:05] <cmr> ipc: weclome
[15:42:09] <dbaupp> ipc: nope
[15:42:11] <cmr> ipc: no
[15:42:58] <ipc> ah, ok; I like the functionality and was looking to set up a non-rust project with bors or something similar
[15:43:12] <erickt> gabor's "remove *T" is intriguing...
[15:43:28] <erickt> bstrie: do you have a proposal for Unsafe<T> somewhere?
[15:43:32] <cmr> ipc: he is quite handy. graydon wants to release the source but it's low priority
[15:44:05] <dbaupp> cmr: it appeared to work! should update soon.
[15:44:07] <ipc> any chance of a private, unsupported drop of whatever source is live?
[15:44:19] <cmr> ipc: you'd have to ask graydon
[15:44:22] <cmr> dbaupp: yay!
[15:44:35] <ipc> ok, thanks!
[15:44:46] <dbaupp> cmr: updated already, I think
[15:44:53] <cmr> yes it did
[15:44:55] <cmr> that was quick
[15:45:30] <dbaupp> anyways, bed time. night.
[15:45:33] <Ms2ger> Night
[15:48:00] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:54:56] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[15:55:21] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[15:55:37] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[15:55:37] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/7QQdqA
[15:55:37] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[15:58:35] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[15:58:35] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/3CLXzA
[15:58:35] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[15:58:38] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[15:58:38] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/CB4C9w
[15:58:38] <ghrust> 13rust/06auto 14e823940 15Luqman Aden: librustc: Respect no_mangle attribute on statics.
[15:58:38] <ghrust> 13rust/06auto 14c32b26b 15Luqman Aden: librustc: Unify name mangling for functions and statics.
[15:58:38] <ghrust> 13rust/06auto 140522955 15bors: auto merge of #8070 : luqmana/rust/nom, r=alexcrichton...
[15:58:40] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[16:03:37] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[16:04:58] <farnoy> why is rust throttling cpu usage to 50% on my pc? is this related with scheduling tasks on threads?
[16:05:03] <farnoy> I'm running a single task
[16:06:06] <cmr> farnoy: it's not throttling, it's running one task as fast as it can
[16:06:24] <cmr> if you have two cores and it's fully using one of them, 50% is normal
[16:06:49] <farnoy> ah, it's represantation in my system monitor
[16:07:17] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[16:07:49] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[16:09:53] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[16:10:15] <sebcrozet> Hi. Why doesnâ€™t @T (or whichever pointer) doesnâ€™t automatically implement the same traits as T itself?
[16:10:37] <bstrie> erickt: you mean the idea of removing *T in favor of Unsafe<T>? it was mostly just a random musing, do you think it might be a good idea?
[16:10:56] <bstrie> erickt: I'd be totally fine with it, but... I never use unsafe pointers :)
[16:11:08] <erickt> :)
[16:11:17] <cmr> sebcrozet: there was an issue open about it and there was a very good reason but I can't remember what it was..
[16:11:28] <erickt> bstrie: This came up because of http://www.reddit.com/r/rust/comments/1j5vbn/rustdev_rfc_removing_t/
[16:11:46] <erickt> gabor has some intriguing ideas about getting rid of *T
[16:11:56] <cmr> bstrie: hahah did you add * to mitsuhiko?
[16:12:21] <erickt> bstrie: I'm not yet sure if I buy his argument yet though
[16:13:18] <kimundi> sebcrozet: Why should they?
[16:14:07] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[16:14:14] <kimundi> In the end, a @T is just a generic type like Rc<T>
[16:14:53] <kimundi> we already have autoborrow and deref sugar to get to the T inside of a @T
[16:15:19] <sebcrozet> kimundi: But the only difference between @T, ~T, &T and T is the memory management.
[16:15:34] <erickt> bstrie: is your Unsafe essentially Option with all the destructuring commands marked as unsafe?
[16:16:28] <sebcrozet> kimundi: And I dont see how the kind of pointer affects the actual behaviour of the object.
[16:17:12] <kimundi> sebcrozet: One counter example: .clone() on a &T is omething different to .clone() on a T
[16:17:39] <engla> even that .clone() thing is tricky
[16:18:04] <kimundi> yeah, but that's just because autoderef shifts tha amount of &-inidirection
[16:18:09] <bstrie> cmr: he asked me to give it to him!
[16:18:15] <cmr> bstrie: heh
[16:18:33] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[16:18:47] <bstrie> erickt: I didn't give it too much thought, I was thinking more analogous to the forthcoming Gc<T> than to Option<T>
[16:19:06] <bstrie> where it's just a more verbose pointer type, to discourage people from using it
[16:19:16] * erickt hasn't been following the Gc<T> talk. I'll look into it
[16:19:17] <sebcrozet> kimundi: As I think more about it, Eq for @ Tis also different from Eq for &T right?
[16:19:36] <sebcrozet> s/ Tis/ T is/
[16:19:41] <engla> no reason to call it Unsafe<T>, the value is not unsafe, only some of its methods
[16:19:46] <kimundi> might be, not sure
[16:19:51] <engla> I think raw pointer is a better name for *T
[16:20:04] <kimundi> bstrie: There was also the &'unsafe idea
[16:20:49] <erickt> and my unsafe region ptrs a la `*'a T` patch: https://github.com/mozilla/rust/pull/7967
[16:21:27] <sebcrozet> kimundi: Ok. Thanks. Iâ€™ll try to find the issue about that.
[16:21:44] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[16:22:10] <bstrie> erickt: right, I didn't pursue the idea because I didn't want to think of how it would interact with that patch :)
[16:22:55] <kimundi> sebcrozet: The important thing imo is that a @T, &T etc is just a wrapper type like Option<T>, Rc<T>, etc. It just has dereference sugar to make it easier with the T inside
[16:23:49] <mitsuhiko> cmr: odd coincidence. i asked for the flair independently of that mail
[16:24:15] <engla> kimundi: the autoderef establish a level of convenience not matched when you go over to generics over traits
[16:24:23] <erickt> gabor's ideas are pretty neat. I do like the realization that Option<&T> acts like *T but forces proper is-null checking. However, I kind of see that as an optimization, and not a language feature so I'm not sure if I want to rely on it
[16:26:03] <sebcrozet> kimundi: that makes sense. I thought that having special operators for @, &, ~ could be a way to say "I dont add any information to the pointed thing, so it is really the same guy, with the same traits, etc.".
[16:26:49] <engla> erickt: but null checks is one thing you may choose to skip in unsafe sections
[16:27:45] <engla> I guess unwrap is fine for that, neveremind
[16:28:12] <erickt> engla: well, unwrap implies checking for None, it'll just fail if it finds it
[16:30:09] <engla> hm ok so some sort of unsafe unwrap would be needed
[16:33:49] <erickt> engla: yeah
[16:34:11] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[16:34:56] *** Quits: etw (john@moz-B2936CAB.nyc.res.rr.com) (Quit: etw)
[16:37:11] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[16:40:29] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[16:41:13] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[16:45:05] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[16:45:53] *** Joins: slaren (slaren@moz-19C08BB0.red-81-35-226.dynamicip.rima-tde.net)
[16:48:46] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[16:56:02] *** Quits: mye (mye@moz-E0C102A6.dip0.t-ipconnect.de) (Quit: mye)
[16:56:49] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[16:59:26] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[17:05:19] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[17:06:49] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[17:07:18] *** Joins: jclements (jclements@D59A0308.23444261.EB48B30D.IP)
[17:07:40] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[17:12:23] *** Joins: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net)
[17:13:43] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[17:16:21] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[17:17:08] *** Joins: mye (mye@moz-E0C102A6.dip0.t-ipconnect.de)
[17:24:55] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[17:34:13] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[17:34:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[17:35:37] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:39:45] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:42:20] <sully> I have landed snapshots, by the way
[17:43:34] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[17:43:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/CB4C9w
[17:43:34] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[17:44:17] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:44:33] <sfackler> sully: r? https://github.com/mozilla/rust/pull/8036
[17:46:29] <sully> done
[17:46:34] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:46:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_i7OvA
[17:46:35] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:46:35] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[17:46:35] <ghrust> 01[13rust01] 15bors pushed 13 new commits to 06auto: 02http://git.io/5VFYRw
[17:46:35] <ghrust> 13rust/06auto 141eb0574 15Erick Tryzelaar: cleanup get_ref
[17:46:35] <ghrust> 13rust/06auto 14fa1f141 15Erick Tryzelaar: cleanup .iter and .iter_err
[17:46:35] <ghrust> 13rust/06auto 14942cbf1 15Erick Tryzelaar: cleanup .unwrap and .unwrap_err fixing io tests
[17:46:36] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[17:46:39] <sfackler> thanks
[17:55:01] *** Quits: goffrie_ (goffrie@moz-1A2DE2C4.dsl.ncf.ca) (Quit: Lost terminal)
[17:56:01] *** Quits: sigma (sigma@moz-BE11A887.range109-151.btcentralplus.com) (Ping timeout)
[18:01:12] *** Joins: Blub\w (wry@moz-D22C0A6E.vps.tuwien.ac.at)
[18:07:51] *** Joins: tikue (tkuehn@moz-9FA353EF.hsd1.ca.comcast.net)
[18:08:26] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[18:08:38] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[18:09:59] *** Quits: Blub\w (wry@moz-D22C0A6E.vps.tuwien.ac.at) (Ping timeout)
[18:11:31] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[18:13:41] *** Joins: sigma (sigma@2AE71BC1.DC5B0862.37339E3A.IP)
[18:14:55] *** Quits: zslayton (Mibbit@moz-14AA87A9.nyc.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[18:15:38] *** Joins: Blub\w (wry@moz-239F88B7.vps.tuwien.ac.at)
[18:16:33] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[18:16:33] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14c7f42c7 to 140522955: 02http://git.io/N3iJvQ
[18:16:33] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[18:16:34] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[18:16:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/doRNTA
[18:16:34] <ghrust> 13rust/06auto 14feb18fe 15Steven Fackler: Added default impls for container methods...
[18:16:34] <ghrust> 13rust/06auto 145157e05 15bors: auto merge of #8036 : sfackler/rust/container-impls, r=msullivan...
[18:16:34] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[18:18:47] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[18:19:31] *** Quits: Blub\w (wry@moz-239F88B7.vps.tuwien.ac.at) (Quit: bb)
[18:22:28] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:23:02] *** Quits: tikue (tkuehn@moz-9FA353EF.hsd1.ca.comcast.net) (Quit: tikue)
[18:26:27] *** Quits: jclements (jclements@D59A0308.23444261.EB48B30D.IP) (Ping timeout)
[18:26:40] *** Joins: jclements (jclements@moz-2185242C.man.east.myfairpoint.net)
[18:27:42] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Quit: WeeChat 0.4.1)
[18:27:50] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:31:31] <true_droid> hi! I'm reimplementing md4 to use Digest trait and also implementing other missing checksum algorithms. So I'm trying to test my modified md4.rs outside of the Rust source folder. I've added "extra::" prefix to all uses, but still get cryptic errors when trying to "rust test" https://gist.github.com/alco/6095810
[18:31:41] <true_droid> the file I'm trying to test https://github.com/alco/rust-digest/blob/master/md4.rs
[18:31:49] <acrichto> strcat: would it be possible to add methods on the string/vector iterators to tell what position you're at? Also, it would be awesome for those to have a lookahead (without advancing) as well
[18:32:08] <true_droid> any hints on what imports I missed?
[18:32:16] <strcat> acrichto: well you can do lookahead with Clone
[18:33:03] <acrichto> strcat: oh good point
[18:33:22] <strcat> rusti: let xs = ["foo", "bar"]; let ys = [1, 2, 3, 4, 5, 6, 7]; for xs.iter().cycle().zip(ys.iter()).advance |(x, y)| { printfln!("%? %?", x, y) }
[18:33:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EAdC
[18:33:38] <strcat> rusti: use std::iterator::*; let xs = ["foo", "bar"]; let ys = [1, 2, 3, 4, 5, 6, 7]; for xs.iter().cycle().zip(ys.iter()).advance |(x, y)| { printfln!("%? %?", x, y) }
[18:33:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aiDE
[18:33:49] <strcat> cycle just clones the iterator
[18:34:49] <acrichto> strcat: oh cycle just repeats infinitely from the current point
[18:34:55] <strcat> yeah
[18:35:10] <strcat> and it's close to free, since it's just going to be copying a small iterator
[18:35:14] <cmr> true_droid: https://github.com/alco/rust-digest/blob/master/md4.rs#L200
[18:35:22] <cmr> true_droid: that should be a #[cfg(test)] mod tests { ...... }
[18:35:23] <acrichto> excellent
[18:35:43] <acrichto> strcat: I guess I could also learn the position with enumeration as well
[18:35:51] *** Quits: jclements (jclements@moz-2185242C.man.east.myfairpoint.net) (Ping timeout)
[18:35:58] <acrichto> so actually, nevermind! :)
[18:36:12] *** Joins: jclements (jclements@moz-11970F49.ptldme.east.myfairpoint.net)
[18:38:04] <true_droid> cmrirc://irc.mozilla.org:6667/#%5Bcfg(test)Do both "fn test" need to be modules? I wrapped test_md4() into mod tests like you showed, but there is also "fn test" inside it which now errors out 
[18:38:38] <cmr> true_droid: you can't have nested #[test] functions.
[18:38:48] <true_droid> I took this code straight from Sha1 and it's confusing why it works there 
[18:39:46] <cmr> it shouldn't work :\
[18:39:58] <true_droid> cmr: oh, I may have gotten the wrong master probably. Here it has a module on the outside and a function marked with [test] inside it https://github.com/mozilla/rust/blob/master/src/libextra/crypto/sha1.rs#L242
[18:39:59] <cmr> there's no way for the test runner to call a nested function
[18:40:09] <true_droid> *the wrong branch â€” what I meant to say
[18:40:49] <true_droid> or I just mixed up md4 and sha1 test code :) seems to work now, thanks
[18:40:52] <acrichto> strcat: actually it would be nice to have a position() method on something like StrCharIterator because enumerate() doesn't know the byte-width of chars. This could just be an impl on StrCharIterator, would you be ok with that?
[18:41:32] <strcat> acrichto: not sure ;]
[18:41:44] <kimundi> acrichto, strcat: sounds like there needs to be a .offset_char_iter()
[18:41:54] <true_droid> hm, has the incoming branch been nuked?
[18:41:58] <kimundi> over (uint, char)
[18:41:58] <strcat> true_droid: yes
[18:42:24] <acrichto> kimundi: yeah that would also work, and then you could map/zip/whatnot as well
[18:42:24] <true_droid> which branch should I use for contribs now?
[18:42:34] <strcat> acrichto: yeah it'd probably be better as an iterator
[18:44:56] <strcat> acrichto: since the iterator objects themselves aren't *usually* used directly
[18:45:05] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[18:45:20] <cmr> true_droid: master
[18:45:39] <cmr> http://cmr.github.io/blog/2013/06/15/this-week-in-rust/
[18:46:54] <true_droid> what, I can't believe it. It seems only last week I sent some PRs to incoming
[18:47:04] <true_droid> time moves fast
[18:47:16] <strcat> rust even more so :)
[18:47:40] <true_droid> it sure does, most of the time I'm confused if I'm writing code against the correct version
[18:48:04] *** Joins: doomlord_ (servitor@moz-13E69BC8.range86-180.btcentralplus.com)
[18:50:01] <true_droid> cmr: thanks for keeping the weekly series, I can see now how it does help a lot
[18:50:14] <cmr> true_droid: np
[18:54:53] *** Parts: xraycat (Adium@moz-3D118ADE.pool.mediaways.net) ()
[18:58:34] *** Joins: tcsc (tcsc@moz-7246F5CD.hsd1.ma.comcast.net)
[19:02:47] <true_droid> why do build instructions say "make && make install"? doesn't "make install" depend on "make?
[19:03:09] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[19:03:23] <cmr> it does. I don't know why they say that
[19:03:50] <sp3d> what do you mean?
[19:04:04] <sp3d> && is "do the first, and if it succeeds, do the second"
[19:04:04] <strcat> ugh
[19:04:18] <sp3d> thus make install won't run if make doesn't complete successfully
[19:04:40] <cmr> sp3d: the install target depends on the default target, which builds everything
[19:04:41] <sfackler> right, but the install target depends on the default target presumably
[19:04:55] <sp3d> ah
[19:05:10] <true_droid> sp3d: make install won't install if the build fails
[19:05:17] <sp3d> right, now I see
[19:05:47] <strcat> and if you *are* actually using make install to install to /usr/local/ it's going to need root
[19:05:52] <strcat> and you really don't want to build as root
[19:06:08] <strcat> it'll leave root owned files scattered around
[19:06:23] <strcat> although doing that is a bad idea anyway ;p
[19:07:01] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:07:22] *** sam113101 is now known as sam113101_afk
[19:08:03] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[19:08:05] *** sam113101_afk is now known as sam113101
[19:08:14] <true_droid> strcat: I see. Makes sense. I do own my /usr/local though
[19:08:32] <strcat> true_droid: you mean your user owns it? that's quite odd.
[19:08:37] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[19:08:41] *** Quits: jclements (jclements@moz-11970F49.ptldme.east.myfairpoint.net) (Ping timeout)
[19:08:43] <strcat> if it's for the specific user you should be using ~/.local
[19:09:02] <strcat> since /usr/local is global (likely in root's path, for one thing)
[19:09:10] <true_droid> strcat: that's a general theme on OS X. Homebrew relies on it to install soft in /usr/local without sudo
[19:09:15] * strcat shrugs
[19:09:18] <strcat> that's pretty awful
[19:09:25] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[19:09:30] *** Joins: jclements (jclements@moz-5399D5B7.ptldme.east.myfairpoint.net)
[19:09:38] <strcat> so how does it handle multiple users using homebrew?
[19:09:38] <true_droid> OS X has at most 1 user any way
[19:09:53] <strcat> it doesn't let you have multiple accounts?
[19:09:55] <sp3d> "at most"
[19:10:06] <true_droid> it does, but seriously, whom you will share you macbook with? 
[19:10:41] <true_droid> if your girlfriend does development too, then it might be a problem
[19:13:47] <doomlord_> if i submit a syntax highlighting config that color codes types, will you let me write functions in CamelCase :)
[19:14:12] <cmr> style guide says no: https://github.com/mozilla/rust/wiki/Note-style-guide
[19:16:08] *** Joins: xazax (xazax@moz-E2EFC88D.pool77-111.dyn.tolna.net)
[19:18:09] *** Quits: mye (mye@moz-E0C102A6.dip0.t-ipconnect.de) (Quit: mye)
[19:18:51] <strcat> so many ICEs preventing Iterable
[19:19:45] *** sam113101 is now known as sam113101_afk
[19:20:16] *** sam113101_afk is now known as sam113101
[19:20:30] *** Quits: xazax (xazax@moz-E2EFC88D.pool77-111.dyn.tolna.net) (Quit: Ex-Chat)
[19:22:30] *** Joins: maikklein (maik@moz-21601AB7.dip0.t-ipconnect.de)
[19:26:32] <Mindless`> I don't understand why [1] type-checks but [2] doesn't... literally the only difference between the impls for eq and equals are the fn names [1] http://codepad.org/zd2KOMuc [2] http://codepad.org/AXcVKsPe
[19:28:03] <cmr> foo.rs:11:66: 11:75 error: mismatched types: expected `&BoolExpr` but found `&~BoolExpr` (expected enum BoolExpr but found ~-ptr)
[19:28:09] <cmr> Mindless`: it has to do with auto-deref
[19:28:28] <cmr> __arg_1_0 in this case is the ~BoolExpr in the Not variant
[19:28:46] <Mindless`> which is identifier dependent?
[19:29:43] <cmr> no idea
[19:29:54] <Mindless`> should I file a bug?
[19:30:07] <cmr> it's a known limitation
[19:30:14] <cmr> ask dbaupp when he's around (he wrote the deriving code)
[19:31:48] <Mindless`> it's not so much the deriving that I'm wondering about :/ -- you could pretend I wrote the impls myself and I would still be confused about it
[19:32:13] <cmr> right, but he's the most familiar with the issue
[19:32:21] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[19:38:06] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[19:39:16] <true_droid> is this fixable without full rebuild? https://gist.github.com/alco/6096023
[19:46:44] *** Joins: Nefzaoui (chatzilla@DD433556.E0FF0FD3.360EF119.IP)
[19:47:04] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[19:51:19] <kimundi> true_droid: In principle yes
[19:51:48] <kimundi> at least, I'm assuming that
[19:52:47] <kimundi> no wait, actually I have no idea
[19:54:29] <kimundi> strcat, acrichto: Anything against me adding offset_char_iter() ?
[19:54:47] *** Quits: maikklein (maik@moz-21601AB7.dip0.t-ipconnect.de) (Connection reset by peer)
[19:56:24] <acrichto> kimundi: be my guest :), although perhaps it should be called char_pos_iter() ?
[19:57:07] <kimundi> hmm. position sounds to generic imo. could be confuset with character position
[19:57:26] <kimundi> 'offset' sounds more like it's talking about the byte offset
[19:57:35] <acrichto> eh, I don't feel too strongly
[19:57:52] <kimundi> but really, I on't care about the name, just want to make PR again xD
[19:58:23] <acrichto> well if it were offset I'd personally prefer char_offset_iter()
[19:58:30] <acrichto> yielding (char, uint)
[19:58:31] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[19:58:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/doRNTA
[19:58:31] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[19:58:48] <kimundi> yeah
[20:00:07] <kimundi> (In general I'd like it if the method names where more prefix sorted: 'iter_chars(), iter_chars_offset(), ...', but that's anothhger issue)
[20:00:29] <engla> and further making it really clear that indices mostly mean byte indices
[20:00:36] <engla> where they do
[20:01:33] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:01:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Pc9T0Q
[20:01:33] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:01:36] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[20:01:36] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/81s1QA
[20:01:36] <ghrust> 13rust/06auto 144a85b08 15Luqman Aden: librustc: Stop trying to make invalid slice with vec in static.
[20:01:36] <ghrust> 13rust/06auto 1468b61e8 15Luqman Aden: Add test for #5917.
[20:01:36] <ghrust> 13rust/06auto 1432622ce 15bors: auto merge of #8078 : luqmana/rust/gst, r=Aatch...
[20:01:37] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[20:02:22] <Yurume> kimundi, doesn't `mut_` have a precedence over `iter_` however?
[20:03:09] <engla> normally they all end in iter
[20:03:09] <cmr> bjz: does gl-rs work when the patch from 6661 is applied manually?
[20:03:09] <kimundi> Yurume: I'd write iter_mut()...
[20:03:16] * cmr doesn't care about windows, but would like to play with it
[20:03:23] <cmr> (gl-rs that is)
[20:03:23] <engla> kimundi: it's .mut_iter() everywhere
[20:03:26] <engla> so far
[20:03:51] <Yurume> kimundi, well, my argument is that the mutability of self is not limited to the iterator so it is better to have a global convention.
[20:04:51] <kimundi> engla: Right, I just personally would order the name components in a way that makes similar things come next to each other alphabetically
[20:04:54] <Yurume> anyway, I'm working on something like this: https://gist.github.com/lifthrasiir/6096084
[20:05:14] <Yurume> ...as I have frustrated with near-death of rust-webencodings. ;)
[20:06:30] <kimundi> hm, char_iter or chars_iter ?
[20:06:34] <engla> kimundi: not a bad idea. as long as it's consistent across the crate anything is fine
[20:06:43] <Yurume> iter_chars?
[20:07:17] <engla> str has  .bytes_iter(), .word_iter(), .line_iter(). Only the bytes are plural
[20:07:18] <kimundi> right now there is bytes_iter, split_iter, matches_index_iter, ...
[20:07:52] <kimundi> I think bytes should be byte. Iterator already implies that it's more than one
[20:07:55] <engla> .iter() is a chars_iter()  logically so
[20:07:57] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[20:08:04] <engla> sounds fine
[20:08:15] <engla> so don't use the name.char_iter()
[20:08:34] <kimundi> well, it's going to be char_offset_iter()
[20:08:50] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[20:11:40] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[20:12:24] <sam113101> guys, is there a convention for where to put the brackets? on their own line or on the same line as the condition, etc.
[20:12:58] <cmr> egyptian braces
[20:13:45] <cmr> https://github.com/mozilla/rust/blob/master/src/libstd/option.rs#L102
[20:13:48] <cmr> As a style example.
[20:14:10] <sam113101> IÂ prefer the other way ;(
[20:14:29] <doomlord> i prefer same line, less wasted lines
[20:14:38] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[20:15:14] <engla> it's not wasted though
[20:16:05] <doomlord> another thing is that when you get a grep result on same-line style, you have more informatoin on that line for little extra cost
[20:16:27] <doomlord> (i.e. you know you have the whole declaration or whatever, if you see the open brace)
[20:17:07] <sam113101> I find the other way clearer, but it gets ugly when } else { takes 3 lines
[20:17:35] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[20:17:57] <engla> small if {  } else { }  expressions are ugly either way, too much braces
[20:18:09] <sam113101> true
[20:18:14] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[20:21:36] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[20:22:35] *** Quits: Ms2ger (Ms2ger@E39D6ADF.6D359A20.187A1082.IP) (Quit: nn)
[20:23:43] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[20:24:23] <doomlord> the kind of IDE support c++ has.. where you write a varname and get a dropbox of all the members ..  how do those work.. would they keep the whole AST in memory, with some sort of half compiler that tries with half-written code ... or  would the ast be offline. (i notice xcode with c++ can be extremely slow and benefits from more ram..)
[20:24:26] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[20:25:00] <cmr> doomlord: I would very much hope they use a sort of "completion server" that keeps it in memory
[20:25:12] <cmr> And I'd imagine it keeps some sort of index, rather than the whole AST
[20:25:26] <strcat> the AST isn't very useful
[20:25:45] <strcat> it needs to type check a bit
[20:25:55] <doomlord> ok a symbol database. and just a bit of parsing for the current part you're editing maybe?
[20:25:58] <strcat> libclang is designed from the bottom up to allow dealing with incomplete inputs
[20:26:08] *** Joins: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net)
[20:26:15] <strcat> and to provide things like fetching documentation, completion, quick fix suggestions
[20:26:21] <strcat> static analysis
[20:26:36] <doomlord> i suppose with rust you get a nice fn.... to start a partial compile from.. or at least its easier to skip through.. knowing there's no #defines going on
[20:26:36] <strcat> doomlord: look at youcompleteme
[20:26:40] <strcat> the codebase isn't that complex
[20:26:50] <cmr> youcompleteme is great
[20:26:53] <strcat> librustc isn't designed to do it
[20:27:01] <strcat> it would need a bottom-up rewrite afaik
[20:27:04] <strcat> to deal with this kind of thing
[20:27:15] <doomlord> i've seen on youtube the same sort of thing for javascript, which must be not far off type inference
[20:27:40] <cmr> I think visual studio actually runs the javascript and analyzes the types at runtime
[20:27:42] <cmr> I don't recall
[20:27:43] <doomlord> eg dropbox of object options... wheras javascript is all dynamic typing.. it must be doing whole program tracing
[20:29:14] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[20:29:51] <doomlord> one suggestion... some c++ compilers have a handy error message "see definition of ..." when you try to use something erroneously
[20:30:28] <doomlord> puts the definition of the item in question in the jump-to-error list, great navigation aid
[20:32:51] <doomlord> oh i suppose that wont be so useful with traits/impls for function definitions. still need other ways of searching
[20:33:48] <doomlord> (perhaps it would be excessive to list all the trait impls's at that point when you try to use a non-existent method)
[20:35:36] *** Quits: sankha93 (Instantbir@7061CD01.D6BD0D91.22D41759.IP) (Quit: Gone to save the world!)
[20:36:32] <doomlord> YouCompleteMe looks awesome, similar to the power of visual studio
[20:37:09] <cmr> its subsequence matching is far better than what VS does though
[20:37:35] <doomlord> am i sounding like a visual studio fanboy despite the fact i haven't touched windows in ages :)
[20:37:42] <cmr> no
[20:40:42] <doomlord> on the subject of "fuzzy searches" i was wondering if , short of true language parsing/type inferences, the usefulness of searches could be increased by just adding  searches for nearby types :
[20:41:30] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[20:41:37] <doomlord> eg look at all the types actually mentioned in the function prototype,and when doing a brute force grep (with my unfold tool) further sorting results based on how many nearby types they  contain
[20:41:51] <doomlord> how many nearby types.. or scope words.. whatever
[20:42:29] <doomlord> 'whole words above where you were, with colons before  or after..'
[20:51:39] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[20:53:54] <true_droid> where can I find description of % sigils supported by fmt! ?
[20:54:02] <strcat> the source
[20:54:36] <engla> true_droid: it's only %u, %d, %s and %? I think
[20:54:44] <true_droid> I'm trying, how do I find fmt's definition in the source?
[20:54:52] <strcat> rusti: fmt!("%x", 5)
[20:54:53] -rusti- ~"5"
[20:54:56] <true_droid> git grep 'fmt' is worthless
[20:55:00] <strcat> rusti: fmt!("%x", 99)
[20:55:01] -rusti- ~"63"
[20:55:14] <cmr> it's in libsyntax/ext somewhere
[20:55:21] <true_droid> rusti: fmt!("%x", 1u8)
[20:55:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bNGW
[20:55:27] <kimundi> true_droid: std::unstable::extfmt and libsyntax
[20:55:38] <true_droid> does it print u8?
[20:55:50] <strcat> all needs to be thrown out
[20:55:59] <engla> check src/libstd/unstable/extfmt.rs
[20:56:00] <Luqman> strcat: any idea why an iterator for a vec in a static might go off the end?
[20:56:36] <strcat> Luqman: what types are the elements?
[20:56:58] <true_droid> engla, kimundi: thanks
[20:57:06] <Luqman> strcat: Command<'static>
[20:57:20] <strcat> what's a Command? how big is it?
[20:57:35] <engla> if it's a vec slice there is an issue for that
[20:57:36] <engla> https://github.com/mozilla/rust/pull/8078
[20:57:41] <engla> invalid static slice
[20:58:04] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[20:58:33] <Luqman> strcat: it's from librust/rust.rs
[20:58:53] <strcat> Luqman: it initializes an iterator with vec::raw::to_ptr as ptr and then 'end' as one-past-the-end
[20:59:17] <strcat> Luqman: http://ix.io/6TM and that's an iteration
[20:59:46] <strcat> don't know why it would go wrong
[21:00:29] <strcat> our pointer arithmetic is slow because of using inttoptr ;\
[21:00:47] <cmr> slow pointer arithmetic
[21:00:49] <cmr> there's a new one
[21:01:09] <strcat> because it's not really pointer arith
[21:01:23] <strcat> it's conversion to an int, arithmetic on the int, and conversion back
[21:01:38] <engla> Luqman: what's the type of the static vec?
[21:02:04] <Luqman> engla: &'static [Command<'static>]
[21:02:24] <engla> I think it's related to the issue I linked
[21:02:50] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[21:03:05] <strcat> Luqman: the only explanation I have is that the vector is the wrong size
[21:03:08] <Luqman> engla: i do have that branch applied :P
[21:03:19] *** Quits: henrikhodne (henrikhodn@moz-F3A92B1C.hsd1.ca.comcast.net) (Ping timeout)
[21:03:20] <engla> oh It's your issue
[21:03:29] <engla> :-|
[21:03:32] <Luqman> strcat: calling .len() seems to return the correct value
[21:03:39] <strcat> Luqman: len reads a field
[21:03:48] <strcat> it doesn't know how long it really is
[21:04:05] <strcat> iterators depend on it being a contiguous block of memory with the correct size
[21:05:11] <strcat> although... I don't see how anything else would work if it wasn't
[21:05:26] *** Joins: Houm (Houm@moz-25669AA8.fbx.proxad.net)
[21:05:48] <Luqman> strcat: and seemingly just on mac :|
[21:05:55] <Luqman> it works fine when i try it on linux
[21:06:08] <strcat> both 64-bit?
[21:06:13] <Luqman> yep
[21:06:23] <strcat> can you pastebin the IR of both?
[21:06:32] <strcat> vimdiff on IR > all other debugging tools
[21:06:34] <strcat> ;p
[21:06:58] <strcat> maybe our targetinfo is just wrong
[21:07:07] <strcat> don't know much about that
[21:07:08] *** Joins: lkuper (lkuper@3E7BB638.A402E718.C082B7DC.IP)
[21:08:02] *** Joins: int3_ (int3_@821905EE.3F6DCB94.50E15D33.IP)
[21:08:44] <cmr> Hah
[21:08:54] <cmr> Returning an Iterator rather than an intermediate vector
[21:08:58] <cmr> makes me feel powerful
[21:11:16] <cmr> strcat: writing .iter() makes me wonder if I'm doing the right thing in my API, and the answer if often "no". I suggest not removing it ;P
[21:11:53] <strcat> cmr: hm?
[21:12:31] <cmr> strcat: I was calling .transform(...).collect(), returning that, and then calling .iter() on the result elsewhere
[21:12:43] <cmr> Should *always* return an Iterator, rather than an intermediate collection
[21:13:32] <engla> cmr: can you return that particular iterator? it depends on if there are captures for transform
[21:13:40] <cmr> Oh hm
[21:13:46] <cmr> I hope so
[21:15:37] <cmr> Ok, the type signature is going to be very messy, without a trait object.
[21:16:13] <engla> about that, what do you think strcat about removing the *Iterator suffix from all the adaptor structs
[21:16:21] <strcat> engla: I'd be fine with that
[21:16:31] <cmr> so would I
[21:16:40] <cmr> std::iterator::Map
[21:16:53] <engla> right, it's already a namespace
[21:17:10] <engla> strcat: ok, I'll make a PR for it
[21:18:11] <Luqman> strcat: https://gist.github.com/luqmana/6096303
[21:18:16] <cmr> engla: yeah you're right, I can't
[21:18:21] <cmr> unfortunate..
[21:18:25] <cmr> (without a trait object)
[21:20:19] <engla> cmr: I hit that in hashmap, there is an EnvFilterIterator, like Filter but with a pointer as explicit capture
[21:20:43] <cmr> So, the rustdoc_ng "test" crate (for testing documentation) now ICEs rustc
[21:20:49] <cmr> ;\
[21:23:33] <strcat> Luqman: don't understand why it would be failing there
[21:23:41] <kimundi> engla: So, if I'm adding two Iterator structs I should remove the Iterator suffix as well? :P
[21:24:13] <Luqman> strcat: neither do I. I also can't reproduce it with a smaller test case
[21:24:16] <engla> If they are adaptors just like Chain, Zip etc I think so
[21:24:48] <kimundi> what's the command line for running the stage1 std tests without rebuilding the compiler?
[21:25:00] <cmr> kimundi: make stage1-std I think
[21:25:03] <Luqman> strcat: hmmm, changing it from `&'static [Command<'static>]` to `[Command<'static>, ..7]` works :|
[21:25:39] <engla> kimundi: (this change is only about std::iterator)
[21:25:49] *** Quits: Nefzaoui (chatzilla@DD433556.E0FF0FD3.360EF119.IP) (Ping timeout)
[21:26:00] <kimundi> engla: Ah, okay
[21:26:18] *** Joins: Nefzaoui (chatzilla@DD433556.E0FF0FD3.360EF119.IP)
[21:26:19] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[21:26:25] <kimundi> So you'r not removing the suffixes from, eg, the str iterators?
[21:26:58] <kimundi> cmr: that make target doesn't sound right...
[21:27:16] <cmr> kimundi: it's something ike it... I can never keep the make targets straight in my head
[21:27:31] <engla> didn't intend to kimundi. Particularly the adaptors like Chain, Zip, etc that appear in many return values are better short
[21:27:39] <kimundi> sure
[21:27:48] <kimundi> cmr: hmmm
[21:28:04] <cmr> Or, check-stage1-std
[21:28:06] <cmr> or something
[21:28:08] <kimundi> something somethnig NO_REBULD=true ...
[21:28:19] <cmr> oh right, there's that too
[21:28:37] <kimundi> but is it the correct one?
[21:28:47] <cmr> NO_REBUILD=1
[21:29:06] <kimundi> make check-stage1-std NO_REBUILD=1 ?
[21:29:11] <cmr> I think :)
[21:29:50] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[21:31:07] <Jesse> confusion between obj-c "ARC" and rust "ARC" makes me wonder if we should rename ARC
[21:31:47] <cmr> Jesse: ...to what?
[21:32:05] <kimundi> AARC! :P
[21:32:41] <doomlord> yours is atomic ref counting?
[21:32:45] <cmr> yes
[21:32:51] <kimundi> SRC? syncronized reference counted
[21:32:56] <cmr> for sharing a value between tasks
[21:33:20] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (No route to host)
[21:33:29] <strcat> AtomicRc
[21:33:50] * strcat shrugs
[21:33:51] <doomlord> -S fo Synchronized or S for Shared
[21:34:42] <kimundi> Things I've allways wondered: I remember that the testsuite used to color the "ok", "ignored" and "FAILED" words
[21:35:28] <strcat> going to add extend
[21:36:03] <cmr> https://gist.github.com/cmr/4be1d1d4eb9ff157e924 stuck between a rock and a hard place?
[21:36:15] <cmr> Oh, should probably be ref s, ref toj
[21:36:37] <cmr> yup
[21:38:59] *** Joins: eholk (eholk@moz-374F1653.tmodns.net)
[21:41:03] *** Quits: zoek (Mibbit@84A78AAC.5BB77DD2.3F0F84F7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:43:25] <strcat> https://github.com/thestinger/rust/commit/fe955e7b062f8787f9df7e9c36abc1b83485fead
[21:43:29] <strcat> something like that anyway.
[21:43:36] <strcat> to replace push_all, push_all_move, etc.
[21:44:12] <kimundi> strcat: r? https://github.com/mozilla/rust/pull/8082
[21:44:38] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[21:45:48] <kimundi> strcat: whoops, wait a moment... I think I placed the "rev" at the wrong place in the name
[21:45:53] <strcat> oh
[21:45:55] <strcat> well
[21:45:58] <strcat> is it even consistent already? ;p
[21:46:23] <kimundi> god question
[21:46:32] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[21:46:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/81s1QA
[21:46:32] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[21:46:58] <kimundi> shuold we leave it for later when someone feels like cleaning up :-? 
[21:47:52] * strcat shrugs
[21:47:59] <strcat> if there's a consistent way you should follow that
[21:48:04] <strcat> I just don't know if there is
[21:48:53] <doomlord> so would there be a use for another parser/ast for rust oriented toward IDE support (doing the partial stuf..) - or would it be better for the community to wait for the main compiler to change.  (ANTLR grammar woould mean building a parser is easy?)
[21:49:17] <strcat> an AST doesn't let you do completion
[21:49:30] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:49:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/rp5MQQ
[21:49:30] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:49:33] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[21:49:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/zHGxjg
[21:49:33] <ghrust> 13rust/06auto 14413446c 15Graydon Hoare: rustc: reorganize driver, replace compile_upto with multiple more-obvious functions.
[21:49:33] <ghrust> 13rust/06auto 140981068 15bors: auto merge of #8077 : graydon/rust/reorganize-driver, r=pcwalton...
[21:49:33] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[21:49:40] <strcat> you need essentially the full compiler, just not trans/back
[21:49:57] <cmr> yeah, you need to run resolve and typeck too
[21:50:09] <doomlord> right ok the type inference is the meat of it i guess..
[21:50:26] <strcat> all of resolve, typeck, liveness, borrowck
[21:50:39] <strcat> it's really not designed to work for the completion use case
[21:50:45] <strcat> I don't see it happening for a long time
[21:50:58] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[21:51:30] <doomlord> so in short its just a difficult problem, and chicken/egg .. (many will be offput by the lack of IDE, and many users are needed to make it economical to develop)
[21:52:18] <strcat> engla: I think we should see what other people think about the Iterator suffix one
[21:52:23] <kimundi> strcat: need another r+, switched the "rev" around to make it consistent with the byte_rev_iter
[21:52:35] <strcat> because it's tempting to say it should be Enumerator, etc.
[21:53:08] <strcat> I can't think of similar names for all of them though
[21:54:45] <engla> strcat: ok
[21:55:15] <strcat> for example.... Chain sounds fine alone
[21:55:18] <engla> no names invented, just removed the suffix
[21:55:20] <strcat> Map doesn't really
[21:55:23] <strcat> engla: yeah I know
[21:56:45] *** Quits: farnoy (farnoy@moz-9F3E690F.neoplus.adsl.tpnet.pl) (Client exited)
[21:56:54] <engla> ok will file the PR when your PR lands
[21:58:07] <kimundi> strcat: ... Urk. I think I managed to have two off_by_one bugs in my PR that channel each other out into a passing unit test........
[21:58:15] <strcat> heh
[21:58:41] <cmr> hahah
[22:00:03] <strcat> cmr: https://github.com/mozilla/rust/pull/8074 r? just the last 2
[22:09:12] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[22:15:18] *** Joins: brson (brson@FA215F65.8CBA6D28.848BB095.IP)
[22:15:18] *** ChanServ sets mode: +o brson
[22:16:24] <brson> hi
[22:16:34] <aatch> brson, heyo
[22:17:23] *** Quits: int3_ (int3_@821905EE.3F6DCB94.50E15D33.IP) (Connection reset by peer)
[22:17:26] *** Joins: int3_ (int3_@821905EE.3F6DCB94.50E15D33.IP)
[22:17:47] *** Quits: igl (igl@moz-9A09347.adsl.alicedsl.de) (Ping timeout)
[22:19:15] *** Quits: int3_ (int3_@821905EE.3F6DCB94.50E15D33.IP) (Ping timeout)
[22:19:20] *** Joins: igl (igl@moz-CE89F295.adsl.alicedsl.de)
[22:20:12] <cmr> zsh: segmentation fault (core dumped)  rustdoc_ng -p basic main.rs
[22:20:19] <cmr> I knew it'd explode as soon as I tried it.
[22:23:51] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[22:24:16] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[22:24:23] <cmr> Hm it might not be my fault..
[22:25:41] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Ping timeout)
[22:26:40] *** Joins: int3_ (int3_@821905EE.3F6DCB94.50E15D33.IP)
[22:29:36] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[22:34:17] <cmr> GUH
[22:34:39] <cmr> The destructor on the DynamicLibrary is being called
[22:34:47] <cmr> which runs dlclose
[22:35:16] <cmr> let lib = dl::DynamicLibrary::open(Some(&x)).unwrap();
[22:35:18] <cmr> let plugin = unsafe { lib.symbol("rustdoc_plugin_entrypoint") }.unwrap();
[22:35:20] <cmr> self.dylibs.push(lib);
[22:35:24] <cmr> it's getting called either in or after the unwrap afaict
[22:36:17] <cmr> and then exploding when I try to get the symbol
[22:38:55] <doener> weird
[22:40:19] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[22:41:24] <sam113101> is it possible to use SFML with rust?
[22:41:26] <doener> cmr: does it help to do: let lib_result = dl::DynamicLibrary::open(Some(&x)); let lib = lib_result.unwrap(); ?
[22:41:53] <aatch> sam113101, SFML?
[22:42:19] <sfackler> sam113101: try this https://github.com/JeremyLetang/rust-sfml
[22:42:25] <sfackler> not sure how complete it is
[22:42:47] <sam113101> thanks
[22:43:18] <Earnestly> aatch: It's basically SDL in C++
[22:43:47] <aatch> Earnestly, ahh. I think I've played with it briefly.
[22:44:07] *** Quits: tcsc (tcsc@moz-7246F5CD.hsd1.ma.comcast.net) (Quit: computer sleeping)
[22:44:36] <sam113101> what kind of library do window managers use to draw the windows?
[22:45:53] <strcat> windows draw themselves
[22:46:05] <sam113101> I mean, the borders
[22:46:08] <sam113101> and the effects
[22:46:54] <Earnestly> That's usually the job of the toolkit you're using or the compositor, such as gnome/kde mutter/kwin resp.
[22:47:11] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[22:47:19] <Earnestly> (or pure xlib/xcb)
[22:47:28] <Earnestly> (afaik)
[22:47:57] <sam113101> can they use SFML? does it even make sense?
[22:49:03] <Earnestly> Yes and not really.
[22:49:32] <Earnestly> There's the ICCCM which the WM's should obey (and EWMH)
[22:49:42] <Earnestly> (At least on Linux, I have no idea about other platforms)
[22:49:52] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Quit: Leaving)
[22:50:43] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[22:51:22] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Client exited)
[22:52:01] <sam113101> IÂ wish IÂ was smart enough to write my own window manager
[22:52:10] <aatch> sam113101, it's not actually too hard.
[22:52:14] <sam113101> maybe I'll wait until mir is out and stable?
[22:52:23] <aatch> sam113101, for a basic one anyway.
[22:52:30] *** Quits: victorporof (victorporo@3A55AFE3.1C233438.79933D60.IP) (Quit: victorporof)
[22:52:35] <sam113101> IÂ don't want to build it for X and have to rewrite it later
[22:52:37] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[22:52:56] <Earnestly> Wayland got a drawing library recently heh
[22:53:06] <sam113101> will IÂ be able to write it in rust?
[22:53:14] <Earnestly> http://lists.freedesktop.org/archives/wayland-devel/2013-July/010375.html
[22:54:07] <aatch> sam113101, yep.
[22:54:18] <sam113101> sweet
[22:54:21] <aatch> sam113101, there's bindings to xcb for Rust
[22:54:25] <Earnestly> sam113101: At least on Linux you'll target X and/or Wayland (or maybe a weston plugin). 
[22:54:41] <aatch> I'm not sure about Wayland, I vaguely remember seeing something for it.
[22:54:56] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[22:55:11] <sam113101> I don't know which one of wayland or mir will take over
[22:55:23] <sigma> wayland
[22:55:26] <Earnestly> aatch: Try the implementationÂ¸ weston, when you have a chance.
[22:55:27] <aatch> sam113101, given that I've never heard of mir, wayland
[22:55:40] <sam113101> sigma: what makes you think that?
[22:55:41] <kimundi> how hard would writing a basic compositing manager be?
[22:55:43] <jensnock_> Wayland, since I dislike Ubuntu.
[22:56:01] <jensnock_> (Also for technical reasons)
[22:56:04] <Earnestly> aatch: Mir is ubuntu's display manager, it doesn't have much traction outside of ubuntu.  It currently doesn't really do anything
[22:56:18] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[22:56:38] <sam113101> it's a windowing system/display server
[22:57:01] <aatch> Earnestly, ah. I like Wayland because they fully admit that replacing X will be very, very hard and therefore wayland is intended to make it possible to still use X
[22:57:03] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:57:05] <sigma> wayland has support from all the DEs, mir is only being developed against by canonical
[22:57:33] <Earnestly> aatch: You'd use xwayland.so inside weston, it's running a rootless Xserver under weston.
[22:59:23] <aatch> Earnestly, yeah, I've read the docs for Wayland, haven't really looked at weston yet though.
[23:01:50] <Earnestly> aatch: A lot still crashes outside of the basics like the demos weston includes and the very lovely wlterm (which is even faster than vte3).  Pretty much all DEs and Toolkits target wayland, stuff like SDL already works there.
[23:02:31] <Earnestly> s/are all targetting wayland/ â€” not quite there yet
[23:02:50] <Earnestly> E.g. https://wiki.gnome.org/Wayland/Applications
[23:03:34] <sam113101> I'm so lost
[23:03:41] <sam113101> wayland is only a protocol, right?
[23:04:02] *** Quits: eholk (eholk@moz-374F1653.tmodns.net) (Quit: eholk)
[23:04:51] <Earnestly> sam113101: That's correct.  Much like X is a protocol.  There are various implementations such as Xorg and Xephyr
[23:05:11] <engla> kimundi: is it possible to write the char offset iterator to be double-ended?
[23:05:11] <Earnestly> weston is an implementation compositor of the wayland protocol.
[23:05:27] <sam113101> Applications render graphics to their own buffers, and the window manager becomes the display server, compositing those buffers to form the on-screen display of application windows.
[23:05:30] <sam113101> ooooooh
[23:05:31] <kimundi> engla: Hm, might be
[23:05:48] <sam113101> IÂ was like, "but where's the windowing system itself?"
[23:05:55] <kimundi> engla: Would have to carry around two indices
[23:06:10] <engla> yeah
[23:06:46] <engla> but logically this is double-ended, like a slice
[23:07:25] <sam113101> is it easier to code a wayland WM than something that runs on X.org? or same difficulty?
[23:07:38] <Earnestly> sam113101: http://vignatti.com/2013/03/05/ui-customization-on-wayland/
[23:07:49] <kimundi> engla: Could you open a issue? "Replace forward ant backwards iterators with double ended ones where applicable" - byte_iter would also fall under this
[23:08:51] <engla> kimundi: ok. bytes_rev_iter is ironic because it just struct-wraps the inversion of the normal vec iterator
[23:09:03] <engla> as in it wraps a bi iterator in a non bi di way
[23:09:06] <engla> bidirectional
[23:09:22] <kimundi> oh xD
[23:09:44] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130725195523])
[23:10:28] <Earnestly> sam113101: <http://community.kde.org/KWin/Wayland> might be a little enlightening
[23:10:41] *** Quits: Nefzaoui (chatzilla@DD433556.E0FF0FD3.360EF119.IP) (Quit: ChatZilla 0.9.90.1 [Firefox 22.0/20130618035212])
[23:11:18] <kimundi> engla: I guess the correct way would be to remove all rev iters where the normal one is a double ended one
[23:11:42] <kimundi> engla: because you can allways call .invert() on them to get a normal reverse iter
[23:11:44] *** Quits: LU324_ (stuff@moz-A17E9A7B.dyn.embarqhsd.net) (Ping timeout)
[23:12:01] <kimundi> hmm
[23:12:35] <engla> kimundi: maybe
[23:12:45] *** Quits: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[23:12:47] *** Quits: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[23:12:52] *** Quits: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca) (Ping timeout)
[23:13:07] <sam113101> does windows also have a display server and protocol?
[23:13:54] <kimundi> what exactly is the semantic of a double ended iterator anyway? iterate from start to end, with both sides being movable to each other, if they meet each other  they return None. Or can both ends pass each other to reach their original end/start  points?
[23:14:49] <Earnestly> sam113101: The clients shouldn't have to care, the WM Toolkits/Display Server handles that
[23:15:05] <engla> kimundi: the points can't pass. It's like a range or deque where you can pick off from either end
[23:15:15] <kimundi> okay
[23:16:17] <sam113101> Earnestly: IÂ get this, but IÂ mean, windows does more or less what linux is doing, right?
[23:16:42] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[23:18:07] <kimundi> strcat: Would there be any problem with transform the char, byte and char_offset iterators from two forward/backward ones into one DoubleEnded one?
[23:18:56] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[23:19:18] <engla> as long as it's valid utf-8 it's no problem
[23:20:16] <Earnestly> sam113101: No idea.  If you want more insight into how WindowsÂ® works you might want to read over oldnewthing's blog posts: <https://blogs.msdn.com/b/oldnewthing/?Redirected=true
[23:20:23] <kimundi> problem in the sense that a double ended one would be twice as large because it has to track two position values instead of one
[23:20:50] <sam113101> thanks
[23:20:54] <engla> true
[23:21:20] <engla> the bytes iter is of course no problem, since the underlying veciterator already is bidi
[23:22:00] <Earnestly> sam113101: <https://blogs.msdn.com/b/oldnewthing/archive/tags/code/> *shrug*
[23:22:32] *** Joins: jgilbert (jgilbert@986623D2.9083A694.9CA62458.IP)
[23:23:49] *** Joins: jgilbert_ (jgilbert@986623D2.9083A694.9CA62458.IP)
[23:24:07] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[23:24:21] *** Quits: jgilbert (jgilbert@986623D2.9083A694.9CA62458.IP) (Ping timeout)
[23:26:26] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[23:27:29] *** Joins: LU324 (stuff@moz-A17E9A7B.dyn.embarqhsd.net)
[23:28:38] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[23:29:44] *** Joins: etw (john@5ADED2BB.8145FF59.D8D886B.IP)
[23:32:06] *** Joins: Nefzaoui (chatzilla@DD433556.E0FF0FD3.360EF119.IP)
[23:32:19] *** Quits: sebcrozet (sebcrozet@moz-C27D92D8.w193-252.abo.wanadoo.fr) (Ping timeout)
[23:34:29] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[23:34:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zHGxjg
[23:34:29] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[23:37:31] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[23:37:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/M8-MSg
[23:37:31] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[23:37:32] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[23:37:32] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/TxhAyg
[23:37:32] <ghrust> 13rust/06auto 14d6bc438 15Daniel Micay: make RandomAccessIterator inherit from Iterator
[23:37:32] <ghrust> 13rust/06auto 14d7c9bb4 15Daniel Micay: vec: add mut_slice_{to,from}...
[23:37:32] <ghrust> 13rust/06auto 147ae17e0 15blake2-ppc: Remove dummy type parameters from iterator adaptors...
[23:37:34] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[23:39:37] *** Joins: jj2baile (jon@moz-DCEF6040.csclub.uwaterloo.ca)
[23:39:37] *** Joins: ssalbiz (ssalbiz@moz-DCEF6040.csclub.uwaterloo.ca)
[23:39:41] *** Joins: Luqman (laden@moz-DCEF6040.csclub.uwaterloo.ca)
[23:41:57] *** Joins: goffrie (goffrie@moz-1A2DE2C4.dsl.ncf.ca)
[23:47:29] *** Quits: brson (brson@FA215F65.8CBA6D28.848BB095.IP) (Quit: leaving)

[00:01:03] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[00:02:09] <SiegeLord> strcat: Are you planning on adding a repeat() iterator method? Would you approve a PR for it?
[00:02:13] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[00:03:13] <graydon> brson: so wait, currently on buildbot if we set targets to nonempty, it passes that as --host-triples
[00:03:16] <graydon> is that correct?
[00:03:37] <strcat> SiegeLord: yes, it should probably take T and then yield &T over and over
[00:04:10] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[00:04:11] <strcat> I'm not sure how useful it'd be though
[00:04:17] <strcat> maybe we should wait for a use case
[00:04:43] <engla> isn't it possible to let it take T and yield T over and over.. the use can provide &Type as T if it's not copyable (?)
[00:04:45] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[00:04:48] <engla> *the user
[00:04:59] <SiegeLord> I'm using it in my plotting library, for horizontal lines and some other things
[00:05:29] <strcat> SiegeLord: ah that makes sense, since you'd have an iterator-based interface
[00:05:33] <SiegeLord> Yeah
[00:05:36] <strcat> anyway yeah, I'll r+ a PR if you make one
[00:05:42] *** cscottnet is now known as cscott
[00:06:38] <strcat> engla: no, not without making two of them
[00:06:49] <strcat> well
[00:07:03] <brson> graydon: no, I don't think so. --build-triple gets a default value, --host-triples are a superset of --build-triple and --target-triples is a superset of --host-triples. if you specify a --target-triple that does not include the --build-triple then the build triple is automatically added to the target triple
[00:07:35] <strcat> there's no trait for implicit copies
[00:07:39] <brson> graydon: so e.g. on x86_64, ../configure --target-triple=i686-... is shorthand for ./configur --build-triple=x86_64.. --host-triples=x86_64.. --target-triples=x86_64...,i686...
[00:07:45] <graydon> brson: so you think it should pass --target-triples
[00:07:46] <engla> strcat: well there used to be Copy :)
[00:07:51] <brson> graydon: no, host-triples
[00:08:00] <graydon> oh. that's what it does now.
[00:08:09] <strcat> engla: Copy is being replaced by Clone though
[00:08:12] <brson> yeah. that's the hardest cross-scenario
[00:08:16] <brson> --target-triples would be much faster
[00:08:19] <strcat> and for example[1, 2, 3] isn't Clone yet
[00:08:20] <graydon> I asked if you thought that was correct, you said no. now I'm confused.
[00:08:37] <engla> strcat: yes I know but I hoped this use case would be covered
[00:08:39] <brson> graydon: oh, I misunderstood the q
[00:08:40] <graydon> I am happy to wire it up to do any combination
[00:08:53] <brson> yes, it's correct
[00:08:55] <strcat> I guess repeat could use T: Clone
[00:09:58] <engla> it does work fine with T:Copy so something that will shallow copy borrows etc
[00:10:26] *** Joins: MaikKlein (maik@moz-ECF25244.dip0.t-ipconnect.de)
[00:11:03] <graydon> brson: so do we want anything doing multi-host mode?
[00:12:12] <graydon> on auto
[00:12:38] <brson> graydon: yes, I think we need to - it's been a source of a lot of breakage
[00:12:51] <graydon> currently buildbot only knows single-host and multi-host modes. but it has no configs for building linux32-only; it only does linux32-as-part-of-multi-host
[00:12:56] <MaikKlein> hm github has a new design
[00:13:09] <graydon> I was thinking I would set up linux32-alone for parallelism sake
[00:13:14] <brson> graydon: isn't auto currently only doing a single host?
[00:13:15] <Aetherspawn_BNC> I hear talk about 0.7 but windows library loading and shared libraries produced on windows are brutally broken right now :P
[00:13:21] <enix> I wanted to play around with Rust since it looks pretty sweet. Anyway, I ended up implementing most of SHA-2 (224, 256, 512, 384, 512/256, and 512/224 modes). As best as I can tell, Rust doesn't currently have implementations of these functions. Is there an implementation i'm unable to find somewhere, or would it make sense to cleanup my implementation and submit it?
[00:13:24] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[00:13:29] <brson> graydon: yeah, auto currently doesn't build multiple hosts
[00:13:35] <graydon> brson: yes. currently. but I just set it to target:all, meaning multihost
[00:13:39] <brson> graydon: oh
[00:13:45] <graydon> (as per request!)
[00:14:13] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[00:14:18] <graydon> a lesser thing would be to have it do single-host, but have a separate 32bit builder
[00:14:52] <brson> graydon: if you have the energy and the botpower then i suggest setting up one linux bot as 32-bit build-triple, one 64, same for mac, then one final linux multi-host that doesn't bother testing
[00:15:00] <dbaupp> Aetherspawn_BNC: releases are time based, not feature based
[00:15:06] <graydon> brson: doesn't bother testing, eh?
[00:15:15] <graydon> same tests either way?
[00:15:18] <brson> graydon: in theory the binaries should be identical
[00:15:19] <brson> yeah
[00:15:20] <dbaupp> Aetherspawn_BNC: i.e. 0.7 is basically "whatever is ready at the end of the month"
[00:15:25] <graydon> ok
[00:15:56] <Aetherspawn_BNC> That's frightening.
[00:16:06] <dbaupp> Aetherspawn_BNC: why?
[00:16:16] <aatch> enix, it would probably be ok in libextra
[00:16:19] <strcat> MaikKlein: they redesign parts every day ;p, it's never ending
[00:16:21] <Aetherspawn_BNC> what if someone makes like a 10% regression before the 0.7 release
[00:16:25] <Aetherspawn_BNC> and then it gets bundled into the windows installer
[00:16:33] <strcat> MaikKlein: endless css tweaks :\
[00:16:45] <aatch> strcat, yeah, but this is a big layout change
[00:16:47] <dbaupp> Aetherspawn_BNC: yeah?
[00:17:01] <dbaupp> Aetherspawn_BNC: (it's pretty clear that the language is alpha ;) )
[00:17:15] <aatch> Aetherspawn_BNC, and? what if somebody makes a 10% improvement a day after the release and it doesn't get in?
[00:17:36] <brson> graydon: of course, not testing the multi-host scenario leaves us open to breaking the makefiles that handle cross-compile testing...
[00:17:42] <brson> maybe we can smoke test a subset
[00:17:45] <brson> check-lite
[00:17:46] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[00:18:00] <graydon> will that be sufficient?
[00:18:01] <brson> there are a lot of ways to build rust
[00:18:07] <graydon> yeah. too many :(
[00:18:30] <brson> i think check-lite will be sufficient for verifying that the makefiles more-or-less work. turn valgrind off too for multi-host
[00:18:34] <Aetherspawn_BNC> aatch: it leaves them hangng for 0.8 !
[00:18:35] <brson> since the results should be identical
[00:18:39] <Aetherspawn_BNC> *hanging.
[00:18:47] <graydon> oh, you want V on for single host? (on auto)
[00:19:21] <aatch> I'm reluctant to have valgrind on auto for single host.
[00:19:27] <cmr> Aetherspawn: You called?
[00:19:31] <brson> graydon: um, I think we could get by without, but only if we continue testing master. valgrind failures are less common these days
[00:19:51] <brson> turning on valgrind on auto would let me feel relatively confident about turning off the master builds
[00:19:57] <graydon> mhm
[00:20:04] <aatch> I mean, the valgrind-related I errors I've seen are only tangentially related to valgrind.
[00:20:09] *** Joins: k00mi (koomi@moz-543186DC.pools.arcor-ip.net)
[00:20:32] <Aetherspawn> hi cmr, are those benches up anywhere :)
[00:20:41] *** Quits: koomi (koomi@moz-73D7CCF0.pools.arcor-ip.net) (Ping timeout)
[00:20:45] <cmr> Aetherspawn: I have the runner complete if you want to run them yourself :)
[00:20:45] <aatch> like "this environment variable that valgrind sets doesn't get inherited"
[00:20:54] <cmr> Aetherspawn: linux-only because of how it measures memory: https://gist.github.com/cmr/5792998
[00:21:02] <cmr> Aetherspawn: there are benchmarks in src/test/bench
[00:21:15] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[00:21:17] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:21:30] <cmr> I'm still refactoring it though, it's massively spaghetti code right now
[00:22:05] <Aetherspawn> aww, linux only. :P
[00:22:32] <cmr> feel free to port it if other platforms have equivalently accurate memory reporting :(
[00:22:37] <cmr> * :)
[00:23:29] <Aetherspawn> as much as it'd be awesome, the clbg is linux-only
[00:23:36] <Aetherspawn> so I'll pass on that one
[00:23:44] <cmr> clbg?
[00:23:50] <cmr> libcg?
[00:23:52] <Aetherspawn> computer language benchmarks game
[00:23:54] <cmr> oh
[00:24:03] <enix> aatch: ok, cool, thanks. I'll clean it up a bit and submit it. I just wanted to make sure there wasn't some implementation of these functions about to land before I spent more time on it.
[00:24:06] <cmr> well it's not for that, it's for isrustfastyet
[00:25:05] *** Joins: jedestep (jedestep@moz-7D1551F6.natpool.nyu.edu)
[00:25:21] <strcat> cmr: I don't think other OSes have a way to measure stuff for a group of processes
[00:25:36] <strcat> or accurately measure mem usage at all, including kernel resources
[00:25:50] <Aetherspawn> strcat, GetProcessMemoryInfo in psapi for windows
[00:26:07] <cmr> I think windows does, the sysinternals stuff is pretty awesome. but it's not a pretty api like cgroups
[00:26:25] <strcat> Aetherspawn: for the children too?
[00:26:30] <cmr> Aetherspawn: cgroups also track threads and child processes
[00:26:52] <Aetherspawn> "Contains the memory statistics for a process." -- one could assume so, but I wouldn't know.
[00:27:10] <strcat> Aetherspawn: I wouldn't assume that
[00:27:31] <strcat> 'a process' doesn't usually include 'anything the process has spawned'
[00:27:36] *** Quits: tjc (tjc@moz-A1C344A0.war.clearwire-wmx.net) (Quit: zzzzzzzzzz)
[00:27:38] <strcat> threads, yes
[00:27:39] <cmr> per-process has kernel resources
[00:27:45] <Aetherspawn> children threads, but not children processes
[00:27:56] <strcat> cmr: not accurately, there are resources shared between processes like shared libraries
[00:28:03] <cmr> http://msdn.microsoft.com/en-us/library/windows/desktop/ms684824%28v=vs.85%29.aspx and http://msdn.microsoft.com/en-us/library/windows/desktop/ms684874%28v=vs.85%29.aspx
[00:28:09] <cmr> strcat: that I don't know about
[00:28:14] <strcat> you can look at per-process memory usage on linux too but it's not accurate
[00:28:34] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[00:28:47] <strcat> cat /proc/self/maps
[00:29:19] <cmr> yes I've used procfs before
[00:29:20] <strcat> and you can know the virtual memory usage, but it's hard to really know the actual usage
[00:29:27] <cmr> not nearly as nice as cgroups
[00:29:46] <strcat> windows doesn't lazily allocate all pages but it does have the same thing with mapped memory
[00:30:28] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[00:30:31] <graydon> brson: opt vs. no-opt variants of everything as well?
[00:30:58] <graydon> or just "everything opt plus one no-opt linux 64", say?
[00:31:12] <brson> graydon: the latter i think is a great start
[00:31:35] * brson wonders if windows is still broken w/o opts
[00:32:05] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[00:32:14] *** Joins: qmx (qmx@E752832C.183C69CE.45D46379.IP)
[00:32:47] <jedestep> trying my question again: having trouble with multiple borrow errors. code is https://gist.github.com/jedestep/5801744 any suggestions?
[00:33:54] <cmr> jedestep: I get `error: cannot borrow immutable field as mutable` on master
[00:34:09] <cmr> which makes sense: you need &mut self to mutate self
[00:34:29] <jedestep> cmr: try to borrow self as &mut and it will throw a different error
[00:34:39] <dbaupp> jedestep: try `let i = self.getval(); self.buf.push(i);`
[00:34:45] <cmr> jedestep: you need an intermediate
[00:35:14] <jedestep> why does it need an intermediate, out of curiosity?
[00:35:18] <cmr> jedestep: because you can't have a mutable and immutable borrow at the same time
[00:35:20] <cmr> I think it's a bug
[00:35:26] <cmr> or, at least, there's an issue for it.
[00:35:31] <jedestep> ok
[00:35:37] <dbaupp> jedestep: the borrow checker isn't very aware of rvalues yet
[00:35:42] <jedestep> i was going to say this seems like something that should be cleaned up 
[00:35:48] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[00:35:50] <jedestep> because that is extremely unintuitive
[00:36:06] <jedestep> as long as someone is aware of it though, all's good :)
[00:36:07] <cmr> yup, https://github.com/mozilla/rust/issues/5074
[00:37:04] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.2.1)
[00:37:41] <dbaupp> specifically https://github.com/mozilla/rust/issues/6268
[00:37:43] <cmr> specifically https://github.com/mozilla/rust/issues/6268
[00:37:50] <cmr> dbaupp: aw man, beat me to it :)
[00:38:05] <dbaupp> heh
[00:38:55] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[00:41:25] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[00:41:29] <MaikKlein> what does unwrap do?
[00:41:58] <cmr> MaikKlein: returns the x in Some(x) of an Option, failing if it's None
[00:42:06] <cmr> failing as in fail!()
[00:42:13] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[00:42:14] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[00:43:08] <MaikKlein> cmr, ah thanks
[00:43:14] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:44:01] <MaikKlein> http://static.rust-lang.org/doc/std/option.html methods and function are not listed. didn't this work yesterday?
[00:44:09] <MaikKlein> I mean as a link
[00:44:27] <cmr> I don't think so.
[00:44:35] <cmr> http://static.rust-lang.org/doc/std/option.html#implementation-for-optiont-where-t has always been the only method list
[00:44:39] <cmr> afaik at least
[00:44:49] <cmr> MaikKlein: rustdoc is next on my todo list :)
[00:45:14] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[00:45:16] <MaikKlein> hm maybe it was just a dream
[00:46:01] <dbaupp> MaikKlein: the functions aren't listed because they've been removed (everything's a method now.)
[00:46:20] <cmr> oh, right
[00:46:26] <cmr> that'd explain it :)
[00:49:02] <aatch> cmr, TodoList/BlackHole
[00:49:07] <MaikKlein> bjz, lol you didn't write key_to_str by yourself or did you :D ? https://github.com/bjz/glfw-rs/blob/master/examples/callbacks.rs
[00:49:46] <cmr> aatch: nonono, my todo list *actually* gets done :p
[00:50:05] <bjz> MaikKlein: multiple cursors to the rescue
[00:50:15] <bjz> MaikKlein: (sublime text)
[00:50:47] <MaikKlein> bjz, haha
[00:51:08] <Aetherspawn> sublime text multiple cursors are great
[00:51:21] <Aetherspawn> cmr, that patch I sent you the other day, did that get tossed? :P
[00:51:42] <cmr> Aetherspawn: tossed? no. open a pull request :)
[00:51:56] <Aetherspawn> aw, I dont know if it even builds.
[00:51:59] <Aetherspawn> I haven't set that up yet
[00:52:04] <Aetherspawn> I'll do it after my exam.
[00:52:06] <cmr> ah, let me apply and test it for yout hen
[00:52:07] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[00:52:48] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:52:50] <Eridius> did the hash of std change again?
[00:52:56] <cmr> Eridius: yes
[00:53:01] <Eridius> why?
[00:53:12] <graydon> the url was wrong
[00:53:16] <graydon> still pointed to core
[00:53:22] <graydon> (not that it ever really pointed to anything)
[00:53:26] <graydon> brson: check buildbot :)
[00:54:34] <MaikKlein> hm do we now need to use Test::init() instead of Test::new (convention I know)?
[00:54:59] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[00:55:09] <Eridius> hmm, I have a parameterized method on &[~[T]] where T:Copy, but current rustc thinks foo[a][b] should move instead of copy the value
[00:55:11] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[00:55:11] <Eridius> didn't used to think that
[00:55:14] <Eridius> what h changed?
[00:55:53] <Eridius> err, make that function taking &[~[T]] if that makes a difference
[00:56:10] <MaikKlein> I thought they might want to use "new" as a keyword and I saw init a couple of times now.
[00:56:17] <dbaupp> Eridius: you need an explicit copy for T: Copy now
[00:56:26] <Eridius> dbaupp: ?/
[00:56:29] <Eridius> err :/
[00:56:37] <dbaupp> Eridius: 'copy foo[a][b]'
[00:56:57] <aatch> Eridius, no more implicit copies for most things.
[00:57:17] <Aetherspawn> Whoever alexcrichton is, he's welcome to borrow my machine for debugging windows llvm stuff
[00:57:32] <cmr> acrichto: ^
[00:57:33] <aatch> paging acrichto 
[00:57:49] <aatch> Eridius, also, Copy is deprecated, so use clone instead.
[00:57:51] <acrichto> debugging windows?!
[00:58:05] <acrichto> Aetherspawn: what did you have in mind?
[00:58:24] <Aetherspawn> Well, I don't know how you prefer to track down llvm issues
[00:58:48] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[00:58:51] <Aetherspawn> but I've got IDA and some other stuff here if that's what you normally use, and I can hook you up with VNC or TeamViewer, whichever you prefer. It'll feel like a VM.. kinda. :\
[00:58:53] <Eridius> dbaupp: how the hell do I bind-by-copy in a match case? It won't let me use the copy keyword there
[00:58:59] <Aetherspawn> On the other hand, if you make it simple, I can try and do it for you.
[00:59:01] <Eridius> but I have a match that needs a copy
[00:59:06] <dbaupp> Eridius: you can't
[00:59:12] <strcat> Eridius: by-ref and then copy
[00:59:16] <Eridius> bah
[00:59:19] <Aetherspawn> I know assembler. I'm actually quite a profecient reverse engineer.
[00:59:59] <dbaupp> Eridius: (you're having a fun time with language changes, right? ;P )
[01:00:16] <cmr> nmatsakis: Aetherspawn might be able to help you with your mysterious windows bug (if you haven't figured that out yet)?
[01:00:56] <strcat> graydon: auto looks unhappy ;p
[01:01:20] <cmr> hoo boy, look at that
[01:01:22] <Eridius> dbaupp: ಠ_ಠ
[01:01:27] <Eridius> 			(Some((ref old, _)), ref u) if *u > *old => Some((copy *u, x)),
[01:01:29] <Eridius> oops
[01:01:32] <Eridius> didn't mean to paste that as-is
[01:01:55] <Eridius> my nice old (Some((old, _)), u) if u > old => Some((u, x)),
[01:01:57] <Eridius> now looks like (Some((ref old, _)), ref u) if *u > *old => Some((copy *u, x)),
[01:02:40] <Aetherspawn> (I'm actually running off to an exam now, bye)
[01:02:42] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[01:02:43] <cmr> configure: CFG_HOST_TRIPLES     := i,6,8,6,-,a,p,p,l,e,-,d,a,r,w,i,n 
[01:02:46] <cmr> good job :p
[01:02:49] <Eridius> haha
[01:03:05] <MaikKlein> where do I find .finally for functions?
[01:03:11] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[01:03:23] * cmr off to bed
[01:03:31] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Quit: Leaving)
[01:03:37] <steven_is_false> MaikKlein: It's in unstable
[01:04:01] <graydon> cmr: yeah yeah, on it
[01:04:17] <graydon> want to rewrite buildbot in a language with static types sometime? :)
[01:04:52] <graydon> wait, what's that, the distant echo of "I never have real type errors in my dynamic language"
[01:04:55] <MaikKlein> steven_is_false, unstable?
[01:06:09] <Eridius> MaikKlein: std::unstable::*
[01:06:59] *** Quits: eholk (eholk@moz-5D9C91FC.uconnect.utah.edu) (Quit: eholk)
[01:07:23] <MaikKlein> hm but unstable is not listed here http://static.rust-lang.org/doc/std/index.html
[01:08:26] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:08:29] <graydon> LLVM 3.3 is out
[01:08:45] <dbaupp> MaikKlein: it's been #[doc(hidden)]'d
[01:09:11] *** Quits: cr (anonymous@moz-C4FDC.dip0.t-ipconnect.de) (Quit: cr)
[01:09:15] <aatch> graydon, I saw.
[01:09:20] <MaikKlein> :(
[01:09:58] <graydon> huh. they switched to sphynx
[01:10:12] <graydon> I keep hearing this would have been wiser than pandoc+md
[01:10:15] <graydon> hard call
[01:10:23] <strcat> graydon: I think sphinx learned how to extract docs from C/C++ with libclang
[01:10:33] <dbaupp> MaikKlein: you can always just use the source
[01:11:04] <aatch> Wow... auto exploded.
[01:11:26] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:11:28] *** Quits: MaikKlein (maik@moz-ECF25244.dip0.t-ipconnect.de) (Ping timeout)
[01:11:36] <strcat> now that libclang has doxygen support
[01:11:55] <graydon> s390 support! woot
[01:12:03] <graydon> aatch: no, it just multiplied :)
[01:12:27] <aatch> graydon, lol. I meant being red across the board.
[01:12:39] <graydon> that's because I did something silly
[01:12:43] <graydon> I'm still trying to get it working
[01:12:59] <graydon> buildbot config is "writing a little python program"
[01:13:22] <aatch> I figured, since they all failed on configure.
[01:13:40] <graydon> so I had to add some new brains about different builders. which has .. well, the "platform" abstraction I was using before was pretty fuzzy anyways
[01:13:50] <graydon> now it's shot to hell. I should rewrite the config at some point.
[01:13:58] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:13:58] <graydon> but it might hold together for now
[01:14:09] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[01:14:16] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[01:14:19] <bjz> rusti: use sys::size_of_value; (size_of_value([1, 2, 3]), size_of_value(&[1, 2, 3]))
[01:14:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IhRh
[01:14:40] <bjz> rusti: use std::sys::size_of_value; (size_of_value([1, 2, 3]), size_of_value(&[1, 2, 3]))
[01:14:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TVAO
[01:15:09] <bjz> rusti: use std::sys::size_of_val; (size_of_val([1, 2, 3]), size_of_val(&[1, 2, 3]))
[01:15:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LWHi
[01:15:24] <bjz> #-_-
[01:15:24] *** Joins: goffrie (goffrie@moz-9153684F.dsl.ncf.ca)
[01:15:35] <Aetherspawn_BNC> ;__; I get global alerts on my phone every time that happens
[01:15:45] <dbaupp> rusti: use std::sys::size_of_val; (size_of_val(&[1, 2, 3]), size_of_val(& &[1, 2, 3]))
[01:15:46] -rusti- <anon>:9:55: 9:65 error: mismatched types: expected `&<V4>` but found `&[<VI2>]` (expected &-ptr but found vector)
[01:15:46] -rusti- <anon>:9     let r = {  use std::sys::size_of_val; (size_of_val(&[1, 2, 3]), size_of_val(& &[1, 2, 3])) };
[01:15:46] -rusti-                                                                 ^~~~~~~~~~
[01:15:46] -rusti- error: aborting due to previous error
[01:15:46] -rusti- application terminated with error code 101
[01:16:00] *** Quits: k00mi (koomi@moz-543186DC.pools.arcor-ip.net) (Ping timeout)
[01:16:05] <graydon> ok, heading out
[01:16:09] <dbaupp> rusti: use std::sys::size_of_val; (size_of_val(&([1, 2, 3])), size_of_val(& &[1, 2, 3]))
[01:16:11] -rusti- (24, 16)
[01:16:12] <graydon> I've caused enough havoc for one evening
[01:16:18] <graydon> hopefully the bots don't melt down overnight
[01:16:39] *** Quits: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu) (Quit: Leaving)
[01:16:48] <graydon> sorry for the abrupt closure everyone. pending 0.7 release kinda snuck up on me, past couple weeks have been very very silly
[01:16:49] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[01:17:04] *** Quits: graydon (Adium@moz-20B06F71.ptr.terago.net) (Quit: Leaving.)
[01:20:30] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[01:20:39] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:20:47] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:24:32] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[01:25:59] <enticeing> the 0.7 release is very soon then?
[01:27:23] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:27:32] <aatch> enticeing, end-of-the month is the goal.
[01:27:43] <aatch> though it'll likely get pushed back a week or two
[01:29:57] <steven_is_false> Recently, a patch was pushed adding some support for debug info in Rust. How might I configure a debug info build? Would ./configure --RUSTFLAGS='-Z debug-info' work?
[01:30:04] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[01:31:34] <brson> steven_is_false: ../configure --enable-debug
[01:31:38] <aatch> steven_is_false, it should get turned on with --enable-debug
[01:31:48] <steven_is_false> And enable-debug works?
[01:32:13] <aatch> Apparently no.
[01:33:41] <steven_is_false> aatch: I thought vadimcn made a pull request that fixed some of it for platforms other than Windows?
[01:33:51] <steven_is_false> This one: https://github.com/mozilla/rust/pull/7134
[01:33:55] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:34:35] <aatch> steven_is_false, yes. I meant that the --enable-debug flags doesn't add -Z debug-info to the compiler
[01:34:53] <aatch> I mean, add it to the compiler build flags
[01:35:15] <steven_is_false> aatch: Should that be fixed for non-Windows platforms?
[01:35:26] <aatch> steven_is_false, possibly.
[01:36:00] <aatch> Otherwise running make RUSTFLAGS="-Z debug-info" will work
[01:36:11] <bblum> hmmmmm
[01:36:16] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[01:36:16] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:36:19] <brson> how do I work around this new error: /home/brian/dev/servo/src/support/geom/rust-geom/matrix.rs:74:30: 74:38 error: cannot move out of dereference of & pointer
[01:36:22] <brson> /home/brian/dev/servo/src/support/geom/rust-geom/matrix.rs:74         Matrix4(self.m11 * x, self.m12,     self.m13,     self.m14,
[01:36:32] <brson> m11 etc are generic T
[01:36:35] <steven_is_false> aatch: Okay, I'll just do it manually for now, and file an issue.
[01:36:42] <strcat> brson: replace the multiply with .mul()
[01:36:56] <strcat> well, where's the actual error from?
[01:36:58] <bblum> eric is talking to me about the closure situation 
[01:37:14] <strcat> missing the span thingy
[01:37:14] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[01:37:16] <bblum> and i'm coming to realise that the new proposed type language will not really save all that much compared to my proposal
[01:37:21] <bblum> in terms of how much a beginner's head will explode
[01:37:22] <bblum> compare:
[01:37:25] <bblum> fn spawn(task_body: ~OnceLambda:Owned<()>)
[01:37:26] <bblum> vs
[01:37:33] <bblum> fn spawn(task_body: once fn~:Owned())
[01:37:44] <brson> strcat: it's from rust-geom. not all my illegal moves have operators, some of them just want a copy of the field. maybe i just need a lot of copy keywords?
[01:37:47] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[01:37:56] <aatch> brson, yep
[01:38:11] <brson> strcat: actuall, the multiple *doesnt* try to move out
[01:38:21] <strcat> brson: ah
[01:38:25] <brson> all the fields that aren't used in a binop try to move
[01:38:37] <aatch> although changing it to be T:Clone and use .clone is better if you can get away with it.
[01:40:02] <aatch> isn't mul() (effectively, I know it's on traits) mul<T>(&T, &T) -> T?
[01:40:47] <aatch> or mul<T,U>(&T, &U) -> T
[01:40:54] <strcat> dbaupp: doing some major vector cleanup :)
[01:40:56] <enticeing> aatch: whenever 0.7 hits, would you mind updating your xcb binding for it?
[01:40:59] <strcat> the end of old_iter and each
[01:41:09] <aatch> enticeing, hmm, oh yeah. I forgot about those :/
[01:41:23] <dbaupp> strcat: awesome!
[01:41:36] <dbaupp> aatch: it's mul<T,U,V>(&T,&U) -> V
[01:41:59] <dbaupp> strcat: (I would help, but I really should be studying not rusting :'( )
[01:42:22] <aatch> dbaupp, Ok. Anyway, the important thing is that V can be moved.
[01:42:25] *** Joins: cr (anonymous@moz-C4FDC.dip0.t-ipconnect.de)
[01:42:31] <dbaupp> aatch: yeah
[01:44:35] *** Quits: cscr (Mibbit@moz-9D6D66FB.servers.jiffybox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:45:19] <aatch> Ugh, somebody reverted my change to test_inherit_env
[01:46:02] <goffrie> rusti: { fn doit<I: Iterator<&'self str>>(i: &mut I) { } doit([].iter()); }
[01:46:04] -rusti- error: internal compiler error: unexpected failure
[01:46:04] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[01:46:04] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[01:46:04] -rusti- application terminated with error code 101
[01:46:06] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[01:46:09] <goffrie> why does this fail :(
[01:46:19] <strcat> 'self
[01:46:36] *** Joins: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP)
[01:46:36] <goffrie> how should it be done?
[01:46:41] *** Quits: qmx (qmx@E752832C.183C69CE.45D46379.IP) (Quit: Textual IRC Client: www.textualapp.com)
[01:46:45] <aatch> goffrie, also, no way to find I in that context.
[01:47:04] <goffrie> huh?
[01:47:04] <aatch> Oh, actually, no nvm
[01:47:14] <strcat> goffrie: using 'self doesn't make sense because it's not coming from anywhere
[01:47:19] <strcat> <'r, foo<'r>>
[01:47:33] <aatch> I mis-read doit
[01:47:33] <strcat> but I don't know if that actually works yet
[01:47:44] <aatch> strcat, it might.
[01:48:09] <aatch> rusti: { fn doit<'r, I: Iterator<&'r str>>(i: &mut I) { } doit([].iter()); }
[01:48:10] -rusti- <anon>:9:45: 9:48 error: Illegal lifetime 'r: only 'self is allowed as part of a type declaration
[01:48:10] -rusti- <anon>:9     let r = {  { fn doit<'r, I: Iterator<&'r str>>(i: &mut I) { } doit([].iter()); } };
[01:48:10] -rusti-                                                       ^~~
[01:48:10] -rusti- error: aborting due to previous error
[01:48:10] -rusti- application terminated with error code 101
[01:48:17] <goffrie> mhmm :/
[01:48:24] <aatch> So, no, it does not.
[01:49:14] <dbaupp> rusti: 1 // test
[01:49:15] -rusti- <anon>:11:0: 11:1 error: file ended with unbalanced delimiters
[01:49:15] -rusti- <anon>:11 }
[01:49:15] -rusti-           ^
[01:49:15] -rusti- application terminated with error code 101
[01:49:25] <dbaupp> strcat: ^
[01:49:37] <strcat> ?
[01:49:48] <dbaupp> a line comment breaks rusti
[01:49:53] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[01:49:56] <strcat> oh
[01:50:21] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[01:50:44] <bblum> brson: so, eric was telling me about this awful "unsafe { *cell_ptr.put(result) }" pattern that arises when using deschedule_task_and_then()
[01:50:45] <strcat> rusti: //
[01:50:46] -rusti- ()
[01:51:12] <bblum> brson: i thought, couldn't you make deschedule_task_and_then have the fn foo<U>(cb: fn() -> U) -> U pattern?
[01:51:30] <bblum> looking at the implementation it seems like you'd need to use a bunch of unsafe casting to get the result U out
[01:51:46] <bblum> but it seems like it could save the cell pattern everywhere that it's used
[01:51:50] <dbaupp> rusti: fn doit<I: Iterator<&str>>(i: &mut I) { } doit([].iter())
[01:51:51] -rusti- <anon>:9:35: 9:39 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[01:51:51] -rusti- <anon>:9     let r = {  fn doit<I: Iterator<&str>>(i: &mut I) { } doit([].iter())
[01:51:51] -rusti-                                             ^~~~
[01:51:51] -rusti- error: aborting due to previous error
[01:51:52] -rusti- application terminated with error code 101
[01:52:09] <strcat> anyway it should allow an arbitrary lifetime
[01:53:42] <strcat> ugh why does so much stuff use vec ;p
[01:54:00] <dbaupp> iterator all the things!
[01:54:52] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[01:56:47] *** Parts: judder (maradukewa@D90735BE.FBAA5D2F.78E362FE.IP) ()
[01:57:00] <brson> bblum: in some cases that would be sufficient, if result is something cheap, but the general reason for that unsafety is because we want to take a pointer into another task's stack for efficiency
[01:57:29] <bblum> hmm
[01:57:29] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[01:57:34] <brson> bblum: so we allocate e.g. a big 'read' buffer on the stack, then do a context switch while holding onto the buffer pointer
[01:57:41] * bblum nods
[01:57:46] <strcat> Iterator gets to hit all the trait bugs, because nothing else has really used them in the stdlib...
[01:58:05] <strcat> beyond abusing them as a workaround for not being able to define impls directly on built-ins
[01:58:26] <dbaupp> strcat: yeah
[01:58:36] <dbaupp> 5898 is so much fun
[01:58:43] <goffrie> hey I got it to work using an impl instead of a top level function
[01:58:54] <strcat> goffrie: ah since you can use 'self
[01:59:00] <strcat> that makes sense but it's sad :)
[01:59:03] <strcat> silly rustc
[01:59:04] <goffrie> yep :)
[02:01:05] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[02:01:37] *** Joins: MaikKlein (maik@moz-ECF25244.dip0.t-ipconnect.de)
[02:02:25] <jedestep> are the traits in extra::serialize worth implementing in the sense that they are commonly used
[02:03:11] *** Joins: jyeo (user@moz-FEFE526F.cpe.net.cable.rogers.com)
[02:04:35] <aatch> jedestep, what traits are those?
[02:04:45] <jedestep> encoder and decoder
[02:05:02] <jedestep> I'm considering porting some similar code onto those traits for standardization
[02:05:09] <jedestep> but if they are not really in use then I won't spend the time
[02:05:34] <dbaupp> jedestep: well they allow you to serialise any datatype that implements Encodable and Decodable
[02:06:01] <dbaupp> jedestep: (and impls for these can be automatically generated with #[deriving(Encodable, Decodable)])
[02:06:22] <jedestep> ah, the benefit of deriving support sounds maybe worth it
[02:09:35] <goffrie> is there any way to have a map with string keys, that accepts string slices in find()
[02:09:43] *** Quits: kimundi (kimundi@moz-77CE41FF.dip0.t-ipconnect.de) (Ping timeout)
[02:09:49] <goffrie> (without writing custom map code)
[02:10:06] <aatch> goffrie, not at the moment, though there is find_equiv on maps
[02:10:32] <strcat> it will accept &str in find if the key is &str, otherwise .find_equiv works on HashMap
[02:10:35] <goffrie> hm for hashmaps only, okay
[02:11:25] <strcat> could have OrdEquiv... it's a mess to support it all
[02:11:27] <goffrie> is a map<&str, ..> feasible if I want to dynamically add entries to it (based on input)?
[02:11:54] <strcat> goffrie: if it's nested somewhere where it can know all the keys have the same lifetime
[02:11:54] <dbaupp> yes, if you store the input somewhere else
[02:12:12] <goffrie> hmm I see
[02:12:14] <strcat> well not necessarily *the same*
[02:12:19] <strcat> but long enough
[02:12:20] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[02:12:35] <strcat> the shortest lifetime is what matters
[02:12:36] *** Joins: kimundi (kimundi@moz-81FBC630.dip0.t-ipconnect.de)
[02:13:11] <bblum> ugh i just hate the idea of having to write a macro for every single task spawn function variant
[02:15:23] <aatch> hey, what does the lsb0 param on to_bytes() mean?
[02:15:36] <strcat> big endian vs little endian, I guess
[02:15:48] <strcat> no doubt implemented totally wrong
[02:15:52] <aatch> Ah, true.
[02:15:57] <aatch> and it's ignore for strings.
[02:16:18] <dbaupp> rusti: use std::to_bytes::*; (0x01020304u32.to_bytes(true), 0x01020304u32.to_bytes(false))
[02:16:20] -rusti- (~[4, 3, 2, 1], ~[1, 2, 3, 4])
[02:16:33] <strcat> aatch: that makes sense because strings are bytes already
[02:16:54] *** kimundi is now known as zz_kimundi
[02:17:12] <aatch> I'm just updating a project for like 3-4 months worth of changes
[02:17:17] <strcat> rusti: (1, 1).to_bytes(false)
[02:17:18] -rusti- <anon>:9:15: 10:5 error: type `(<VI0>,<VI1>)` does not implement any method in scope named `to_bytes`
[02:17:18] -rusti- <anon>:9     let r = {  (1, 1).to_bytes(false)
[02:17:19] -rusti- <anon>:10     }; // to make line comments work
[02:17:19] -rusti- error: aborting due to previous error
[02:17:19] -rusti- application terminated with error code 101
[02:17:32] <MaikKlein> rusti: use std::to_bytes::*; (0x01020304u33.to_bytes(true)
[02:17:33] -rusti- <anon>:10:4: 10:5 error: incorrect close delimiter: `}`
[02:17:33] -rusti- <anon>:10     }; // to make line comments work
[02:17:33] -rusti-               ^
[02:17:33] -rusti- application terminated with error code 101
[02:17:46] <aatch> hah
[02:17:52] <MaikKlein> rusti: use std::to_bytes::*; 0x01020304u33.to_bytes(true)
[02:17:52] -rusti- <anon>:9:48: 9:50 error: expected `;` or `}` after expression but found `33`
[02:17:52] -rusti- <anon>:9     let r = {  use std::to_bytes::*; 0x01020304u33.to_bytes(true)
[02:17:53] -rusti-                                                          ^~
[02:17:53] -rusti- application terminated with error code 101
[02:18:28] <dbaupp> aatch: that must be fun
[02:18:44] <aatch> dbaupp, fortunately most of the code is generated dynamically.
[02:18:59] <aatch> so I fix like 10000 lines by changing 5
[02:19:01] <strcat> ugh removing .each is going to suck
[02:19:05] *** Quits: jyeo (user@moz-FEFE526F.cpe.net.cable.rogers.com) (Ping timeout)
[02:20:24] <dbaupp> aatch: not so bad then :)
[02:20:27] <dbaupp> strcat: yes
[02:20:32] <aatch> Almost done
[02:20:45] <aatch> enticeing, xcb'll work with latest master in about 10 mins.
[02:20:59] <strcat> dbaupp: vec is really a mess ;[
[02:21:16] <dbaupp> strcat: yeah, I look at it every so often
[02:21:21] <dbaupp> strcat: and then run away
[02:21:28] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:21:29] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[02:21:47] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Connection reset by peer)
[02:22:17] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[02:24:17] *** Quits: jedestep (jedestep@moz-7D1551F6.natpool.nyu.edu) (Quit: jedestep)
[02:26:43] <strcat> and the good ol' rvalue bugs
[02:28:04] <strcat> this is just .find and .to_vec
[02:28:07] <strcat> [iterator 93ce5f9] vec: rm old_iter implementations
[02:28:09] <strcat>  29 files changed, 78 insertions(+), 206 deletions(-)
[02:28:15] <Luqman> strcat: i thought nmatsakis had fixed that?
[02:29:09] <strcat> Luqman: well they can be borrowed as &mut now but there are other issues
[02:29:09] *** Quits: MaikKlein (maik@moz-ECF25244.dip0.t-ipconnect.de) (Ping timeout)
[02:29:17] *** Joins: vk (chatzilla@F92596F.2DEF7520.EF7679FA.IP)
[02:29:37] <aatch> enticeing, and done. Compiles with current master, examples still work and I renamed the `ll` module to `ffi` since that's the convention for wrappers.
[02:31:57] *** Joins: brendan (brendaneic@moz-8AD662B6.sub-70-197-4.myvzw.com)
[02:35:16] <aatch> note to self, when doing a multi-host build, use -j flag
[02:36:54] <strcat> and go oom
[02:37:14] <aatch> strcat, fortunately I have 8GB of ram
[02:37:38] <strcat> yeah but it'll need ~5.2GiB for the peak
[02:37:47] * strcat has a lot of other stuff running ;p
[02:37:54] <aatch> strcat, I don't really.
[02:38:31] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:38:42] <aatch> I've got firefox at the top atm, with a couple hundred RES
[02:39:05] <aatch> couple hundred MB RES
[02:39:15] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[02:39:17] *** Joins: idkfa (idkfa@moz-141F54A4.krasinfo.ru)
[02:42:35] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[02:42:53] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[02:43:36] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[02:43:37] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[02:44:12] <strcat> opt_vec is going to be a pain too
[02:47:08] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[02:49:36] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[02:51:03] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[02:52:30] <steven_is_false> Hey I know that when the garbage collector lands it's going to eat up extra memory for a while but how fast will it be?
[02:52:43] <strcat> slow and memory hungry
[02:52:49] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[02:53:00] <steven_is_false> okay
[02:53:32] <strcat> seems to cause rustc to use at least twice as much memory right now
[02:53:35] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[02:53:45] <steven_is_false> I get why it's memory hungry but why is it slow?
[02:53:45] <strcat> because graydon is still bumping against the address space limit on 32-bit
[02:54:49] <strcat> steven_is_false: because it has to keep track of a bunch of pointers in a currently slow data structure
[02:55:06] <steven_is_false> strcat: I thought it used a hashmap?
[02:55:23] <strcat> our hashmap is slow
[02:55:28] <strcat> for integers
[02:56:04] <steven_is_false> strcat: integers being pointers in this case right?
[02:56:09] <strcat> yes
[02:56:17] *** Joins: danielrm (Mibbit@moz-19151A45.cg.shawcable.net)
[02:56:51] <steven_is_false> strcat: We can't do template specializations like in C++, so does that make us unable to special case integers, and get good performance?
[02:57:04] <strcat> that's not the issue
[02:57:12] <strcat> and we can do specializations
[02:57:20] <steven_is_false> strcat: It's just slow in general?
[02:57:33] <strcat> steven_is_false: no
[02:58:06] <strcat> it uses SipHash for a cryptographically secure guarantee of O(1) performance
[02:58:37] <steven_is_false> There should really by a symbol for amortized time complexity.
[02:58:54] <strcat> not amortized, worst-case
[02:59:17] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:59:23] <steven_is_false> strcat: So it's a perfect hash?
[02:59:25] <strcat> SipHash is much slower than the usual fragile integer hashes though
[02:59:28] <strcat> steven_is_false: no
[03:00:02] <strcat> it's a probabilistic guarantee
[03:00:07] <strcat> it's not about amortized time complexity
[03:00:17] <steven_is_false> strcat: Okay, I mispoke.
[03:01:28] <steven_is_false> strcat: So with high probability it's O(1).
[03:01:34] <strcat> yes
[03:02:00] <steven_is_false> But have we actually double checked to make sure that it's working right? Maybe a silly mistake in implementing the algorithm was made?
[03:02:13] <strcat> it's implemented correctly
[03:02:25] <steven_is_false> Okay, it's just slow like you said.
[03:02:28] <strcat> it performs the same as existing SipHash implementations
[03:02:35] <strcat> it's just not as fast as a fragile hash
[03:02:47] <steven_is_false> How do other garbage collectors handle this problem?
[03:03:08] <strcat> years of work/research put into making them somewhat acceptable
[03:03:27] <steven_is_false> Fair enough.
[03:04:01] <strcat> and I don't think they need to use a lookup table like that
[03:04:31] <strcat> they can just tag every single thing on the heap
[03:04:57] <steven_is_false> So the fact that were not using tagged values is the bottleneck?
[03:05:20] <strcat> it's just a very primitive/immature implementation
[03:05:37] <strcat> and we aren't going to tag values
[03:05:39] <steven_is_false> That's fair.
[03:06:48] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[03:06:59] <strcat> the gc for @ isn't ever going to be as good as a language without unmanaged pointers
[03:07:09] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[03:07:13] *** Quits: KindOne (KindOne@moz-DBCDCEA8.dynamic.ip.windstream.net) (Quit: You think I'm not online. But I'm always here. Even if I'm not typing. I'm here. Reading. Judging.)
[03:07:30] <steven_is_false> strcat: Do managed pointers have their own problems?
[03:07:45] <strcat> slow as hell and no static control of mutability? ;p
[03:07:59] <strcat> and no deterministic cleanup
[03:08:33] <strcat> you either have immutability like @ or a mess of dynamic failures like @mut
[03:08:52] <strcat> iterator invalidation, modifying map keys externally, etc.
[03:09:24] <steven_is_false> So why can't we just have ~, and @ values liver on their own separate heaps?
[03:09:33] <strcat> that's not the issue
[03:09:39] <strcat> the issue is that you can borrow from @ and @mut
[03:10:14] <strcat> borrowing from @ is fine semantically, it just means it can't be a moving gc (without doing a bunch of operations to track borrows)
[03:10:26] <strcat> borrowing from @mut is slow and fragile
[03:10:51] <doomlord> i saw talk of making @ selectable as gc or refcounting
[03:11:00] <doomlord> which seems like a good idea to me.
[03:11:04] <strcat> that won't work
[03:11:11] <strcat> @ allows cycles
[03:11:32] <strcat> allows/encourages cyclic data structures
[03:11:48] <steven_is_false> Is there some kind of cyclic more deterministic garbage collection?
[03:12:07] <Ralith> deterministic gc is not physically impossible
[03:12:15] <strcat> dealing with cycles means tracing
[03:12:27] <strcat> if you wanted it to be deterministic it would be incredibly slow
[03:12:32] <strcat> slower than python slow
[03:12:33] <Ralith> but gc for <novel set of requirements> is a research problem
[03:12:36] *** Quits: danielrm (Mibbit@moz-19151A45.cg.shawcable.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:12:49] <Ralith> and rust seems to be trying to avoid those
[03:12:58] <steven_is_false> Right I was reading up on articles on deterministic GC lately.
[03:13:07] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[03:13:29] <strcat> and also @ is implicitly copyable so even without cycles it's unsuited to refcounting
[03:13:39] <strcat> so Rc isn't a drop-in replacement for @
[03:13:48] <strcat> because for refcounting you want move semantics
[03:14:02] <doomlord> can you clarify that point
[03:14:24] <strcat> reference counted types need to be passed around by-value as a move to avoid ridiculous amounts of refcounting
[03:14:50] <dbaupp> doomlord: are you talking about https://gist.github.com/Kimundi/5744578?
[03:14:57] <doomlord> i thinkso
[03:15:21] <steven_is_false> Well, I'll enjoy playing with the GC implementation when it lands.
[03:15:23] <dbaupp> doomlord: that proposal is just making @ sugar for smart pointers, so @ just means 'smart pointer' and then you need @Gc or @Rc to clarify which exact one
[03:16:10] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[03:16:18] <doomlord> would there be a souce-file wide default you can set or something
[03:16:51] <strcat> doomlord: it's not going to be configurable like that
[03:16:58] <strcat> they aren't drop-in replacements for each other
[03:17:08] <doomlord> fair enough
[03:17:12] <strcat> one handles cycles, one doesn't
[03:17:19] <strcat> one copies implicitly, one moves implicitly
[03:17:26] <doomlord> i guess between ~ and GC you capture a wide extreme of uses
[03:17:36] <strcat> there is reference counting
[03:17:38] <strcat> in extra::rc
[03:17:50] <strcat> and it will gain the same borrow/deref sugar
[03:18:16] <strcat> but it's not a drop-in replacement you can toggle with a switch
[03:18:27] <doomlord> does the way task-heaps work offer optimization possibilites for the GC
[03:18:34] <strcat> well the gc is task-local
[03:18:53] <doomlord> and could whole-program analysis determine when RC is an option
[03:19:06] <strcat> they have much different performance characteristics
[03:19:11] <strcat> you don't write code the same way for them
[03:19:24] <strcat> reference counting can't deal with a high fanout persistent data structure sanely
[03:19:34] <strcat> or lots and lots of small short-lived objects
[03:19:48] <strcat> it's just not as simple as a switch you can flip
[03:20:02] <steven_is_false> Isn't a more sensible proposal escape analysis?
[03:20:08] <doomlord> ok i think i can certainly take having to write refcount explicitely when wanted. ~ is my most common case.
[03:20:09] *** Joins: KindOne (KindOne@moz-DBCDCEA8.dynamic.ip.windstream.net)
[03:20:26] <strcat> steven_is_false: escape analysis isn't very necessary
[03:20:28] *** Quits: joone (joone@moz-C50DC051.jf.intel.com) (Ping timeout)
[03:20:32] <doomlord> some detractors call ~ manual escape analysis :) but i prefer it
[03:20:40] <strcat> you can just not use @ when there isn't actually shared ownership
[03:20:53] <doomlord> i'd want to know ~ is being used. by typing it 
[03:20:56] *** Joins: joone (joone@moz-C04AAE60.fm.intel.com)
[03:21:03] <strcat> @mut is a huge pain anyway
[03:21:11] <strcat> borrows from it are really *very* fragile
[03:21:42] <steven_is_false> strcat: It'd be strange to have immutable reference counting only.
[03:21:44] <doomlord> @mut - a mutable pointer? or a pointer to a mutable object
[03:22:00] <steven_is_false> Doh! I meant immutable managed only.
[03:22:00] <dbaupp> steven_is_false: there's RcMut too
[03:22:01] <strcat> steven_is_false: we are going to have mutable shared types
[03:22:02] <doomlord> mut @T   vs @mut T
[03:22:04] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:22:06] <strcat> but they don't need sugar for dynamic borrows
[03:22:24] <dbaupp> doomlord: @mut is a pointer to a mutable object
[03:22:28] <strcat> borrowing from them is basically an anti-pattern with the way it's implemented, you're better off passing them by-value
[03:22:43] <strcat> that way you won't get dynamic freeze failures
[03:22:48] <doomlord> mut @T would be a mutable pointer?
[03:23:12] <dbaupp> doomlord: yeah, you could change which object it pointed to, but not the objects themselves
[03:23:28] <strcat> @ is immutable, @mut/RcMut doesn't inherit mutability
[03:23:34] <strcat> it's just always mutable
[03:23:36] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[03:23:55] <strcat> and if you borrow from it, freezing is handled dynamically and can fail
[03:24:02] <steven_is_false> How does mut @~mut behave?
[03:24:02] <dbaupp> strcat: @ doesn't inherit either
[03:24:16] <strcat> dbaupp: well that's not really true
[03:24:22] <dbaupp> steven_is_false: `mut @mut ~`?
[03:24:24] <dbaupp> strcat: ?
[03:24:25] <strcat> dbaupp: it doesn't inherit and it doesn't not inherit
[03:24:28] <strcat> it's just always immutable
[03:24:37] <strcat> you can make other immutable types - just don't expose any &mut self methods
[03:24:59] <doomlord> am i reading it right - GC'd pointers to *mutable objects* is problemativ
[03:25:00] <dbaupp> strcat: correct
[03:25:01] <doomlord> am i reading it right - GC'd pointers to *mutable objects* is problematic^
[03:25:08] <strcat> doomlord: yes
[03:25:09] <dbaupp> yes
[03:25:19] <strcat> doomlord: in other languages too, but especially in rust because & and &mut exist
[03:25:36] <dbaupp> doomlord: rust exposes the unsafety more obviously
[03:25:36] <strcat> for example, python forbids using mutable objects as dictionary keys
[03:25:50] <dbaupp> (in that the program crashes)
[03:25:52] <strcat> and python iterators over containers keep track of iterator invalidation dynamically
[03:26:00] <steven_is_false> strcat: Objective C's NSDictionary has the same problem.
[03:26:15] <strcat> steven_is_false: yeah, any gc'ed language with mutable objects has these problems :)
[03:26:26] <dbaupp> (what's with everything in Objective C starting with 'NS'?)
[03:26:32] <doomlord> NextSun
[03:26:34] <strcat> it's solved by keeping track of ownership
[03:26:39] <steven_is_false> dbaupp: NextStep not NextSun
[03:26:44] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: anri)
[03:26:53] <doomlord> ah someone missinformed me
[03:27:07] <strcat> as a bonus, with @mut you can't see where mutations happen
[03:27:08] <dbaupp> doomlord, steven_is_false: I see
[03:27:12] <strcat> a mutation can happen through an & parameter
[03:27:16] <strcat> or through a by-value parameter
[03:27:24] <strcat> much like any language with shared ownership + mutability
[03:27:33] <doomlord> ~mut is fine?
[03:27:34] *** Joins: jyeo (user@moz-FEFE526F.cpe.net.cable.rogers.com)
[03:27:37] <strcat> doomlord: doesn't exist
[03:27:47] <strcat> ~ is owned and inherits mutability
[03:27:50] <steven_is_false> Could we just disallow borrowing from @mut, and force people to use &const?
[03:28:06] <strcat> steven_is_false: sure, or move borrowing out of the language to the library
[03:28:09] <strcat> I've proposed that
[03:28:17] <strcat> (dynamic borrowing)
[03:28:26] <dbaupp> strcat: it's been 'accepted' hasn't it? just not implemented?
[03:28:45] <strcat> dbaupp: well pcwalton liked the idea but no one else has really commented about it
[03:28:49] <doomlord> i need to write a little example to clarify what you can and can't do i think
[03:28:57] <doomlord> and learn where the muts go..
[03:29:25] <strcat> steven_is_false: https://github.com/mozilla/rust/issues/7140
[03:29:31] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[03:29:31] <doomlord> i'm sure ~ is 90% of what i'd use coming from c++
[03:29:38] <dbaupp> doomlord: essentially you can put a mut on any "owner", which are stack variables, @ and &
[03:29:44] *** Quits: jyeo (user@moz-FEFE526F.cpe.net.cable.rogers.com) (Ping timeout)
[03:29:55] <dbaupp> i.e. let mut, @mut and &mut
[03:29:59] <strcat> doomlord: well 95% of what you use should be stack allocation and &/&mut
[03:30:11] <strcat> ~ is mostly for implementing recursive data structures
[03:30:18] <doomlord> ok you can say that
[03:30:26] <steven_is_false> Okay, if only in the possible unsafe cases one needs to use a function the proposal is really sensible.
[03:30:32] <strcat> *occasionally* you actually want to move some big object into the heap to reduce the cost of moving it around
[03:30:34] <doomlord> 905 of the 5%
[03:30:39] <doomlord> 90% of the 5%
[03:30:54] <strcat> steven_is_false: only in the cases where it can fail (currently all & and &mut borrows)
[03:31:13] <strcat> we can possibly prove many of them to be safe without failure in the future, but never all of them
[03:31:18] <doomlord> i mean the reason i use c++ is i dont want GC overhead :)
[03:31:23] <steven_is_false> strcat: Okay
[03:31:46] <steven_is_false> doomlord: GC is very awesome for total performance, just not for deterministic latency
[03:31:51] <doomlord> and i dont mind gc overhead if its an opptional extra (explicitely requested with @)
[03:32:04] <strcat> steven_is_false: compared to using ownership it's not good
[03:32:11] <doomlord> +1^ ^^^
[03:32:15] <strcat> it's only good compared to reference counting *everywhere*
[03:32:21] <doomlord> desigining to avoid GC is awesome for total performance
[03:32:35] <strcat> but that's not how refcounting is used in C++, it's used in edge cases and outside of tight loops
[03:32:40] <steven_is_false> What about heap compaction?
[03:32:48] <doomlord> hence ~ is awesome, compared to writing for a language with GC and expecting escape analysis
[03:32:50] <strcat> steven_is_false: the heap is already compact for objects under 4k
[03:33:02] <strcat> a gc can't make it more compact, jemalloc/tcmalloc are good at what they do
[03:33:10] <steven_is_false> strcat: Oh, right jemalloc is pretty awesome.
[03:33:48] <doomlord> i suppose you'll get Java people using @ everywhere by default and C++ people using ~ everywhere by default
[03:33:50] <aatch> Ok, so cross-compiling and running make check passes on my machine.
[03:34:01] <dbaupp> aatch: cross-compiling to i686?
[03:34:04] <aatch> this is frustrating.
[03:34:07] <aatch> dbaupp, yep.
[03:34:15] <strcat> steven_is_false: gc > rc for any case where the objects are small/plentiful or where they are copied frequently with short lives
[03:34:20] <steven_is_false> With a moving GC objects that refer to each other frequently can be moved very close to each other in memory.
[03:34:22] <dbaupp> aatch: that was failing on the bots, right?
[03:34:50] <strcat> steven_is_false: you can do that just by allocating them together though
[03:34:51] <steven_is_false> I got confused when talking about compaction, I meant that the objects get close together.
[03:35:06] <strcat> jemalloc puts them close together if they're allocated together
[03:35:08] <steven_is_false> strcat: Right but the GC adapts dynamically to different situations.
[03:35:12] <strcat> steven_is_false: in theory it does
[03:35:21] <strcat> in reality that's too expensive
[03:35:27] <aatch> dbaupp, yeah. the bots are still running on the first build though, and the ones that are passing passed before.
[03:35:32] <strcat> it just compacts things based on how long they've been alive
[03:35:57] <strcat> there are lots of theoretical things a JIT or GC can do but not many that are actually worth doing
[03:36:05] <steven_is_false> That's true.
[03:36:29] <strcat> since trying to figure out objects that reference themselves the most of a nice big graph problem
[03:36:33] <strcat> strongly connected components I guess
[03:36:40] * strcat forgets the time complexity of those algorithms
[03:36:56] <strcat> also I guess # of references isn't really relevant
[03:36:58] <dbaupp> aatch: ah, right... compiling LLVM :/
[03:37:06] <strcat> it's how they're being used that is - so you need runtime instrumentation counting/profiling
[03:37:10] <aatch> dbaupp, also, stuff like no-opt builds
[03:37:24] <dbaupp> aatch: each PR is going to take *ages* to land now
[03:37:47] <steven_is_false> The object graph can be represented as a matrix right?
[03:37:56] <steven_is_false> And we can take the derivative of it right?
[03:38:04] <strcat> steven_is_false: I don't think it can practically be represented as one
[03:38:08] <strcat> it'd be *huge* ;p
[03:38:22] <strcat> think about a recursive data structure with N children per layer, etc.
[03:38:33] <steven_is_false> strcat: Right but I was talking about in theory.
[03:38:33] <strcat> or just graphs
[03:38:37] <aatch> dbaupp, I think graydon was a little zealous. I have a feeling that the no-opts were only supposed to build, not test.
[03:38:45] <aatch> Or atleast only do a check-lite.
[03:39:16] <strcat> ok I can't make it through compile-fail
[03:39:19] <strcat> too many stack canary failures
[03:39:26] <dbaupp> aatch: I see
[03:39:27] <strcat> maybe RUST_MIN_STACK will help
[03:39:35] <dbaupp> also, http://buildbot.rust-lang.org/builders/auto-mac-32-nopt/builds/1/steps/compile/logs/stdio ?
[03:39:57] <strcat> heh I should do all my builds with RUST_MIN_STACK=5000000
[03:40:16] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[03:40:30] <aatch> I don't see any canary failures.
[03:40:34] <aatch> which is odd.
[03:40:35] <strcat> small segmented stacks are never actually useful on x86_64 ;\
[03:40:39] <strcat> aatch: x86_64 linux?
[03:40:44] <aatch> strcat, yep
[03:40:53] <aatch> is it only on 32bit?
[03:40:53] <strcat> aatch: you don't get them if you run make check a few times?
[03:40:57] <strcat> aatch: no, 64-bit
[03:41:01] <strcat> I haven't tested 32-bit
[03:41:04] <aatch> ok.
[03:41:07] <strcat> it doesn't happen if I use RUST_MIN_STACK=high
[03:41:15] <strcat> think it's a fast_ffi bug
[03:41:39] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[03:41:49] <strcat> aatch: happens during run-pass (rarely), compile-fail (frequently) and pretty (occasionally)
[03:41:58] <strcat> never any of the other stages.
[03:42:23] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[03:42:33] <dbaupp> strcat: can you get a backtrace or something?
[03:42:54] <strcat> well I know where it fails
[03:42:58] <strcat> it's not really useful to know that
[03:43:00] <doomlord> if you dont use any @s .. is GC completely eliminated (no tracing going on, no memory for tracing )
[03:43:02] <strcat> rustc: /home/strcat/projects/rust/src/rt/rust_stack.cpp:55: void check_stack_canary(stk_seg*): Assertion `stk->canary == canary_value && "Somebody killed the canary"' failed.
[03:43:12] <doomlord> (on a task by task basis..)
[03:43:12] <strcat> doomlord: should be
[03:43:30] <dbaupp> strcat: yeah... where in the compiler is it dying, I mean
[03:43:53] <strcat> dbaupp: well that's kind of hard unless I can make rust_stack.cpp give me a traceback
[03:44:01] <strcat> it happens compiling like 3/800 tests
[03:44:07] <strcat> or running them? not even sure.
[03:44:22] <dbaupp> strcat: does running it by hand give you the traceback?
[03:44:24] <strcat> I tried running in valgrind before and couldn't replicate it
[03:44:27] <strcat> seems like a race
[03:44:30] <dbaupp> err, kill the birdies
[03:44:41] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[03:44:44] <strcat> dbaupp: I'll try that in a sec
[03:44:55] <dbaupp> strcat: the test runner under valgrind, or the individual testcase?
[03:45:00] <strcat> dbaupp: test runner
[03:45:12] <strcat> valgrind serializes it
[03:45:16] <dbaupp> yeah
[03:45:49] <aatch> Oh. I'm running under valgrind.
[03:45:53] <aatch> I'll try without it.
[03:46:17] <aatch> dbaupp, also, it seems that we produce too much code for the linker under no-opt.
[03:46:29] <dbaupp> aatch: eurgh :(
[03:46:50] <strcat> we generate absolutely ridiculous IR
[03:46:56] <enticeing> aatch: how should i compile it? having xcb.rc deleted
[03:47:00] <aatch> at least on a 32 bit system
[03:47:05] <strcat> 100x-200x more instructions than clang ;\
[03:47:11] <aatch> enticeing, oh right, its just renamed to xcb.rs
[03:47:23] <aatch> sorry, left that out of the message by accident
[03:47:23] <strcat> the number of alloca's that it does for a swap....
[03:47:30] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[03:47:33] <enticeing> ah, thanks
[03:47:46] <dbaupp> strcat: do we know why it does so many?
[03:47:50] <aatch> enticeing, wait, looks like I accidentally deleted it
[03:47:55] <strcat> dbaupp: because trans sucks ;p
[03:48:10] <strcat> dbaupp: it also generates IR with undef behaviour, that's a more serious issue
[03:48:20] <enticeing> aatch: i was about to tell you i couldn't find it
[03:48:21] <dbaupp> strcat: yeah... i meant more specifically ;P
[03:48:32] <aatch> enticeing, sorry. I'll just dig it out of git
[03:48:39] <strcat> dbaupp: I think it's the kind of thing where if you figure out what the problem is you've fixed it ;p
[03:48:42] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:48:51] <dbaupp> strcat: haha
[03:48:57] <strcat> millions of little papercuts
[03:49:14] <aatch> The code in trans is too spread out.
[03:49:19] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:49:20] <aatch> making it impossible to follow
[03:49:36] <aatch> so you don't want to change too much because you have no idea what calls what
[03:49:41] <aatch> or relies on what behaviour
[03:49:58] <dbaupp> huh, I'm getting a pile of random failures in cfail (the compiler is generating the incorrect error message, not crashing)
[03:50:15] <steven_is_false> I'm making a bunch of little changes to follow up on my driver.rs commit, and plan on cleaning up stuff a bit.
[03:50:15] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[03:50:22] <strcat> dbaupp: try with RUST_MIN_STACK=5000000
[03:50:25] <strcat> I bet it goes away.
[03:50:40] <steven_is_false> strcat: Thanks for telling me about the GC stuff.
[03:50:51] <aatch> this is made worse by the explicit passing around of LLVM <Object>Refs, so you don't get the advantage of knowing "oh, that function modifies this thing"
[03:50:52] <dbaupp> strcat: that'd be pretty strange
[03:50:57] <dbaupp> strcat: (trying it now)
[03:51:11] <strcat> aatch: also, we use the LLVM C API
[03:51:13] <strcat> which is loosely typed
[03:51:18] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[03:51:18] <strcat> the C++ API is much better
[03:51:42] <strcat> in C++ they can use inheritance + real types, instead of weird crap like ValueRef
[03:51:49] <aatch> Also, people did things like pub type foo = @mut foo_;
[03:51:52] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[03:52:06] <strcat> aatch: HashMap used to be @mut HashMap_
[03:52:15] <strcat> and HashMap_ was implemented with chains of @mut
[03:52:16] <aatch> It's terrible.
[03:52:19] * strcat was very happy to fix that :D
[03:52:27] <dbaupp> strcat: nope, doesn't disappear
[03:52:40] <strcat> dbaupp: different bug than I'm seeing then
[03:52:43] <strcat> fun!
[03:52:46] <aatch> for one, it hides what's going on.
[03:52:51] <strcat> or at least a different manifestation of the bug
[03:53:21] <aatch> dbaupp, compile the tests manually and see what the error message is.
[03:53:30] <aatch> it could be as simple as a broken test.
[03:53:34] <dbaupp> aatch: it seems to be correct
[03:53:44] <dbaupp> aatch: looking at the file manually
[03:53:46] <strcat> dbaupp: now time to rm ExtendedIter for vec ;p
[03:53:47] *** Joins: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net)
[03:53:53] <strcat> 20000 errors, coming right up
[03:54:26] <dbaupp> aatch: yup 'error-pattern:some control paths may return a value' ... '15:40: some control paths may return a value' :/
[03:54:39] <dbaupp> err, s/ a value//
[03:54:44] <dbaupp> (for both)
[03:54:46] <SiegeLord> Anyone know how rustpkg works?
[03:55:03] <SiegeLord> I tried doing: rustpkg install github.com/brson/rust-sdl but it failed
[03:55:16] <SiegeLord> "error: main function not found
[03:56:02] * strcat doubts there are any libraries updated for the newest revision of rustpkg
[03:56:42] <SiegeLord> I find the documentation of it to be impenetrable
[03:57:04] <dbaupp> SiegeLord: it's still very in-progress
[03:57:23] <SiegeLord> Is it still meant to be done-ish for 0.7?
[03:58:38] <dbaupp> unlikely
[03:59:06] *** Quits: vk (chatzilla@F92596F.2DEF7520.EF7679FA.IP) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130612084701])
[03:59:26] <strcat> lots of stuff used eachi
[03:59:29] <strcat> heh
[03:59:48] <dbaupp> and now each eachi line is 50 characters longer
[04:00:05] <aatch> enticeing, ok, fixed now
[04:00:10] <aatch> Sorry about that.
[04:00:17] <strcat> dbaupp: because enumerate is a better word ;p
[04:00:22] <strcat> and luckily advance will go away
[04:00:41] *** Joins: brichter45 (brichter45@moz-19BCE1F8.lightspeed.cicril.sbcglobal.net)
[04:00:43] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[04:00:59] <strcat> yay libextra done
[04:01:06] <strcat> now libsyntax and then the fun part, 1000 rustc errors
[04:01:19] <strcat> impl<'self,A> old_iter::BaseIter<A> for &'self [A] {
[04:01:21] <strcat> impl<'self,A:Eq> old_iter::EqIter<A> for &'self [A] {
[04:01:28] <strcat> the two remaining old_iter impls for vec
[04:01:30] <strcat> :)
[04:01:38] <strcat> ofc BaseIter will be the most fun
[04:01:48] <dbaupp> aatch, strcat: http://ix.io/6fX is what I see for cfail
[04:02:20] <aatch> huh, says "wrong error code"
[04:02:44] <strcat> dbaupp: http://ix.io/6fY
[04:02:44] <dbaupp> oh, wait... running the commands by hand gives me a segfault o_O
[04:03:08] <strcat> dbaupp: same as me! :D
[04:03:12] <aatch> dbaupp, there you go then.
[04:03:28] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Client exited)
[04:03:36] <aatch> since the error code from a segfault is different to the one from a compiler error
[04:03:41] <aatch> I think compiler errors are 101
[04:03:41] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[04:03:54] <dbaupp> strcat: I still get one it with RUST_STACK_MIN=large
[04:04:12] <strcat> dbaupp: RUST_THREAD=1?
[04:04:41] <dbaupp> strcat: this is executing the rustc command by hand
[04:04:51] <dbaupp> it's crashing in free, apparently
[04:05:06] <strcat> rustc?
[04:05:09] <enticeing> aatch: okay, i hate to bother you again
[04:05:09] <strcat> or the binary
[04:05:17] <aatch> enticeing, no worries
[04:05:33] <enticeing> but you forgot to change all your includes/uses from `use ll;` or `ll::etc...` to ffi
[04:05:34] <dbaupp> strcat: yeah, rustc
[04:05:54] <dbaupp> strcat: in a chain of glue_drops
[04:06:24] <strcat> well our glue drop IR is invalid
[04:06:26] <strcat> not surprising
[04:06:55] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: WeeChat 0.4.1)
[04:07:16] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[04:07:26] <dbaupp> :/
[04:07:32] <aatch> enticeing, huh? I just build with the current head.
[04:07:44] <aatch> strcat, it might not be anymore
[04:08:00] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:08:09] <aatch> I think somebody fixed that, to get it to inline.
[04:08:25] *** Parts: brichter45 (brichter45@moz-19BCE1F8.lightspeed.cicril.sbcglobal.net) ()
[04:08:26] <strcat> aatch: it is, don't worry
[04:08:28] <strcat> invalid
[04:08:31] <strcat> :D
[04:08:35] <strcat> they fixed one of several problems
[04:08:44] <strcat> fn main() { let x = ~5; }
[04:08:45] *** Quits: telotortium (rmi1@moz-90BFA359.dhcp.mdsn.wi.charter.com) (Client exited)
[04:08:48] <strcat> Undefined behavior: Call return type mismatches callee return type
[04:08:51] <strcat>   %21 = call %"~struct std::sys::TypeDesc[#1]"* bitcast (i64 ({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)*, i64)* @_ZN4cast14transmute_293617_4b765accdc6169d33_00E to %"~struct std::sys::TypeDesc[#1]"* ({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)*, i8*)*)({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, i8* %20)
[04:08:53] <strcat> Undefined behavior: Call return type mismatches callee return type
[04:08:55] <strcat>   %36 = call i8* bitcast (i64 ({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)*, i64)* @_ZN4cast14transmute_293617_4b765accdc6169d33_00E to i8* ({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)*, %"~enum std::libc::types::common::c95::c_void[#1]"*)*)({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, %"~enum std::libc::types::common::c95::c_void[#1]"* %35)
[04:08:57] <strcat> Undefined behavior: Call return type mismatches callee return type
[04:08:59] <strcat>   %13 = call %"~enum std::libc::types::common::c95::c_void[#1]"* bitcast (i64 ({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)*, i64)* @_ZN4cast14transmute_293617_4b765accdc6169d33_00E to %"~enum std::libc::types::common::c95::c_void[#1]"* ({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)*, i8*)*)({ i64, %tydesc*, i8*, i8*, i8 } addrspace(1)* undef, i8* %12)
[04:09:28] * strcat is surprised anything works
[04:09:49] * dbaupp wishes someone would perform some heroics and fix everything
[04:09:58] * strcat picks dbaupp
[04:10:05] * dbaupp has exams
[04:10:34] <aatch> strcat, more evidence of trans' suckiness: https://github.com/mozilla/rust/issues/7206
[04:10:40] * dbaupp probably shouldn't even be on #rust
[04:10:42] * dbaupp leaves
[04:10:58] <strcat> \o
[04:11:21] <enticeing> also, since when does rustc respect crate_type
[04:11:37] <aatch> enticeing, um, always?
[04:11:44] <enticeing> it never seemed to work for me
[04:11:54] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[04:14:13] *** Joins: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp)
[04:15:57] <enticeing> hmmm, when was run::run_program removed?
[04:17:18] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[04:17:24] *** Quits: brendan (brendaneic@moz-8AD662B6.sub-70-197-4.myvzw.com) (Quit: brendan)
[04:17:44] <strcat> *sigh*, 250 manual fixes so far
[04:17:48] <strcat> compile -> fix thing, repeat
[04:18:12] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[04:21:21] *** Joins: brson (brson@DA348D07.AD1E507F.3688B332.IP)
[04:21:21] *** ChanServ sets mode: +o brson
[04:21:40] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[04:23:46] *** Quits: brson (brson@DA348D07.AD1E507F.3688B332.IP) (Ping timeout)
[04:23:48] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Ping timeout)
[04:23:56] *** Joins: Palmik (palmik@moz-5CA3F354.pks.muni.cz)
[04:25:02] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[04:25:25] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[04:25:55] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[04:26:22] *** Joins: brson (brson@DA348D07.AD1E507F.3688B332.IP)
[04:26:22] *** ChanServ sets mode: +o brson
[04:26:53] <bstrie> agh, why did the tree have to close just before landing the fixes for default methods? :)
[04:27:39] *** Joins: brendan (brendaneic@moz-C252503F.public.wayport.net)
[04:28:19] <strcat> and right before I'm ready to wipe out 90% of internal iterators ;p
[04:28:49] *** Quits: kemurphy (kemurphy@moz-7332FD74.hsd1.pa.comcast.net) (Ping timeout)
[04:31:11] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:32:11] <Jeaye> bstrie: Gar, that's a bummer.
[04:32:22] <Jeaye> Maybe if we ask nicely it'll get in! :P
[04:33:46] *** Joins: canin (quassel@moz-EC67E844.cpe.distributel.net)
[04:33:56] <strcat> error: aborting due to 107 previous errors
[04:33:58] <strcat> ;[
[04:34:08] <strcat> just from eachi
[04:34:43] <Jeaye> We love you for it.
[04:35:08] <canin> If I wanted to make something very "LTS" in Rust, would it be a good idea waiting for 1.0?
[04:35:25] <aatch> Knowledge check - generic functions are instantiated before getting to trans right?
[04:35:34] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[04:36:51] <strcat> stupid vectors, how I loathe thee
[04:37:12] <Luqman> aatch: as in monomorphised?
[04:37:25] <aatch> Luqman, no.
[04:38:02] <aatch> From what I can see in trans, a generic function is just ignored, with any items it has being translated.
[04:38:22] <aatch> this suggests that they are already instantiated sometime earlier.
[04:38:32] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[04:38:44] <aatch> I think monomorphisation tries to combine functions.
[04:38:58] <strcat> aatch: pretty sure type_use is what deals with that
[04:39:07] <strcat> monomorphisation is instantiating?
[04:39:42] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[04:40:09] <strcat> die eachi.
[04:40:25] <strcat> also our 20 variants of fold
[04:40:27] <aatch> I though instantiation was taking foo<T>(a:T) to foo(a:int), and monomorphization was taking foo(a:int) and foo(a:uint) and combining them if they end up being the same code.
[04:40:37] <strcat> don't think so
[04:40:53] <strcat> type_use just has really crappy heuristics to make it not specialize in some cases
[04:41:14] <strcat> it can say 1) don't specialize, 2) do specialize, 3) do specialize based on size/align
[04:41:16] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[04:41:40] <strcat> and I think it considers all destructors to be the same....
[04:42:21] <Luqman> type_use: Determines the ways in which a generic function body depends on its type parameters. Used to aggressively reuse compiled function bodies for different types.
[04:42:33] <Luqman> comment from middle/trans/type_use.rs
[04:42:57] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[04:43:52] <enix> Hey all. So, i've got a mostly ready SHA-2 implementation. Everything works fine, but, i'm not sure if I'm following Rust coding style or not. I also made changes to the sha1 code.
[04:44:21] <enix> Can anyone tell me what I do next? Do I create a pull request and then wait for a review? Is there something I should do before the? (mailing list?) Should I create a new issue to associate the pull request with?
[04:44:35] <enix> i'm new to Rust, and I'm just not sure what the standard practice is
[04:44:59] <strcat> create a pull request :)
[04:45:25] <bjz> nmatsakis: ping
[04:45:26] <strcat> after it gets reviewed you can rebase it or add commits, with the same pull
[04:45:30] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[04:45:44] <enix> ok, cool, thanks, will do
[04:46:00] <strcat> for once I get to break almost every rust program out there
[04:46:27] <aatch> Figured it out, generic functions aren't translated until later
[04:46:58] <Jeaye> aatch: Noted. :)
[04:47:31] <strcat> rust is a funny codebase
[04:47:38] <strcat> usage of the internal iterators is concentrated together
[04:47:47] <strcat> some files use position a dozen times, others use eachi 20 times
[04:48:04] <Luqman> strcat: breaking all rust programs is like a rite of passage :P
[04:48:06] <strcat> but they aren't actually widely used
[04:48:25] <aatch> Jeaye, I'm trying to document trans, see if I can find any glaring structural structural issues or obvious refactorings.
[04:48:46] <aatch> That are hidden by the terrible code
[04:51:28] *** Parts: canin (quassel@moz-EC67E844.cpe.distributel.net) (http://quassel-irc.org - Chat comfortably. Anywhere.)
[04:52:39] <strcat> and now for the test failures \o/
[04:54:12] <dbaupp> strcat: now you get to be flamed for removing methods ;D
[04:54:39] <strcat> that's the encouragement I need to remove more
[04:54:55] <aatch> "Your hate only makes me stronger!"
[04:55:03] <dbaupp> heh
[04:55:18] * aatch imagines strcat cackling maniacally
[04:56:25] <strcat> removing each itself won't be fun
[04:56:29] <strcat> will probably save that for another pullk
[04:56:33] <strcat> pull*
[04:56:53] * strcat expects conflicts
[04:56:59] <strcat> since it touches every file a few times.... pretty much
[04:57:28] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[04:57:32] <strcat> you know the worst part about this change is that sometimes I need to know the types, for .collect()
[04:57:40] <strcat> and that means reading a bunch of code to figure it out.
[04:57:50] <dbaupp> strcat: 839 .each's apparently
[04:57:56] <strcat> ;[
[04:58:03] <dbaupp> strcat: (yeah, .collect is annoying like that :/ )
[04:58:16] <strcat> librustc compiled!
[04:58:23] <strcat> now *actually* on to the tests
[04:58:26] <strcat> :p
[04:59:35] *** Quits: brendan (brendaneic@moz-C252503F.public.wayport.net) (Quit: brendan)
[05:00:24] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[05:00:27] <strcat> dbaupp: anyway, it sucks making a bunch of nearly mechanical changes
[05:00:42] <dbaupp> strcat: that is 100% correct
[05:00:44] <strcat> foldl(|&x, y| ....) -> iter.fold(|x, y| ...)
[05:00:49] <strcat> and so on.
[05:01:17] <strcat> anyway I think we should be careful about adding APIs to things ;p
[05:01:27] <strcat> because one day someone has to remove the poorly designed API :(
[05:01:32] <dbaupp> strcat: the str stuff meant I'd merged something ~60 commits in a week... I guess that's nice?
[05:01:39] <strcat> heh
[05:02:06] <strcat> I have to finish playpen too
[05:02:14] <strcat> "finish" (a neverending task!)
[05:02:24] <dbaupp> yeah... at least the iterating stuff is starting to stabilise on a *decent* api
[05:02:49] <strcat> https://github.com/thestinger/playpen/issues/16 yay
[05:03:00] <dbaupp> all the other old modules in std... on the other hand :/
[05:03:34] <strcat> dbaupp: it's not as bad as it seems because nothing uses them
[05:03:38] <strcat> vec/str are the worst
[05:03:42] <dbaupp> strcat: heh, yeah
[05:03:58] <dbaupp> but, still. someone has to sit down and clean them all up
[05:04:01] <strcat> I'm very happy about how nice Iterator is to use already
[05:04:08] <strcat> even though it's a very early *iteration* of it :)
[05:04:15] <dbaupp> hehe
[05:04:24] <aatch> Ok, there is something wrong when you have a function that takes 12 (twelve? TWELVE!) arguments.
[05:04:27] <dbaupp> all we need is that default method patch to land...
[05:04:30] <strcat> when the default method fix lands I can add a size hint
[05:04:34] <strcat> aatch: tell that to POSIX
[05:04:37] <strcat> well...
[05:04:42] <strcat> then again win32 is 10000x worse
[05:04:57] <dbaupp> aatch: the problem is there are *only* 12 arguments right? not enough flexibility!
[05:05:25] <strcat> anyway pthreads are weird
[05:05:28] <aatch> Hmm, clearly we need ~38 for a proper level of flexibility.
[05:05:36] <strcat> I find it pretty strange that stacks are "backwards"
[05:05:52] <strcat> the parent allocates N bytes for the child's stack and the child starts filling it from the end
[05:06:11] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[05:06:23] <strcat> at least the linux implementation works that way.
[05:06:37] <strcat> the clone system call optionally allows you to pass a stack
[05:06:49] <dbaupp> strcat: that has to happen, right? otherwise the calling convention changes depending on whether it's in a thread or not?
[05:06:52] <strcat> if you don't.... you can't use clone without CLONE_VM (process)
[05:07:15] <strcat> dbaupp: dunno
[05:07:21] <strcat> anyway threads == processes on linux, pretty much :)
[05:07:27] <dbaupp> aatch: definitely, that is appropriately flexible.
[05:07:43] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[05:07:43] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[05:07:49] <strcat> the only difference between a "thread" and a "process" is that the process uses CLONE_VM for a copy-on-write address space + usually won't be passed a stack
[05:07:53] <aatch> dbaupp, I mean, lets not go crazy here.
[05:07:58] <strcat> they're scheduled exactly the same way
[05:08:37] <dbaupp> strcat: that seems like an "obvious" simplification
[05:08:46] <dbaupp> i.e. it makes the kernel code much nicer
[05:09:00] <dbaupp> (i definitely wouldn't've thought of it myself though...)
[05:09:15] *** Quits: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp) (Client exited)
[05:09:30] <aatch> dbaupp, eh, don't sell yourself short. When you start implementing you tend to find the common patterns.
[05:09:45] <dbaupp> aatch: you might ;)
[05:09:55] <strcat> dbaupp: yep, it's pretty neat
[05:10:02] <strcat> and namespaces are just clone flags, much like CLONE_VM
[05:10:05] <aatch> It's the "hmm, it seems like the only difference between X and Y is A! I could probably refactor that out"
[05:10:07] <dbaupp> I can't even seem to get a patch into rust without bouncing 50 times
[05:10:13] <dbaupp> :'(
[05:10:33] <aatch> dbaupp, at the moment you cant get it in at all :P
[05:10:34] <strcat> the new github style is... distracting
[05:10:41] <dbaupp> aatch: heh
[05:10:41] <strcat> they made the language breakdown so huge
[05:10:44] <strcat> giant pink line
[05:10:47] <strcat> not helping me concentrate
[05:10:51] <dbaupp> strcat: yeah, I don't get that at all
[05:10:57] <strcat> https://github.com/thestinger/playpen
[05:10:59] <strcat> piiiink
[05:11:20] <dbaupp> it's not like the contributors need to be told what language it is
[05:11:45] <dbaupp> (and they are the people using the github project page the most, I guess.)
[05:12:08] <aatch> Hmm, I don't think we can get away with running the full test suite without optimizations.
[05:12:38] <aatch> Hang on, wait, I misread that.
[05:12:38] <strcat> we'll just have to fix trans before testing no-opt
[05:12:55] <dbaupp> enix: nice pr :)
[05:13:09] <aatch> linux-32-opt failed in test with this lovely message: "command timed out: 3600 seconds without output, attempting to kill"
[05:13:26] <strcat> aatch: pretty sure that's just buildbot sucking
[05:13:43] <strcat> happens on a lot of my pulls and I have to make bors retry
[05:13:46] <strcat> :[
[05:15:58] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:16:33] <strcat> dbaupp: https://github.com/thestinger/rust/commits/iterator so far ;p
[05:16:35] <strcat> still a lot to do!
[05:16:41] *** Joins: benw (Mibbit@E1944658.5CE6F2CA.CC99BD9.IP)
[05:16:45] <strcat> EqIter can die next
[05:17:31] <dbaupp> strcat: you're not removing the methods?
[05:17:42] <dbaupp> oh, right, last commit
[05:18:41] * strcat is just going to keep amending the last commit
[05:18:48] <enix> dbaupp: thanks!
[05:19:01] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:20:11] <benw> Hi, I'm trying to learn some basics. Can someone explain why this snippet doesn't do what I expect? See the last few lines of main: https://gist.github.com/benw/5802109
[05:20:32] *** Joins: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr)
[05:21:01] <strcat> benw: probably a bug
[05:21:07] <strcat> trait objects don't work well yet
[05:21:56] <benw> strcat: Wow, really? Ok, I hadn't seriously considered that.
[05:22:14] <dbaupp> benw: yeah, owned trait objects are particularly bad
[05:22:35] <strcat> benw: trait objects are a corner case (usually you want trait bounds) so they don't get much attention :(
[05:22:45] <strcat> but... traits as a whole are very fragile right now
[05:23:06] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[05:23:07] <benw> I just wanted to work out how to do polymorphic objects in an array
[05:23:12] <strcat> default methods are just starting to work, generic impls aren't resolved well at all, trait inheritance doesn't work, etc.
[05:23:18] <strcat> benw: well, you could use an enum
[05:23:35] <strcat> in most cases you'd probably want an enum rather than a trait object
[05:23:41] <benw> I wanted to do the equivalent of virtual methods
[05:23:54] <benw> so that the call site doesn't need to know all the possible options
[05:23:57] <strcat> well then you're stuck with broken-ish trait objects :)
[05:24:03] <strcat> @Trait mostly works though.
[05:24:14] <strcat> ~Trait, pretty much guaranteed to corrupt memory somehow ;p
[05:24:18] <benw> Good to know, thanks
[05:24:20] <strcat> &Trait is fragile too
[05:24:27] <strcat> but I don't think it's as bad as ~Trait
[05:24:51] <benw> Is this worth submitting somewhere as a possible test case?
[05:25:26] <benw> I guess I could open an issue on guthub
[05:25:33] <benw> github even
[05:25:42] <strcat> benw: yeah, an issue would be good
[05:25:46] * aatch is calling it guthub from now on
[05:25:55] <benw> Ok will do
[05:26:02] <aatch> maybe 'guthib'
[05:26:20] <benw> or 'neckbeardhub'?
[05:26:23] <aatch> "I does my works on the guthib"
[05:31:00] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[05:31:00] <strcat> dbaupp: heh and all variants of position/rposition/find/rfind on vec can go
[05:31:03] <strcat> ;p
[05:31:14] <strcat> rev_iter().find() !
[05:31:18] <strcat> yay code reuse.
[05:31:22] <dbaupp> :D
[05:31:41] <strcat> and contains/any/all
[05:31:54] * dbaupp wonders if this will make boostrapping noticably faster
[05:32:02] <strcat> doubt it
[05:32:05] <strcat> because of .advance
[05:32:05] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Client exited)
[05:32:12] <strcat> once we replace for loops..... compiles will get faster
[05:32:58] <strcat> great
[05:33:01] <dbaupp> doing the same for str seemed to possibly have a minute effect
[05:33:03] <strcat> there was a vector test in run-pass
[05:33:05] <strcat> for position
[05:33:05] * strcat sighs
[05:33:36] <dbaupp> strcat: http://huonw.github.io/isrustfastyet/#1310212
[05:33:42] <strcat> anyway a smaller API means much fewer things to test, too
[05:34:20] <strcat> dbaupp: what's the line?
[05:34:24] <strcat> vertical line
[05:34:33] <strcat> oh
[05:34:36] <strcat> the commit
[05:34:38] <dbaupp> the pr of interest
[05:35:02] <dbaupp> (the speed-up is possibly also because the str module got so much smaller in general.)
[05:36:10] *** Quits: pyrac (pyrac@moz-C46184AA.w86-198.abo.wanadoo.fr) (Quit: pyrac)
[05:37:35] *** Quits: a_make (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[05:39:02] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[05:39:25] <strcat> rusti: let xs = ~[1, 2, 3]; let ys: ~[int] = xs.rev_iter().collect(); ys
[05:39:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MJXZ
[05:39:45] <strcat> rusti: let xs = ~[1, 2, 3]; let ys: ~[int] = xs.rev_iter().transform(|&x| x).collect(); ys
[05:39:49] -rusti- ~[3, 2, 1]
[05:39:59] * strcat wants size hints
[05:40:12] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[05:40:23] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[05:40:32] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[05:41:03] <strcat> dbaupp: meh it does still happen with a huge stack
[05:41:06] <strcat> placebo
[05:41:12] <strcat> maybe it happens less frequently ;[
[05:41:55] <dbaupp> strcat: :(
[05:43:54] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[05:45:37] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[05:47:10] <Eridius> anyone feel up to reviewing my printf terminfo patch? strcat? https://github.com/mozilla/rust/pull/7161
[05:47:19] <Eridius> there's only a handful of unsafe blocks.. ;)
[05:47:20] <strcat> sure
[05:47:50] <strcat> what are the unsafe blocks needed for?
[05:47:53] <Eridius> performance
[05:48:08] <strcat> but what specifically?
[05:48:35] <Eridius> expanding a vector and filling the extra spots with '0' mostly
[05:48:40] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[05:48:59] <dbaupp> Eridius: does it make a noticeable difference?
[05:49:15] <Eridius> dbaupp: dunno, one of them avoids an extra allocation
[05:49:30] <Eridius> another could probably be replaced with vec::with_capacity + copying stuff manually + vec::grow
[05:49:37] <dbaupp> Eridius: e.g. s.unsafe_get(0) == '-' || s.unsafe_get(0) == '+' *really* should just be s[0] == '-' || s[0] == '+'
[05:49:45] <Eridius> well I guess both could do that,j ust by moving the order of grow and copy
[05:49:53] <Eridius> dbaupp: I already know for a fact the length is large enough
[05:49:58] <Eridius> why test it twice?
[05:50:14] <dbaupp> because you use unsafe code
[05:50:17] <strcat> Eridius: it will optimize that out
[05:50:21] <Eridius> this is partially because I was on a kick to remove potential fails in the code
[05:50:45] <aatch> Eridius, no premature optimization.
[05:51:08] <aatch> Rules for optimization: 1. Don't do it, 2. (Experts only) Don't do it now
[05:51:22] <dbaupp> also, the cast::transmute of the .to_upper() call can probably be changed in light of https://github.com/mozilla/rust/pull/7199
[05:51:35] <dbaupp> s/can probably/should/
[05:51:44] <strcat> Eridius: can you add the idiom you need to vec.rs?
[05:51:55] <Eridius> dbaupp: oh good, I hadn't seen that PR
[05:51:56] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[05:52:15] *** Joins: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp)
[05:52:45] <strcat> they should have a safe set_memory for [u8] and similar types
[05:52:55] <Eridius> strcat: we need a vec::copy or somesuch that copies elements from one slice into another, and an equivalent move
[05:53:14] <Eridius> strcat: there's a safe copy_memory, but I was already in unsafe code so I just used the ptr one
[05:54:14] <strcat> well, I think it would be best to add set_memory as a method to u8 vecs
[05:54:17] <strcat> and avoid unsafe here
[05:54:24] <strcat> + copy/move
[05:54:31] <strcat> or whatever it needs
[05:54:45] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[05:54:55] <Eridius> hmm what do you think of adding a MutableVector method fn<T:Copy> coy_from(&mut self, src: &[T]) -> uint, which copies elements from the src vector into the receiver, using the shorter of the two lengths, and returns the number of elements copied
[05:55:01] <Eridius> make that copy_from
[05:55:04] <Eridius> and a similar .move_from?
[05:55:19] <strcat> Eridius: with T: Clone though
[05:55:25] <strcat> but yeah
[05:55:26] <strcat> sounds good
[05:55:40] <Eridius> a .move_fromw ould also be nice, but it would have to take a ~[T], which makes it harder to grab a subset of elements
[05:55:50] <Eridius> unless we added start/length parameters
[05:56:53] <Eridius> ok so vec::bytes should have set_memory, and MutableIterator should have copy_from and move_from (with, unfortunately, differeing parameter counts, but usability trumps consistency). I'll see about doing that now
[05:56:58] <Eridius> and then I'll rework the PR to use them
[05:57:02] <strcat> :)
[05:57:12] <Eridius> so Clone is ready to be used?
[05:57:16] <strcat> Eridius: yes
[05:57:24] <strcat> Eridius: and do all 3 as methods please ;p
[05:57:40] <strcat> Eridius: Clone/DeepClone are both usable now
[05:57:45] <Eridius> strcat: vec::bytes is all functions atm
[05:57:50] <strcat> the only issue is that some types are missing impls
[05:57:59] <strcat> Eridius: that's fine, new things should still be methods
[05:58:09] <strcat> just impl it on &mut [u8]
[05:58:11] <strcat> I guess
[05:58:12] <Eridius> ok so you want me to invent a trait? MutableByteVector I suppose
[05:58:17] <strcat> Eridius: yeaah
[05:58:31] <Eridius> I assume primitives are Cloneable now, as they were Copyable before?
[05:58:39] <strcat> Eridius: yep
[05:58:47] <strcat> and there's #[deriving(Clone)] for structs/enums
[05:58:53] <Eridius> nice
[05:59:01] <strcat> also there's DeepClone to traverse through @ and Rc
[05:59:08] <strcat> at least for T: Const
[05:59:14] <dbaupp> (and #[deriving(DeepClone)])
[06:04:36] <Eridius> strcat: hmm, should set_memory take a count parameter, or require the caller to re-slice the receiver to the desired length?
[06:04:59] <strcat> Eridius: making them use a slice sounds nice
[06:05:04] <benh> What is a cleanup block/landing pad?
[06:05:16] <Eridius> I'm a fan of that, it works really well in Go, although Go doesn't have to deal with borrowck and has nice sugar for slicing
[06:05:20] <strcat> benh: the code that calls destructors when the stack unwinds
[06:05:40] <benh> Is intuitively a "cleanup: free(blah);"/"goto cleanup;" thing in C code?
[06:06:01] <strcat> benh: no, it doesn't run if no exception is thrown afaik
[06:06:42] <strcat> landing pads are just where unwinding jumps to
[06:06:49] <benh> mhm
[06:06:55] <strcat> it might reuse the same blocks as regular control flow, dunno if it does
[06:07:12] <aatch> strcat, it does
[06:07:22] <strcat> well that's good :)
[06:07:52] <Eridius> why do impl blocks for &slices all seem to require `impl<'self> Foo for &'self [T]`?
[06:08:01] <Eridius> (e.g. why is the lifetime parameter always required)
[06:08:08] <Eridius> or I suppose 'static
[06:08:11] <strcat> because all borrowed ptrs and slices need a lifetime in impls
[06:08:22] <strcat> it used to infer
[06:08:32] <strcat> maybe it will again one day, but it was very broken/confusing
[06:09:09] <Eridius> it just seems weird to require it in the for when it may not be used again anywhere else in the impl
[06:09:20] <Eridius> I mean, if I don't specify it, what other lifetime is it going to have?
[06:10:02] <strcat> Eridius: you can have multiple borrowed ptrs in an impl
[06:10:12] <strcat> (&'a T, &'b U)
[06:10:20] <strcat> there will be multiple lifetime params in the future afaik
[06:10:22] <strcat> there aren't right now
[06:10:57] <strcat> anyway I think it will infer the basic case again one day
[06:11:15] <strcat> but adding more inference before the existing language works wouldn't be great
[06:11:27] <Eridius> heh
[06:12:16] *** Joins: dpc (Mibbit@moz-86B6569C.hfc.comcastbusiness.net)
[06:12:32] <strcat> alright time for EqIter to die
[06:12:35] <strcat> dbaupp: tests passed! ;p
[06:12:51] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[06:12:54] <dpc> Can you help me debug why my code stopped working in some latest `master` ?
[06:12:58] <dpc> rust: task failed at 'borrowed at ui.rs:205', map.rs:353   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
[06:13:19] <dpc> I get this, and it makes no sense. The lines are completely unrelated and there's really no borrowing between them. :/
[06:13:42] *** Quits: enticeing (user@1983AA36.E4834407.EAAB5301.IP) (Client exited)
[06:14:16] <strcat> dpc: from @mut
[06:14:22] <aatch> dpc, on line 205 in ui.rs, there is an immutable borrow of an @mut
[06:14:27] <Eridius> hmm there seem to be no tests for vec::bytes. Although any such tests would be pretty trivial
[06:14:45] <strcat> T, ~T, @T, &T, &mut T have mutability entirely statically checked
[06:14:50] <strcat> @mut dynamically freezes on borrows
[06:15:00] <strcat> to guarantee that &mut borrows never alias &mut or & borrows
[06:15:10] <strcat> so if you borrow as &mut, you can't borrow again until it's gone
[06:15:17] <strcat> if you borrow as &, you can't borrow as &mut
[06:15:20] <aatch> this freezes it, the length of that freeze overlaps with a mutable access on line 353 in map.rs
[06:15:43] <strcat> anyway I have a bug open about removing sugar for dynamic borrows, so it can't be accidentally used.
[06:16:49] <dpc> But this code was working fine with 0.6, I haven't changed it and on ui.rs line 205 I can see no borrowing of any @.
[06:16:51] <dpc> the line is
[06:16:56] <dpc> .       .       let mut rm = map::RelativeMap::new(player.map, player.pos, player.dir);
[06:17:11] <dpc> Which calls:.       pub fn new(map: &'self mut Map, pos : Position, dir : Direction) -> RelativeMap<'self> {
[06:17:33] <aatch> dpc, "Working in 0.6" probably means "Was unsound in 0.6"
[06:18:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:18:10] <aatch> remember, if a compiler compiles code that should be broken, that makes both the compiler and the code broken.
[06:18:13] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:18:16] <dpc> Might be.
[06:18:55] <dpc> And map.rs:353 is a line on a function that is not using any @ neither. 
[06:18:59] <aatch> dpc, so there, Map is borrowed for the lifetime of RelativeMap.
[06:19:09] <dpc> Only & are there.
[06:19:09] <aatch> what type is player?
[06:19:15] <dpc> Creature
[06:19:26] <aatch> dpc, I meant, is that a @mut?
[06:19:32] <dpc> And map.rs353 is Creature's member that takes &self
[06:19:50] *** Joins: pseudoku (quassel@C87C2A0.20B1F350.C28326FD.IP)
[06:20:02] <dpc> Let me push the code.
[06:20:10] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[06:20:38] <pseudoku> what is the advantage of using @self in methods instead of &self? 
[06:20:45] <dpc> https://github.com/dpc/rustyhex/blob/master/ui.rs#L205
[06:20:58] <aatch> pseudoku, if you need to have an @-ptr to self.
[06:21:04] <Eridius> bleh, do I really have to explicitly call .mut_slice() on my [u8, ..5] or my ~[u8] in order to use methods defined on &mut [u8]?
[06:22:16] <aatch> dpc, so yeah, when you borrow a field of a @mut, you borrow the @mut itself.
[06:23:37] <dpc> aatch: Can you elaborate more, please? :)
[06:23:51] <dpc> Where exactly I am doing this, I mean.
[06:24:00] <pseudoku> aatch: ha...so is there any other reason...i was looking at the code for rustc/session and the impl for Session use @self, but i don't see the self ptr passed around...
[06:25:23] <aatch> dpc, well you have player, which is, on that line, a @mut Creature, when you do &mut player.map, you are borrowing the field in Creature, _and_ the Creature itself.
[06:25:31] <aatch> pseudoku, old, bad code.
[06:25:46] <aatch> From before &-ptrs were usable.
[06:26:00] <aatch> Remember that rustc has been building rust for several years now.
[06:26:36] <Jeaye> vec has mut_each, yeah? I don't see it anymore, but each is still there.
[06:27:17] <aatch> dpc, because you are passing it to a function that takes a &'r mut Map, and returns a RelativeMap<'r>, the borrow lasts for as long as 'r
[06:27:29] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Client exited)
[06:27:38] <Eridius> I can't run a full `make check` on my machine (because of the inability to use task::try). Is there a way to run the doc checker alone? `make tidy` isn't complaining about missing docs so I assume that's not it
[06:28:10] <aatch> Eridius, missing documentation is a lint
[06:29:00] <Eridius> aatch: I thought line length was a lint, and `make tidy` yells about that
[06:29:30] <aatch> Eridius, different kind of lint
[06:29:35] <Eridius> ok so how do I run the doc lint?
[06:29:54] <aatch> missing docs is a lint the same way unused variable is a lint
[06:30:04] <Eridius> oh so it should just warn automatically?
[06:30:18] <pseudoku> aatch, so even if i have a instance of @Session , i can invoke methods that take &self, right?
[06:30:29] <Eridius> or do I have to say -W missing_doc?
[06:30:30] <aatch> pseudoku, correct.
[06:30:34] <aatch> Eridius, it should.
[06:30:46] <aatch> In fact, I think it will actually fail to compile
[06:30:48] <Eridius> well I'm building std manually at the moment, to run tests
[06:30:48] <dpc> aatch: So I cannot mutate player as long as relative map is around?
[06:31:01] <aatch> dpc, correct.
[06:31:10] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:31:23] <aatch> Eridius, I think it's turned off by default
[06:31:41] <Eridius> hrm I threw in -D missing_doc but it's not complaining that I have no docs on the method in my trait
[06:31:45] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90 [Firefox 22.0/20130612084701])
[06:32:04] <dpc> aatch: But map.rs:353 has nothing to do with any mutating...
[06:32:09] <strcat> pseudoku: if you use &self and it's allocated as @self you need a dynamic borrow
[06:32:42] <Eridius> oh hmm -W all says it's missing-doc, but the cfg directive I've seen in code is allow(missing_doc)
[06:32:49] <pseudoku> aatch: i'm willing to do the clean up...if its ok with you guys...
[06:33:00] <dpc> aatch: I cannot *use* the borrowed player, or I can not even access it?
[06:33:05] <Eridius> err I guess that's an attribute, not a cfg directive
[06:33:16] <dpc> I mean, modify or access?
[06:33:19] <Eridius> well no, -D missing-doc didn't work either. hmm
[06:33:59] *** Quits: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP) (Quit: z0w0)
[06:34:01] <aatch> dpc, correct, more accurately, you can't borrow it twice
[06:34:05] <pseudoku> strcat: to increment the reference count?
[06:34:13] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:34:19] <strcat> pseudoku: no
[06:34:40] <strcat> pseudoku: unlike other types, borrows from @mut are checked dynamically
[06:35:00] <aatch> basically, it's the dynamic equivalent to the error you get when you try to do `let mut a = "foo"; let b = &mut a; let c = &a;`
[06:35:14] <aatch> rusti: let mut a = "foo"; let b = &mut a; let c = &a;
[06:35:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZiYA
[06:35:37] <dpc> aatch: Would "copy player.map" help?
[06:36:38] <strcat> pseudoku: https://github.com/mozilla/rust/issues/7140
[06:36:39] <Eridius> rusti: let mut a = @"foo"; let b = &mut a; let c = &a;
[06:36:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QRQZ
[06:36:58] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Ping timeout)
[06:37:08] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[06:37:47] <aatch> dpc, maybe, but it would be better to try and re-structure the code so you don't need to re-borrow the player
[06:38:25] <strcat> if you really want to use @mut, you should try to pass it by-value whenever you can to avoid failures
[06:38:42] <brson> " error: unresolved name `f_cell`. Did you mean `m\
[06:38:44] <brson> ain_cell`?"
[06:38:49] <strcat> heh
[06:38:52] <brson> first time it's even been correct
[06:39:03] <brson> it was amazing
[06:41:02] *** Quits: pseudoku (quassel@C87C2A0.20B1F350.C28326FD.IP) (Ping timeout)
[06:41:07] <Eridius> damn, I need to add a new MutableCopyableVector. Yay for proliferation of traits
[06:41:43] <strcat> Eridius: we should really make it so those types count as being implemented in libstd
[06:41:52] <strcat> so we can just make impls and no traits...
[06:41:55] <strcat> it's really annoying
[06:41:57] <Eridius> that would be cure
[06:41:59] <Eridius> *cute
[06:42:04] <strcat> 99% of the current traits are workarounds for this :|
[06:43:03] *** Joins: pseudoku (quassel@A3020883.504D9FE1.520CDC98.IP)
[06:43:36] *** Quits: benw (Mibbit@E1944658.5CE6F2CA.CC99BD9.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:44:03] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[06:44:21] <dpc> aatch: OK, I understand now and I fixed it. Thank you. :)
[06:44:56] <pseudoku> strcat: is there any code that demonstrates such dynamic failure?
[06:45:14] <strcat> pseudoku: just try breaking the borrow check rules
[06:45:29] <strcat> borrow &mut to @mut and then borrow something else with the &mut still around
[06:45:37] <strcat> or borrow & and then &mut
[06:45:50] <dpc> pseudoku: I'm just fixing such code. :D
[06:46:35] <strcat> everything else handles that statically, just not mutable shared ownership types
[06:46:58] <strcat> it can still exist, I just don't think it should be sugar - far too easy to use without realizing it
[06:47:06] <strcat> and far too fragile when you do use it
[06:49:48] <pseudoku> dpc: can i get a link? strcat, sorry i'm not following you, i am afraid i don't have enough knowledge of the borrowck rules
[06:50:32] <strcat> rusti: let x = @mut 5; let mutable = &mut *x; let conflict = &*x;
[06:50:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KVGV
[06:50:57] <dpc> pseudoku: https://github.com/dpc/rustyhex/blob/master/ui.rs#L205
[06:50:59] <strcat> rusti: let x = @mut 5; let y = x.clone(); let mutable = &mut *x; let conflict = &*y;
[06:51:02] -rusti- rust: task failed at 'borrowed', <anon>:9
[06:51:02] -rusti- rust: domain main @0x7f65aac1f810 root task failed
[06:51:02] -rusti- application terminated with error code 101
[06:51:11] <dpc> pseudoku: Though it's not a simplest case, I guess.
[06:51:27] <dpc> The latest commit is fixing the issue.
[06:51:27] <strcat> rusti: let x = @mut 5; let y = x.clone(); let immutable = &*x; let conflict = &mut *y;
[06:51:28] -rusti- rust: task failed at 'borrowed', <anon>:9
[06:51:28] -rusti- rust: domain main @0x7f55c101f810 root task failed
[06:51:29] -rusti- application terminated with error code 101
[06:51:32] <strcat> there are two examples
[06:51:33] *** Quits: pseudoku (quassel@A3020883.504D9FE1.520CDC98.IP) (Ping timeout)
[06:51:41] <strcat> you can't borrow something as both &mut and &
[06:51:43] <dbaupp> Jeaye: if you're still looking .mut_iter()
[06:51:50] <strcat> rusti: let x = @mut 5; let y = x.clone(); let immutable = &*x; let fine = &*y;
[06:51:51] -rusti- ()
[06:51:52] <strcat> that's fine
[06:51:57] <strcat> rusti: let x = @mut 5; let y = x.clone(); let immutable = &mut *x; let fine = &mut *y;
[06:51:58] -rusti- rust: task failed at 'borrowed', <anon>:9
[06:51:59] -rusti- rust: domain main @0x7f7b6ec1f810 root task failed
[06:51:59] -rusti- application terminated with error code 101
[06:52:01] <dbaupp> Jeaye: (is the replacement for .mut_each)
[06:52:01] <strcat> and &mut borrows have to be unique
[06:52:05] <strcat> anyway
[06:52:12] <strcat> for *everything* but @mut, this is enforced statically
[06:52:17] <strcat> by the compiler
[06:52:19] <strcat> you can't get it wrong
[06:52:24] <Jeaye> dbaupp: I ended up using i32::range :P
[06:52:36] * Jeaye changes it to iterators.
[06:52:49] <strcat> oh he timed out anyway
[06:53:04] <strcat> luckily I'll be removing int::range and uint::range soon
[06:53:05] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[06:53:06] <strcat> yay
[06:54:04] <dbaupp> strcat: replaced with?
[06:54:19] <strcat> an external iterator range object
[06:54:46] <dbaupp> do we have the infrastructure for a generic one?
[06:55:00] <strcat> well it can be implemented like range
[06:55:03] <strcat> with the same edge cases
[06:55:06] <strcat> for now
[06:56:31] *** zz_kimundi is now known as kimundi
[07:01:02] <strcat> dbaupp: doing EqIter now :)
[07:01:12] <strcat> then I'll zap find/rfind/rposition
[07:01:51] <strcat> we really need an Iterable trait soon + default methods
[07:01:59] <strcat> so stuff doesn't become so much uglier
[07:03:50] <Eridius> strcat: https://github.com/mozilla/rust/pull/7210
[07:04:42] *** Joins: sankha93 (Instantbir@9C09B5F2.75FB07DC.8B6C1D65.IP)
[07:04:49] <Eridius> ...well crud. I ran `rustc` manually and all built, but for some reason `make` just b0rked
[07:05:00] <Eridius> how is that possible?
[07:05:01] *** Joins: pseudoku (quassel@268856DF.6753A649.C28326FD.IP)
[07:05:21] <Eridius> ..does ptr::set_memory not exist at stage0 or something?
[07:05:29] <strcat> yeah not in stage0
[07:05:33] <strcat> we need a snapshot ;p
[07:05:41] <Eridius> crap. What do I do to make this build?
[07:05:54] *** Quits: pseudoku (quassel@268856DF.6753A649.C28326FD.IP) (Connection reset by peer)
[07:05:59] <dbaupp> Eridius: just put #[cfg(not(stage0))] around everything new
[07:06:09] <strcat> well the stuff that needs set_memory
[07:06:20] <Eridius> I assume not the tests though, right?
[07:06:27] <strcat> Eridius: do it for the tests too
[07:06:31] <Eridius> those build in stage0?
[07:06:34] <strcat> they can
[07:07:04] <Eridius> do I use separate directives, e.g. #[test]\n#[cfg(not(stage0))] or do they combine into one?
[07:07:19] <Eridius> s/directives/attributes
[07:07:24] <dbaupp> Eridius: the tests don't build in stage0
[07:07:44] <dbaupp> (but yes, putting multiple attributes would work.)
[07:07:51] <strcat> by default ;p
[07:08:31] <Eridius> ok I updated the PR
[07:08:44] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[07:09:01] <strcat> sadly bors is off
[07:09:14] <Eridius> strcat: ty
[07:09:21] <Eridius> more maintenance? bah
[07:09:40] *** Quits: dpc (Mibbit@moz-86B6569C.hfc.comcastbusiness.net) (Quit: http://www.mibbit.com ajax IRC Client)
[07:09:56] <dbaupp> Eridius: "maintenance" = everything's broken!
[07:10:14] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[07:10:16] <Eridius> what broke this time?
[07:10:24] *** Joins: pseudoku (quassel@412362AA.2A26FCB3.C28326FD.IP)
[07:10:26] <strcat> a dozen things
[07:10:38] <strcat> stack canaries killed randomly
[07:10:42] <Eridius> :/
[07:10:44] <strcat> other issues on 32-bit
[07:11:20] <strcat> ugh this is going to make some things temporarily very painful
[07:11:32] <strcat> the Equiv trait needs a default impl for Eq types
[07:11:39] <strcat> so I can use Equiv instead of Eq for contains
[07:11:44] <strcat> and add <&T, T>
[07:11:57] <dbaupp> strcat: we need some sort of specialisation for that
[07:12:05] <strcat> dbaupp: no
[07:12:10] <strcat> dbaupp: it just needs to not consider
[07:12:17] <strcat> hm
[07:12:20] <strcat> actually I could do it now
[07:12:22] <strcat> nvm
[07:12:28] <dbaupp> Equiv<A> for A won't work
[07:12:34] *** Quits: pseudoku (quassel@412362AA.2A26FCB3.C28326FD.IP) (Ping timeout)
[07:12:36] <strcat> I want
[07:12:53] <strcat> impl<A: Eq> Equiv<A, A> for A {}
[07:13:04] <strcat> err
[07:13:08] <strcat> impl<A: Eq> Equiv<A> for A {}
[07:13:12] <strcat> dbaupp: that won't work? :\
[07:13:52] <dbaupp> strcat: yeah... but then nothing else can impl Equiv
[07:14:05] <strcat> oh right
[07:14:10] <strcat> I forgot generic impls were totally broken
[07:14:13] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[07:14:18] <dbaupp> rusti: trait Foo<A> {} impl<A: Eq> Foo<A> for A {} impl Foo<uint> for uint {}
[07:14:19] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AeFV
[07:14:33] <strcat> we're not going to be able to stabilize library APIs for a *long* time ;\
[07:15:05] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[07:15:10] *** Joins: nano (nano@moz-972880B.superkabel.de)
[07:15:13] <strcat> definitely not Iterator and most of the containers at least
[07:15:57] <dbaupp> it's good that way.. we get to break programs for months to come ;P
[07:16:46] <strcat> yeah but I hate doing these things in baby steps that make a lot of code uglier in the meantime
[07:17:57] *** Joins: pseudoku (quassel@B6EFE24.5B86C286.C28326FD.IP)
[07:18:03] <strcat> [iterator 79335d6] vec: rm old_iter implementations
[07:18:05] <strcat>  86 files changed, 313 insertions(+), 467 deletions(-)
[07:18:07] <strcat> yay
[07:18:09] <strcat> every but 'each'
[07:18:11] <strcat> almost done
[07:18:25] *** Parts: pseudoku (quassel@B6EFE24.5B86C286.C28326FD.IP) (http://quassel-irc.org - Chat comfortably. Anywhere.)
[07:18:29] *** Joins: pseudoku (quassel@B6EFE24.5B86C286.C28326FD.IP)
[07:19:38] <pseudoku> strcat, dpc: thanks a lot. my internet is acting up today...anyway strcat, so 'let x = @mut 5; let y = x.clone(); let immutable = &mut *x; let fine = &mut *y;' should also result in dynamic failure right?
[07:19:54] <strcat> pseudoku: yes
[07:20:01] <strcat> pseudoku: &mut has to be unique
[07:20:05] <Eridius> rusti: let x = @mut 5; let y = x.clone(); let immutable = &mut *x; let fine = &mut *y;
[07:20:07] -rusti- rust: task failed at 'borrowed', <anon>:9
[07:20:07] -rusti- rust: domain main @0x7fe297c1f810 root task failed
[07:20:07] -rusti- application terminated with error code 101
[07:20:09] <strcat> can't alias &mut or &
[07:21:07] *** Quits: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp) (Ping timeout)
[07:22:18] *** Quits: pseudoku (quassel@B6EFE24.5B86C286.C28326FD.IP) (Connection reset by peer)
[07:23:50] *** Quits: nattofriends (tsutsumi@moz-4CEEC7AA.warosu.org) (Client exited)
[07:24:21] <dbaupp> strcat: nice... so it's just BaseIter left?
[07:24:28] <strcat> yep
[07:24:29] <Jeaye> making my lt impl return gt seems to kill quick_sort3 (seems to be going infinitely) o.O
[07:24:33] <strcat> and some functions/methods I have to kill
[07:26:12] <strcat> dbaupp: https://github.com/thestinger/rust/commit/81174e7625f7c02ee9af79c8b2e0e03a3896057b still haven't made it pass tests
[07:26:13] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZzzz)
[07:26:15] <strcat> just finished librustc
[07:27:25] *** Joins: pseudoku (quassel@1E0E5142.AE78DE90.520CDC98.IP)
[07:29:42] *** Quits: pseudoku (quassel@1E0E5142.AE78DE90.520CDC98.IP) (Ping timeout)
[07:29:53] <strcat> -                        if !queue.contains(parent) {
[07:29:55] <strcat> +                        if !queue.iter().contains_(&parent) {
[07:29:57] <strcat> that's just great
[07:30:00] <strcat> somehow this counts as a conflicting borrow now
[07:30:15] <dbaupp> huh?
[07:30:34] <strcat> it's too stupid to realize it will be gone
[07:30:35] <strcat> during the block
[07:30:46] <strcat> I guess I should report this
[07:30:58] <dbaupp> oh, it conflicts with the contents of the if?
[07:31:04] <strcat> yep
[07:31:14] <dbaupp> does using a temp fix it?
[07:31:40] <strcat> I think it will, but sec
[07:32:02] <strcat> wtf.
[07:32:30] <strcat> I can't make it happen
[07:32:44] <strcat> outside of this example ;[
[07:33:41] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[07:33:48] <dbaupp> where is it?
[07:33:59] <strcat>     pub fn sub_free_region(&self, sub: FreeRegion, sup: FreeRegion) -> bool {
[07:34:06] <strcat> librustc/middle/region.rs
[07:34:47] <strcat> I can't get it to happen in a standalone example
[07:35:50] *** Joins: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp)
[07:36:19] *** kimundi is now known as zz_kimundi
[07:36:34] <dbaupp> does it conflict with the &queue[i]?
[07:36:50] <strcat> no
[07:37:21] <strcat> dbaupp: https://github.com/mozilla/rust/issues/7211
[07:37:55] <Eridius> strcat, dbaupp: https://github.com/mozilla/rust/pull/7161 (terminfo printf) has been updated to not use unsafe blocks
[07:38:38] <Eridius> ironically, removing unsafe from my printf stuff doesn't use any of the new methods.. since I'm actually operating on uninitialized memory and the new methods operate on initialized memory
[07:38:42] <Eridius> instead I'm using .push_all_move instead of .move_from, and just straight-up .grow instead of .set_memory
[07:39:14] <strcat> hm, is move_from still useful?
[07:39:18] <strcat> or does push_all_move already do that
[07:39:33] <Eridius> strcat: .move_from overwrites the source. push_all_move grows it
[07:39:40] <strcat> ah, right.
[07:40:52] <strcat> wtf
[07:40:56] <strcat> /home/strcat/projects/rust/src/librustc/middle/region.rs:208:28: 208:33 error: cannot borrow `queue` as mutable because it is also borrowed as immutable
[07:40:59] <strcat> /home/strcat/projects/rust/src/librustc/middle/region.rs:208                             queue.push(*parent);
[07:41:01] <strcat>                                                                                          ^~~~~
[07:41:03] <strcat> /home/strcat/projects/rust/src/librustc/middle/region.rs:206:33: 206:38 note: second borrow of `queue` occurs here
[07:41:05] <strcat> /home/strcat/projects/rust/src/librustc/middle/region.rs:206                         let r = !queue.iter().contains_(&parent);
[07:41:07] <strcat> ;\
[07:41:13] *** Quits: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp) (Ping timeout)
[07:41:17] <dbaupp> gah!
[07:41:54] <dbaupp> is it .contains_ or .iter() that's the problem?
[07:42:22] *** Joins: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp)
[07:42:52] <strcat> doesn't make that clear
[07:43:01] <strcat> it underlines queue
[07:43:21] <dbaupp> I mean, if you convert .contains_ to a manual .fold (or .advance) does it fix it
[07:45:13] <strcat> meh
[07:45:16] <strcat> screw this contains method
[07:45:23] *** Quits: blitter (blitter@moz-FB45689C.dyn.centurytel.net) (Ping timeout)
[07:45:31] * strcat removes it
[07:45:37] *** Joins: jim (Mibbit@moz-6029075.tpgi.com.au)
[07:46:39] *** Joins: pseudoku (quassel@168044A7.A588E5E2.520CDC98.IP)
[07:48:05] <jim> I'm following along with the tutorial using the rust 0.6 compiler, but skipping iterations in while loops seems to not work. The tutorial claims using 'loop' inside a while loop will skip to the next iteration, but it seems to go into an infinite loop instead. This makes sense, but how do you skip to the next iteration of the while loop?
[07:48:21] <strcat> loop;
[07:48:27] <jim> I've tried next, cont, continue, skip, pass, etc. but nothing works.
[07:48:46] <strcat> can you give an example of one using 'loop'?
[07:48:49] <strcat> that loops forever
[07:48:51] <jim> loop sticks it in an infinite loop. Maybe it's a bug in the rust 0.6 release.
[07:49:31] <jim> I'm using a while loop, just counting down from 5 to 0. I'm simply outputting the count with a println.
[07:49:43] <strcat> what's the specific code though?
[07:49:47] <jim> I want to skip '2', but can't see a way to.
[07:50:04] <dbaupp> rusti: let mut i = 5; while i >= 0 { if i == 2 { loop; } println(i.to_str()); }
[07:50:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bjXM
[07:50:21] <dbaupp> rusti: let mut i = 5i; while i >= 0 { if i == 2 { loop; } println(i.to_str()); i -= 1 }
[07:50:27] -rusti- 5
[07:50:27] -rusti- 4
[07:50:27] -rusti- 3
[07:50:27] -rusti- timeout triggered!
[07:50:47] <dbaupp> rusti: let mut i = 5i; while i >= 0 { if i == 2 { i -= 1; loop; } println(i.to_str()); i -= 1 }
[07:50:48] <strcat> well that happens because it's 2 on the next iteration too
[07:50:49] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RddW
[07:51:14] <dbaupp> jim: did you forget to decrement before `loop`ing?
[07:51:19] *** Quits: pseudoku (quassel@168044A7.A588E5E2.520CDC98.IP) (Connection reset by peer)
[07:52:07] <jim> dbaupp: Ah, of course, Yes. My mistake. Ta.
[07:52:35] <strcat> ugh this is a pain to remove
[07:52:45] <strcat> those 50 places I updated need to be redone
[07:52:47] <strcat> yay
[07:53:37] <dbaupp> strcat: `sed -i s/\.contains_(/.fold(|a, b| a || b == /` ?
[07:53:42] *** Quits: brson (brson@DA348D07.AD1E507F.3688B332.IP) (Quit: leaving)
[07:53:49] <strcat> dbaupp: using .any
[07:53:50] *** Parts: jim (Mibbit@moz-6029075.tpgi.com.au) ()
[07:53:58] <strcat> .contains(& &5) -> .any(|x| x == &5)
[07:54:02] <strcat> but anyway
[07:54:09] <dbaupp> strcat: ah, right. even easier to sed ;)
[07:54:12] <strcat> dbaupp: true.
[07:54:45] <strcat> dbaupp: it's even conveniently .contains_
[07:55:02] <dbaupp> yeah, perfectly planned! ;P
[07:57:04] *** Joins: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP)
[07:57:08] *** Joins: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk)
[07:58:42] *** Quits: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp) (Client exited)
[07:59:03] *** Joins: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp)
[07:59:11] <strcat> yay I think I did it right
[07:59:32] <strcat> git ls-files | xargs sed -i 's/\.contains_(& /\.any(|x| x == /'
[07:59:37] <strcat> nooo
[07:59:39] <strcat> any_
[07:59:44] <strcat> git reset to the rescue
[07:59:57] * strcat tries make
[08:00:49] *** Quits: ysuzuki (ysuzuki@moz-3830D141.st.keio.ac.jp) (Ping timeout)
[08:06:27] <strcat> dbaupp: if we really wanted we could implement almost all of them with skip_while ;p
[08:06:50] <strcat> but it'd be slower to compile
[08:08:52] *** Joins: pseudoku (quassel@8866FEB2.CBE465C1.C28326FD.IP)
[08:10:00] *** aatch is now known as aatch|gone
[08:11:04] *** Quits: pseudoku (quassel@8866FEB2.CBE465C1.C28326FD.IP) (Ping timeout)
[08:11:24] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[08:14:44] *** Joins: pseudoku (quassel@5ABC21F3.269A2B47.520CDC98.IP)
[08:16:13] *** Joins: berak (chatzilla@6B7FC2A3.6062171A.1A5CC7E5.IP)
[08:17:32] *** Quits: pseudoku (quassel@5ABC21F3.269A2B47.520CDC98.IP) (Ping timeout)
[08:20:09] *** Parts: berak (chatzilla@6B7FC2A3.6062171A.1A5CC7E5.IP) ()
[08:21:22] *** Joins: Blei (philipp@moz-7077963E.ethz.ch)
[08:23:57] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[08:24:04] *** Joins: fabiand (fabiand@B363761C.DC24CC58.16E13E53.IP)
[08:29:30] *** Joins: pseudoku (quassel@C02E9D6C.88326D41.520CDC98.IP)
[08:34:45] *** Quits: pseudoku (quassel@C02E9D6C.88326D41.520CDC98.IP) (Ping timeout)
[08:36:43] *** Joins: pseudoku (quassel@D4834D96.AB6E7807.C28326FD.IP)
[08:39:55] *** Quits: pseudoku (quassel@D4834D96.AB6E7807.C28326FD.IP) (Ping timeout)
[08:42:32] *** Joins: pseudoku (quassel@B7144B72.6785D218.520CDC98.IP)
[08:43:32] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:43:51] *** Joins: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[08:47:31] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[08:50:15] <doener> hm, I wish rust's commit history was a bit more like that of git or linux
[08:50:36] <strcat> doener: better commit messages?
[08:50:49] <strcat> and fewer intermediate broken ones
[08:51:21] <doener> that, and more squashing of bugfixes within a single PR.
[08:51:41] <strcat> github encourages small, iterative pull requests
[08:52:07] <doener> introducing a bug/problem and fixing it in the same PR just creates noise
[08:52:19] <doener> strcat: I didn't mean to stuff more commits into a single PR
[08:53:28] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[08:53:31] <doener> strcat: there's was a PR lately that introduced trailing whitespace in one commit, and then removed it in another. The second one could have been squashed into the first one. Much less noise.
[08:53:47] <strcat> yeah I like rebasing mine a lot
[08:54:34] <strcat> only reason they'll ever be multiple commits is to logically break them up into independent chunks
[08:54:39] <strcat> that compile by themselves
[08:54:51] <strcat> but anyway, we don't really have any standards about that
[08:54:54] <strcat> or commit messages
[08:55:12] *** Quits: pseudoku (quassel@B7144B72.6785D218.520CDC98.IP) (Ping timeout)
[08:55:20] <doener> I think brson mentioned that maybe there should be some
[08:56:10] <Blei> i agree. imo each commit should be able to stand on its own
[08:56:34] <Blei> makes bisecting much easier as well
[08:57:15] *** Joins: pseudoku (quassel@1301254A.7BF686B4.C28326FD.IP)
[08:57:43] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:59:30] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[09:00:35] *** Quits: pseudoku (quassel@1301254A.7BF686B4.C28326FD.IP) (Ping timeout)
[09:03:02] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[09:04:09] *** Joins: pseudoku (quassel@17EF0F49.4BA3D6CC.520CDC98.IP)
[09:04:55] *** Quits: cr (anonymous@moz-C4FDC.dip0.t-ipconnect.de) (Ping timeout)
[09:06:41] *** Joins: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP)
[09:07:04] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:08:39] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[09:10:28] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[09:12:55] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[09:13:55] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[09:17:27] *** Joins: vmx (vmx@moz-49FC0C93.dip0.t-ipconnect.de)
[09:19:51] *** Quits: pseudoku (quassel@17EF0F49.4BA3D6CC.520CDC98.IP) (Ping timeout)
[09:21:52] *** Joins: pseudoku (quassel@87FE3781.D65816C7.520CDC98.IP)
[09:23:07] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[09:23:39] *** Quits: pseudoku (quassel@87FE3781.D65816C7.520CDC98.IP) (Ping timeout)
[09:24:36] <engla> is it possible to have bisect run linearly along the master branch, i.e bisecting merges rather than commits?
[09:26:11] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[09:26:22] *** Quits: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net) (Ping timeout)
[09:26:43] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[09:26:52] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[09:27:07] *** Joins: rbancroft (rumble@moz-4E8E0D7F.cg.shawcable.net)
[09:27:15] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[09:27:17] *** Joins: pseudoku (quassel@FD285757.BB211C3B.520CDC98.IP)
[09:29:11] *** Quits: pseudoku (quassel@FD285757.BB211C3B.520CDC98.IP) (Ping timeout)
[09:29:53] <dbaupp> engla: it doesn't look easy but it's approximately possible http://stackoverflow.com/questions/5638211/how-do-you-get-git-bisect-to-ignore-merged-branches
[09:30:45] *** Quits: SimonSapin (simon@moz-73287A57.zone9.bethere.co.uk) (Ping timeout)
[09:32:11] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[09:33:34] *** Joins: k00mi (koomi@moz-543186DC.pools.arcor-ip.net)
[09:41:49] <doener> engla: git rev-list --first-parent --merges --parents HEAD | cut -d' ' -f1,2 > .git/info/grafts
[09:42:16] <doener> engla: that makes git ignore the secondary parents of all merge commits along the first parent ancestry
[09:42:32] <doener> engla: just drop the grafts file when you're done with the bisection
[09:43:21] *** Joins: pseudoku (quassel@41EB990C.86BDF78C.520CDC98.IP)
[09:45:36] *** Quits: pseudoku (quassel@41EB990C.86BDF78C.520CDC98.IP) (Ping timeout)
[09:49:38] <engla> wow nice hack
[09:52:26] *** Quits: sankha93 (Instantbir@9C09B5F2.75FB07DC.8B6C1D65.IP) (Ping timeout)
[09:56:00] *** Joins: pseudoku (quassel@8106AC67.D9D38C1F.520CDC98.IP)
[09:56:18] *** Joins: sankha93 (Instantbir@DB7B6454.EEA5FE15.8B6C1D65.IP)
[09:57:21] *** Quits: pseudoku (quassel@8106AC67.D9D38C1F.520CDC98.IP) (Connection reset by peer)
[09:59:38] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[10:00:13] *** Joins: pseudoku (quassel@F95E16F4.96D08489.C28326FD.IP)
[10:01:37] <nmatsakis> bjz: pong
[10:01:44] *** Joins: MaikKlein (maik@moz-ECF25244.dip0.t-ipconnect.de)
[10:01:59] *** Quits: pseudoku (quassel@F95E16F4.96D08489.C28326FD.IP) (Ping timeout)
[10:04:47] *** Quits: idkfa (idkfa@moz-141F54A4.krasinfo.ru) (Quit: Cracked by Bill Gilbert)
[10:04:57] *** Joins: rubber-duck (rubber-duc@moz-DAF7A616.dsl.iskon.hr)
[10:05:34] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[10:06:22] *** Joins: heftig_ (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[10:06:51] <bjz> nmatsakis: how goes that difficult abi patch?
[10:07:02] <bjz> any news?
[10:07:19] <rubber-duck> is the compiler written in some old version of rust ? isn't this supposed to be "enum" https://github.com/nikomatsakis/rust/blob/master/src/comp/middle/ty.rs#L252 ?
[10:07:28] <nmatsakis> bjz: sorry, I haven't looked at it at all :(
[10:07:33] *** Quits: heftig (heftig@moz-22E2F36E.dip0.t-ipconnect.de) (Ping timeout)
[10:07:35] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[10:07:37] <nmatsakis> bjz: I really need to, it's just bitrotting away while aatch|gone rewrites trans from scratch
[10:07:49] <bjz> ahh ok
[10:08:13] <bjz> I guess it would make more sense to wait until after he's done
[10:08:45] <Blei> rubber-duck: this is not the official repo, you are looking at rust from 1 year ago
[10:08:56] <Blei> rubber-duck: go to https://github.com/mozilla/rust
[10:08:59] <bjz> rubber-duck: yes, enum used to be called tag
[10:09:18] <rubber-duck> Blei, lool I forgot I was reading a fork
[10:09:25] <nmatsakis> bjz: oh, no, I don't want to wait!
[10:09:46] <nmatsakis> bjz: Mostly I've just had limited cycles, and I've been focusing those on this patch to fix let patterns that's 95% done
[10:09:49] <rubber-duck> I was actually looking for the exact branch you're talking about in nmatsakis fork 
[10:10:18] <nmatsakis> rubber-duck: what branch are you looking for?
[10:10:29] <nmatsakis> rubber-duck: if you dig back too far in the history, you'll find a VERY different looking rust
[10:10:42] <rubber-duck> The pull that lets me use extern C fn ptrs 
[10:11:02] <bjz> rubber-duck: you might even find the ocaml source files :)
[10:11:02] <rubber-duck> I think it was closed because of incoming removal, and it didn't work on windows
[10:11:36] <nmatsakis> rubber-duck: ah, you want issue-3678-wrappers-be-gone-2
[10:11:43] <nmatsakis> rubber-duck: and yes if you can help me debug it, I would be grateful :)
[10:11:48] <nmatsakis> rubber-duck: I can tell you what I know...
[10:11:52] <bjz> nmatsakis: so much to do as always :[
[10:12:02] <bjz> nmatsakis: will it ever end?
[10:12:10] <nmatsakis> bjz: no, I suspect not.
[10:12:15] <bjz> hehe
[10:12:26] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[10:12:26] <bjz> the dangers of starting a project eh?
[10:12:53] * bjz is beginning to realise this
[10:13:20] <nmatsakis> we really need to expend some energy on cycle time.
[10:13:31] <bjz> cycle time?
[10:13:31] <nmatsakis> even though I'm pretty guilty of expanding it :)
[10:13:31] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[10:13:38] <nmatsakis> that is, the time to build rustc
[10:13:44] <bjz> ahh yes
[10:13:45] <Blei> _5_ canaries at the same time
[10:13:47] <Blei> argh
[10:14:01] <bjz> that is important, it would make iteration much easier
[10:14:15] *** Quits: sankha93 (Instantbir@DB7B6454.EEA5FE15.8B6C1D65.IP) (Ping timeout)
[10:14:16] <bjz> and improve bors
[10:14:19] <nmatsakis> yes. I pretty much agree with graydon that there is low hanging fruit galore
[10:14:33] <nmatsakis> or at least...medium.
[10:14:34] <bjz> (thereby making it less likely for PRs to rot)
[10:14:38] <bjz> yeah
[10:14:55] <bjz> unfortunately I wouldn't have a clue where to start :(
[10:15:09] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[10:15:18] <nmatsakis> my tour through the let patterns has made me realize what strcat is talking about when he complains about the quality of our generated LLVM IR :)
[10:15:25] <nmatsakis> I generally just look at the post-optimization stuff,
[10:15:32] <nmatsakis> but it's true we generate a lot of garbage.
[10:15:51] <nmatsakis> stuff like "load value; store value; load value; store value; load value; use value"
[10:16:01] <bjz> do you think fixing that could lead to some speedups?
[10:16:11] <nmatsakis> yes, but I'm not claiming it's a silver bullet
[10:16:20] <nmatsakis> not always so easy to fix unfortunately,
[10:16:33] <nmatsakis> most of those indirections are there because they make the architecture cleaner.
[10:16:49] <nmatsakis> anyway, I don't really know where to start either exactly, I think by measuring :)
[10:17:15] <nmatsakis> graydon's e-mail had many plausible sounding suggestions, and his work on the GC is probably going to help too, since he's been reducing memory usage
[10:17:29] <bjz> nice
[10:17:52] <Yoric> I remember seeing servo benchmarks a few weeks ago.
[10:18:01] <bjz> oh well, we move ever onwards
[10:18:03] <bjz> :)
[10:18:06] <Yoric> Did the servo people find out what was causing the slowdowns?
[10:18:08] *** Joins: sankha93 (Instantbir@BE39845E.105820C5.8B6C1D65.IP)
[10:18:22] <doener> I plan to spend a large part of my holiday (next week and the one after) one perf improvements
[10:18:23] <Yoric> (i.e. the benchmarks were 1000x slower than gecko, or something like this)
[10:18:32] <doener> s/one perf/on perf/
[10:19:33] <nmatsakis> Yoric: I don't know
[10:19:45] <Yoric> Just curious.
[10:20:01] <nmatsakis> rubber-duck: regarding windows problems... think you might be able to help?
[10:20:25] <Yoric> Given the order of magnitude, I assume something was cached on the Gecko side and recomputed on the Servo side.
[10:20:36] <nmatsakis> rubber-duck: I suspect the problem has something to do with linking, but I'm kind of guessing. It crops us when calling GetEnvironmentVariableW(), I believe, but only when rustc is building itself, not in standalone tests.
[10:20:44] <nmatsakis> Yoric: sounds likely.
[10:21:36] <rubber-duck> nmatsakis, was about to reboot to win, I'll certainly try but can't make any promises :|
[10:23:03] <Blei> please, someone fix the canaries XD
[10:23:08] <Blei> it doesn't stop
[10:23:18] <Blei> well, it doesn't stop stopping
[10:23:29] <nmatsakis> rubber-duck: let me know if I can help in any way. all it takes to reproduce the error is "make" :)
[10:24:42] <doomlord> how much optimization can be done in llvm->llvm transformations
[10:24:42] <engla> An unmentioned(?) issue so far with external iterators is traits: We can't replace fn each, fn each_key etc in the Map trait, because we'd either need to specify a concrete iterator type as return value, or add a type variable for each iterator method in the trait
[10:26:21] *** Quits: fabiand (fabiand@B363761C.DC24CC58.16E13E53.IP) (Ping timeout)
[10:26:38] *** Joins: fabiand (fabiand@B363761C.DC24CC58.16E13E53.IP)
[10:26:55] <engla> possibly the Map trait can afford to have one type variable for an .iter() method and let that be all
[10:29:21] *** Joins: pseudoku (quassel@8390C8EF.58489E08.520CDC98.IP)
[10:30:02] <engla> ah, the solution should of course be associated items
[10:30:41] *** Quits: rubber-duck (rubber-duc@moz-DAF7A616.dsl.iskon.hr) (Input/output error)
[10:31:08] *** Quits: pseudoku (quassel@8390C8EF.58489E08.520CDC98.IP) (Ping timeout)
[10:33:39] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[10:36:53] *** Joins: pseudoku (quassel@D49607BA.6F53187D.520CDC98.IP)
[10:40:13] *** Quits: pseudoku (quassel@D49607BA.6F53187D.520CDC98.IP) (Ping timeout)
[10:41:19] <nmatsakis> engla: good point, and yes the answer ought to be associated items;
[10:41:29] <nmatsakis> engla: as a stopgap one could imagine using objects, but it's unsatisfying.
[10:42:07] *** Joins: pseudoku (quassel@9FA7EA76.23383917.520CDC98.IP)
[10:44:23] *** Quits: pseudoku (quassel@9FA7EA76.23383917.520CDC98.IP) (Ping timeout)
[10:46:21] *** Joins: pseudoku (quassel@79B48C9C.1E3EB3FF.C28326FD.IP)
[10:46:40] <dbaupp> doomlord: a lot, LLVM basically does all the optimisations that rustc does.
[10:47:29] *** Quits: fabiand (fabiand@B363761C.DC24CC58.16E13E53.IP) (Quit: Verlassend)
[10:47:33] <cmr> almost all the optimizations llvm does is before native codegen isn't it?
[10:48:07] *** Quits: pseudoku (quassel@79B48C9C.1E3EB3FF.C28326FD.IP) (Ping timeout)
[10:49:04] <cmr> Did the debuginfo stuff land!?
[10:49:18] <dbaupp> cmr: yep, -Z debug-info *actually* works
[10:49:44] <dbaupp> you can set breakpoints on lines, and list the source and everything. It's sorta amazing.
[10:49:55] <cmr> Words cannot express how pleased I am!
[10:50:23] <dbaupp> cmr: and, yeah, I believe the optimisations are all IR -> IR transformations with codegen as the final step (approximately)
[10:52:05] *** Joins: snearch (snearch@moz-7C4E95C9.pool.mediaways.net)
[10:54:10] <engla> nmatsakis: I added my comment about external iterators to the associated items issue so it sticks around.   I'm mostly ignorant about traits as types (~Iterator<A>) but I think those are unusable when you need a lifetime, like the hashmap iterator does
[10:56:44] *** Joins: pseudoku (quassel@4F06EA2D.DACC8C67.520CDC98.IP)
[10:56:54] *** Quits: Blei (philipp@moz-7077963E.ethz.ch) (Quit: WeeChat 0.4.1)
[10:58:07] <nmatsakis> engla: they should work fine, but I think the code doesn't handle it correctly yet. You should be able to write ~Iterator:'r<A> to indicate an iterator object that has lifetime 'f
[10:58:29] <nmatsakis> dbaupp: woah! really!
[10:58:38] * nmatsakis has to try that out sometime
[10:58:48] <dbaupp> nmatsakis: yup, I tried it myself ;D
[10:59:03] <dbaupp> (it works on x86-64 linux, at least.)
[11:02:18] *** Quits: pseudoku (quassel@4F06EA2D.DACC8C67.520CDC98.IP) (Connection reset by peer)
[11:05:41] <cmr> rusti: bytes!("foo")
[11:05:46] -rusti- &[102, 111, 111]
[11:06:00] <cmr> Shouldn't the release notes say it returns a slice, rather than a vector?
[11:08:46] *** Joins: pseudoku (quassel@8BEA8E59.EC2003F4.C28326FD.IP)
[11:11:38] <doener> dbaupp: hm, so it's not enabled by default? I wonder why the PR caused such a big increase in compile time then
[11:11:53] <dbaupp> doener: possibly noise
[11:12:14] <dbaupp> doener: (but it was very stable for the few before that, so I'm not sure.)
[11:12:28] <doener> it was a pretty consistent jump across all three machines
[11:12:48] <doener> previously, the "noise jumps" were scattered
[11:13:22] <dbaupp> yeah... I've got no idea :S
[11:13:46] <dbaupp> that said, the windows compile is back to where it was
[11:13:58] *** Joins: sk (sk@1335CD0E.81A8C295.D066974A.IP)
[11:14:34] <doener> well, we'll see
[11:15:03] <dbaupp> the jump in the tests is probably (in part) due to the debug info tests being turned back on
[11:15:18] <dbaupp> actually, maybe not, given there is only 5 of them
[11:17:12] *** Quits: MaikKlein (maik@moz-ECF25244.dip0.t-ipconnect.de) (Ping timeout)
[11:23:40] *** Joins: Blei (philipp@moz-7077963E.ethz.ch)
[11:24:12] *** jdm is now known as jdm|f00ding
[11:33:38] *** zz_kimundi is now known as kimundi
[11:35:00] *** Quits: pseudoku (quassel@8BEA8E59.EC2003F4.C28326FD.IP) (Ping timeout)
[11:36:56] *** Joins: pseudoku (quassel@6D218259.E403A972.520CDC98.IP)
[11:41:22] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:43:39] *** Joins: judder (maradukewa@D90735BE.FBAA5D2F.78E362FE.IP)
[11:53:52] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[11:57:48] *** Quits: pseudoku (quassel@6D218259.E403A972.520CDC98.IP) (Ping timeout)
[11:59:40] *** Joins: pseudoku (quassel@D5B6A088.29155700.520CDC98.IP)
[12:01:37] *** Joins: fabiand (fabiand@moz-4FA43672.adsl.alicedsl.de)
[12:01:44] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Ping timeout)
[12:05:07] *** Joins: Blub\w (wry@moz-6B71B3CF.wireless.dyn.drei.com)
[12:05:35] *** Quits: pseudoku (quassel@D5B6A088.29155700.520CDC98.IP) (Connection reset by peer)
[12:08:44] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[12:09:32] *** Joins: pseudoku (quassel@3703544.98CA9F9E.520CDC98.IP)
[12:10:35] *** Joins: pyrac (pyrac@moz-C6037E0A.ghst.net)
[12:12:21] *** Quits: pyrac (pyrac@moz-C6037E0A.ghst.net) (Ping timeout)
[12:13:10] *** jdm|f00ding is now known as jdm
[12:16:40] *** Quits: z0w0 (zack@FDF4EF6A.2CA5CD8.5F93A189.IP) (Client exited)
[12:20:12] *** Quits: pseudoku (quassel@3703544.98CA9F9E.520CDC98.IP) (Ping timeout)
[12:21:16] *** Joins: pyrac (pyrac@moz-C6037E0A.ghst.net)
[12:22:05] <Blei> about the rust stacks: they grow down like system stack right?
[12:22:23] <Blei> i.e. the stack starts at stk->data + stk->end ?
[12:23:01] *** Quits: pyrac (pyrac@moz-C6037E0A.ghst.net) (Ping timeout)
[12:24:46] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:25:50] *** Joins: pseudoku (quassel@D41FDA18.2B2E4944.C28326FD.IP)
[12:27:44] *** Quits: pseudoku (quassel@D41FDA18.2B2E4944.C28326FD.IP) (Ping timeout)
[12:29:23] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.1)
[12:29:33] *** Joins: pseudoku (quassel@625FB3BF.B97AF14.C28326FD.IP)
[12:32:47] *** Quits: pseudoku (quassel@625FB3BF.B97AF14.C28326FD.IP) (Ping timeout)
[12:35:23] *** Joins: cr (anonymous@moz-32D659DA.dip0.t-ipconnect.de)
[12:35:28] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[12:35:58] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[12:36:56] *** Joins: pseudoku (quassel@9F70BB11.85E0F014.520CDC98.IP)
[12:39:19] *** Joins: jyeo (user@F2D29657.F60B0462.67AC9B1.IP)
[12:39:35] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[12:41:19] *** Joins: Amanieu (amanieu@moz-81B25A99.cs.man.ac.uk)
[12:44:27] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[12:44:49] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[12:45:25] *** Joins: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP)
[12:50:07] *** Quits: sankha93 (Instantbir@BE39845E.105820C5.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[12:55:45] *** Quits: pseudoku (quassel@9F70BB11.85E0F014.520CDC98.IP) (Ping timeout)
[12:57:17] *** Joins: gunther (Mibbit@moz-A0E225F0.avcosystems.co.uk)
[12:57:50] *** Joins: pseudoku (quassel@9D2C9770.F932B67E.C28326FD.IP)
[12:59:30] *** Joins: mw (mw@moz-4C7A686C.adsl.highway.telekom.at)
[13:01:02] *** Quits: pseudoku (quassel@9D2C9770.F932B67E.C28326FD.IP) (Ping timeout)
[13:02:49] *** Joins: lucian_ (lucian@moz-D82F7974.zone16.bethere.co.uk)
[13:03:02] *** Joins: pseudoku (quassel@36CF0E77.5C1EBCBC.520CDC98.IP)
[13:03:52] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[13:04:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:04:55] <nmatsakis> Blei: yes.
[13:06:08] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[13:07:28] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[13:14:24] <Blei> nmatsakis: thanks. do you know if any assembly or rust code is accessing the stk_seg struct directly?
[13:14:35] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[13:14:45] <Blei> (i'm trying to get an mprotect on the canary running)
[13:15:15] <cmr> doesn't mprotect only have page-resolution?
[13:15:25] <cmr> hm, guess not
[13:15:31] <Blei> (either i'm successful and it's overwritten more often than expected, or i'm doing something wrong)
[13:15:34] <Blei> cmr: true
[13:15:38] <cmr> actually it does
[13:15:41] <cmr> is the canary its own page?
[13:15:58] <Blei> that's why i'm modifying the stk_seg struct to be 2 pages long, so the canary has its own page
[13:16:04] <cmr> also only works for mmap'd pages
[13:16:18] *** Quits: pseudoku (quassel@36CF0E77.5C1EBCBC.520CDC98.IP) (Ping timeout)
[13:16:18] <nmatsakis> Blei: I don't know.
[13:16:34] <Blei> cmr: really? it seems to work here...
[13:16:44] <Blei> well, at least the call succeeds
[13:16:46] <cmr> linux extends it though
[13:17:17] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[13:17:42] <Blei> ah, "unspecified"
[13:17:44] <Blei> great
[13:18:19] *** Joins: pseudoku (quassel@FE233E74.B488EF51.C28326FD.IP)
[13:18:39] *** Quits: lucian_ (lucian@moz-D82F7974.zone16.bethere.co.uk) (Ping timeout)
[13:19:31] *** Joins: lucian_ (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[13:19:31] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Connection reset by peer)
[13:20:04] *** Quits: pseudoku (quassel@FE233E74.B488EF51.C28326FD.IP) (Ping timeout)
[13:21:43] *** Quits: gunther (Mibbit@moz-A0E225F0.avcosystems.co.uk) (Quit: http://www.mibbit.com ajax IRC Client)
[13:22:32] *** Joins: pseudoku (quassel@224B4AAE.B839B00D.520CDC98.IP)
[13:23:00] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:23:13] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[13:24:31] *** Quits: pseudoku (quassel@224B4AAE.B839B00D.520CDC98.IP) (Connection reset by peer)
[13:25:40] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[13:27:20] *** Joins: pseudoku (quassel@1F164E25.7BF686B4.C28326FD.IP)
[13:27:39] *** Joins: sankha93 (Instantbir@D109B33B.822F35C9.8B6C1D65.IP)
[13:27:44] <Blei> argh, no way to guarantee alignment when using mmap
[13:28:32] <Blei> ah, i don't actually need mmap
[13:29:04] <Blei> cmr: you were right, in linux any memory address is permissible
[13:29:33] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Ping timeout)
[13:29:50] <cmr> Blei: maybe valgrind has something that allows you to mark addresses as "don't touch this"? I feel like that'd be easier to use to debug than mprotect (I do not know, though)
[13:30:46] <Blei> cmr: true, but running valgrind in a loop for a failure that occurs 1 in 50 times or less is no fun
[13:30:56] <cmr> yeah
[13:31:06] <Blei> well, i'll see how far i get before i give up
[13:32:04] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[13:36:31] *** Quits: pseudoku (quassel@1F164E25.7BF686B4.C28326FD.IP) (Ping timeout)
[13:38:32] *** Joins: pseudoku (quassel@D989D98A.1514E2AF.C28326FD.IP)
[13:40:19] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: WeeChat 0.4.1)
[13:42:46] *** Quits: pseudoku (quassel@D989D98A.1514E2AF.C28326FD.IP) (Ping timeout)
[13:42:49] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[13:44:47] *** Joins: pseudoku (quassel@62A9B5BB.269A2B47.520CDC98.IP)
[13:45:31] *** Quits: bananana (Mibbit@moz-EBEA08D4.dynamic.ip.windstream.net) (Quit: http://www.mibbit.com ajax IRC Client)
[13:45:48] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:48:44] <Blei> ah, i think i found my bug
[13:49:09] <dbaupp> Blei: is this the bug that's killing poor little canaries?
[13:49:12] <Blei> i didn't unprotect the range when the stack got freed, and if another stack got allocated over the same range, stuff exploded
[13:49:18] <Blei> dbaupp: unfortunately, no
[13:49:25] <dbaupp> oh :(
[13:49:32] * dbaupp was all excited
[13:49:37] <Blei> only my usage of mprotect that should help the canaries. maybe.
[13:49:48] *** Quits: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com) (Ping timeout)
[13:49:50] <Blei> *should help find the problem of
[13:49:58] <dbaupp> ah, right... good luck :)
[13:49:58] *** Joins: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net)
[13:50:09] <Blei> thanks :)
[13:50:27] *** Quits: pseudoku (quassel@62A9B5BB.269A2B47.520CDC98.IP) (Ping timeout)
[13:52:34] *** Joins: pseudoku (quassel@70A0C21F.F2AFF267.520CDC98.IP)
[13:53:05] <cmr> What exactly does mprotect do on an access violation? segfault?
[13:53:38] <Blei> yeah
[13:54:14] <cmr> don't forget to set the signal disposition to core
[13:54:31] <Blei> whu?
[13:55:06] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:55:10] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[13:55:17] <Blei> ah, i see. is this change by rust somewhere?
[13:55:26] <cmr> the default is abort I think
[13:55:46] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[13:55:52] <cmr> or, rather, kill
[13:55:59] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Input/output error)
[13:56:06] <cmr> oh nevermind
[13:56:10] <cmr> it's core by default
[13:56:44] <cmr> don't forget to set ulimit -c unlimited and check your /proc/sys/kernel/core_pattern :)
[13:56:52] *** Joins: gretchen (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[13:57:19] *** Quits: Blub\w (wry@moz-6B71B3CF.wireless.dyn.drei.com) (Quit: ...)
[13:59:16] <Blei> ah, that's all the stuff in dmesg about
[13:59:29] <Blei> systemd-journald doesn't like my core file sizes
[13:59:54] <cmr> yeah, I just disable systemd-coredump
[14:00:17] <cmr> it's rarely useful for me
[14:01:34] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[14:07:28] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[14:11:58] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[14:12:04] *** Quits: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net) (Client exited)
[14:12:11] *** Quits: pseudoku (quassel@70A0C21F.F2AFF267.520CDC98.IP) (Connection reset by peer)
[14:12:15] *** kimundi is now known as zz_kimundi
[14:12:39] *** Quits: gretchen (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:13:05] *** Quits: joone (joone@moz-C04AAE60.fm.intel.com) (Ping timeout)
[14:13:06] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[14:14:48] *** Joins: pseudoku (quassel@D3A29C5E.B839B00D.520CDC98.IP)
[14:15:08] *** Joins: joone (joone@moz-C50DC051.jf.intel.com)
[14:17:54] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[14:22:02] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[14:24:02] *** Joins: mib_0p8aaq (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:25:57] *** Joins: qmx (qmx@E752832C.183C69CE.45D46379.IP)
[14:31:46] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[14:33:24] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Quit: Leaving)
[14:33:24] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[14:35:02] *** Quits: pseudoku (quassel@D3A29C5E.B839B00D.520CDC98.IP) (Ping timeout)
[14:35:58] *** Joins: moslimmasmmmry (muslimmasr@12BB9DE1.2C772474.563BE9DB.IP)
[14:36:02] <moslimmasmmmry> do chat prog spy4isreal&usa?????  do chat prog spy4usa&isreal??????
[14:36:02] <moslimmasmmmry>   do skype,yahoo,otherchat&socialcommunication prog spy4isreal&usa?????
[14:36:02] <moslimmasmmmry>   do they record&analyse everything we type?
[14:36:02] <moslimmasmmmry>     do skype,yahoo,otherchat&socialcommunication prog spy4isreal&usa?????
[14:36:02] <moslimmasmmmry>   do they record&analyse everything we type?
[14:37:00] *** Joins: pseudoku (quassel@ACE6EF45.A50065F5.C28326FD.IP)
[14:37:01] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:37:56] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:38:09] <EXetoC> lololol
[14:38:35] *** Parts: moslimmasmmmry (muslimmasr@12BB9DE1.2C772474.563BE9DB.IP) ()
[14:38:40] *** Joins: nano (nano@moz-972880B.superkabel.de)
[14:41:12] *** Quits: pseudoku (quassel@ACE6EF45.A50065F5.C28326FD.IP) (Ping timeout)
[14:42:18] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:43:14] *** Joins: pseudoku (quassel@88840F60.AE78DE90.520CDC98.IP)
[14:47:41] *** Quits: Blei (philipp@moz-7077963E.ethz.ch) (Ping timeout)
[14:49:08] *** Quits: pseudoku (quassel@88840F60.AE78DE90.520CDC98.IP) (Connection reset by peer)
[14:49:11] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:51:56] *** Joins: pseudoku (quassel@40C5557B.F2AFF267.520CDC98.IP)
[14:54:58] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:56:36] *** Joins: hansjorg (hansjorg@moz-EECB5F79.static.cust.telenor.com)
[14:57:07] *** Quits: pseudoku (quassel@40C5557B.F2AFF267.520CDC98.IP) (Connection reset by peer)
[14:59:40] *** Joins: pseudoku (quassel@68B7ED64.EA11172.520CDC98.IP)
[14:59:49] *** Quits: jga (asdf@114D2B3A.FB5B5D5.B5524284.IP) (Ping timeout)
[15:05:38] *** Joins: eholk (eholk@moz-5CE2DFCF.uconnect.utah.edu)
[15:05:52] *** zz_kimundi is now known as kimundi
[15:07:15] <mw> Hi! Does somebody know where I can see messages generated by the debug!() macro?
[15:07:24] <cmr> mw: RUST_LOG=4
[15:07:41] <cmr> mw: but that's going to flood you if you're running it on rustc
[15:07:53] <mw> as parameter to rustc?
[15:07:55] <cmr> you can do RUST_LOG=rustc::middle::whatever=4 (any module) to narrow it down
[15:07:58] <cmr> as environment variable
[15:08:09] <mw> ah, ok
[15:08:15] <mw> thank you
[15:08:49] <cmr> np. really looking forward to better debug info :D
[15:09:59] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:10:00] <mw> I'm on it ;-)
[15:10:12] <mw> found the first bug already
[15:10:43] <mw> when having two tuples within a struct
[15:11:00] <mw> the second tuple can't be read by gdb
[15:11:23] *** Quits: pseudoku (quassel@68B7ED64.EA11172.520CDC98.IP) (Ping timeout)
[15:13:27] *** Joins: pseudoku (quassel@2092396B.3E0BD90F.520CDC98.IP)
[15:14:04] *** Joins: MaikKlein (maik@moz-EA0093E4.uni-koblenz.de)
[15:14:49] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[15:15:42] *** Quits: pseudoku (quassel@2092396B.3E0BD90F.520CDC98.IP) (Ping timeout)
[15:16:07] *** Joins: jga (asdf@FE876AEA.207DAD7B.B5524284.IP)
[15:17:03] *** Quits: MaikKlein (maik@moz-EA0093E4.uni-koblenz.de) (Ping timeout)
[15:17:39] *** Joins: pseudoku (quassel@E30EDF34.CBE465C1.C28326FD.IP)
[15:19:54] *** Quits: pseudoku (quassel@E30EDF34.CBE465C1.C28326FD.IP) (Ping timeout)
[15:20:03] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[15:21:52] *** Joins: pseudoku (quassel@67EEF7D2.5B86C286.C28326FD.IP)
[15:26:59] *** Quits: Palmik (palmik@moz-5CA3F354.pks.muni.cz) (Quit: Lost terminal)
[15:28:15] *** Quits: pseudoku (quassel@67EEF7D2.5B86C286.C28326FD.IP) (Connection reset by peer)
[15:31:06] *** Joins: pseudoku (quassel@CF934091.4DA35B3F.520CDC98.IP)
[15:32:28] *** Quits: pseudoku (quassel@CF934091.4DA35B3F.520CDC98.IP) (Connection reset by peer)
[15:35:10] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[15:35:33] *** Joins: pseudoku (quassel@48204577.44911EBC.C28326FD.IP)
[15:37:24] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[15:37:24] *** ChanServ sets mode: +qo graydon graydon
[15:37:46] *** Quits: pseudoku (quassel@48204577.44911EBC.C28326FD.IP) (Ping timeout)
[15:38:24] <erickt> kimundi: ping
[15:38:34] <kimundi> vgji
[15:38:40] <erickt> good morning!
[15:38:41] <kimundi> err, pong
[15:38:45] <erickt> hehe
[15:39:46] *** Joins: pseudoku (quassel@171B5783.A649DFF7.C28326FD.IP)
[15:40:52] <erickt> I had an idea stewing in my head regarding this whole str::from_bytes_slice can access invalid memory thing. How bad of an idea would it be to subtract 1 from a &str's length?
[15:41:06] *** Quits: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[15:41:29] <kimundi> subtracting 1 is completly safe
[15:41:33] <erickt> such that doing s[s.len()] is not accessing invalid memory
[15:41:59] *** Quits: pseudoku (quassel@171B5783.A649DFF7.C28326FD.IP) (Ping timeout)
[15:42:38] <kimundi> well, it depends wher you want to subtract 1
[15:42:46] <erickt> or rather, doing `str::as_buf(s, |p, len| *ptr::offset(p, len))` would not access invalid memory
[15:43:32] <erickt> `fn len()` would add back in that subtracted 1 so the end user isn't aware of these shenanigans
[15:43:48] <cmr> Anyone good with gnuplot or other plotting software? I have memory usage and timing data from all the benchmarks (that compile on master) :)
[15:43:53] <kimundi> err... that sounds not good I think
[15:44:00] *** Joins: pseudoku (quassel@B021B237.D65816C7.520CDC98.IP)
[15:44:10] <erickt> kimundi: It feels wrong, but I'm having trouble articulating why
[15:44:19] <kimundi> the problem isn't one thet can be circiumvented that way
[15:44:36] *** Joins: josh (josh@moz-C350AC70.hsd1.mn.comcast.net)
[15:45:24] <kimundi> &str -> &[u8] : possible without problem, &[u8] -> &str not possible without the &[u8] beeing one longer than you want in your &str
[15:45:42] *** Quits: pseudoku (quassel@B021B237.D65816C7.520CDC98.IP) (Ping timeout)
[15:46:25] <cmr> the problem is we want nul termination for fast C interop, but we don't want to have to deal with the nul, which isn't feasible.
[15:46:31] <kimundi> rusti: let f = "foo"; let s: &[u8] = unsafe { transmute(foo) }; s
[15:46:32] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:46:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FEYS
[15:46:39] *** Joins: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[15:47:01] <kimundi> rusti: let f = "foo"; let s: &[u8] = unsafe { transmute(foo) }; println(fmt!("%?", s))
[15:47:02] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KaUQ
[15:47:13] <kimundi> rusti: let f = "foo"; let s: &[u8] = unsafe { transmute(s) }; println(fmt!("%?", s))
[15:47:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SIBB
[15:47:36] <kimundi> rusti: let f = "foo"; let s: &[u8] = unsafe { ::std::cast::transmute(s) }; println(fmt!("%?", s))
[15:47:37] -rusti- <anon>:9:77: 9:78 error: unresolved name `s`. Did you mean `f`?
[15:47:37] -rusti- <anon>:9     let r = {  let f = "foo"; let s: &[u8] = unsafe { ::std::cast::transmute(s) }; println(fmt!("%?", s))
[15:47:37] -rusti-                                                                                       ^
[15:47:37] -rusti- error: aborting due to previous error
[15:47:37] -rusti- application terminated with error code 101
[15:47:40] <cmr> kimundi: you're really bad at this game :p
[15:47:42] *** Joins: pseudoku (quassel@B43D6CAA.175EDA21.C28326FD.IP)
[15:47:52] <kimundi> rusti: let f = "foo"; let s: &[u8] = unsafe { ::std::cast::transmute(f) }; println(fmt!("%?", s))
[15:47:53] -rusti- &[102, 111, 111, 0]
[15:47:53] -rusti- ()
[15:47:56] <kimundi> ther :P
[15:48:00] <erickt> haha
[15:48:14] <graydon> https://etherpad.mozilla.org/Meeting-weekly-2013-06-18
[15:48:33] <kimundi> that's the problem, a &str of size N is actually a &[u8] of size N+1
[15:49:13] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[15:49:14] <cmr> &[u8] -> &str isn't a sane or safe operation, I'm fine with it being broken
[15:49:27] <jack> nmatsakis: did your fast ffi patch land, and if not, do you know the bug number?
[15:50:08] <kimundi> cmr: Its sane an safe with a isutf8 check
[15:50:09] <erickt> cmr: it can make sense when you're doing parsing. Thats where I got tripped up when I tried to remove from_bytes_slice
[15:51:08] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[15:51:16] <erickt> not completely safe. If you take a *u8 and length from C, then turn it into a &[u8], then turn it into a &str, you have no guarantee that original *u8 is null terminated
[15:51:21] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:52:41] <erickt> we could just call this "these were marked unsafe for a reason", but I could see the unsafeness of that *u8 spilling out from a library into an application
[15:53:05] <kimundi> erickt: There is no problem with the scenarion you described
[15:53:34] <erickt> kimundi: how so?
[15:54:11] <kimundi> erickt: once you got the &[u8], its not safe to access one after the last element anyway, so it doesn't matter if there is a n ull or not
[15:54:33] <kimundi> you'd have to check it the last byte is null, and if not make a copy
[15:54:55] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: anri)
[15:55:39] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[15:56:08] *** Quits: mib_0p8aaq (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:56:28] <erickt> kimundi: it does if you pass the &str to as_c_str. Say the C program has something like `char foo[2] = { 'h', 'i' }; char bar = 0;` and the pointer to foo gets passed to rust as a &[u8]
[15:56:34] <kimundi> the range of memorry address you can access is always the same: (*u8,  len) == &[u8] == &str
[15:57:39] <kimundi> it's just that logically, user code sees one byte less in the &str compared to the &[u8]
[15:57:47] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[15:58:03] <kimundi> but that byte is still there and points at a valid, allocated memory address
[15:58:48] <erickt> kimundi: yes when dealing with proper rust structures. It all goes to heck when interacting with C
[15:58:53] *** Joins: brendan (brendaneic@moz-8AD662B6.sub-70-197-4.myvzw.com)
[15:59:24] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[16:00:23] <cmr> graydon: is it generally agreed no new language features before 1.0?
[16:00:32] <kimundi> erickt: at the c boundaries you of course have to make sure that such problems can't creep ints rusts types
[16:00:38] <erickt> We could just document that it's dangerous to do `let v = vec::from_buf_slice(buf, len); let s = str::from_bytes_slice(v)` because it doesn't guarantee that there's a null terminateor
[16:01:11] <Amanieu> cmr: from what I understood, no backward-compatibility breaking after 1.0
[16:01:15] <kimundi> erickt: Sounds like a bad idea
[16:01:15] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:01:21] <erickt> kimundi: I agree
[16:01:26] <graydon> cmr: we're in the process of trying to define such concepts. 1.0 is not a defined milestone yet. we're looking at milestones in "maturity" terms. one of which is backwards compatibility. a later one is feature completeness.
[16:01:30] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:01:46] *** Joins: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[16:01:49] <graydon> cmr: which feature did you have in mind?
[16:01:56] <cmr> graydon: so there could be a 0.10 or 0.11 before 1.0?
[16:01:57] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[16:02:02] <graydon> cmr: yes, of course
[16:02:07] <cmr> ah, ok
[16:02:41] <cmr> graydon: I don't have any particular feature in mind, just trying to get a better grasp of the release plan
[16:02:47] <graydon> the 0.x series will continue quarterly until we reach the milestone we consider appropriate for 1.0-ness, which implies (I think) at least a backwards-compatibility commitment, since otherwise the next version would be 2.0 :(
[16:02:50] <erickt> kimundi: I just feel like if I saw a `&[u8]`, it feels like it should be safe to treat it as a `&str`. Only as_c_str cares about that dang null.
[16:02:58] <kimundi> erickt: I'd say have two versions: one safe one that demands a &[u8] one longer then the &str you want to end up with, and a unsafe one that just increments the len field but can point at invalid memory that way
[16:03:22] <erickt> kimundi: that is what we have right now
[16:03:42] <kimundi> erickt: either write correct code on the way the implementation works, or change the implementation :P
[16:03:46] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:03:55] <erickt> from_bytes_slice is the unsafe one, and from_bytes_slice_with_null demands the trailing null at the end of the slice
[16:04:13] <kimundi> excep it doesn't need to ba a null
[16:05:13] <kimundi> demanding a null there is to specific
[16:05:21] *** Joins: tjc (tjc@C65425CA.7859580F.DC443CCD.IP)
[16:05:21] *** ChanServ sets mode: +o tjc
[16:05:42] <erickt> kimundi: ah. hm. where we just assert the &[u8] one longer. that could work
[16:06:11] <kimundi> no need for an assertion either :P
[16:06:41] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[16:07:16] <kimundi> fn from_bytes_plus_one(in: &'a [u8]) -> &'a str { unsafe { transmute(in) } }
[16:08:33] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[16:08:33] *** ChanServ sets mode: +o brson
[16:08:53] *** Quits: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:08:54] <erickt> i was thinking `fn from_bytes<'a>(in:&'a [u8], len: uint) -> &'a str { assert!(len < in.len()); unsafe { transmute(in) } }`
[16:09:05] <kimundi> errr, do'h of course there still needs to be the is utf-8 assertion
[16:09:13] <erickt> yeah :)
[16:09:28] <kimundi> what? why? :P
[16:09:40] <erickt> or maybe follow the slice notation with begin and end
[16:09:48] <kimundi> the &[u8] already has a length
[16:10:00] <nmatsakis> jack: no, it's issue #3678
[16:10:08] <nmatsakis> jack: I haven't had any time to look into it
[16:10:09] *** Joins: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[16:10:25] <nmatsakis> jack: if you know anything about Windows, or would care to learn, I'd be happy to discuss :)
[16:10:40] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[16:11:02] <erickt> kimundi: to force the user to think about how strings need to have that extra byte
[16:11:03] <cmr> nmatsakis: Aetherspawn_BNC claimed to know a lot about windows yesterday, but he has exams right now
[16:11:04] <kimundi> fn from_bytes_plus_one(in: &'a [u8]) -> &'a str { assert!(in.slice(0,in.len()-1).is_utf8()); unsafe { transmute(in) } } // All that's needed, I think
[16:11:27] <erickt> kimundi: plus I think the _plus_one looks funny :)
[16:12:05] <kimundi> erickt: To force what? I just semmes like it makes the function unneccessary more complicated, with the same result
[16:12:06] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[16:12:24] <kimundi> _with_byte_term ?
[16:12:39] <kimundi> _with_trailing?
[16:12:40] *** Quits: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[16:12:49] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[16:12:56] <erickt> also, I think one of the common patterns with from_bytes is to parse a byte string, where you are walking over a subset of the bytes
[16:13:41] *** Quits: brendan (brendaneic@moz-8AD662B6.sub-70-197-4.myvzw.com) (Quit: brendan)
[16:13:50] <kimundi> erickt: yeah, wich means if you want to slice that to a &str without copy you need to slice you'r bytes one longer than neccessarry
[16:13:54] <erickt> kimundi: for example, libextra/ebml.rs is doing `str::from_bytes_slice(self.data.slice(self.start, self.end))`
[16:14:14] <kimundi> which is fine, just needs a copy
[16:14:30] <kimundi> or consuming self and a push(0)
[16:14:37] *** Joins: laci (Mibbit@moz-319388CD.catv.broadband.hu)
[16:14:53] <laci> hi
[16:15:41] <laci> I've been reading the manual and it seems that a single source file either produces a shared library or an executable. Is this true for all cases or did I misunderstand something?
[16:16:17] <laci> is it possible to link together the content of multiple source files (after compilation)?
[16:16:19] *** Joins: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[16:16:34] <kimundi> laci: High :) First of, better read the tutorial. Second, no this is not directld correct, but almost
[16:16:39] <erickt> laci: you can package up multiple files into what we call a crate
[16:16:45] <kimundi> Err, jush 'Hi' :P
[16:16:45] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[16:16:49] <kimundi> just*
[16:16:56] <mark_edward> crates are defined by crate files (*.rc)
[16:16:56] <erickt> but we don't do separate compilation like C yet
[16:16:58] <tikue> etherpad link?
[16:17:08] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Ping timeout)
[16:17:10] <kimundi> mark_edward: No they are not anymore
[16:17:17] <erickt> mark_edward: not anymore, *.rc files are deprecated
[16:17:20] <mark_edward> no?
[16:17:21] <kimundi> tikue: https://etherpad.mozilla.org/Meeting-weekly-2013-06-18
[16:17:23] <mark_edward> since when!
[16:17:27] <kimundi> mark_edward: No
[16:17:27] <tikue> kimundi: thank you
[16:17:42] <kimundi> mark_edward: Deprecated since 0.6 or so
[16:17:56] <mark_edward> hm... this is the first im hearing it... 
[16:18:01] <laci> so, it is possible to organize my code into several files and still put everything into a large executable, that's good news:)
[16:18:09] <mark_edward> so what are you supposed to do instead?
[16:18:11] <kimundi> the makefile just uses the .rc ending for identifying crates, but that's it
[16:18:24] *** Quits: sk (sk@1335CD0E.81A8C295.D066974A.IP) (Quit: Leaving)
[16:18:32] <kimundi> mark_edward: name all .rs, and pass rustc the right root file
[16:18:33] *** Quits: jyeo (user@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[16:19:06] <mark_edward> what was the purpose of this? I think having a different file extension helped clarify the purpose of that file
[16:19:12] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[16:19:49] <cmr> mark_edward: what is the purpose of that file, exactly?
[16:20:01] <kimundi> mark_edward: Well for one there is no difference between a rs and rc file. Also, rc is apparently a bit more overloaded filending-wise than rs
[16:20:26] <cmr> yeah, it's already used for config files
[16:20:32] <mark_edward> cmr: to declare the compilation... stuff... i think of it sort of like a rust specific makefile
[16:20:46] <cmr> mark_edward: that's what pkg.rs is for :)
[16:21:07] <erickt> kimundi: got to step out for a bit. I like the direction this is going though :)
[16:21:22] <mark_edward> when will support for .rc files be removed?
[16:21:44] <cmr> rust doesn't care what the extension of the file you're using is atm, not sure if it ever will
[16:21:54] <kimundi> laci: You just designate one of your .rs file as the root of you module hierachy by passing it to rustc for compilation. The result of that, wich might pull in more source files, is a crate. That crate is either a lib or a binary, depending on compiler flags/command line options
[16:22:02] <cmr> for example, I accidentally used foo.py earlier today :p
[16:22:28] <kimundi> mark_edward: There is no support for rc files at all.
[16:22:33] <laci> kimundi: thanks, I'll try it and will check the tutorial too
[16:22:50] <kimundi> mark_edward: It's just an different file ending, like .txt or .so
[16:22:57] <mark_edward> oh ok... 
[16:23:33] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[16:23:57] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[16:25:10] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[16:25:38] <bstrie> tjc: how was the presentation?
[16:25:50] <tjc> bstrie: practice talk was great! lots of questions
[16:26:05] <tjc> somehow I have to find time today to update the slides in response to some of the feedback, despite all the interesting talks today
[16:26:09] <bstrie> what aspects were they most inquisitve about?
[16:26:22] <tjc> everything! Um...
[16:26:32] <cmr> heh
[16:26:40] <tjc> really, though, I feel like I got questions about almost every slide
[16:27:04] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[16:27:04] *** ChanServ sets mode: +o pcwalton
[16:27:24] <kimundi> Where they that incomprehensible? ;)
[16:27:36] <tjc> yeah, definitely :-)
[16:29:30] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[16:30:25] <steven_is_false> Hello! I installed rust in a ~/.local, and now I am wondering: Can I add the man pages in ~/.local to some kind of MAN_PATH variable?
[16:30:25] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[16:31:01] <cmr> steven_is_false: MANPATH :)
[16:31:06] <steven_is_false> cmr: Thanks!
[16:31:15] <cmr> there's a program `manpath` that will tell you the default
[16:31:40] <steven_is_false> cmr: thanks
[16:32:32] <steven_is_false> So I should add $HOME/.local/share/man"?
[16:32:59] *** Quits: tjc (tjc@C65425CA.7859580F.DC443CCD.IP) (Ping timeout)
[16:33:07] <cmr> yes
[16:33:21] <steven_is_false> I have a man1 subdirectory.
[16:33:37] <cmr> yes, that is how man searches through sections, that is normal
[16:33:49] <steven_is_false> Oka
[16:33:51] <steven_is_false> Okay
[16:34:18] <steven_is_false> Shoot, there's a bug in the compton installer.
[16:34:27] <steven_is_false> It installs to man rather than man1
[16:34:52] <steven_is_false> Rust doesn't seem to have any man pages.
[16:35:07] <cmr> I have a ~/.local/share/man/man1/rustc.1
[16:35:36] <steven_is_false> Maybe I didn't have the right programs installed to generate it?
[16:35:42] <cmr> ah, maybe
[16:35:50] <cmr> you need pandoc and maybe something else
[16:37:02] <steven_is_false> cmr: Thanks, I'll figure it out.
[16:37:24] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[16:37:33] *** Quits: pseudoku (quassel@B43D6CAA.175EDA21.C28326FD.IP) (Connection reset by peer)
[16:37:42] *** Joins: tjc (tjc@moz-24060A8E.firstunitarianportland.org)
[16:37:42] *** ChanServ sets mode: +o tjc
[16:40:35] *** Joins: pseudoku (quassel@D4BD28B1.9EDE08CF.C28326FD.IP)
[16:40:51] <cmr> https://github.com/cmr/rust-bench has my current rust-bench code (measures memory usage in realtime, measures cpu time and realtime elapsed). outputs json, requires python3. I have data for all the working benchmarks in src/test/bench if anyone wants/knows how to plot/do other things with them
[16:41:11] <cmr> also gets memory usage for compiling the test, and extracts the time-passes data
[16:41:25] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[16:41:26] *** Quits: pseudoku (quassel@D4BD28B1.9EDE08CF.C28326FD.IP) (Connection reset by peer)
[16:41:29] <cmr> ie, from rustc
[16:41:39] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[16:41:50] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[16:41:57] <bstrie> cmr: wow, that would be great to have for isrustfastyet
[16:42:03] <bstrie> memory reporting, I mean
[16:42:06] <cmr> bstrie: that's exactly why I'm writing it :)
[16:42:19] <bstrie> ask graydon if it can be integrated into the builtbots
[16:42:21] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:43:01] <cmr> It'd take some polishing to get it generic enough, right now it just takes a path to a crate and compiles it, no configurability
[16:43:09] <cmr> graydon: but I'd be up for it
[16:43:51] <cmr> I'd like to rewrite it in rust eventually, but python is very convenient :)
[16:45:59] *** Joins: pseudoku (quassel@5B0D84E5.AB6E7807.C28326FD.IP)
[16:46:18] *** Parts: mw (mw@moz-4C7A686C.adsl.highway.telekom.at) ()
[16:46:30] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[16:47:22] *** Joins: jyeo (user@F2D29657.F60B0462.67AC9B1.IP)
[16:49:31] *** Quits: sankha93 (Instantbir@D109B33B.822F35C9.8B6C1D65.IP) (Ping timeout)
[16:50:15] *** Quits: pseudoku (quassel@5B0D84E5.AB6E7807.C28326FD.IP) (Ping timeout)
[16:51:44] *** Quits: jyeo (user@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[16:51:51] *** Joins: xarcus (Mibbit@moz-DC0176A1.kroger.com)
[16:53:07] <Blei> so, i think i found the place where the canary gets overwritten
[16:53:16] <Blei> it's ... dramatic drumroll ... jemalloc
[16:53:20] *** Quits: tjc (tjc@moz-24060A8E.firstunitarianportland.org) (Quit: zzzzzzzzzz)
[16:53:28] <pcwalton> Blei: interesting
[16:53:35] <Blei> 2 possibilities: 1) jemalloc is buggy 2) we have a double free somewhere
[16:53:38] <cmr> what is jemalloc doing with the stack?
[16:53:42] *** Joins: sankha93 (Instantbir@D109B33B.822F35C9.8B6C1D65.IP)
[16:53:44] <xarcus> can enums inherit?
[16:53:56] <xarcus> that might be a stupid question.
[16:53:58] <Blei> cmr: the stack is allocated by jemalloc, so i guess it does some free list management
[16:54:03] <cmr> Blei: ah
[16:54:33] <cmr> is the stack canary not allocated and just assumed to be unused?
[16:54:44] *** Joins: brendan (brendaneic@moz-8AD662B6.sub-70-197-4.myvzw.com)
[16:54:49] * cmr knows nothing about this part of rust
[16:55:36] *** Joins: pseudoku (quassel@3A2C6995.9F275360.C28326FD.IP)
[16:56:07] <Blei> specifically, the call to free in rust_stack.cpp:170 (part of the exception handler??) causes jemalloc to do some stuff, leading to a segfault in arena_chunk_dirty_remove in arena.c:205
[16:56:29] <Blei> cmr: well, yes. but apparently it's overwritten somewhere, and that somewhere is jemalloc
[16:56:50] <Blei> the canary is there to check that noone overwrites that part of the memory
[16:57:08] <cmr> Blei: you can pass --enable-debug to jemalloc's configure to get much more debugging info
[16:57:30] <cmr> there's also opt.zero, opt.redzone, and opt.junk
[16:57:47] <Blei> https://gist.github.com/Blei/5807181
[16:58:55] *** Quits: pseudoku (quassel@3A2C6995.9F275360.C28326FD.IP) (Ping timeout)
[16:58:56] <doener> hm, my rust_stack.cpp only has 105 lines
[16:59:01] <cmr> as does mine
[16:59:27] <Blei> oh, that's because it's rust_task.cpp
[16:59:29] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:59:31] <Blei> sorry
[16:59:36] <Blei> see the backtrace i gisted
[17:00:51] <doener> hm, that's the catch, so probably the free is called from the unwinding codE?
[17:01:13] *** Joins: Palmik (palmik@moz-5CA3F354.pks.muni.cz)
[17:01:26] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:01:36] <Blei> probably
[17:02:14] <cmr> Blei: did you find any way to reliably reproduce?
[17:02:15] <doener> Blei: could you gist the disassembly for stackframe 16?
[17:02:20] *** Joins: mib_ti14h9 (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[17:02:21] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:02:52] <Blei> cmr: make check :P almost always results in a canary or five
[17:03:14] <nmatsakis> jld: it's too bad that once fns can't be defined as "exactly once" vs "at most once" --- or at least, if we did, they wouldn't be usable with Option.map
[17:03:24] <nmatsakis> jld: because that would seem to bring another level of power that you can't get by passing arguments
[17:03:35] *** Joins: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[17:03:42] <pcwalton> let's use dependent types to encode the number of times a closure can be invoked
[17:03:47] * pcwalton apologizes
[17:03:48] * graydon weeps
[17:03:53] <jedestep> I'm still having mutable borrowing troubles. Here is the exact code: https://gist.github.com/jedestep/5807238
[17:03:56] *** Quits: pnkfelix1 (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[17:04:00] <jld> nmatsakis: I guess the full substructural lattice could be encoded by passing in a T and passing out a U, but....
[17:04:01] <Blei> doener: https://gist.github.com/Blei/5807240
[17:04:04] <nmatsakis> jld: the use case I had in mind was this parallelism API, where I was writing things like: "parallel::execute([|| f = ..., || g = ...])"
[17:04:05] <pcwalton> (I don't mean to trivialize the use case for once functions)
[17:04:12] <pcwalton> it *is* a hard call
[17:04:16] *** Joins: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP)
[17:04:22] <brson> Blei: my rust_stack.cpp doesn't have line 170
[17:04:31] <doener> brson: rust_task.cpp
[17:04:35] *** Quits: xarcus (Mibbit@moz-DC0176A1.kroger.com) (Quit: http://www.mibbit.com ajax IRC Client)
[17:04:46] <nmatsakis> jld: you can't quite model this with return values, because the different closures you are executing in parallel may not generate the same type of result (that is, in my example, f and g may have distinct types)
[17:05:04] <graydon> it's not trivial. it's just a border case. the argument I was making is merely that "moving a value involves passing it as an argument" is how several of our APIs are already structured (and will remain, due to the nature of the interface) so I feel like it might generalize to the places we're using once.
[17:05:43] *** Quits: josh (josh@moz-C350AC70.hsd1.mn.comcast.net) (Quit: josh)
[17:05:45] <doener> jedestep: what's the problem there?
[17:05:54] <doener> Blei: thanks!
[17:05:56] <brson> jemalloc must require more stack than stock malloc
[17:06:07] <graydon> much like C programmers just get accustomed to mentally distinguishing by-value and by-reference, callback-with-a-user-data-value and callback-with-none, etc.
[17:06:08] <jld> nmatsakis: Oh, right.  The closures are existential.  I may not be sufficiently caffeinated for this yet.
[17:06:24] <graydon> brson: very possible
[17:06:25] <brson> Blei: those calls to malloc in rust_start_wrapper can be moved into the cleanup_task function
[17:06:28] <Blei> it's not always at 170, i have one case where it happens at 195
[17:06:33] <jedestep> doener: "cannot borrow self.stream as mutable because it is borrowed as immutable" at the line self.stream.pass(1)
[17:06:35] <brson> cleanup_task runs on the big C stack
[17:07:00] *** Joins: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[17:07:05] * graydon notes the other curiosity about the broken build: the 32bit builds are timing out building libextra's unit tests. in llvm. it is not using all memory or anything, just seemingly ilooping.
[17:07:10] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[17:07:14] <doener> jedestep: the subtype causes a borrow
[17:07:19] <jld> Wasn't there talk of compiling a malloc with stack limit checks?
[17:07:45] * jld is probably out of date on the current state of stack switching.
[17:07:45] *** Quits: ecr (ereed@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:07:48] <jedestep> doener: yes that is given as a note. but trying to reborrow self.stream for subtype results in a similar error being thrown there
[17:07:51] <brson> Blei: return_c_stack() calls free, drop glue does arbitrary things and the region->free obviously calls free
[17:08:23] <brson> oh, drop glue should grow the stack
[17:08:25] <Blei> return_c_stack doesn't call free iirc
[17:08:33] <doener> jedestep: you deref it later anyway, so you could do the deref at assignment time. That should drop the borrow
[17:08:36] <brson> Blei: oh that's right
[17:08:56] <brson> Blei: I guess it's just that call to free
[17:09:02] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[17:09:19] *** Joins: pseudoku (quassel@337B1ACF.579EB575.520CDC98.IP)
[17:09:23] <jld> (But then there's the question of what mallocs stack frames for malloc, I guess.)
[17:09:47] *** Joins: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net)
[17:09:49] <jedestep> doener: wow, that got it. thanks a ton. was it because of assigning the borrowed value?
[17:09:56] <Blei> oh, a third possibility: are there cases where rust stacks are freed by calling free directly instead of calling destroy_*_stack ?
[17:10:06] *** Joins: jyeo (user@F2D29657.F60B0462.67AC9B1.IP)
[17:10:21] <brson> jld: yeah, i think malloc is the case where you absolutely have to have some fallback stack to work with somewhere
[17:11:03] *** Quits: pseudoku (quassel@337B1ACF.579EB575.520CDC98.IP) (Ping timeout)
[17:11:04] <doener> jedestep: Because you get a pointer from first(), that means a borrow on self.stream (which is &self for first())
[17:11:20] * pcwalton wants to revamp metadata
[17:11:23] <doener> jedestep: because modifying self.stream could invalidate the returned pointer
[17:11:23] <pcwalton> I'm doing it today
[17:11:24] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[17:11:27] <pcwalton> slight revamp
[17:11:42] <doener> jedestep: since the deref creates a copy, the borrow is no longer needed
[17:12:00] <jedestep> doener: ooooohhhhh I see what you mean. thanks so much :)
[17:12:17] <doener> hm, should that be borrow or loan? I guess loan?
[17:14:42] *** Joins: pseudoku (quassel@4133B1A1.FE7DDF00.520CDC98.IP)
[17:14:52] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[17:15:15] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[17:16:00] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:16:35] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:17:01] *** Quits: pnkfelix|rcirc (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Input/output error)
[17:18:07] *** Quits: pnkfelix (pnkfelix@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Quit: Leaving.)
[17:19:01] <nmatsakis> grr. this damn patch. every time I squelch one crash, another peeks out. worrisome.
[17:19:18] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[17:19:54] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[17:20:25] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:20:45] <pcwalton> nmatsakis: is this the ffi one?
[17:21:12] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[17:21:27] <nmatsakis> pcwalton: no. cleaning up irrefutable bindings.
[17:21:31] <pcwalton> oh
[17:21:38] <pcwalton> that's very important too :)
[17:21:45] <strcat> graydon: did you see https://github.com/mozilla/rust/issues/7206 ?
[17:21:53] <nmatsakis> pcwalton: however, I'll reboot to windows now, I should at least rebase that FFI patch and see if it's miraculously gone away ;)
[17:22:49] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[17:23:14] * strcat gets endless stack overflows now :(
[17:23:26] <graydon> I did. it's interesting. busy at the moment, but yeah. I laughed when I saw that.
[17:23:35] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:24:06] <strcat> probably something to do with how we generate 100 allocas and 50 casts for something as simple as swap ;p
[17:24:23] *** Quits: pseudoku (quassel@4133B1A1.FE7DDF00.520CDC98.IP) (Ping timeout)
[17:25:26] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[17:26:23] *** Joins: mr_evil (Mibbit@18E94BFD.C0CAE658.DFAB1F33.IP)
[17:27:17] <jld> Speaking of silly code generation: Do we know if it's significant that Some(17) is an actual function call that has to be always-inline'd away?
[17:27:31] <jld> (And every other tuple-like variant/struct.)
[17:27:57] <pcwalton> jld: it might be significant
[17:29:11] *** Joins: pseudoku (quassel@909F9CCF.5FE01038.C28326FD.IP)
[17:29:16] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[17:29:28] <Luqman> i noticed it sometimes means forgetting to handle that case for things like structs. (i.e one issue was drop flag wasn't getting set for newtype structs before)
[17:30:48] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:30:51] <strcat> jld: yes, anything like that is significant
[17:31:01] <strcat> look at the IR clang generates at -O0 compared to us ;p
[17:33:02] <strcat> it doesn't just generate 50x fewer instructions for the same code, it also turns stuff like array init into memsets and strips trivially dead code
[17:33:13] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[17:33:17] *** Joins: eschweic1 (Adium@2557E599.66715431.D25A875A.IP)
[17:33:18] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[17:33:18] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:33:23] <brson> Blei: are you attempting to fix that jemalloc problem?
[17:33:26] <strcat>     int a[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
[17:33:28] <strcat>   call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 40, i32 16, i1 false)
[17:33:31] <strcat> at -O0
[17:33:49] <jld> strcat: Does it still use the strategy of alloca'ing everything and letting mem2reg sort it out?
[17:34:13] <strcat> jld: don't know, but we generate a ridiculous amount of allocas
[17:34:53] <strcat> jld: https://github.com/mozilla/rust/issues/6923 an example
[17:35:15] <strcat> they generate 3 allocas for swap
[17:35:26] <jld> O_O  That is a lot of alloca's.
[17:35:38] <strcat> we generate 46.
[17:36:01] *** Quits: pseudoku (quassel@909F9CCF.5FE01038.C28326FD.IP) (Connection reset by peer)
[17:36:13] <strcat> they also spit out nounwind from the frontend
[17:36:42] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[17:36:57] <strcat> our intrinsic generation strategy is also really bad ;\
[17:37:03] <strcat> they should generally spit out code, not a function
[17:38:45] <jld> So... we have this "datum" thing to abstract out values that we have as an immediate value vs. a pointer.
[17:38:54] *** Joins: pseudoku (quassel@7E4129FC.883997E4.520CDC98.IP)
[17:39:01] <jld> I feel as if that ought to let us not alloca everything.
[17:39:52] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[17:40:51] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[17:41:12] *** jdm is now known as jdm|away
[17:41:56] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[17:42:05] *** Quits: pseudoku (quassel@7E4129FC.883997E4.520CDC98.IP) (Ping timeout)
[17:42:31] *** Quits: k00mi (koomi@moz-543186DC.pools.arcor-ip.net) (Quit: WeeChat 0.4.1)
[17:42:35] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[17:42:37] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[17:42:41] <jld> But also, if we're doing intrinsics as always-inline functions, the same way as tuple-like constructors, that'd also be Not Helping.
[17:43:03] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[17:43:19] * jld is still kind of stunned by the wall of alloca's and trying to make sense of it.
[17:44:07] <strcat> jld: I think we should strip every single always inline in the codebase anyway
[17:44:12] <doener> jld: make sure to use --passes ""
[17:44:20] <strcat> because of how ridiculous our IR is, it's *always* a bad thing at no-opt
[17:44:36] <doener> jld: the inlining that happens otherwise makes things infinitely worse to read
[17:44:43] <strcat> our functions are never small enough that they should inlined without opt passes
[17:44:48] *** Joins: roo (Mibbit@moz-F3EBFE77.dynamic.ip.windstream.net)
[17:44:52] <strcat> unless they're super trivial...
[17:45:32] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[17:45:40] <doener> strcat: the always inliner is called at opt-level 0
[17:45:47] <strcat> I know
[17:45:56] <strcat> and it makes huge amounts of code bloat
[17:45:59] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:46:05] <doener> yup
[17:46:13] <strcat> because we have multi-kilobyte always inline functions
[17:46:34] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[17:47:02] <strcat> fn foo(x: &mut int) { *x = 10; }
[17:47:06] <jld> Is the hugeness of the always-inline functions necessary, or a symptom of other simplistic codegen things like the use of alloca?
[17:47:21] <strcat> -> http://ix.io/6gg
[17:47:25] <strcat> jld: our codegen just sucks overall
[17:47:34] *** Joins: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de)
[17:47:51] <strcat> clang doesn't even output that function because it's dead, but if I force it to...
[17:48:48] <strcat>  %1 = alloca i32*, align 8
[17:48:51] <strcat>   store i32* %x, i32** %1, align 8
[17:48:53] <strcat>   %2 = load i32** %1, align 8
[17:48:55] <strcat>   store i32 5, i32* %2, align 4
[17:48:57] <strcat>   ret void
[17:49:16] <strcat> no labels, 1 alloca
[17:49:28] <jld> Wasn't there a change to not do the `alloca {}`?
[17:49:41] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[17:49:44] <nmatsakis> jld: in my branch, I have given names to all allocas,
[17:49:50] <nmatsakis> jld: this helps with reading the generated code but,
[17:49:58] <nmatsakis> jld: more importantly, also gives you a clue as to WHO created it,
[17:50:09] <nmatsakis> jld: so one of the things I had hoped to do a bit of was seeing how we can remove them.
[17:50:12] <doener> I tried to eliminate the alloca/Load/Store sequence for functions returning Nil
[17:50:28] *** Quits: vmx (vmx@moz-49FC0C93.dip0.t-ipconnect.de) (Quit: Leaving)
[17:50:32] <nmatsakis> jld: for example we generate some rather unnecessary allocas on argument passing
[17:50:38] <nmatsakis> sometimes it takes some shuffling to get rid of them though
[17:50:42] <strcat> we need a lint check for non-pub functions that aren't called
[17:50:46] <doener> but that kills TCO, unless you convert use void instead of {}, and I didn't get to do that, yet
[17:50:53] <doener> s/convert//
[17:50:58] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[17:51:07] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:51:25] <jld> doener: ...oh, because you wind up returning a different {} than the recursive call, so LLVM doesn't recognize it as tail recursive?
[17:51:51] <doener> yes. It only recognizes return value pass-through and void
[17:51:54] <strcat> also, -Z lint-llvm ;p
[17:52:26] * strcat thinks we should flip it on by default
[17:53:06] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[17:53:11] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[17:53:11] *** Quits: laci (Mibbit@moz-319388CD.catv.broadband.hu) (Quit: http://www.mibbit.com ajax IRC Client)
[17:53:39] <brson> strcat: i agree
[17:53:48] <brson> strcat: are you fixing the lint errors?
[17:54:08] <brson> is anybody trying to fix the jemalloc problem Blei identified?
[17:54:11] <strcat> brson: not atm, I fixed a few when I touched the memset/align stuff
[17:54:16] <strcat> there are a *lot* :(
[17:54:18] <doener> d'oh... I've been wondering about really strange compile errors... Reason: Running make in two terminals in the same working tree, instead of different ones...
[17:54:27] <strcat> like, it will spew out 200k undef errors atm
[17:54:36] <doener> brson: I'm trying something, but it's just a wild guess...
[17:54:52] <strcat> 200k isn't actually an exaggeration, doing x = ~5 is 4 cases undef behaviour
[17:54:55] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[17:54:57] <strcat> cases of*
[17:55:17] <doener> brson: I moved the stack_reset stuff out of the catch block. I think freeing the exception _after_ resetting the stack might be a bad idea. But I'm really clueless and it's just a gut feeling
[17:56:01] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[17:56:19] *** Joins: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP)
[17:56:19] *** ChanServ sets mode: +o pcwalton
[17:56:21] <strcat> brson: our drop glue relies on dozens of cases of undef behaviour so we have no guarantee that any of it compiles to valid code :\
[17:56:31] <strcat> LLVM optimizations could remove all our drop glue if they wanted
[17:56:46] <strcat> they just don't happen to break it (much?) with our current LLVM revision
[17:56:48] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[17:56:50] *** Quits: brendan (brendaneic@moz-8AD662B6.sub-70-197-4.myvzw.com) (Quit: brendan)
[17:56:58] <strcat> but who knows how many of the phantom failures are from that ;\
[17:56:59] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[17:57:25] <strcat> that's why it wasn't inlining glue.... I'm sure there are worse symptoms
[17:58:07] *** Joins: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net)
[17:58:15] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[17:59:43] *** Joins: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP)
[18:00:33] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[18:00:46] *** Quits: fabiand (fabiand@moz-4FA43672.adsl.alicedsl.de) (Quit: Verlassend)
[18:00:58] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Ping timeout)
[18:00:58] <strcat> http://ix.io/6gh and there's that. (let x = ~5)
[18:01:29] *** Quits: lucian_ (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[18:01:55] <doener> ouch, why are the transmute calls bitcasted? I thought I checked those when I fixed the glue
[18:02:57] *** Joins: tjc (tjc@6902864.17C2F9C.163DC5C6.IP)
[18:02:57] *** ChanServ sets mode: +o tjc
[18:03:00] <strcat> doener: dunno :(
[18:03:03] <brson> strcat: ah, I didn't consider that the exception itself needed to be freed
[18:03:15] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[18:03:27] <doener> brson: did you mean me?
[18:03:50] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[18:04:18] <brson> doener: yes, sory
[18:04:34] <doener> no problem, just wondered whether I missed something
[18:05:12] <brson> doener: I suspect that changing where the stack limit is reset won't change anything though
[18:05:15] *** Joins: koomi (koomi@moz-B2B8B6D1.superkabel.de)
[18:05:34] <brson> doener: is the exception freed automatically when the catch block goes out of scope?
[18:05:56] <nmatsakis> bblum: brson: when I spawn a new task with task::spawn, is it placed into a fresh taskset by default?
[18:05:58] <doener> brson: the __cxa_end_catch call right after the stack reset does it
[18:06:08] <bblum> nmatsakis: you mean in terms of failure?
[18:06:16] <nmatsakis> bblum: I mean is there a fresh taskset object
[18:06:20] <doener> brson: but yeah, no luck, just got a dead bird
[18:06:25] <bblum> uhh
[18:06:33] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[18:06:35] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:06:36] <nmatsakis> bblum: trying to trace down a problem with my code, if you don't recall off top of your head I can read into it some
[18:06:57] <brson> doener: we might need that __cxa_end_catch call (and the later call to free) to be invoked on the C stack, in cleanup_task
[18:06:59] <bblum> nmatsakis: i see
[18:07:09] <brson> doener: maybe we can open-code the exception handling ...
[18:07:11] <bblum> i was confused why you were asking about internal implementation details :P
[18:07:22] <pcwalton> jld: in general always alloca-ing is a good thing
[18:07:26] <pcwalton> we should be careful about removing that
[18:07:29] <bblum> nmatsakis: no, you should use task::spawn_unlinked, or spawn_supervised
[18:07:36] <brson> are these canary deaths only happening on linux, where our red zone is small?
[18:07:37] <pcwalton> if you lower values immediately to SSA form then you will lose debug info
[18:07:43] <doener> brson: I've heard the term before, but what does "open-code" actually mean?
[18:07:57] <pcwalton> sabre cautioned us against trying to do that
[18:08:06] <brson> doener: write out the calls to the unwinding functions by hand instead of using try/catch
[18:08:06] <nmatsakis> bblum: sorry, what I mean is, trying to track down a problem with my *patch* ---
[18:08:25] <nmatsakis> bblum: ---and in this test case, it is getting assertion failures because the task is not found in the task set
[18:08:31] <brson> doener: open-code just means to write out the guts of an abstraction
[18:08:32] <nmatsakis> bblum: and I'm trying to figure out what's going on :)
[18:08:36] <brson> code duplication
[18:08:42] <bblum> nmatsakis: also, if you want to use the ancestor_list, you have to use spawn_supervised
[18:08:46] *** jdm|away is now known as jdm
[18:09:03] <doener> brson: ah, ok, thanks
[18:09:04] <Blei> brson: no, sorry, i was having dinner
[18:09:13] <strcat> brson: they happen even when I use RUST_MIN_STACK=5000000, they are just rarer ;\
[18:09:17] <Blei> i'm not sure how to fix it XD needs mor diagnosing
[18:09:51] <brson> strcat: are those definitely the same cause?
[18:10:02] *** Joins: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com)
[18:10:08] <strcat> brson: likely, they happen during compile-fail and report a stack canary was wiped out
[18:10:16] <strcat> I suspect it's related to fast_ffi
[18:10:24] <Blei> yeah, it's always compile fail
[18:10:26] <pcwalton> strcat: jld: we should make a concrete list of bad codegen problems
[18:10:47] <pcwalton> it's clear we're generating too much code but it's not clear in my mind what exactly we're doing wrong, other than bad drop glue
[18:11:24] <nmatsakis> pcwalton: this is where that change in my patch comes in handy, you can at least identify the source of the myriad allocas we produce...
[18:11:33] <pcwalton> oh, nice
[18:11:36] <Blei> so, again, just to make sure: are rust stack segments ever freed by directly calling free() instead of destroy_*_stack()
[18:11:47] <nmatsakis> pcwalton: if only I could figure out why it causes rustc-stage2 to parse incorrectly ;)
[18:11:54] *** Quits: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[18:12:47] <brson> Blei: no
[18:13:08] <Blei> brson: ok, thanks
[18:14:09] <mark_edward> when is it planned for traits to be fixed? specifically inheritance?
[18:15:00] <brson> does reverting jemalloc fix the canary problems?
[18:16:25] <brson> I'll try
[18:16:38] <jld> pcwalton: Seems to me that, if we're (mostly) not otherwise optimizing, all we'd lose are values after their lifetimes end.
[18:17:37] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Ping timeout)
[18:17:39] <jld> pcwalton: Though that does vex people occasionally -- I saw this in a previous life with `gcc -O1` as the thing for debug builds.
[18:18:09] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[18:19:24] <jld> pcwalton: I speculated about working around that by adding a synthetic use of local variables whenever they'd go out of scope, because it'd still be less bad than -O0, but not exactly trivial I guess.
[18:19:36] <pcwalton> yeah
[18:19:51] *** Quits: eschweic1 (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:20:03] <Blei> brson: what platform are you on? if linux 64bit, i could upload my mprotect patch
[18:20:16] <jld> I mean... I don't know how much we can do about the wall of alloca in the util::swap issue if we want all named variables to live in memory (before mem2reg).
[18:20:42] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[18:20:56] <strcat> jld: why do we want it, but the clang devs don't want it?
[18:21:03] <strcat> there can't actually be that many named variables
[18:21:18] <strcat> fn foo(x: &mut) { *x = 5 } isn't 1 alloca
[18:21:22] <strcat> it is in clang
[18:21:28] <jld> True.
[18:22:00] <brson> Blei: linux 64. what does your mprotect patch do?
[18:22:15] <Amanieu> regarding default methods, would it be reasonable to allow a trait to define a default implementation of a supertrait method?
[18:22:53] <sully> hmmmmmm.
[18:22:58] <MaikKlein> any news on default methods for 0.7
[18:22:59] <MaikKlein> ?
[18:23:03] *** Parts: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Leaving)
[18:23:08] <Blei> brson: move the canary into its own page and calling mprotect on it to cause segfaults when it is overwritten
[18:23:10] *** Joins: dualhbridge (dad@moz-EC9F5CE0.public.wayport.net)
[18:23:18] <Blei> thus creating the backtraces you saw
[18:23:21] *** Parts: dualhbridge (dad@moz-EC9F5CE0.public.wayport.net) ()
[18:23:23] <sully> I am making steady progress on default methods
[18:23:26] <strcat> or we could just not use segmented stacks ;p
[18:23:35] <sully> but I also haven't paid much attention to release considerations
[18:23:47] <brson> Blei: can you link the backtraces again? I didn't see them
[18:24:20] <Blei> brson: https://gist.github.com/Blei/5807181
[18:24:23] <brson> thanks
[18:24:46] <strcat> that looks like a double-free
[18:24:55] <strcat> jemalloc doesn't have the same double-free guards as glibc
[18:25:13] * strcat shrugs
[18:27:09] *** Quits: skchrko_ (sk@61A494B3.BA40E8A.AAC02D62.IP) (Ping timeout)
[18:27:19] <Amanieu> sully: the idea is that you could define a Widget trait which has a draw() method, and a ButtonWidget which provides a default implementation of draw()
[18:27:35] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:27:36] <Blei> yeah, double free or dangling pointer/stack
[18:27:45] <Blei> or (very unlikely) a bug in jemalloc
[18:28:03] <Amanieu> sully: though there might be a way to do this using generic impls, I'm not too familiar with them :)
[18:29:43] <strcat> wouldn't ButtonWidget be an impl of Widget?
[18:30:06] *** Quits: carllerche (carllerche@moz-CDE5367B.dsl.static.sonic.net) (Quit: carllerche)
[18:30:19] <Amanieu> well I'm thinking of ButtonWidget being another trait
[18:30:30] <Amanieu> and you have different implementations of it
[18:30:42] <Amanieu> (ok, it's a terrible example, sorry)
[18:32:02] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[18:32:11] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:33:18] <Amanieu> then again you could do this: impl<T: ButtonWidget> Widget for T {...}
[18:33:40] <Amanieu> but then the compiler will complain if you try to implement Widget for some other type
[18:34:56] *** Joins: blitter (blitter@moz-FB45689C.dyn.centurytel.net)
[18:35:26] <tikue> rusti: match [1, 2, 3, 4, 5] { [a, ..b, c] => b, _ => 0 }
[18:35:27] -rusti- <anon>:9:62: 9:63 error: mismatched types: expected `&[<VI4>]` but found `<VI5>` (expected vector but found integral variable)
[18:35:27] -rusti- <anon>:9     let r = {  match [1, 2, 3, 4, 5] { [a, ..b, c] => b, _ => 0 }
[18:35:27] -rusti-                                                                        ^
[18:35:27] -rusti- error: aborting due to previous error
[18:35:27] -rusti- application terminated with error code 101
[18:36:16] <brson> https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-06-18
[18:36:20] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[18:36:25] <graydon> brson: thanks
[18:37:16] <tikue> rusti: match [1, 2, 3, 4, 5] { [a, ..b, c] => b, _ => [] }
[18:37:16] -rusti- <anon>:9:62: 9:64 error: mismatched types: expected `&[<VI4>]` but found `[<V10>, .. 0]` ([] storage differs: expected & but found 0)
[18:37:16] -rusti- <anon>:9     let r = {  match [1, 2, 3, 4, 5] { [a, ..b, c] => b, _ => [] }
[18:37:16] -rusti-                                                                        ^~
[18:37:17] -rusti- error: aborting due to previous error
[18:37:17] -rusti- application terminated with error code 101
[18:38:19] <Eridius> huh, you can use match to get subsets of a vector? that's interesting
[18:38:33] <tikue> Eridius: allegedly. not sure how thogh
[18:38:39] *** Joins: untothebreach (paul@15A17709.47300931.30F15291.IP)
[18:38:48] <Eridius> rusti: match [1,2,3,4,5] { [a, ..b, c] => b[0], _ => 10 }
[18:38:50] -rusti- 2
[18:39:15] <Eridius> match ([1,2,3,4,5],[]
[18:39:17] <strcat> Eridius: it isn't smart enough to realize fixed-size vector patterns can be irrefutable though
[18:39:36] <bstrie> not yet, anyway
[18:39:38] <Eridius> rusti match ([1,2,3,4,5],[]) { ([a, ..b, c], _) => b, (_,z) => z }
[18:39:44] <Eridius> rusti: match ([1,2,3,4,5],[]) { ([a, ..b, c], _) => b, (_,z) => z }
[18:39:45] -rusti- <anon>:9:72: 9:73 error: mismatched types: expected `&[<VI4>]` but found `[<V10>, .. 0]` ([] storage differs: expected & but found 0)
[18:39:45] -rusti- <anon>:9     let r = {  match ([1,2,3,4,5],[]) { ([a, ..b, c], _) => b, (_,z) => z }
[18:39:45] -rusti-                                                                                  ^
[18:39:45] -rusti- error: aborting due to previous error
[18:39:46] -rusti- application terminated with error code 101
[18:40:03] <Eridius> pfft it should slice that for me
[18:40:07] <Eridius> rusti: match ([1,2,3,4,5],[]) { ([a, ..b, c], _) => b, (_,z) => z.slice(0,0) }
[18:40:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZEAH
[18:40:13] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Ping timeout)
[18:40:30] <Eridius> actually returning b alone should also fail
[18:40:40] <tikue> rusti: match [1, 2, 3, 4, 5] { [a, ..b, c] => fmt!("%?", b), _ => ~"" }
[18:40:41] -rusti- ~"&[2, 3, 4]"
[18:40:51] <Eridius> rusti: match [1,2,3,4,5] { [a, ..b, c] => b.to_owned(), _ => ~[] }
[18:40:52] -rusti- ~[2, 3, 4]
[18:41:05] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[18:41:13] <tikue> nice
[18:42:47] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Connection reset by peer)
[18:43:01] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[18:43:27] <mark_edward> does `&mut int` mean reference to a mutable int or mutable reference to an int?
[18:43:45] <strcat> it means the memory the reference points at is mutable
[18:43:59] <strcat> the only place it means a variable is mutable is when it's on something like 'let'
[18:44:57] <mark_edward> rusti:  let r: &mut int = 5; *r -= 2; println(r.to_str());
[18:44:57] -rusti- <anon>:9:34: 9:35 error: mismatched types: expected `&mut int` but found `<VI0>` (expected &-ptr but found integral variable)
[18:44:57] -rusti- <anon>:9     let r = {   let r: &mut int = 5; *r -= 2; println(r.to_str());
[18:44:58] -rusti-                                            ^
[18:44:58] -rusti- error: aborting due to previous error
[18:44:58] -rusti- application terminated with error code 101
[18:45:09] <mark_edward> rusti: let r: &mut int = &5; *r -= 2; println(r.to_str());
[18:45:10] -rusti- <anon>:9:33: 9:35 error: cannot borrow immutable dereference of & pointer as mutable
[18:45:10] -rusti- <anon>:9     let r = {  let r: &mut int = &5; *r -= 2; println(r.to_str());
[18:45:10] -rusti-                                           ^~
[18:45:10] -rusti- error: aborting due to previous error
[18:45:10] -rusti- application terminated with error code 101
[18:45:18] <mark_edward> ???
[18:45:34] <mark_edward> rusti: let rq &mut int = &5; *rq -= 2; println(rq.to_str());
[18:45:34] -rusti- <anon>:9:22: 9:23 error: expected `;` but found `&`
[18:45:35] -rusti- <anon>:9     let r = {  let rq &mut int = &5; *rq -= 2; println(rq.to_str());
[18:45:35] -rusti-                                ^
[18:45:35] -rusti- application terminated with error code 101
[18:45:45] <mark_edward> rusti: let rq: &mut int = &5; *rq -= 2; println(rq.to_str());
[18:45:46] -rusti- <anon>:9:34: 9:36 error: cannot borrow immutable dereference of & pointer as mutable
[18:45:46] -rusti- <anon>:9     let r = {  let rq: &mut int = &5; *rq -= 2; println(rq.to_str());
[18:45:46] -rusti-                                            ^~
[18:45:46] -rusti- error: aborting due to previous error
[18:45:47] -rusti- application terminated with error code 101
[18:45:57] <mark_edward> what does this mean?
[18:46:13] <strcat> you're trying to coerce & to &mut
[18:46:25] <mark_edward> rusti: let rq: &mut int = &mut 5; *rq -= 2; println(rq.to_str());
[18:46:26] -rusti- 3
[18:46:26] -rusti- ()
[18:46:29] <mark_edward> hm..
[18:46:30] <strcat> rusti: let mut x = 5; let r = &mut x; *r = 10; x
[18:46:30] -rusti- 10
[18:47:03] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Client exited)
[18:47:23] <SiegeLord> What exactly does &mut 5 mean?
[18:47:23] <Blei> huh? an &mut of an rvalue works? i didn't expect that
[18:48:05] <strcat> SiegeLord: a mutable reference to 5
[18:48:32] <strcat> in some cases rvalue lifetimes are enough for it to work
[18:48:40] <SiegeLord> But 5... is immutable
[18:48:40] <strcat> it's not very clever at dealing with them though
[18:48:47] <strcat> no, it's not immutable
[18:48:56] <SiegeLord> Where is it stored then?
[18:49:00] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Ping timeout)
[18:49:00] <strcat> on the stack
[18:49:16] <strcat> rvalues are mutable/moveable
[18:49:18] <SiegeLord> So there's an implicit stack allocation of an integer
[18:49:23] <SiegeLord> That's interesting
[18:49:33] <strcat> foo(bar(5))
[18:49:39] <strcat> there's always implicit stack allocation
[18:49:52] <SiegeLord> Hmm, I guess
[18:49:54] <strcat> it has to push 5 onto the stack and then bar puts the return value on the stack
[18:50:05] <strcat> it will optimize to registers but...
[18:50:17] <strcat> if you want to think about that stuff being on the stack, there's stack allocs everywhere
[18:50:31] <strcat> 2 + 3 + 4
[18:50:36] <strcat> needs somewhere to put the result of 2 + 3
[18:50:44] <SiegeLord> rusti: let a = 5 += 1;
[18:50:46] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/VDVa
[18:51:03] <mark_edward> rusti: struct Point {x:int,y:int} impl Point { fn x_mut<'r>(&'r mut self) -> &'r mut int {&'r mut self.x } } let p: &mut Point = &mut Point {x:1,y:1}; let x = p.x_mut(); x += 4; x
[18:51:06] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/fMcW
[18:51:10] *** Quits: mr_evil (Mibbit@18E94BFD.C0CAE658.DFAB1F33.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:51:10] <strcat> is += actually still around?
[18:51:25] <strcat> rusti: let mut x = 5; x += 2;
[18:51:26] -rusti- ()
[18:51:30] <Eridius> why wouldn't it be?
[18:51:31] <mark_edward> rusti: struct Point {x:int,y:int} impl Point { fn x_mut<'r>(&'r mut self) -> &'r mut int {&'r mut self.x } } let p: &mut Point = &mut Point {x:1,y:1}; let x = p.x_mut(); (*x) += 4; x
[18:51:32] <strcat> guess that didn't land yet
[18:51:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iDfi
[18:51:38] <strcat> Eridius: being removed because it's broken
[18:51:41] <Eridius> broken?
[18:51:42] <strcat> and it should use a trait
[18:51:44] *** Quits: tjc (tjc@6902864.17C2F9C.163DC5C6.IP) (Quit: zzzzzzzzzz)
[18:51:45] <strcat> Eridius: yep, broken
[18:51:47] <Eridius> how so?
[18:51:49] <strcat> evaluates twice
[18:51:58] <Eridius> so fix it!
[18:52:04] <strcat> Eridius: fixing it means removing it
[18:52:07] <strcat> because it uses Add right now
[18:52:07] <Eridius> :(
[18:52:08] <strcat> it shouldn't
[18:52:09] <SiegeLord> let a = (5 = 6);
[18:52:14] <SiegeLord> rusti: let a = (5 = 6);
[18:52:16] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/ajUJ
[18:52:46] <Amanieu> rusti: let mut a = 5; a += a; a
[18:52:47] -rusti- 10
[18:52:54] <mark_edward> I don't understand the error i got
[18:53:14] <Eridius> grr, the inability for task::try to work on my system is seriously impeding my ability to run tests
[18:53:29] <mark_edward> rusti: struct Point {x:int,y:int} impl Point { fn x_mut<'r>(&'r mut self) -> &'r mut int {&'r mut self.x } } let p: &mut Point = &mut Point {x:1,y:1}; let x = p.x_mut(); (*x) += 4; let r: int = *x; r
[18:53:31] -rusti- 5
[18:53:38] <mark_edward> ok...
[18:55:13] <SiegeLord> rusti: 1 = 2;
[18:55:13] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/dPiW
[18:55:22] <SiegeLord> Hmm
[18:55:29] <SiegeLord> So will that be allowed?
[18:57:12] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:57:37] <bstrie> SiegeLord: not sure why, assigning to 1 doesn't make sense
[18:57:56] <SiegeLord> It seems to flow from being able to do &mut 1
[18:58:14] <bstrie> I wouldn't expect `&mut 1 = 2` to work either
[18:58:33] <SiegeLord> rusti: let a = &mut 1; *a = 2
[18:58:34] -rusti- ()
[18:58:45] <SiegeLord> rusti: let a = &mut 1; *a = 2; a
[18:58:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RjBj
[18:58:56] <SiegeLord> rusti: let a = &mut 1; *a = 2; *a
[18:58:58] -rusti- 2
[18:59:14] <bstrie> something something rvalues
[18:59:34] <tikue> not sure how let 1 = 2 follows from that though
[19:00:03] <Blei> rusti: *(&mut 1) = 2;
[19:00:04] -rusti- ()
[19:00:07] <Blei> heh
[19:00:29] <Blei> imo `&mut 1` shouldn't work at all
[19:00:35] <engla> why not
[19:00:54] <Blei> i don't see a reason why it's needed
[19:01:12] <Eridius> in case you need to work with an API that takes a &mut int but don't actually care about the results?
[19:01:13] <Blei> c++ does the same iirc
[19:01:20] <tikue> rusti: *(&mut 1) = 2; *(&mut 1)
[19:01:21] -rusti- 1
[19:01:27] <tikue> don't see a problem
[19:01:32] <Blei> i.e. disallowing non-const references to be filled by rvalues
[19:01:32] <Eridius> same reason you can pass a &(int){3} in C to something
[19:01:35] <engla> it's practical to not need a variable to make a borrowed pointer
[19:01:43] <strcat> Blei: if you want to write temporary variables whenever you use an iterator, that's your choice
[19:01:49] <Eridius> forcing people to say `let mut a = 1; &mut a` is needless
[19:02:18] <Blei> strcat: where would you need that?
[19:02:21] <strcat> without rvalues that can be borrowed as &mut, the new for loop will have to use an lvalue as the expression
[19:02:25] <strcat> Blei: because of how iterators work
[19:02:42] <strcat> iterating uses &mut self
[19:02:46] <Blei> ah, i see
[19:03:15] <strcat> rusti: let xs = [1u, 2, 3]; xs.iter().fold(|a, b| a + b)
[19:03:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/QNjh
[19:04:31] <strcat> rusti: let xs = [1u, 2, 3]; xs.iter().fold(0, |a, b| a + b)
[19:04:31] -rusti- <anon>:9:65: 9:66 error: mismatched types: expected `<VI2>` but found `&uint` (expected &-ptr but found integral variable)
[19:04:31] -rusti- <anon>:9     let r = {  let xs = [1u, 2, 3]; xs.iter().fold(0, |a, b| a + b)
[19:04:32] -rusti-                                                                           ^
[19:04:32] -rusti- error: aborting due to previous error
[19:04:32] -rusti- application terminated with error code 101
[19:04:36] <strcat> rusti: let xs = [1u, 2, 3]; xs.iter().fold(0, |a, b| a + *b)
[19:04:37] -rusti- 6
[19:04:43] <strcat> fold uses &mut self
[19:04:52] <strcat> rusti: let xs = [1u, 2, 3]; xs.iter().chain(xs.iter()).fold(0, |a, b| a + *b)
[19:04:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eMcF
[19:04:59] <strcat> rusti: let xs = [1u, 2, 3]; xs.iter().chain_(xs.iter()).fold(0, |a, b| a + *b)
[19:05:00] -rusti- 12
[19:05:13] <brson> I'm going to push a commit to master that turns off jemalloc
[19:05:34] <mark_edward> why?
[19:05:36] <strcat> brson: isn't that just hiding heap corruption?
[19:05:37] <Blei> brson: yeah, i was about to say that i don't see any canaries without it
[19:05:51] <strcat> I really doubt we've found a jemalloc bug
[19:06:09] <brson> strcat: i'm sure it's not a jemalloc bug
[19:06:15] <brson> but turning off jemalloc makes rust work
[19:06:25] <strcat> brson: it hides heap corruption, it doesn't make it work
[19:06:33] <brson> strcat: why do you say that?
[19:06:46] <strcat> brson: well I assume we're corrupting the heap and hitting one of jemalloc's data structures
[19:06:48] <strcat> or doing a double free
[19:07:08] <strcat> glibc doesn't pack things as much so you're more able to corrupt stuff without hitting something important
[19:07:40] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[19:08:09] <roo> Is there an idiomatic way to organize a rust source tree hierarchically? Everything I have come across organizes itself in a single flat folder per crate for the most part (mostly library bindings though). Ideally, for larger modules, I would like to put submodules in a subdirectory
[19:08:21] <brson> i don't assume that we're corrupting the heap or double freeing. glibc malloc does not like double frees either
[19:08:39] <brson> but it may be the case
[19:09:14] <strcat> brson: does valgrind catch these?
[19:09:34] <strcat> or helgrind
[19:09:49] <bstrie> roo: no idiomatic way that I know of, we're sort muddled wrt file organization right now
[19:10:08] <strcat> brson: imo we should try removing all the fast_ffi annotations because I really suspect that's what it is
[19:10:15] <strcat> and just seeing if that fixes it
[19:10:19] <roo> alright :)
[19:11:25] <Blei> strcat: actually, in the iterator example you could instead make your folds etc. take self instead of &mut self
[19:11:47] <strcat> Blei: then it would require that the iterator can be moved into it
[19:11:53] <strcat> and it also wouldn't work for ones you can break out of
[19:12:04] <strcat> you can break out of a loop and the iterator state has to still be around
[19:12:38] <strcat> rusti: let x = ~5; do 1.times { let y = x }
[19:12:39] <Blei> why wouldn't it be able to be moved? and what do you need the state for after breaking?
[19:12:39] -rusti- <anon>:9:50: 9:51 error: expected `;` but found `}`
[19:12:39] -rusti- <anon>:9     let r = {  let x = ~5; do 1.times { let y = x }
[19:12:39] -rusti-                                                            ^
[19:12:39] -rusti- application terminated with error code 101
[19:12:46] <strcat> rusti: let x = ~5; for 1.times { let y = x }
[19:12:46] -rusti- <anon>:9:51: 9:52 error: expected `;` but found `}`
[19:12:47] -rusti- <anon>:9     let r = {  let x = ~5; for 1.times { let y = x }
[19:12:47] -rusti-                                                             ^
[19:12:47] -rusti- application terminated with error code 101
[19:12:47] *** concrete.mozilla.org sets mode: +M 
[19:12:49] <strcat> rusti: let x = ~5; for 1.times { let y = x; }
[19:12:49] -rusti- <anon>:9:49: 9:50 error: cannot move out of captured outer variable
[19:12:50] -rusti- <anon>:9     let r = {  let x = ~5; for 1.times { let y = x; }
[19:12:50] -rusti-                                                           ^
[19:12:50] -rusti- error: aborting due to previous error
[19:12:53] -rusti- application terminated with error code 101
[19:13:15] <strcat> Blei: you need the state so you can break out of a loop and then continue iterating
[19:13:28] * brson lunch
[19:13:43] <strcat> brson: building with all the fast_ffi annotations gone atm
[19:13:47] *** Joins: Blub\w (wry@moz-159C4DAD.wireless.dyn.drei.com)
[19:15:24] <nmatsakis> ah, that would cause crashes....
[19:15:38] <Blei> well, in that case you have to capture the iterator into a temp variable anyway
[19:15:47] <Blei> but i see your point
[19:16:09] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[19:16:10] <strcat> Blei: not the whole iterator
[19:16:11] <nmatsakis> strcat: so I wrote fn zero_memory<T>(dst: *mut T, count: uint) { set_memory(dst, 0, 1) }
[19:16:17] <Blei> but i still don't understand why you can't move the iterator
[19:16:25] <nmatsakis> strcat: or rather, I wrote set_memory(dst, 0, count) 
[19:16:27] <strcat> Blei: you can't always move things
[19:16:31] <nmatsakis> strcat: and then I was seeing lots of fun errors :)
[19:16:33] <strcat> it can be in a field or you might want to use it in a closure
[19:16:59] <nmatsakis> hmm, why do I even take a count argument
[19:17:46] *** concrete.mozilla.org sets mode: -M 
[19:17:53] <strcat> rusti: let xs = [1, 2, 3, 4, 5]; let mut it = xs.iter().transform(|x| x * 2); for xs.advance |x| { println(x.to_str()); break; }
[19:17:54] -rusti- <anon>:9:135: 9:136 error: failed to find an implementation of trait std::iterator::Iterator<<V58>> for [int, .. 5]
[19:17:54] -rusti- <anon>:9     let r = {  let xs = [1, 2, 3, 4, 5]; let mut it = xs.iter().transform(|x| x * 2); for xs.advance |x| { println(x.to_str()); break; }
[19:17:54] -rusti-                                                                                                                                                 ^
[19:17:54] -rusti- application terminated with error code 101
[19:17:54] <engla> strcat: I'm looking at hashmap iterators right now and I think I know why it hasn't changed yet -- interface changes are tied to the std::container traits. Can I submit just an implementation of hashmap::iter() ? or should I remove each, each_key and so on?
[19:18:00] <Eridius> nmatsakis: because raw pointers don't have a length?
[19:18:04] <engla> (yay moderation mode removed)
[19:18:13] <nmatsakis> Eridius: well, I always want to zero out sys::sizeof::<T>...
[19:18:21] <strcat> nmatsakis: can you do `/mode -f` ?
[19:18:26] <strcat> the flood protection thing is really annoying
[19:18:36] *** nmatsakis sets mode: -f [5c#C5,7j#R5,3k#K5,10m#M5,5n#N5]:10
[19:18:36] *** ChanServ sets mode: +f [5c#C5,7j#R5,3k#K5,10m#M5,5n#N5]:10
[19:18:40] <strcat> ugh ;p
[19:18:45] <nmatsakis> strcat: nope :)
[19:18:51] <Eridius> nmatsakis: whyt not count*sys::sizeof::<T>? What if I'm zeroing a vector of Ts?
[19:18:53] * strcat doesn't know how to deal with that ;p
[19:19:36] <nmatsakis> Eridius: yeah, I could make it take a count. main thing is that I was amused that I mixed up the unit for set_memory (which takes "elements" not "bytes" and hence got a lot of stray writes)
[19:19:44] <strcat> Eridius: set_memory zeroes units of T
[19:20:00] <strcat> if you pass *int and count of 4, it will zero count * size_of::<int>
[19:20:05] *** Quits: koomi (koomi@moz-B2B8B6D1.superkabel.de) (Ping timeout)
[19:20:06] <Eridius> ah
[19:20:27] <strcat> it's faster that way, and it's usually what you actually want so it saves some boilerplate
[19:21:01] <strcat> if you do want byte zeroing, can just 'as *u8'
[19:22:38] <bblum> strcat: something like /msg chanserv set mlock ....
[19:22:46] <bblum> really, /msg chanserv help set mlock
[19:22:50] *** Quits: Amanieu (amanieu@moz-81B25A99.cs.man.ac.uk) (Ping timeout)
[19:23:08] <bblum> but you have to be higher than just ops on the ACL to set mlock
[19:23:14] <mark_edward> can you help something'
[19:23:30] <mark_edward> i'm having an issue with mutability and stuff,
[19:23:42] <mark_edward> the situation is basically exactly this;
[19:23:45] <mark_edward> rusti: struct Point {x:int,y:int} impl Point { fn x_mut<'r>(&'r mut self) -> &'r mut int {&'r mut self.x } } let p: &mut Point = &mut Point {x:1,y:1}; let x = p.x_mut(); (*x) += 4; let r: int = *x; r
[19:23:47] -rusti- 5
[19:23:53] <mark_edward> but it's not working
[19:24:21] <strcat> bblum: is there a meta-channel like #freenode? we can just bug one of them
[19:24:41] <strcat> flood protection is a nice idea but not the current flag ;p
[19:24:58] <strcat> it's too sensitive and setting +M is really annoying
[19:25:07] *** Quits: snearch (snearch@moz-7C4E95C9.pool.mediaways.net) (Quit: Verlassend)
[19:25:22] *** Quits: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[19:26:43] <mark_edward> the code is here: https://github.com/MarkJr94/rust_adventure
[19:27:30] <mark_edward> the relevant files are monster/skeleton.rs and monster/mummy.rs, and i keep getting `error, cant borrow immutable argument as mutable
[19:27:31] *** Joins: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net)
[19:27:46] <bblum> strcat: unknown
[19:28:05] <bblum> depends what irc server software mozilla runs
[19:28:16] <bblum> (whether you could hop over to freenode for help, i mean)
[19:28:49] <strcat> bblum: well I meant finding a server op
[19:29:09] <engla> mark_edward: link to the line this error happens please
[19:29:09] *** Joins: berak (chatzilla@C6E0AF17.3A27401E.16E13E53.IP)
[19:29:33] <bblum> strcat: i mean, just /msg chanserv help set mlock.
[19:29:37] <bblum> it has a help text
[19:30:04] <mark_edward> how do i do that? the lines are 39 in monster/mummy.rs and 45 and 56 in monster/skeleton.rs
[19:30:09] <mark_edward> i'll find out how to link
[19:30:12] <engla> ok
[19:30:12] <strcat> bblum: yeah but does anyone have more than op? graydon?
[19:30:16] <engla> it's ok
[19:30:27] <bblum> strcat: whoever registered the channel
[19:30:43] <strcat> well it doesn't seem like they're here or they'd have &, wouldn't they?
[19:31:01] <strcat> 15:28:46  mozilla  -- | ChanServ (services@mozilla.org):         Founder: graydon
[19:31:04] <strcat> hrm
[19:31:07] <Blei> do &Traits work nowadays?
[19:31:11] <bblum> nah, & is only on some irc servers
[19:31:11] <strcat> Blei: a bit
[19:31:15] <strcat> bblum: ah
[19:31:48] <mark_edward> https://github.com/MarkJr94/rust_adventure/blob/master/monster/mummy.rs#L39, https://github.com/MarkJr94/rust_adventure/blob/master/monster/skeleton.rs#L45, and
[19:31:56] <mark_edward> https://github.com/MarkJr94/rust_adventure/blob/master/monster/skeleton.rs#L56
[19:32:39] <nmatsakis> mark_edward: this is a bug.
[19:32:44] *** Joins: xazax (xazax@moz-D7592A2A.csoma.elte.hu)
[19:32:53] <nmatsakis> mark_edward: the problem is that you are using "&"-objects, and objects are kind of broken right now.
[19:33:21] <mark_edward> :-( is there any estimate on when they will be fixed?
[19:33:24] <nmatsakis> that reminds me that Sodel-the-V was wokring on a patch for that, I've been meaning to follow up with him / take a look at why it doesn't work...
[19:33:40] <nmatsakis> mark_edward: I don't know, I hope soon :(
[19:33:50] <mib_ti14h9> random question: is it possible to have a privately mutable field in an immutable struct? as in, the immutable struct can touch its own mutable field but nothing else can
[19:34:02] *** Joins: jviereck (Adium@moz-D1C14B6F.ethz.ch)
[19:34:58] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[19:35:12] <jedestep> mib_ti14h9: i believe struct fields inherit mutability but you could put a field in a mutable managed box, i.e. struct Foo{ field: @mut Bar }
[19:35:16] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[19:35:55] <steven_is_false> rusti: struct Foo <'self> { priv field: &'self uint }
[19:35:56] -rusti- ()
[19:35:58] <mib_ti14h9> I wanted to avoid using managed boxes in case of concurrency (and hence race conditions)
[19:36:14] <mib_ti14h9> oh hm steven_is_false I'll check that out, thanks
[19:36:16] <steven_is_false> rusti: struct Foo <'self> { priv field: &mut 'self uint }
[19:36:17] -rusti- <anon>:9:53: 9:58 error: expected type, found token LIFETIME({name: 8, ctxt: 0})
[19:36:17] -rusti- <anon>:9     let r = {  struct Foo <'self> { priv field: &mut 'self uint }
[19:36:17] -rusti-                                                               ^~~~~
[19:36:17] -rusti- application terminated with error code 101
[19:36:21] <steven_is_false> rusti: struct Foo <'self> { priv field: &'self mut uint }
[19:36:22] -rusti- ()
[19:36:27] <engla> mib_ti14h9: it's just like std::cell
[19:36:39] <steven_is_false> mib_ti14h9: Right, I wasn't even sure if that would work so experiment a bit.
[19:36:47] <mib_ti14h9> all right, thanks all!
[19:37:23] <strcat> mib_ti14h9: managed boxes are task-local
[19:37:32] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[19:37:34] <strcat> there aren't data races outside of unsafe code
[19:38:42] <mib_ti14h9> strcat ah, all right
[19:38:46] <mib_ti14h9> thank you
[19:38:58] <strcat> you should really just use mutability if you need mutability
[19:39:08] <strcat> @mut and Cell turn mutability errors into dynamic failures instead
[19:39:13] *** Quits: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de) (Ping timeout)
[19:39:19] *** Parts: berak (chatzilla@C6E0AF17.3A27401E.16E13E53.IP) ()
[19:39:22] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[19:39:23] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[19:39:55] <strcat> borrow &mut and & from @mut -> fail, borrow &mut and &mut from @mut -> fail, borrow & or &mut and modify -> fail
[19:40:21] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[19:40:24] <strcat> Cell is pretty much the same thing, it's just less flexible so you're less likely to run into a failure
[19:41:03] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[19:41:10] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[19:41:56] <indutny> hey people
[19:42:05] <indutny> after removing x86_64… folder
[19:42:09] <indutny> build broke down
[19:42:09] <indutny> :(
[19:42:13] <indutny> what can I do now?
[19:43:02] *** Joins: jeltz (andreas@moz-7C6B0B72.tn.glocalnet.net)
[19:43:07] <indutny> ah
[19:43:11] <indutny> simpler to do fresh clone
[19:44:15] <bstrie> yes, that's my usual approach
[19:44:25] <strcat> brson: ping
[19:45:13] <strcat> hrmm
[19:45:16] <engla> strcat: did you see my question about hashmap iterators above?
[19:45:24] <strcat> engla: no, missed it, sec
[19:45:41] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[19:45:45] <strcat> engla: it just hasn't been updated yet
[19:45:48] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[19:45:52] <strcat> removing the internal iterators is hours of work
[19:46:03] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[19:46:19] <engla> I guess. especially fixing the remaining users of std::container
[19:46:25] <strcat> it can be changed to having iter() and mut_value_iter()
[19:46:35] <strcat> it can be changed to having iter() and mut_values_iter()
[19:46:37] <strcat> *
[19:46:47] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[19:46:50] <engla> right, I've implemented it
[19:46:53] <engla> that part is easy
[19:47:06] <engla> :-) then it's all that stuff by porting and removing methods
[19:47:25] <strcat> can just remove the internal iterators from the trait and move them to the type impls
[19:47:29] <strcat> nothing uses the traits
[19:47:35] <strcat> and then remove them one by one
[19:51:20] *** Joins: MidnightFun (huh@moz-F31B7D19.cpe.net.cable.rogers.com)
[19:51:40] *** Joins: zslayton (Mibbit@BF6B2242.269AFE30.6A3AF4D7.IP)
[19:51:48] * MidnightFun Picture of my whore ex-girlfriend naked: http://imagetwist.com/d3b8918upcxy
[19:52:27] * MidnightFun Picture of my whore ex-girlfriend naked: http://imagetwist.com/d3b8918upcxy
[19:52:32] *** Quits: MidnightFun (huh@moz-F31B7D19.cpe.net.cable.rogers.com) (Quit: )
[19:52:38] <indutny> very nice
[19:52:52] *** Joins: koomi (koomi@moz-B2B8B6D1.superkabel.de)
[19:52:58] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[19:53:36] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:55:18] <Eridius> strcat: well crud, I just realized my .move_from() doesn't take the start/end parameters I had intended to add. How does one cancel a r+?
[19:55:30] <strcat> Eridius: I can delete it
[19:55:48] <Eridius> I guess this is what I get for not actually using .move_from in practical code :/
[19:57:00] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[19:57:54] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[19:58:21] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[19:59:56] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[20:01:13] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Quit: Lost terminal)
[20:01:50] *** Joins: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de)
[20:03:41] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Ping timeout)
[20:04:14] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[20:04:51] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[20:05:36] <indutny> hm… probably I've asked it before
[20:05:43] <indutny> but is there any trait for casting things to uint?
[20:05:46] *** Quits: xazax (xazax@moz-D7592A2A.csoma.elte.hu) (Quit: Ex-Chat)
[20:06:18] <cmr> strcat: http://github.com/cmr/rust-bench btw
[20:06:24] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[20:06:40] <cmr> strcat: works well enough that I can do `for file in *.rs; do rust-bench.py $file >> /tmp/data.json; done` in src/test/bench
[20:06:40] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[20:06:51] <indutny> trait Num?
[20:06:57] <indutny> oh
[20:06:59] <indutny> I found one
[20:07:04] <indutny> IntConvertible
[20:07:11] <strcat> so it happens because of #[rust_stack] on the malloc/free upcalls
[20:07:12] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[20:07:16] <indutny> though, its only for ints  :(
[20:07:27] <strcat> although I guess there's no workaround for that
[20:07:28] <Eridius> indutny: can't you say .to_uint on any integral type?
[20:07:35] <indutny> oh
[20:07:36] <indutny> well
[20:07:37] <Eridius> rusti: 3ui.to_uint()
[20:07:39] <indutny> the thing is
[20:07:39] -rusti- <anon>:9:17: 9:18 error: expected `;` or `}` after expression but found `i`
[20:07:39] -rusti- <anon>:9     let r = {  3ui.to_uint()
[20:07:39] -rusti-                           ^
[20:07:39] -rusti- application terminated with error code 101
[20:07:40] *** Joins: eschweic (Adium@43CB6079.66715431.D25A875A.IP)
[20:07:43] <Eridius> oops
[20:07:46] <Eridius> rusti: 3u8.to_uint()
[20:07:48] -rusti- 3
[20:07:53] * strcat doesn't really see the point of using segmented stacks
[20:07:57] <cmr> strcat: the canaries dying?
[20:07:59] <strcat> yep
[20:08:03] <indutny> that I want it to be working with anything
[20:08:07] <indutny> like user supplies type T
[20:08:09] <Eridius> strcat: segmented stacks let you have thousands of them without wasting space
[20:08:11] <indutny> and I cast it to uint
[20:08:14] <strcat> Eridius: not true
[20:08:18] <Eridius> no?
[20:08:19] <cmr> \o/
[20:08:26] <strcat> Eridius: all allocations are lazily allocated page-by-page on linux
[20:08:28] <indutny> rusti: struct S(uint, uint); S(1, 2).to_uint()
[20:08:29] -rusti- <anon>:9:37: 10:5 error: type `main::S` does not implement any method in scope named `to_uint`
[20:08:29] -rusti- <anon>:9     let r = {  struct S(uint, uint); S(1, 2).to_uint()
[20:08:29] -rusti- <anon>:10     }; // to make line comments work
[20:08:29] -rusti- error: aborting due to previous error
[20:08:30] -rusti- application terminated with error code 101
[20:08:32] <Eridius> indutny: if you want `as uint` to work, I'm not aware of any way to do that
[20:08:40] <indutny> no
[20:08:43] <strcat> segmented stacks make you scale less on x86_64 since you're wasting so much time managing stack memory
[20:08:43] <indutny> I just want a trait
[20:08:46] <indutny> like IntConvertible
[20:08:46] <kimundi> strcat: even if having them is pointless on x64 they still need to be supported for x32
[20:08:47] <indutny> but for uint
[20:08:48] <Eridius> strcat: what about other platforms?
[20:08:59] <strcat> Eridius: does anyone need 500k tasks on 32-bit?
[20:09:03] <indutny> its really useful
[20:09:05] <Eridius> sure, why not?
[20:09:05] <strcat> who is running servers on 32-bit OSes?
[20:09:08] <indutny> for smallintmaps
[20:09:11] <indutny> strcat: many people
[20:09:14] <strcat> Eridius: ok, so it can be opt-in
[20:09:20] <kimundi> indutny: There should be NumCast, it's the one that supplies to_uint()
[20:09:25] <indutny> oh
[20:09:26] <indutny> thanks
[20:09:32] <strcat> if you want 500k tasks on 32-bit, you can opt-in to 25%+ slowdowns ;\
[20:09:41] <mib_ti14h9> oh strcat apologies, didn't notice your response; I want the privately mutable fields mutable, but not necessarily the entire struct, for things like internal bookkeeping
[20:09:50] <indutny> thanks
[20:09:53] <Eridius> strcat: opt-in program-wide, or on a per-task basis?
[20:09:55] <strcat> mib_ti14h9: well, you can't really do that
[20:09:56] <indutny> kimundi: its exactly what I'm looking for
[20:10:00] <Eridius> e.g. could the scheduler determine if the task uses segmented stacks?
[20:10:02] <indutny> ok, ttyl
[20:10:19] <strcat> Eridius: probably, but then you still need the stack checks
[20:10:28] <Eridius> mib_ti14h9: I don't know what the context here is but you could use a @mut Foo field, no?
[20:10:29] <mib_ti14h9> strcat: is this a philosophical "can't", or just an operational "can't"?
[20:10:42] <strcat> mib_ti14h9: as in you can't do that without fragile hacks
[20:10:50] <cmr> Who writes maniagnosis?
[20:10:57] <mib_ti14h9> Eridius that would make it work, yes; my only worry is if concurrency might screw things up but apparently they probably won't
[20:11:10] <Eridius> well if you have a @-box then you can't send between tasks
[20:11:19] <kimundi> mib_ti14h9: It's important for safety that a type in an immutable location _is actually immutable_
[20:11:28] <strcat> if it contains @mut it's never *not* mutable
[20:11:30] <mib_ti14h9> strcat by philosophical I mean this is something the language doesn't want? or just that it can't do now?
[20:11:41] <strcat> mib_ti14h9: the language won't/can't do it because it's not memory safe
[20:11:51] <strcat> if it contains Cell or @mut it's inherently mutable without 'mut' exposed
[20:12:00] <strcat> it's non-Freeze
[20:12:10] <strcat> rust is memory safe, that's why
[20:12:24] * strcat shrugs
[20:12:32] <strcat> if you want mutable data, you have to expose mutability
[20:12:37] <SiegeLord> Can't you have a &mut field?
[20:12:44] <strcat> either it has to be stored in a mutable location or the struct has to be inherently mutable
[20:12:48] <Eridius> SiegeLord: if you parameterize your struct with a lifetime
[20:12:50] <mib_ti14h9> eh, I'm playing with these as well as ways around it
[20:12:54] <strcat> SiegeLord: that makes it non-Freeze, i.e. inherently mutable
[20:12:58] <mib_ti14h9> just hoping for an easier way to do bookkeeping
[20:13:07] <SiegeLord> I see
[20:13:11] <strcat> mib_ti14h9: task-local storage
[20:13:13] <SiegeLord> Better than @mut, imo :P
[20:13:21] <mib_ti14h9> I get the memory safety stuff and was hoping to preserve memory safety but still retain internal ease of bookkeeping
[20:13:25] <strcat> SiegeLord: @mut, &mut and Cell all make it non-Freeze
[20:13:29] <mib_ti14h9> right
[20:13:33] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[20:13:38] <strcat> mib_ti14h9: non-Freeze is still memory safe
[20:13:42] <strcat> but it's now always mutable
[20:13:54] <strcat> so you *are* exposing the mutability, more than you would by using mut yourself
[20:14:05] <mib_ti14h9> interesting
[20:14:05] <strcat> it can't be put in Rc or ARC anymore
[20:14:14] <strcat> if you make it non-Freeze
[20:14:16] <mib_ti14h9> right, right
[20:14:28] *** Quits: zslayton (Mibbit@BF6B2242.269AFE30.6A3AF4D7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:14:32] <mib_ti14h9> thanks for everyone's responses!
[20:14:37] <mib_ti14h9> I'll think about this some more
[20:14:37] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[20:14:48] <strcat> mib_ti14h9: if you store the stats in TLS it won't have to be exposed
[20:14:57] <SiegeLord> Is freezing a requirement for immutability?
[20:14:58] <strcat> but TLS is kind of an unsound mess right now. so...
[20:15:10] <mib_ti14h9> lol
[20:15:15] <mib_ti14h9> I'll keep it in mind though!
[20:15:17] <strcat> SiegeLord: either something is immutable, statically freezable (inherited mutability) or inherently mutable
[20:15:23] <strcat> the first two are both Freeze
[20:15:37] <strcat> @mut, Cell, RcMut, RWArc, etc. are non-Freeze
[20:15:44] <strcat> and they all have dynamic failure cases
[20:15:48] <SiegeLord> But you still can't modify fields of a non-mutable struct
[20:16:14] <strcat> if the field is in Cell you can modify it without the struct being somewhere mutable
[20:16:30] <strcat> but that's because the struct is now non-freezable (it's *always* mutable)
[20:16:40] <mib_ti14h9> bleh :P
[20:17:35] *** Joins: tjc (tjc@moz-24060A8E.firstunitarianportland.org)
[20:17:35] *** ChanServ sets mode: +o tjc
[20:17:55] <strcat> we can probably find all of the mutability bugs standing in the way of alias analysis by using some debugging allocator with mprotect
[20:17:57] <SiegeLord> rusti: struct A<'self> { a:int, b:&'self mut int } let a = A{a : 5, b : &mut 5}; a.a = 1; a
[20:17:58] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bBDU
[20:18:06] <strcat> SiegeLord: &mut is non-Const
[20:18:11] <strcat> so anything containing it is non-Const
[20:18:22] <SiegeLord> rusti: struct A<'self> { a:int, b:&'self mut int } let mut i = 5; let a = A{a : 5, b : &mut i}; a.a = 1; a
[20:18:23] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eaMU
[20:18:24] <strcat> and modifying &mut through an & pointer is unsound and will be removed (if it isn't already)
[20:18:42] <cmr> strcat: it would be as easy as an LD_PRELOAD if we didn't statically link in jemalloc :p
[20:18:54] <strcat> cmr: well I don't mean that
[20:19:11] <strcat> I mean we could implement functionality to move frozen things to read-only pages
[20:19:16] <strcat> for debugging
[20:19:18] <cmr> ah
[20:19:30] <SiegeLord> Anyway, ignoring that error... there's still "error: cannot assign to immutable field"
[20:19:36] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[20:19:51] <SiegeLord> I'm not sure what Const/ARC etc are... I still can't assign anything to that struct unless it's created as mut
[20:20:21] *** Joins: zslayton (Mibbit@BF6B2242.269AFE30.6A3AF4D7.IP)
[20:20:32] *** Quits: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP) (Quit: victorporof)
[20:20:33] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[20:20:41] <strcat> SiegeLord: not sure what you're saying
[20:20:46] <strcat> a.a isn't the non-Const field
[20:20:58] <strcat> a.a is Const, a itself isn't Const
[20:21:38] <SiegeLord> What code would highlight that?
[20:21:48] <strcat> rusti: struct Foo { x: @mut int, y: int }; let s = Foo { x: @mut 2, y: 5 }; *s.x = 3; s
[20:21:49] -rusti- {x: @mut 3, y: 5}
[20:21:54] <SiegeLord> There's no way to make a.a not share the immutability of a
[20:22:03] <strcat> SiegeLord: a isn't immutable
[20:22:20] <SiegeLord> Well, how would I make a immutable and a.a mutable?
[20:22:42] <strcat> by making a.a a non-Const thing like @mut
[20:23:05] <strcat> rusti: struct Foo { x: @mut int, y: int }; let s = Foo { x: @mut 2, y: 5 } /* not stored in a mutable location */; *s.x = 3 /* can still mutate */; s
[20:23:07] -rusti- {x: @mut 3, y: 5}
[20:23:16] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[20:23:34] <SiegeLord> You don't mutate x though
[20:23:49] <strcat> x is stored in an immutable location
[20:23:55] <strcat> what it points at isn't
[20:23:57] <SiegeLord> So s is immutable
[20:24:15] <strcat> not really
[20:24:19] <strcat> rusti: struct Foo { x: std::cell::Cell<int> }
[20:24:20] -rusti- ()
[20:24:23] <SiegeLord> I can't reconcile every variable in a struct being stored in an immutable location, but the struct itself is not mutable
[20:24:28] <SiegeLord> *is not immutable
[20:24:33] <Eridius> strcat: ok I've fixed https://github.com/mozilla/rust/pull/7210
[20:24:41] <strcat> SiegeLord: Cell is unboxed
[20:24:46] <strcat> it doesn't do a heap allocation
[20:24:52] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[20:24:58] <strcat> rusti: struct Foo { x: std::cell::Cell<int> } let x = Foo { x: std::cell::Cell::new(5) };
[20:24:59] -rusti- ()
[20:25:07] <strcat> rusti: struct Foo { x: std::cell::Cell<int> } let x = Foo { x: std::cell::Cell::new(5) }; println(fmt!("%?", x))
[20:25:09] -rusti- {x: {value: Some(5)}}
[20:25:09] -rusti- ()
[20:25:23] <SiegeLord> Can you mutate *x.x?
[20:25:32] <SiegeLord> Or whatever the syntax is
[20:25:41] <strcat> rusti: struct Foo { x: std::cell::Cell<int> } let x = Foo { x: std::cell::Cell::new(5) }; println(fmt!("%?", x)); do x.with_mut_ref |y| { *y = 10 }; println(fmt!("%?", x))
[20:25:42] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FOjL
[20:25:56] <brson> strcat: any luck re canaries?
[20:25:56] *** Quits: eschweic (Adium@43CB6079.66715431.D25A875A.IP) (Quit: Leaving.)
[20:25:59] <strcat> rusti: struct Foo { x: std::cell::Cell<int> } let x = Foo { x: std::cell::Cell::new(5) }; println(fmt!("%?", x)); do x.x.with_mut_ref |y| { *y = 10 }; println(fmt!("%?", x))
[20:26:00] -rusti- {x: {value: Some(5)}}
[20:26:00] -rusti- {x: {value: Some(10)}}
[20:26:00] -rusti- ()
[20:26:35] <SiegeLord> Hmm... so where is cell stored then?
[20:26:37] <strcat> brson: I removed fast_ffi and that didn't help, but looking into it more - it's just that we don't have enough room
[20:26:41] <strcat> SiegeLord: in-place
[20:26:48] <strcat> cell isn't boxed
[20:26:52] <SiegeLord> That's surprising
[20:26:52] <strcat> Foo as a whole is non-Const
[20:26:59] <strcat> it's inherently mutable, no matter where it's stored
[20:27:06] <brson> strcat: ok, I'm going to turn off jemalloc for now. feel free to turn it back on if you find a fix
[20:27:06] <strcat> same as when it has @mut or RcMut
[20:27:15] <strcat> brson: well I guess the fix is making the red zone bigger
[20:27:18] <SiegeLord> But Cell has dynamic failures?
[20:27:26] <brson> strcat: I would rather not do that
[20:27:50] <strcat> brson: well... freebsd uses jemalloc by default and we don't really know what allocator libc uses
[20:27:51] <brson> strcat: we already take care to do expensive work off the rust stack in task_start_wrapper
[20:28:05] <strcat> SiegeLord: yes
[20:28:08] <SiegeLord> Hmm, ok
[20:28:32] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:28:32] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/ZW4CoQ
[20:28:32] <ghrust> 13rust/06master 14371a316 15Brian Anderson: Turn off jemalloc
[20:28:32] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:28:38] <strcat> SiegeLord: if you try using with_ref/with_mut_ref inside another with_*
[20:28:46] <strcat> same as @mut borrows but more explicit
[20:29:00] <SiegeLord> I see
[20:29:22] *** Joins: flowsnake_ (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[20:29:25] <strcat> and imo @mut borrows should be that explicit
[20:29:36] <strcat> as long as they're implemented with dynamic freezing
[20:30:46] *** Quits: jviereck (Adium@moz-D1C14B6F.ethz.ch) (Quit: Leaving.)
[20:31:07] <brson> task-perf-one-million is OOMing on linux-32-nopt so I'm going to xfail it
[20:31:11] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[20:31:32] <graydon> ok
[20:31:43] *** Joins: nrubin (nathanaelr@moz-267EC31A.iol.unh.edu)
[20:31:59] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[20:32:04] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:32:04] <ghrust> 01[13rust01] 15graydon merged 06master into 06auto: 02http://git.io/3NGSEg
[20:32:04] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:32:08] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[20:32:08] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/ma0XRw
[20:32:08] <ghrust> 13rust/06master 14303d7bf 15Brian Anderson: test: xfail bench/task-perf-one-million. OOM on 32-bit linux w/o opts
[20:32:08] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[20:32:28] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[20:32:28] <ghrust> 01[13rust01] 15graydon merged 06master into 06auto: 02http://git.io/iaQP7g
[20:32:28] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[20:32:51] *** Quits: tjc (tjc@moz-24060A8E.firstunitarianportland.org) (Quit: zzzzzzzzzz)
[20:33:04] <brson> graydon: what should i look at next re greening master?
[20:33:12] *** Quits: heftig_ (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Quit: Quitting)
[20:33:20] <strcat> brson: I can spawn more pthreads than I can spawn rust tasks so I just don't really see the point ;\
[20:33:21] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[20:33:32] <brson> strcat: of?
[20:33:36] *** Quits: mib_ti14h9 (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:33:37] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[20:33:42] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[20:33:48] <brson> strcat: there's a bug in stack management of green threads right now
[20:33:48] <strcat> brson: segmented stacks
[20:34:17] <brson> https://github.com/mozilla/rust/pull/7111
[20:35:01] <brson> at one point we could spawn 500,000
[20:38:34] <brson> ok, I'm going to look for the deadlock in exttest on 32-bit with opts
[20:40:46] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[20:40:49] *** Quits: dan_johnsin (dan_johnsi@6902762D.11B071D.FB9A45AF.IP) (Quit: Leaving)
[20:41:39] *** Quits: flowsnake_ (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[20:42:10] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[20:43:27] <graydon> brson: 32bit is breaking on something .. fascinating
[20:43:32] *** Quits: Diamond (dick@moz-625C0DAF.ks.ok.cox.net) (Client exited)
[20:43:40] <graydon> it seems to just iloop in the LLVM codegen for libextratest
[20:43:48] <graydon> or deadlock?
[20:43:54] <graydon> I don't think it's deadlocking
[20:43:58] <brson> graydon: oh, i didn't realize it was in compilation
[20:44:00] <graydon> it's spinning on my machine, endlessly
[20:44:00] <brson> weird
[20:44:01] <graydon> post-LLVM
[20:44:04] <graydon> er, post-trans
[20:44:06] <graydon> in LLVM
[20:44:13] <graydon> I'm going to break in it now, have a build
[20:44:45] <graydon> I assume we're generating some pathological code. maybe we turn on LLVM lint and start fixing stuff :)
[20:44:52] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[20:45:08] <brson> is this the last error?
[20:45:20] <brson> i guess bsd is still broke, but maybe the jemalloc revert will fix it
[20:45:22] <strcat> making a bunch of threads makes the load average fun
[20:45:46] <graydon> there might be others
[20:46:26] <brson> i don't see anything left on the bots besides this hang
[20:47:19] <graydon> ok
[20:47:56] <graydon> so .. I'm watching it on perf top
[20:47:58] <strcat>  16:45:43 up 2 days, 13:32,  8 users,  load average: 4342.05, 1240.91, 432.74
[20:48:01] <graydon> it does actually seem to be doing stuff
[20:48:03] <graydon> just real slowly
[20:48:10] *** Quits: nattofriends (tsutsumi@moz-A369A791.warosu.org) (Ping timeout)
[20:48:42] *** Joins: nattofriends (tsutsumi@moz-A369A791.warosu.org)
[20:49:10] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[20:50:06] <graydon> llvm::SmallPtrSetImpl::FindBucketFor
[20:50:11] <graydon> is the innermost, I think
[20:50:57] <graydon> now it's switched to llvm::LazyValueInfo::eraseBlock
[20:51:01] <acrichto> graydon: just fyi I noticed that the *-vg bots were configured with --disable-valgrind instead of the other way around
[20:51:07] <graydon> it does seem to be doing work
[20:51:10] <graydon> acrichto: oh, huh
[20:51:17] <graydon> wrong move! I'll fix
[20:51:50] <graydon> wait, the non-vg ones are also --disable-valgrind, right?
[20:51:57] <strcat> graydon: llvm-lint will help us zap undef behaviour but it won't save us from bloat
[20:51:59] <acrichto> that's what I saw yeah
[20:52:52] <graydon> I wonder if we are accidentally configuring LLVM no-opt when we build no-opt
[20:53:15] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[20:53:32] <graydon> doesn't look like
[20:53:50] <strcat> graydon: we generate pathological amounts of code without optimization passes
[20:54:03] <strcat> and we have force inlining everywhere
[20:54:04] *** Quits: sankha93 (Instantbir@D109B33B.822F35C9.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[20:54:36] <graydon> are you saying no-opt is just likely to take 60 minutes to build this crate on 32bit?
[20:54:42] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:54:50] <strcat> graydon: or more? ;p
[20:54:57] <graydon> oh dear
[20:54:58] <strcat> graydon: we force inline 500+ IR instruction functions into other functions
[20:55:04] <strcat> and then force inline those into other functions...
[20:55:11] <strcat> and then it has to somehow turn that into a binary
[20:55:31] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[20:55:36] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Input/output error)
[20:55:46] <pcwalton> can we make lists of these pathological cases
[20:56:00] <pcwalton> I know our IR is bad but I think it's just down to killing bugs
[20:56:03] <strcat> ~5
[20:56:17] <pcwalton> IMHO trans doesn't need to be rewritten
[20:56:32] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[20:56:40] <strcat> I don't think it needs to be completely rewritten, but it needs a *lot* of work
[20:56:50] *** Quits: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de) (Ping timeout)
[20:56:51] <pcwalton> it just needs bugs fixed
[20:57:00] <strcat> pcwalton: look at the no-opt IR for 'fn main() { let x = ~5; }'
[20:57:17] <pcwalton> that's probably mostly headers, I guess?
[20:57:26] <strcat> pcwalton: no I just mean the main function
[20:57:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:57:32] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[20:57:34] <pcwalton> I mean, the headers on ~ boxes
[20:57:35] <strcat> the glues are bad but I assume they get reused
[20:57:49] <strcat> pcwalton: I don't really think so, I think we compile anything with pointers very strangely
[20:57:51] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[20:57:52] *** Joins: eschweic1 (Adium@2557E599.66715431.D25A875A.IP)
[20:58:15] <strcat> so it's made 4-5x worse by the header, I guess
[20:58:56] * pcwalton wishes he had more time to work on this stuff
[20:59:04] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[20:59:15] <strcat> trying to figure out where it actually goes wrong
[20:59:29] <strcat> it's sane with just some variables and borrowed pointers in a function
[21:01:22] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:01:30] <brson> what's the replacement for str::to_bytes?
[21:01:50] <strcat> graydon: I bet if you just sed inline(always) to inline(hint) it will be much better
[21:01:50] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[21:02:07] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[21:02:10] *** Quits: nrubin (nathanaelr@moz-267EC31A.iol.unh.edu) (Quit: nrubin)
[21:02:13] <cmr> rusti: "foo".iter_bytes().collect::<~[u8]>()
[21:02:14] <graydon> strcat: that is an experiment I'm happy to run here.
[21:02:16] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BXDc
[21:02:19] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:02:47] *** Joins: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:02:47] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Connection reset by peer)
[21:03:02] <strcat> I don't really think force inlining makes sense unless you require it for some weird ABI reason
[21:03:12] <zootm> another new guy question from me: what does &const mean? and if I have a & can I get a &const?
[21:03:17] <brson> what doen #[inline(hint)] to compared to #[inline]?
[21:03:24] <strcat> brson: same thing
[21:03:58] <strcat> 'inline' in C++ is #[inline] in rust
[21:04:31] <strcat> I've never seen __attribute__((always_inline)) widely used
[21:04:41] <kimundi> zootm: it means you can only read the destination through the pointer, but it might get modified by some other place. turning & into &const should be possible I think, but otherway 'round is unsafe
[21:04:46] <cmr> I've never seen it once
[21:05:02] <strcat> inlinehint is a *really* strong hint
[21:05:06] <nano> I saw that attribute in embedded development a few tiems
[21:05:12] <strcat> it basically won't not inline unless it thinks it's pathological
[21:05:15] <zootm> kimundi, any idea what the syntax to do that would be? a guess would be fine :)
[21:05:26] *** Quits: eagen (eagen@8737942B.7A99C13A.B7961A98.IP) (Quit: Leaving)
[21:05:31] <kimundi> zootm:  I think it just coerces
[21:05:46] <zootm> I'm having trouble with it not doing that
[21:05:51] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:05:56] <strcat> gcc/clang even have -Winline to throw a warning if it decides not to inline an #[inline] function
[21:06:01] <kimundi> hmm... then it might not work after all
[21:06:15] <pcwalton> I think nmatsakis and I need to discuss what it takes to get rid of all drop flags
[21:06:22] <pcwalton> it's clear that this is becoming an unacceptable tax
[21:06:26] <zootm> kimundi, in particular I have a &[u8] which I want to pass to str::from_bytes, but that function wants "&const [u8]"
[21:06:34] *** Quits: Palmik (palmik@moz-5CA3F354.pks.muni.cz) (Quit: Lost terminal)
[21:06:44] <strcat> pcwalton: but that move/drop tax exists in C++
[21:06:55] <pcwalton> only in C++11
[21:07:01] <pcwalton> if you use rvalue references and moves
[21:07:12] <pcwalton> which no large software packages are really doing yet
[21:07:26] <kimundi> zootm: Hm, I'm not sure. But I think that particular function is being rewritten in master now, maybe its solved there :P
[21:07:30] <pcwalton> i.e. it's not clear to me that it'll be an acceptable tax for C++ either in the long run
[21:07:40] <strcat> pcwalton: LLVM optimizes out the destructor calls in C++
[21:07:49] <strcat> if you move
[21:07:53] <zootm> zootm, ha, yeah, I think I noticed the signature in the version I had locally is different :)
[21:07:56] <pcwalton> is that LLVM or clang?
[21:08:06] <strcat> pcwalton: well we don't generate code that it can optimize out
[21:08:08] *** Quits: Blub\w (wry@moz-159C4DAD.wireless.dyn.drei.com) (Quit: bb2m)
[21:08:11] <pcwalton> also: why isn't it doing that for us?
[21:08:12] <zootm> kimundi, ^ (not intentionally talking to myself there)
[21:08:14] <strcat> there's an opaque function call to global_heap::free
[21:08:15] <pcwalton> because our drop glue is undefined?
[21:08:20] <strcat> pcwalton: that's one thing
[21:08:23] <strcat> but it can't see 'free'
[21:08:30] <strcat> it needs to be able to see it
[21:08:46] <nmatsakis> pcwalton: I've been talking to bblum  about it
[21:08:54] <strcat> it has no idea what global_heap::free(nullptr) does
[21:09:00] <pcwalton> yeah, ok
[21:09:10] <pcwalton> maybe we should patch LLVM or something to add it to its table of "free-like things"
[21:09:15] <pcwalton> or just call it "operator delete"
[21:09:27] <strcat> well I think in this case we just need #[inline] on that fn
[21:09:31] <doener> strcat: calls to drop_glue should be optimized out now, it the value is moved
[21:09:39] <strcat> doener: how?
[21:09:50] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Ping timeout)
[21:09:50] <pcwalton> nmatsakis: what conclusion have you come to?
[21:09:52] <pcwalton> if any
[21:10:05] *** Joins: flowsnake_ (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[21:10:17] <strcat> global_heap::free isn't readnone/readonly and it's not called free so LLVM assumes it could be sending an email or whatever
[21:10:21] <pcwalton> right
[21:10:36] <cmr> it *should* be sending an email!
[21:10:38] <pcwalton> I understand that, I just think it might be even easier (saves inlining) if it were just called operator delete
[21:10:42] <strcat> To: foo@bar.com Subject: the pointer was null!
[21:10:46] <pcwalton> because last time I read LLVM's code
[21:10:48] <pcwalton> it had a list of functions
[21:10:49] <doener> strcat: https://github.com/mozilla/rust/pull/7154 -- one thing I check with that was that "let x = ~5; let y = x;" only creates a single free call, instead of the two drops it created before
[21:10:51] <nmatsakis> pcwalton: well, first, I think bblum will be working on it, I expect it'll be done in stages --- that is, we can start by just avoiding zeroing in many cases, but keeping the option,
[21:11:02] <pcwalton> that were considered to be "free-like"
[21:11:06] <strcat> doener: yeah, that's a big improvement, but I mean optimizing it out completely
[21:11:07] <pcwalton> and one of them was "operator delete"
[21:11:07] <nmatsakis> pcwalton: the one tricky case I've found is vec::consume()
[21:11:13] <strcat> pcwalton: yep
[21:11:17] <strcat> pcwalton: it's called isFreeCall
[21:11:19] <strcat> easy to look for
[21:11:22] <strcat> we could patch it
[21:11:24] <nmatsakis> pcwalton: though you can implement consume_rev() easily enough, and consume() can be handled by reversing in place and then calling consume_rev
[21:11:35] <pcwalton> or we could just take that lang item and name it "operator delete" so LLVM finds it
[21:12:35] <doener> strcat: hm, I guess I don't see what you mean then
[21:12:50] <strcat> http://llvm.org/docs/doxygen/html/MemoryBuiltins_8cpp_source.html#l00308
[21:13:17] <strcat> pcwalton: ZdlPv ;p - but I assume we can't link against C++ programs then
[21:13:21] <strcat> that'd be bad
[21:13:36] <pcwalton> oh hmm, I guess that's true
[21:14:01] <strcat> it's a one-line function, just needs to be tagged as inline
[21:14:07] <strcat> or we could insert free calls directly for exchange_alloc
[21:14:08] <pcwalton> let's do that then
[21:14:31] <strcat> well actually not one line since it does the atomic integer sub
[21:14:41] <strcat> but it *could* be one line ;p
[21:14:57] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:15:24] <strcat> pcwalton: I don't really understand
[21:15:40] <strcat> I think we have a check for null, than an atomic int operation, then an assert that it's not null, then a free call
[21:16:00] <strcat> it could just be free though...
[21:16:14] <graydon> strcat: is inline(hint) == inlinehint?
[21:16:20] <strcat> graydon: yes
[21:16:30] *** Joins: kemurphy (Mibbit@92AB82D7.E41D1164.61CD561F.IP)
[21:16:32] <graydon> you said it's the same as #[inline]?
[21:16:36] <strcat> graydon: yeah
[21:16:37] <graydon> and this is "really strong"?
[21:16:44] <strcat> graydon: yep, it's 'inline' in C/C++
[21:16:47] * graydon wishes we could let llvm do these choices
[21:16:57] <strcat> it means 'disregard your heuristics, I know better'
[21:17:00] <graydon> it's doing LTO for us. intentionally. is its cost model so wrong?
[21:17:17] <graydon> (should we be feeding it PGO arcs?)
[21:17:19] *** Joins: tjc (tjc@6902864.17C2F9C.163DC5C6.IP)
[21:17:19] *** ChanServ sets mode: +o tjc
[21:17:19] <strcat> graydon: #[inline] makes it inline cross-crate though
[21:17:28] <graydon> aha
[21:17:44] <cmr> You can set the inline hint weight, and we do, at the same place as the optimization passes, wherever that is ;p
[21:18:17] <graydon> so you think its heuristic is good in-crate but we are damaging it by making the #[inline] we add to make things cross-crate inlinable cause inlinehint as well?
[21:18:21] <strcat> graydon: right now if you mark a function as inline, it *has* to be at least inlined into the crate calling it
[21:18:21] *** Quits: tjc (tjc@6902864.17C2F9C.163DC5C6.IP) (Quit: zzzzzzzzzz)
[21:18:35] <strcat> and then LLVM can decide if it wants to inline it to the call locations, but it has a strong hint
[21:18:43] <zootm> kimundi, I think I was slightly misreading the error message; adding a * got rid of my issue. Thanks a lot for your help.
[21:19:00] <strcat> graydon: we ideally need a way for LLVM to either 1) inline or 2) link against the libraryt
[21:19:19] <strcat> right now if you make it inline-able it always gets inlined into every crate calling it
[21:19:25] <graydon> strcat: should that "strong hint" not be present just because we copied it from crate A to crate B?
[21:19:27] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[21:19:56] <graydon> IOW should #[inline] just make a single inline copy in the caller crate and let LLVM decide the rest, hint-free?
[21:20:14] <strcat> graydon: probably not because copying it into the caller crate is already a cost
[21:20:30] <strcat> the way templates work across object files is that clang tags them linkonce_odr
[21:20:32] <strcat> and they are merged
[21:20:36] <graydon> how else would we swing this? LLVM can't give us feedback on "functions it might want to inline", can it?
[21:20:44] <strcat> but I don't know if that can work across libraries
[21:21:31] *** Joins: tjc (tjc@6902864.17C2F9C.163DC5C6.IP)
[21:21:31] *** ChanServ sets mode: +o tjc
[21:21:41] <graydon> huh. I think perhaps linkonce_odr and available_externally are more what we want here
[21:21:47] <graydon> not manual inlining, as we are doing
[21:21:57] <strcat> available_externally
[21:21:59] <strcat>     Globals with “available_externally” linkage are never emitted into the object file corresponding to the LLVM module. They exist to allow inlining and other optimizations to take place given knowledge of the definition of the global, which is known to be somewhere outside the module. Globals with available_externally linkage are allowed to be discarded at will, and are otherwise the same as
[21:22:01] <strcat> linkonce_odr. This linkage type is only allowed on definitions, not declarations.
[21:22:03] <strcat> graydon: yeah
[21:22:19] <graydon> there's no need to re-lower the code if it's not a polymorphic instance
[21:22:25] <graydon> maybe all or most of our inline instances are
[21:22:26] <strcat> graydon: inline hints are useful but usually LLVM knows better
[21:22:28] <graydon> I wish we had stats on this
[21:22:35] <kimundi> Doesn't #[inline(maybe)] exist for 'include this in the metadata section, but don't set the inline hint' ?
[21:22:49] <strcat> kimundi: inline(maybe) would still force-inline it into the caller crate
[21:22:52] <strcat> even if it's 100MiB
[21:23:14] <kimundi> why would it force inlien it? (what does that even mean)
[21:23:21] *** Quits: kemurphy (Mibbit@92AB82D7.E41D1164.61CD561F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:23:28] <jld> graydon: By any chance, we testing 32bit-to-64bit cross compiling after the buildbot expansion?
[21:23:58] <graydon> jld: no, but I can try to add that if you like
[21:24:53] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[21:25:05] <strcat> graydon: anyway it's just very wrong right now :(
[21:25:13] <jld> graydon: I don't know how big a deal it is.  Currently it's distinguishable from 64-to-64 because enum discriminants will be truncated to 32 bits.
[21:25:25] <strcat> graydon: our generics too, because they're instantiated for every crate and not merged
[21:25:42] <jld> graydon: Also, I think [T, ..0] will be equal to [T, ..(1<<32)], etc.
[21:25:45] <strcat> C++11 added the ability to pre-instantiate some 
[21:25:49] <strcat> and link against them
[21:26:00] <strcat> like HashMap<int, int>
[21:26:03] <graydon> strcat: yeah
[21:26:28] <graydon> one thing at a time :)
[21:27:00] <graydon> so with this perl bulk edit I just did
[21:27:04] <graydon> from inline(always) to inline(hint)
[21:27:11] <graydon> this didn't likely reduce the amount of inlining, did it?
[21:27:13] <graydon> or ..
[21:27:19] <strcat> graydon: it did, at no-opt
[21:27:24] <graydon> ah
[21:27:32] <graydon> what about opt?
[21:27:33] <jld> graydon: There's a bunch of host-int/target-int confusion, and I gave up trying to untangle all of it because it gets into metadata, but discriminants I have fixes for (which hopefully haven't rotted too much) as preparation for the enum size changes.
[21:27:37] <strcat> graydon: forceinline always runs, it's more about semantics (this function is *not* a symbol) than perf
[21:27:46] <strcat> graydon: with opt, it probably inlines everything with #[inline(hint)]
[21:27:49] <strcat> unless it's really, really huge
[21:28:04] <strcat> or ones we bitcast in invalid ways (but forcing inlining wouldn't work there either)
[21:28:23] <jld> graydon: So I was thinking, it'd be a shame to submit a change (esp. for something that subtle) with no tests, but there really wasn't a good way to.  And then I saw the announcement earlier about the new auto-tests including some cross configurations.
[21:28:38] <jld> graydon: (This may be more information than you actually wanted to know.)
[21:28:43] <graydon> jld: it's helpful!
[21:29:12] <graydon> I don't actually know how to provoke a 32-to-64 cross. I guess just --build with i686 and --host with x86_64?
[21:29:44] <strcat> graydon: I think the only opt pass that runs at no-opt is the one for alwaysinline things
[21:30:01] <strcat> so... it's pretty much guaranteed to be a bad thing
[21:30:11] <strcat> since we generate poor IR in most cases
[21:30:21] <jld> graydon: A build with both i686 and x86_64 as targets should wind up with a makefile target somewhere that makes an i686-hosted compiler that can target x86_64.
[21:30:46] *** Quits: jyeo (user@F2D29657.F60B0462.67AC9B1.IP) (Input/output error)
[21:31:08] *** Quits: tjc (tjc@6902864.17C2F9C.163DC5C6.IP) (Quit: zzzzzzzzzz)
[21:31:17] <graydon> jld: so will http://buildbot.rust-lang.org/builders/auto-linux-all-opt/builds/1/steps/configure/logs/stdio build the compiler you want?
[21:32:37] <graydon> if so, that's part of the new configs. though I don't think the 64bit testsuite it builds will be from the 32bit host compiler.
[21:32:47] <graydon> (guessing)
[21:33:07] <jld> graydon: ...I think so?  I confess I don't understand the build process hugely well, and it's been a while since I actually tried to observe things going wrong.
[21:33:19] <graydon> ok
[21:33:46] <graydon> let's try for now and see if we can get it working and if you don't feel there's quite the right coverage for something you want to land, ask and I'll try to add more
[21:33:51] <jld> graydon: Oh, hm.  If it doesn't build the tests for each (host,target) pair then that won't get it.
[21:34:01] <graydon> ah
[21:34:17] <graydon> I would ask brian about that. I don't know which one it's using for which. maybe it does all 4.
[21:34:57] <jld> graydon: The other thing is, I don't know how valuable running all possible tests is, in general.
[21:35:01] <graydon> brson: is an all-hosts build going to do 32->64, 32->32, 64->64, and 64->32 testing?
[21:35:17] <graydon> jld: what else would we do? got no fuzzer that works presently :(
[21:35:26] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[21:35:36] <graydon> ooh
[21:35:40] <jld> Test for all possible combinations, I mean.
[21:35:43] <brson> graydon: our all-hosts build only does 2 of the four possible combos. checking which those are
[21:35:56] <graydon> strcat: the change you suggested un-wedges the 32bit build (now actually completes)
[21:36:02] <strcat> graydon: \o/
[21:36:12] <graydon> weird since this is an opt build
[21:36:17] <graydon> just 32bit
[21:36:34] <strcat> graydon: well, the force inlining is probably a bad choice in most places
[21:36:37] <strcat> LLVM really knows better
[21:36:50] <strcat> it has trouble handling our closures though
[21:36:59] <graydon> still gets a failure in complex::test::test_norm
[21:37:13] <graydon> I bet this is the 32bit-double-passing-clobber bug
[21:37:36] <strcat> I think we need to tag all the trait/closure function pointers as llvm.invariant but I don't know how to do that
[21:37:56] <jld> graydon: I mean, if it's going to be increasing the time changes spend in the build queue, that does have an effect on developer productivity.
[21:38:10] <brson> graydon: it looks like our all-hosts build tests 64->64 and 64->32 but doesn't test the 32-bit compiler at all ...
[21:38:20] <graydon> brson: ok
[21:38:41] <graydon> the 32bit compiler is being tested on its own in a different queue
[21:38:44] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[21:38:51] <graydon> just not the one cross-built
[21:39:42] * graydon suggests checkin involves every compiler completing a cross-bootstrap round trip :)
[21:40:24] <graydon> meanwhile, shall I push this inline(always) => inline(hint) change?
[21:40:24] <seth> do i recall correctly that the copy keyword is going away?
[21:40:37] <jld> ...but if graydon is hoisting the "Test ALL the things!" flag anyway I won't exactly complain about having coverage for my pet bugs.
[21:40:40] <cmr> graydon: does it hurt performance?
[21:40:45] <graydon> brson pcwalton nmatsakis strcat: ?
[21:40:59] <pcwalton> f5ne by 0e
[21:41:05] <cmr> I remember aatch testing it a while ago and saying performance went up
[21:41:08] <graydon> cmr: I have no idea. lemme, uh .. I can try comparing against stage0 to get a rough estimate
[21:41:16] <graydon> cmr: as in, it got better?
[21:41:19] <cmr> graydon: yes
[21:41:19] <Eridius> seth: Copy is being replaced with Clone
[21:41:33] <pcwalton> err
[21:41:34] <strcat> graydon: I think you should push it
[21:41:35] <pcwalton> fine by me
[21:41:36] <pcwalton> num lock
[21:41:44] <Eridius> pcwalton: you on a laptop?
[21:41:54] <jld> There's one place where I #[inline(always)]'ed a function because the entire body should be constant-folded -- but it might not be if we're doing too much alloca.
[21:41:55] <nmatsakis> graydon: please do? I'm always replacing inline(always) with inline(hint) locally just so that I can read the generated llvm :)
[21:42:01] <strcat> graydon: we should be really careful about using it
[21:42:02] <pcwalton> Eridius: the kinesis freestyle 2 has laptop-like Fn
[21:42:28] <nmatsakis> seth: yes plan is to remove copy keyword
[21:42:28] <strcat> jld: but the thing is, if it's not huge then inlinehint will make it get inlined
[21:42:42] <strcat> jld: forcing inlining only really does anything at -O0
[21:42:54] <strcat> or overrides the compiler's good sense
[21:43:01] <brson> graydon: can you use #[inline] instead of #[inline(hint)], just as a style preference?
[21:43:04] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[21:43:05] <brson> but yes, please push
[21:43:11] <brson> inline(always) considered harmful
[21:43:25] <seth> nmatsakis: so is best practice right now to use .clone() all the time?
[21:43:35] <graydon> oh, hm. it also seems like it deadlocks if I run it under RUST_THREADS=1
[21:43:48] <jld> strcat: sys::nonzero_size_of.  I was expecting/hoping that inlining it at -O0 would make things less bad, but I may have been wrong.
[21:43:48] <nmatsakis> seth: most forward-compatible
[21:43:54] <seth> nmatsakis: cool, thanks
[21:44:12] <graydon> brson: sure. what should I do about the remaining complex::test::test_norm failure?
[21:44:28] <graydon> turn it off? nmatsakis you had a fix for edx clobbering, was this related?
[21:44:30] <brson> graydon: oh, I didn't see that. what configuration is it on?
[21:44:43] <graydon> brson: it's the next thing that happens when stdtest builds :)
[21:45:06] <brson> graydon: i think ignoring tests for complex numbers is fine. they're not so important
[21:45:22] <brson> whatever it takes to get master green
[21:45:24] <graydon> can we do a target-specific cfg ignore? hmm
[21:45:30] <nmatsakis> graydon: unsure, I never saw that faliure, but it may well be related
[21:45:41] <brson> #[ignore(target_arch ="x86")] maybe
[21:45:45] <brson> wait
[21:45:51] <brson> #[ignore(cfg(target_arc = "x86"))]
[21:45:55] <nmatsakis> graydon: I ... think that fix landed, but I still think we're handling double returns wrong
[21:46:01] * nmatsakis -> dinner
[21:46:33] <graydon> nmatsakis: ok
[21:46:44] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[21:50:30] *** Joins: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca)
[21:50:55] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[21:51:29] *** Quits: ksev (DrunkenPan@745B767B.989A61DC.CA5B6332.IP) (Ping timeout)
[21:51:29] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[21:51:29] <ghrust> 01[13rust01] 15graydon fast-forwarded 06master from 14303d7bf to 142e41689: 02http://git.io/vbKdxw
[21:51:29] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[21:51:33] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[21:51:33] <ghrust> 01[13rust01] 15graydon merged 06master into 06auto: 02http://git.io/vbKdxw
[21:51:33] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[21:52:01] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[21:53:20] *** Joins: Diamond (dick@moz-625C0DAF.ks.ok.cox.net)
[21:54:17] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[21:54:23] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:55:35] *** Quits: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca) (Ping timeout)
[21:55:43] *** Joins: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca)
[21:56:26] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[21:56:31] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[21:56:45] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[21:57:14] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[21:57:43] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Input/output error)
[21:58:37] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[21:58:41] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[21:58:42] *** vcl_ is now known as vcl
[22:00:34] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[22:01:04] *** Quits: judder (maradukewa@D90735BE.FBAA5D2F.78E362FE.IP) (Ping timeout)
[22:01:07] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Quit: ChatZilla 0.9.90 [Firefox 23.0a2/20130618004018])
[22:02:33] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[22:04:40] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[22:05:21] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[22:05:48] *** Quits: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca) (Ping timeout)
[22:06:17] *** Quits: koomi (koomi@moz-B2B8B6D1.superkabel.de) (Quit: WeeChat 0.4.1)
[22:07:28] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Ping timeout)
[22:08:31] <cmr> graydon: does master build right now?
[22:08:37] <cmr> and run, I suppose
[22:08:38] <graydon> cmr: waiting to see
[22:08:41] <cmr> ah, ok
[22:08:56] *** Joins: mleise (marco@moz-3468AB5B.pools.arcor-ip.net)
[22:09:07] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[22:09:33] *** Joins: RMF (RMF@7CB4432F.59969257.8D19547B.IP)
[22:09:39] <sully> argh, found a new default method bug
[22:09:45] <sully> that manifests as a... link error
[22:10:08] *** Joins: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca)
[22:10:26] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[22:13:09] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[22:13:45] *** Quits: Azdle (Azdle@moz-B334B496.hfc.comcastbusiness.net) (Ping timeout)
[22:13:45] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[22:14:48] *** Quits: ssbr (ssbr@moz-2D56B53B.dsl.bell.ca) (Ping timeout)
[22:14:58] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Ping timeout)
[22:15:22] *** Joins: ssbr (ssbr@moz-2D56B53B.dsl.bell.ca)
[22:15:50] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[22:15:53] <mark_edward> hey, this program just hangs, never exiting
[22:15:57] <mark_edward> can anyone help?
[22:15:59] <mark_edward> https://gist.github.com/MarkJr94/5809941
[22:16:13] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[22:16:50] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:17:29] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[22:18:03] *** Joins: heftig_ (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[22:18:22] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[22:18:57] *** Quits: ssbr (ssbr@moz-2D56B53B.dsl.bell.ca) (Ping timeout)
[22:19:14] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (NickServ (GHOST command used by heftig_))
[22:19:22] *** heftig_ is now known as heftig
[22:19:43] <steven_is_false> mark_edward: I've had a lot of problesm working with libuv but let me think about it a bit.
[22:20:41] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[22:20:43] <mark_edward> ok
[22:21:08] <steven_is_false> mark_edward: Does it work if use the global loop?
[22:21:14] <mark_edward> it hangs on pthread_cond_wait. i figured it out from gdb
[22:21:18] <mark_edward> why I gon't know
[22:21:27] <mark_edward> I'll try it now
[22:21:31] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[22:21:37] *** vcl_ is now known as vcl
[22:23:06] <mark_edward> nope, it doesn't hang
[22:23:08] <mark_edward> DARN IT
[22:23:22] <mark_edward> it's because of the supervised call
[22:23:27] <cmr> stage0 vs stage1 memory usage compiling libstd: http://i.imgur.com/9w5iiuW.png
[22:23:39] <cmr> (y axis in KiB, x in seconds)
[22:23:52] <steven_is_false> mark_edward: Why would supervized cause things to hang?
[22:23:56] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Ping timeout)
[22:24:03] <mark_edward> oh yeah, doesn't make any sense
[22:24:56] <mark_edward> but it doesn't hang with the global loop
[22:25:03] *** Joins: ssbr (ssbr@moz-2D56B53B.dsl.bell.ca)
[22:25:30] <steven_is_false> Sorry, you'll have to ask someone who knows more.
[22:25:36] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[22:25:46] <steven_is_false> rusti: match extra::net::ip::get_addr("localhost", &extra::uv_global_loop::get()) {
[22:25:46] <steven_is_false>         Ok(addrs) => { addrs[0] }
[22:25:46] <steven_is_false>         _ => { fail!("Couldn't get IP address to listen on") }
[22:25:46] <steven_is_false>     };
[22:25:48] -rusti- <anon>:12:0: 12:1 error: file ended with unbalanced delimiters
[22:25:48] -rusti- <anon>:12 }
[22:25:48] -rusti-           ^
[22:25:48] -rusti- application terminated with error code 101
[22:25:59] <steven_is_false> rusti: match extra::net::ip::get_addr("localhost", &extra::uv_global_loop::get()) { Ok(addrs) => { addrs[0] }  _ => { fail!("Couldn't get IP address to listen on") }  };
[22:26:04] -rusti- timeout triggered!
[22:26:14] <brson> mark_edward: give uv_global_loop: spawn_task a look
[22:26:22] <brson> the uv loop has some special requirements
[22:26:41] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[22:26:45] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[22:26:52] *** Joins: nicelydone (Mibbit@moz-BB21156B.dynamic.csail.mit.edu)
[22:26:52] *** vcl_ is now known as vcl
[22:26:58] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[22:27:03] <brson> mark_edward: in particular see the comment about 'weak tasks'
[22:27:23] <nicelydone> Hi all. Is there a way to have Rust look for a module from a parent directory?
[22:27:42] <cmr> nicelydone: when using "mod foo"?
[22:27:49] <nicelydone> Exactly.
[22:28:01] <mark_edward> like what?
[22:28:12] <cmr> nicelydone: #[path="../foo.rs"] mod foo;
[22:28:12] <strcat> brson: how big do stacks start out as right now?
[22:28:19] <cmr> nicelydone: (usually on two lines)
[22:29:16] <nicelydone> Excellent.
[22:29:17] <mark_edward> brson: what are the requiremens? they're not in the docs
[22:29:20] <brson> strcat: 768 bytes + a 2k - 20k red zone
[22:29:47] <nicelydone> Also, was the durable trait removed for the 0.6 release or at some point after?
[22:30:12] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[22:30:19] <nicelydone> The docs seem to indicate it happened in time for the 0.6 release but my install seems to still include it.
[22:32:24] <brson> mark_edward: um, actually the problem is that you need to call 'exit' on the iotask at some point to tell the uv loop to stop
[22:32:38] <brson> the global loop does this automatically as part of runtime shutdown
[22:33:14] <brson> nicelydone: I think it was after
[22:33:31] <mark_edward> why wouldn't the destructor do that?
[22:33:44] <mark_edward> seems like a good use for one
[22:34:21] *** Quits: ssbr (ssbr@moz-2D56B53B.dsl.bell.ca) (Ping timeout)
[22:34:28] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Client exited)
[22:35:17] <brson> mark_edward: the uv code in extra is unmaintained
[22:35:48] *** Joins: koomi (koomi@moz-543186DC.pools.arcor-ip.net)
[22:35:51] <mark_edward> oh ok
[22:37:07] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[22:37:15] *** Quits: erickt1 (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:37:23] <mark_edward> brson: but when i call exit i get a segfault
[22:37:30] *** Quits: qmx (qmx@E752832C.183C69CE.45D46379.IP) (Quit: Textual IRC Client: www.textualapp.com)
[22:37:39] <cmr> see above comment :p
[22:38:21] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[22:39:34] *** Quits: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca) (Ping timeout)
[22:40:06] *** Quits: int3_ (int3_@43CB6079.66715431.D25A875A.IP) (Client exited)
[22:40:41] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:41:38] *** Quits: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de) (Ping timeout)
[22:42:49] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[22:44:09] <graydon> what do we do about the 32bit non-opt mac build not being able to link?
[22:44:15] <graydon> "doesn't matter"?
[22:44:27] <graydon> IOW take it out of the pool?
[22:44:36] <strcat> graydon: did you try that with inline(always) gone?
[22:44:37] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[22:44:37] *** Joins: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca)
[22:44:40] <graydon> "LLVM ERROR: Section too large, can't encode r_address (0x10006ad) into 24 bits of scattered relocation entry"
[22:44:41] <graydon> yeah
[22:44:41] *** Joins: vcl_ (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[22:44:42] <graydon> same
[22:44:43] *** vcl_ is now known as vcl
[22:44:43] <cmr> I don't think it matters right now... maybe when codegen isn't awful
[22:44:49] <graydon> ok
[22:46:54] *** Quits: mark_edward (quassel@moz-65479535.dynamic.utc.edu) (Ping timeout)
[22:47:45] *** Joins: heftig (heftig@moz-9CF50836.dip0.t-ipconnect.de)
[22:49:49] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Connection reset by peer)
[22:49:55] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:50:42] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[22:50:53] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[22:51:00] *** Quits: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca) (Ping timeout)
[22:53:25] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[22:53:41] *** Quits: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP) (Ping timeout)
[22:54:39] *** Joins: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[22:54:55] *** Joins: tjc (tjc@6902864.17C2F9C.163DC5C6.IP)
[22:54:55] *** ChanServ sets mode: +o tjc
[22:55:10] *** Joins: ssbr (ssbr@moz-2D56B53B.dsl.bell.ca)
[22:55:12] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[22:56:19] *** Quits: jdm (jdm@moz-801E009D.vlan502.asr1.cdg2.gblx.net) (Ping timeout)
[22:56:59] *** Joins: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca)
[23:02:24] <brson> what's the replacement for str::raw::buf_as_slice?
[23:03:15] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:04:12] * flu_ is buf as slice
[23:04:56] <dbaupp> brson: possibly c_str_to_static_slice
[23:08:57] <brson> dbaupp: thanks
[23:11:15] <graydon> looks like rusti doesn't work on 32bit mac at all
[23:11:21] <graydon> someone want to tell me how to disable that? :)
[23:11:38] <strcat> ln -s it to /bin/true :D
[23:12:01] <Eridius> /bin/false
[23:12:48] <dbaupp> graydon: the tests are in the bottom of the rusti source files, I think, so they should be able to be cfg'd out
[23:12:56] <graydon> oh, ok
[23:12:59] *** Quits: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca) (Ping timeout)
[23:13:01] *** Joins: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca)
[23:13:08] <brson> graydon: I don't know of a way to disable rusti tests for just 32-bit mac
[23:13:28] <graydon> can't I AND-together ignore(cfg(...)) clauses?
[23:13:46] <Eridius> what's the difference between ignore(cfg(...)) and cfg(not(...))?
[23:13:55] <dbaupp> #[cfg(not(and(target_word_size=32, target_os="mac")))] on mod tests?
[23:13:56] *** Joins: alisdair (textual@moz-EA60A466.dedicated.allstream.net)
[23:14:03] <graydon> yeah, something like that?
[23:14:06] <brson> dbaupp: yes that will work
[23:14:13] <brson> I don't think #[ignore] knows how to do it though
[23:14:17] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:14:44] <brson> but maybe somebody had that foresight
[23:14:55] <Eridius> #[ignore(broken_things)]
[23:16:00] <dbaupp> brson: it looks like ignore does use the same code as cfg, so it probably works fine
[23:16:21] *** Joins: prudhvi (prudhvi@moz-154A460A.supr.io)
[23:16:49] <prudhvi> Hi, I just compiled a hello world from current master. I get these errors am i missing something? http://pastie.org/8057277
[23:17:33] <Eridius> prudhvi: the hash of std changed. You'll want to delete your installed rust bits and re-install
[23:22:55] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[23:25:20] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:25:59] *** Quits: dLog (anonymous@moz-8FAE8709.eastlink.ca) (Ping timeout)
[23:28:41] *** Joins: xenocons (otk@moz-C675529E.members.linode.com)
[23:29:09] <xenocons> rusti: 1
[23:29:14] -rusti- 1
[23:29:21] *** Quits: SiegeLord (sl@moz-56D7E78.bstnma.fios.verizon.net) (Quit: Leaving)
[23:30:28] <steven_is_false> So I should try to remove copy, and replace it with clone in the compiler source code if possible right?
[23:32:23] <Eridius> you should use the Knockoff trait. It doesn't produce exact copies, but it's cheaper
[23:33:10] *** Quits: tjc (tjc@6902864.17C2F9C.163DC5C6.IP) (Quit: zzzzzzzzzz)
[23:33:41] <steven_is_false> Hmm, some parts of the source it may be better to use the TwoForOne trait instead. Then I get quality, and cost effeciency!
[23:34:03] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[23:35:09] *** Quits: Ralith (ralith@moz-768BBE2B.wireless.sfu.ca) (Ping timeout)
[23:35:21] *** Joins: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de)
[23:35:53] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[23:35:57] <steven_is_false> But wait there's more! If I use the BuyOneNow trait, I can get TwoMoreFree as well!
[23:36:03] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:37:07] <Eridius> you're confusing purchasing and manufacturing
[23:37:10] <bblum> whose idea was the design for typeck/infer/combine.rs?
[23:37:15] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[23:37:21] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[23:37:23] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[23:37:41] <bblum> whoever it is, i want to praise them for how pretty it is
[23:38:56] *** Quits: MaikKlein (maik@moz-27A63459.dip0.t-ipconnect.de) (Ping timeout)
[23:38:58] <strcat> git blame says a lot of it is niko's fault ;p
[23:39:20] <steven_is_false> strcat: You mean git praise right :)
[23:39:55] *** Quits: koomi (koomi@moz-543186DC.pools.arcor-ip.net) (Ping timeout)
[23:40:51] *** Joins: tjc (tjc@moz-24060A8E.firstunitarianportland.org)
[23:40:51] *** ChanServ sets mode: +o tjc
[23:41:44] *** Quits: eholk (eholk@moz-5CE2DFCF.uconnect.utah.edu) (Ping timeout)
[23:42:43] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[23:42:54] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[23:44:02] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[23:45:00] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[23:45:05] *** Quits: Diamond (dick@moz-625C0DAF.ks.ok.cox.net) (Client exited)
[23:46:13] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[23:46:21] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[23:46:21] <ghrust> 01[13rust01] 15graydon pushed 1 new commit to 06master: 02http://git.io/svuOuw
[23:46:21] <ghrust> 13rust/06master 1404b1dba 15Graydon Hoare: rusti: disable tests on 32bit mac. r=burningtree.
[23:46:21] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[23:46:24] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:46:24] <ghrust> 01[13rust01] 15graydon merged 06master into 06auto: 02http://git.io/y5Qk7Q
[23:46:24] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:46:49] <roo> i have kind of a long-form question here http://pastebin.com/qm3XmqWh and was wondering if someone could take a look at it
[23:47:06] *** Joins: koomi (koomi@moz-543186DC.pools.arcor-ip.net)
[23:47:07] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[23:47:08] <Eridius> hmm, the ctags definition in src/etc/rust.ctags is effectively unusable.
[23:48:21] <Eridius> roo: remove the ; after the #[path] attribute
[23:49:06] <bblum> if i have an option is it preferred to write
[23:49:12] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[23:49:15] <bblum> for foo.iter().advance |x| { ... }
[23:49:20] <bblum> or do foo.map |x| { ... };
[23:49:27] *** Joins: jrfeenst (jrfeenst@moz-F912484F.cpe.norwoodlight.com)
[23:49:30] <bblum> i feel like the answer is gonna be the former
[23:49:32] <cmr> map is going away
[23:49:40] <bblum> that... can't be.
[23:50:01] *** Quits: int3_ (int3_@43CB6079.66715431.D25A875A.IP) (Client exited)
[23:50:31] <cmr> also you want foo.iter().transform(|x| ...)
[23:50:35] <dbaupp> bblum: probably the former, if you don't care about the Option returned from .map
[23:50:46] <cmr> which should be renamed to map once old-map goes away
[23:50:52] <bblum> dbaupp: i don't but map looks prettier
[23:51:01] <cmr> also the new for sugar should make it better
[23:51:01] <Eridius> assuming we ever get once functions working, seems like we might want to add a method to Option that takes a once function and ignores its return value (e.g. .map without the return, + once)
[23:51:08] <cmr> strcat: is there a proposal about that somewher?
[23:51:15] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[23:51:16] <dbaupp> bblum: yeah, it does... hopefully the for sugar will make things nicer
[23:51:46] <cmr> dbaupp: finished rust-bench. I have data for all the benchmarks in master (yesterday's master)
[23:51:55] <dbaupp> cmr: proposal about s/transform/map/?
[23:52:03] <dbaupp> cmr: nice!
[23:52:04] <cmr> once the tree is put out I'll setup auto-merge benchmarks
[23:52:07] *** aatch|gone is now known as aatch
[23:52:09] <cmr> dbaupp: about the for sugr
[23:52:20] <dbaupp> cmr: oh, yeah... I think so
[23:52:34] <dbaupp> cmr: not sure if there's a bug about it
[23:52:36] <brson> cmr: neat. do you have a link yet?
[23:52:49] <cmr> brson: to the data?
[23:53:02] * cmr scp's quickly
[23:53:14] <brson> cmr: or graphs
[23:53:25] <cmr> brson: I don't have graphs yet, haven't automated that
[23:53:35] *** Quits: alisdair (textual@moz-EA60A466.dedicated.allstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:53:44] <cmr> eventually (hopefully) isrustfastyet will pull it in
[23:53:47] * dbaupp wants to do all sorts of visualisations
[23:54:04] <aatch> Auto is almost working again!
[23:54:08] <cmr> I know nothing about how to do plotting/data visualization :)
[23:54:15] <dbaupp> (I have exams for the next 2 weeks, unfortunately :( )
[23:54:16] <cmr> (besides the plot() function in ipython)
[23:54:28] <dbaupp> aatch: it's like magic!
[23:54:54] <cmr> brson: http://octayn.net/data.json.gz
[23:54:59] <cmr> one json object per-line
[23:55:31] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[23:56:06] <flu_> why is the windows test suite so fast? Is it a different test battery?
[23:56:07] <cmr> https://github.com/cmr/rust-bench/blob/master/rust-bench.py#L60 for the format used
[23:56:20] <cmr> flu_: see omment on bottom of the site
[23:56:24] <flu_> kk
[23:56:36] *** Quits: KindOne (KindOne@moz-DBCDCEA8.dynamic.ip.windstream.net) (Ping timeout)
[23:56:36] <dbaupp> flu_: https://github.com/mozilla/rust/wiki/Note-testsuite#fast-check
[23:56:37] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[23:56:46] <aatch> Huh, looks like cross-compiling on mac doesn't work
[23:56:51] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[23:56:53] <flu_> aha
[23:57:09] <aatch> Or at least 32-bit mac doesn't work
[23:57:30] *** Quits: mleise (marco@moz-3468AB5B.pools.arcor-ip.net) (Quit: Leaving.)
[23:57:55] <nicelydone> Is there a way to iterate through the characters of a string without using the standard library?
[23:58:16] <cmr> nicelydone: not safely.
[23:58:21] <nicelydone> That's okay.
[23:58:34] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[23:58:42] <brson> graydon: thank you for improving the integration bots and fixing all the bugs
[23:58:46] <cmr> you need to transmute, take the length, and decode the utf-8
[23:59:02] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[23:59:10] <bblum> nmatsakis: what is ty;:visitor_object_ty?
[23:59:17] <graydon> brson: hey, no worries!
[23:59:25] *** Quits: blitter (blitter@moz-FB45689C.dyn.centurytel.net) (Quit: Leaving)
[23:59:34] <graydon> cheers me up that it seems to have been so few root causes
[23:59:40] <graydon> none of which involved fighting helgrind :)
[23:59:46] <graydon> wonder if we're done yet
[23:59:58] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)

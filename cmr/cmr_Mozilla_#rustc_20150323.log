[00:25:36] *** Joins: theme (theme@moz-i3mhhb.asianet.co.th)
[00:29:59] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[00:31:39] *** Parts: theme (theme@moz-i3mhhb.asianet.co.th) ("Leaving")
[00:38:51] *** Quits: bleibig (bleibig@moz-btk.gm4.170.73.IP) (Connection closed)
[00:39:50] *** Joins: bleibig (bleibig@moz-btk.gm4.170.73.IP)
[00:40:01] *** nrc|afk is now known as nrc
[03:25:20] *** Joins: kimundi_ (kimundi@moz-rl5lt8.dip0.t-ipconnect.de)
[03:28:51] *** Quits: kimundi (kimundi@moz-l9a7he.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[03:28:51] *** kimundi_ is now known as kimundi
[03:32:52] *** Joins: bombless (bombless@moz-0p4aul.0v2u.0v40.0da8.2001.IP)
[03:34:21] *** kimundi is now known as zz_kimundi
[03:39:21] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Connection closed)
[03:39:58] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[03:41:11] *** zz_kimundi is now known as kimundi
[04:37:01] *** Quits: bombless (bombless@moz-0p4aul.0v2u.0v40.0da8.2001.IP) (Quit: Leaving)
[05:11:21] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[05:48:20] *** Joins: reem (reem@moz-61svef.coob.q2h1.0009.2601.IP)
[06:25:00] *** Quits: reem (reem@moz-61svef.coob.q2h1.0009.2601.IP) (Connection closed)
[06:25:27] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[06:29:31] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Ping timeout: 121 seconds)
[06:34:54] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[06:35:13] *** Joins: simukis (nagisa@moz-pol184.mif.vu.lt)
[06:39:38] *** Quits: simukis (nagisa@moz-pol184.mif.vu.lt) (Ping timeout: 121 seconds)
[06:42:41] *** Joins: simukis (nagisa@moz-pol184.mif.vu.lt)
[06:51:46] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:05:19] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:05:19] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:05:20] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:10:52] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:13:57] *** Quits: simukis (nagisa@moz-pol184.mif.vu.lt) (Client exited)
[07:29:10] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:36:13] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[07:38:23] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:40:04] *** Joins: simukis (nagisa@moz-pol184.mif.vu.lt)
[07:42:49] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:42:49] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:42:50] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:47:01] *** Quits: simukis (nagisa@moz-pol184.mif.vu.lt) (Ping timeout: 121 seconds)
[07:50:36] *** Joins: simukis (nagisa@moz-pol184.mif.vu.lt)
[07:51:17] *** Quits: simukis (nagisa@moz-pol184.mif.vu.lt) (Client exited)
[07:51:39] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[07:56:24] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[07:58:43] *** Joins: simukis (nagisa@moz-pol184.mif.vu.lt)
[07:59:02] *** Quits: simukis (nagisa@moz-pol184.mif.vu.lt) (Client exited)
[08:00:48] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Ping timeout: 121 seconds)
[08:01:09] *** Joins: reem (reem@moz-9o70fr.coob.q2h1.0009.2601.IP)
[08:18:49] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[08:23:03] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[09:12:15] *** Joins: laumann (thomas@moz-vj4.hq0.225.130.IP)
[09:12:59] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[09:17:12] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[09:25:35] *** Quits: reem (reem@moz-9o70fr.coob.q2h1.0009.2601.IP) (Connection closed)
[09:25:56] *** Joins: reem (reem@moz-9o70fr.coob.q2h1.0009.2601.IP)
[09:33:10] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[09:51:48] *** Quits: reem (reem@moz-9o70fr.coob.q2h1.0009.2601.IP) (Connection closed)
[09:53:05] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[09:53:05] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[09:53:06] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[10:07:08] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[10:10:20] *** kimundi is now known as zz_kimundi
[10:11:24] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[10:11:36] *** zz_kimundi is now known as kimundi
[10:18:30] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[10:26:53] *** Quits: laumann (thomas@moz-vj4.hq0.225.130.IP) (Ping timeout: 121 seconds)
[10:37:17] *** Joins: laumann (thomas@moz-vj4.hq0.225.130.IP)
[10:54:41] *** Quits: laumann (thomas@moz-vj4.hq0.225.130.IP) (Ping timeout: 121 seconds)
[10:54:42] *** Joins: laumann (thomas@moz-vj4.hq0.225.130.IP)
[11:01:16] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[11:05:32] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[11:55:26] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[11:59:42] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[12:12:28] *** Joins: bombless (bombless@moz-69nc8e.0v2u.0v40.0da8.2001.IP)
[12:43:01] *** Joins: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP)
[12:43:01] *** ChanServ sets mode: +o pnkfelix
[12:49:36] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[12:53:52] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Ping timeout: 121 seconds)
[12:55:00] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[13:14:26] *** Quits: bombless (bombless@moz-69nc8e.0v2u.0v40.0da8.2001.IP) (Ping timeout: 121 seconds)
[13:18:53] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[13:22:31] *** Joins: joel2 (joel@moz-6ampnk.gtri.gatech.edu)
[13:22:57] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Ping timeout: 121 seconds)
[13:43:46] *** Joins: Rym (y@moz-vsu.f6d.55.31.IP)
[14:22:17] <nmatsakis> eddyb: ping
[14:24:27] *** Joins: WindowsBunny1 (Peter@moz-7f2st1.east.verizon.net)
[14:24:55] *** Quits: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net) (Ping timeout: 121 seconds)
[14:46:59] *** Quits: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP) (Ping timeout: 121 seconds)
[14:52:16] *** Joins: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP)
[14:52:17] *** ChanServ sets mode: +o pnkfelix
[15:41:18] *** Joins: bombless (bombless@moz-69nc8e.0v2u.0v40.0da8.2001.IP)
[15:54:02] *** Quits: laumann (thomas@moz-vj4.hq0.225.130.IP) (Ping timeout: 121 seconds)
[16:03:02] *** Quits: bombless (bombless@moz-69nc8e.0v2u.0v40.0da8.2001.IP) (Quit: Leaving)
[16:11:53] *** Quits: pnkfelix (pnkfelix@moz-je0.a5j.80.81.IP) (Quit: rcirc on GNU Emacs 24.3.92.1)
[16:15:04] <eddyb> nmatsakis: pong
[16:29:08] <eddyb> nmatsakis: have you seen this "outdated" comment thread? https://github.com/rust-lang/rfcs/pull/996#discussion_r26891117
[16:30:06] <eddyb> nmatsakis: I think you need &own fn() to even have issues with dynamic zero-size btw
[16:30:20] <eddyb> nmatsakis: or at least &mut fn()... how would you do that?
[16:30:39] <eddyb> nmatsakis: but yes, I prefer the type system option :)
[17:03:38] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:03:38] *** ChanServ sets mode: +qo brson brson
[17:25:59] <eddyb> nmatsakis: I am wondering something...
[17:27:47] <eddyb> nmatsakis: can T: Unsize<Trait> just be T: Trait? wait, no, if T is unsized then it *has* to be a "subtype" of Trait
[17:27:59] <eddyb> hmm
[18:38:57] <nmatsakis> eddyb: I don't see why you need &own fn, but you do need a way to pass ownership of unsized types
[18:39:33] <eddyb> nmatsakis: how do you own an unsized fn?
[18:40:00] <eddyb> nmatsakis: "you can't" is the main reason why it's safe to use a 0 size
[18:40:20] <eddyb> but I can't prove we won't ever get there
[18:40:20] <nmatsakis> eddyb: you can't today
[18:40:49] <eddyb> it wouldn't ever have a destructor
[18:40:51] <nmatsakis> but I specifically want to add the ability to own unsized types, and all I'm saying is that if we add fn, we have to accommodate that there are types where you can't own an instance of them
[18:41:00] <eddyb> so what is ownership without a destructor :P
[18:41:04] <nmatsakis> well
[18:41:05] <nmatsakis> if I am a jit
[18:41:07] <nmatsakis> and I construct a fn
[18:41:16] <nmatsakis> it's plausible to make a Box<fn()>
[18:41:25] <eddyb> nmatsakis: what does dropping it do?
[18:41:25] * nmatsakis shrugs
[18:41:32] <nmatsakis> yeah, nothing :)
[18:41:35] <eddyb> maybe Gc<fn()> would work
[18:41:39] <nmatsakis> I guess that's sort of the point though
[18:41:46] <nmatsakis> that this is a new sort of type
[18:41:49] <nmatsakis> in that it has no reasonable dtor
[18:42:08] <eddyb> nmatsakis: !Droppable + !Sizeable
[18:42:13] <nmatsakis> but it's not really the point actually
[18:42:14] <nmatsakis> that is,
[18:42:20] <nmatsakis> the dtor can just be a no-op,
[18:42:26] <nmatsakis> the point is that Box<fn()> couldn't free the ptr
[18:42:29] <nmatsakis> without knowing the size
[18:42:36] <nmatsakis> (at least with today's sized free APIs)
[18:42:39] <eddyb> what I don't want is a trait for it that includes "fn" in its name
[18:42:51] <eddyb> same with NotBottom
[18:43:02] <eddyb> (Uninhabited being at least a half-decent name)
[18:43:27] <eddyb> I don't think anyone suggesting such names is thinking beyond the immediate future
[19:03:43] *** Joins: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com)
[19:37:36] <eddyb> nmatsakis: I hope you're here. I'm getting turned around in select
[19:38:54] <eddyb> nmatsakis: for Struct<T>: Unsize<Struct<U>>, should I check the type params & fields when adding the candidate, or when confirming it?
[19:39:26] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[19:39:26] *** ChanServ sets mode: +qo nrc nrc
[19:39:33] <eddyb> nmatsakis: looking at fn(..A) -> R: Fn<A, Output=R>, the latter seems... okay
[19:40:10] <eddyb> nmatsakis: but the upcast method does some probing and it's used in assemble_candidates_from_object_ty
[19:45:03] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[19:51:45] <nmatsakis> eddyb: generally speaking, the current code does kind of shallow checks initially, and deeper checks get added as nested obligations in the vtable; those can then become new obligations when confirming, or be used during winnowing
[19:51:53] <nmatsakis> I might like to change this strategy but anyway
[19:52:16] <eddyb> I did try to do something shallow initially
[19:52:36] <eddyb> but subtyping is not a valid obligation, no?
[19:52:46] <nmatsakis> I think for Unsize though you'd want to wait until you know enough to know that at least the two Structs are the same etc -- i.e., that you CAN construct the nested conditions
[19:52:57] <nmatsakis> right, we don't have a subtyping obligation
[19:53:12] <eddyb> I like using nested obligations for the tail field
[19:53:26] <nmatsakis> well, we have the Eq type check
[19:53:31] <nmatsakis> it's plausible we could add a subtyping obligation
[19:53:39] <nmatsakis> shouldn't be too hard
[19:53:50] <eddyb> but coercion using selection has to eagerly resolve all Unsize obligations
[19:53:55] <eddyb> not sure if that is reasonable
[19:54:24] <eddyb> the only obligations left are for T: Unsize<Trait>
[19:54:43] <eddyb> T: Unsize<Trait+'a> I mean, i.e. T: Sized + Trait + 'a
[19:55:03] <nmatsakis> so I think what I had in mind is for the select phase to do most of the matching; but if it came to T: Unsize<Trait>,
[19:55:10] <nmatsakis> then it would generate that as a subcondition
[19:55:18] <eddyb> right
[19:55:30] <eddyb> nmatsakis: so confirming should not generate nested Unsize obligations?
[19:55:59] <nmatsakis> right, I don't think you should need to do that
[19:58:05] <eddyb> hmm
[19:59:01] <eddyb> nmatsakis: should it be done during confirming? (to avoid expensive checks if there's a bound in scope, for example)
[20:02:49] <eddyb> nmatsakis: I am glad I managed to bug you about this, thanks a lot, btw :D
[20:07:34] <nmatsakis> eddyb: sorry, was reading something, should what (exactly) be done during confirming?
[20:07:50] <eddyb> nmatsakis: recursing in structures
[20:08:05] <eddyb> OH
[20:08:11] <eddyb> nmatsakis: I remember what the issue was now
[20:08:28] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[20:08:28] *** ChanServ sets mode: +o pnkfelix
[20:08:50] <eddyb> nmatsakis: I can't just do the old recursion, if T: Unsize<U> is in scope, Struct<T>: Unsize<Struct<U>>
[20:09:17] <eddyb> nmatsakis: so I need to invoke selection recursively?
[20:09:32] <nmatsakis> eddyb: actually, wait, so why don't you want to make nested unsize obligations? I think I may have been confused
[20:09:42] <nmatsakis> that actually does seem right now that you say it
[20:09:48] <nmatsakis> specifically, for the last fields of the two structs, right?
[20:09:52] <eddyb> yes
[20:10:04] <nmatsakis> with regard to coercion,
[20:10:08] <eddyb> well, I don't mind the obligations, but I need a way to enforce that they are not left around
[20:10:09] <nmatsakis> and the need to "fully evaluate",
[20:10:24] <eddyb> if it's not certain, then there's no point in a coercion
[20:10:54] <nmatsakis> you can use evaluate_obligation()
[20:11:04] <nmatsakis> though that does err on the side of implemented in some cases
[20:11:19] <nmatsakis> but it does handle the nested cases for you
[20:11:24] <eddyb> I want non-Unsize obligations to be lazy and Unsize obligations to be handled early
[20:11:56] <nmatsakis> it's what we use for example to decide if Deref is impl'd and so forth
[20:12:13] <eddyb> I wonder if that logic has any edge cases
[20:12:17] <nmatsakis> well, as I said, it errors on the side of impl'd, so it will evaluate non-unsize obligations
[20:12:25] <nmatsakis> but if there isn't enough info
[20:12:27] <nmatsakis> e.g. unbound type vars
[20:12:28] <nmatsakis> it'll return true
[20:12:34] <nmatsakis> (actually ambig)
[20:12:36] <eddyb> nmatsakis: definitely don't want that
[20:12:48] <nmatsakis> (but the evaluate_obligation convers that to a bool, which would be easy to cahnge)
[20:13:09] <nmatsakis> yeah, it's a bit tricky. interesting. I've been wanting to merge the fulfillment context and inference context,
[20:13:16] <nmatsakis> which would actually help you here a bit, since you could use snapshots.
[20:13:17] <nmatsakis> but anyway
[20:13:38] <eddyb> what about nested ty_var: Trait obligations?
[20:13:52] <nmatsakis> so 
[20:13:55] <eddyb> I want to keep those around even if they're ambiguous
[20:13:56] <nmatsakis> you can write your own nested loop really
[20:14:02] <eddyb> right
[20:14:06] <nmatsakis> since it seems like the existing ones don't suit your needs
[20:14:18] <eddyb> can I do it in coercion?
[20:14:24] <nmatsakis> sure, should be no problem
[20:14:35] <nmatsakis> you can even make your own nested fulfillment context
[20:14:48] <nmatsakis> start a transaction
[20:14:54] <nmatsakis> and run select_all_or_error()
[20:14:59] <nmatsakis> or something like that
[20:15:06] <nmatsakis> though that may be stronger than you really want
[20:15:29] <eddyb> I really want to peek at each predicate
[20:15:36] <nmatsakis> so if you just want to filter by hand
[20:15:47] <nmatsakis> then you can just call the selectioncontext methods yourself
[20:15:50] <nmatsakis> it will give you back a vtable
[20:15:59] <nmatsakis> with nested predicates
[20:16:09] <nmatsakis> you can basically jsut call map_move_nested
[20:16:11] <nmatsakis> and examine each predicate
[20:16:21] <nmatsakis> decide whether you want to throw it on a  vector  to recursively evaluate
[20:16:22] <nmatsakis> or what
[20:16:32] <nmatsakis> at some point you'll reach some ambiguities maybe (selcx will return Ok(None)
[20:16:38] <nmatsakis> and you have to decide whether you care 
[20:16:50] <eddyb> there shouldn't be more than one Unsize obligation each time
[20:16:59] <nmatsakis> well, then you don't need a vector I guess
[20:17:07] <nmatsakis> if you really do want to ignore the non-unsize things
[20:17:09] <nmatsakis> which I guess you do
[20:17:17] <eddyb> I do wonder about the trait thing
[20:17:18] <nmatsakis> yeah you can easily "drive" this yourself
[20:17:31] <eddyb> can I encode T: Trait + Sized + 'a?
[20:17:47] <nmatsakis> not sure what you mean by encode
[20:17:51] <nmatsakis> but seems like the answer will be yes :)
[20:18:03] <eddyb> register_object_cast_obligations
[20:18:04] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[20:18:09] <eddyb> and then register_region_obligation
[20:18:31] <nmatsakis> from what context are you talking about doing this?
[20:18:55] <eddyb> T: Unsize<Trait+'a> needs to require at least those things *in general*
[20:18:57] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[20:19:04] <nmatsakis> right
[20:19:14] <eddyb> right now coercions trigger it in particular
[20:19:26] <nmatsakis> those are all just obligations
[20:19:29] <eddyb> on the function context
[20:19:33] <nmatsakis> Sized is just a TRait obligation
[20:19:36] <nmatsakis> T: 'a is a TypeOutlives
[20:19:39] <eddyb> aaaah
[20:19:43] <nmatsakis> so T: Unsize<TraitType> can easily encode that
[20:19:46] <nmatsakis> by jsut generating nested obligations
[20:19:50] <eddyb> great :D
[20:20:05] <nmatsakis> also output type bindings
[20:20:08] <eddyb> "object_safety::is_object_safe" hmm
[20:20:40] <nmatsakis> yes, all the traits should be object-safe
[20:20:52] <eddyb> interesting, vtable::check_object_safety only does "nice error" generation
[20:20:52] <nmatsakis> but that's easy to test
[20:20:54] <eddyb> on top of that check
[20:21:23] <nmatsakis> ps wtf is this http://buildbot.rust-lang.org/builders/auto-mac-64-nopt-t/builds/4200/steps/compile/logs/stdio
[20:21:33] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[20:21:38] <acrichto> nmatsakis: merge conflict?
[20:21:44] <acrichto> not in the git conflict sense that is
[20:22:02] <eddyb> acrichto: those are fun
[20:22:04] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[20:22:18] <eddyb> and rustc is terrible for some of those
[20:22:34] <eddyb> I end up looking at the resulting commits for odd diff lines
[20:23:00] <nmatsakis> acrichto: maybe but the branch is fully rebased
[20:23:06] <nmatsakis> acrichto: and it buidls locally
[20:23:12] <nmatsakis> acrichto: I don't know how it would parse on one platform but not mac32
[20:23:46] <eddyb> acrichto: can we get playbot in here?
[20:23:58] * nmatsakis doesn't miss playbot
[20:23:58] <nmatsakis> so noisy
[20:24:53] <acrichto> nmatsakis: oh hm, then that is weird..
[20:24:55] <pnkfelix> nrc: oh I guess there's a running conversation in here too...
[20:25:55] *** Joins: ecr (chatzilla@moz-lbb.gon.175.205.IP)
[20:26:16] <eddyb> pnkfelix: not really
[20:26:28] <eddyb> I have extracted most of the information I need
[20:26:28] <nmatsakis> acrichto: oh I remember what I wanted to ask youa bout
[20:26:31] <pnkfelix> nrc: anyway, I do not know what the `F/FnSpace.0` notation is in `Place<F/FnSpace.0,...>`
[20:26:40] * nmatsakis does
[20:26:41] <eddyb> nrc: is that -v output?
[20:26:46] <nmatsakis> that's -Z verbose
[20:26:50] <eddyb> oh, right
[20:27:00] <eddyb> nrc: what does it look like without -Z verbose?
[20:27:21] <nrc> yeah, without that it looks like: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn()`
[20:27:25] <eddyb> I believe it makes sense, and it's what pnkfelix was working around
[20:27:29] <eddyb> nrc: oh
[20:27:53] <pnkfelix> nrc: what?
[20:27:58] <nmatsakis> acrichto: in particular I was going to mention that I have a branch that does the `impl Fn for &F where F: Fn` work, but it (currently at least) has an ergonomic hit, and I wanted to talk it overe
[20:28:03] <nrc> pnkfelix: yeah....
[20:28:03] <pnkfelix> nrc: that sounds like a totally different error ...
[20:28:11] <acrichto> nmatsakis: oh yay! and oh dear...
[20:28:38] <nrc> er, two different errors
[20:28:42] <nrc> in full:
[20:28:45] <nrc> bar.rs:10:25: 10:41 error: the trait `Place<F>` is not implemented for the type `BP<core::ops::Fn()>` [E0277]
[20:28:47] <nrc> bar.rs:10         let raw_place = ::Place::pointer(&mut place);
[20:28:48] <nrc>                                   ^~~~~~~~~~~~~~~~
[20:28:48] <eddyb> the trait `Place<F, BP<Fn()>>` is not implemented for the type `BP<Fn()>`
[20:28:50] <nrc> bar.rs:7:1: 14:2 note: in expansion of box_!
[20:28:51] <nrc> bar.rs:36:64: 36:76 note: expansion site
[20:28:53] <nrc> bar.rs:9:25: 9:41 error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn()` [E0277]
[20:28:54] <nrc> bar.rs:9         let mut place = ::BoxPlace::make();
[20:28:56] <nrc>                                  ^~~~~~~~~~~~~~~~
[20:28:57] <nrc> bar.rs:7:1: 14:2 note: in expansion of box_!
[20:28:59] <nrc> bar.rs:36:64: 36:76 note: expansion site
[20:29:00] <nrc> bar.rs:9:25: 9:41 note: `core::ops::Fn()` does not have a constant size known at compile-time
[20:29:02] <nrc> bar.rs:9         let mut place = ::BoxPlace::make();
[20:29:03] <nrc>                                  ^~~~~~~~~~~~~~~~
[20:29:05] <nrc> bar.rs:7:1: 14:2 note: in expansion of box_!
[20:29:06] <nrc> bar.rs:36:64: 36:76 note: expansion site
[20:29:12] <eddyb> that could have been shortened :P
[20:29:14] <pnkfelix> nrc: okay, multiple errors does match my expectations
[20:29:21] <pnkfelix> eddyb: (or gisted)
[20:29:39] <eddyb> but this is the original issue, isn't it?
[20:30:07] <pnkfelix> nrc: e.g. if you just get rid of the `as BoxFn` entirely, in the playpen, I think you see the same set of errors
[20:30:20] <nrc> pnkfelix: Ok
[20:30:22] <pnkfelix> nrc: like this: http://is.gd/iHDGoJ
[20:30:47] <pnkfelix> nrc: but it was nice that the `as BoxFn` managed to sidestep it .... and i was hoping your branch would preserve that property
[20:30:47] <nmatsakis> acrichto: rtying to remember where I wrote the comment summarizing
[20:30:59] <eddyb> where you don't get the coercion because you're creating a Box<type variable>
[20:31:21] <nmatsakis> acrichto: ah https://github.com/rust-lang/rust/issues/23015#issuecomment-82539671
[20:31:27] <nrc> pnkfelix: so, please explain to me why, if the only extra bit of type info is that something is a Box<_> we get these errors which look unrelated
[20:31:43] <eddyb> nrc: what looks unrelated?
[20:31:58] <eddyb> pnkfelix: type variables tracking sizedness would be *so good* for this
[20:32:11] <nrc> the above trait errors
[20:32:13] <pnkfelix> nrc: its probably easier to explain after you look at the expansion of the box_! macro
[20:32:26] <nrc> pnkfelix: I have done that locally
[20:32:28] <acrichto> nmatsakis: hm yeah that is a little unfortunate, but somewhat specific to Pattern?
[20:32:30] <pnkfelix> nrc: let me make a new version of the playpen with some annotations explaining
[20:32:35] <nrc> thanks
[20:32:58] <pnkfelix> nrc: (at least according to *my* understanding; maybe eddyb or nmatsakis will provide some beautiful pithy summary in the meantime)
[20:32:59] <acrichto> nmatsakis: it could in theory be solved if there was only an impl for a `&Fn` trait object and then we coerced when satisfying bounds, but that's also far-fetched
[20:33:06] <eddyb> nrc: Box<X>: Box<U> unifies X=U where the intention involves X: Unsize<U>
[20:33:18] <nmatsakis> acrichto: the thing I was concerned about was `mut f: &mut FnMut()`
[20:33:30] <pnkfelix> eddyb: yeah I have brought up tracking sized-ness in type-variables to nmatsakis in the past, but he is not a fan.  (Not yet, at least.)
[20:33:41] * acrichto reads again
[20:33:56] <eddyb> pnkfelix: there's a special Expectation variant to account for this and it still makes me sad :(
[20:34:16] <acrichto> nmatsakis: hm that does seem bad... that introduces double indirection?
[20:35:02] <eddyb> acrichto: autoderef would be nice
[20:35:07] <eddyb> (preferring autoderef, that is)
[20:35:21] <eddyb> not sure if it solves all the issues here
[20:35:46] <nmatsakis> acrichto: the way the autoderef loop for calls is currently implemented, it does, it seems fixable, I just didn't do the work yet
[20:35:56] <eddyb> which leads to that old (somewhat unpopular) idea of satisfying bounds by autoderef
[20:36:15] <nmatsakis> acrichto: we can probably hold off but I want to remove e.g. the PAttern impl -- and hopefully we fix this coherence thing so that we know we can dd the impls in the future
[20:36:18] <nmatsakis> acrichto: without breaking downstream code
[20:36:30] <nmatsakis> acrichto: that was the main reason I was considering expediting (#23086, that is)
[20:36:53] <acrichto> nmatsakis: that seems fine, it's definitely not the end of the world in any sense
[20:37:20] <nmatsakis> acrichto: it wasn't actually that much code though which is why I wondered if I should just land it and fix it later...
[20:37:31] <nmatsakis> acrichto: that is, not so much code that does `mut f: &mut FnMut`, 
[20:37:39] <acrichto> hmm
[20:37:46] <nmatsakis> acrichto: but I sort of wnt to *encourage* people to follow that pattern, not discourage them ;)
[20:39:01] <acrichto> nmatsakis: true...
[20:42:30] <nmatsakis> eddyb: oh I wanted to say re: const fn I think we will merge the RFC, but on a provisional basis (in particular we don't expect to unfeature-gate const fn support before 1.0 or anything like that)
[20:43:06] * nmatsakis drowning in branches
[20:53:46] <eddyb> nmatsakis: deja vu
[20:54:03] <eddyb> nmatsakis: but std macros can use it, right?
[20:55:00] <eddyb> (I would really want to use it in thread_local! to avoid the current madness)
[20:55:56] *** Joins: ff (flaper87Moz@moz-g7hu5v.ip56.fastwebnet.it)
[20:56:50] <nmatsakis> eddyb: I'm not 100% sure how that works, maybe acrichto or brson knows
[20:57:26] <pnkfelix> nrc: ping
[20:58:03] <acrichto> nmatsakis: eddyb: due to macros being able to use unstable features now I believe it's possible
[20:58:39] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[20:58:48] <eddyb> nmatsakis: TraitRef including Self can be so confusing sometimes
[20:59:24] <eddyb> huh, object_trait.principal_trait_ref_with_self_ty(tcx, tcx.types.err)?
[20:59:31] <eddyb> why err in particular?
[20:59:53] <eddyb> I wanted to just use data.principal
[21:02:08] <eddyb> nmatsakis: to preserve error messages, it might be necessary to have a "terminal" mode for coercions
[21:02:38] <eddyb> nmatsakis: either that or... object safety obligations
[21:02:52] <nrc> pnkfelix: pong
[21:03:17] <pnkfelix> nrc: so I have a slightly pithy note that may or may not illuminate
[21:03:37] * nrc prepares to be illuminated
[21:03:38] <pnkfelix> nrc: in particular, I realize now that I was wrong in saying that your expansion "should be fine"
[21:04:03] <nrc> heh, that's good because I was struggling to work out why it was not in fact fine
[21:04:10] <pnkfelix> nrc: look at this playpen: http://is.gd/n7Q6e3
[21:04:21] <pnkfelix> nrc: in particular, compare coerce2 and coerce3
[21:04:34] <pnkfelix> nrc: the crucial thing that that old hack for `as Box<Trait>` was doing
[21:04:51] <pnkfelix> nrc: was effectively inserting a type-ascription to `Box<_>`
[21:04:56] <pnkfelix> nrc: *not* `Box<Trait>`
[21:05:16] <pnkfelix> nrc: because we want to force the expression to figure out for itself what type is supposed to be used for the contents of the box
[21:05:26] <nrc> Ok
[21:05:32] <pnkfelix> nrc: (and thus it will figure out in that process the appropriate sized type to use)
[21:05:35] <eddyb> wait
[21:05:42] <eddyb> pnkfelix: those expansions are suboptimal
[21:05:58] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[21:06:02] <eddyb> the type cannot be propaged down to the inner expression
[21:06:17] <nrc> pnkfelix: is there some type for _ that cannot be denoted?
[21:06:25] <nrc> Is that the root problem here?
[21:06:32] <pnkfelix> eddyb: ... we don't want the trait's type to be propogated down
[21:07:02] <eddyb> pnkfelix: only because it's not Sized
[21:07:34] <pnkfelix> eddyb: yes, and because we want the coercion to actually occur at the point where `as` is being done, right?
[21:07:42] <pnkfelix> eddyb: and not earlier?
[21:07:54] <pnkfelix> eddyb: (or rather, it *can't* be done earlier)
[21:07:57] <eddyb> there is no earlier coercion
[21:08:23] <eddyb> I'm a bit confused why this doesn't work
[21:08:33] <eddyb> value does have a concrete type
[21:08:41] <pnkfelix> nrc: I don't know if I would describe a lack of denotation for `_` as the root problem ...
[21:09:14] <pnkfelix> nrc: (in particular, I would have guessed that in terms of writing a macro expansion, one *can* denote `_` ...)
[21:09:18] *** Quits: Rym (y@moz-vsu.f6d.55.31.IP) (Connection closed)
[21:09:22] <eddyb> after `::std::ptr::write(raw_place, value);`, I expect raw_place to have a concrete type - nevermind
[21:09:26] <eddyb> I forgot this one of those HKT things
[21:09:30] <eddyb> *this is
[21:09:38] *** Joins: Rym_ (y@moz-vsu.f6d.55.31.IP)
[21:09:44] <pnkfelix> nrc: maye I'll put a few more notes into the example
[21:10:08] <eddyb> pnkfelix: shouldn't Place's type parameter be an associated type?
[21:10:36] * eddyb tries tweaking
[21:11:15] <pnkfelix> eddyb: at the time when I was getting this working, there were enough bugs with assoc types that that probably would not have worked
[21:11:20] <pnkfelix> eddyb: but it may work now
[21:11:59] <eddyb> <anon>:81:25: 81:41 error: type mismatch resolving `<BP<core::ops::Fn()> as Place>::Data == F`:
[21:12:03] <nrc> pnkfelix: to clarify, in current Rust, coerce2 works, but coerce3 does not? And the reaspn is because the type the compiler infers for `_` has more information that `Fn()+'a`?
[21:12:17] <eddyb> nrc: no
[21:12:24] <pnkfelix> nrc: it infers a sized type for the `_`
[21:12:30] <pnkfelix> nrc: based on the expression itself
[21:12:37] <pnkfelix> on the left-hand-side of the as
[21:13:05] <pnkfelix> nrc: rather than trying to propogate the unsized trait type down into the interior of the expression
[21:13:07] <nrc> that is in coerce1?
[21:13:24] <nrc> (there is no `as` in coerce2 or 3)
[21:13:33] <pnkfelix> nrc: oh yes
[21:14:01] <pnkfelix> nrc: so okay, where I said "lhs of as", insert "the initialization expression"
[21:14:08] <nrc> so coerce1 and 2 work and 3 and 4 don't?
[21:14:11] <pnkfelix> nrc: that's right
[21:14:26] <pnkfelix> nrc: it would be great if all of them worked
[21:14:32] <pnkfelix> nrc: but for now, we suffer
[21:14:45] <pnkfelix> nrc: (but I would like to avoid injecting more suffering...)
[21:16:38] <nrc> Ok, and on my branch only coerce2 works, which is expected, but sub-optimal
[21:19:00] <nrc> so I expect with type ascription, a more user-friendly version of coerce2 should work
[21:19:08] <nrc> pnkfelix: would that be acceptable?
[21:19:38] <pnkfelix> nrc: well, ideally coerce1 would still work
[21:20:15] <eddyb> wait, your type param *isn't even* Sized
[21:20:26] <eddyb> or rather, type var
[21:20:54] <pnkfelix> nrc: I take it you cannot (or are unwilling to) make `<expr> as Box<Foo>` compile to `(x: Box<_>) as Box<Foo>` ?
[21:20:56] *** Quits: joel2 (joel@moz-6ampnk.gtri.gatech.edu) (Connection closed)
[21:21:06] <eddyb> only BoxPlace::make requires Sized
[21:21:18] <eddyb> pnkfelix: it's still a hack
[21:21:37] <pnkfelix> eddyb: of course its a hack; so was gh22012 itself
[21:22:04] <nrc> pnkfelix: in any case coerce1 would give you a warning for a trivial cast, I feel bad about optimising for an unrecommended path
[21:22:04] <eddyb> we need a long-term solution
[21:22:27] <pnkfelix> nrc: ah right
[21:22:33] <pnkfelix> nrc: hmm, okay
[21:22:51] <eddyb> pnkfelix: why is Boxed implemented on Box and not BP?
[21:23:02] <pnkfelix> nrc: yeah okay I'm willing to suffer with e.g. writing `(<expr> : Box<_>): Box<Trait>`
[21:23:38] <nrc> pnkfelix: great, thanks!
[21:23:56] <pnkfelix> eddyb: Boxed is intended to be the thing that libraries implement on their types that support `box <expr>`
[21:24:00] * nrc nudges eddyb to land his type ascription branch
[21:24:29] <pnkfelix> eddyb: BP is an intermediate structure used by Box<T>'s implementation of the protocol; its not meant for outside users to access
[21:24:58] <pnkfelix> eddyb: Is there some reason you see for it to implement `Boxed` (and thus integrate with the `box` protocol itself in some wacky way?
[21:25:17] <eddyb> I'm just curious what the relationship seems to be... a bit inverted
[21:25:24] <eddyb> *why
[21:25:25] <pnkfelix> eddyb: its certianly *possible* that it could make sense
[21:25:39] <pnkfelix> eddyb: in many ways this code is meant to be illustrative
[21:26:09] <eddyb> I think I can restructure all of this to propagate the right information down
[21:26:25] <eddyb> which may seem counter-intuitive given that Fn is not what you want
[21:26:29] <pnkfelix> eddyb: feel free to try; it took me a long time to even get this version to work
[21:26:53] <pnkfelix> eddyb: but such flexibility for experimentation is the big reason why we stopped pushing to stabilize the protocol
[21:26:57] <eddyb> pnkfelix: have you seen the current vec! implementation?
[21:27:01] <pnkfelix> eddyb: yes
[21:27:15] <eddyb> it's a single expression with no blocks
[21:27:26] <eddyb> I wish we had the equivalent of NRVO for type propagation
[21:27:52] <eddyb> pnkfelix: but what's sad is that your box implementation does not preserve type hints
[21:28:39] <eddyb> I was going to link to https://github.com/rust-lang/rust/blob/master/src/test/run-pass/coerce-expect-unsized.rs
[21:29:11] <eddyb> pnkfelix: how on earth is that test passing?
[21:29:31] <eddyb> OH
[21:29:34] <eddyb> pnkfelix: yes, this is perfect
[21:29:45] <eddyb> just one little tweak :D
[21:33:15] *** WindowsBunny1 is now known as WindowsBunny
[21:34:01] <eddyb> pnkfelix: how did you get away without Boxed: Sized?
[21:34:11] <eddyb> that's super weird
[21:34:46] <eddyb> nmatsakis: is it a bug that methods that return Self only require Self: Sized if they have defaults?
[21:35:20] *** Quits: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net) (Connection closed)
[21:35:27] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[21:35:28] *** ChanServ sets mode: +o pnkfelix
[21:35:56] <eddyb> nmatsakis: also the argument types, I guess
[21:39:13] <eddyb> pnkfelix: so this may work, if we can figure out how to prevent early unification of those type variables with something not Sized http://is.gd/cO8psH
[21:39:59] <pnkfelix> eddyb: hmm, that's interesting
[21:41:28] <pnkfelix> eddyb: but then again, I thought the early unification of type variables with the unsized traits *was* the heart of the problem we were facing
[21:41:40] <eddyb> pnkfelix: it's not early in your case
[21:41:50] <eddyb> your coerce{3,4}, that is
[21:41:59] <eddyb> not as early as possible, anyways
[21:43:11] <eddyb> pnkfelix: in order to do *anything* reasonable, you need the value to be part of the direct downwards expected type propagation
[21:43:27] <eddyb> pnkfelix: these work https://github.com/rust-lang/rust/blob/master/src/test/run-pass/coerce-expect-unsized.rs#L29-L34
[21:43:40] <eddyb> hang on, maybe using associated types was my mistake :P
[21:43:59] <pnkfelix> "these work" as in, under your new suggested protocol?
[21:44:02] <eddyb> no
[21:44:07] <eddyb> that test passes
[21:44:10] <eddyb> with function calls
[21:44:19] <eddyb> I am not sure *how*
[21:44:32] <eddyb> ~magic~
[21:44:37] <eddyb> pnkfelix: just need to reuse that magic
[21:45:07] <pnkfelix> eddyb: Box::new's resulting Box<T> has T:Sized
[21:45:15] <pnkfelix> eddyb: does that help explain it, or not?
[21:45:38] <pnkfelix> eddyb: perhaps not
[21:45:45] <eddyb> pnkfelix: the expected type is propagating down
[21:46:04] <pnkfelix> eddyb: oh because it did not use the int-fallback you mean
[21:46:07] <eddyb> pnkfelix: [_; 3] is being "related" to [int]
[21:46:20] <eddyb> using a specific Expectation variant
[21:46:41] <eddyb> which means something higher up successfully processed the expected type based on its sizedness
[21:49:12] <eddyb> <anon>:40:9: 40:29 error: the trait `Boxed<F>` is not implemented for the type `Box<core::ops::Fn()>` [E0277]
[21:49:25] <eddyb> pnkfelix: I might not be able to grasp the polymorphism properly
[21:49:57] <pnkfelix> hmm
[21:50:11] <eddyb> it's figuring out the right trait!
[21:50:36] <eddyb> let me try inverting the direction of Boxed
[21:52:49] <eddyb> <anon>:40:9: 40:29 error: type annotations required: cannot resolve `<_ as Boxed<F>>::Output == _` [E0284]
[21:52:57] <eddyb> right, that's the polymorphism issue
[21:54:12] <eddyb> pnkfelix: you know what would work :P?
[21:55:30] <eddyb> pnkfelix: impl<T> Boxed<T> for Box<T>; impl<T: Unsize<U>, U> Boxed<T> for Box<U>;
[21:55:37] *** Joins: reem (reem@moz-2icmmi.ca.comcast.net)
[21:56:01] <eddyb> well, `U: !Sized` would be needed
[21:56:02] <pnkfelix> eddyb: I don't know what the Unsize trait is
[21:57:38] <eddyb> pnkfelix: it's introduced by nrc's recent DST coercions RFC
[21:58:03] <eddyb> [T;N]: Unsize<[T]> and T: Unsize<Trait> where T: Trait
[21:58:36] <pnkfelix> eddyb: I see
[22:00:10] <eddyb> so Self is incorrectly... oooh
[22:00:14] <eddyb> pnkfelix: let me check something
[22:02:23] <eddyb> check_argument_types uses Expectation::rvalue_hint(ty) for each argument type ty
[22:05:03] <eddyb> pnkfelix: aha! I have a potential solution
[22:06:50] <pnkfelix> (i'm task switching a lot, so feel free to keep typing, but I'm not likely to respond much)
[22:06:58] <pnkfelix> eddyb: ^
[22:07:44] <eddyb> pnkfelix: after type-checking the arguments of Trait::method(...), attempt selection: if there is a single impl result, use it to obtain Self from argument types, in case it's used in the return type
[22:08:01] <eddyb> i.e. this works for Box because it's an inherent method there
[22:08:08] <eddyb> Box::new in that test, I mean
[22:08:36] <pnkfelix> hmm
[22:08:51] <eddyb> it shouldn't be ever wrong, I don't think
[22:09:11] <pnkfelix> is there a chance that the selection could determine its single at that early stage, and then later it turns out there were multiple ones?
[22:09:23] <eddyb> but has the potential to replace type mismatches with coercions
[22:09:30] <eddyb> pnkfelix: no
[22:09:56] <eddyb> pnkfelix: selection would return a result signifying "ambiguous" if it is not *certain*
[22:10:31] * pnkfelix doesn't know the trait selection algorithm well enough
[22:11:26] <eddyb> pnkfelix: oh, I do wonder if the Self resulting from the impl + trait type params + argument types might result in something too different from the original
[22:11:45] <eddyb> s/resulting/computed/
[22:11:53] <eddyb> nmatsakis: ^^ have you ever considered something like this?
[22:12:44] <eddyb> nmatsakis: it's either this or tracking sizedness :P
[22:20:51] <eddyb> nmatsakis: hmm, did you ever answer the thing about adding an object safety obligation?
[22:28:07] *** Joins: arielb1 (Ariel@moz-33pn30.red.bezeqint.net)
[22:44:35] *** Quits: reem (reem@moz-2icmmi.ca.comcast.net) (Connection closed)
[22:45:46] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Client exited)
[22:57:30] *** Quits: arielb1 (Ariel@moz-33pn30.red.bezeqint.net) (Quit: Ex-Chat)
[22:59:10] *** kimundi is now known as zz_kimundi
[23:50:31] <pnkfelix> nmatsakis: ping
[23:51:15] <pnkfelix> nmatsakis: nm

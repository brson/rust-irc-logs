[00:15:35] *** Quits: gsingh93 (uid22642@moz-aq0iah.charlton.irccloud.com) (Quit: Connection closed for inactivity)
[00:44:22] *** Quits: o11c (ben@moz-9bd9kh.customer.t3.se) (Ping timeout: 121 seconds)
[00:48:55] *** Joins: o11c (ben@moz-9bd9kh.customer.t3.se)
[01:29:13] <Ilari> Lol: 'In flipping through Microsoft's "constant-time" ECCLib_v1.1, I noticed'
[01:32:16] <Ilari> Wonder if MS ECClib would pass valgrind undefined-key tests...
[01:54:30] <Ilari> Lol: "Well, it *is* OpenSSL, what were you expecting?"
[01:56:23] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:03:21] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:10:32] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Ping timeout: 121 seconds)
[02:17:56] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[02:31:23] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:45:18] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[02:50:27] <Ilari> Hah, On SSL labs forum, there's a post seeking help resolving "obsolete crypto" warning. Looks like the user intended to disable RC4, but it ended up being enabled instead. :->
[02:52:28] <Ilari> Wonder if one could get OpenSSL to deimplement RC4 in TLS (it is MUST NOT use nowadays).
[03:07:01] <Ilari> Good way to sabotage crypto: Make crypto config way too hard to use and way too easy to configure broken ciphers (I think you can even configure openSSL to break TLS version negotiation).
[03:08:01] *** Joins: erickt (erickt@moz-hc1ntj.sntcca.sbcglobal.net)
[03:25:20] <mcpherrin> Ilari: I worry that would lead to people using outdated OpenSSL to get RC4, though
[03:27:05] <eternaleye> mcpherrin: At some point, idiocy is its own reward.
[03:27:25] <eternaleye> mcpherrin: Better to make it safe for people who aren't intentionally doing crazy things.
[03:28:29] <Ilari> Heck, soon one could also point to reasons for deimplementing SSL 3.0
[03:32:22] *** Joins: adu (ajr@moz-melbkr.ms5a.74ae.000a.2601.IP)
[03:43:08] *** Parts: adu (ajr@moz-melbkr.ms5a.74ae.000a.2601.IP) ("")
[03:47:20] *** Joins: adu (adu@moz-melbkr.ms5a.74ae.000a.2601.IP)
[04:13:02] *** Quits: erickt (erickt@moz-hc1ntj.sntcca.sbcglobal.net) (Ping timeout: 121 seconds)
[04:24:53] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:35:10] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[06:38:39] *** Quits: adu (adu@moz-melbkr.ms5a.74ae.000a.2601.IP) (Quit: Leaving)
[06:56:28] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[08:01:47] *** Joins: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP)
[08:06:00] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Client exited)
[08:41:46] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[08:42:09] *** Joins: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP)
[08:43:08] *** Joins: ttaubert (uid2620@moz-6d2u0s.uxbridge.irccloud.com)
[09:56:17] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:15:02] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Connection closed)
[13:15:48] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[14:17:48] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[15:25:47] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[15:57:41] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[16:18:16] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:11:30] <bascule> https://twitter.com/kennyog/status/577470959843700736
[17:11:34] <bascule> Kenny Patterson strikes again
[17:36:37] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[17:45:28] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (A TLS packet with unexpected length was received.)
[17:54:08] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[18:18:43] <Ilari> Also, I don't personally view using the same point format for both ECDH and signatures as practicularly good idea. Montgomery-X is very good for ECDH. But even Montgomery-X+sign isn't very good for signatures.
[18:25:21] <bascule> yeah
[18:25:45] <bascule> and if you make your public identity a signature key, you can sign your ephemeral ECDH keys! :o
[18:26:03] <Ilari> Signatures are much more complicated than ECDH, even if you use schemes where those are practicularly simple like EdDSA.
[18:26:10] <bascule> I guess that's what trevp is trying to avoid with Noise though
[18:27:48] <Ilari> ECDSA (including FrankenECDSA) are even more complicated as one needs to make lots of interrim reductions modulo scalar order.
[18:28:57] <bascule> use EdDSA :o
[18:29:04] <lahwran> who is ed
[18:30:12] <tiffany> lots of similar initialisms
[18:30:49] <klutzy> http://en.wikipedia.org/wiki/Harold_Edwards_(mathematician)
[18:31:00] <klutzy> -> Edwards curve -> EdDSA
[18:34:34] <Ilari> Paypal is RC4-only, but does TLS 1.2? They didn't even enable the ciphers that require TLS 1.2?
[18:36:22] <bascule> hahahahahahaha
[18:36:26] <bascule> yeah that's so weird eh Ilari?
[18:47:56] <Ilari> Hmm... Should browsers update the "green bar" conditions to included TLS 1.2+? :->
[18:49:02] <Ilari> ... And not RC4.
[19:03:03] <Ilari> Now where's that poll? It has to come rather quick for it to have time to finish before CFRG session at IETF92...
[20:14:14] *** Joins: Tobba|Laptop (Tobba@moz-o13d22.bredband.telia.com)
[20:18:19] *** Quits: Tobba|Laptop (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[20:43:48] <Ilari> bascule: OMG at the OAuth and HTTPS(!) proxy guys at unbearable...
[20:57:14] <eternaleye> Ilari: The list living up to its name?
[21:10:51] <Ilari> Okay, new openSSL release, fixing high-severity vulns (FREAK was low-severity, so...)
[21:11:29] <mcpherrin> Ilari: today?
[21:12:53] <Ilari> Ah, preannoucment, release to be out 19th.
[21:13:57] <mcpherrin> Yeah, I just saw in #crypto and then on the mailing list :)
[21:17:44] <bascule> Ilari: perhaps they're trying to reinvent this? https://jasig.github.io/cas/development/images/cas_proxy_flow_diagram.jpg
[21:17:55] <bascule> which is TERRIBLE
[21:17:57] <bascule> BURN THAT DIAGRAM
[21:18:01] <bascule> IT MAKES MY EYES BLEED
[21:22:00] <Ilari> Well, maybe the OpenSSL hole is something on the severity of "Winshock". :-)
[21:22:29] <bascule> yeah
[21:22:32] <bascule> RCE would be my guess
[21:24:43] <Tobba> winshock is reserved for winsock bugs
[21:25:09] <bascule> https://twitter.com/bascule/status/577581321956016128
[21:27:57] <bascule> you know what's funny
[21:28:03] <bascule> I'm handrolling a Macaroons "parser"
[21:28:14] <bascule> and it feels so dirty
[21:28:18] <bascule> but I'm doing it in Rust
[21:28:25] <bascule> and in C, fucking that up is Remote Code Execution
[21:32:34] <Ilari> Do I think openSSL is trustworthy? Hell no.
[21:43:23] <bascule> lolololol
[21:43:36] <bascule> I was dusting this off over the weekend: https://cleancrypt.org/
[21:43:54] <cmr> swag
[21:44:42] <cmr> I've been... mucking about in blas/lapack...
[21:44:47] <cmr> very very unsexy
[21:45:32] <Ilari> Also, shouldn't be hard to write RFC about volatile_set_memory / volatile_set_bytes, right?
[21:45:45] <bascule> Ilari: you should totally do that! :D :D :D
[21:45:59] <cmr> Ilari: not at all
[21:46:47] <Ilari> (I think most of the RFC woudl be about why the function is needed).
[21:46:52] <Ilari> *would
[21:47:54] <bascule> https://mta.openssl.org/pipermail/openssl-commits/2015-March/000669.html
[21:48:26] <cmr> that sucks
[21:54:12] <Ilari> Random numbers are important.
[22:00:16] *** Quits: ttaubert (uid2620@moz-6d2u0s.uxbridge.irccloud.com) (Quit: Connection closed for inactivity)
[22:29:22] <Ilari> Haha: "@kennyog This is just revenge on TLS WG because they asked CFRG for curves."
[22:37:17] *** Quits: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net) (Connection closed)
[22:37:54] *** Joins: WindowsBunny (Peter@moz-gv8vtu.east.verizon.net)
[22:44:10] <Ilari> BTW, here's the current list of unstable functions this complex of several crates is using: http://codepad.org/cy10bDNA
[22:47:30] <huon> there's a thread on users.rust-lang.org where that info would be more useful :)
[22:52:20] <Ilari> Actually, probably a couple more than what was tagged as unworkaroundable are in fact very nasty to even try to workaround (if at all possible).
[22:54:31] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[22:54:53] <Ilari> One of the crates has implementation of global hashmap that can store multiple key types (each with associated value type) at once.
[22:55:27] <Ilari> (That's the one using static rw locks and typeid)
[23:01:37] <Ilari> I used to have some very type-unsafe code implementing that (complete with fair amount of hairy C code) before replacing it with Rust implementation...
[23:03:07] <bascule> you know what I really want?
[23:03:22] <bascule> a vector type that does a volatile zero on drop
[23:03:31] <bascule> ZeroingVec?
[23:04:07] <lahwran> that would be super cool
[23:04:26] <eternaleye> bascule: Could that be done with a minimal wrapper type on the value?
[23:04:59] <bascule> I think so! especially if it were in the stdlib and could call into unstable LLVM intrinsics that tend to move around a lot
[23:05:02] <eternaleye> bascule: struct Zeroing<T>(T); impl Borrow<T> for Zeroing<T> {}; impl Drop for Zeroing<T> { /// unsafe erase }
[23:05:13] <bascule> sure, a generic zeroing wrapper would be sweet
[23:05:46] <eternaleye> bascule: The main issue there is memcpy-move
[23:05:55] <eternaleye> bascule: I don't think there's a way to inhibit that...
[23:06:26] <eternaleye> bascule: Might be possible to get an PhantomImmobile or whatever marker, though
[23:07:43] <Ilari> Also, what TLS features are very rarely or almost never used and could be dropped? What TLS extensions could be mainlined?
[23:07:49] * bascule happy with best effort, and wrapping this up in a generic means that all future improvements can concentrate on improving the generic and then everything that uses it gets that for free
[23:07:55] <bascule> brson: ^^^ !!!
[23:08:27] <bascule> sounds like good stuff to try to work into the existing zeroing RFC
[23:08:39] <bascule> or should I say (non-)zeroing RFC
[23:09:44] <eternaleye> bascule: Honestly, Zeroing<T> + PhantomImmobile would _guarantee_ proper zeroing; at the cost of not being movable ever. A Move trait would solve the whole issue, and then Zeroing<T> could just impl Drop and Move
[23:10:10] <bascule> those seem like beneficial properties to me ;)
[23:10:27] <eternaleye> bascule: Sometimes, moving is okay, but you want the temporaries erased
[23:10:33] <bascule> indeed
[23:10:44] <bascule> moving seems fine if you clean up your mess ;)
[23:10:52] <bascule> s/mess/secrets/
[23:11:18] <eternaleye> Anyway, the way I see it, Move would be very much like Drop - inhibits Copy, etc.
[23:12:04] <bascule> I think the imporant part is the secret gets erased each time it's moved
[23:12:15] <bascule> having multiple copies in memory is okay
[23:12:16] <eternaleye> Tricky thing would be only calling Move::move on actual moves, not just semantic/syntactic moves
[23:12:19] <bascule> if you want better buffers use TARS
[23:12:21] <bascule> ;)
[23:12:28] <eternaleye> Otherwise, a lot of things get really painful
[23:14:30] <eternaleye> But since Rust relies on LLVM for move elision IIRC, that could be very difficult - since from Rust's POV, every move is a real move
[23:14:54] <eternaleye> Might be possible if Move::move is called by something that is used instead of memcpy for moves...
[23:15:10] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[23:16:51] <eternaleye> Ilari: TLS should be relegated to establishing a channel with I and C, that has a channel-binding to enable A.
[23:17:03] <eternaleye> Ilari: Anything further should DIAF
[23:18:10] <adu> DIAF?
[23:18:16] <adu> that's harsh
[23:18:47] <lahwran> how about just D
[23:18:53] <adu> or J?
[23:18:59] <lahwran> I don't know what J would mean
[23:19:04] <lahwran> D as in die
[23:19:13] <adu> in a fire
[23:19:27] <eternaleye> adu: lahwran was suggesting that perhaps the fire was overkill
[23:19:31] <adu> Jump in a fire?
[23:19:35] <eternaleye> adu: (but that it should still die)
[23:19:55] <adu> what's I, C, A?
[23:21:05] <eternaleye> Integrity, Confidentiality, Authentication
[23:21:34] <eternaleye> So an attacker can't falsify messages, can't observe plaintext, and can't impersonate another party
[23:21:50] <Ilari> Strapping AEAD and exporter on top of Diffie-Hellman? Doesn't sould very hard.
[23:22:15] <eternaleye> Pretty much.
[23:22:50] <eternaleye> With channel-binding you can do any auth you need
[23:23:17] <eternaleye> Certificates? Use a signature to attest to the binding.
[23:23:31] <eternaleye> Passwords? There are SO MANY ways.
[23:24:13] <eternaleye> Macaroons with a caveat on the channel binding? Oh hell yes.
[23:24:47] <adu> I thought macaroons were cookies?
[23:25:20] <eternaleye> adu: They're conditionalized - one  tricky thing is that macaroons conditionalized on channel bindings could probably be used for channel equality
[23:25:37] <lahwran> are we still talking about cryptography?
[23:25:43] <eternaleye> lahwran: Yup!
[23:26:42] <eternaleye> lahwran: Macaroons are basically bearer credentials with crypto-protected conditional validity specifications, as I understand them
[23:27:12] <Ilari> draft-ietf-tls-sslv3-diediedie -> Last Call requested.
[23:27:16] <eternaleye> :D
[23:27:24] <lahwran> what
[23:29:38] <eternaleye> Ilari: Anyway, IMO the 'right' replacement for TLS would be a parameterized composition of KEX and AEAD with channel binding, that acts like a SOCK_DGRAM
[23:30:01] <eternaleye> Ilari: Because SOCK_STREAM is awful for building on top of
[23:31:13] <eternaleye> Ilari: I also feel it should be able to run on _top_ of arbitrary SOCK_DGRAM
[23:31:37] <eternaleye> Ilari: A nice, composable layer.
[23:31:42] <bascule> eternaleye: perhaps a different trait that actually handles the move?
[23:31:47] <bascule> Mover?
[23:32:06] <eternaleye> bascule: That's what I'd want Move to be.
[23:32:09] <bascule> aah
[23:32:20] <eternaleye> bascule: Well, no
[23:32:36] <eternaleye> bascule: I want Move::move to take the old location and the new location, both mutably
[23:32:43] <bascule> seems good
[23:32:49] <eternaleye> bascule: It executes after the actual move
[23:33:34] <eternaleye> bascule: The idea is that it'd also be useful for, say, fixing up pointers in other members of a linked datastructure and such
[23:34:03] <eternaleye> bascule: So knowing both memory addresses, being able to mutate, and having access to the values of the moved structure, are all necessary
[23:34:31] <eternaleye> bascule: a GC might use Move to handle shoving stuff between arenas, say.
[23:36:37] <eternaleye> bascule: So a GC would be cool with types that are Copy or Move, since both could be transferred between generational arenas
[23:37:04] <bascule> yeah, seems good

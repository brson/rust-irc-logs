[00:04:13] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[00:37:44] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[02:18:12] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[02:37:24] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[03:39:19] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[13:35:51] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:28:07] <nmatsakis> HRTB make WF checking extra... fun. 
[19:53:20] <nmatsakis> aturon: you gotta second to talk through something ?
[19:53:25] <aturon> nmatsakis: sure!
[19:53:41] <nmatsakis> so i've been working more on the RFC related to projections and outlives
[19:54:00] <nmatsakis> one of the things I'm trying to be careful and think through is WF checking and the interaction with HRTB :)
[19:54:08] <nmatsakis> we're currently doing WF checking in a kind of haphazard way
[19:54:16] <nmatsakis> in some places it is not enforced where it should be
[19:54:21] <nmatsakis> and in others, it is enforced more than it needs to be :)
[19:54:27] <nmatsakis> (which just waits compilation time ...0
[19:54:28] <aturon> heh, yes
[19:54:36] <nmatsakis> part of the reason for this is that the compiler
[19:54:39] <nmatsakis> combines "outlives" and "WF"
[19:54:46] <nmatsakis> I've pulled them apart into two distinct notions in the RFC
[19:54:50] <nmatsakis> and I think it makes things much cleaner
[19:54:53] <nmatsakis> but:
[19:54:59] <nmatsakis> well, to briefly summarize
[19:55:21] <nmatsakis> in the RFC, `T: 'a` means basically "all lifetimes in T outlive 'a"
[19:55:32] <aturon> yes
[19:55:41] <nmatsakis> for projections it's a bit subtle
[19:55:48] <nmatsakis> in that there are 3 relevant rules
[19:55:54] <nmatsakis> but anyway the thing I wanted to talk about was:
[19:56:07] <nmatsakis> if you have higher-ranked lifetimes, like for<'a,'b> fn(&'a &'b T)
[19:56:10] <nmatsakis> and you say
[19:56:15] <nmatsakis> for<'a,'b> fn(&'a &'b T): 'c
[19:56:31] <nmatsakis> then in the inference rules I wrote up, you wind up ignoring 'a and 'b because they are bound, bsically
[19:56:44] <nmatsakis> similarly,
[19:56:46] <aturon> which seems like you've actually lost the constraint?
[19:57:01] <nmatsakis> well, depends on your POV I guess
[19:57:04] <aturon> presumably fn(&'a &'b T): 'c actually checks 'a against 'c ?
[19:57:08] <nmatsakis> maybe I shoudl written
[19:57:14] <nmatsakis> "all FREE lifetimes in T outlive 'a" :)
[19:57:25] <nmatsakis> yes
[19:57:29] <nmatsakis> if they are not bound
[19:57:30] <nmatsakis> they are checked
[19:57:33] <aturon> right, such a property then isn't invariant under instantiation
[19:57:34] <nmatsakis> even if they appear in fn arguments
[19:57:43] <aturon> (which could be problematic?)
[19:57:52] <nmatsakis> (yes, that is correct, but I don't think it's problematic)
[19:57:55] <aturon> ok
[19:58:10] <nmatsakis> though that is the sort of thing I am trying to be careful about :)
[19:58:21] <nmatsakis> so in particular, with the WF checking,
[19:58:22] <aturon> i suspect for/where would give you a way to do otherwise
[19:58:25] <aturon> but anyway.
[19:58:27] <nmatsakis> yes, it would.
[19:58:50] <nmatsakis> basically, WF checking is checking that the declared where clauses are met, primarily
[19:58:56] <nmatsakis> in some cases there are "builtin"  where clauses
[19:59:28] <nmatsakis> https://github.com/nikomatsakis/rfcs/blob/projection-and-lifetimes/text/0000-projection-and-lifetimes.md#the-wf-relation
[19:59:49] <nmatsakis> (hmm, \ell renders weird there...)
[20:00:17] <aturon> (reading the rules)
[20:00:44] <aturon> in WfTrait,
[20:00:49] <aturon> the premise is missing a WF i think?
[20:00:55] <aturon> well
[20:00:57] <aturon> or something
[20:01:13] <nmatsakis> well
[20:01:14] <nmatsakis> that's an error
[20:01:17] <nmatsakis> that shoudl be deleted
[20:01:30] <nmatsakis> in particular there is WfObject below
[20:01:34] <nmatsakis> but there are no real criteria :)
[20:01:38] <nmatsakis> which is kidn of what I wanted to talk about
[20:02:07] <aturon> hm right, ok
[20:02:11] <nmatsakis> so, with higher-ranked things (and lacking for/where), you can't enforce the WF criteria in any obvious way,
[20:02:15] <nmatsakis> so what I was thinking is that we defer that
[20:02:16] <aturon> so this is precisely the issue about where clauses and HRTB
[20:02:22] <nmatsakis> until the "instantiation" point
[20:02:36] <nmatsakis> which seems...probably ok :) for types
[20:02:58] <nmatsakis> (the major concern here is that implied bounds work out, primarily)
[20:03:02] <nmatsakis> but also I guess that 
[20:03:11] <nmatsakis> it is relevant to deciding
[20:03:15] <nmatsakis> JUST WHERE do we have to do WF checking
[20:03:19] <nmatsakis> to ensure that all types we wind up with are WF
[20:03:28] <nmatsakis> e.g., we had better check that the return type is WF when you call
[20:03:32] <nmatsakis> or else it could become the type of an expression
[20:03:32] <nmatsakis> etc
[20:03:47] <nmatsakis> with me thus far?
[20:04:11] <aturon> yep
[20:04:25] <aturon> (this all makes me vaguely uncomfortable, but you know that already :)
[20:04:42] <aturon> by "all" i mean the deferring
[20:04:53] <nmatsakis> yes I know that already
[20:04:55] <nmatsakis> ;)
[20:05:14] <aturon> but yes, this formalization matches the intuitions we'd discussed before
[20:05:17] <nmatsakis> so then I was working through WF evaluation e.g. on structs and so forth 
[20:05:27] <nmatsakis> and imaging first this:
[20:05:34] <nmatsakis> struct Foo<T: Trait<SomeType>>
[20:05:39] <nmatsakis> presumably if that trait is declared
[20:05:45] <nmatsakis> trait Trait<T:Copy>
[20:05:50] <nmatsakis> and SomeType: Copy is not true
[20:05:53] <nmatsakis> we should declare an error?
[20:06:00] <nmatsakis> or it'd seem nice if we did :)
[20:06:02] <aturon> yes
[20:06:06] <nmatsakis> that is, this is not so much WF on TYPES
[20:06:08] <nmatsakis> as it is WF on trait references
[20:06:23] <nmatsakis> anyway, ok, but trait refs can be HR too
[20:06:24] <aturon> yes
[20:06:26] <nmatsakis> so
[20:06:38] <nmatsakis> struct Foo<T: for<'a> Trait<&'a SomeType>>
[20:06:43] <aturon> suddenly, no error
[20:06:45] <nmatsakis> what are the rules for that to be WF?
[20:06:49] <nmatsakis> do we require
[20:06:57] <nmatsakis> for<'a> (&'a SomeType: Copy)
[20:07:03] <nmatsakis> (which I've argued is too strict)
[20:07:17] <nmatsakis> or do we defer this to an instantiation point? 
[20:07:21] <nmatsakis> I could imagine that there is such a point
[20:07:25] <nmatsakis> e.g. where we rely on it in trait judgement
[20:07:28] <nmatsakis> but ...
[20:07:36] <nmatsakis> doesn't feel as nic
[20:07:42] <nmatsakis> the other one already felt a bit annoying
[20:07:43] <nmatsakis> this feels more so
[20:08:04] <nmatsakis> the example was not great in that
[20:08:11] <nmatsakis> for<'a> (&'a SomeType: Copy) holds :)
[20:08:16] <aturon> right
[20:08:19] <aturon> but i take the point
[20:08:33] <aturon> in particular,
[20:08:39] <nmatsakis> it's more the requirement that for<'a> SomeType: 'a
[20:08:50] <nmatsakis> which also holds in this case, I guess, but anyway
[20:08:50] <aturon> the trait could take two parameters, one where a lifetime was involved and the other where you put SomeType
[20:09:06] <aturon> and the fact that HRTB is "blocking" checking for SomeType feels arbitrary
[20:09:10] <nmatsakis> right so
[20:09:11] <nmatsakis> with types
[20:09:12] <aturon> (since instiation doesn't affect it)
[20:09:15] <nmatsakis> this is why I said
[20:09:17] <nmatsakis> we just don't check at all
[20:09:24] <nmatsakis> so if we were going to a deferred scheme
[20:09:28] <nmatsakis> that's probably what it woudl mean
[20:09:37] <nmatsakis> we don't check where clauses in the def'n, but rather at some later time when they are "used"
[20:09:42] <aturon> right
[20:09:50] <nmatsakis> then at least you are consistent :)
[20:10:02] <aturon> so, just to be clear, is your main worry here the error messages?
[20:10:03] <nmatsakis> anyway I started to get worried
[20:10:07] <nmatsakis> well
[20:10:10] <nmatsakis> not so much that
[20:10:18] <aturon> or are you unsure there's a "right point" to check?
[20:10:27] <nmatsakis> more that
[20:10:33] <nmatsakis> and a bit 
[20:10:42] <nmatsakis> that this means our environment is kind of..."untrusted" :)
[20:11:04] <aturon> say more?
[20:11:16] <nmatsakis> well, the where clauses go into the environment, but we haven't validated them for WF-edness yet
[20:11:33] <nmatsakis> so I think that "right point" will basically be when we pull them out from the env and put them to use
[20:11:42] <nmatsakis> which is also the point where they are fully instantiated
[20:12:01] <aturon> i see
[20:12:11] <aturon> it does seem bug-prone at least
[20:12:14] <nmatsakis> I was also worrying if somehow
[20:12:21] <nmatsakis> a where-clause could "justify itself
[20:12:26] <aturon> but not entirely surprising that you'd end up with these corners with the deferral approach
[20:12:30] <nmatsakis> yes
[20:12:33] <nmatsakis> there is also the other side
[20:12:36] <nmatsakis> to consider
[20:12:37] <nmatsakis> so when you call a fn
[20:12:38] <aturon> ah hm, before getting checked for WF or something?
[20:12:51] <aturon> allowing you to skip the WF check altogether, perhaps
[20:12:51] <nmatsakis> (yeah, I don't know, I can't make that into a firm concern)
[20:12:57] <nmatsakis> (but that is what I was afraid of)
[20:13:04] <nmatsakis> so when you call a fn
[20:13:11] <nmatsakis> which has let's say a where clause like
[20:13:19] <nmatsakis> for<'a> T: Foo<&'a U>
[20:13:27] <nmatsakis> then we have to show that this holds
[20:13:31] <nmatsakis> but we don't yet know it's WF of course
[20:13:36] * nmatsakis tries to remember how this code works
[20:13:48] * nmatsakis realizes he can read it
[20:13:53] <aturon> :)
[20:14:08] <nmatsakis> just want to remember what gets instantiated with what... one sec...
[20:14:13] <nmatsakis> but presumably this means
[20:14:16] <nmatsakis> also the WC that we have to check
[20:14:19] <nmatsakis> must be WF-validated
[20:14:32] <nmatsakis> I'm trying to remember if there is an "obvious point"
[20:14:32] <nmatsakis> to do that
[20:14:53] * nmatsakis grumbles about stupid where clauses on structs and traits grumble grumble
[20:15:45] <aturon> heh, indeed... in hindsight, if this specialization design goes through, we'd hardly need them
[20:16:04] <nmatsakis> ok so
[20:16:09] <aturon> (except for assoc types...)
[20:16:23] <nmatsakis> well, yeah, assoc types really need them tho
[20:16:39] <aturon> (i mean on structs/trait specifically)
[20:16:47] <aturon> (to be able to project, e.g. in the definition of Cow)
[20:17:03] <nmatsakis> yes I know
[20:17:05] <nmatsakis> what you mean
[20:17:10] <nmatsakis> and that is the "killer use case"
[20:17:10] <aturon> ok
[20:17:19] <nmatsakis> so the way this works is that we
[20:17:24] <nmatsakis> skolemize the thing we must prove (naturally...)
[20:17:32] <nmatsakis> create inference variables for the impl's parameters
[20:17:49] <nmatsakis> relate them, and check for "leaks"
[20:17:54] <nmatsakis> so yer basic algorithm basically
[20:18:00] <nmatsakis> makes sense
[20:18:01] <aturon> :)
[20:18:12] <nmatsakis> I feel like all I do these days is thing about higher-ranked things
[20:18:28] <nmatsakis> anyway, so, that's kind of weird though right because
[20:18:53] <nmatsakis> well so the point where things are fully instantiated
[20:19:00] <nmatsakis> they are instantiated with skolemized things
[20:19:27] <nmatsakis> so that seems checking that those are WF is sort of equivalent to generating HR-versions of the WF requirements?
[20:20:03] <nmatsakis> for<'a> T: Trait<&'a U> -> T: Trait<&'A U>, we'd then check for WF on &'A U (where 'A is this skolemized lifetime)
[20:20:38] <nmatsakis> incidentally
[20:20:42] <nmatsakis> I'm also not sure how for/where helps here ;)
[20:20:53] <nmatsakis> well I mean I can see how it might but it's like
[20:20:57] <nmatsakis> where clauses on where clauses on where clauses ;0
[20:21:12] <aturon> ah, you mean, you end up having to have layers of WF checking
[20:21:20] <nmatsakis> (though I can imagine wanting it for like for<K> CollectFrom<K> where K: sized)
[20:21:20] <aturon> or something like that
[20:21:37] <nmatsakis> yeah, I'm kind of trying to decide what WF means here :)
[20:22:08] <nmatsakis> like if I have
[20:22:13] <aturon> hm so, i wonder if thinking about for/where,
[20:22:17] <aturon> can shed light on this approach actually
[20:22:29] <aturon> for <'a, 'b> fn(&'a &'b T)
[20:22:38] <aturon> would not be wellformed
[20:22:41] <aturon> in a for/where world
[20:22:56] <nmatsakis> an aside: for/where is actually ... kind of a generalization of the deferal approach, right?
[20:22:57] <aturon> you have to have `for <'a, 'b> vn(&'a &'b T) where 'b: 'a`
[20:23:26] <nmatsakis> (well anyway, leave that comment aside for a sec, I'll explain what I meant later)
[20:23:35] <nmatsakis> but yes that was the basic idea
[20:23:36] <aturon> (ok, i have some guess)
[20:23:38] <nmatsakis> but so in this context
[20:23:44] <nmatsakis> for<'a> T: Trait<&'a U>
[20:23:47] <nmatsakis> where the trait is declared as
[20:23:55] <nmatsakis> well actually
[20:24:02] <nmatsakis> in a sense we don't need to declare the trait as anything
[20:24:05] <nmatsakis> that is
[20:24:13] <nmatsakis> presumabl a trait ref P0: Trait<P1..Pn>
[20:24:19] <nmatsakis> is only WF if Pi WF
[20:24:21] <aturon> (actually that side comment made me suddenly more comfortable with the deferral approach)
[20:24:28] <nmatsakis> (that was it's aim ;)
[20:24:41] <nmatsakis> or rather
[20:24:53] <nmatsakis> I was wondering if we could find a way to phrse the deferal approach as a limited form of for/where
[20:24:58] <aturon> yes
[20:25:05] <nmatsakis> (though I think you need invariance for that) 
[20:25:12] <nmatsakis> anyway back to the question at hand so
[20:25:25] <nmatsakis> for<'a> T: Trait<&'a U> already requires the component types to be WF
[20:25:32] <nmatsakis> so basically the judgement for WF wants to be
[20:25:38] <nmatsakis> not just T WF
[20:25:42] <nmatsakis> but <'a...'z> T WF
[20:25:45] <nmatsakis> i.e., with <'a..'z> bound
[20:25:53] <nmatsakis> but I don't know what that means
[20:25:59] <aturon> hold on, i'm confused
[20:26:01] <aturon> when you say that
[20:26:02] <nmatsakis> me too :)
[20:26:07] <aturon> it already requires the components to be WF,
[20:26:11] <aturon> that doesn't match the proposed rule
[20:26:19] <nmatsakis> right by "already" I meant
[20:26:31] <nmatsakis> if we were going to try do some kind of for/where-like concept
[20:26:36] <aturon> ok
[20:26:46] <nmatsakis> I guess what I'm saying is
[20:26:48] <nmatsakis> as simple as
[20:26:59] <nmatsakis> there is a kind of "where clause" like "T WF"
[20:27:05] <nmatsakis> you can't write it right now but
[20:27:17] <nmatsakis> for<'a> where<&'a U> T: Trait<&'a U>
[20:27:31] <nmatsakis> might be the "for/where" version?
[20:27:44] <nmatsakis> where just saying "&'a U" just means "this type is WF"
[20:27:47] <aturon> i see
[20:27:50] <nmatsakis> I guess you can expand that out to more base predicates like
[20:27:56] <nmatsakis> for<'a> where<U: 'a> T: Trait<&'a U>
[20:27:56] <aturon> that seems... redundant
[20:28:02] <aturon> well
[20:28:03] <aturon> hm
[20:28:07] <aturon> no i guess not
[20:28:24] <aturon> well, so the point is,
[20:28:31] <aturon> for a for/where to be WF,
[20:28:40] <aturon> you need to have sufficient `where` clause to prove its components WF
[20:28:47] <aturon> and what you're adding here is a simple syntax for saying exactly that
[20:28:51] <aturon> ?
[20:28:54] <nmatsakis> right
[20:28:56] <nmatsakis> so I was just thinking
[20:29:06] <nmatsakis> maybe the caller doesn't have to check WF,
[20:29:08] <nmatsakis> in the sense that,
[20:29:23] <nmatsakis> if we can show that the system will only prove WF trait refs
[20:29:49] <nmatsakis> not sure if that makes sense yet :)
[20:30:07] <aturon> the caller doesn't have to check WF of what, exactly?
[20:30:08] <aturon> basically,
[20:30:15] <aturon> this makes it seem like the caller just needs to check the where clause
[20:30:17] <aturon> and that will imply WF
[20:30:18] <aturon> right?
[20:30:26] <nmatsakis> that is what i'm sort of hoping is true ;)
[20:30:34] <aturon> that's what i'd hope for/where would give you
[20:30:36] <nmatsakis> but I think that you do want to check WF also at projections
[20:30:39] <nmatsakis> in fact
[20:30:51] <nmatsakis> (right re: for/where)
[20:30:56] <nmatsakis> so basically what I'm thinking is
[20:31:01] <nmatsakis> the "deferal point" 
[20:31:04] <nmatsakis> i.e., where we check the where clauses :)
[20:31:40] <nmatsakis> is probably more when the callee "make's use" of the where clause,
[20:31:44] <nmatsakis> and (perhaps) in the impl
[20:31:50] <nmatsakis> er, makes use of
[20:31:57] <nmatsakis> not sure where those quotes and apostrophe came fgrom
[20:32:29] * nmatsakis thinks about this
[20:32:33] <aturon> ok, this is sounding like a reasonable argument that for/where and deferral boil down to the same thing,
[20:32:55] <aturon> except in the case where you can alter the type/constraints in some way prior to the deferred checking
[20:32:59] <aturon> (a la variance)
[20:33:32] <aturon> that is, the constraints we'd require in for/where are precisely WF of the substitution,
[20:33:38] <aturon> so it should be kosher to just check *that* later,
[20:33:45] <aturon> and not bother to write/track the constraints along the way
[20:33:51] <aturon> as long as we know they can't meaningfully change...
[20:33:53] <nmatsakis> aturon: that was the equivalence I was hinting at, yes 
[20:34:15] <nmatsakis> I think perhaps the difference is in the question of
[20:34:17] <nmatsakis> when a where clause is checked
[20:34:19] <nmatsakis> that is, 
[20:34:30] <nmatsakis> is something like
[20:34:45] <nmatsakis> for<> where<T:'a> fn(&'a T) 
[20:34:45] <nmatsakis> legal
[20:34:53] <nmatsakis> because that is what our system (as I've been writing it up)
[20:34:54] <nmatsakis> amounts to
[20:35:09] <nmatsakis> (though you could imagine "eagerly" checking WF when you can)
[20:35:14] <nmatsakis> so it's not really a big difference
[20:35:23] <nmatsakis> that is, these are all kind of... "policy" decisions
[20:35:27] <aturon> right
[20:35:46] <aturon> somehow this reminds me of C++-style templates versus generics
[20:35:49] <nmatsakis> yes
[20:35:52] <nmatsakis> funny
[20:39:21] <nmatsakis> aturon: ok so I feel somewhat better, but I still feel like I have to work out just how the "reliance" scheme works out for where-clauses etc (i.e., who is assuming and who is guaranteeing ;)
[20:40:03] <aturon> yes. i wish it were more plausible to see it all as a set of rules,
[20:40:12] <aturon> but the actual locations of WF checking are not so easy to formulate
[20:40:41] <aturon> also, i once more feel like we're reinventing a wheel that SMT solvers have had to deal with
[20:40:49] <aturon> (for extensions that can touch on first order logic)
[20:42:11] <nmatsakis> aturon: yes, I know, I'm trying to decide how to bone up on that sort of thing. Not sure where to start.
[20:42:46] <nmatsakis> though my experience is it's often a good idea to take a good shot at implementing something first before reading up on how other's did it; it makes you understand that work much better
[20:45:26] <aturon> yep, not saying we're in a position to re-use just yet
[21:36:37] <nmatsakis> aturon: it's kind of hard to avoid talking about invariance in this RFC, but I guess I can just by pretending I don't know about the soundness hole :)
[21:36:46] <nmatsakis> (or saying it'll be discussed in another RFC...)
[21:37:02] <aturon> hah, the latter sounds fine :P
[21:37:35] <nmatsakis> aturon: still I feel like it's .. sort of falling into place
[21:37:47] <nmatsakis> almost feels clean
[21:37:51] <nmatsakis> now I have to go map this to the code somehow
[21:37:57] <nmatsakis> ;)
[21:39:50] <aturon> nmatsakis: very good to hear!
[21:40:24] <nmatsakis> I'm now obsessed with writing a LR parser generator for some reason. Having difficulty not working on that.
[21:40:27] <nmatsakis> ;)
[21:40:37] <nmatsakis> not in macros this time

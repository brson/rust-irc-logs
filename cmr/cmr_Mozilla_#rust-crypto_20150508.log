[00:08:06] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[00:22:39] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[00:35:29] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[00:50:55] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[00:51:31] *** Joins: brson (brson@moz-r1h.uhc.47.96.IP)
[01:25:19] *** Joins: Lurkin2 (Lurkin@moz-p4efgs.mpls.qwest.net)
[01:27:20] *** Quits: brson (brson@moz-r1h.uhc.47.96.IP) (Quit: leaving)
[01:27:56] *** Joins: brson (brson@moz-k0d.pdv.48.37.IP)
[01:28:47] *** Quits: Lurkin (Lurkin@moz-p4efgs.mpls.qwest.net) (Ping timeout: 121 seconds)
[02:32:49] *** Joins: skeuomorf (skeuomorf@moz-h8l.u8d.32.197.IP)
[02:53:52] *** Quits: brson (brson@moz-k0d.pdv.48.37.IP) (Quit: leaving)
[03:38:25] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[04:39:28] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[04:57:59] *** Joins: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net)
[04:59:41] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[05:28:10] *** Joins: adu (adu@moz-d3un5a.ms5a.74ae.000a.2601.IP)
[05:37:24] *** Quits: adu (adu@moz-d3un5a.ms5a.74ae.000a.2601.IP) (Quit: Leaving)
[05:40:00] *** Quits: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net) (Ping timeout: 121 seconds)
[05:56:06] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[06:02:08] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:11:11] *** Quits: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net) (Connection closed)
[06:58:40] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[07:03:28] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[10:02:30] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[10:36:14] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[10:40:59] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[12:48:04] *** Quits: blank_name (blank_name@moz-649u30.mi.frontiernet.net) (Quit: leaving)
[12:51:11] *** Joins: c74d (c74d3a4ebb6@moz-0ersgu.oc.cox.net)
[13:25:24] *** Joins: Lurkin3 (Lurkin@moz-p4efgs.mpls.qwest.net)
[13:25:44] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[13:28:48] *** Quits: Lurkin2 (Lurkin@moz-p4efgs.mpls.qwest.net) (Ping timeout: 121 seconds)
[13:30:30] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[13:43:38] *** Lurkin3 is now known as Lurkin
[13:50:07] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[14:21:34] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[14:38:08] *** Joins: gsingh93 (gulshan@moz-qnbukr.mi.comcast.net)
[15:26:04] *** Joins: brson (brson@moz-qjg.7vl.56.172.IP)
[15:54:48] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[16:29:57] *** Quits: brson (brson@moz-qjg.7vl.56.172.IP) (Quit: leaving)
[16:30:06] *** Joins: brson (brson@moz-qjg.7vl.56.172.IP)
[16:48:19] <Ilari> Also, when writing TLS library: Refuse to load improper certificate chains, or error out if peer sends invalid certificate chain.
[16:55:20] <Ilari> Also, not supporting old insecure crap, like EXPORT, RSA key exchange, DSS, CBC, RC4, Binary ECC, <WF100 ECC, Insecure renego, etc...
[16:56:45] <kmc> yep
[16:57:20] <kmc> I would love for servo to have a "paranoid mode" that uses a pure Rust implementation of TLS 1.2+ and good ciphers only
[16:57:32] <kmc> as well as being more anal about certs
[16:57:51] <kmc> (to the degree that can't be turned on all the time)
[16:58:50] <kmc> like rejecting DV certs
[16:59:25] <Ilari> Well, there are probably loads of crap in certificates to reject on technical grounds. Like I would like to just reject anything containing length bytes 0x80 or >0x83.
[16:59:35] <kmc> i read about the hack where someone registered sslcertificates@live.com and got a DV cert...
[16:59:38] <kmc> looool
[16:59:48] <cmr> oh god
[16:59:58] <kmc> what's the length byte for?
[17:00:09] <Ilari> 0x80 is just plain illegal in DER, and certificates are supposed to be DER. And >0x83 is likely an attack.
[17:00:15] <kmc> ok
[17:00:17] <Ilari> (Or very broken cert)
[17:00:26] <kmc> I know nothing about ASN.1/DER/BER
[17:00:31] <kmc> a state of blissful ignorance to be sure
[17:00:58] <kmc> I think paranoid mode would also blacklist algorithms and parameter sets
[17:01:17] <kmc> which would evolve over time
[17:02:50] <Ilari> Basically >0x83 means that the length field takes more than 3 bytes, which is supposed to only happen for elements at least 2^24 bytes. And maximum total size of certificate chain in TLS is limited by protocol to bit under 2^24 bytes.
[17:02:57] <Tiffany> DV certs are kind of shitty, but there's not really anything in between, is there?
[17:03:06] <kmc> between DV and EV? no :(
[17:03:06] <Tiffany> there's just all out EV certs, which only large companies can afford
[17:03:12] <kmc> yeah EV is a racket
[17:03:21] <kmc> but DV certs are pretty much meaningless
[17:03:26] <Tiffany> even google doesn't have an EV cert as far as I can tell
[17:03:32] <Ilari> Well, there's OV, but it is pretty useless.
[17:03:38] <kmc> CAs should be pressured into offering a middle ground
[17:03:51] <kmc> instead of just operating "free garbage security for plebs" and "enterprise money siphoning racket"
[17:03:59] <Lurkin> OR domains should be their own CA's instead of trusting a third party.
[17:04:06] <Ilari> The browser vendors don't treat them as strong enough, so it gets clumped with DV:
[17:04:27] <Ilari> 0x80 means indeterminate length (there is stop code). Not allowed in DER.
[17:04:54] <Lurkin> There ought to be key parties like there is for PGP keys for CA's.
[17:05:01] <kmc> DER is deterministic BER?
[17:05:01] <Ilari> Lurkin: Like DNSSEC and RRTYPE 52? Or something else?
[17:05:15] <kmc> if you trust DNSSEC then you can bootstrap TLS security from that
[17:05:17] <Tiffany> inb4 ssh security model
[17:05:20] <kmc> TOFU!
[17:05:36] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[17:05:38] <Tiffany> I haven't looked into dnssec in detail, but I like the idea of basing the trust chain off dns
[17:07:28] <Lurkin> Idk Ilari, I just think using a third party to sign your name is a major showstopper.
[17:08:04] <Lurkin> The errors that pop up about untrusted certs should be the norm, not the exception. Maybe it'll force folks to think about what they're connecting to.
[17:08:48] <Tiffany> no it won't
[17:08:58] <Lurkin> Certs should be by default untrusted.
[17:10:00] <Ilari> Lurkin: Statistics: Any test that has false positive rate greater than amount of true positives is useless. So if you have 0.1% true positives, you need false positive rate <0.1%.
[17:10:48] <Lurkin> Anybody heard of the GFW and the Great Cannon?
[17:10:55] <Ilari> Lurkin: Certs as deployed fail that: False warning rate is far greater than amount of MITMs.
[17:12:13] <Ilari> The point where false positive rate is equal to amount of true positives is approximately the point where positive is equally likely to be true or false.
[17:13:08] <Lurkin> Ok so you're saying that we need to trust the folks who CAN sign certs that the browser has installed by default?
[17:13:32] <Ilari> Also, I regard CT as presently deployed as a joke.
[17:13:59] <Lurkin> You know the github ddos that happened a couple weeks back?
[17:15:17] <Lurkin> https://citizenlab.org/2015/04/chinas-great-cannon/
[17:15:57] <Lurkin> That led to this
[17:15:57] <Lurkin> http://googleonlinesecurity.blogspot.com/2015/03/maintaining-digital-certificate-security.html
[17:16:11] <kmc> i know almost nothing about CT, but what are the flaws Ilari?
[17:17:20] <Ilari> Lurkin: The reasons for CNNIC dropping were not as publically claimed?
[17:19:59] <Lurkin> They used their CA to MITM ALL the traffic coming in and out of china to DDOS github.
[17:20:05] <Ilari> kmc: There is no way to require CT for your site.
[17:20:42] <Ilari> kmc: Which means that somebody can get a bad certificate and then use that for MITM, and nobody will know (unless you deploy HPKP, which is regarded as risky).
[17:21:48] <Ilari> AFAIK, all the known CA compromise incidents that were detected from outside were from HPKP, not CT.
[17:22:40] <Ilari> Lurkin: AFAIK, they didn't MITM, but used side-injection against unencrypted http:// to inject attack scripts into pages.
[17:24:14] <Ilari> AFAIK, side-injection can't be used for MITM, even against anondh.
[17:24:32] <Lurkin> I thought they had to strip the ssl at the gfw so they could inject that xss
[17:25:57] <Ilari> Lurkin: AFAIK, they didn't do that either.
[17:26:42] <Ilari> Great Cannon isn't too smart, according to the public analysis.
[17:26:58] <Lurkin> https://en.greatfire.org/blog/2015/mar/evidence-shows-cnnic-and-cac-behind-mitm-attacks
[17:28:11] <Lurkin> The "inspection" portion of the GFW is SSL stripping.
[17:28:28] <Lurkin> includes SSL stripping*
[17:30:10] <Lurkin> Doesn't matter, I won't be the one to fix CA.
[17:31:10] <Ilari> Well, perhaps SSL stripping would be possible with side injection (use it to alter URLs).
[17:33:16] <Lurkin> I'm just trying to lay out the reason I think https is a joke in it's current state, it prevent's MITM if you're damn sure the dude on the other end isn't malicious and their intermediary trustee isn't malicious either.  That's too much trust for one paranoid guy.
[17:36:25] <Ilari> Lurkin: If it was just their intermediary trustee, it wouldn't be so bad. It is loads more than that.
[17:36:51] <Lurkin> Agree trust goes with security much like oil with water.
[17:40:14] <Tiffany> according to digitcert, they don't offer DV certs
[17:40:20] <Tiffany> and yet, they offer other types of certs besides EV
[17:40:34] <Tiffany> "Standard SSL"
[17:42:06] <Tiffany> I have to wonder what that is
[17:42:12] <Tiffany> they say it's not DV, but it's not EV either
[17:42:27] <Tiffany> huh
[17:42:33] <Tiffany> the EV cert isn't as expensive as I thought it would be
[17:42:51] <Tiffany> ah
[17:42:55] <Tiffany> OV, maybe?
[17:43:03] <kmc> maybe it's OV, in which case brotwsers will treat it as DV
[17:43:07] <kmc> yeah
[17:43:19] <kmc> so "no DV certs" is kind of misleading?
[17:43:40] <Tiffany> and of course let's encrypt is supposed to be all DV certs
[17:43:55] <Tiffany> I feel like DV certificates could be a lot better
[17:43:57] <Ilari> Also, there is Chinese 360 browser or somesuch with really broken cert validation...
[17:44:11] <Tiffany> such as not letting you register a cert just by obtaining sslvalidation@live.com
[17:44:29] <kmc> "let's encrypt" is an admission that DV is no V and that we should use TLS as opportunistic encryption
[17:44:44] <kmc> to block dragnet surveilance
[17:44:48] <Tiffany> like uh
[17:44:51] <Tiffany> dns records maybe?
[17:45:01] <kmc> i've heard some interesting proposals along those lines
[17:45:16] <Tiffany> some sites let you do DV via adding dns records
[17:45:20] <Tiffany> but they also do it the regular way too
[17:45:26] <Tiffany> and browsers don't care either way
[17:45:27] <kmc> accept DV and invalid / unsigned certs but don't display the URL as "https"
[17:45:34] <kmc> only EV counts as "secure"
[17:45:53] <kmc> not really viable
[17:46:07] <Ilari> Also, HTTP should be shown as insecure.
[17:46:08] <kmc> but you can imagine lots of possible UI policies
[17:46:21] <kmc> separate from the technical question of whether encryption is being used or not
[17:46:39] <Ilari> Otherwise you are playing known-difficult games with security.
[17:49:30] <Tiffany> firefox is trying to phase out plaintext http and everyone is angry at them for it
[17:50:50] <Ilari> Also, has the oppsec support in Firefox been fixed yet (it was removed in 37.0.1 about a month ago)?
[17:53:31] <Tiffany> what's that?
[17:54:51] <Ilari> Basically, I feel the way browsers are handling safety, with any physical product with that kind of attitude one would be in world of hurt with consumer safety authorities.
[17:55:16] <Ilari> Tiffany: Encryption without certificates (no active attack protection).
[17:55:33] <Lurkin> Ilari, but aren't you happy that now you can bascially facetime without any apps in your browser /s
[18:02:02] <Ilari> Lurkin: I don't think I have ever used that...
[18:03:05] <Lurkin> Nobody has, that's the thing.
[18:03:13] <Lurkin> Just opening another attack surface.
[18:03:40] <Tiffany> that's something that really bothers me about the WHATWG
[18:03:53] <Tiffany> these browsers have ever growing attack surfaces and we don't have any kind of real sandboxing
[18:04:04] <Tiffany> you can either disable webgl entirely, or you can let every single application use it
[18:04:08] <Tiffany> you can't whitelist them when they ask
[18:04:14] <Tiffany> unless you install noscript
[18:04:26] <Lurkin> It's pretty sad that browsers can no longer simply browse.
[18:04:39] <Lurkin> Browsers have been phoneified.
[18:04:42] <Tiffany> I don't want to navigate to a random website and have an attacker able to crash my system because of a bug in my graphics drivers
[18:04:57] <kmc> yeah
[18:04:58] <Tiffany> or even just by using an infinite amount of memory
[18:05:04] <kmc> the browser permissions model is better than the android one, at least
[18:05:14] <kmc> apps on fxos ask for permissions on first use and you can approve / deny
[18:05:18] <Tiffany> at least applications can't fullscreen without asking...
[18:05:30] <Lurkin> Haha ActiveX
[18:06:01] <Ilari> Heh, reminds me of being interested in one browser feature... Looking it up and then being... You did WHAT? I need to check I don't have that enabled.
[18:06:03] <Tiffany> and I don't think they can rebind the escape key to do anything other than exit fullscreen
[18:06:50] <kmc> gl sandboxing will get better over time
[18:06:59] <kmc> it can't really be worse than X11 + DRI2
[18:07:07] * Lurkin chants unikernel unikernel
[18:07:19] <Tiffany> yeah but I don't run arbitrary applications from random places on the internet on my X server
[18:07:20] <kmc> course drivers can still be  buggy
[18:07:30] <Tiffany> drivers are never going to be perfect either
[18:07:30] <kmc> but you do
[18:07:35] <kmc> with webgl
[18:07:46] <kmc> cause there's no other way to reliably get a GL context on desktop Linux
[18:07:58] <kmc> than to talk to the X server, thereby puncturing sandboxing
[18:08:05] <Tiffany> yeah but context stuff is all handled by the browser
[18:08:10] <Ilari> I have seen very bad graphics driver... Basically so bad that switching to dumb FB was vast improvement in performance.
[18:08:18] <Tiffany> so you have to break the browser, and then you have to break X
[18:08:22] <kmc> yep
[18:08:34] <kmc> browser exploits these days tend to be multi-step affairs
[18:08:51] <kmc> esp against chrome
[18:09:04] <Lurkin> Google's got their shit in order that's for sure.
[18:09:11] <Tiffany> but yeah I really don't trust webgl
[18:09:24] <Tiffany> I still can't go to the front page of shadertoy.com without webgl in both chrome and firefox crashing
[18:09:34] <kmc> Servo is going for a multiprocessed sandbox architecture too
[18:09:35] <Tiffany> and it's not like I have some fucked up gl impl, this is just intel mesa
[18:09:45] <kmc> but there's only so much we can do for webgl :/
[18:10:06] <Tiffany> there's just way too large an attack surface for gl
[18:10:21] <Tiffany> short of writing a driver which perfectly models the state machine using idris, I doubt it's going to get much better
[18:11:20] <kmc> you could implement webgl (=~ OpenGL ES 2.0) in sandboxed userspace in terms of Vulkan or something
[18:11:49] <kmc> hell, you could implement in in JS
[18:12:03] <kmc> if you have "webvulkan"
[18:12:10] <kmc> and that should be much easier to sandbox
[18:12:18] <Tiffany> that's something I thought about
[18:12:39] <kmc> you could also standardize "webvulkan" but it's not necessary to start using this technique in engines
[18:12:40] <Tiffany> it will be interesting to see what happens
[18:12:42] <kmc> what did you conclude?
[18:12:45] <kmc> yeah
[18:15:03] <Ilari> Also, wonder if webgl could be exploited to do something more nasty than just crash the browser or whole system.
[18:15:39] <Lurkin> BTC mining
[18:16:15] <Lurkin> https://github.com/derjanb/hamiyoca
[18:16:18] <eternaleye> Ilari: Well, there was the exploit at one point that let it read data out of images IIRC
[18:16:53] <Ilari> Really nasty would be able to do arbitrary writes to physical RAM.
[18:17:18] <eternaleye> "Using cross-domain images in WebGL and Chrome 13"
[18:17:46] <Tiffany> I wonder if rowhammer works on the gpu
[18:17:49] <eternaleye> Name of the google blog post about it
[18:17:59] <eternaleye> Tiffany: ...oooh, for integrated, probably
[18:18:08] <Lurkin> I'm sure it does if the RAM is susceptible.
[18:18:17] <Lurkin> But afaik it was manufacturing issues?
[18:18:18] <eternaleye> Tiffany: Main obstacle is a lack of the way to figure out the pagemap
[18:18:43] <Tiffany> you might be able to combine it with that paper I saw on cache timing attacks in javascript
[18:18:45] <Lurkin> Tiffany what do you do besides swim through nasty db's?  Just curious?
[18:19:04] <Tiffany> http://arxiv.org/abs/1502.07373
[18:19:17] <Tiffany> lurkin: huh?
[18:19:32] <Lurkin> I grow lettuce and tomatoes with electronics, that's what I do, what is your area of expertise? 
[18:19:34] <kmc> yeah, even though they fixed the API-based cross origin image reads, GPU bugs where you can read uninitialized textures are common
[18:19:46] <kmc> and it's not just image read
[18:20:05] <kmc> since browsers do GL compositing, you can potentially read any part of any tab from webgl by exploiting a driver bug :(
[18:20:07] <Tiffany> computer graphics and related areas, I suppose?
[18:20:45] <Lurkin> I thought you were an engineer is all, it doesn't matter I was just curious.
[18:25:18] *** Joins: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net)
[18:27:29] <Ilari> Also, weren't there some estimate that only about half of browser bugs are memory safety bugs, the rest are something else? And considering the way browsers are written, that tends to hint that those are far too complicated to be secure...
[18:30:29] <kmc> yep
[18:31:09] <kmc> well, some of the remainder are memory-saftey issues in JIT code
[18:31:29] <kmc> 50% are memory safety issues that would be prevented by good static types such as Rust's
[18:32:00] <kmc> the top two bugs on http://googlechromereleases.blogspot.com/2015/04/stable-channel-update_14.html are same origin policy violations and not (obviously) memory-related
[18:32:13] <kmc> I think Servo should do something systematic about that
[18:32:15] <kmc> e.g. https://github.com/servo/servo/issues/5743
[18:32:42] <kmc> we're also going to have OS sandboxing to mitigate JIT bugs
[18:33:08] <kmc> that's why it's important to block things like X11 from the script thread
[18:33:39] <kmc> ideally, native code in the script thread is barely more trusted than JS from the corresponding origin
[18:34:46] <kmc> also Servo will do things like SVG (already working-ish) and XSLT with JS polyfills rather than privileged engine code
[18:36:06] <kmc> if yall have more ideas for browser architecture defense in depth let me know soon :)
[18:36:24] <kmc> in the next few months I'll be writing up a document about the state of security in Servo
[18:36:46] <Ilari> There doesn't seem to be a way to process to act as supervisor for memory space (at least without messing with virtual machines).
[18:39:21] <kmc> no, but you can configure the kernel as supervisor to enforce a restrictive policy, irrevocably
[18:39:33] <kmc> using e.g. seccomp mode 2 + namespaces, on Linux
[18:39:46] <kmc> https://github.com/pcwalton/gaol has a nice cross platform interface
[18:39:57] <kmc> I made a demo of sandboxing a single library: https://github.com/kmcallister/pngbox
[18:40:43] <kmc> we've also talked about in-process sandboxing of C libraries or JIT outputs, using something like Native Client
[18:41:00] <Tiffany> ooh, the rust beta is in arch repos
[18:41:07] <Tiffany> is servo up to beta?
[18:41:17] <kmc> yes, but it uses nightly-only features
[18:41:23] <Tiffany> oh
[18:41:43] <Tiffany> hm.. doesn't servo download and build its own rustc or something?
[18:41:51] <kmc> yeah, the build does that by default
[18:42:06] <Tiffany> it's been a while since I tried servo
[18:42:18] <Tiffany> last time it paniced on almost every page
[18:42:21] <Tiffany> even very simple ones
[18:42:28] <kmc> Servo is written in a weird, continually evolving mixture of Rust dialects from the ancient past and Rust dialects from the future with features that don't exist yet (emulated via gross hacks)
[18:44:18] <eternaleye> kmc: Actually, one thing I wonder is if something like the proof system seL4 used could be applied to a JIT, to prove type-safety all the way through...
[18:44:29] <Tiffany> most of them, from what I remember, came from .unwrap(), and mostly from something with layout in the name
[18:44:41] <Tiffany> you definitely could, eternaleye
[18:44:48] <kmc> eternaleye: yeah. typed assembly language (TAL) and proof-carrying code (PCC) are both interesting approaches for JIT
[18:45:21] <kmc> once Servo ships, maybe Mozilla will start rewriting spidermonkey in rust with PCC
[18:45:24] <kmc> who knows
[18:45:30] <Tiffany> seL4 in particular has a sort of C to isabelle translator
[18:45:36] <kmc> cool
[18:45:40] <Tiffany> and then the proofs are written against those isabelle expressions
[18:45:51] <kmc> I have seen papers about C compilers that produce a proof along with the binary
[18:46:06] <Tiffany> I find VCC pretty interesting
[18:46:13] <Tiffany> syntax extensions to C for attaching proofs
[18:46:20] <Tiffany> and invariants
[18:46:35] <Tiffany> it lets you express ownership and non-null values
[18:46:52] <kmc> cool
[18:47:54] <kmc> I've been reading a lot recently about systems with hybrid static/dynamic checking of arbitrary dependent refinement types
[18:48:14] <kmc> there's some really cool stuff there
[18:49:23] <kmc> you can also do type checking of dynamically typed programs based on profiles / observed execution traces
[18:49:35] <kmc> to find bugs or just get a better sense of how things work
[18:50:00] <Tiffany> there's also klee, which I want hooked up to emacs in a nice UI
[18:50:05] <kmc> yeah
[18:50:22] <kmc> everyone has the same two things to say about klee which is a) it's amazingly powerful, and b) it's impossible to build or use
[18:50:35] <Tiffany> being able to push a button and see a table of inputs -> outputs generated by klee would be great
[18:51:25] <kmc> have you seen https://github.com/nick8325/quickspec
[18:52:08] <Tiffany> heh
[18:52:27] <Tiffany> that reminds me of that brute force tool for finding interdefinitions of concatenative combinators
[18:52:39] <kmc> Tiffany: Servo still panics fairly often but it also handles lots of real pages correctly
[18:52:48] <kmc> and is impressively fast in release builds
[18:52:58] <kmc> when there isn't some dumb bug getting in the way of performance, which there often is :/
[18:53:15] <Tiffany> one thing that confused me was how it would crash after scrolling vigorously on some pages
[18:53:19] <kmc> heh
[18:53:25] <kmc> well that's not too surprising
[18:53:28] <Tiffany> what the
[18:53:29] <kmc> a lot happens when you scroll
[18:53:29] <Tiffany> 	tests/wpt/w
[18:53:29] <Tiffany> Aborting
[18:53:30] <Tiffany> could not detach HEAD
[18:54:18] <Tiffany> eh, I haven't written any code against this, I might as well just reset --hard
[18:55:01] <Ilari> could not detach HEAD? HEAD detaching failing sounds pretty bad...
[18:55:28] <kmc> sharpen axe and try again
[18:56:46] *** Quits: erickt (erickt@moz-4hh.6p3.217.74.IP) (Ping timeout: 121 seconds)
[18:57:08] <Ilari> Probably means that checkout failed or something like that...
[18:57:24] <Tiffany> I was doing a git pull with the rebase config option, that failed
[18:57:29] <Tiffany> but it failed after it had fetched
[18:57:35] <Tiffany> it was during the rebase
[18:57:40] <Tiffany> so I just git reset --hard origin/master
[18:57:45] <Tiffany> pretty strange error
[18:58:11] <Tiffany> I could blame it on random bit flips, on a bug with git handling repos this large, or on nasal demons
[18:58:22] <kmc> blame it on computers are terrible
[18:59:13] <Tiffany> oh
[18:59:19] <Tiffany> it looks like I missed the actual error in a wall of stuff
[18:59:23] <Tiffany> error: The following untracked working tree files would be overwritten by checkout:
[18:59:24] <eternaleye> Nasal demons really get up my nose :P
[18:59:32] <Tiffany> it's a bunch of testsuite stuff
[19:00:07] <Ilari> I actually have repository where I have seen git warning about operations taking too long...
[19:01:09] <Tiffany> I think servo is the largest repository on my system
[19:01:27] <Tiffany> if you count all the non-tree stuff
[19:01:29] <Tiffany> like rustc and llvm
[19:01:41] <kmc> servo doesn't build its own rustc anymore
[19:01:43] <kmc> not for a long time
[19:01:57] <Tiffany> oh, snapshot
[19:02:06] <kmc> yeah, it downloads a rust and cargo snapshot
[19:02:14] <kmc> ./mach has commands to run them btw
[19:02:16] <Ilari> I have one repo with 199,680 files in it...
[19:02:32] <Tiffany> that's a lot of files
[19:06:14] <Ilari> 270,438 objects reachable from HEAD.
[19:10:21] <kmc> I used to do a lot of complicated rebase work across hundreds of linux kernel branches
[19:16:28] <Ilari> git archive HEAD of that repo is 1,450,311,680 bytes...
[19:18:51] <Ilari> Also, size-pack: 701045 ... I guess that's kilobytes.
[19:22:13] <eternaleye> Ilari: How big's a git bundle of it?
[19:22:31] <Ilari> eternaleye: I would presume pretty close ot that 701045kB.
[19:22:38] <Ilari> eternaleye: It has only one branch.
[19:25:28] <eternaleye> Mm
[19:26:44] *** Quits: atomic (atomic@moz-md1mas.ipredator.se) (Quit: Leaving)
[19:31:23] *** Joins: atomic (atomic@moz-5jhi75.piratenpartei-nrw.de)
[19:45:17] <Ilari> Also, allegedly Intel is planning to add feature where pages can be labeled in 16 ways, and one can declare which of the 16 labels can be read and which of 16 labels can be written.
[19:46:15] <Ilari> If one tries to read a page with label not among set of allowed ones, one takes a #PF. Similarly for writing to page.
[19:58:25] *** Quits: atomic (atomic@moz-5jhi75.piratenpartei-nrw.de) (Connection closed)
[20:00:03] *** Joins: atomic (atomic@moz-th81f8.headstrong.de)
[20:03:23] <Ilari> Also, if one can somehow hijack DNS of some domain, one can presumably get mississued certificate for it. And those certificates are very dangerous.
[20:03:48] <Tobba> Ilari: I'm not sure what the use case of that feature would be unless theres more you can do with each label
[20:04:27] <Tobba> it'd just waste the last 4 bits unused bits in the page entries
[20:04:54] <Tobba> (actually, I guess it can replace the read/write/executable bits)
[20:06:17] *** Quits: geofft (geofft@moz-vfphq1.mit.edu) (Connection closed)
[20:06:53] <Ilari> I think the vulernability that caused firefox to disable oppsec had nothing directly to do with oppsec, but just occured in the same signaling code as used in oppsec.
[20:08:40] <Ilari> Also, one problem to migrating for secure everyting is devices that have major issues with certificate deployment (think SOHO devices).
[20:09:07] <Tobba> SOHO devices have bigger problems than certificates
[20:10:30] <Ilari> Well, basically anything that is not / should not be connected to the Internet and doesn't have IT department supporting it...
[20:11:28] <Tobba> any embedded device*
[20:11:34] <Tobba> (that isn't rackmounted)
[20:12:20] <Ilari> Oh, and then there are the devices with really anemic CPUs... Where marking Curve25519 run under a second is a challenge. Or even weaker CPUs than that.
[20:15:13] <Ilari> And I think Curve25519 is one of the fastest key exchanges at 128 bit level that are not of questionable security (like bECC, HECC, AE (lol) or similar things).
[20:23:29] <Ilari> AE => Algebraic Eraser... That braid crypto stuff...
[20:36:22] <Ilari> I get the feeling that Browsers add more features without really thinking about security... Especially back in old days. And thus the web security is just Charlie Foxtrot.
[20:36:39] <Tiffany> does the servo build -j8 by default or something?
[20:36:41] <Ilari> Or maybe proper term would be TRE.
[20:36:42] <Tiffany> my load average is almost 10
[20:38:35] <kmc> Tiffany: it builds with cargo, and cargo will use all your cores
[20:39:12] <Tiffany> I see 9 processes all fighting to the death over my 4 cores
[20:39:18] <Tiffany> virtual cores, anywa
[20:39:19] <Tiffany> y
[20:40:59] <c74d> Is that behavior of Cargo configurable globally?
[20:48:35] <kmc> dunno
[20:58:52] <Ilari> Also, encryption won't really help that much if the other end is NSA partner... :-)
[21:05:53] <kmc> that intel paging feature sounds useful
[21:06:09] <kmc> i'm guessing part of the point is that you can quickly change which tags have read or write privs
[21:06:13] <kmc> without a TLB flush
[21:06:35] <kmc> that would generalize the user/kernel protection mechanism
[21:07:39] <Ilari> Yeah, it is an user-accessable register that sets which ones are allowed.
[21:07:53] <kmc> oh, userspace can modify it?
[21:07:56] <Tiffany> nice
[21:08:04] <kmc> in that case it sounds like a mechanism for sandboxing
[21:08:13] <kmc> within a process
[21:08:20] <Tiffany> so you could switch between 16 different address spaces without needing to flush the TLB?
[21:08:24] <Tobba> I'm assuming theres some mechanism that controls what can be modified from userspace
[21:08:38] <Tobba> also possibly that
[21:10:30] <Tobba> if they allowed you to have more than 16 we could maybe finally have sefe single address spaces
[21:12:11] <c74d> s/sefe/safe/ or?
[21:13:24] <Tobba> safe* yeah
[21:13:32] <Tobba> guh
[21:17:14] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[21:26:28] <kmc> these kinds of systems typically rely on the OS to multiplex an indefinite number of contexts onto the 16 or whatever slots
[21:27:06] <kmc> e.g. an OS will (re)allocate TLB tags between active processes
[21:27:24] <kmc> x86 already supports TLB tags of some kind
[21:27:36] <kmc> this is different though
[21:27:44] <eternaleye> There was just recently a discussion on LKML regarding how to make use of that
[21:27:56] <eternaleye> Lemme dig up the link I posted in #rust-osdev
[21:29:12] <eternaleye> http://www.spinics.net/lists/linux-mm/msg87836.html
[21:29:34] *** Quits: jtdowney (jtdowney@moz-gh1isj.static.twtelecom.net) (Ping timeout: 121 seconds)
[21:31:45] <kmc> ah
[21:31:50] <kmc> yeah that PCID feature has been around for a while
[21:34:24] <eternaleye> RISC-V has ASIDs that work similary - it has set current ASID, flush single ASID (not necessarily the current one), and flush entire TLB
[21:34:37] <eternaleye> At least as of the most recent privileged ISA draft
[21:34:43] <eternaleye> *similarly
[21:35:19] <eternaleye> The ASID length is 0 <= ASIDLEN <= registerlen
[21:35:45] <kmc> is it a parameter of the ISA?
[21:35:46] <eternaleye> They advise testing it by writing -1 to the register, then reading back the result (which will be the maximum allowable ASID)
[21:35:58] <eternaleye> kmc: No, of the individual chip
[21:36:10] <kmc> eh, that's what I meant :)
[21:36:18] <kmc> a parameter as opposed to a fixed value for the ISA
[21:36:22] <eternaleye> Mm
[21:36:26] <kmc> cool
[21:37:00] <kmc> does it also have different page permissions for different privilege levels?
[21:37:06] <eternaleye> Yeah, an embedded CPU might only support one ASID (= 0), while some massive cloud computing beast might support 12 bits
[21:37:15] <kmc> or is the user<->kernel transition a change of address space
[21:37:19] <eternaleye> kmc: Yes
[21:37:22] <kmc> ok
[21:37:31] <kmc> so even with no ASID you can do syscalls w/o a TLB flush
[21:37:34] <eternaleye> The draft has unix mode bits (rwx) X (user, kernel)
[21:37:42] <kmc> ok
[21:37:44] <eternaleye> Although I think that may have changed
[21:37:48] <eternaleye> The draft is a year old
[21:38:39] <cmr> I've been trying to beg a newer draft out of them to no success
[21:39:01] <eternaleye> Ah, no, it's still (rwx) X (user, super)
[21:39:03] <Tobba> intel's PCIDs might be useful in microkernel contexts
[21:39:06] <Tobba> but I'm not sure
[21:39:23] <kmc> eternaleye: one problem with that model is that you want to distinguish between intentional and unintentional access to userspace by the kernel
[21:39:26] <kmc> as an exploit mitigation
[21:39:31] <kmc> intel has SMEP/SMAP
[21:39:41] <kmc> I bet RISC-V has something too
[21:39:42] <eternaleye> kmc: Um? I mean it has six mode bits
[21:39:46] <Tobba> it'll only be useful if whatever you call doesn't evict too much of the TLB
[21:39:53] <eternaleye> kmc: UR, UW, UX, SR, SW, SX
[21:39:58] <Tobba> it's only useful*
[21:40:05] <eternaleye> X is cross product
[21:40:18] <kmc> the kernel is "allowed" to read userspace, but the CPU should trap if it tries to read userspace from an instruction that's not explicitly marked as such
[21:40:29] <eternaleye> kmc: UR=1, SR=0
[21:40:41] <kmc> and then there's an instruction to override the SR bit?
[21:40:49] <eternaleye> kmc: It's a bit in the PTE
[21:40:50] <kmc> or do you have to change it and change it back
[21:40:53] <kmc> okay
[21:40:55] <kmc> that's not really acceptable
[21:41:10] <kmc> I think you want an instruction for "read this thing from userspace"
[21:41:12] <kmc> that ignores the SR bit
[21:41:29] <kmc> that's what SMAP gives you iirc
[21:41:30] <eternaleye> kmc: That sounds decidedly un-risc-y
[21:41:50] <kmc> SMEP is on the exec side, it prevents jumping to any page that's accessible to userspace whilst in kernel mode
[21:42:04] <kmc> well un-risc-y or not, it's an important mitigation against kernel exploits
[21:42:19] <eternaleye> kmc: See, my solution is to go the seL4 way, and have userspace explicitly mark its message buffer space...
[21:42:19] <kmc> anyway I don't think it's un-risc-y
[21:42:23] <kmc> hmm
[21:42:34] <eternaleye> kmc: The rest of user memory is not kernel readable, period. No exceptions.
[21:42:46] <kmc> mm
[21:42:51] <kmc> that would be nice
[21:43:02] <kmc> rewriting linux and all of the software for linux would be nice
[21:43:13] <kmc> but these protection features could work for stock linux software on risc-v
[21:43:33] <eternaleye> kmc: So would a helper function that does it.
[21:43:54] <eternaleye> It wouldn't be large, especially if you use fractal-mapped page tables
[21:44:24] <kmc> helper function that does what?
[21:44:35] <eternaleye> kmc: And then there's the fact that there are L4 userland servers that allow running Linux code...
[21:44:44] <eternaleye> kmc: Flip the bit, read some data, flip it back
[21:44:44] <kmc> true
[21:45:02] <kmc> introduces a race condition, doesn't it?
[21:45:08] <kmc> or a global sync event for every read from userspace
[21:45:17] <kmc> which is most interesting syscalls
[21:46:04] <eternaleye> kmc: Sure, which is why I very much favor the compat servers in userland option
[21:46:25] <eternaleye> kmc: And there's empirical evidence that's performance-competitive
[21:47:05] <eternaleye> kmc: Trying to get the hardware to add more and more features to paper over a rather weak security model is a losing battle, IMO
[21:47:25] <eternaleye> kmc: A proper capability system (like seL4) meets the goal out of the gate
[21:48:15] <kmc> yeah
[21:48:19] <kmc> I agree basically
[21:48:58] <eternaleye> kmc: Anyway, the reason I said that instruction is "un-risc-y" is that it'd basically require specialcasing the TLB algorithm for that one instruction
[21:50:05] <eternaleye> kmc: That'd be a layering violation IMO
[21:50:36] <eternaleye> kmc: And RISC-V is specced as having hardware page-table walking
[22:37:43] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[22:53:03] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[22:54:21] *** Quits: brson (brson@moz-qjg.7vl.56.172.IP) (Quit: leaving)
[23:07:20] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)

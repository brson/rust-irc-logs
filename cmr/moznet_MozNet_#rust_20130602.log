[00:02:00] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[00:03:31] *** Quits: tjc (tjc@moz-B867959A.redactedconsulting.com) (Quit: zzzzzzzzzz)
[00:04:22] *** Joins: tjc (tjc@moz-B867959A.redactedconsulting.com)
[00:04:22] *** ChanServ sets mode: +o tjc
[00:09:47] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (No route to host)
[00:09:47] *** Joins: SimonSapin1 (simon@A5049320.3E93794D.61EA6C28.IP)
[00:14:11] *** Quits: bletch (Mibbit@moz-E89B7C5B.range109-154.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[00:15:36] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:15:36] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14472dd28 to 1424e85ac: 02http://git.io/N3iJvQ
[00:15:36] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:15:37] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:15:37] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/NYCNxw
[00:15:37] <ghrust> 13rust/06auto 148716843 15Erick Tryzelaar: std: fix run tests when symlink is in the rust checkout path
[00:15:37] <ghrust> 13rust/06auto 1423808ef 15Erick Tryzelaar: syntax: move callee_id into the expr_ variants
[00:15:37] <ghrust> 13rust/06auto 1463417da 15bors: auto merge of #6885 : erickt/rust/move-callee_id, r=catamorphism...
[00:15:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:16:23] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[00:16:51] *** Joins: dew (Instantbir@moz-66796D51.dhcp.stls.mo.charter.com)
[00:19:42] *** Joins: Caseus (bacon@moz-9F046088.members.linode.com)
[00:20:24] *** Quits: SimonSapin1 (simon@A5049320.3E93794D.61EA6C28.IP) (Quit: Leaving.)
[00:20:44] *** Joins: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net)
[00:21:03] *** kimundi is now known as zz_kimundi
[00:23:39] *** Quits: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net) (Quit: adu)
[00:27:19] *** Quits: doomlord (doomlod@moz-3CF8202D.range81-159.btcentralplus.com) (Ping timeout)
[00:30:37] *** Joins: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP)
[00:34:49] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[00:34:50] <Eridius> rusti: let a = &mut 2; let b = &mut 3; a == b
[00:35:15] <Eridius> bah it's not here
[00:36:15] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[00:36:49] <cmr> brson: r? https://github.com/mozilla/rust/pull/6895
[00:37:28] <deepdog> Eridius: error: binary operation == cannot be applied to type `&mut <VI0>`
[00:37:49] <Eridius> deepdog: yeah that's what I expected
[00:37:51] <dbaupp> Eridius: *a == *b would work
[00:38:18] <Eridius> dbaupp: yeah that's what I'm doing
[00:40:18] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:41:37] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[00:43:11] <steven_is_false> How will using jemalloc in Rust embedding Rust in other applications? Will jemalloc override the other applications malloc, and etc..? Will the other application have to provide malloc, and etc.. to Rust? 
[00:43:45] <cmr> steven_is_false: shouldn't affect anything. it's statically linked into the runtime.
[00:44:11] <steven_is_false> cmr: In that case won't it be impossible for the other application to free Rust objects?
[00:44:55] <cmr> steven_is_false: I guess so, without a rust function exposing the internal "free"
[00:45:23] <caitp> if a C application gets ownership of something allocated by Rust, it does need an interface to know how to free it
[00:46:20] <cmr> yeah that's true. destructors and all.
[00:46:30] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:47:32] <steven_is_false> So jemalloc doesn't really make things any more complicated anyways because there is already the destructor problem.
[00:47:56] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[00:48:13] <cmr> Yeah
[00:49:15] <steven_is_false> cool.
[00:49:42] <benh> So if I call std::libc::malloc in rust code I still get '''system''' malloc and not jemalloc?
[00:49:46] <cmr> yes
[00:49:49] <benh> swell
[00:50:09] <Eridius> vec::each is implemented with unsafe code. I assume this is intended to avoid the overhead of bounds-checking on each element access? Is this considered good code, or is this considered old crufty code?
[00:50:36] <caitp> lots of things in rustc are implemented with unsafe code
[00:50:42] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[00:50:45] <Eridius> caitp: yeah but each_const() isn't implemented like this
[00:50:52] <Eridius> I'm wondering if that's because of laziness
[00:50:52] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[00:50:52] *** ChanServ sets mode: +o brson
[00:50:57] <Eridius> I've been told that vec and str are old, crufty modules
[00:51:07] <Eridius> so I don't know if a given snippet of code is considered good, or considered crufty
[00:51:21] <caitp> they are, all of it is, but it doesn't necessarily matter
[00:51:54] <dbaupp> Eridius: each is "good"
[00:51:59] <steven_is_false> Eridius: Why don't you try changing it to use safe code, and benchmark the performance difference?
[00:51:59] <Eridius> dbaupp: ok
[00:52:11] <dbaupp> Eridius: at least, the unsafety to avoid bounds checks is good
[00:52:12] <Eridius> steven_is_false: I'm not sure the right way to benchmark rust code atm
[00:52:21] <Eridius> dbaupp: I'm asking because I'm going to submit a pull request to fix the return value
[00:52:27] <Eridius> and I was just wondering if that's all that needed to be changed
[00:52:33] <dbaupp> Eridius: there is a #[bench] attribute like #[test]
[00:52:57] <dbaupp> Eridius: also, https://github.com/mozilla/rust/pull/6886
[00:53:08] <Eridius> oh pfft, it didn't reference my issue
[00:53:42] <dbaupp> https://github.com/mozilla/rust/wiki/Doc-unit-testing#benchmarking
[00:54:01] <caitp> "Pardon me while I fix my master/incoming confusionâ€¦." does the github API let you modify the base branch of a pull request now?
[00:54:10] <caitp> neat
[00:54:37] <caitp> maybe i need to update hub :u
[00:54:43] <Eridius> caitp: I wouldn't be surprised if it bases it off of the repo's HEAD, which really should be changed to incoming
[00:55:27] <dbaupp> cmr: for your jemalloc patch, maybe it'd be better to be a submodule?
[00:55:46] <cmr> dbaupp: I thought that but I think it was brson who said it is small and stable, no need for a submodule
[00:55:56] <dbaupp> cmr: oh, ok, cool :)
[00:57:21] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[00:58:26] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[01:02:35] *** Joins: lahwran (lahwran@moz-46CCAD84.net)
[01:02:39] *** Parts: lahwran (lahwran@moz-46CCAD84.net) ()
[01:02:44] <\n> Eridius: it looks like Pull Request #6886 already tackled vec::each return types
[01:03:06] <\n> oh oop
[01:03:08] <\n> oops
[01:03:19] <\n> dbaupp already pointed that out
[01:04:10] <caitp> mmk, so there is basically no elegant way to initialize complex types with optional parameters -- at least chaining, chaining does not seem to work, optional parameters don't exist, overloading doesn't exist, and macros are not really solving the problem
[01:04:19] <caitp> >:(!
[01:05:27] <steven_is_false> caitp: You could try making a with! macro.
[01:06:20] <dbaupp> caitp: or have literal "optional" parameters: fn new(a: Option<foo>, b: Option<bar>) -> MyThing
[01:06:29] <caitp> the trouble with these is they are not very good ways to do these things--chaining is at least sort of agreeable, although there's no guarantee that they're used in the constructor context really
[01:06:29] <dbaupp> caitp: it's not very good, unfortunately
[01:06:32] *** Joins: lahwran (lahwran@lahwran.net)
[01:06:36] <lahwran> much better
[01:06:41] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:06:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/NYCNxw
[01:06:41] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:07:13] <caitp> literal optional parameters are honestly one of the most ill-conceived ideas ever
[01:07:25] <steven_is_false> caitp: This was the idea I was referring to https://github.com/mozilla/rust/issues/6679
[01:07:32] <cmr> caitp: they'd be less terrible with default arguments.
[01:07:34] <caitp> like, there is a reason why people don't like passing NULL for 12 parameters in C functions :p
[01:07:35] *** Joins: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de)
[01:07:35] <dbaupp> caitp: and changing should work, fn new() -> MyThing, fn withFoo(self, foo) -> MyThing, ...
[01:07:58] <caitp> yeah, chaining doesn't actually work, it turns out
[01:08:20] <dbaupp> caitp: I believe optional/default arguments are possible (and planned?), just haven't been implemented yet
[01:08:22] <caitp> at least not with structs
[01:08:26] <dbaupp> caitp: why not?
[01:08:31] <dbaupp> LLVM assertions?
[01:08:31] *** Joins: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au)
[01:08:54] <dbaupp> or things not being mutable?
[01:09:25] <caitp> I don't really understand why not, because the error in reported doesn't make a lot of sense
[01:09:38] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:09:39] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/Y72i4g
[01:09:39] <ghrust> 13rust/06auto 14dbd61b3 15Tim Chevalier: rustc: Remove unused import
[01:09:39] <ghrust> 13rust/06auto 141ef207f 15Tim Chevalier: rustc: Improve astconv error message
[01:09:40] <ghrust> 13rust/06auto 14cb05dca 15Tim Chevalier: syntax: Add an each_view_item method on traits
[01:09:42] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:09:54] <dbaupp> caitp: can you put it online somewhere? :)
[01:10:25] *** Joins: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net)
[01:10:43] *** Joins: AliSaydi (AliAsghar@440F236.A7454891.64463B1D.IP)
[01:10:43] <cmr> tjc: +1000 for https://github.com/mozilla/rust/commit/599d358726c95253fe94cb88037dc9515f6742da
[01:11:37] <AliSaydi> http://www.iranianmovies.org/index.php/board,6.0.html online movies with english subtitles
[01:11:52] *** Quits: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de) (Ping timeout)
[01:13:22] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[01:15:18] *** Quits: tjc (tjc@moz-B867959A.redactedconsulting.com) (Quit: zzzzzzzzzz)
[01:17:25] *** Quits: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au) (Ping timeout)
[01:18:29] *** Quits: AliSaydi (AliAsghar@440F236.A7454891.64463B1D.IP) (Quit: )
[01:24:50] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[01:26:11] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[01:26:39] *** Joins: tjc (tjc@moz-B867959A.redactedconsulting.com)
[01:26:39] *** ChanServ sets mode: +o tjc
[01:27:47] <tjc> cmr: Heh, congratulate me when it finally passes tests :-)
[01:29:06] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[01:31:01] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[01:32:59] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[01:39:30] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:40:26] <dbaupp> strcat: I think rusti's dead :)
[01:40:53] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:40:54] <strcat> it timed out
[01:40:59] <strcat> stupid pytho
[01:41:00] <strcat> n
[01:41:21] <cmr> I have my ircbot like: while true; do ./bot; done
[01:41:26] <dbaupp> rusti: botsnack
[01:41:28] -rusti- "nom nom"
[01:41:28] <cmr> in a tmux session
[01:41:39] <lahwran> ow
[01:41:40] <strcat> cmr: well in theory it has a callback to reconnect
[01:41:42] <strcat> but...
[01:41:44] <dbaupp> cmr: that's how isrustfastyet runs, hehe :)
[01:41:44] <strcat> ;\
[01:42:11] <lahwran> isrustfastyet? that name sounds ominous
[01:42:21] <strcat> cmr: oh nice you got it working on windows
[01:42:22] <strcat> :D
[01:42:26] <cmr> strcat: yup
[01:42:30] <dbaupp> lahwran: http://huonw.github.io/isrustfastyet/
[01:42:41] <strcat> cmr: so it didn't require a prefix after all
[01:42:42] <strcat> good
[01:42:58] <lahwran> dbaupp: oh, you aren't referring to speed of the outputted code
[01:43:00] <dbaupp> lahwran: (the answer is "no" for compiling, but "yes" for (some) code)
[01:43:16] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[01:43:34] <lahwran> because I'd think that something as static as rust would allow for some pretty hefty compiler optimizations
[01:43:42] <dbaupp> lahwran: we're close to GCC and (often) faster than Clang, https://gist.github.com/huonw/5553335
[01:43:57] <dbaupp> lahwran: and with the current incoming, those times have got faster
[01:44:20] <lahwran> faster than clang at what?
[01:44:25] <strcat> we really need TBAA though ;\
[01:44:39] <dbaupp> that's pure numerics though, with stuff that uses pointers and so on, Rust has more static information and so (in theory) can be way faster than C
[01:44:39] <lahwran> outputted code or compile time? I'm used to a language's "speed" being the speed of the code outputted by the default implementation
[01:44:51] <dbaupp> lahwran: outputted code for generating random numbers
[01:44:55] <lahwran> oh nice
[01:45:09] <lahwran> also, it seems I can't load github stuff right now. I don't understand wtf's going on, it's driving me up the wall.
[01:45:23] <lahwran> wait, github.io worked, why isn't gist?
[01:45:39] <dbaupp> hm, github.io seems to be unreliable for me
[01:45:52] <dbaupp> but gist is fine?
[01:45:55] <cmr> I don't have any problems..
[01:45:56] <lahwran> unreliable is one thing, nothing at all on github.com is loading for me
[01:46:00] <lahwran> w t f
[01:46:23] <lahwran> how do you have a connection specific issue where the host will resolve, but not ping, where everyone else can connect and load?
[01:47:31] <dbaupp> :(
[01:47:50] <strcat> lahwran: they give you different servers based on location
[01:47:53] <lahwran> no, I take that back. IT PINGS FROM PING, BUT CHROME WON'T LOAD IT
[01:47:56] <strcat> lahwran: try tor or something
[01:47:58] <lahwran> what the flying _fuck_
[01:49:39] <cmr> What is miniz in the runtime used for?
[01:50:11] *** Joins: sp3d (a@moz-49806493.dhcp.stls.mo.charter.com)
[01:50:49] <dbaupp> cmr: std::flate
[01:51:11] <cmr> dbaupp: Well specifically I want to know what rustc is doing with it
[01:51:26] <dbaupp> cmr: oh, um, all the metadata is deflated
[01:51:33] <dbaupp> (when it's written to disk)
[01:51:33] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[01:51:40] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:51:40] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140058f3d to 1463417da: 02http://git.io/N3iJvQ
[01:51:40] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:51:41] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:51:41] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/sRaz7A
[01:51:41] <ghrust> 13rust/06auto 14ddbd1aa 15Luqman Aden: Add test for #6861
[01:51:41] <ghrust> 13rust/06auto 14d3a56db 15bors: auto merge of #6891 : luqmana/rust/unit-struct-drop, r=catamorphism
[01:51:41] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:51:42] <cmr> ah
[01:52:38] <cmr> It's the biggest offender when compiling small things.
[01:52:47] <cmr> Would it be feasible to replace it with LZ4?
[01:53:38] * cmr tries
[01:53:50] *** Joins: SimonSapin1 (simon@AC677AA0.72C1E24.8EDFB172.IP)
[01:54:08] *** Quits: SimonSapin (simon@A5049320.3E93794D.61EA6C28.IP) (Ping timeout)
[01:55:43] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[01:55:44] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:55:52] <dbaupp> cmr: is it the actual deflating that's causing the problem, or the overhead of calling into the runtime?
[01:55:56] <dbaupp> (i guess it's the former)
[01:56:05] <cmr>   10.66%  rustc  librustrt.so                           [.] tinfl_decompress
[01:56:06] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:56:09] <strcat1> rusti: 1
[01:56:10] -rusti- 1
[01:56:10] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[01:56:14] *** strcat1 is now known as strcat
[01:56:34] *** Quits: SimonSapin1 (simon@AC677AA0.72C1E24.8EDFB172.IP) (Ping timeout)
[01:56:44] <dbaupp> cmr: oh, so it's the decompressing...
[01:56:50] <cmr> dbaupp: yup
[01:56:59] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:57:09] <dbaupp> cmr: is LZ4 optimised for decompression?
[01:57:12] <cmr> dbaupp: sure is
[01:57:17] <cmr> https://code.google.com/p/lz4/
[01:57:51] <dbaupp> only 5x faster! not good enough! :P
[01:58:07] <dbaupp> that sounds like an easy win
[01:58:17] <cmr> yup, that's what I was thinking
[01:58:29] <strcat> heh, the high compression one decompresses faster
[01:58:57] <dbaupp> cmr: port it to Rust? ;P
[01:59:20] <strcat> anyway rust got 13MiB smaller since yesterday
[01:59:26] <strcat> from those optimization pass fixes
[01:59:28] <lahwran> why does rusti send a notice to the channel :|
[01:59:37] <cmr> lahwran: http://tools.ietf.org/html/rfc1459.html#section-4.4.2
[01:59:59] <dbaupp> strcat: \o/
[02:00:06] <dbaupp> aatch: you're a hero!
[02:00:09] <aatch> Yay!
[02:00:13] <cmr> You really are :)
[02:00:28] <lahwran> cmr: yes, but not to _channels_, that alerts clients
[02:00:34] * dbaupp converts to aatchism
[02:00:36] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:00:51] <strcat> lahwran: not most clients
[02:00:55] <cmr> lahwran: yes, to channels... same with privmsg. If your client is giving you an alert, it's broken.
[02:01:17] <lahwran> I'm not sure what you consider "most clients", but hexchat does
[02:02:01] <aatch> My favorite is that it actually made the compiled code faster, without making compiles slower. It's a win-win!
[02:02:07] <cmr> 2.26%  rustc  libstd-c3ca5d77d81b46c1-0.7-pre.so     [.] io::u64_from_be_bytes::_d5c23c4f973fe39::_07pre, called by 52.79% metadata::decoder::lookup_hash::anon::expr_fn_93718
[02:02:11] <strcat> aatch: if only mergefunc worked
[02:02:21] <cmr> Why in hell would it use big endian :|
[02:02:24] <strcat> aatch: any idea why it doesn't? did it before?
[02:02:29] <aatch> strcat, yeah. I've no idea why it doesn't
[02:02:34] <strcat> cmr: because we use this silly ebml thing
[02:02:40] <strcat> and it's in big endian
[02:02:42] <cmr> why
[02:02:46] <cmr> that is the worst thing ever
[02:02:51] <dbaupp> can we use le-ebml?
[02:02:54] <strcat> because it was a silly decision
[02:02:57] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[02:03:00] <strcat> dbaupp: or not use ebml
[02:03:00] <dbaupp> (i.e. invent it, and use it)
[02:03:17] <dbaupp> what's a better choice?
[02:03:17] <aatch> There are better encoding formats
[02:03:21] <strcat> msgpack, protobufs
[02:03:23] <strcat> etc.
[02:03:40] <aatch> We don't really need a super-generic format.
[02:03:45] *** Joins: snearch_ (snearch@moz-99EEC48F.pool.mediaways.net)
[02:03:48] <cmr> Reading metadaa is easily 25% + of compilation of small files.
[02:03:48] <strcat> right
[02:04:03] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[02:04:10] <dbaupp> isn't there a desire to move rustc::metadata out anyway?
[02:04:44] <dbaupp> (out into it's own crate)
[02:04:46] *** Quits: snearch (snearch@moz-DBC0E338.pool.mediaways.net) (Ping timeout)
[02:06:18] <cmr> int LZ4_compress        (const char* source, char* dest, int inputSize);
[02:06:19] <cmr> int LZ4_decompress_safe (const char* source, char* dest, int inputSize, int maxOutputSize);
[02:06:22] *** Quits: steven_is_false (user@moz-144077DE.bchsia.telus.net) (Ping timeout)
[02:06:24] <cmr> Now that's a nice API I like to see :)
[02:06:56] <dbaupp> is LZ4 streaming?
[02:07:32] <strcat> dbaupp: I don't think it matters
[02:07:42] <dbaupp> strcat: yeah, it doesn't 
[02:07:49] <dbaupp> it was a general question
[02:07:50] <strcat> it won't find spread out patterns if it's anything like snappy
[02:08:06] <cmr> No, it is not
[02:10:15] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:10:34] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:10:54] <lahwran> cmr/dbaupp/strcat: narrowed down the issue with my conn a bit - ssl isn't going through >:|
[02:11:02] <lahwran> to any site
[02:11:14] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[02:11:22] <cmr> that's no good
[02:12:37] *** Joins: SimonSapin (simon@AC677AA0.72C1E24.8EDFB172.IP)
[02:12:58] <cmr> Anyone in windows atm? Does it have a uname and what does it return?
[02:13:14] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[02:13:39] <strcat> cmr: I doubt it
[02:13:42] <dbaupp> cmr: as a shell command?
[02:13:45] <cmr> dbaupp: yeah
[02:14:04] <dbaupp> cmr: I can test in a minute or two
[02:14:09] <cmr> dbaupp: thanks
[02:14:25] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[02:14:25] *** ChanServ sets mode: +o brson
[02:14:35] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:14:42] <brson> congratulations on being so awesome, #rust
[02:14:51] <cmr> brson: hm?
[02:14:53] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[02:15:37] <dbaupp> cmr: "uname is an unrecognised program blah blah cmd.exe sucks blah blah"
[02:15:42] <cmr> heh
[02:15:48] <cmr> dbaupp: alright, thanks
[02:18:36] *** Quits: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net) (Quit: adu)
[02:18:39] <aatch> brson, thanks, but is there some more context?
[02:20:14] <strcat> cmr: I guess we should test the jemalloc stuff on OS X too
[02:20:26] <cmr> strcat: caitp said all tests passed
[02:21:11] <strcat> rusti: 2
[02:21:12] -rusti- 2
[02:21:17] <dbaupp> does someone want to close https://github.com/mozilla/rust/issues/6865 ? (it's a duplicate)
[02:24:39] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:24:39] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14d3a56db to 1463417da: 02http://git.io/N3iJvQ
[02:24:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:24:42] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:24:43] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/9_ySuw
[02:24:43] <ghrust> 13rust/06auto 14231aea6 15Tim Chevalier: rustc: Improve astconv error message
[02:24:43] <ghrust> 13rust/06auto 14760c71d 15Tim Chevalier: syntax: Add an each_view_item method on traits
[02:24:43] <ghrust> 13rust/06auto 14341678b 15Tim Chevalier: rustc: Call str::is_empty
[02:24:43] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:25:22] *** Quits: snearch_ (snearch@moz-99EEC48F.pool.mediaways.net) (Quit: Verlassend)
[02:26:13] <brson> aatch: nope
[02:26:26] <aatch> brson, ok then.
[02:27:10] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:27:12] *** Joins: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de)
[02:27:14] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[02:27:20] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:27:45] <strcat> rusti: 5
[02:27:46] -rusti- 560068KiB
[02:28:02] <strcat> rusti: 5
[02:28:03] -rusti- 5
[02:28:03] -rusti- peak: 60112KiB
[02:28:15] <strcat> hrm
[02:28:41] *** Joins: a__ (a__@moz-250D9B4.nycmny.fios.verizon.net)
[02:31:10] <MaikKlein> hm
[02:31:20] <MaikKlein> how do I import this module? http://static.rust-lang.org/doc/std/time.html#struct-tm
[02:31:48] <cmr> rusti: use extra::time;
[02:31:49] -rusti- foo.rs:10:13: 10:24 warning: unused import [-W unused-imports (default)]
[02:31:49] -rusti- foo.rs:10          use extra::time;
[02:31:49] -rusti-                        ^~~~~~~~~~~
[02:31:49] -rusti- ()
[02:31:58] <strcat> rusti: extra::time::now()
[02:32:00] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/ARTK
[02:32:11] <strcat> rusti: extra::time::now().tm_year
[02:32:12] -rusti- 113
[02:32:40] *** Joins: lkuper (lkuper@136BFF36.14CD977C.51B6877.IP)
[02:33:49] <MaikKlein> hm
[02:34:24] <MaikKlein> if I do use extra::time; I get /home/maik/hello.rs:1:4: 1:9 error: unresolved import. maybe a missing `extern mod extra`?
[02:34:24] <MaikKlein> /home/maik/hello.rs:1 use extra::time;
[02:34:58] <cmr> MaikKlein: Did you read the warning? Do you have "extern mod extra;" ?
[02:35:24] *** Quits: zz_kimundi (kimundi@moz-E9F14C50.dip0.t-ipconnect.de) (Ping timeout)
[02:35:32] <brson> strcat cmr: jemalloc is used by default by virtue of weak linkage? how exactly does that work?
[02:35:44] <MaikKlein> oh
[02:36:00] <MaikKlein> well
[02:36:02] <MaikKlein> thanks :D
[02:36:04] <strcat> brson: glibc (and apparently windows, because it works) uses weak symbols for the allocation functions, so alternatives override them
[02:36:14] <strcat> brson: https://en.wikipedia.org/wiki/Weak_symbol
[02:36:19] <strcat> I don't really know why it works on windows
[02:36:42] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[02:36:44] <strcat> brson: we could make jemalloc use a je_ prefix but then LLVM would stop doing libcall optimizations (since it hardcodes the malloc/free symbol names)
[02:37:14] <brson> strcat: llvm calls malloc and free?
[02:37:24] <strcat> brson: no, but it hardcodes libcall optimizations for known functions
[02:37:28] <strcat> it knows free(nullptr) is a no-op
[02:38:13] <brson> what about mac?
[02:38:45] *** Joins: zz_kimundi (kimundi@moz-D4550336.dip0.t-ipconnect.de)
[02:38:45] <Luqman> tjc: r? again https://github.com/mozilla/rust/pull/6891 
[02:39:05] *** zz_kimundi is now known as kimundi
[02:39:24] <strcat> brson: needs to be tested there to make sure it's actually kicking in afaik
[02:39:30] <strcat> brson: http://llvm.org/docs/doxygen/html/Local_8cpp_source.html#l00269 here's the LLVM thing
[02:39:34] <strcat> 00307   if (CallInst *CI = isFreeCall(I, TLI))
[02:39:35] <strcat> 00308     if (Constant *C = dyn_cast<Constant>(CI->getArgOperand(0)))
[02:39:37] <strcat> 00309       return C->isNullValue() || isa<UndefValue>(C);
[02:39:48] <strcat> we could probably add a pass doing stuff like that ourselves anyway
[02:40:04] <aatch> strcat, it should be doing that now, I'm not sure about before
[02:40:11] <brson> i wonder how it knows what functions named 'free' are libc free specifically
[02:40:28] <tjc> Luqman: r+, but do you know why it's failing on windows?
[02:40:33] <strcat> brson: I think it's really stupid and just assumes it's free if the prototype matches
[02:40:47] <strcat> so if you don't link against libc and can have those symbols you have to turn off those libcall passes
[02:41:41] <Luqman> tjc: i'm guessing it's since check-fast just groups all the tests together and thus doesn't like having the task fail (which the test does intentionally)
[02:43:06] *** cmr is now known as cmr|zzz
[02:43:20] <strcat> brson: http://llvm.org/bugs/show_bug.cgi?id=5130
[02:43:30] <strcat> so someone actually ran into a problem and they started checking the prototype ;p
[02:43:33] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[02:44:03] <strcat> but still... it could go wrong if you implemented void *malloc(size_t) with a different behaviour afaik
[02:44:04] <cmr|zzz> strcat: brson: as for weak linkage, it's linked in as a static library, doesn't that kick in before any dynamic linking happens?
[02:44:24] <tjc> Luqman: Ah ok, that's fine then
[02:44:24] <strcat> cmr|zzz: ah that explains why it works on windows.
[02:44:49] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[02:44:54] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:45:10] *** Joins: an0nymous (an0nymous@moz-A6B0CE4.tx.res.rr.com)
[02:49:44] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[02:49:50] *** Quits: twm (twm@moz-13417AD3.dsl.static.sonic.net) (Quit: Leaving.)
[02:50:40] <brson> strcat: have you captured any numbers on the jemalloc change?
[02:51:03] <brson> *performance
[02:51:32] <brson> strcat: cmr|zzz: did either of you try adding the configure step to the rust configure script?
[02:51:48] * brson building
[02:51:56] <strcat> brson: I actually originally did that but it doesn't work out because I'm using ./configure to build in a specific dir
[02:52:03] <strcat> it goes fast so it doesn't really matter
[02:52:47] <strcat> brson: it's marginally better than the current stable release of glibc for single-threaded stuff, I haven't tested a real multi-threaded contention benchmark
[02:53:05] <brson> strcat: on linux? have you tested windows or mac?
[02:53:25] <brson> we might see bigger improvements there
[02:53:30] <strcat> brson: I just tested on linux
[02:53:42] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[02:53:47] <strcat> I do actually have a windows install around but I don't really feel like setting it up for rust
[02:55:17] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:55:17] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[02:55:34] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:55:36] *** Joins: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:55:44] *** strcat1 is now known as strcat
[02:55:51] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:55:51] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 1494af698 to 142d63517: 02http://git.io/k471pw
[02:55:51] <ghrust> 13rust/06try 14cff203e 15Daniel Micay: add jemalloc to the runtime
[02:55:51] <ghrust> 13rust/06try 14933897c 15Daniel Micay: integrate jemalloc into the build
[02:55:51] <ghrust> 13rust/06try 142d63517 15Corey Richardson: Windows fixes
[02:55:51] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:56:17] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[02:56:19] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[02:56:27] *** Quits: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[02:56:28] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[02:56:47] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[02:58:11] <brson> what are the most important metrics for measuring allocator performance?
[02:59:09] *** Joins: duckinator (nick@moz-74B346B5.mostlyincorrect.info)
[02:59:22] <strcat> brson: small allocation speed/overhead, fragmentation (hard to measure, I assume) and lock contention
[02:59:35] <strcat> I guess checking peak memory usage of a rustc build would be a good metric
[03:00:44] <strcat> brson: the core-map test has a good test for the small allocs (treemap)
[03:00:52] <strcat> could also try it with a bunch of threads
[03:03:56] <brson> strcat: does this affect llvm's allocator?
[03:04:09] <strcat> brson: no, just binaries linked against librustrt.so
[03:04:54] <strcat> brson: I don't think it would matter much for LLVM because they use their own allocator things
[03:05:31] <MaikKlein> I have found something weird and I hope you can explain it to me
[03:05:32] <MaikKlein> https://gist.github.com/MaikKlein/5692462
[03:05:57] <MaikKlein> I spawn x amount of tasks, each task should wait 2 * 2 secs
[03:06:17] <MaikKlein> so the expected time to terminate this program should be around 4 secs
[03:06:27] <MaikKlein> but if I increase the number of tasks that are spawned
[03:06:43] <MaikKlein> it takes really long, like 20 - 50 secs
[03:06:49] <steven_is_false> MaikKlein: Try putting a task::yield into the loop.
[03:07:06] <heftig_> the while loop, that is
[03:07:23] <strcat> brson: they do call the system malloc but there's a wrapper around it
[03:07:42] <dbaupp> It's not possible to freeze a @mut box is it?
[03:07:46] <strcat> not sure if it's just the JIT using it
[03:09:27] <MaikKlein> what is task::yield doing? It doesn't change the outcome. Is my sleep function wrong?
[03:10:25] <MaikKlein> i know it probably goes crazy in the loop
[03:10:49] <strcat> MaikKlein: it won't yield in the busy loop
[03:10:52] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:10:55] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: erickt)
[03:11:54] <strcat> a proper sleep function would probably involve the scheduler
[03:12:07] <strcat> can't really use stuff like nanosleep because they make the thread sleep
[03:12:34] <strcat> I guess it would just yield and then the scheduler would not give back control until the time elapsed
[03:12:51] * strcat shrugs
[03:12:59] <strcat> on linux it would ideally use timerfd
[03:13:04] <strcat> *no idea* about other platforms
[03:13:21] <strcat> maybe LLVM wraps that away
[03:13:31] <strcat> err
[03:13:32] <strcat> libuv*
[03:14:34] <strcat> MaikKlein: there's http://static.rust-lang.org/doc/std/timer.html
[03:15:37] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:15:38] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/9_ySuw
[03:15:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:15:45] <MaikKlein> strcat: yes I saw that, but I never used an uv::iotask before. I probably test this tomorrow
[03:15:55] <MaikKlein> or is do spawn just a uv::iotask?
[03:16:12] <strcat> MaikKlein: no I think you just grab the scheduler's main iotask
[03:16:58] <strcat> extra::uv_global_loop::get()
[03:17:51] *** Joins: twm (twm@moz-13417AD3.dsl.static.sonic.net)
[03:18:19] <MaikKlein> ah
[03:18:36] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:18:36] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/jSRqDw
[03:18:36] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:18:37] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:18:37] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/_hCiIw
[03:18:37] <ghrust> 13rust/06auto 14ddbd1aa 15Luqman Aden: Add test for #6861
[03:18:37] <ghrust> 13rust/06auto 14101e387 15Luqman Aden: Mark run-pass/unit-like-struct-drop-run.rs as xfast-fail.
[03:18:37] <ghrust> 13rust/06auto 1496f6f29 15bors: auto merge of #6891 : luqmana/rust/unit-struct-drop, r=catamorphism
[03:18:39] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:18:41] <MaikKlein> okay cool didn't know that
[03:18:54] <MaikKlein> I'll get some sleep now bye
[03:19:16] *** Quits: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de) (Quit: Leaving)
[03:20:55] <\n> I was thinking about blogging about pipes (not sure what aspect of them yet), but thought up the title "hitting the pipe with Rust"
[03:31:16] <Luqman> \n: haha nice
[03:32:02] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:34:55] *** Quits: carter (carter@moz-12C317EF.nyc.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[03:35:05] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[03:35:05] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[03:44:24] *** Quits: tjc (tjc@moz-B867959A.redactedconsulting.com) (Quit: zzzzzzzzzz)
[03:44:36] *** Joins: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net)
[03:46:56] *** Joins: jclements (jclements@BE2C733F.BE115975.BABD49BE.IP)
[03:47:30] <\n> is init just a typical name for a method that populates a struct, or is it an actual constructor function?  Similarly, can you define a function to execute when an object's lifetime expires (like a destructor)?
[03:49:03] <aatch> \n, the convention is `new` for constructor static methods
[03:49:17] <aatch> though they aren't at all special
[03:49:30] <\n> aatch: do you have a code sample? I would understand that faster
[03:49:42] <aatch> and there is a `Drop` trait that allows you specify a destructor
[03:49:47] <strcat> \n: just a function returning a struct
[03:49:54] <strcat> the language has no idea about constructors
[03:50:53] <\n> strcat: similar to implementing a singleton in C++, you make the constructor private and define an init method that returns a new obj?
[03:51:08] <strcat> dunno what you mean
[03:51:24] <dbaupp> \n: https://github.com/mozilla/rust/blob/incoming/src/libstd/run.rs#L113
[03:51:46] <\n> dbaupp: what are the single quotes?
[03:51:54] <dbaupp> \n: also, https://github.com/mozilla/rust/blob/incoming/src/libstd/run.rs#L150
[03:52:01] <dbaupp> \n: lifetimes
[03:52:30] <\n> I thought lifetimes usually had an identifier like 'r
[03:52:39] <\n> or is that only when you need to differentiate?
[03:52:50] <dbaupp> yes?
[03:52:59] <dbaupp> 'self and 'a have an identifier of that pattern?
[03:53:08] <strcat> you can call them whatever you want in most cases
[03:53:12] <strcat> 'static is the only special one
[03:53:19] <\n> how does Drop work?
[03:53:24] <dbaupp> (and 'self at the moment, but that's changing)
[03:53:31] <dbaupp> \n: https://github.com/mozilla/rust/blob/incoming/src/libstd/run.rs#L429
[03:53:32] <strcat> dbaupp: yeah, but it's not special
[03:53:39] <dbaupp> strcat: yep
[03:54:11] <dbaupp> \n: implement the 'finalize' method, and it gets automatically called as at the appropriate time
[03:54:11] <\n> impl Drop for MyType { fn finalize(&self) { â€¦ } }
[03:54:15] <Luqman> \n: you implement the Drop trait and the compiler knows about it and calls it when things go out of scope
[03:54:35] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Quit: Leaving)
[03:54:38] <dbaupp> *as a destructor
[03:55:48] <\n> how about instead of inheritence between structs, you should compose the child class with an instance of the base class? does that sound right?
[03:55:58] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[03:56:19] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[03:56:49] <dbaupp> \n: there isn't inheritance in the C++/Java/C# sense
[03:56:57] <\n> right
[03:57:12] <dbaupp> \n: so you'll have to be more specific about what you mean (e.g. code sample)
[03:59:51] <\n> In C++ you use inheritence instead of redefining the members of a base class.  In Rust, you would compose the child struct with an instance of the base struct, and impl the same traits as the base struct.
[04:01:06] <dbaupp> as in `struct Base { x: int, y: int }`, `struct Child { z: int, base: Base }`? 
[04:01:07] <\n> I'll work on a gist
[04:01:13] <\n> yes!
[04:02:02] <\n> though now I'm not so sure about the impl of traits thing I said
[04:02:35] <dbaupp> That would work, sure. (although, off the top of my head, I can't remember seeing any instance of that pattern in any Rust code, including the compiler)
[04:02:52] <dbaupp> and, yes, to get the same behaviour, you'd impl the traits
[04:03:06] *** Quits: wizeman (quassel@moz-9C343656.dyn.user.ono.com) (Connection reset by peer)
[04:03:09] <dbaupp> actually, I think it does occur, I lied.
[04:03:12] *** Joins: wizeman (quassel@moz-9C343656.dyn.user.ono.com)
[04:03:26] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[04:03:27] <lahwran> if there was some way to copy the definition of a struct and all impled traits, and then add a new trait
[04:03:28] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[04:03:42] <lahwran> that would be a bit more like inheritance but it'd still have the isolatedness of being a separate trait
[04:04:02] <\n> oh I see
[04:04:07] <lahwran> thoughts? keeping in mind i haven't used rust yet so it's just an off-the-cuff dumb idea
[04:05:10] <aatch> lahwran, a lot of that would be covered by the currently-not-implemented default methods for traits
[04:05:24] <\n> how about, in C++ you can force an object to only be creatable on the heap by making the destructor private.  I take it that if you impl Drop for YourType but make finalize priv than you're not satisfying the trait?
[04:06:12] <lahwran> making the destructor private? wtf?
[04:06:24] <lahwran> I'd like to see the circumstances that caused *that* to be the way to do it
[04:06:33] <dbaupp> \n: you can't control the visibility of trait methods
[04:06:36] <aatch> \n, you'll be much happier if you /don't/ try to copy C++ patterns
[04:06:42] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[04:07:02] <aatch> Take it from someone that is currently trying to map C++ patterns into rust.
[04:07:09] <aatch> (I don't have a choice, however)
[04:07:12] <dbaupp> and what aatch said; in many ways Haskell patterns seem to fit better with Rust.
[04:07:18] <dbaupp> aatch: llvm.rs?
[04:07:22] <aatch> dbaupp, yep
[04:07:32] <dbaupp> aatch: did you get the lifetimes thing to work?
[04:07:37] <aatch> dbaupp, nope.
[04:07:42] <dbaupp> :(
[04:07:45] <aatch> I'm giving up for now.
[04:07:48] <Luqman> \n: if this was a library you could probably keep the struct priv and just export something like type Foo = @FooPriv; maybe
[04:08:04] <aatch> Well, that's not strictly true
[04:08:13] <aatch> I got the more important cases working.
[04:08:19] <dbaupp> yeah, lifetimes mostly involve black magic
[04:08:37] <aatch> So a module can't out-live the context.
[04:08:45] <\n> Luqman: yeah that might work!
[04:08:56] <dbaupp> \n: what reason do you have for a type to be always heap allocated?
[04:09:08] <steven_is_false> This is weird, the delayed_send method only takes a Chan but I have a SharedChan. I take it there's a way to get a lock on the Exclusive <Chan <T>> contents?
[04:09:39] <lahwran> steven_is_false: oh great, there's already an irc bot thing in rust?
[04:09:44] <aatch> The sticking point I'm having at the moment is trying to figure out how to decently encode the type hierarchy
[04:09:49] <aatch> for values.
[04:09:57] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Connection reset by peer)
[04:10:19] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[04:11:47] <dbaupp> steven_is_false: shared.ch.with(|ch: &mut Chan| foo), or shared.ch.with_imm(|ch: &Chan| foo)
[04:11:56] <dbaupp> (maybe)
[04:12:04] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:12:13] <dbaupp> aatch: have you looked at other languages bindings?
[04:13:02] <aatch> dbaupp, Yeah, the OCaml ones just replicate the C api and the python ones have proper inheritance they can use.
[04:13:09] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[04:13:11] <\n> dbaupp: in case the type being instantiated is too big for the stack
[04:13:45] *** Joins: terra (Adium@moz-D20CB886.pool.mediaways.net)
[04:13:52] <aatch> \n, then have the only way to construct the type be a static method that returns a ~-ptr
[04:13:54] <steven_is_false> dbaupp: So close! I'm getting the really strange: expected struct std::comm::Chan but found struct std::comm::pipesy::Chan)
[04:13:59] <aatch> or a @-ptr
[04:14:07] <dbaupp> aatch: https://github.com/bos/llvm for Haskell too... I can't work where the main code is though
[04:14:21] <dbaupp> \n: there's not such thing as "too big for the stack" in Rust
[04:14:39] <dbaupp> \n: the stack gets dynamically expanded if necessary
[04:14:40] <\n> but there is in C/C++?
[04:14:46] <dbaupp> \n: yes
[04:14:52] <\n> why?
[04:15:27] <aatch> segmented stacks
[04:15:34] <dbaupp> rusti: let x = [0, 60_000_000]; std::sys::size_of_val(&x)
[04:15:36] -rusti- 16
[04:15:43] <dbaupp> rusti: let x = [0, .. 60_000_000]; std::sys::size_of_val(&x)
[04:15:44] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[04:15:57] <dbaupp> rusti: let x = [0, .. w0_000_000]; std::sys::size_of_val(&x)
[04:15:57] <lahwran> whoa.
[04:15:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cKJg
[04:16:00] <aatch> technically you can have them in C/C++
[04:16:06] <dbaupp> rusti: let x = [0, .. 20_000_000]; std::sys::size_of_val(&x)
[04:16:08] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[04:16:17] <dbaupp> rusti: let x = [0, .. 10_000_000]; std::sys::size_of_val(&x)
[04:16:18] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[04:16:27] <dbaupp> rusti: let x = [0, .. 5_000_000]; std::sys::size_of_val(&x)
[04:16:28] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[04:16:30] <strcat> dbaupp: codegen is buggy
[04:16:37] <dbaupp> strcat: :(
[04:16:42] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[04:16:44] <aatch> yeah, I don't think it's a semantic issue here
[04:16:52] <strcat> if you want to demonstrate it just do infinite recursion 
[04:16:55] *** Joins: steve (steve@moz-FE467FE7.public.wayport.net)
[04:17:01] *** steve is now known as steveklabnik
[04:17:10] <aatch> let x = [0, .. 5_000_000]; x.len()
[04:17:13] <strcat> you can't allocate large fixed-size arrays due to an unrelated bug
[04:17:19] <dbaupp> \n: in theory, those should've allocated huge vectors on the stack. clearly it doesn't work properly yet.
[04:17:30] <strcat> dbaupp: not related to segmented stacks
[04:17:41] <dbaupp> rusti: fn foo() { foo() } foo()
[04:17:42] -rusti- application terminated abnormally with signal 9 (Killed)
[04:17:45] <\n> hopefully there's no vector for attacking the server by sending commands to rusti over irc
[04:17:54] <aatch> There is not
[04:17:58] <\n> rusti: 5 + 5
[04:17:59] -rusti- 10
[04:17:59] <dbaupp> \n: it's actually strcat's laptop
[04:18:04] <strcat> \n: you're welcome to try, it's sandboxed well
[04:18:05] <dbaupp> \n: and there's not
[04:18:11] <heftig_> rusti: fn foob() -> int { foob() * 1 }; foob()
[04:18:11] <\n> lol
[04:18:12] -rusti- application terminated abnormally with signal 9 (Killed)
[04:18:18] <heftig_> oops :p
[04:18:21] *** heftig_ is now known as heftig
[04:18:30] <\n> why a laptop, and not a dedicated box?
[04:18:47] <aatch> \n, you are welcome to provide a dedicated box
[04:18:52] <dbaupp> steven_is_false: no idea about that :(
[04:18:55] <strcat> because it's an irc bot limited to 128MiB of memory
[04:19:12] <strcat> and I don't have somewhere better
[04:19:26] <\n> I have one, but not willing to provide
[04:19:37] <strcat> unless I cross-compile to arm
[04:19:49] <steven_is_false> dbaupp: I'm reading the very latest documentation that hasn't reached the website yet. Apparantly, a pipesy::Chan is more primitive than just a normal Chan, and I have to manually construct the Chan.
[04:20:10] <dbaupp> steven_is_false: oh
[04:20:17] <dbaupp> steven_is_false: pipesy is a nice name though
[04:20:21] <dbaupp> heh
[04:23:07] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[04:24:54] <Luqman> steven_is_false: Chan is a simple wrapper around either pipesy::Chan or rtcomm::Chan (new runtime)
[04:25:47] <\n> another question, if you can "hook" into object destruction, can you "hook" object copying or moving?
[04:27:10] <steven_is_false> Yep, I've got things compiling now.
[04:27:31] <dbaupp> \n: you can impl the Clone trait, which will become the method for copying soon
[04:27:46] <dbaupp> \n: but not moving, other than by custom functions/methods that you call
[04:27:47] <steven_is_false> Now I'm getting a task yielded in an atomic section error.
[04:28:47] <\n> are there any forms of reflection or metaprogramming?
[04:29:17] <dbaupp> \n: yes to both. macros for the latter, and something for the former.
[04:29:32] <dbaupp> (I've never used the former, so I can't say much about it.)
[04:29:42] <aatch> there is reflection, it's just not very useful atm.
[04:29:57] <\n> maybe a good question for jclements
[04:30:10] <jclements> sorry... what's the question?
[04:30:22] <Luqman> \n: there's http://static.rust-lang.org/doc/core/reflect.html
[04:30:34] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:30:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/_hCiIw
[04:30:34] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:32:34] *** Joins: tjc (tjc@moz-B867959A.redactedconsulting.com)
[04:32:35] *** ChanServ sets mode: +o tjc
[04:32:35] *** Quits: wizeman (quassel@moz-9C343656.dyn.user.ono.com) (Connection reset by peer)
[04:32:48] *** Joins: wizeman (quassel@moz-9C343656.dyn.user.ono.com)
[04:33:14] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[04:33:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:33:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/2u0JNg
[04:33:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:33:36] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:33:36] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ioEfpA
[04:33:36] <ghrust> 13rust/06auto 147bc950c 15Kevin Ballard: Refactor some hashmap code into a new private function mangle()...
[04:33:36] <ghrust> 13rust/06auto 1475f1b7f 15Kevin Ballard: Add new function hashmap.insert_or_update_with()...
[04:33:36] <ghrust> 13rust/06auto 1414c3310 15bors: auto merge of #6815 : kballard/rust/hashmap-insert_or_modify_with, r=erickt...
[04:33:38] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:34:33] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[04:37:32] *** Joins: SingingBoyo (brandon@moz-94AE1D3A.bchsia.telus.net)
[04:42:45] <\n> dbaupp: I just found the section in the tutorial about supertraits irt inheriting traits
[04:43:26] *** Joins: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[04:44:20] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:49:50] *** Quits: jclements (jclements@BE2C733F.BE115975.BABD49BE.IP) (Quit: jclements)
[04:51:30] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:51:32] *** Parts: terra (Adium@moz-D20CB886.pool.mediaways.net) ()
[04:53:17] *** Quits: lkuper (lkuper@136BFF36.14CD977C.51B6877.IP) (Quit: lkuper)
[04:55:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[04:57:04] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[05:01:42] <Eridius> whoa, the github page for the pull request says "Determining merge status -- running tests"? I didn't know it could do that
[05:01:47] <Eridius> (https://github.com/mozilla/rust/pull/6815)
[05:02:16] <Jeaye> bjz: ping
[05:02:31] *** Joins: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp)
[05:04:45] *** Joins: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net)
[05:04:56] <dbaupp> Eridius: bors is magical! :)
[05:05:05] <bjz> Jeaye: bong
[05:05:24] <bjz> Jeaye: I literally just walked in the door ^_^
[05:06:51] <Jeaye> hah
[05:07:42] <Jeaye> On a new Arch setup, I'm unable to build glfw-rs (with the latest incoming). http://dpaste.com/1208076/
[05:08:10] <bjz> ahh
[05:08:15] <bjz> I have to fix that
[05:08:33] <bjz> the mod re-exports were removed from prelude
[05:08:52] <bjz> just a sec
[05:09:12] <bjz> will take me like, a couple of minutes
[05:11:49] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[05:13:03] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Quit: Lost terminal)
[05:13:21] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[05:13:54] <adu> where would be a good place to discuss my latest blog entry?
[05:14:08] <aatch> adu, reddit?
[05:14:23] <adu> hmm, perhaps
[05:14:36] <aatch> Assuming that "on your blog" isn't the answer you're looking fo
[05:14:39] <aatch> for*
[05:14:53] <Jeaye> bjz: No rush, mate. Just good to know it's not something wrong with my setup.
[05:15:13] <adu> I was hoping for some editorial comments _before_ I post it
[05:15:27] <dbaupp> adu: if it's about rust, then you can ask here
[05:15:36] <bjz> Jeaye: lmath is *almost* fixed
[05:15:38] <bjz> :P
[05:15:40] <adu> my next one is about rust
[05:15:42] <bjz> -_-
[05:15:42] <Jeaye> badass
[05:15:50] <aatch> Ah, if its editorial stuff, here is fine
[05:15:57] <adu> and my previous entry mentioned rust
[05:16:11] <bjz> Jeaye: and no copies for indexes (well, I had to forgo the index operator)
[05:16:14] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[05:16:32] <adu> http://straymindcough.blogspot.com/2013/06/review-of-previous-posts.html
[05:16:49] <adu> (4th paragraph mentions Rust)
[05:18:07] <adu> http://pastebin.com/raw.php?i=kQk5yvxX (This is the draft of my current entry)
[05:20:56] <dbaupp> adu: that doesn't appear to be about Rust?
[05:21:17] <adu> ok, I'll unpost it
[05:21:56] <dbaupp> I'm confused... what do you mean?
[05:22:13] <adu> I don't know, my backspace doesn't work over IRC
[05:23:37] <adu> I'm planning on a series of posts about Rust, but I have to do more research before I can do that
[05:24:50] <bjz> Jeaye: done!
[05:25:30] *** Joins: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net)
[05:26:28] <aatch> Man I like Rust's type system at times.
[05:29:29] <aatch> like being able to parameterize a struct, but not actually needing to have something of the type in it.
[05:29:58] <dbaupp> aatch: as a marker?
[05:30:43] <aatch> More like being able to say that this LLVM Array type contains a certain type, but the struct just has a single TypeRef field
[05:32:50] <aatch> Also, stuff like traits with static methods, so I can do Wrapper::from_ref(r)
[05:34:44] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Quit: Leaving.)
[05:36:34] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:36:35] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ioEfpA
[05:36:35] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:37:20] <bjz> aatch: somtimes I hate rust's types
[05:37:22] <bjz> https://github.com/mozilla/rust/issues/6894
[05:37:34] <bjz> massive pain
[05:37:52] <aatch> bjz, oh yeah. It has it's pain points
[05:38:02] <Eridius> woohoo, my hashmap function made it in
[05:38:07] <bjz> also: https://github.com/mozilla/rust/issues/6898
[05:38:16] <Eridius> I'm just annoyed that I had to add the extra param to mangle. Gonna make it harder to remove if once functions ever get implemented
[05:39:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:39:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/19whWw
[05:39:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:39:33] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:39:33] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nKh-Qw
[05:39:33] <ghrust> 13rust/06auto 14ecd08b9 15Nick Desaulniers: Swap return value of pipes::init Fixes #4501
[05:39:33] <ghrust> 13rust/06auto 14c354a0c 15bors: auto merge of #6896 : nickdesaulniers/rust/issue4501, r=brson...
[05:39:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:40:19] <bjz> aatch: I thought I'd managed to hack around #6894 - alas, no
[05:41:37] <SingingBoyo> so if I have a trait declared pub 
[05:41:56] <SingingBoyo> gah.  bad enter key.
[05:43:01] <SingingBoyo> okay, so if I have a trait declared 'trait A : Eq' and a struct B{foo:~[~A]} can I not derive Eq for B?  I'd expect to be able to but the compiler says it can't find an implementation of Eq for A
[05:43:26] *** Quits: steveklabnik (steve@moz-FE467FE7.public.wayport.net) (Quit: Lost terminal)
[05:43:49] <dbaupp> bjz: don't those issues (and their resolutions) depend heavily on the associated item syntax?
[05:44:05] <bjz> dbaupp: no idea
[05:44:09] <aatch> SingingBoyo, trait inheritance is a bit janky
[05:44:37] <bjz> dbaupp: all I know is that it's majorly painful
[05:45:46] <dbaupp> bjz: I'm pretty sure it does, but not totally sure
[05:46:05] <SingingBoyo> tried writing my own impl for B.  still doesn't find the impl of Eq for A.  this is just odd. 
[05:46:12] <bjz> dbaupp: my hack-around doesn't work :(
[05:46:28] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[05:46:41] <dbaupp> bjz: anyway, for 6898 doesn't size_of<T: TypeInfo>() { ... } work?
[05:46:44] <bjz> SingingBoyo: #[deriving(Eq)] struct B{foo:~[~A]}
[05:46:56] <dbaupp> bjz: or is the point to avoid having to specify the bound?
[05:47:04] <bjz> dbaupp: no, that is assuming a SizeOf trait
[05:47:06] <adu> bjz: I immortalized your code forever: http://straymindcough.blogspot.com/2013/06/rust-echo.html
[05:48:12] <dbaupp> SingingBoyo: Eq trait objects don't make sense, e.g. `(@1i as @Eq) == (@"string" as @Eq)` what method does it call?
[05:48:32] <dbaupp> rusti: (@1i as @Eq) == (@"string" as @Eq)
[05:48:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ELTg
[05:49:09] <bjz> adu: http://www.reddit.com/r/rust/comments/1fi900/what_a_stray_mind_coughed_up_rust_echo/
[05:49:19] <dbaupp> adu: isn't the middle program incorrect?
[05:49:23] <bjz> adu: :)
[05:49:27] <dbaupp> adu: i.e. it prints each argument on a new line?
[05:49:44] <dbaupp> or is that the desired behaviour?
[05:50:02] <bjz> dbaupp: that's if it has the -n flag
[05:50:24] <dbaupp> bjz: for posix echo, the -n disables printing the trailing newline
[05:50:38] <dbaupp> bjz: but otherwise it's the same
[05:51:42] <adu> dbaupp: it doesn't satisfy either posix or bsd requirements
[05:51:52] <bjz> adu: it is wrong
[05:51:56] <adu> dbaupp: and it doesn't work
[05:52:04] <adu> bjz: oh, how so?
[05:52:08] <dbaupp> rusti: std::run::process_output("echo", &[~"a", ~"b"]).output
[05:52:09] -rusti- ~[97, 32, 98, 10]
[05:52:24] <dbaupp> rusti: std::run::process_output("echo", &[~"-n", ~"a", ~"b"]).output
[05:52:26] -rusti- ~[97, 32, 98]
[05:52:32] <bjz> adu: print(str::connect(strs, "\n")) -> print(str::connect(strs, " ")),
[05:52:44] <\n> lol I just got pinged
[05:52:52] <adu> haha
[05:52:54] <bjz> [_,..strs] => print(str::connect(strs, " ")), -> [_,..strs] => println(str::connect(strs, " ")),
[05:53:09] <bjz> adu: I was confused about the implementation of echo
[05:53:16] <bjz> could you fix that?
[05:53:24] <adu> bjz: should I remove it? or fix it?
[05:53:30] <bjz> I'll fix my gist
[05:53:30] <SingingBoyo> dbaupp: Guess that makes sense.  Is there a way to get around that at all?  So maybe check somehow that they have the same type and then call the appropriate eq?
[05:53:34] <dbaupp> adu: the first one of https://gist.github.com/huonw/5683000
[05:54:00] <adu> dbaupp: that works
[05:54:17] <bjz> adu: fixed https://gist.github.com/bjz/5682965
[05:54:24] <dbaupp> SingingBoyo: I guess it could check that they shared the same vtable, and if they do call the method. but what happens if they don't share the vtable?
[05:54:34] <bjz> https://gist.github.com/bjz/5682965/revisions
[05:54:46] <bjz> adu: just alter the snippet in your blog post
[05:54:47] <dbaupp> SingingBoyo: Rust would need to support someway to hook into trait-object method resolution, or something
[05:55:00] <dbaupp> SingingBoyo: or special case Eq
[05:55:26] <adu> I updated the post
[05:55:39] <dbaupp> SingingBoyo: what you might want is to parameterise the struct? i.e. struct B<T> { foo: ~[~T] }
[05:55:40] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[05:56:11] <dbaupp> adu: looks good! :)
[05:56:48] <adu> dbaupp: thanks :)
[05:57:23] <bjz> adu: yeah, this is what *should* work, but fails due to a bug: https://gist.github.com/bjz/5682965
[05:57:42] <dbaupp> bjz: I'm not sure it's a bug?
[05:58:02] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[05:58:08] <SingingBoyo> dbaupp: Wish I could.  But unfortunately it's a trait representing component data and I don't see an easy way to restructure and do that.  Is there a way to write an impl of Eq for the trait?  so something like impl Eq for A?  I know there's impl<T : A> Eq for T or something similar but I think that'd run into my original problem
[05:58:37] <adu> dbaupp: bjz: I thought it was a property of the pointer returned
[05:58:39] <dbaupp> SingingBoyo: you could try impl Eq for ~A {}
[05:58:47] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[05:58:56] <dbaupp> adu: yes, lifetimes, and so on
[05:59:02] <dbaupp> and scoping
[05:59:08] <aatch> lol, I accidentally commited the .svn folder for llvm
[05:59:10] <dbaupp> SingingBoyo: I guess that won't work though
[05:59:29] <aatch> I just removed it: 11,241 changed files with 3,123 additions and 2,023,152 deletions.
[05:59:53] <bjz> dbaupp: ohh I see
[05:59:53] <SingingBoyo> dbaupp: Nah it might.  I have conversion functions in the trait that should generate unique values that can be compared.  It'll be slow, but it'll work until I find something better
[05:59:58] <dbaupp> SingingBoyo: you might have to have a wrapper struct that encodes the type, or something. I don't know how to deal with this.
[06:00:14] <bjz> dbaupp: yeah last time I tried that, it compiled, but had a runtime malloc error
[06:00:18] <dbaupp> SingingBoyo: (I think it won't work because Rust already has an Eq for ~)
[06:00:42] <bjz> dbaupp: it fails to build now, which probably what should have happened
[06:01:08] <dbaupp> rusti: trait A{} impl Eq for ~A { fn eq(&self, _: &~A) -> bool {true} fn ne(&self, _: &~A) -> bool {true} }
[06:01:16] <dbaupp> hm, it's gone
[06:01:23] <dbaupp> bjz: that's a bit strange
[06:01:36] <aatch> In other news, I now have decent wrappers (I think) for all of the LLVM type stuff.
[06:01:36] <bjz> ?
[06:01:45] <dbaupp> bjz: the runtime malloc thing
[06:02:02] <bjz> well it fails to build now, due to a lifetime error
[06:02:12] <bjz> which is what it should have been
[06:02:23] <bjz> your one is ok
[06:02:31] <brson> how do you pattern match an unsafe pointer?
[06:02:34] <bjz> with the intermediate variable
[06:02:36] <SingingBoyo> dbaupp: Well, giving that to the REPL works, so I'll give it a shot in my code.
[06:02:39] <dbaupp> even so, why did it compile previously?
[06:02:49] <bjz> because it shouldn't have
[06:02:58] <aatch> brson, good question
[06:03:01] <bjz> bug in lifetimes?
[06:03:07] <bjz> brson: & ?
[06:03:12] <aatch> I'm guessing the obvious didn't work..
[06:03:51] <brson> bjz: & seems to work. i did not expect that
[06:04:09] <bjz> brson: in an unsafe block though, right?
[06:04:34] <bjz> brson: because that *should* be an unsafe deref
[06:05:06] <brson> bjz: i haven't gotten far enough into the errors for rustc to mention it yet
[06:05:12] <bjz> ahh
[06:06:11] <bjz> brson: was attempting to make a TypeInfo trait today
[06:06:15] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[06:06:32] <bjz> brson: so eventually we might be able to do: T::size_of()
[06:06:36] <bjz> but yeah https://github.com/mozilla/rust/issues/6898
[06:06:38] <bjz> :(
[06:07:03] <SingingBoyo> well it compiles, but my tests segfault.  hmm.
[06:08:01] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[06:08:19] <bjz> Luqman: ping
[06:08:31] <Luqman> bjz: pong
[06:08:41] <dbaupp> SingingBoyo: segfault!
[06:08:44] <bjz> Luqman: did you manage to check it out?
[06:08:54] <dbaupp> SingingBoyo: are you using unsafe code anywhere?
[06:09:20] <Luqman> bjz: i built lmath with latest incoming but yeea I saw all the resolve errors with rray
[06:10:34] <bjz> nmatsakis: ping
[06:10:39] <bjz> Luqman: yeah :(
[06:10:42] <SingingBoyo> dbaupp:nope.  Doesn't actually seem to be coming from the Eq code either
[06:10:47] <bjz> Luqman: bug in resolve?
[06:10:53] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[06:10:59] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[06:11:18] *** Quits: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw) (Ping timeout)
[06:11:31] <bjz> Luqman
[06:11:35] *** cscottnet is now known as cscottnet_away
[06:11:41] <bjz> Luqman: so annoying :(
[06:11:45] <Luqman> bjz: bugs with glob imports perhaps
[06:12:26] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[06:12:34] <bjz> It works when importing with the tests
[06:12:37] *** Quits: tjc (tjc@moz-B867959A.redactedconsulting.com) (Quit: Places to go, people to annoy)
[06:12:42] <bjz> but not cross-crate
[06:13:31] <brson> oh, & doesn't work in the pattern. it parsed but failed to typecheck later
[06:13:38] <bjz> ahh
[06:13:39] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[06:13:43] <bjz> bugger
[06:13:49] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[06:13:49] *** Joins: doomlord (doomlod@moz-3CF8202D.range81-159.btcentralplus.com)
[06:15:09] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[06:15:27] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[06:16:54] *** Joins: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net)
[06:16:54] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[06:17:21] <bjz> Luqman: should we file a bug?
[06:18:00] <Luqman> bjz: do you have a small testcase to reproduce?
[06:18:49] <dbaupp> SingingBoyo: well, then that's a bug
[06:19:12] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[06:19:20] <dbaupp> brson: doesn't `match *foo { ... => ... }` work?
[06:20:19] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[06:20:24] <SingingBoyo> dbaupp: yes indeed.  The question is where it came from.  Seems to be somewhere in code that converts to json...
[06:20:47] <brson> dbaupp: I have an unsafe pointer that i want to match in the middle of a pattern
[06:20:54] <brson> Some(*(foo, bar baz))
[06:21:03] <dbaupp> brson: I see.
[06:23:10] <dbaupp> SingingBoyo: the builtin JSON module?
[06:24:34] <SingingBoyo> dbaupp: well, code that build up to it.  Oddly enough though, it seems to be in a for self.aVector.each |content| {blah
[06:25:06] <SingingBoyo> dbaupp: but it's between the end of one loop run and the start of another run if my printlns can be trusted
[06:25:57] <dbaupp> SingingBoyo: what's happening in 'blah'?
[06:27:36] <SingingBoyo> dbaupp: map.insert(content.getKey(), content.getJson()) so basically get a key from content, and the json for content, and put it into a map that I can use to create a json Object
[06:28:17] <SingingBoyo> but I put printlns before and after map.insert(...) and they both print once, then it segfaults
[06:28:18] <dbaupp> SingingBoyo: can you gist/pastebin it?
[06:29:45] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[06:31:30] <SingingBoyo> dbaupp: https://gist.github.com/singingboyo/5692821
[06:32:08] <dbaupp> SingingBoyo: um, it would be more useful if it was runnable, so I can reproduce it :)
[06:34:23] <SingingBoyo> dbaupp: Not sure I can do that.  would have to create a minimal test case cause this one uses several files.   I'll see what I can do.
[06:35:37] <Jeaye> bjz: So what was changed to break all of that?
[06:36:22] *** Quits: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[06:39:29] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:39:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/nKh-Qw
[06:39:29] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:46:52] *** Quits: blitter (blitter@moz-BA14D5CF.dyn.centurytel.net) (Ping timeout)
[06:48:00] *** Quits: huhlig-home (huhlig@moz-C8339267.hfc.comcastbusiness.net) (Connection reset by peer)
[06:49:14] *** Quits: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net) (Quit: \n)
[06:51:02] *** Quits: adu (ajr@moz-96FE9B84.washdc.fios.verizon.net) (Quit: adu)
[06:51:19] <SingingBoyo> dbaupp: alright, it should compile now.  sort of large but I think everything there is needed to cause the segfault
[06:51:31] <SingingBoyo> same gist, https://gist.github.com/singingboyo/5692821
[06:52:35] *** Joins: cdidd (cdidd@moz-9F8C21.broadband.corbina.ru)
[06:53:13] <dbaupp> SingingBoyo: well, LLVM asserts for me :S
[06:53:34] *** Quits: mflamer (Mibbit@moz-C6ED16AA.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[06:55:17] <SingingBoyo> dbaupp: hmm.  I'm on a fairly recent version from github.  could be something got broken...  I'll see if I still have the 0.6 binaries and try them if I do
[06:55:35] <dbaupp> SingingBoyo: i'm on an incoming from a few hours ago
[06:55:50] <dbaupp> SingingBoyo: so if yours doesn't assert, something is strange
[06:56:05] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[06:57:44] <dbaupp> SingingBoyo: it appears to be createIssue that is asserting for me, strangely enough
[06:59:01] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[06:59:05] <SingingBoyo> dbaupp: That actually does make sense.  When I did the test without the createXXXContent methods and just created the StringContent where the calls to those methods are, it worked just fine.
[07:00:02] <SingingBoyo> dbaupp: so it's possibly that whatever commit I'm on isn't doing something properly there and a move or free is happening that shouldn't
[07:00:51] <aatch> oh, right. ~-objects don't work properly atm
[07:01:30] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[07:04:01] <dbaupp> SingingBoyo: LLVM still fails with an assertion if I replace the createIssue call with Issue { contents: ~[] } and remove the create* functions.
[07:04:16] <dbaupp> this is strange, and probably caused by the ~objects
[07:04:25] *** Joins: mib_yes3sp (Mibbit@54E1AA1B.39A8BEB0.BFD31463.IP)
[07:04:41] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Ping timeout)
[07:04:52] *** Quits: mib_yes3sp (Mibbit@54E1AA1B.39A8BEB0.BFD31463.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:04:55] <aatch> let me guess, pointer cast problems?
[07:06:01] <dbaupp> aatch: in the code I've got that asserts, there's no actual casting, but Issue is defined as struct Issue { contents: ~[~IssueContent] }, where IssueContent is a trait
[07:06:24] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[07:06:26] <SingingBoyo> dbaupp: odd, it works fine for me if I do that
[07:06:27] <aatch> dbaupp, yeah, but I'm guessing the assertion is related to a pointer cast?
[07:07:34] <dbaupp> llvm::Type* llvm::checkGEPType(llvm::Type*): Assertion `Ty && "Invalid GetElementPtrInst indices for type!"' failed.
[07:07:48] <SingingBoyo> aatch: seems to be related to it for me.  Apparently dbaupp removed everything that casts though, and still had it assert on him
[07:07:50] <dbaupp> trait A {} struct B(~[~A]); fn main() { B(~[]); }
[07:07:52] <aatch> huh, haven't seem that one.
[07:07:57] <dbaupp> that fails ^
[07:08:10] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[07:09:05] <aatch> Seems like some code is out of sync
[07:09:19] <dbaupp> does it fail for you?
[07:09:26] <aatch> dbaupp, haven't tried it
[07:09:29] <dbaupp> oh
[07:09:34] <dbaupp> sure
[07:09:41] <aatch> I'm just guessing from the errors
[07:10:14] <aatch> I'm guessing somebody removed fields from the trait box struct definition and code that relied on that definition wasn't updated
[07:10:16] <dbaupp> SingingBoyo: what's rustc --version say for you?
[07:11:01] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:12:41] <SingingBoyo> rustc 0.6 (803c12d 2013-05-15 06:38:01 -0700) 
[07:13:16] <SingingBoyo> not sure if I managed to revert my install to 0.6 at some point though.  should probably install the latest from incoming.
[07:13:24] <aatch> SingingBoyo, I strongly suggest updating
[07:13:34] <dbaupp> SingingBoyo: yes, that's 2 weeks old
[07:13:38] <aatch> There have been quite a few significant changes
[07:13:44] <dbaupp> (it's not 0.6 though)
[07:13:45] *** Quits: orshem (orshem@19491716.F0FDCE77.E3D28531.IP) (Quit: Leaving)
[07:14:00] <dbaupp> should I file this assertion as a bug?
[07:14:31] <aatch> dbaupp, see if there is something related already, otherwise, go for it.
[07:14:46] <aatch> Let me know when you're done and I'll tag it.
[07:15:14] <dbaupp> https://github.com/mozilla/rust/issues/5882
[07:15:16] <dbaupp> maybe?
[07:16:42] <aatch> dbaupp, looks like it. I'm gonna add more info and suggest an earlier milestone.
[07:16:56] <dbaupp> aatch: I just added a simpler test case
[07:17:59] <aatch> I saw
[07:18:17] <aatch> I think alex's Production Ready nomination is a bit conservative.
[07:19:13] <aatch> That's for stuff like "Rust shouldn't take 4 days to compile" and "This wrong code causes a failure, not an error message"
[07:19:46] <Luqman> Hmmm, this probably shouldn't be using `expect` but `get` right? https://github.com/mozilla/rust/blob/incoming/src/libextra/dlist.rs#L146
[07:21:20] *** Joins: jyyou (jyyou@moz-47B052FA.cs.nctu.edu.tw)
[07:21:54] *** Joins: pyrac (pyrac@moz-984F61EC.w83-200.abo.wanadoo.fr)
[07:23:18] *** tsrube^mil is now known as LimeBurst
[07:29:24] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Client exited)
[07:32:29] *** Joins: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au)
[07:32:45] *** Quits: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net) (Quit: balpert)
[07:33:51] *** Joins: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp)
[07:36:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:36:10] <ghrust> 01[13rust01] 15luqmana 04force-pushed 06try from 142d63517 to 147b78b52: 02http://git.io/k471pw
[07:36:10] <ghrust> 13rust/06try 14f34be85 15Luqman Aden: librustc: Always pass self ByRef.
[07:36:10] <ghrust> 13rust/06try 143049c30 15Luqman Aden: Add test for #5321.
[07:36:10] <ghrust> 13rust/06try 147b78b52 15Luqman Aden: libextra: Use .get() instead of .expect(..).
[07:36:11] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:38:16] *** Quits: SimonSapin (simon@AC677AA0.72C1E24.8EDFB172.IP) (Ping timeout)
[07:46:41] *** Quits: tav (tav@moz-196E6F10.sohonet.co.uk) (Quit: tav)
[07:48:42] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[07:51:42] <Luqman> hmm, there wasn't a magic incantation to get try to build things right?
[07:55:44] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:00:34] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[08:02:04] *** Quits: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP) (Ping timeout)
[08:03:11] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[08:05:03] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:06:47] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:06:56] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[08:07:38] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[08:07:55] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Quit: Leaving.)
[08:08:29] *** Quits: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au) (Client exited)
[08:10:52] *** Joins: SimonSapin (simon@AC677AA0.72C1E24.8EDFB172.IP)
[08:11:44] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:14:37] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[08:17:46] *** Joins: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au)
[08:19:58] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[08:20:27] *** Quits: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au) (Client exited)
[08:38:09] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[08:38:25] *** Joins: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au)
[08:44:32] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[08:55:22] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[08:55:30] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:56:06] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[08:56:12] *** Joins: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net)
[08:57:04] *** Joins: orshem (orshem@19491716.F0FDCE77.E3D28531.IP)
[08:58:25] *** Joins: berak (chatzilla@38BEF962.8B38C502.16E13E53.IP)
[08:59:45] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Quit: leaving)
[09:02:00] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[09:12:34] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[09:13:00] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[09:13:38] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[09:13:43] *** Quits: SimonSapin (simon@AC677AA0.72C1E24.8EDFB172.IP) (Ping timeout)
[09:14:28] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[09:14:50] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[09:18:08] *** Parts: berak (chatzilla@38BEF962.8B38C502.16E13E53.IP) ()
[09:19:17] <nmatsakis> bjz: pong
[09:23:19] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[09:34:54] <bjz> nmatsakis: would this actually be related to the associated items syntax? https://github.com/mozilla/rust/issues/6894
[09:35:06] <bjz> ie. https://github.com/mozilla/rust/issues/6894#issuecomment-18802563
[09:35:21] <bjz> I hadn't realised that
[09:37:46] *** Quits: orshem (orshem@19491716.F0FDCE77.E3D28531.IP) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[09:40:41] <nmatsakis> bjz: there is a relationship, what you wrote in that comment is not the approach we settled on.
[09:41:29] *** Quits: pyrac (pyrac@moz-984F61EC.w83-200.abo.wanadoo.fr) (Quit: pyrac)
[09:42:26] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[09:42:43] *** Joins: pyrac (pyrac@moz-984F61EC.w83-200.abo.wanadoo.fr)
[09:43:27] <nmatsakis> bjz: https://github.com/mozilla/rust/issues/6894#issuecomment-18804712
[09:43:41] <bjz> nmatsakis: also, I was trying to implement a TypeInfo trait for std:: sys: https://github.com/mozilla/rust/issues/6898
[09:44:35] <bjz> nmatsakis: oh that thing.
[09:44:50] <nmatsakis> bjz: I think the way to do that, right now,
[09:44:57] <nmatsakis> bjz: would be to have size_of declared like so:
[09:45:03] *** Joins: Palmik (palmik@moz-5CA3F354.pks.muni.cz)
[09:45:08] <nmatsakis> bjz: fn size_of(x: Option<T>)
[09:45:14] <nmatsakis> bjz: and then you would call it like so:
[09:45:23] <nmatsakis> TypeInfo::size_of(None::<T>)
[09:45:41] <nmatsakis> amazingly enough, this is how it works in Haskell, afaik
[09:45:50] <nmatsakis> oops, sorry
[09:45:52] <nmatsakis> you define size_of as
[09:45:57] <nmatsakis> fn size_of(Option<Self>)
[09:45:59] <nmatsakis> not Option<T>
[09:46:11] <nmatsakis> kind of a hack, but it works.
[09:46:13] <bjz> 8.
[09:46:22] <nmatsakis> basically the types of associated items must include `Self` somewhere
[09:46:46] <bjz> dang
[09:47:21] <bjz> use impl foo = SizeOf for ~Option<float>; seems rather roundabout. what was the reasoning forgoing with that?
[09:47:22] <nmatsakis> what's wrong with that, though?
[09:48:26] <nmatsakis> bjz: there were many factors,
[09:48:32] <bjz> parsing?
[09:48:48] <nmatsakis> parsing among them but not chief among them
[09:48:56] <nmatsakis> for one thing, if you want to have a *complete, unambiguous specification*
[09:48:59] <nmatsakis> you need more than the self type
[09:49:05] <nmatsakis> you also need the values of all the trait type parameters
[09:49:09] <nmatsakis> so, if you syntax is
[09:49:12] <nmatsakis> SelfType::associated_fn()
[09:49:14] <nmatsakis> as you showed
[09:49:18] <nmatsakis> there is no place to put those 
[09:49:21] <nmatsakis> but if youre syntax is
[09:49:38] <nmatsakis> use impl foo = TraitName<A,B,C> for SelfType;
[09:49:50] <nmatsakis> everything is specified, including A, B, C
[09:49:55] <nmatsakis> I had previously proposed:
[09:50:03] <nmatsakis> SelfType::(TraitName::<A,B,C>::associated_fn)
[09:50:11] <nmatsakis> but this was...not popular.
[09:50:14] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Client exited)
[09:50:25] <bjz> What is the downside of doing: (~Option<float>)::size_of()
[09:50:31] <nmatsakis> see above
[09:50:32] <nmatsakis> :)
[09:50:46] <nmatsakis> that only works for some traits
[09:50:47] <nmatsakis> is what i'm saying
[09:50:52] <nmatsakis> and even then,
[09:50:59] <nmatsakis> pcwalton didn't like it because it mixes two kinds of name resolution
[09:51:05] <bjz> mmk
[09:51:11] <nmatsakis> that is, until now `::` has always been lexical name resolution based on what's imported etc
[09:51:26] <nmatsakis> whereas SelfType::size_of() is actually type-based lookup
[09:51:27] <nmatsakis> like a method call
[09:51:37] <nmatsakis> you have to go search for the impls of the TypeInfo trait
[09:51:41] <nmatsakis> and see if any of them are the same as SelfType
[09:51:55] <nmatsakis> anyway, there were an extensive series of blog posts on
[09:51:57] <nmatsakis> this topic
[09:52:01] <bjz> yikes
[09:52:08] <nmatsakis> but I think Felix's summarizes them all
[09:52:09] <nmatsakis> http://blog.pnkfx.org/blog/2013/04/22/designing-syntax-for-associated-items-in-rust/
[09:52:59] <nmatsakis> bjz: but seriously, besides the mild hackiness, what's wrong with the Option<Self> idea?
[09:52:59] <bjz> yeah, I read a bit of that a while ago, but it was a little over my head
[09:53:06] <nmatsakis> yeah, it's a very involved thing
[09:53:31] <nmatsakis> bjz: e.g., https://github.com/mozilla/rust/issues/6898#issuecomment-18804842
[09:53:53] <nmatsakis> I mean, you can hide the need to write None::<T> in the size_of fn anyhow.
[09:55:13] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[09:55:49] <bjz> from a user standpoint, I would expect something like that to work
[09:56:08] <bjz> (without understanding the complexties of the type system)
[09:56:26] <bjz> ie. joe blow
[09:58:10] <bjz> If Real::pi::<float>() works, why doesn't TypeInfo::size_of::<T>() work too?
[09:59:32] <nmatsakis> yeah, sadly it's just not that simple.
[09:59:49] <bjz> unfortunately I'm ignorant of lots of details :(
[09:59:58] <bjz> (sorry)
[10:00:02] <nmatsakis> that was one idea, just concatenate all type parameters from the trait into the fn
[10:00:16] <nmatsakis> so if you have "trait TypeInfo<A,B,C> [for Self] { fn size_of() }
[10:00:32] <nmatsakis> then TypeInfo::size_of effectively has 4 type parameters, A,B,C,Self
[10:00:39] <nmatsakis> that's kind of what the curent implementation does today,
[10:00:43] <nmatsakis> though you are not supposed to take advantage of it
[10:00:53] <nmatsakis> that is, it's an impl detail that I think maybe leaks out
[10:01:07] *** Joins: spider-mario (spidermari@moz-CDAD7F84.rev.sfr.net)
[10:01:13] <nmatsakis> what you're supposed to do is to use the types A, B, C, and Self somewhere in the signature of size_of,
[10:01:18] <nmatsakis> so that the type inferencer can constrain them.
[10:01:34] <nmatsakis> anyway, people found it surprising that the type parameters declared on the trait
[10:01:36] <nmatsakis> "moved" onto the fn
[10:01:42] <bjz> yeah
[10:01:49] <heftig> "use impl" just seems terribly verbose to me
[10:01:49] <nmatsakis> (and I can see why, consider what happens if size_of has type parameters too...)
[10:01:53] <bjz> I don't like that syntax either
[10:01:59] <bjz> yep
[10:02:10] <bjz> I have encountered that with lmath
[10:02:27] <bjz> (was extremely confusing)
[10:02:39] <nmatsakis> so, use impl is only needed for those cases where you want to apply to a non-generic type
[10:02:46] <nmatsakis> it is verbose and i'm not wild about it,
[10:02:59] <nmatsakis> I suspect what will happen is that people will make wrappers for traits that are commonly applied to non-type-parameters
[10:03:13] <nmatsakis> like you showed with type_info::size_of in your example
[10:03:26] <nmatsakis> so that you can call type_info::size_of::<T> and internally,
[10:03:30] <nmatsakis> it is impemented as:
[10:03:48] <nmatsakis> fn size_of<T:TypeInfo>() -> { T::size_of() }
[10:04:06] <nmatsakis> which is itself a kind of shorthand for
[10:04:10] <bjz> I was only doing that because its curently easier to use the stand alone function
[10:04:26] <nmatsakis> fn size_of<T:T=TypeInfo>() { T::size_of() }
[10:04:35] <bjz> I was assuming that in the future we could get rid of it an use T::siz_of()
[10:04:57] <bjz> *and use T::size_of()
[10:05:03] <heftig> and TypeInfo gets derived?
[10:05:06] <nmatsakis> not as currently planned,
[10:05:17] <nmatsakis> though writing out the previous example now,
[10:05:19] <nmatsakis> where T is a type parameter,
[10:05:28] <nmatsakis> I am thinking that this system may cause much confusion.
[10:05:41] <nmatsakis> since in that case you can write T::size_of()
[10:06:00] <nmatsakis> but this does not extend to normal types like int
[10:06:08] <nmatsakis> only bounded type parameters with one bound, in fact.
[10:06:20] <nmatsakis> at least as we described it when we meeting
[10:06:24] <bjz> T.size_of()? :P
[10:06:29] <nmatsakis> *were meeting
[10:06:46] <nmatsakis> this seems like one of those annoying situations where there is no "right answer"
[10:06:52] <bjz> yeah
[10:07:02] <nmatsakis> but I'm not sure we've got the best bad answer yet
[10:07:09] <bjz> but this is tho one thing that really worries me
[10:07:45] <nmatsakis> it does seem a bit like boilerplate in the making, nobody will want to write `use impl` with any regularity, I suspect.
[10:08:05] <nmatsakis> the real question is how often we will have associated fns that get applied to concrete types,
[10:08:08] <nmatsakis> vs type parameters.
[10:08:18] <nmatsakis> I think the assumption we had was that it would be relatively unusual.
[10:08:33] <bjz> for my code at least it would be regular
[10:08:46] <bjz> but then I'm weird
[10:08:47] <nmatsakis> certainly for associated types, this is true, but for associated fns, less so 
[10:08:49] *** Quits: spider-mario (spidermari@moz-CDAD7F84.rev.sfr.net) (Connection reset by peer)
[10:08:49] <bjz> :P
[10:09:19] <nmatsakis> yeah, I'm not sure, it may be more common than we were thinking.
[10:09:43] <nmatsakis> there is much to like in the current plan from the perspective of flexibility and lack of ambiguity,
[10:09:59] *** Joins: spider-mario (spidermari@moz-CDAD7F84.rev.sfr.net)
[10:10:00] <bjz> indeed
[10:10:01] <nmatsakis> but I do agree that what people expect to write is Type::fn()
[10:10:36] <nmatsakis> 
[10:11:11] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:11:26] <aatch> I'm finding that a having associated types, fns and items would make what I'm working on atm a lot easier.
[10:11:34] <aatch> I'm working on LLVM wrappers atm.
[10:12:32] <heftig> aatch: so that rust contains less c++?
[10:13:07] <bjz> aatch: why would you find it useful?
[10:13:28] <aatch> heftig, no. Because I want to use LLVM in another project and the stuff inside rustc is awful.
[10:13:45] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[10:14:03] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Quit: Leaving.)
[10:14:14] <aatch> bjz, basically, being able to express the hierarchy without ending up with a really fragmented api
[10:14:40] <aatch> it's possible, but it's also been a mission to find the exact right combination
[10:14:46] <bjz> it's nice beca
[10:15:06] <bjz> it's nice because the associated items idea allows you to collect things together
[10:16:03] <nmatsakis> aatch: would you be trying to access associated items for concrete types often?
[10:16:13] <nmatsakis> aatch: (if that question makes sense)
[10:16:27] <aatch> nmatsakis, assuming I'm interpreting it right, yes
[10:16:34] <heftig> is it a goal for rust to be completely self-hosting? (and all you would need to compile it being llvm libs and a linker, not clang or gcc)
[10:16:54] <aatch> heftig, well llvm and libuv aren't going anywhere
[10:17:22] <aatch> and we don't actually use a standard LLVM, unless somehow all our patches get upstream
[10:17:25] <heftig> could libuv become an external dep?
[10:17:52] <bjz> nmatsakis: I wonder if there is a wider assumption that is being made that might be constraining your options? (I have no idea what that would be though)
[10:18:47] <aatch> heftig, making rustc /completely/ hosting isn't really a goal.
[10:18:56] <bjz> heftig: libuv will be removed
[10:19:10] <bjz> heftig: once brson completes the runtime
[10:19:26] <aatch> bjz, except the new runtime relies on libuv...
[10:19:28] <heftig> well, that leaves llvm then
[10:19:35] <aatch> it won't be as integrated though
[10:19:39] <bjz> aatch: oh, I am mistaken then
[10:19:46] <heftig> assuming unmodified llvm could be used, would rustc become c-free?
[10:19:47] <nmatsakis> bjz: I don't believe so. 
[10:19:50] <aatch> but it will be part of the standard distro
[10:19:51] <bjz> heftig: ignore my ignorant statement
[10:20:05] <aatch> heftig, I guess.
[10:20:50] <aatch> but I don't see it being a high priority.
[10:20:55] *** Quits: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net) (Quit: balpert)
[10:21:05] <nmatsakis> aatch: out of curiosity, can you give an example?
[10:21:17] <aatch> nmatsakis, of what?
[10:21:28] <nmatsakis> aatch: of a case where you would use an associated item of a concrete type?
[10:21:39] <nmatsakis> aatch: or of the hierarchy you envision
[10:21:49] <bjz> nmatsakis: could you clarify 'concrete type'?
[10:21:59] <nmatsakis> aatch: bjz: basically i'm thinking that if we were going to revisit this discussion, it will be very helpful to have more guiding use cases
[10:22:10] <nmatsakis> in this context, by concrete type I mean "not a generic type parameter"
[10:22:12] <bjz> indeed
[10:22:49] <bjz> nmatsakis: I would say that concerete types would be more frequent in useage
[10:22:49] <nmatsakis> so if you write "fn size_of<T:TypeInfo>() { ... }", then T is not a concrete type in this case,
[10:22:52] <nmatsakis> but everything else.
[10:23:47] <nmatsakis> bjz: I am not sure. Traditionally, anyway, you use a trait because you intend to write generic code?
[10:24:01] <nmatsakis> bjz: but then I think we wind up with a lot of traits that are only sometimes used generically,
[10:24:01] <aatch> Ah, would that extend to stuff like impl S<T:Type> { ... }?
[10:24:05] <bjz> nmatsakis: well, on the user side of a lib
[10:24:05] <nmatsakis> bjz: like perhaps 'iterable'
[10:24:27] <bjz> nmatsakis: the lib developer would use generic types more
[10:24:31] <nmatsakis> aatch: do you mean: impl<T:Type> S<T> { ... }?
[10:24:42] <aatch> nmatsakis, yes
[10:24:43] <nmatsakis> aatch: within the impl, T would not be a concrete type in that example.
[10:25:11] <aatch> Ok, I might be thinking of a different issue then.
[10:25:34] <bjz> nmatsakis: basically I would prefer a solution that improves the experience of users of a library
[10:26:03] <aatch> I think I may be wrong and my problems would be better solved with default methods.
[10:26:05] <nmatsakis> bjz: yes, this makes sense, I hadn't thought about the distinction.
[10:26:15] <bjz> nmatsakis: as opposed to making compramises in favour of the library developer
[10:26:53] <bjz> nmatsakis: like, I already have been bending in contortions to try and provide a nices api for lmath, and I'm happy to do so
[10:27:07] <bjz> *nice
[10:28:03] <aatch> I've had a similar issue here, trying to make sure I have sensible names for everything.
[10:28:11] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[10:29:02] <bjz> nmatsakis: at the moment I have a macro definining mods of the same names as my typedefs, with free-floating functions in them
[10:29:14] <bjz> nmatsakis: to emulate associated functions
[10:29:29] * bjz is a little crazy
[10:29:48] <aatch> I have structs that implement a bunch of traits and implement static fns on the struct directly.
[10:29:59] <bjz> nmatsakis: https://github.com/bjz/lmath-rs/blob/master/src/vec.rs#L684
[10:30:19] <aatch> so I can still get Constant::null(ty) -> Constant<T>
[10:30:30] <aatch> (where ty is T)
[10:30:55] <bjz> nmatsakis: the gain that I get from those contortions is a super nice api: https://github.com/bjz/lmath-rs/blob/master/src/test/test_vec.rs#L31
[10:31:29] <bjz> nmatsakis: that is easier for somebody with less knowledge of the implementation details to understand
[10:31:43] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[10:32:39] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[10:32:42] <bjz> nmatsakis: unfortunately I have run into some cross-crate resolve issues with the current solution, so it doesn't work outside the tes-suite tough :(
[10:33:40] <bjz> nmatsakis: and here is an example of some client code: https://github.com/luqmana/rray/blob/master/trace.rs#L96
[10:34:30] <bjz> nmatsakis: my original 'hack' was this: https://github.com/mozilla/rust/pull/6087#issuecomment-17111505
[10:35:11] <bjz> nmatsakis: impls on type aliases were understandably disallowed though
[10:35:46] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[10:36:20] <nmatsakis> bjz: sorry, was afk
[10:37:20] <nmatsakis> bjz: but yeah I see your situation, I...don't know what's the best fix.
[10:37:25] <bjz> nmatsakis: to illustrate another user doing contortions to get a similar api to lmath, here is some of Jeayne's code in q3: https://github.com/Jeaye/q3/blob/master/src/math/vec3.rs
[10:37:35] <bjz> he does a different approach
[10:37:53] <bjz> ie. he just gives up on generics, and uses a macro and mod
[10:38:08] <nmatsakis> yeah, I've done the thing of defining an impl on the type and also implementing the trait,
[10:38:13] <nmatsakis> so as to avoid needing to import the trait.
[10:38:28] <nmatsakis> oh, that's not quite what he's doing
[10:38:32] <nmatsakis> (it's also a separate issue)
[10:39:01] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:39:03] *** Joins: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[10:39:04] *** Quits: q66_ (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[10:40:09] <bjz> nmatsakis: this is him using his vec type: https://github.com/Jeaye/q3/blob/master/src/gl/texture.rs#L62
[10:40:35] <bjz> nmatsakis: here as well: https://github.com/Jeaye/q3/blob/master/src/gl/texture.rs#L41
[10:42:29] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[10:43:56] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[10:44:13] <bjz> nmatsakis: I guess I'm anticipating more of this happening in the future
[10:44:16] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[10:44:20] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[10:44:38] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Quit: Leaving.)
[10:44:39] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[10:45:01] <nmatsakis> bjz: right.
[10:45:20] <bjz> nmatsakis: it's definitely something that wasn't intended to when designing the language
[10:46:00] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[10:46:11] <bjz> those silly users :)
[10:46:24] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[10:46:39] <bjz> I mean, the whole of std::num is almost like that
[10:47:20] <bjz> ie. even before I came on the scene, you were doing f32::sqrt(x)
[10:47:33] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[10:48:04] * bjz just made that connection
[10:48:32] <dbaupp> bjz: Are you saying that Real::sqrt(x) is worse?
[10:48:49] <dbaupp> (or whatever the exact trait name is)
[10:49:11] <nmatsakis> bjz: I'm actually not sure what you mean by that :)
[10:49:23] <bjz> yep
[10:49:34] <nmatsakis> bjz: but if I had my druthers, we'd be writing `SelfType::associated_item`
[10:49:46] <bjz> druthers?
[10:49:53] <nmatsakis> bjz: i.e., that is my personal preference,
[10:49:58] <nmatsakis> but I lost the argument.
[10:49:59] <bjz> ah
[10:50:15] <nmatsakis> there are possibly some technical hurdles to be resolved,
[10:50:16] <nmatsakis> I must admit.
[10:51:55] <bjz> sorry, I'll stop now
[10:52:05] <bjz> :(
[10:53:13] <nmatsakis> bjz: I think you've got a good point, and the examples are helpful.
[10:53:44] <bjz> Zero::zero() is another weird one
[10:54:39] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[10:54:51] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[10:55:44] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[10:55:51] <bjz> when I say 'wider assumptions' I was sort of alluding to when you were talking about 'mixing two kinds of name resolution' (I don't fully understand that though)
[10:56:00] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[10:56:22] <bjz> why aren't you using the '.' operator like in Java, for example?
[10:56:31] *** Joins: jviereck (Adium@moz-AE0D2189.dynamic.hispeed.ch)
[10:56:39] <bjz> (just wondering)
[10:57:03] <bjz> oh wait
[10:57:08] <bjz> I think I know
[10:57:25] <aatch> Wow, I cannot type metadata properly
[10:57:26] <bjz> dw
[10:57:34] <aatch> metdata, every time
[10:57:44] <heftig> <Zero for int>::zero()
[10:57:57] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[11:01:02] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[11:02:47] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[11:05:49] *** Joins: stowellde (uid6365@moz-D8B63698.irccloud.com)
[11:08:12] *** Quits: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[11:09:27] *** Quits: jviereck (Adium@moz-AE0D2189.dynamic.hispeed.ch) (Quit: Leaving.)
[11:11:15] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[11:11:18] *** Joins: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP)
[11:11:52] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:14:52] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[11:15:21] <aatch> Hey, how does the new loop protocol work again?
[11:16:42] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[11:16:54] <dbaupp> aatch: return false if the loop broke, true otherwise
[11:17:12] <aatch> cool.
[11:17:16] <aatch> thanks
[11:25:52] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[11:30:43] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[11:30:57] <doener> aatch: nice work with the pipeline. Finally sane code for vec::len() again :-)
[11:31:11] <aatch> doener, thanks
[11:33:26] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[11:33:47] <doener> aatch: seems to have fixed https://github.com/mozilla/rust/issues/6623  as well :-D
[11:34:26] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[11:34:38] <aatch> doener, cool, could post a confirmation to the issue? I'll close it then.
[11:35:02] *** Joins: SimonSapin (simon@AC677AA0.72C1E24.8EDFB172.IP)
[11:35:13] *** Joins: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp)
[11:35:22] <doener> aatch: oops, already closed it
[11:36:25] <aatch> doener, oh, it's your issue.
[11:36:28] <aatch> nvm then
[11:36:52] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[11:39:13] <dbaupp> doener: the reason it's "fixed" is because from_elem is implemented as you suggest https://github.com/mozilla/rust/blob/incoming/src/libstd/vec.rs#L167
[11:39:31] *** Joins: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP)
[11:39:52] <dbaupp> doener: not necessarily because of aatch's pipeline changes
[11:40:06] <doener> oh
[11:40:13] <doener> :-(
[11:40:28] <aatch> dbaupp, trying to diminish my glory with facts >:(
[11:40:48] <dbaupp> aatch: i'm sorry :(((
[11:40:49] <dbaupp> :P
[11:40:52] <aatch> :D
[11:41:10] <dbaupp> doener: it's probably worth trying with the old implementation, to see if the pipeline improved it
[11:41:23] <doener> Yeah, already on it
[11:42:46] *** Joins: ysuzuki_ (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[11:43:43] <doener> dbaupp: you were huonw on github, right?
[11:44:01] <dbaupp> doener: still are :)
[11:44:05] *** Quits: ysuzuki (ysuzuki@moz-60FA9D06.net119083145.t-com.ne.jp) (Ping timeout)
[11:44:28] <doener> just wondering, because the input box won't complete your username. Oh well...
[11:44:43] <aatch> doener, yeah, it doesn't always
[11:44:50] <aatch> and it's really random.
[11:45:14] <aatch> I've had it not auto-complete pcwalton and nmatsakis before
[11:45:24] * nmatsakis hates that
[11:47:24] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[11:48:08] <doener> same as before :-/
[11:48:24] <dbaupp> doener: :(
[11:48:51] <dbaupp> aatch: you need to be more glorious!
[11:51:13] *** Joins: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de)
[11:52:23] <aatch> Closures are pretty weird, both in codegen and LLVM in general
[11:53:32] <dbaupp> isn't everything weird in rustc's codegen atm? ;P
[11:53:51] <aatch> dbaupp, well, yeah, but closures especially so
[11:54:00] <dbaupp> heh
[11:55:34] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[11:58:01] <aatch> Ahh, so that's what the type of BasicBlocks is.
[11:58:04] <aatch> are?
[11:58:06] <aatch> whatever
[11:58:16] <aatch> "Label"
[11:58:55] <dbaupp> what's #[unsafe_destructor] for?
[11:59:43] <aatch> dbaupp, when Drop is used as an extension trait and when the thing you are implementing on is non-owned
[12:00:18] <dbaupp> aatch: erm... does that include unsafe pointers?
[12:00:26] <dbaupp> i.e. a struct containing unsafe pointers?
[12:00:27] <aatch> nope.
[12:00:43] <aatch> unsafe pointers are treated pretty much the same as `uint`
[12:00:57] <aatch> except you can dereference them
[12:01:33] <dbaupp> ah, I see
[12:03:08] <dbaupp> thanks
[12:09:39] <MaikKlein> core was renamed to std right?
[12:11:14] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[12:11:46] *** Quits: xandy (xandy@moz-EA2E101B.eventnet.ccc.de) (Ping timeout)
[12:12:22] <dbaupp> MaikKlein: yes, and std to extra
[12:12:29] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:15:40] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[12:15:57] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Quit: Leaving.)
[12:16:13] *** Joins: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP)
[12:16:18] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[12:16:59] <Thiez> aatch: rustray is awesome again
[12:17:40] <aatch> Thiez, np
[12:17:59] <Thiez> I did kill some of the #[inline(always)], but some of them really seemed to matter
[12:18:05] <aatch> I was the one that broke everything in the first place
[12:19:16] <Thiez> still, with the optimization passes and the new fmin/fmax it gets under 3.6 seconds at times, so I'm rather pleased
[12:20:15] <aatch> Thiez, yeah, I noticed about a 20% performance improvement from pre-regression
[12:29:18] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Textual IRC Client: www.textualapp.com)
[12:29:33] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[12:31:13] *** Quits: RMF (RMF@C168F480.14CBA568.1D9D5961.IP) (Ping timeout)
[12:33:03] *** cmr|zzz is now known as cmr
[12:34:46] *** Joins: RMF (RMF@68B6AD91.A3D80C3C.8D19547B.IP)
[12:36:32] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[12:36:51] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[12:37:24] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[12:38:02] *** Quits: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP) (Ping timeout)
[12:39:32] <MaikKlein> rusti: do vec::from_fn(3) |init_val| {let (port, chan) = stream(); chan };
[12:39:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bbCj
[12:40:22] <MaikKlein> rusti: let v = do vec::from_fn(3) |init_val| {let (port, chan) = stream(); chan };
[12:40:24] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/AZKZ
[12:41:04] <dbaupp> rusti: use std::vec; let v = do vec::from_fn(3) |init_val| {let (port, chan) = stream(); chan };
[12:41:04] <MaikKlein> rusti: use std::comm::{stream, Chan,Port}; do vec::from_fn(3) |init_val| {let (port, chan) = stream(); chan };
[12:41:05] -rusti- error: internal compiler error: unexpected failure
[12:41:05] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[12:41:05] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[12:41:05] -rusti- application terminated with error code 101
[12:41:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YCFG
[12:41:20] <cmr> good job, you broke it ;p
[12:41:23] <dbaupp> hm, who was that?
[12:41:28] <MaikKlein> this is allowed right?
[12:41:29] <MaikKlein> me
[12:41:31] <dbaupp> rusti: use std::vec; let v = do vec::from_fn(3) |init_val| {let (port, chan) = stream(); chan };
[12:41:31] -rusti- error: internal compiler error: unexpected failure
[12:41:32] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[12:41:32] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[12:41:32] -rusti- application terminated with error code 101
[12:41:33] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[12:41:49] <dbaupp> MaikKlein: breaking things is totally allowed :P
[12:41:54] <MaikKlein> :D
[12:42:07] <dbaupp> rusti: use std::vec; let v = do vec::from_fn(3) |init_val| {let (port, chan) = stream::<int>(); chan };
[12:42:09] -rusti- ()
[12:42:48] <dbaupp> That ICE is because Rust couldn't determine the type of the stream, and it don't like that.
[12:42:57] <MaikKlein> oh nice workaround
[12:43:21] <dbaupp> rusti: None
[12:43:21] -rusti- error: internal compiler error: unexpected failure
[12:43:22] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[12:43:22] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[12:43:22] -rusti- application terminated with error code 101
[12:43:34] <dbaupp> same thing
[12:44:14] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[12:46:07] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[12:46:36] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[12:47:12] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[12:47:54] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[12:48:56] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[12:53:37] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[12:55:16] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[12:56:24] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[12:56:29] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[12:57:26] <nmatsakis> sigh, ICE?
[12:57:49] *** cscottnet_away is now known as cscottnet
[12:59:20] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[13:00:05] <doener> what's the calling convention for rust on x86_64?
[13:00:48] <cmr> fastcc ("whatever llvm feels like today") I thought
[13:03:40] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[13:04:50] <aatch> cmr, correct
[13:07:47] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Ping timeout)
[13:09:03] <doener> thanks
[13:10:43] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[13:13:06] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:16:47] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[13:17:49] <cmr> rusti: 1<<16
[13:17:51] -rusti- 65536
[13:18:38] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[13:24:43] <MaikKlein> is there a task safe println?
[13:29:26] *** Joins: kornholi (kornholi@moz-185F17B0.net)
[13:31:32] <dbaupp> MaikKlein: I have a feeling `do task::atomically { println("foo"); }` might make println task-safe, but I don't actually know
[13:33:13] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[13:35:54] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[13:36:16] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:36:53] <aatch> what do you mean by "task safe" ?
[13:38:31] <MaikKlein> well that println should print the string and then a \n but it sometimes skips the new line
[13:39:07] *** Quits: SimonSapin (simon@AC677AA0.72C1E24.8EDFB172.IP) (Ping timeout)
[13:39:26] <dbaupp> aatch: i.e. two println's called in parallel can interleave output
[13:39:32] <cmr> it doesn't skip, the threads just stomp over stdout
[13:42:24] <aatch> Ah, right. In that case, no, not as far as I know.
[13:43:01] <dbaupp> MaikKlein: it seems that atomically doesn't help
[13:43:52] *** Joins: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP)
[13:43:52] *** Quits: youknowone (youknowone@A826BD81.8A0DEF81.38747683.IP) (Z:lined (Open Proxy found on your host. Please visit www.blitzed.org/proxy?ip=115.68.131.49 for more information.))
[13:44:01] <dbaupp> MaikKlein: print(fmt!("%s\n", string)) works though
[13:44:33] <MaikKlein> dbaupp: ah nice thanks
[13:45:04] <cmr> Ah, println does two separate calls to write()? That'd do it.
[13:45:19] <cmr> (I think posix guarantees that all write()s smaller than the page size are atomic)
[13:47:04] <dbaupp> cmr: it calls 'w.write_str(s); w.write_str(&"\n");` so yes.
[13:47:22] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[13:47:31] <dbaupp> it's strange that the second one isn't write_char('\n')
[13:49:30] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[13:53:01] *** Joins: CrazyDownloader2 (CrazyDownl@moz-6A2B38FE.retail.telecomitalia.it)
[13:53:06] <CrazyDownloader2> ciao
[13:53:09] <CrazyDownloader2> !lista
[13:53:26] *** Quits: CrazyDownloader2 (CrazyDownl@moz-6A2B38FE.retail.telecomitalia.it) (Quit: )
[13:53:35] <aatch> sigh...
[13:54:34] *** Joins: nencio (foolish@moz-EB6D27EE.retail.telecomitalia.it)
[13:55:01] <MaikKlein> do you think this could be a good example for tasks? http://maikklein.github.io/2013/06/02/tasks-in-rust/
[13:55:37] <MaikKlein> or am I doing anything bad?
[13:55:45] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:55:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:56:26] <cmr> MaikKlein: you should use eachi and give ever task a different number, to show disorder
[13:56:49] <cmr> well, task number does that already I guess
[13:58:43] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[13:59:09] <MaikKlein> yeah, but I also forgot to give my variables meaningful names
[13:59:14] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:59:31] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[14:03:29] <MaikKlein> github is down?
[14:03:31] <MaikKlein> https://github.com/
[14:03:42] *** Quits: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP) (Ping timeout)
[14:03:49] <cmr> yup
[14:03:54] <cmr> https://status.github.com/
[14:04:09] *** Quits: nencio (foolish@moz-EB6D27EE.retail.telecomitalia.it) (Quit: )
[14:06:36] <MaikKlein> well, never saw that before :)
[14:06:57] *** Parts: corecode (2@moz-BCA4C10D.org) (:wq)
[14:07:32] *** Joins: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP)
[14:08:27] *** decoder_ is now known as decoder
[14:09:41] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[14:10:01] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[14:11:02] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[14:11:46] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[14:15:53] *** Joins: Yoric (Yoric@moz-DB4A9C19.scl3.mozilla.com)
[14:17:33] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[14:17:56] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Quit: Leaving.)
[14:17:56] *** Joins: jack (jack@moz-41443983.npg.sta.suddenlink.net)
[14:19:45] *** Quits: jack (jack@moz-41443983.npg.sta.suddenlink.net) (Ping timeout)
[14:23:33] *** Quits: dbaupp (Thunderbir@moz-C6B1454A.lns20.syd7.internode.on.net) (Ping timeout)
[14:26:39] <cmr> Is there any way to realloc a vec to be *smaller*?
[14:26:39] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[14:26:50] <cmr> ie, I overallocated, and now want to free some of the extra up
[14:26:53] <strcat> cmr: not yet
[14:26:59] <strcat> we need shrink_to_fit like C++11
[14:27:12] <strcat> cmr: well, you can do it manually
[14:27:24] <strcat> cmr: make a new vector ;p
[14:29:10] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[14:30:50] <aatch> I think I'm getting the hang of traits.
[14:33:45] <doener> hm, I wonder why some "drop_glue"s aren't getting inlined, although they're set to "always inline"
[14:37:41] *** Quits: spider-mario (spidermari@moz-CDAD7F84.rev.sfr.net) (Input/output error)
[14:38:37] <cmr> What is glue, exactly?
[14:40:40] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bbl)
[14:40:59] <doener> helper code, that handles taking/dropping refs, freeing allocs and visiting node (whatever that might be)
[14:42:02] <doener> I'm trying to figure out https://github.com/mozilla/rust/issues/6682 and saw that even with -O, the drop_glue for ~uint isn't inlined, although the compiler marks it as "always inline" AFAICT
[14:53:24] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[14:54:07] *** Quits: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de) (Ping timeout)
[14:55:04] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[14:56:02] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:56:55] *** Quits: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP) (Ping timeout)
[14:56:57] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[14:57:36] *** Quits: ysuzuki_ (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Client exited)
[14:57:56] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:01:41] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[15:06:02] *** Joins: Solitario (DINO@moz-97F294FA.static.axtel.net)
[15:11:38] *** Parts: Solitario (DINO@moz-97F294FA.static.axtel.net) ()
[15:11:42] *** Joins: victorporof (victorporo@114C3C1F.E934E1A1.4A6B528C.IP)
[15:11:44] *** cscottnet is now known as cscottnet_away
[15:12:10] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:14:45] *** Joins: gareth0 (gareth0@moz-10A7C8D0.dynamic.dsl.as9105.com)
[15:16:02] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:17:48] *** Joins: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp)
[15:20:04] *** Joins: koomi (koomi@moz-37293BFC.pools.arcor-ip.net)
[15:20:47] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:27:21] <gareth0> r? https://github.com/mozilla/rust/pull/6867
[15:30:55] *** Joins: oksobul (Instantbir@5420C305.88F2F905.4A037BC4.IP)
[15:31:49] <nmatsakis> gareth0: r+
[15:32:01] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[15:32:04] *** Quits: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP) (Ping timeout)
[15:32:19] <gareth0> hurrah, thanks nmatsakis 
[15:34:05] *** Joins: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP)
[15:36:37] <oksobul> Hello. I am trying to build rust on Windows. The last line I saw was:
[15:36:37] <oksobul> extracting rust-stage0/bin/rustllvm.dll
[15:36:37] <oksobul> It seems that computer is doing something but no output is generated. Is this ok?
[15:37:15] *** Joins: unbracketed (textual@moz-7F0EE151.lsanca.fios.verizon.net)
[15:37:24] <cmr> oksobul: that shouldn't take too long. I find that when building on windows it sometimes gets "stuck", a Ctrl-c and another "make" usually gets it going again
[15:37:57] <oksobul> I used "make -j3". Could this cause problems?
[15:38:00] <cmr> yes
[15:38:09] <cmr> Parallel make on windows is really broken
[15:38:18] <cmr> I don't know why, it just doesn't work :)
[15:38:35] <oksobul> Ok I'll try only make
[15:41:30] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[15:42:45] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[15:45:53] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[15:47:07] <oksobul> Now I received this error when tryed make under windows:
[15:47:08] <oksobul> make: *** No rule to make target `/c/vcs/rust/src/llvm/lib/Target/PowerPC/Makefile/toy.cpp', needed by `/c/vcs/rust/llvm/i686-pc-mingw32/Release+Asserts/bin/llvm-config.exe'.  Stop.
[15:47:31] <cmr> oksobul: try make again
[15:49:02] <oksobul> Tried thrre times with the same result.
[15:49:10] <cmr> Ok, dunno what to say then
[15:49:23] *** Joins: blitter (blitter@moz-BA14D5CF.dyn.centurytel.net)
[15:49:27] <cmr> What branch are you building?
[15:49:48] <oksobul> master
[15:50:07] <cmr> try building incoming (although master should work)
[15:50:36] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[15:51:34] *** Quits: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP) (Ping timeout)
[15:53:29] *** Joins: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP)
[15:55:57] <oksobul> What contains the auto branch?
[15:56:16] <cmr> it's what bors, our test bot, merges into when testing pull requests
[15:56:41] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:56:41] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:00:20] *** Joins: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP)
[16:05:04] <Yurume> rusti is dead, why?
[16:05:23] <cmr> Yurume: it runs on strcat's laptop. could have rebooted, or pinged out, or ...
[16:05:54] * Yurume realizes he is not good at making fun of ping timeout
[16:06:21] <Yurume> anyway, I'm currently working on rust-opengles-angle
[16:06:32] <Yurume> which runs on Windows hopefully
[16:08:28] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[16:08:32] <oksobul> Just tried to build incoming branch and the same error occurred.
[16:08:52] <kimundi> oksobul: Have you tried cleaning up the build dir?
[16:09:12] <oksobul> Hmm probably not. :-)
[16:09:31] <kimundi> Like, just wipe it completly and start with a fresh checkout of incoming?
[16:09:33] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Ping timeout)
[16:09:48] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[16:10:03] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:12:37] *** Quits: unbracketed (textual@moz-7F0EE151.lsanca.fios.verizon.net) (Quit: Computer has gone to sleep.)
[16:12:41] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[16:12:54] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:18:36] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:18:36] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/lwHtbw
[16:18:36] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:18:41] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:18:41] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/JYHLlQ
[16:18:41] <ghrust> 13rust/06auto 14d443fc6 15gareth: Add a get_mut method to accompany the get method.
[16:18:41] <ghrust> 13rust/06auto 14077ca79 15bors: auto merge of #6867 : Dretch/rust/hashmap_get_mut, r=nikomatsakis
[16:18:41] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:19:21] *** Joins: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net)
[16:19:22] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[16:19:42] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[16:19:54] *** Joins: doomlord_ (walter@moz-3CF8202D.range81-159.btcentralplus.com)
[16:20:11] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Quit: Leaving)
[16:21:34] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[16:24:02] *** Parts: Tad (Tom@moz-2036EE54.kimsufi.com) ()
[16:25:42] *** Joins: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com)
[16:26:37] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Ping timeout)
[16:26:52] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[16:27:11] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[16:30:27] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[16:31:51] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[16:32:04] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[16:32:32] <joebobjoe> Why doesn't thiis work? let monster_size: float = 5;
[16:32:49] <cmr> rusti: let monster_size: float = 5;
[16:32:55] <doener> joebobjoe: 5 is an int, not a float. Try 5f instead
[16:32:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jcKd
[16:33:08] <cmr> it should be inferred, there's a bug open for it I think
[16:33:08] <doener> rusti: let monster_size: float = 5f; monster_size
[16:33:11] -rusti- 5
[16:33:42] <joebobjoe> cmr: Okay that's what I wanted to know
[16:35:17] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[16:36:13] <joebobjoe> Does rust have user-defined syntax extensions?
[16:36:22] <cmr> joebobjoe: yes, macro_rules!
[16:37:16] <joebobjoe> Oh, I see: "You can define your own syntax extensions with the macro system. For details, see the macro tutorial." Guess I should read the tut first :D
[16:39:56] *** Quits: oksobul (Instantbir@5420C305.88F2F905.4A037BC4.IP) (Quit: Instantbird 1.2 -- http://www.instantbird.com)
[16:40:27] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[16:40:42] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Ping timeout)
[16:40:45] <cyndis> in the future (and maybe now if you're daring) you can also write syntax extension plugins for the compiler
[16:41:31] <cyndis> ugh, bad timing
[16:41:44] <Blei> terminology crash...
[16:42:51] <Blei> syntax extensions vs. macros: they are the same/similar in the tutorial and as seen as a typical user but are quite different in the language
[16:45:48] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Quit: Lost terminal)
[16:46:06] *** Joins: victorporof_ (victorporo@114C3C1F.E934E1A1.4A6B528C.IP)
[16:47:05] *** Quits: victorporof (victorporo@114C3C1F.E934E1A1.4A6B528C.IP) (Ping timeout)
[16:47:21] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[16:48:20] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[16:49:26] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[16:49:54] *** Joins: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de)
[16:50:09] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[16:50:23] <kimundi> all macros are syntax extensions, but not all syntax extensions are macros?
[16:50:35] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[16:50:54] <strcat> kimundi: I wouldn't really say macros are syntax extensions
[16:51:04] <strcat> it might be convenient to say that but it is only going to confuse people
[16:51:09] <kimundi> why not?
[16:51:26] <strcat> because it will confuse people. macros are a DSL implemented *with* a syntax extension but alone they are not
[16:51:38] <kimundi> confusion aside it's not wrong, or is it?
[16:51:46] <strcat> it is wrong
[16:53:16] <kimundi> Hm... The term syntax extension sounds to me like it means "a way to use custom syntax rules to achieve things the regular rust syntax is not capable of"
[16:53:49] <joebobjoe> So Rust doesn't have syntax extensions?
[16:54:03] <kimundi> lol
[16:54:08] <kimundi> so much for confusion
[16:54:20] <kimundi> joebobjoe: Rust has syntax extensions
[16:54:43] <strcat> kimundi: yeah but it's not what it means in rust
[16:54:57] <strcat> 'function' sounds like the math term 'function' but it's not what it means in rust
[16:55:55] *** Quits: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de) (Ping timeout)
[16:56:30] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:56:36] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:56:45] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[16:56:50] <kimundi> joebobjoe: You can define macros with 'macro_rules!', which are somewhat limited, you can write syntax extensions that can use arbitrary rust code at compiletime (currently just by defining it in the compiler, but that will chang), and you can define custom attributes that can use arbitrary rust code (again, atm just as build-ins)
[16:57:29] <kimundi> strcat1: Well, the question then is, what is the official deffinition of a syntax extension in rust ;)
[16:57:33] <joebobjoe> kimundi k
[16:58:06] <doomlord> function vs procedure..
[16:58:20] *** strcat1 is now known as strcat
[16:58:33] <doomlord> did i see some meeting notes where a use of the term proc was being debated here?
[16:58:43] <strcat> kimundi: the official definition is the extensions written in rust code 
[16:58:51] <strcat> if you want to call macros syntax extensions then you need a new term for those
[16:59:03] <strcat> can't just call 2 different things the same term or you'll confuse people
[16:59:09] <cmr> doomlord: yes, http://smallcultfollowing.com/babysteps/blog/2013/05/13/mutable-fn-alternatives/ and http://smallcultfollowing.com/babysteps/blog/2013/05/14/procedures/
[16:59:21] <strcat> macro_rules! is implemented as a syntax extension
[17:00:41] <kimundi> strcat: Sure, less confusion is always good, and IF it's officially defined that way, then whatever. But I remember 'syntax extension' being the  catch all term for custom attributes, declarative macros, and procedural macros
[17:02:11] <strcat> I don't really think attributes extend syntax, any more than defining a custom function extends syntax
[17:02:29] <kimundi> Also, I think the explanation 'foo!(...) is a syntax extension' might be less confusing than 'foo!(...) is a syntax extension or a macro, depending on what foo is', just saying...
[17:02:52] <strcat> there's still a difference 
[17:03:11] <kimundi> Sure it is
[17:03:45] <kimundi> BUt is it relevant?
[17:03:52] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[17:04:14] <kimundi> I think that's just an implementation detail
[17:04:14] *** Joins: Sevki (Sevki@moz-EB20D033.cable.virginmedia.com)
[17:04:50] <strcat> kimundi: because it matters to a user
[17:04:55] <strcat> they can't define something like fmt!
[17:04:59] <joebobjoe> Why can't I do println(5); in rust? No implicit conversions or something (sorry I am noob)?
[17:05:07] <kimundi> fail!() is a declarative macro but might just as well be a procedural one, wouldn't change what it does.
[17:05:10] *** Quits: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP) (Quit: ëžœë¤ì€ ì‡ í‡´í–ˆìŠµë‹ˆë‹¤.)
[17:05:19] <bstrie> joebobjoe: you can use the error-reporting macros to do that, `error!(5)`
[17:05:24] <strcat> kimundi: it's not really declarative vs procedural
[17:05:26] <kimundi> strcat: NOt yet, but they will
[17:05:30] <strcat> you could write a "procedural" one as functional rust
[17:05:37] <strcat> one is written in the macro DSL, one is written in rust
[17:05:48] <cmr> joebobjoe: no, there are no implicit conversions.
[17:05:57] <strcat> kimundi: yeah but when they will, they will have to dynamically load a .so with the syntax ext
[17:06:00] <strcat> it will not be at all the same
[17:06:14] *** Parts: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au) ()
[17:06:28] <joebobjoe> bstrie what magic is that???
[17:06:52] <cmr> joebobjoe: it's a syntax extension, part of the logging system
[17:07:09] <cmr> http://static.rust-lang.org/doc/rust.html#logging-system
[17:07:36] <kimundi> strcat: No reason the compilerr couldn't be streamlined to generate the .so automatically from some definitions in you .rs file. Just because A is harder to use/ more cumbersome doesn't automatically mean it's sometihng different than B.
[17:08:17] <strcat> so it's different but it's... not different? ;\
[17:08:30] <strcat> that's obviously going to confuse people
[17:08:47] <kimundi> They are differesntly implemneted but fall under the sema cathegory
[17:08:57] <kimundi> urg, spelling...
[17:08:59] <strcat> so what are they both called?
[17:09:26] <kimundi> syntax extension
[17:09:35] <strcat> no, what are the individual names
[17:09:38] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:10:10] <kimundi> Well, I called them declarative vs procedural macros, but I don't know if those names would be correct.
[17:10:25] <strcat> it's not because rust isn't inherently procedural
[17:11:14] <Blei> i like those names
[17:11:19] <joebobjoe> I like rust better than c++
[17:11:22] <kimundi> declarative: You declare what the macro does with the macro DSL. Procedural: You write a rust procedure that produces an AST.
[17:12:11] <cmr> those names make sense to me
[17:12:16] <cmr> if even they aren't "perfect"
[17:12:32] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:12:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/JYHLlQ
[17:12:32] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:12:55] <strcat> or we could just call them what we do now (macros and extensions)
[17:13:12] <kimundi> Do we call them that?
[17:13:24] <strcat> yes
[17:13:29] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[17:13:31] <strcat> maybe you don't, but the docs do
[17:13:35] <strcat> and the codebase does
[17:13:36] <kimundi> I've heard a lot of different names thrown around in thin channel for them :P
[17:13:48] <strcat> people throw around a lot of names for ~ too and lots aren't accurate
[17:13:53] <strcat> "owned pointer" definitely isn't right
[17:14:06] <strcat> an @ pointer is owned too, it's what it points at that isn't
[17:14:12] <benh> "'owned' pointer"
[17:14:39] <kimundi> I think this matter could be simply solved by asking pauls :)
[17:14:58] <joebobjoe> What;s the difference between core lib and std lib?
[17:15:07] <benh> imo it's like calling float* a "float pointer", the pointer isn't suddenly floating-point but you know what i mean
[17:15:09] <kimundi> joebobjoe: Depends... xD
[17:15:49] <kimundi> joebobjoe: old core is new std, and old std is new extra, so... your quesiton could mean two different things :)
[17:15:50] <strcat> benh: but that can't be interpreted multiple ways
[17:16:04] <cmr> joebobjoe: Are you using 0.6?
[17:16:22] <strcat> benh: ~T isn't necessarily Owned anyway
[17:16:32] <strcat> if T isn't
[17:16:56] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Ping timeout)
[17:16:58] <strcat> so it's an owned pointer but it's not owned
[17:16:59] <benh> not Owned, but owned by the pointer in that it at least shallowly defines the lifetime
[17:17:12] <joebobjoe> cmr yes
[17:17:32] <strcat> benh: extra::rc is still 'owned', it just has multiple owners
[17:17:50] <strcat> @ is really the only thing you can call non-owned (or owned by the gc)
[17:18:58] <cmr> joebobjoe: Alright, so on incoming core was renamed to std and std was renamed to extra, which better reflects their purpose. core is mostly for manipulating built-in data structures, defining hugely ubiquitous traits (Eq or Ord, for comparing things, for example). std (now extra) is for "other" stuff like json encoding and stuff. it will be moving into its own repo eventually
[17:19:02] <benh> I already forgot what I posted in that bikeshed issue
[17:19:11] <kimundi> non-stack-owned :P
[17:19:23] <strcat> not related to the stack
[17:19:25] <strcat> ~ can be anywhere
[17:19:39] <strcat> and you can hold all the owners of an extra::rc box on the stack
[17:19:44] <joebobjoe> cmr why moving to separate repo?
[17:19:55] <cmr> joebobjoe: because it doesn't need to be in the compiler source
[17:20:26] <strcat> the tutorial still has blatantly incorrect information like saying ~[T] is 'on the exchange heap'
[17:20:56] <benh> ~[T] is whereever, but the [T,.. ?] in ~[T] is on the exchange heap?
[17:21:04] <strcat> benh: nope
[17:21:12] <strcat> it's not in the exchange heap if it contains @
[17:21:16] <kimundi> well the only two possible owners in rust are a local variable and @. So stack-owned and non-stack-owned seems fitting :P
[17:21:17] <strcat> neither is ~
[17:21:32] <strcat> kimundi: ~ can be in @
[17:21:36] <strcat> @ can be in ~
[17:21:58] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[17:21:59] <kimundi> so?
[17:22:00] <benh> I didn't realize the exchange heap was anything but where malloc gets its stuff from
[17:22:06] <strcat> kimundi: ~ isn't 'stack owned'
[17:22:14] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:22:14] <strcat> benh: @ comes from malloc too atm
[17:22:20] <strcat> exchange/local heap aren't really things
[17:22:31] <strcat> they're implementation details and it's not actually how it's implemented so...
[17:22:36] <kimundi> strcat: Never claimed that :P
[17:23:24] <strcat> things that are Owned are sendable - that's all we have to say
[17:23:25] <kimundi> Just thought of something to call the two possible ownership trees...
[17:23:41] <benh> ugh all those kinds are terrible
[17:23:52] <strcat> benh: agreed
[17:23:58] <strcat> Owned should be called Send
[17:24:12] <benh> I'd forget what it does eventhen :(
[17:24:20] <strcat> not all things that are owned are Owned and not all things that are Owned are owned
[17:24:32] <strcat> benh: sendable
[17:24:35] <strcat> ;p
[17:24:45] <benh> half the time I don't worry about sending though so I won't remember!
[17:24:46] <strcat> and &const isn't Const, what great names those are
[17:24:57] <benh> I mean at least we have names for them in the language, unlike C++'s varying ideas of pod, standard layout, virtual, blah
[17:25:06] <strcat> &const means mutable but not through this reference
[17:25:12] <strcat> pretty terrible abuse of the word constant
[17:25:26] <kimundi> &readonly
[17:25:34] <kimundi> or &ro
[17:25:57] <strcat> and Const is a bad name
[17:26:04] <strcat> nothing to do with constant
[17:26:24] <strcat> anyway imo...
[17:26:45] <kimundi> what does it mean again?
[17:27:00] <kimundi> Freezeable?
[17:27:11] <strcat> Send (instead of Owned), unique pointer (~), managed pointer (@), borrowed reference (&) since we already have 'ref' and 'ref mut' and need a name for a module to put that stuff in (ref.rs)
[17:27:22] <strcat> kimundi: well not really
[17:27:29] <strcat> kimundi: Const means statically freezable
[17:27:45] <benh> Does that mean no embedded @mut?
[17:27:59] <cmr> I thought @ wanted to be "managed box"
[17:28:00] <strcat> benh: means no Cell, no @mut, no extra::rc::RcMut, no RW ARCs
[17:28:11] <benh> ... right :(
[17:28:20] <strcat> cmr: well, owned/managed box works too
[17:28:34] <strcat> but no one is calling them that ;\
[17:29:00] <kimundi> Const => StaticFreeze? :P
[17:29:18] <illissius> iirc they decided Const => Freeze and Owned => Send at the last meeting-ish
[17:29:27] <benh> What is Const necessary for again?
[17:29:37] <strcat> benh: memory safety
[17:29:41] <strcat> stopping cycles
[17:29:46] <strcat> in reference counted stuff
[17:29:50] <joebobjoe> cmr: Speaking of compilation, are there any future ideas for improving Rust build time? It took 102 minutes to build on my 2008 MacBook :(
[17:30:07] <cmr> joebobjoe: yes, it's a constant item of optimization
[17:30:17] <cmr> joebobjoe: a few recent threads on the ML about it.
[17:30:20] <benh> joebobjoe: out of curiosity how big is your build dir?
[17:30:51] <strcat> joebobjoe: how much memory do you have?
[17:31:06] <cmr> it should only take ~20 minutes, sans LLVM
[17:31:10] <joebobjoe> benh: I used Homebrewâ€¦ what do you want?
[17:31:18] <joebobjoe> System Information: Model: MacBook (Early 2008) â€¢ CPU: Intel Core 2 Duo T8100 (2 Threads, 2 Cores) @ 2.10 GHz â€¢ Memory: 2.50 GB â€¢ Uptime: 45 Minutes â€¢ Load: 33% â€¢ OS: Mac OS X 10.7.5 (Lion) (Build 11G63)
[17:31:37] <benh> nvm
[17:31:48] <strcat> joebobjoe: did you compile 0.6 or incoming?
[17:32:08] <joebobjoe> Build time included downloading (but I have a fast connection)
[17:32:13] <joebobjoe> strcat 0.6
[17:32:15] <strcat> 2.5GiB isn't enough, which is the problem
[17:32:34] <joebobjoe> strcat: Oh, so I was swapping
[17:32:36] *** Joins: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de)
[17:32:45] <strcat> joebobjoe: yeah
[17:32:56] <strcat> rust peaks at 2500MiB but you have other stuff running
[17:33:10] <strcat> memory usage is down in stage1/stage2 of incoming
[17:33:16] <strcat> stage0 still hits that high point
[17:33:19] <joebobjoe> strcat: What's with the mem usage???
[17:33:26] <joebobjoe> strcat Ah, okay
[17:33:30] <strcat> joebobjoe: lots of legacy cruft mostly
[17:33:46] <strcat> the compiler isn't really a high quality codebase yet
[17:33:49] <strcat> too much churn
[17:34:05] <strcat> lots of unhandled errors, correctness bugs and it's slow ;p
[17:34:24] <joebobjoe> Does incoming still compile thrice?
[17:34:32] <strcat> joebobjoe: yes it will always do that
[17:34:35] <cmr> Yes, it has to, to properly bootstrap
[17:34:38] <strcat> gcc does too
[17:34:41] <strcat> it's not unique to rust
[17:34:57] <joebobjoe> strcat: gotcha
[17:35:29] <benh> Why can't it use the last build's stage2 as the next build's stage1?
[17:35:54] <strcat> benh: because it doesn't know how old that is
[17:36:11] <strcat> it has to be old enough to work with cfg(stage0)
[17:36:17] <benh> Could check against the snapshot's timestamp I guess
[17:36:37] <strcat> it likely isn't old enough most of the time
[17:36:56] <strcat> benh: the stage0 compiler is already compiled for you though
[17:37:27] <benh> Why can't it skip the first two builds if I have a relatively recent rustc that I could pretend is stage1?
[17:37:55] <joebobjoe> benh that's a good idea
[17:38:07] <benh> I'm sure it's really a silly idea because I don't understand the build system :(
[17:38:29] <strcat> benh: you don't have to build stage2 at all...
[17:38:35] <strcat> you can just build stage1
[17:38:48] <cmr> because theny ou aren't ensuring the new compiler compiles itself properly
[17:38:52] <cmr> (and converges)
[17:39:16] <strcat> well
[17:39:24] <strcat> when you finish stage1, you have the new compiler
[17:39:28] <strcat> but built with the old compiler
[17:39:31] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Quit: Leaving)
[17:39:50] <strcat> so if there was a perf improvement or a bug fix, you didn't use it to make that compiler
[17:39:51] *** Joins: rumpler (Mibbit@moz-E89B7C5B.range109-154.btcentralplus.com)
[17:40:24] <strcat> compiling stage2 makes you another build of the new compiler but *with* the new compiler
[17:40:43] <strcat> so you check that you can still build it, and it makes one with the new codegen
[17:40:51] <strcat> anyway you can skip stage2.
[17:40:55] <strcat> the makefile lets you
[17:41:40] <benh> someone needs to draw a graph.....
[17:42:35] <strcat> downloaded snapshot compiler (stage0) -> new compiler built with snapshot compiler (stage1) -> new compiler built with stage1 compiler (stage2)
[17:43:16] <strcat> stage1 and stage2 are similar but stage1 was *built with* the old compiler so if there were memory corruption bugs or perf fixes since then, it doesn't have them
[17:44:28] <strcat> you could build stage3 but it won't converge anyway
[17:44:32] <strcat> because of RNG
[17:45:28] <cmr> It would be easier to understand if the build system wasn't so... writen in make./
[17:46:31] *** Quits: Sevki (Sevki@moz-EB20D033.cable.virginmedia.com) (Quit: Linkinus - http://linkinus.com)
[17:47:52] <benh> I can never remember any of the make targets either :)
[17:49:57] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[17:51:37] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Ping timeout)
[17:51:52] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[17:53:39] *** Quits: victorporof_ (victorporo@114C3C1F.E934E1A1.4A6B528C.IP) (Ping timeout)
[17:56:16] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[17:56:57] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[17:57:05] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:57:21] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[17:57:33] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[17:57:42] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[17:57:47] <cmr> well that was... interesting
[17:59:11] *** Joins: ssbr (ssbr@moz-A48A4550.s-ip.magma.ca)
[17:59:29] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[17:59:52] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[18:07:53] *** Quits: zq (p@moz-4A6945B7.de) (Ping timeout)
[18:09:21] *** Quits: igl (igl@moz-26400444.adsl.alicedsl.de) (Ping timeout)
[18:09:40] *** Joins: igl (igl@moz-F81201D5.adsl.alicedsl.de)
[18:12:04] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:12:09] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:17:56] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[18:18:42] *** Joins: zq (p@moz-4A6945B7.de)
[18:19:54] *** Joins: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net)
[18:23:43] *** Joins: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au)
[18:24:32] <cmr> strcat: mind lending me a hand? https://github.com/mozilla/rust/pull/6901 adds LZ4 stuff, but... I can't get it into the build system correctly.
[18:24:41] <cmr> I don't know how to do it, and what I tried is broken :)
[18:29:51] *** Quits: sankha93 (Instantbir@AF37D2F8.927D11A.8B6C1D65.IP) (Ping timeout)
[18:33:51] *** Joins: sankha93 (Instantbir@D46AAA40.F6D95C1.8B6C1D65.IP)
[18:34:16] *** Parts: z0w0 (zack@moz-B5D18119.lns1.woo.bigpond.net.au) ()
[18:34:31] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[18:36:39] *** Joins: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com)
[18:36:50] *** Quits: HollyRain (HollyRain@moz-50A83091.dyn.user.ono.com) (Quit: bye, bye)
[18:37:35] *** Joins: balpert (alpert@moz-B247840C.hsd1.ca.comcast.net)
[18:37:39] <jld> Okay, so... an enum is an ast::def_ty?  So how can I tell if it's an enum rather than a typedef or something else?
[18:37:52] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Client exited)
[18:38:02] <jld> The AST and its many IDs confuse me greatly.
[18:39:41] <doener> cmr: https://gist.github.com/dotdash/5694434
[18:40:33] <cmr> doener: I also need to get tidy to ignore the lz4 source
[18:41:11] <doener> cmr: or this for easier fetching: https://github.com/dotdash/rust/tree/lz4 
[18:41:13] <cmr> doener: super thanks though!
[18:41:54] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[18:43:53] *** Joins: mleise (marco@moz-3468AB5B.pools.arcor-ip.net)
[18:45:29] *** Joins: jviereck (Adium@moz-340574DC.dclient.hispeed.ch)
[18:45:53] <doener> cmr: updated the lz4 branch with lz4 excluded from tidy
[18:46:37] *** Quits: MaikKlein (maik@moz-8EF3B6AF.dip0.t-ipconnect.de) (Ping timeout)
[18:47:48] <cmr> doener: thanks! changes pushed to my branch and the pr
[18:47:57] <doener> you're welcome
[18:50:16] <mleise> how does rust handle parameter passing by value or by ref? depending on several factors one may be better than the other. is it 100% the developers choice as in other languages?
[18:50:25] <cmr> mleise: yes.
[18:50:53] <cmr> mleise: all parameters are by value, but sometimes that value is a pointer (&, @, ~, *, and their mut varities)
[18:51:37] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[18:52:04] <mleise> ok, so does that mean you can even see what is going on on the callsite?
[18:52:08] <strcat> rusti: fn foo(x: &mut int) { *x += 5 } let mut x = 10; foo(&mut x); x
[18:52:13] -rusti- 15
[18:52:33] <strcat> mleise: it hides it for the 'self' value in method calls though
[18:52:43] <strcat> foo.bar() could take foo as &self, &mut self, self, etc.
[18:53:01] <strcat> other parameters are always explicit
[18:53:02] <mleise> it could take self as a value copy?
[18:53:09] <cmr> yes
[18:53:12] <mleise> O.o
[18:53:20] <cmr> which is useful for like char and u8 and stuff where self is smaller than a word
[18:53:28] <strcat> mleise: by-value means move (unless it has no destructor)
[18:53:37] <strcat> you'd still have to do a real copy explicitly
[18:54:07] <Earnestly> "The Rust Programming Language - strcat". I expect to see an Oreilly publication as soon as 1.0.
[18:54:07] <mleise> ok, i didn't realize that there are method calls on base types
[18:54:32] <strcat> mleise: you can add methods to types in other libraries too by implementing your own traits for them
[18:55:05] <mleise> While that is convenient, my indoctrination with encapsulation and Java tells me to call you heretics!
[18:55:32] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[18:55:54] <cmr> mleise: your trait has to be in scope for you to be able to call your trats methods on them. it doesn't break encapsulation.
[18:55:58] <doener> cmr: seems like I didn't get the deps quite right. 
[18:56:18] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:56:46] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:56:48] <cmr> doener: feel free to edit lz4's makefile too. It didn't come with a good one, so I wrote a new one.
[18:56:50] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (NickServ (GHOST command used by strcat1))
[18:56:53] *** strcat1 is now known as strcat
[18:57:09] <cmr> (all it built was the lz4c utility, which is GPLv2 and entirely unneeded)
[18:57:20] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:57:34] <SingingBoyo> speaking of traits and scope, is there any way to get the methods into scope, but not the actual trait name?  crate::module::Trait::* doesn't do it, wondering if it's actually possible.
[18:57:36] <cmr> not sure I did it right :)
[18:57:45] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[18:58:03] <strcat> SingingBoyo: no
[18:58:45] <strcat> the reason you're allowed to add your own traits and implement them for types in other crates is *because* they won't be usable without the trait in scope
[18:58:53] <mleise> and can you write functions that can handle most types generically? with all the different ways to point to something and immutable/mutable it could be difficult, i imagine.
[18:59:07] <strcat> mleise: yes
[18:59:34] *** Quits: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: Leaving)
[18:59:37] <strcat> mleise: if you need ownership (your own copy), you take it by-value
[18:59:41] *** Joins: lkuper_ (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[18:59:43] <strcat> if you don't, you take it by-borrowed-pointer
[18:59:48] <strcat> that works for anything
[18:59:57] *** lkuper_ is now known as lkuper
[19:00:16] <mleise> sounds like a deal :D
[19:00:18] <strcat> you should rarely have ~ or @ parameters, it's just how the caller chooses to allocate (if they don't want it on the stack)
[19:01:27] <mleise> so I could easily wrrite a factorial function that takes base data types or a user defined big-int structure?
[19:01:46] <strcat> mleise: yeah
[19:01:49] <mleise> i.e. can a struct disguise itself as an int well enough?
[19:02:06] <strcat> mleise: yes, int could very well be a struct (it isn't, but it could be :P)
[19:02:22] <cmr> fn fac<T:Mul+Sub> { ... } -> T
[19:03:00] <mleise> are Mul and Sub actual function names or keywords?
[19:03:05] <cmr> traits
[19:03:05] <strcat> mleise: trait names
[19:03:07] <cmr> http://static.rust-lang.org/doc/core/ops.html
[19:03:19] <cmr> T: Foo + Bar are trait bounds
[19:03:28] <strcat> mleise: generic functions basically work like templates in D or C++ but you explicitly bound them by the traits they require
[19:03:37] <strcat> because they're type-checked from the definition, not instantiations
[19:03:58] <strcat> if they type-check from the definition it will compile for any type implementing the traits
[19:05:04] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Client exited)
[19:05:59] <mleise> in D it is more or less the same, just that the built-in traits are a very different set. like 'compiles' or 'struct fields'
[19:06:58] <strcat> mleise: well it's different because you can do 'a = foo.bar(); a.baz()' in a template
[19:07:09] <strcat> and it can't know from the template definition if that will type check
[19:07:56] <mleise> what exactly do you mean by type check?
[19:08:30] *** Quits: gareth0 (gareth0@moz-10A7C8D0.dynamic.dsl.as9105.com) (Quit: Leaving)
[19:08:32] <mleise> i can only think of compiles or doesn't compile
[19:08:46] <cmr> Is valid for every use of the template
[19:08:58] <cmr> (I think)
[19:09:08] <mleise> that would be a bonus
[19:09:20] * jld finds ty::lookup_item_type
[19:09:25] <strcat> mleise: as in if you write a function taking <T: Bar> and it type checks, it will compile correctly for every type T implementing Bar
[19:09:46] <strcat> instead of getting different errors for different type instantiations
[19:10:09] <strcat> more work documentation the concepts it needs up-front, and less effect/trouble to use it
[19:10:12] <strcat> documenting*
[19:10:18] <strcat> effort*
[19:10:20] * strcat sighs
[19:10:52] <mleise> ok, so it is the same as an interface in Java from that point of view
[19:11:10] <strcat> mleise: yeah, they can actually be used dynamically like java interfaces too
[19:11:18] <strcat> but the common usage is with type bounds which is static dispatch
[19:12:05] <strcat> foo<T: Ord + Eq>(a: &T, b: &T) -> bool { ... }, is static (like a template), where T is some type implementing the Ord and Eq traits
[19:12:09] <mleise> And this never turned out to be limiting? Were there never situations where you would have liked to contrain a function by something else?
[19:12:11] <Jesse> type bounds let you specify required interfaces, but also basic language features: that T needs to be copyable, or freezable, or ok to share between threads
[19:12:23] <mleise> *constrain
[19:12:26] <strcat> mleise: well you can define your own traits any time you need them
[19:12:54] <strcat> trait Foo: Ord + Eq { fn foo(&self) -> uint }
[19:13:11] <strcat> so T: Foo means it implements Foo (has that method) and also implements Ord and Eq
[19:13:34] <mleise> it really looks like interfaces :)
[19:13:45] <strcat> mleise: they are very much like interfaces
[19:13:45] <doener> cmr: updated the branch, building now *fingers crossed*
[19:13:58] <strcat> mleise: you can use traits as objects instead of type bounds which is identical to an interface
[19:14:03] <mleise> and I assume all the basic language features and base types have all required traits already
[19:14:07] <strcat> like &Trait, ~Trait or @Trait
[19:14:15] <strcat> mleise: yeah, like Clone, DeepClone, Eq, Ord
[19:15:06] <strcat> if you didn't define the trait or the type, you can't implement the trait for the type so... you'd have to make a new type wrapping the old one if it was missing a trait it should have
[19:15:10] <Jesse> "trait" is a shorter word than "interface". rust likes short keywords ;)
[19:15:35] <mleise> "mut" :)
[19:16:00] <strcat> they used to be called iface
[19:16:02] <Jesse> strcat: you can add a trait in any file, right?
[19:16:08] <strcat> Jesse: yes
[19:16:32] <engla> I think trait is a smart word. It's one aspect of many of an object
[19:16:33] <Jesse> strcat: when would you make a new wrapper type?
[19:16:37] <strcat> mleise: when used as type bounds they're equivalent to type classes in haskell/scala
[19:16:50] <strcat> Jesse: if you didn't define the trait or the type
[19:16:52] <strcat> so..
[19:17:11] <strcat> lets say there's some third party lib you use with a Foo trait, and it doesn't define it for 'int'
[19:17:23] <strcat> you can't define it for int because you defined neither the trait/type
[19:18:03] <strcat> it's just how coherence is preserved. to prevent conflicting implementations
[19:18:04] <Jesse> oh, i see
[19:18:06] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[19:18:31] <Jesse> i wonder if you could make a wrapper trait instead of a wrapper object
[19:18:51] <Jesse> i'm not sure that question even makes sense
[19:18:58] <mleise> no it doesn't :p
[19:18:59] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[19:19:09] <strcat> Jesse: well you could actually
[19:19:12] <strcat> if you need Foo
[19:19:18] *** Joins: barosl (barosl@1E71221E.C81E10FB.7544CABF.IP)
[19:19:18] <strcat> you could instead define a Bar trait
[19:19:35] <strcat> and add 'impl<T: Foo> Bar for T { fn bar(&self) { self.foo() }'
[19:19:48] <strcat> so any type implementing Foo would implement Bar... and then you could implement Bar for int
[19:19:53] <strcat> it would be easier to just wrap the type ;p
[19:20:39] <strcat> and having two identical methods on some types would be silly...
[19:21:26] * strcat thinks that's what you meant
[19:21:46] *** Quits: aruniiird (arun@84E199D6.DCDBCF8E.83D0DF30.IP) (Ping timeout)
[19:22:35] <cmr> doener: nope
[19:22:53] <doener> saw it :-/
[19:26:10] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[19:26:45] <cmr> rusti: fn foo(a: u8, b: u8) -> u8 { a + b } foo(128, 128)
[19:26:48] -rusti- 0
[19:26:51] <cmr> Oh good
[19:28:47] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Ping timeout)
[19:29:03] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[19:29:21] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[19:32:43] <mleise> what is the clang useflag in the gentoo ebuild for? does anyone know?
[19:33:02] <cmr> mleise: build the rt with clang (./configure --enable-clang), I imagine
[19:33:23] <mleise> ok, and what does that feature do?
[19:33:36] <cmr> nothing... it just uses clang instead of gcc
[19:33:58] <cmr> well, not just the rt, llvm too I think
[19:34:05] <mleise> so all it does is use a different compiler for the runtime ok
[19:35:29] *** Quits: tcsc (tcsc@moz-ADC0ED45.hsd1.ct.comcast.net) (Quit: bye!)
[19:35:49] *** IRCMonkey46086 is now known as rhelmer
[19:37:38] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:38:38] *** Quits: thou (thou@moz-1C1CA9F7.fasttrackcomm.net) (Input/output error)
[19:39:44] <cmr> mleise: if you're going to be bnuilding rust anyway, build the incoming branch
[19:40:02] *** Joins: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP)
[19:40:51] <mleise> is that stable enough? :)
[19:40:59] <cmr> it passes tests, at least
[19:42:27] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[19:42:44] <strcat> mleise: it's likely more stable than 0.6 was ;p
[19:44:11] <mleise> hehe
[19:44:58] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Computer has gone to sleep.)
[19:45:06] <mleise> ok this request is a bit brash, but can anyone tell me what this D code would look like in Rust? http://dpaste.1azy.net/08dcbef3
[19:45:25] *** Joins: Blub\w (wry@moz-5567490F.wireless.dyn.drei.com)
[19:46:10] <strcat> mleise: what does iota do? what a lazily created range?
[19:46:19] <mleise> yeah
[19:46:39] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[19:46:44] <mleise> a functional foreach ;)
[19:46:59] *** Quits: joebobjoe (joebobjoe@55F2E07A.7F841963.2213276E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[19:47:15] <strcat> mleise: well there's std::iterator::Counter for an object or just
[19:47:31] <strcat> rusti: for uint::range(0, 3) |x| { println(x.to_str()) }
[19:47:33] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HYeM
[19:47:41] <strcat> rusti: for std::uint::range(0, 3) |x| { println(x.to_str()) }
[19:47:44] -rusti- 0
[19:47:44] -rusti- 1
[19:47:44] -rusti- 2
[19:47:44] -rusti- ()
[19:47:55] <cmr> silly prelude
[19:48:11] <strcat> mleise: there isn't really a convenient range object yet, you'd have to Counter(start, step).take_while(|x| *x < end)
[19:48:51] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Ping timeout)
[19:48:58] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[19:49:08] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[19:49:29] <strcat> rusti: use std::iterator::*; let mut it = Counter::new(0, 2).take_while(|x| *x < 10); it.next()
[19:49:31] -rusti- Some(0)
[19:49:52] <strcat> rusti: use std::iterator::*; let mut it = Counter::new(0, 2).take_while(|x| *x < 10); for it.advance |x| { println(x.to_str()) }
[19:49:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ERIC
[19:50:01] <cmr> doener: All it needs is an -llz4 and -> $build_dir/rt/x86_64-unknown-linux-gnu/stage1/lz4
[19:50:12] <cmr> doener: but I don;t know where/how to add those :(
[19:50:29] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[19:50:43] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[19:51:48] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[19:53:07] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[19:53:55] *** Quits: jrfeenst (jrfeenst@moz-3265BD65.cpe.norwoodlight.com) (Ping timeout)
[19:55:14] *** Quits: heftig (heftig@moz-D18DEBBD.dip0.t-ipconnect.de) (Ping timeout)
[19:55:19] <mleise> does the Rust ebuild build a complete LLVM? I already have that installed.
[19:55:28] <cmr> mleise: yes. rust has its own fork.
[19:55:50] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:55:51] <mleise> oh ok. that'll take a while then :p
[19:56:07] <cmr> plus needs an asserts build to not silently generate bad code
[19:56:47] <mleise> So...         let L = Counter(0.0, 1.0).take_while(|x| *x < 10000000.0);    is probably not correct, right?
[19:56:55] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:56:55] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[19:57:13] <strcat1> mleise: that'd probably work.
[19:57:23] *** Joins: heftig (heftig@moz-8E0B0A99.dip0.t-ipconnect.de)
[19:57:30] *** strcat1 is now known as strcat
[19:58:24] <mleise> good and where do I find the "map" functionality? do I import something for that?
[19:58:55] <strcat> mleise: well with an Iterator type it's a method... but due to a bug in resolving names it's called transform instead of map
[19:58:58] *** Joins: fread2282 (Mibbit@moz-CB181B42.dia.static.qwest.net)
[19:59:05] *** Joins: jrfeenst (jrfeenst@1B4E3DBD.8A7F2529.1CD399FA.IP)
[19:59:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[19:59:44] <fread2282> Are there any incoming binaries?
[19:59:52] *** Joins: hjr3 (hradtke@54B05067.8A23C5CC.BCAEBB33.IP)
[19:59:57] <fread2282> I'm trying to get rust on Travis CI!
[20:00:38] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[20:01:03] <lkuper> fread2282: I don't think there are.  Is there an advantage to that over the existing buildbot setup?
[20:01:13] <strcat> well I have an Arch repo with a daily build of incoming... other than that probably no
[20:01:23] <strcat> lkuper: it would mean random rust libs could have CI
[20:01:39] <lkuper> mleise: what do you want to map over?  there are things like vec::map and friends.
[20:01:47] <lkuper> strcat: oh, that's true.
[20:02:00] <strcat> lkuper: the vec implementations of those will probably go away though
[20:02:24] <strcat> they are redundant with implementations for any Iterator or the simple internal iterator ones
[20:02:31] <strcat> we really need default methods working...
[20:02:52] <lkuper> I know :(
[20:04:17] <mleise> lkuper: I'm looking for an efficient port of this code: http://dpaste.1azy.net/08dcbef3
[20:04:35] <cmr> What does that code *do*, exactly?
[20:05:04] <mleise> I'd like to see how that currently looks in Rust and how efficiently the compiler can handle the functional programming
[20:05:37] <mleise> cmr: nothing special, it just applies some simple arithmetics to a range of numbers and sums the result up
[20:05:43] <strcat> rusti: let mut it = Counter::new(0.0, 1.0).take_while(|x| *x < 10000000.0).transform(|x| x / 2).transform(|x| x + 2);
[20:05:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BFNK
[20:06:02] <lkuper> mleise: see also uint::range: http://static.rust-lang.org/doc/core/uint.html#function-range
[20:06:48] <mleise> lkuper: thx, but the original Lua code was using doubles so I want to stick to that
[20:06:51] <strcat> rusti: use std::iterator::*; let mut it = Counter::new(0.0, 1.0).take_while(|x| *x < 10000000.0).transform(|x| x / 2).transform(|x| x + 2).fold(0, |a, b| a + b)
[20:06:52] -rusti- foo.rs:11:4: 11:5 error: expected `;` but found `}`
[20:06:52] -rusti- foo.rs:11     }));
[20:06:52] -rusti-               ^
[20:06:52] -rusti- application terminated with error code 101
[20:06:57] <strcat> heh
[20:07:00] <strcat> where did I make a typo ;p
[20:07:03] *** Joins: samx (sami@moz-62B7FC03.dyn.optonline.net)
[20:07:20] <strcat> rusti: use std::iterator::*; let mut it = Counter::new(0.0, 1.0).take_while(|x| *x < 10000000.0).transform(|x| x / 2).transform(|x| x + 2).fold(0, |a, b| a + b);
[20:07:22] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WWZg
[20:07:32] <lkuper> mleise: oh, all the Rust numeric types should have `range`
[20:07:38] <strcat> rusti: use std::iterator::*; let mut it = Counter::new(0.0, 1.0).take_while(|x| *x < 10000000.0).transform(|x| x / 2.0).transform(|x| x + 2).fold(0.0, |a, b| a + b);
[20:07:40] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/gLLJ
[20:08:02] <strcat> rusti: use std::iterator::*; let mut it = Counter::new(0.0, 1.0).take_while(|x| *x < 10000000.0).transform(|x| x / 2.0).transform(|x| x + 2.0).fold(0.0, |a, b| a + b).to_vec()
[20:08:02] -rusti- foo.rs:11:4: 11:5 error: expected `;` but found `}`
[20:08:02] -rusti- foo.rs:11     }));
[20:08:02] -rusti-               ^
[20:08:02] -rusti- application terminated with error code 101
[20:08:12] <strcat> rusti: use std::iterator::*; Counter::new(0.0, 1.0).take_while(|x| *x < 10000000.0).transform(|x| x / 2.0).transform(|x| x + 2.0).fold(0.0, |a, b| a + b).to_vec()
[20:08:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/YYEG
[20:08:24] <strcat> oh whoops
[20:08:25] <mleise> to_vec() ?
[20:08:26] * strcat is silly
[20:08:28] <doomlord> is "take_while" different to filter
[20:08:29] <strcat> rusti: use std::iterator::*; Counter::new(0.0, 1.0).take_while(|x| *x < 10000000.0).transform(|x| x / 2.0).transform(|x| x + 2.0).fold(0.0, |a, b| a + b)
[20:08:32] -rusti- 25000017500000
[20:08:36] <mleise> yay!
[20:08:38] <strcat> mleise: brain not working at 100% ;p
[20:09:05] <cmr> doener: rt/x86_64-unknown-linux-gnu/stage0/lz4/liblz4.a is in the link line, right after libuv.a, yet the LZ4 symbols are not in 'nm librustrt.so'
[20:09:11] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Quit: Leaving)
[20:09:16] <lkuper> strcat and rusti should really privmsg. :D
[20:09:58] <doener> cmr: because it only exports dynamic symbols, so they need to be in the "def" file, and the linker doesn't include directly used symbols from the archive eitehr
[20:10:19] <doener> cmr: I'm just including directly adding it to rt now
[20:10:26] <doener> s/including//
[20:11:16] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[20:11:34] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Ping timeout)
[20:11:43] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[20:11:55] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[20:12:44] *** Quits: fread2282 (Mibbit@moz-CB181B42.dia.static.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:13:06] *** Quits: ssbr (ssbr@moz-A48A4550.s-ip.magma.ca) (Ping timeout)
[20:14:39] *** Quits: samx (sami@moz-62B7FC03.dyn.optonline.net) (Quit: This computer has gone to sleep)
[20:14:59] *** Joins: jeff (jeff@moz-7F2975F1.nycmny.east.verizon.net)
[20:15:05] <strcat> mleise: http://ix.io/5Ww that's the LLVM IR spit out after optimization
[20:15:25] <strcat> so it manages to get it into one loop
[20:15:58] <strcat> for http://ix.io/5Wx
[20:16:14] *** Joins: fdr (user@B280A391.27376607.189F3E15.IP)
[20:17:39] <mleise> cool, looks as good as LuaJIT and D using LLVM :)
[20:17:50] <cmr> nice :)
[20:18:01] <mleise> GCC is starting to fall behind
[20:18:03] <cmr> might be nice to add to the benchmarks?
[20:18:31] <mleise> maybe add a proper iota range first ;)
[20:20:37] <doener> cmr: branch updated
[20:21:24] <doener> cmr: nvm, still broken *sigh*
[20:22:09] <SiegeLord> Except it shouldn't be called "iota"
[20:22:53] <SingingBoyo> is it just me or does make build then make install not install libcore with the incoming from last night?
[20:23:00] <strcat> Range::new(start, stop, step) I guess. or we could just have count() and range() as free functions
[20:23:06] <cmr> SingingBoyo: libcore was renamed to libstd
[20:23:10] <cmr> (and libstd to libextra)
[20:23:21] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[20:23:21] *** ChanServ sets mode: +o brson
[20:23:39] <doener> cmr: ok, that was just stupid, I dropped the lz4 directory creation from configure... Looking at the objdump output, it might actually work now
[20:24:07] <SingingBoyo> cmr: ah thanks.  Well that's gonna mean some changing of extern mod/use.
[20:24:13] <cmr> SingingBoyo: yup
[20:25:23] <mleise> SiegeLord: yeah iota is from boost I think
[20:25:48] *** Quits: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net) (Quit: \n)
[20:25:52] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[20:26:31] *** Joins: sfackler (sfackler@moz-316FE70F.compute-1.amazonaws.com)
[20:29:32] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[20:29:56] *** Joins: lerc (quassel@moz-598ED764.telstraclear.net)
[20:30:35] <SingingBoyo> did the prelude get changed too?  having to go through and add use std::{str, vec, ...} to everything.
[20:30:42] <cmr> SingingBoyo: yes
[20:31:21] <mleise> finally it compiled
[20:31:50] <Luqman> SingingBoyo: not the prelude per se. Just that the core modules are nolonger re-exported
[20:32:03] <cmr> Luqman: ...from the prelude
[20:32:20] <Luqman> cmr: true
[20:33:18] <strcat> SingingBoyo: use std::*; will essentially get you what we had before
[20:33:36] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[20:34:04] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Client exited)
[20:34:48] *** Quits: sankha93 (Instantbir@D46AAA40.F6D95C1.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[20:37:30] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[20:37:45] <doener> cmr: yay, that worked
[20:38:02] <cmr> doener: you're awesome, thank you :)
[20:38:37] *** Joins: samx (sami@moz-62B7FC03.dyn.optonline.net)
[20:41:06] <SingingBoyo> so many changes... how does one match on borrowed pointers to enums now?  used to do &EnumVal(copy blah) and it worked fine but that doesn't work anymore.
[20:42:17] <doener> rusti: enum Foo { A, B }; let x = A; match &x { &A => "A", &B => "B" }
[20:42:20] -rusti- "A"
[20:42:24] <doener> seems to work fine
[20:42:36] <doener> what kind of error do you get?
[20:44:49] <SingingBoyo> rusti: enum Foo{ A(int), B(int) }; let x = A(2); match &x { &A(blah1) => blah1, &B(blah2) => blah2 }
[20:44:51] -rusti- 2
[20:44:57] <SingingBoyo> odd
[20:45:07] <heftig> rusti: enum Foo { A(~str), B(int) }; let x = A(~"foo"); match &x { &A(copy y) => y, &B(y) => y  }
[20:45:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jbiE
[20:45:12] <heftig> rusti: enum Foo { A(~str), B(int) }; let x = A(~"foo"); match &x { &A(y) => y, &B(y) => y  }
[20:45:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fAJJ
[20:45:22] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[20:45:36] <heftig> rusti: enum Foo { A(~str), B(int) }; let x = A(~"foo"); match &x { &A(y) => y, &B(y) => y.to_str()  }
[20:45:38] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RaDK
[20:45:52] <heftig> rusti: enum Foo { A(~str), B(int) }; let x = A(~"foo"); match &x { &A(copy y) => y, &B(y) => y.to_str()  }
[20:45:54] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/GXeQ
[20:45:54] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[20:46:09] <heftig> rusti: enum Foo { A(~str), B(int) }; let x = A(~"foo"); match &x { &A(ref y) => y.clone(), &B(y) => y.to_str()  }
[20:46:11] -rusti- ~"foo"
[20:46:13] <heftig> there
[20:46:32] <SingingBoyo> ah.   is ref new?  haven't seen it before
[20:46:37] <heftig> no, it's not
[20:46:46] <heftig> it gets you a borrowed pointer
[20:47:32] <SingingBoyo> hmm well guess I just haven't had a reason to use it.  alright thanks, looks like that'll do what I want.
[20:51:47] *** Quits: cdidd (cdidd@moz-9F8C21.broadband.corbina.ru) (Input/output error)
[20:52:01] *** Joins: ssbr (ssbr@moz-B9B9415A.s-ip.magma.ca)
[20:52:04] <rumpler> how could i copy a borrowed vector to create an owned vector?
[20:52:11] <strcat> rumpler: .to_owned()
[20:52:20] <rumpler> thanks
[20:53:45] *** Joins: cdidd (cdidd@moz-8F89EF1D.broadband.corbina.ru)
[20:56:35] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:56:50] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[20:57:29] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:58:19] *** Quits: ssbr (ssbr@moz-B9B9415A.s-ip.magma.ca) (Client exited)
[21:00:02] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[21:04:33] *** Joins: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net)
[21:05:40] *** Joins: orshem (Mibbit@19491716.F0FDCE77.E3D28531.IP)
[21:06:04] *** Joins: SimonSapin (simon@AC677AA0.72C1E24.8EDFB172.IP)
[21:06:19] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:11:46] *** Quits: pyrac (pyrac@moz-984F61EC.w83-200.abo.wanadoo.fr) (Quit: pyrac)
[21:12:55] *** Quits: jeff (jeff@moz-7F2975F1.nycmny.east.verizon.net) (Quit: jeff)
[21:15:17] *** Quits: Palmik (palmik@moz-5CA3F354.pks.muni.cz) (Ping timeout)
[21:16:35] *** Quits: hjr3 (hradtke@54B05067.8A23C5CC.BCAEBB33.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[21:16:56] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Ping timeout)
[21:17:18] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[21:18:32] *** Quits: jviereck (Adium@moz-340574DC.dclient.hispeed.ch) (Quit: Leaving.)
[21:18:34] *** Joins: Palmik (palmik@moz-F8AEBE04.vpn.muni.cz)
[21:21:39] <cmr> brson: r? https://github.com/mozilla/rust/pull/6901
[21:22:41] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Ping timeout)
[21:23:54] *** Joins: pudgetta (Mibbit@F6FB5B36.5650C2AC.7998D41D.IP)
[21:24:01] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[21:24:40] *** Quits: pudgetta (Mibbit@F6FB5B36.5650C2AC.7998D41D.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:26:52] *** Joins: hjr3 (hradtke@54B05067.8A23C5CC.BCAEBB33.IP)
[21:26:58] <steven_is_false> I'm having this strange problem where I'm not receiving any messages from one of my threads. It's still active, and doing stuff but sending messages just doesn't work.
[21:29:50] *** Quits: tikue (tkuehn@moz-CF8BEBEF.dia.static.qwest.net) (Quit: tikue)
[21:34:03] <doener> ah, finally :-) https://github.com/mozilla/rust/pull/6903
[21:34:43] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[21:35:04] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:36:29] *** Quits: orshem (Mibbit@19491716.F0FDCE77.E3D28531.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:36:46] *** Quits: Palmik (palmik@moz-F8AEBE04.vpn.muni.cz) (Quit: Lost terminal)
[21:36:55] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[21:37:05] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[21:37:48] *** Quits: samx (sami@moz-62B7FC03.dyn.optonline.net) (Quit: This computer has gone to sleep)
[21:43:59] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[21:45:18] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[21:45:19] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[21:45:58] *** Joins: MaikKlein (maik@moz-972D34E0.dip0.t-ipconnect.de)
[21:46:07] <cmr> brson: hold off from an r+ atm, fixing the tests
[21:46:13] *** Joins: orshem (orshem@19491716.F0FDCE77.E3D28531.IP)
[21:47:18] <brson> cmr: thanks for doing all those malloc benchmarks!
[21:47:36] <cmr> brson: they're still not comprehensive, unfortunately, but I think they provide enough of the picture to be compelling :)
[21:48:25] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[21:50:12] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[21:53:02] *** cscottnet_away is now known as cscottnet
[21:53:20] <MaikKlein> is there a limit of how many tasks I can spawn?
[21:53:38] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[21:55:08] <MaikKlein> lets say I want to create a game where I can spawn monsters. Each monster has it's own task. If I spawn now 1000 tasks is it possible that some computers are not able to have 1000 tasks available? Or does Rust abstract this away?
[21:56:07] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:56:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:56:23] *** strcat1 is now known as strcat
[21:56:55] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[21:57:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:57:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/zHOKRw
[21:57:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:57:32] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:57:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/TSy08A
[21:57:32] <ghrust> 13rust/06auto 14c582e3e 15Patrick Walton: librustc: Don't require `pub extern` to make extern functions visible
[21:57:32] <ghrust> 13rust/06auto 1463b11e4 15bors: auto merge of #6866 : pcwalton/rust/pub-extern, r=brson...
[21:57:33] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:57:38] <mark_edward> how do you loop over a numeric range in rust/incoming?
[21:57:44] <mark_edward> int::range seems to have disappeared
[21:57:53] <strcat> mark_edward: std::int::range
[21:57:55] <strcat> still there
[21:58:20] <mark_edward> oh i guess you are reexporting less in prelude.rs now
[21:58:39] <mleise> q66: are you there?
[21:59:07] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[21:59:32] <q66> no
[21:59:32] <q66> :P
[22:00:22] <mark_edward> strcat: can you answer MaikKlein's question?
[22:00:34] <mark_edward> "is there a limit of how many tasks I can spawn?"
[22:00:47] <mark_edward> "lets say I want to create a game where I can spawn monsters. Each monster has it's own task. If I spawn now 1000 tasks is it possible that some computers are not able to have 1000 tasks available? Or does Rust abstract this away?"
[22:01:38] <mark_edward> MaikKlein: I'm certainly no rust expert but i'd say yes.
[22:01:48] <mleise> q66: had to necromance: http://forum.dlang.org/thread/ietsl5$30d4$1@digitalmars.com?page=6#post-20130602080524.66a45d9e:40marco-leise
[22:01:58] <mark_edward> tasks are scheduled onto hardware threads in an M:N scheduling thingy
[22:02:23] <cmr> The only limit I can conceive is the thread id number, and memory size.
[22:02:29] <cmr> task id, that is
[22:02:38] <mleise> q66: it turned out that Andrei's iota implementation was overcautious compared to the quick&dirty Lua function
[22:03:10] <MaikKlein> okay thanks, thats's what I was thinking too
[22:03:25] <mleise> I am now trying to do the same in Rust. The LLVM code looks good already.
[22:04:35] <mark_edward> whats the difference between use and extern mod
[22:04:44] <mark_edward> and why can't i say std::int::range
[22:04:55] <mark_edward> it says unknown module `std`
[22:05:09] <strcat> mark_edward: because you're not using the latest version from incoming
[22:05:10] <mleise> core::int?
[22:05:28] <mark_edward> yes i am
[22:05:30] <strcat> libcore was renamed to libstd and libstd to libextra in incoming
[22:05:32] <mark_edward> switched today
[22:05:54] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:05:57] <strcat> to incoming or master?
[22:06:03] <strcat> 'extern' is to link against a crate
[22:06:06] *** Quits: doomlord (doomlod@moz-3CF8202D.range81-159.btcentralplus.com) (Ping timeout)
[22:06:12] <strcat> 'use' is to import a name into the current scope
[22:06:57] <mark_edward> incoming
[22:07:02] <mark_edward> and i get this:
[22:07:05] <mark_edward> preprocess.rs:20:8: 20:23 error: unresolved name
[22:07:05] <mark_edward> preprocess.rs:20     for std::int::range(1,16) |n| {
[22:07:25] <strcat> rusti: for std::int::range(1, 3) |n| { println(n.to_str()) }
[22:07:28] -rusti- 1
[22:07:28] -rusti- 2
[22:07:28] -rusti- ()
[22:07:38] *** Joins: petantik (oz@moz-20EC2160.net)
[22:07:49] <mark_edward> do i need to `extern mod std`;
[22:08:03] <strcat> no, libstd (what used to be libcore) is linked against by default
[22:08:05] *** Joins: nooy (user@moz-2458675D.a146.priv.bahnhof.se)
[22:08:08] <MaikKlein> i think std is default
[22:08:16] <MaikKlein> only extra has to be linked
[22:08:21] <q66> <mleise> q66: it turned out that Andrei's iota implementation was overcautious compared to the quick&dirty Lua function
[22:08:22] <q66> actually nah
[22:08:25] <mark_edward> i cant quite figure out the problem
[22:08:26] <q66> it's due to dmd being shitty
[22:08:29] <q66> and not being able to inline
[22:08:30] <q66> :}
[22:08:37] <SingingBoyo> mark_edward: what does rustc --version print?  You could have an old version somewhere that you're still using
[22:08:43] <q66> if it actually could optimize properly it'd be fast enough
[22:08:46] <mark_edward> `rustc 0.6 (24e85ac 2013-06-01 15:46:40 -0700)`
[22:09:04] <mleise> q66: when benchmarking you have to compare with the same compiler backend. dmd is fast but badly optimizing.
[22:09:14] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[22:09:15] <q66> wut
[22:09:32] <SingingBoyo> hmm well that should be fine
[22:09:37] <mleise> i'd never use it for a release built, but for debugging and fast iteration it is great
[22:09:38] <strcat> mark_edward: that's not incoming, at least not a recent build
[22:09:48] <mark_edward> really?
[22:09:57] <q66> luajit is even better, i just run the thing! :P
[22:10:00] <strcat> mark_edward: oops nvm misread the month.
[22:10:02] <strcat> ;p
[22:10:04] <cmr> strcat: it's yesterday :\
[22:10:06] <cmr> heh
[22:10:07] <MaikKlein> rusti: for int::range(1, 3) |n| { println(n.to_str()) }
[22:10:09] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/dXfb
[22:10:09] <mleise> q66: Also you see I had to reimplement iota. It _was_ a lot slower
[22:10:18] <strcat> mleise: it's std::int::range
[22:10:25] <strcat> err
[22:10:27] <mleise> type `core::iterator::MapIterator/&<float,float,core::iterator::MapIterator/&<float,float,core::iterator::TakeWhileIterator/&<float,core::iterator::Counter<float>>>>` does not implement any method in scope named `fold`
[22:10:30] <q66> mleise, yet, dmd is still slower than luajit
[22:10:30] <strcat> MaikKlein: *
[22:10:55] <SingingBoyo> rusti: use std::*; for int::range(1, 3) |n| { println(n.to_str()) }
[22:10:56] <mleise> q66: yes, but I give a f... about dmd when it comes to runtime performance
[22:10:57] -rusti- 1
[22:10:58] -rusti- 2
[22:10:58] -rusti- ()
[22:11:08] <q66> mleise, also >2.0.0 b7
[22:11:08] <q66> wat
[22:11:10] <mleise> I used the gentoo -9999 built
[22:11:15] <strcat> mleise: I don't think it existed in 0.6
[22:11:22] <mleise> is there no .fold in there?=
[22:11:27] <strcat> there is now
[22:11:28] <mark_edward> strcat: can you say `use std::vec`
[22:11:33] <strcat> mark_edward: yes
[22:11:37] <q66> mleise, you do realize that release of luajit is old as fuck, right
[22:11:48] <mleise> q66: that was the latest in gentoo
[22:11:53] <mark_edward> and then youd have to prefix things like `vec::each2` right
[22:12:04] <q66> 2.0.1 is current
[22:12:05] <cmr> mark_edward: each2 was renamed
[22:12:19] <cmr> or it wasn't
[22:12:22] <cmr> which one did I rename...
[22:12:28] <SingingBoyo> mark_edward: but yes, you'd prefix things with 'vec::'
[22:12:45] <cmr> Ah, mod2
[22:12:47] <mark_edward> ok cool
[22:13:04] <mleise> q66: maybe i should update my package sources
[22:13:05] <MaikKlein> so it's the same as in c++ where mod is #include and "use" are namespaces?
[22:13:09] <q66> mleise, for reference, the beta 7 is 2 years old
[22:13:13] <q66> it's quite a lot faster now
[22:13:24] <cmr> MaikKlein: extern mod isn't #include, -lfoo to the compiler is extern mod
[22:13:44] <q66> update to 2.0.1 and re-run your bench
[22:13:45] <mleise> q66: It cannot be faster than that. look it is only a tiny bit slower than GDC
[22:13:46] <MaikKlein> cmr: oh didn't know that
[22:13:48] <strcat> 'use' is equivalent to 'using'
[22:13:52] <q66> mleise, sure it can
[22:13:53] <mleise> it is obviously the limit
[22:13:55] <strcat> there's no equivalent to headers
[22:14:09] <q66> mleise, as luajit is faster than clang in several things i tried it's barely the limit
[22:14:12] *** cscottnet is now known as cscottnet_away
[22:14:16] <strcat> if you link against something the symbols are available and the crate metadata has the types
[22:14:29] <MaikKlein> okay
[22:14:40] <strcat> q66: with which code?
[22:14:48] <q66> strcat, quicksort :P
[22:14:54] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[22:15:05] <strcat> q66: a specific implementation of it at least
[22:15:13] <q66> sorting a table of 10 million random integers with luajit takes less than equivalent implementation and sorting of array in clang
[22:15:26] <strcat> q66: well what's the code you were comparing to?
[22:15:33] <q66> i wrote both by hand
[22:15:46] <q66> i don't have the C code anymore unfortunately
[22:15:51] <q66> I regularly clean up my tests/ dir
[22:15:55] <strcat> it's not very meaningful without the code
[22:16:03] <q66> i have the lua code
[22:16:10] <q66> because i used it in my game engine
[22:16:11] <q66> but that's it
[22:16:47] <q66> strcat, it's not actually just quicksort, it's introsort, but the C impl was too
[22:17:00] <strcat> yeah but it's still not a meaningful statement without the code
[22:17:13] <mleise> q66: I ported your sorting algorithm to D as well
[22:17:13] <q66> strcat, http://codepad.org/rAXiX9E6
[22:17:20] <strcat> you're say a specific implementation of X is faster in a language than a specific implementation in another
[22:17:23] <strcat> saying*
[22:17:25] <mleise> and it runs twice as fast with LLVM
[22:18:30] <q66> i don't have any compiler of d installed so i can't try but i seriously doubt it
[22:18:55] <mleise> :p I didn't use doubles, but ints. that's all I can be blamed for
[22:19:03] <q66> I used ints too
[22:19:07] <mleise> in Lua?
[22:19:11] <q66> in C
[22:19:26] <q66> in lua they're not really doubles, luajit optimizes them down to ints
[22:19:41] <mleise> yeah I thought so, like JS does as well
[22:19:57] <mleise> that's the benefit of dynamic types
[22:20:06] <q66> there are no types in lua, nor in JS
[22:20:13] <q66> they're simply tagged values
[22:20:28] <q66> types are static
[22:20:28] <strcat> there are still types, just not typed variables
[22:20:38] <mleise> well, they have a notion of boolean, number, string, etc...
[22:20:40] <strcat> types don't have to be static
[22:20:44] <q66> yeah, those are type tags mleise
[22:20:58] <q66> there is one actual static type
[22:21:00] <q66> a value :P
[22:21:30] *** Joins: thou (thou@moz-1C1CA9F7.fasttrackcomm.net)
[22:21:45] <q66> mleise, there is barely any benefit though
[22:22:16] <q66> the primary reason to do this is so that it doesn't have to check types :P
[22:22:21] <mleise> except for unifying integers I rarely see a good point in lack of static typing
[22:22:21] <q66> thus it can start up faster
[22:22:29] <strcat> they still have a semantic purpose
[22:22:36] <q66> mleise, with variant types you can do the same thing
[22:22:56] <mark_edward> in the new rust incoming, does main have to be in the crate file
[22:22:58] <mleise> Right, and for JS I used an IDE that tried to add some type safety :p
[22:23:00] <q66> type number = int | double
[22:23:09] <mark_edward> P.S. i really like crate files. way better than makefiles
[22:23:43] <q66> Rust has variant types, via enum
[22:23:53] <cmr> mark_edward: no.
[22:23:59] <cmr> mark_edward: actually I'm not sure.
[22:24:11] <cmr> mark_edward: but the entry point does need to be marked somewhere (there's an attribute for it)
[22:24:22] <mark_edward> oh ok
[22:25:00] <q66> mleise, btw, with luajit i can also create explicit integers of any size as well as C structs
[22:25:17] <q66> local foo = ffi.new("uint64_t", initval)
[22:25:48] <q66> ffi.cdef [[ typedef struct vec3 { float x, y, z; } vec3; ]]
[22:25:55] <q66> local x = ffi.new("vec3", { 5, 10, 15 })
[22:26:51] <mleise> q66: yeah Lua is pretty nice as an embedded language. there is even an editor mostly written in Lua with a small C shell
[22:27:01] <cmr> textadept?
[22:27:04] <mark_edward> where did str::to_lower go? :-(
[22:27:06] <q66> I implement efficient vectors this way in my engine https://github.com/quaker66/OF-Engine/blob/master/data/library/core/lua/math.lua#L296
[22:27:09] <mleise> cmr: right
[22:27:10] <q66> way faster than if I used tables
[22:27:11] <cmr> rusti: "FOO".to_lower()
[22:27:13] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IgYB
[22:27:14] <cmr> u
[22:27:17] <MaikKlein> are there already some qt bindings?
[22:27:20] <strcat> it never worked properly for str
[22:27:23] <cmr> MaikKlein: No
[22:27:23] <strcat> so it's not on str anymore
[22:27:39] <q66> the cdef https://github.com/quaker66/OF-Engine/blob/master/data/library/core/lua/math.lua#L272
[22:27:46] <strcat> there's an ascii module if you *really* want that
[22:27:53] <cmr> MaikKlein: however it'd be very feasible to write bindings using SMOKE
[22:27:53] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[22:27:56] <mleise> q66: Just in case, my port of your sort algorithm: http://dpaste.1azy.net/bd3809a7
[22:28:12] <q66> I can't run it
[22:28:39] <mleise> I know. Also it was a mess with all those off-by-1 errors I had from porting Lua :p
[22:28:51] <MaikKlein> cmr: what is smoke?
[22:28:54] <q66> mleise, sure
[22:28:58] *** Quits: wycats_ (uid79@moz-C944F5EC.irccloud.com) (Ping timeout)
[22:28:59] <mleise> especially array indexes and for loops
[22:29:03] <q66> the indexes compute differently
[22:29:07] <cmr> MaikKlein: http://techbase.kde.org/Development/Languages/Smoke
[22:29:08] <q66> like, for th heap
[22:29:09] <q66> *the
[22:29:17] <cmr> MaikKlein: You can see https://github.com/reusee/go-qt for sample usage
[22:29:32] *** Quits: wilfred (uid159@moz-C944F5EC.irccloud.com) (Ping timeout)
[22:29:40] <q66> mleise, because you know, heap is specified as { root, child1, child2, .... }
[22:29:44] <q66> heap order
[22:29:50] <q66> so you need to compute the child indexes :P
[22:29:58] <strcat> cmr: except Go only has gc and not destructors so it's not really the same way you'd do it in rust
[22:30:01] <q66> different with 1-indexing and 0-indexing
[22:30:07] <strcat> I don't really think SMOKE is going to be usable.
[22:30:10] <cmr> No?
[22:30:11] *** Joins: wilfred (uid159@moz-C944F5EC.irccloud.com)
[22:30:13] <strcat> unless you use a million @mut
[22:30:49] <q66> mleise, oh I guess I can see why it was so much faster with llvm in your case :P
[22:30:56] <mleise> why? :)
[22:30:56] <q66> because you have that old beta 7 release
[22:31:07] <mleise> oh... maybe that's true
[22:31:19] <q66> there have been 2 years of optimizations since
[22:31:21] <mleise> I should check again
[22:31:42] <mleise> yep, there we go, 2.0.1 made it into portage
[22:31:45] <q66> mleise, like, luajit 2.x is sometimes about 20x faster than luajit 1.x
[22:32:18] <mleise> we are talking about a minor revision or a minor revision here ;)
[22:32:23] <mleise> *of
[22:32:40] <mleise> hmm, with lua52compat or not?
[22:32:46] <q66> doesn't matter
[22:32:51] <q66> i use lua 5.2 compat because it's nifty
[22:32:59] <q66> like, overloadable __len for tables
[22:33:03] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[22:33:29] <cmr> What is the variable to not rebuild anything for test-only changes?
[22:33:34] <cmr> *everything
[22:33:53] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[22:33:56] <strcat> cmr: I don't think there is one
[22:34:06] <cmr> Oh :(
[22:34:08] <strcat> cmr: just fudge the mtime on the file and make -B the test target
[22:34:14] <kimundi> rusti: "FOO".to_ascii().to_lower().to_str_ascii()
[22:34:14] <strcat> or only build the test harness manually
[22:34:16] -rusti- ~"foo"
[22:34:22] <kimundi> cmr: ^
[22:34:26] <strcat> kimundi: but doesn't that copy?
[22:34:30] <strcat> isn't that 3 copies? :|
[22:34:32] <steven_is_false> Hi! Does Rust's build system benefit from the -j4 option (I know many configurations can prevent it from doing anything?)
[22:34:33] <q66> mleise, the thing is, these are all in-place, there are no extra allocs on the way, just comparing, swapping and stuff.. there is no reason for there to be much difference on a good compiler of any language - the results should be pretty much identical
[22:34:40] <kimundi> strcat: Yes
[22:34:51] <q66> and they are when I benched luajit vs C
[22:35:03] <kimundi> strcat: But the no-copies one exist already, they just crash because moving self :P
[22:35:05] <q66> the difference was 5% at max and that barely matters at all
[22:35:28] <mleise> q66: ok i tested with luajit-2.0.1
[22:35:40] <q66> mleise, don't forget to test the iota thing
[22:35:50] <kimundi> rusti: "FOO".to_ascii()
[22:35:52] -rusti- &[{chr: 70}, {chr: 79}, {chr: 79}]
[22:36:09] <mleise> 3.66 to 3.94 seconds for LuaJIT and about 2.1 seconds for LDC
[22:36:16] <kimundi> strcat: Actuall just on copy because to_lower and one because to_str
[22:36:30] <cmr> steven_is_false: no
[22:36:35] <strcat> mleise: which version of LLVM?
[22:36:44] <cmr> steven_is_false: LLVM benefits, and the initial build of the rt and libuv, but other than that... no, not at all.
[22:36:49] <mleise> strcat: 3.2
[22:36:54] <cmr> steven_is_false: it *hurts* test performance because the test harness is already parallel
[22:37:06] <SingingBoyo> How does one go about concatenating &'static strings?  just using '+' doesn't work
[22:37:07] <strcat> cmr: it actually does build some things like librustdoc in parallel ;p
[22:37:12] <strcat> pretty small gain though
[22:37:38] <q66> mleise, just curious, when you run the interpreter what's the second line
[22:37:38] <cmr> SingingBoyo: str::connect or something like that iirc
[22:37:47] <q66> here it's: JIT: ON SSE2 SSE3 SSE4.1 fold cse dce fwd dse narrow loop abc sink fuse
[22:37:49] <kimundi> SingingBoyo: Or use fmt!()
[22:37:54] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.1)
[22:38:19] <q66> also i use 2.1-dev which has some extra stuff but that shouldn't make much difference
[22:38:20] <steven_is_false> So the answer is too complicated to sum up in a yes, or no answer?
[22:38:29] *** Quits: MaikKlein (maik@moz-972D34E0.dip0.t-ipconnect.de) (Ping timeout)
[22:38:40] <strcat> steven_is_false: rust's build system doesn't benefit
[22:38:41] <strcat> LLVM's does
[22:38:43] <strcat> so no
[22:38:43] <mleise> q66: same result as before for the iota stuff. 50% longer runtime with Lua. Flags are: JIT: ON CMOV SSE2 SSE3 fold cse dce fwd dse narrow loop abc sink fuse
[22:38:54] <steven_is_false> strcat: Okay.
[22:39:15] <q66> mleise, hm, ok. your build doesn't use sse 4.1, but it uses the same set of optimizations
[22:39:15] <kimundi> rusti: fmt!("%s%s", "foo", "bar")
[22:39:16] -rusti- ~"foobar"
[22:39:38] <q66> mleise, I suppose it's not supported by your CPU
[22:39:46] <mleise> correct
[22:39:50] <strcat> sadly fmt spits out 300 asm ops to do that
[22:39:57] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[22:40:02] <strcat> ;p
[22:40:14] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[22:40:23] <q66> mleise, I guess LuaJIT does some extra optimizations using the extra instructions on tables, would explain the difference, as my C impl was almost the same as your D impl
[22:40:38] <q66> in either case, tables are a lot more complicated structure than raw arrays
[22:40:49] <q66> which means more optimizations are needed on these for them to be fast ;P
[22:41:02] *** Quits: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net) (Quit: eatkinson)
[22:41:25] <q66> I suppose you could use a FFI array, but meh
[22:41:29] <mleise> sure, I just felt that you had some old numbers in your head (10x slower)
[22:41:29] <q66> in the end, it barely matters
[22:41:44] <q66> 10x slower is the 2010 number, 8x slower is my number from last year
[22:41:46] <mleise> if you care about speed it's not that bad
[22:41:53] <SingingBoyo> rusti: static A:&'static str = "blah"; static B:&'static str = "foo"; static C:&'static str = fmt!("%s%s", A, B);
[22:41:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FEJR
[22:42:01] <mleise> since you look for better compiler backends
[22:42:10] <q66> if dmd did extra optimizations recently, it's very well possible it's lower, but it's still slower, which feels wrong :P
[22:42:15] <mark_edward> the library docs are generated from source code comments right?
[22:42:15] <mleise> you don't use Lua, you use LuaJIT for example
[22:42:20] <orshem> Hi. I'm trying to run the front page example. I changed the core to std, but it won't compile.
[22:42:23] <SingingBoyo> anyone know what's up with that error?
[22:42:37] <strcat> orshem: with which version
[22:42:49] <orshem> after adding "use std::rand;" I'm getting an error unresolved name `rand::Rng`
[22:43:02] <orshem> I'm using yesterday's incoming
[22:43:09] <cmr> SingingBoyo: I don't think you can do that with fmt!(). fmt!() returns a ~str anyway
[22:43:23] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Quit: )
[22:43:32] <orshem> rustc --version: rustc 0.6 (c354a0c 2013-06-01 22:37:35 -0700)
[22:43:48] <strcat> orshem: well it's not called that now
[22:43:57] <strcat> there were changes to the rand module
[22:44:13] <strcat> Rng is a trait
[22:44:27] <q66> aw, freebsd ports don't have ldc
[22:44:32] <q66> i wanted to try it here
[22:44:38] <mark_edward> rusti: "FIZZBUZZ".to_ascii().to_lower().to_str_consume()
[22:44:39] <q66> I CBA building it
[22:44:40] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[22:44:44] <mark_edward> huh
[22:44:53] <strcat> self-by-value doesn't work yet
[22:44:56] <mark_edward> rusti: "FIZZBUZZ".to_ascii().to_lower().to_str()
[22:44:58] -rusti- ~"[\'f\', \'i\', \'z\', \'z\', \'b\', \'u\', \'z\', \'z\']"
[22:44:58] <SingingBoyo> cmr: hmm good point.  well then I'm at a loss here.
[22:45:05] <q66> it has dmd2, but that's useless
[22:45:11] <mark_edward> huh
[22:45:25] <strcat> mark_edward: you're converting a vector to a string
[22:45:43] *** Joins: eatkinson (eatkinson@moz-5CF47426.dia.static.qwest.net)
[22:45:45] <mark_edward> oh ok
[22:46:10] <strcat> maybe Ascii should be more indirectly a vector
[22:46:46] <mark_edward> rusti: "FIZZBUZZ".to_ascii().to_lower().to_str_ascii()
[22:46:48] -rusti- ~"fizzbuzz"
[22:46:51] <orshem> strcat: thanks. I tried to look at the code and the examples in the comments still used core, so they're probably out of date too/
[22:46:51] <mark_edward> ok cool
[22:46:52] <kimundi> use to_str_ascii
[22:47:08] <kimundi> that converts a [Ascii] to a str
[22:47:14] <mleise> q66: actually it is pretty simple to build and install LDC2: http://wiki.dlang.org/Building_LDC_from_source#LDC
[22:47:15] <cmr> orshem: they are, the docs are built from master
[22:47:21] <kimundi> In the more useful sense :P
[22:47:33] <mark_edward> thanks
[22:47:38] <mleise> as long as LLVM 3.2 is installed
[22:47:43] <mark_edward> when i use str.each_char
[22:47:56] <mark_edward> i get error,  multiple applicable methods
[22:48:08] <kimundi> known issue
[22:48:21] <q66> mleise, for your ref
[22:48:23] <mark_edward> how do i workaround it?
[22:48:26] <q66> q66@freebsd: /home/q66/tests$ ./test                  
[22:48:26] <q66> done: 2.468750
[22:48:26] <q66> q66@freebsd: /home/q66/tests$ luajit-2.1.0-alpha sort.lua 
[22:48:26] <q66> finished: 2.2375
[22:48:29] <kimundi> each_char of StringSlice ant Writer conflict
[22:48:30] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:48:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/TSy08A
[22:48:30] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:48:33] <strcat> mark_edward: you can't
[22:48:34] <q66> (i still have the binary :P)
[22:48:51] <mark_edward> but then how do i iterate over a strings chars
[22:48:52] <orshem> cmr: I meant the examples inline in the source: rust/src/libstd/rand.rs
[22:49:01] <mleise> q66: was that the C version?
[22:49:17] <q66> yep
[22:49:20] <kimundi> mark_edward: try the standalon fn str::each_char(...)
[22:49:31] <mleise> also your cpu is quite fast, may i say :D
[22:49:39] <q66> it's an ivy bridge i5
[22:49:58] <mark_edward> ok thanks
[22:49:58] <mleise> I guess something didn't get inlined
[22:50:13] <q66> who knows
[22:50:22] <mleise> the disassembler :p
[22:50:26] <q66> it doesn't matter anyway.. it's freakin' 10 million numbers
[22:50:34] <q66> it sorts that in two seconds
[22:50:46] <mleise> yeah it's awesome
[22:51:06] <kimundi> rusti: for std::str::each_char("Î»fÃ¶") |c| { print(fmt!("%x ", c as uint)) }
[22:51:07] -rusti- 3bb 66 f6 ()
[22:51:12] <mleise> I was surprised by how fast the fastest sudoku solvers are today
[22:51:18] <q66> and in a real world application you'll barely be bounded by slowness of something like this
[22:51:24] <q66> there totally different things matter
[22:51:28] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:51:28] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/9Cxtag
[22:51:28] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:51:29] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:51:29] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/VnvxDA
[22:51:29] <ghrust> 13rust/06auto 145076bca 15Young-il Choi: mk: test.mk modify to better support
[22:51:29] <ghrust> 13rust/06auto 140ea8274 15Young-il Choi: etc: adb_run_wrapper added
[22:51:29] <ghrust> 13rust/06auto 14fe1dc32 15Young-il Choi: compiletest: improve exit code handling with adb_run_wrapper
[22:51:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:51:36] <mleise> like stop-the-world garbage collectors
[22:51:42] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[22:51:48] <q66> luajit's gc kinda sucks too tbh
[22:51:57] <q66> it's identical with the lua 5.1 gc
[22:51:58] <cmr> yeah it's really really simple
[22:52:11] <q66> in comparison to the druntime GC it's at least incremental, so it doesn't freeze my engine every collection cycle
[22:52:14] <q66> but that's it ;P
[22:52:55] <mleise> well as long as we have Manu in the community, chances are that something will be done within 2013 or 2014
[22:52:57] <q66> not that I generate a lot of garbage in that code, the temporary table allocations inside functions (locals) are optimized out by luajit
[22:53:07] <q66> and the global tables are typically permanent
[22:53:21] <q66> so my scripting barely leaves any garbage for the GC at all
[22:53:28] *** Quits: judder (maradukewa@385DDD8F.206937E4.78E362FE.IP) (Ping timeout)
[22:53:36] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[22:53:55] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Ping timeout)
[22:54:18] <mleise> btw. LDC has this new feature to run an escape analysis and switch GC allocations to stack allocations, so you can freely use 'new' there
[22:54:28] <SingingBoyo> rusti: static A:~str = ~"a"; static B:~str = ~"b"; static AB:~str = A + B; fn main(){std::io::println(AB)}
[22:54:30] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CbJO
[22:54:33] <q66> alright
[22:54:39] <mleise> It's amazing how much compiler tech can have an effect on languages
[22:54:55] <q66> did they solve the problems with dead code elimination yet?
[22:55:01] <cmr> SingingBoyo: You can only have &'static or values in static variables
[22:55:05] <q66> i recall it having a lot of problems in that area
[22:55:10] <mleise> a few years ago some ideoms would have been dismissed because they cannot be implemented efficiently
[22:55:12] <q66> LDC in particular, dmd doesn't do this at all ;P
[22:55:26] <SingingBoyo> cmr: fair enough.  Then how would I manage to build up strings this way?
[22:55:35] <SingingBoyo> cmr: is it even possible?
[22:55:36] <cmr> SingingBoyo: You don't, you do it at runtime.
[22:55:48] <mleise> dmd does that actually for simple if's. but i don't know about LDC
[22:56:01] <q66> mleise, http://wiki.luajit.org/Optimizations btw
[22:56:12] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[22:56:12] <mleise> I found it to beat GDC now in a few test programs, so that's pretty cool
[22:56:19] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:56:50] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[22:57:15] <mleise> Also their approach to offer flags to enable/disable in-contracts, out-contracts, asserts and pretty much every other tiny language feature is nice
[22:57:18] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[22:57:40] <q66> too bad asserts in D throw exceptions
[22:57:42] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[22:57:44] <q66> I always found that terrible
[22:58:13] <mleise> "Machine Code Patching" - way to go :)
[22:58:46] <mleise> what's so terrible with exceptions? i think with scope(exit) they are quite manageable
[22:59:20] <q66> mleise, they're pervasive
[22:59:25] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[22:59:33] <q66> and my complaint wasn't about exceptions in general anyway
[22:59:38] <q66> but about assert throwing exceptions
[22:59:44] <mleise> what do you want asserts to do instead?
[23:00:02] <q66> IMO if D even tries to claim it's a systems programming language, it should not make core language constructs throw
[23:00:17] <q66> instead if you want throwing assert, it should be defined in std.exception
[23:00:18] <mleise> ...or use a GC? :D
[23:00:30] <q66> the default assert should behave pretty much identically to C
[23:01:04] <q66> mleise, GC is fine again, if your core features do not depend on it
[23:01:14] <mleise> that's what I mean, they DO
[23:01:14] <q66> in D they do
[23:01:31] <q66> so D is pretty much a bit worse designed C# that compiles to native code
[23:01:37] <q66> a high level language
[23:01:40] <q66> barely a systems language
[23:02:13] *** strcat1 is now known as strcat
[23:02:15] <cmr> q66: And how do you feel about rust?
[23:02:17] <mleise> well, I think they aimed for the middle ground while allowing you to implement your own assert
[23:02:50] <mleise> i don't think rust is always so minimal either? what do asserts in rust do by the way?
[23:02:56] <cmr> Task failure
[23:02:57] <bjz> q66: why do you feel so personally about D?
[23:03:09] <strcat> mleise: the current assert is more like a shorthand for if !x { fail!() }
[23:03:11] <bjz> q66: it's just a language
[23:03:16] <q66> cmr, rust is alright, right now :P
[23:03:21] <strcat> mleise: there will be asserts that compile out for debugging, maybe debug_assert!
[23:03:24] <q66> i'm looking forward to it maturing
[23:03:35] <q66> bjz, i wasted too much time with that PoS in the past
[23:03:40] <strcat> mleise: anyway it's trivial to write one with a macro ;p
[23:03:42] <mleise> strcat: ok, but what does fail!() do?
[23:03:47] <strcat> mleise: unwinding
[23:03:54] <mleise> exception! OMG!
[23:03:59] <mleise> q66 RUUUN
[23:04:06] <bjz> q66: wouldn't you have learned some things along the way though?
[23:04:16] <strcat> mleise: although assert! is sort of a library feature since it's just a macro ;p
[23:04:17] <q66> well, sure
[23:04:20] <cmr> It runs destructors but it definitely isn't an exception, because it can't be caught
[23:04:22] <q66> for instance, I learned D is crap! hrhrhrhr
[23:04:31] *** Joins: wycats_ (uid79@moz-C944F5EC.irccloud.com)
[23:04:43] <strcat> cmr: at a task boundary it can be
[23:05:18] <mleise> in D it isn't caught normally either, but you can if you catch Throwable instead of Exception
[23:05:30] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[23:05:45] <q66> bjz, initially, i was *really* but *really* looking forward to D eventually getting its place in my new projects as it seemed pretty nice at first, I looked past all the issues
[23:05:50] <q66> but meh, what's the point, I realized afterwards
[23:06:01] <q66> it has way too many issues to my liking
[23:06:05] <bjz> q66: well that's ok
[23:06:20] <bjz> I was of the same opinion
[23:06:23] <q66> if it has so many issues, why would I use it rather than C++, which has issues too (way fucking too many) but at least it's well supported
[23:06:31] <bjz> but why the personal vendetta?
[23:06:36] <EXetoC> mleise: yeah, you shouldn't really catch that so it doesn't matter. it's alright for testing purposes though
[23:06:41] <q66> personal vendetta? there is none ;P
[23:06:44] <q66> I just like trolling mleise
[23:07:13] *** Joins: tjc (tjc@moz-9B206D5E.tukw.qwest.net)
[23:07:14] *** ChanServ sets mode: +o tjc
[23:07:17] <bjz> well, it's tiresome
[23:07:29] <q66> ok, I guess it's getting kinda old
[23:07:46] <EXetoC> rly
[23:07:55] <q66> EXetoC, ya rly! :P
[23:08:11] <bjz> pm him if you want to go on like a broken record
[23:08:13] <mleise> hehe, at least wm4 and q66 don't troll on #D anymore ;)
[23:08:50] <q66> it wasn't always trolling, I was constructive too
[23:08:59] <mleise> until you started trolling
[23:09:07] <q66> I was constructively trolling afterwards
[23:09:15] <cmr> q66: mleise: can you quabble elsewhere?
[23:09:18] <EXetoC> sure
[23:09:25] <q66> ok
[23:09:30] <mleise> ok
[23:09:36] <q66> let's take it.. where? :P
[23:09:44] <mleise> no no nono
[23:09:58] <xenocons> bjz: hey
[23:10:04] <EXetoC> in a black hole
[23:10:10] <q66> in a butt
[23:10:16] <bjz> xenocons: hoya
[23:10:26] <xenocons> i got a question, ill pm coz its not rust related :)
[23:11:40] <mleise> I don't know... trolling is so boring without a public
[23:12:10] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[23:12:42] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:13:35] *** Joins: snearch (snearch@moz-20D9F6B4.pool.mediaways.net)
[23:13:45] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[23:13:59] <orshem> I'm reading the tutorial and I'm not sure: is self a keyword?
[23:14:04] <orshem> and Self?
[23:14:16] <orshem> it is a type name?
[23:14:39] <strcat> self is a keyword, Self is a type used in trait definitions
[23:14:52] <strcat> to refer to the type it's implemented for
[23:16:22] <orshem> thanks strcat
[23:16:29] <strcat> np
[23:21:35] *** Joins: \n (NDesaulnie@moz-C2B49FFE.hsd1.ca.comcast.net)
[23:22:00] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:22:41] <mark_edward> hey
[23:23:21] <mark_edward> if im spawing closures in a loop
[23:23:49] <mark_edward> and i know i'm only going to have read access the data
[23:24:01] <mark_edward> how do ishare it accross tasks like that
[23:24:40] <strcat> if you really don't want to use message passing you can use std::arc for shared immutable data
[23:24:52] *** Joins: ssbr (ssbr@8C6BCB51.60379805.59660190.IP)
[23:25:01] <mark_edward> fairly big structures, so i don't want to copy them 11 times
[23:27:23] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[23:29:20] *** Joins: deepdog (deepdog@moz-490E834C.client.mchsi.com)
[23:29:39] <tjc> brson: r? https://github.com/mozilla/rust/pull/6904
[23:31:51] <strcat> tjc: https://github.com/mozilla/rust/pull/6905 r?
[23:32:20] *** kimundi is now known as zz_kimundi
[23:33:26] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[23:33:49] <tjc> strcat: looking
[23:33:50] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[23:34:24] <tjc> r+'ed
[23:34:39] <strcat> :)
[23:35:38] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Ping timeout)
[23:35:48] *** Joins: claude (Mibbit@moz-D29440D3.eastlink.ca)
[23:36:37] *** Quits: deepdog (deepdog@moz-490E834C.client.mchsi.com) (Quit: Leaving)
[23:37:29] <claude> Hello, I have been looking at the rust tutorial and in the structs section (5) there is a function used called info!. I cannot find any information on this function and I was wondering what it does.
[23:37:45] <cmr> claude: it's part of the logging system, it outputs at log level 3.
[23:37:51] <cmr> http://static.rust-lang.org/doc/rust.html#logging-system
[23:38:01] <claude> ahhh thanks.
[23:38:49] <cmr> (And it's a macro, not a function, but that's a fairly minor detail)
[23:39:29] <claude> Is that what the ! denotes?
[23:39:32] <cmr> Yes
[23:39:39] <claude> Nice
[23:40:22] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[23:42:02] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[23:42:37] *** Joins: MaikKlein (maik@moz-972D34E0.dip0.t-ipconnect.de)
[23:42:49] <mark_edward> how optimized is Rust now? I ask because i ported a text-processing thing from C++ over
[23:42:55] *** Quits: rumpler (Mibbit@moz-E89B7C5B.range109-154.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[23:43:03] <tjc> mark_edward: not very
[23:43:09] *** Joins: JesseH (JesseH@moz-2E766C3E.mc.at.cox.net)
[23:43:20] <strcat> tjc: well that's not entirely true, it's mostly the library features that are slow
[23:43:24] <mark_edward> and with multitasking, it runs at 26s on rust, and 21s with completely sequential c++
[23:43:45] <strcat> if you write the same code in rust and C++, it's essentially the same
[23:44:07] <mark_edward> strcat: what do you mean?
[23:44:09] <tjc> strcat: I just have a vague sense that there's plenty more work to do on performance
[23:44:11] <JesseH> Where can I find speed benchmarks for rust?
[23:44:18] <cmr> JesseH: src/test/bench 
[23:44:25] <JesseH> Alright ty
[23:44:26] <tjc> but, asking how optimized it is always leaves the question open of "optimized relative to what?"
[23:44:31] <mark_edward> C++
[23:44:32] <tjc> it's the most optimized Rust compiler there is :-)
[23:44:37] <cmr> heh
[23:44:39] <strcat> tjc: I'm sure there is, but I think it's mostly the runtime and stdlib where that applies
[23:44:51] <mark_edward> i really like the multitasking though
[23:45:00] <strcat> tjc: compared to identical code (probably with parts in unsafe) in C++ the only difference is that we lack TBAA
[23:45:07] <MaikKlein> do you know when we get official default methods for traits? is there an open ticket for this?
[23:45:17] <mark_edward> `time` tells me the user time was 1m32s but the real time was 26s
[23:45:19] <strcat> moves are slow, ~ has useless headers, I/O is slow, scheduling is slow
[23:45:28] <strcat> etc.
[23:45:32] <tjc> yeah
[23:45:51] <mark_edward> a fairly good part of my program is i/o
[23:46:05] <tjc> MaikKlein: I don't think there's a meta-bug yet
[23:46:07] <strcat> mark_edward: well if you don't use rust's stdlib for I/O it will be fine
[23:46:11] <tjc> there probably should be one
[23:46:13] <mark_edward> and how can moves be slow?
[23:46:15] <strcat> if you just call stdio directly
[23:46:22] <cmr> mark_edward: If you're on linux, profile with `perf` and take a peek :)
[23:46:34] <mark_edward> you just switch everything, at leasts thats what bjarne stroustroup told me
[23:46:43] <mark_edward> okey-dokey
[23:46:55] <strcat> mark_edward: because in C++ they usually only zero 1 field in the source to mark it as destroyed
[23:47:01] <strcat> rust currently zeroes the whole thing
[23:47:10] <mark_edward> id love to contribute, but don't think i have the skills to contribute to compiler/optimization stuff
[23:47:13] <strcat> and types with custom (not from ~) destructors get a drop flag
[23:47:19] <strcat> which is often bad
[23:47:32] <strcat> sometimes you need a drop flag, sometimes you don't want an extra hidden field since you can reuse an existing one
[23:48:07] <cmr> mark_edward: depends. some optimizations are really ridiculously easy to make, but haven't been noticed yet.
[23:48:20] <strcat> ~ allocations currently have unused 32-byte headers, that's a big one. although you can make a nearly equivalent (it just can't contain @) type in a library
[23:48:27] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[23:48:44] <strcat> then you get hit with the drop field though ;p
[23:48:49] <mark_edward> 32 byte or bit?
[23:48:53] <mark_edward> 32 bytes is a lot
[23:48:53] <strcat> byte
[23:48:54] <cmr> byte
[23:48:56] <mark_edward> oh
[23:48:58] <strcat> mark_edward: yes but it's unused
[23:48:58] *** Quits: ssbr (ssbr@8C6BCB51.60379805.59660190.IP) (Ping timeout)
[23:49:07] <strcat> it can be removed if someone feels like making the compiler smarter
[23:49:09] <mark_edward> is there a future use planned?
[23:49:13] <strcat> mark_edward: nope
[23:49:18] <cmr> "9589 bytes compressed to 3183 (33.2% size) and was decompressed to 18446744073709550343"
[23:49:21] <cmr> Well that's a bug
[23:49:33] <strcat> it only exists because the compiler generates the same code for ~ not containing @ and ~ containing @
[23:49:44] <strcat> it doesn't have to, it knows that at compile-time
[23:49:55] <strcat> but updating a million offsets is not going to be fun and no one has done it
[23:50:04] <mark_edward> hm...
[23:50:11] <strcat> (well more like 6-10, but they are going to be fun to find)
[23:50:25] <mark_edward> sounds like a job for an unpaid intern
[23:50:29] <cmr> heh
[23:50:38] <tjc> we don't believe in unpaid interns :-)
[23:50:39] <cmr> mark_edward: isn't that what we community members are? :P
[23:50:43] <aatch> mark_edward, so an OSS contributor?
[23:50:59] <mark_edward> yup!
[23:51:02] <tjc> *awesome volunteers*, on the other hand...
[23:51:04] <cmr> mark_edward: you get paid in heaps of praise, though
[23:51:08] <tjc> and T-shirts
[23:51:11] <tjc> soon
[23:51:29] <cmr> Removing the headers from ~ would be super amazing
[23:51:34] <steven_is_false> tjc: T-shirts !?!
[23:51:43] <strcat> cmr: can only be removed from ~ not containing @ atm though
[23:51:45] <aatch> tjc, T-SHIRTS?
[23:51:46] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:51:51] <cmr> strcat: even so
[23:51:53] <tjc> steven_is_false: I'm told the T-shirts have actually materialized; I'm not in Mountain View right now, so I can't say firsthand
[23:51:55] <strcat> so that's essentially what has to be done, distinguishing between them at compile-time
[23:51:55] <tjc> aatch: ^
[23:51:58] <strcat> instead of runtime
[23:52:00] <strcat> like we do now
[23:52:04] <strcat> which is dumb. :)
[23:52:20] <tjc> once we figure out where you all live, people who have contributed significantly will start getting them (we reserve the right to determine arbitrarily what "significantly" means :-)
[23:52:22] <thomaslee_> that header thing sounds an awful lot like the vestigial first argument for functions immediate return types.
[23:52:29] <thomaslee_> functions with*
[23:52:41] <aatch> strcat, doesn't type_contents have machinery in place for that kind of detection though?
[23:52:49] <strcat> aatch: yes
[23:52:53] <strcat> aatch: but it's not used properly
[23:53:28] <strcat> afaict ~ was tacked on after @ already existed, but I wasn't around for that
[23:53:55] <strcat> type contents may not have existed then
[23:54:13] <aatch> strcat, wouldn't surprise me.
[23:54:32] <aatch> I wasn't criticizing, just making an observation
[23:54:32] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:54:32] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/VnvxDA
[23:54:32] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:54:40] <strcat> aatch: I know :)
[23:54:46] *** Quits: tjc (tjc@moz-9B206D5E.tukw.qwest.net) (Quit: zzzzzzzzzz)
[23:54:48] <strcat> just interesting how it ended up so horrible
[23:55:05] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[23:55:19] <aatch> yeah, it's cruft built on cruft built on cruft.
[23:55:42] <aatch> Pretty much the entirety of trans needs to be re-written.
[23:56:19] <cmr> Is it possible to do it piecemeal or is the whole thing generally bad?
[23:56:23] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:56:43] *** Joins: strcat1 (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:56:45] <aatch> cmr, might be possible to do it piecemeal, but the general structure isn't very good either.
[23:56:51] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:57:03] *** strcat1 is now known as strcat
[23:57:11] <aatch> there are patterns that exist because better ones weren't possible at the time.
[23:57:31] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:57:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/NXgYHw
[23:57:31] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:57:32] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:57:32] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/5GDZXg
[23:57:32] <ghrust> 13rust/06auto 144541331 15Daniel Micay: ptr: split out borrowed pointer utilities...
[23:57:32] <ghrust> 13rust/06auto 14c40baf6 15bors: auto merge of #6905 : thestinger/rust/ptr, r=catamorphism...
[23:57:32] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:58:00] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Client exited)
[23:58:01] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)

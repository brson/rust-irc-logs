[00:07:11] <nmatsakis> nrc: :(
[00:08:34] <nmatsakis> nrc arielb1: can you clarify https://github.com/rust-lang/rfcs/pull/1052#discussion_r31562561 <-- pnkfelix and I have the right intepretation, yes? 
[00:10:10] <nrc> nmatsakis: commented, short answer: no
[00:11:11] * nmatsakis reconsiders
[00:11:19] <nmatsakis> I'm actually not sure now which way I interpreted it :)
[00:11:25] <nmatsakis> now that you mention it, seems to make sense
[00:12:00] <nmatsakis> in particular
[00:12:12] <nmatsakis> otherwise you're just casting *Foo to *Foo
[00:14:18] <nmatsakis> nrc: however, I am a bit unsure about this, after all, we do want to support upcasts eventually
[00:14:25] <nmatsakis> and in that case, we will adjust the vtable
[00:20:30] <nrc> I guess I was thinking of explicit casts as the more 'intentional' operation. I.e., implicit coercions would not do the conversion from fat ptrs to thin ptrs and would change the vtables, but casting would just take the pointers
[00:20:42] <nrc> on reflection I'm not sure if that is a good idea
[00:20:57] <nrc> I think there is an expectation that implicit coercion and explicit casts do the same thing
[00:21:12] <nrc> i.e., that explicit casts are a superset of implicit coercions
[00:23:21] <nmatsakis> I have that expectation, yes
[00:24:31] <nrc> This kind of implies we need a third kind of conversion - somewhere between a cast and a transmute
[00:24:56] <nrc> I think these can be done in code, they don't need anything first class in the language
[00:25:30] <nmatsakis> in the past I had in mind some intrinsics for working with possibly-fat-pointers
[00:25:36] <nmatsakis> is that your concern as to why it cannot just be a tranmsute?
[00:25:50] <nmatsakis> (that is, the desire to work uniformly)
[00:25:57] <nmatsakis> like, if you're slicing a vtable around
[00:26:08] <nmatsakis> I imagine you want to know the types involved most of the time?
[00:30:51] <nrc> there seem to be some common-ish operations which are safer than transmutes, it would be nice to support them without forciing programmers to use transmutes
[00:31:23] <nrc> I'm imagining something a bit higher level than fat ptr intrinsics, I think
[00:37:06] <nmatsakis> nrc: I can imagine it, but i don't have an example in mind of some "reasonable code" to enable
[00:38:11] <nrc> you mean the implementation or a use case?
[00:38:17] <nmatsakis> latter
[00:40:00] <nmatsakis> I guess I'm not sure what's bad about transmute; I'm not 100% sure why we support *X -> *Y for arbitrary X and Y,
[00:40:09] <nmatsakis> except for constant evaluation
[00:40:12] <nmatsakis> and legacy reasons of course :)
[00:40:28] <nmatsakis> but *X -> *u8 -> *X feels like something one sort of expects from C etc
[00:40:43] <nrc> getting the raw pointers out of a bunch of trait objects seems reasonable, although I'm not sure about an actual concrete use case
[00:40:45] <nrc> right
[00:41:25] <nrc> trait object to trait object I guess seems less clear
[00:43:24] <nrc> unsized arrays seem reasonable
[00:43:46] <nrc> e.g., [u8] as [i8]
[00:44:01] <nrc> er., &[u8] as &[i8]
[00:44:09] <nmatsakis> *?
[00:44:14] <nmatsakis> (I think you mean)
[00:44:22] <nrc> yeah
[00:44:24] <nrc> *
[00:47:06] <nmatsakis> seems no worse than *X to *Y
[00:47:53] <nrc> I can't imagine how you would want to cast trait objects though
[00:48:39] <nmatsakis> me either
[00:48:44] <nrc> perhaps we just remove trait object casts, and reserve them for when we can upcast properly
[00:49:06] <nrc> leave fat -> thin and *array ->* array
[01:11:14] <huon> question: do we intend to have first class support for powerpc and mips?
[01:11:36] <huon> (specifically, first-class SIMD support)
[01:13:51] <nrc> I think we would like to "some day" I don't think anyone is actively working on it
[01:14:35] <huon> I will be the one actively working on it (SIMD) for the two + epsilon months starting in a few weeks :)
[01:15:20] <huon> (that's what my internship is on)
[01:15:45] <nrc> where "it" = support for powerpc and mips
[01:16:24] <huon> yeah, I'm scoping out if I should be working on that aspect too
[01:16:24] <nrc> I wouldn't worry about SIMD for powerpc/mips
[01:16:39] <huon> ok
[01:16:40] <nrc> it would be nice to have an architecture that didn't prevent support in the future
[01:16:52] * huon doesn't really have a good idea for what/where powerpc/mips are used
[01:16:57] * huon reads up a bit
[01:18:48] <nrc> routers
[01:18:54] <nrc> some phones
[01:19:06] <nrc> embedded stuff
[01:20:22] <huon> ok, so... things Rust would probably be good for.
[01:20:46] <huon> so yeah, at least keeping the avenue open for the future sounds important
[01:30:03] <nrc> yeah, we do seem to get a fair amount of interest in those targets
[02:00:34] *** WindowsBunny is now known as WindowsSheep
[02:14:19] *** Quits: Luqman (laden@moz-bjmiqc.csclub.uwaterloo.ca) (Ping timeout: 121 seconds)
[02:14:38] *** Joins: Luqman (laden@moz-bjmiqc.csclub.uwaterloo.ca)
[02:28:49] <cmr> huon: ah nice.
[02:28:53] <cmr> re: simd focus.
[03:03:37] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[07:01:54] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[08:26:45] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[09:33:12] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[09:43:33] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[10:22:33] *** Joins: Tobba (Tobba@moz-6oh.7ki.21.217.IP)
[11:26:40] *** WindowsSheep is now known as WindowsBunny
[11:32:48] *** Quits: nrc (nrc@moz-14pjgj.xtra.co.nz) (Ping timeout: 121 seconds)
[12:33:19] *** Quits: Tobba (Tobba@moz-6oh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[13:37:38] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[22:04:46] *** Joins: nrc (nrc@moz-14pjgj.xtra.co.nz)

[00:02:50] <erickt> jdm: looking
[00:06:19] <erickt> jdm: it's because JSTracer isn't implementing the Encoder interface properly. You need to call the closure methods
[00:06:26] <jdm> ohhhh
[00:06:31] <jdm> that makes sense
[00:06:45] <jdm> yeah, I should have looked closer at that
[00:06:46] <jdm> thanks
[00:06:58] <erickt> jdm: `rustc --pretty expanded foo.rs` really helps out with these kinds of things
[00:07:09] <jdm> I'll keep that in mind
[00:07:22] <erickt> let me know if you run into any more trouble with em
[00:08:00] <strcat> acrichto: it'll be so nice when @ is gone...
[00:08:05] <strcat> no more take glue, no more free glue...
[00:08:27] <acrichto> free glue?
[00:08:30] <erickt> ooh are @s almost removed?
[00:08:32] <acrichto> how is that distinct from drop glue?
[00:08:39] <strcat> acrichto: because @ ;p
[00:08:46] <acrichto> erickt: pcwalton has championed in the fight against @
[00:08:49] <strcat> tbh I think I could probably get rid of it
[00:08:51] <acrichto> strcat: what did free glue do?
[00:08:52] <strcat> right now
[00:08:59] <strcat> acrichto: free glue frees allocations
[00:09:01] <strcat> ~ and @
[00:09:04] <erickt> acrichto: I know, I've been watching it with a hopeful eye
[00:09:13] <acrichto> strcat: huh? how's that different from drop glue?
[00:09:15] <strcat>     // Called when a value of type `T` is no longer needed
[00:09:17] <strcat>     drop_glue: GlueFn,
[00:09:19] <strcat>     // Called by drop glue when a value of type `T` can be freed
[00:09:21] <strcat>     free_glue: GlueFn,
[00:09:24] <acrichto> oh lol
[00:09:32] <strcat> acrichto: well, it was a poor way of doing something similar to what Rc does now that it supports Weak
[00:09:33] <acrichto> just in the tydesc
[00:09:35] <pcwalton> free glue is already gone
[00:09:40] *** Quits: jdm (jdm@CC0122E6.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[00:09:40] <strcat> pcwalton: oh, it is?
[00:09:45] <pcwalton> yeah, eddy removed it iirc
[00:09:47] <pcwalton> eddyb
[00:09:47] <strcat> ah
[00:10:02] <strcat> he asked me about stuff to optimize and I suggested that but I didn't know he finished it ;p
[00:10:26] <strcat> pcwalton: hm, it looks like some is still there
[00:10:35] * pcwalton shrugs
[00:10:49] <strcat> make_free_glue is there at least
[00:11:24] <strcat> maybe it just didn't land yet?
[00:15:19] <strcat> gtk really annoys me with their cdecl abuse
[00:15:25] * strcat sighs
[00:20:32] *** Joins: deens (deens@moz-A47475CE.hsd1.ca.comcast.net)
[00:21:31] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[00:21:31] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/mIIKsg
[00:21:31] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[00:22:24] *** Quits: deens (deens@moz-A47475CE.hsd1.ca.comcast.net) (Client exited)
[00:23:26] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[00:26:30] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:26:30] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/hkA1ag
[00:26:30] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:26:33] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[00:26:33] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/bM8PXg
[00:26:33] <ghrust> 13rust/06auto 1477cdd77 15Daniel Micay: remove reference counting headers from ~...
[00:26:33] <ghrust> 13rust/06auto 1489e2550 15Daniel Micay: remove `borrow_offset` as ~ is now free of headers
[00:26:34] <ghrust> 13rust/06auto 147675c0e 15Daniel Micay: add implementation of `Repr` for `~[T]`
[00:26:36] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[00:27:27] <strcat> pcwalton: so if the gc uses side tables, does that mean trait objects wouldn't need a tydesc? just a dtor ptr
[00:27:37] <strcat> ~Trait
[00:27:42] <strcat> &Trait wouldn't need anything
[00:27:43] <pcwalton> well, not if you want to support casting
[00:27:45] <pcwalton> RTTI
[00:27:54] <strcat> pcwalton: afaik Any does that separately though
[00:28:00] <strcat> and you can say Foo + Any
[00:28:06] <pcwalton> yeah, but it might be nice to have thatâ€¦ oh, I see, Foo + any
[00:28:07] <pcwalton> maybe
[00:28:11] * pcwalton has to think
[00:28:23] <pcwalton> but perhaps Any might be a quite elegant way to opt into RTTI on a per type basis like that
[00:28:41] <strcat> as elegant as you can call RTTI anyway ;p
[00:29:04] <strcat> afaik stack closures still have headers
[00:29:22] <pcwalton> sometimes it takes a tough man to make a tender chicken
[00:29:31] <pcwalton> said the MIT guy
[00:31:33] <strcat> soon gmail will be using as much memory as rustc
[00:31:38] <strcat> 120MiB! :|
[00:32:12] * ChrisMorgan remembers Gmail being 75MB only a few months ago
[00:32:18] <strcat> it leaks
[00:32:58] <strcat> and it has strings that are over 1MiB :)
[00:34:23] <strcat> 0.10 MB (00.04%) ++ string(length=15, copies=1600, "mail.google.com")
[00:34:29] * strcat is a bit suspicious of about:memory
[00:34:31] <strcat> it counts itself
[00:35:19] <ChrisMorgan> Of course it does.
[00:40:20] *** Quits: bytewise (bytewise@moz-175CA5D5.adsl.alicedsl.de) (Quit: Leaving)
[00:48:23] <Yurume> bstrie, aaaargh! XD
[00:48:46] <Yurume> consequently the page now has a permanent URL: http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/
[00:51:18] <dbaupp> gah, why does libstd --test take so long to build?
[00:53:14] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[00:53:35] <acrichto> pcwalton: fn foo<T>(t: ~T) {} <- can I call that with ~str in DST?
[00:53:45] <pcwalton> yes
[00:53:51] <acrichto> \o/
[00:56:03] <pcwalton> acrichto: chans could use some cross crate inlining
[00:56:20] <pcwalton> comm::Consumer::packet is extremely expensive
[00:56:30] <pcwalton> well, hmm
[00:56:31] <acrichto> pcwalton: oh dear I would believe that
[00:56:34] <pcwalton> why didn't that hit the inlining heuristic
[00:56:34] <acrichto> that's just a getter
[00:56:50] <pcwalton> also maybe_yield is extremely high in the profile
[00:56:52] <dbaupp> does -Z lto help?
[00:56:53] <pcwalton> it's huge
[00:57:03] <acrichto> pcwalton: whoa, I tried to eliminate that
[00:57:04] <pcwalton> we REALLY need TBAA-struct
[00:57:09] <pcwalton> well, wait
[00:57:10] <pcwalton> 2.9%
[00:57:15] <pcwalton> I wouldn't say extremely high
[00:57:16] <pcwalton> never mind
[00:57:32] <acrichto> pcwalton: what's the slow thing in maybe_yield?
[00:57:34] <pcwalton> still, try_recv_inc shouldn't be 1K of code
[00:57:37] <acrichto> is it the TLS hit or what it does later on?
[00:58:25] <pcwalton> acrichto: it's mostly all the "mov" instructions coming from not having TBAA-struct
[00:58:27] <pcwalton> 50% of it is that
[00:58:38] <acrichto> ugh
[00:59:32] <pcwalton> acrichto: anyway, I have parallel layout redone for the new runtime and 33% of it is spent in try_recv_inc
[00:59:36] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[00:59:36] *** ChanServ sets mode: +qo brson brson
[00:59:36] <pcwalton> that's a lot of perf
[00:59:52] <acrichto> pcwalton: can you send me a profile?
[01:00:00] <acrichto> that should be super fast
[01:00:14] <pcwalton> it bottoms out at try_recv_inc
[01:00:17] <acrichto> pcwalton: is this a stream or a shared chan?
[01:00:26] <pcwalton> I can send you the instruction level profile
[01:00:45] <pcwalton> it's a stream
[01:00:53] <acrichto> that should be insanely fast
[01:01:23] <pcwalton> it's nearly 1K of code :P
[01:01:31] <pcwalton> lots of formatting, debug statements...
[01:01:42] <acrichto> I guess it depends on how much gets inlined
[01:01:51] <pcwalton> lots of drops of unsafe arcs
[01:01:54] <acrichto> we have lots of assertions still
[01:01:55] <acrichto> what!?
[01:01:57] <acrichto> no
[01:02:01] <dbaupp> https://github.com/mozilla/rust/pull/11546 r?
[01:02:01] <acrichto> that's not on any normal path
[01:02:15] <pcwalton> I guess it's all out of line but LLVM is not putting it at the end
[01:02:25] <acrichto> ugh
[01:02:39] <acrichto> that makes me sad :(
[01:03:40] <pcwalton> we need to redo our logging story, I think
[01:03:50] <pcwalton> we really need libstd to just not have any logging or assertions when compiled normally
[01:03:53] <pcwalton> the code bloat is too much
[01:05:03] <pcwalton> and it messes up LLVM's inlining heuristics
[01:05:38] <kimundi> Is make on OS X known to be flaky?
[01:05:47] <dbaupp> We'd probably need to go through and change some of the assert!()s to proper fails if they got removed in opt builds
[01:06:24] <pcwalton> I think assert! should always be on
[01:06:30] <pcwalton> but there should be a warn_unless! or something
[01:07:14] <acrichto> well we also don't trust most things in libstd right now
[01:07:23] <acrichto> I'm not sure if anything is rock-solid enough to remove asserts
[01:07:34] <pcwalton> ok, but we have no idea what the performance of rust code is like
[01:07:45] <pcwalton> it's hurting servo, we don't have accurate numbers
[01:07:49] <pcwalton> because we have asserts everywhere
[01:07:58] <pcwalton> we can leave them on while running rust tests
[01:08:23] <acrichto> we should probably have a mode of compiling libstd without asserts at the very least
[01:08:50] <dbaupp> it'd be easy enough to get a Rust compiler with assert!() and assert_eq!()  expanding to nothing, to get a baseline comparison
[01:09:20] <dbaupp> (although a proper way to do this is obviously better.)
[01:09:23] *** Quits: dherman (dherman@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: dherman)
[01:09:31] <kimundi> wait, aren't asserts used to implement safe interfaces? Removing them would introduce unsafeness
[01:10:23] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[01:10:37] * strcat sighs
[01:10:41] <strcat> reflect tests
[01:11:54] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[01:12:28] <dbaupp> strcat: btw, triemap.insert still has optmisations available without unsafe code :P
[01:12:30] <dbaupp> https://github.com/mozilla/rust/pull/11546 
[01:12:37] <dbaupp> r?
[01:13:02] <strcat> dbaupp: I want to poke at it for a bit
[01:13:13] <dbaupp> sure
[01:13:41] <dbaupp> anyway, I should've left an hour ago...
[01:13:43] * dbaupp leaves now
[01:15:35] *** Quits: dbaupp (Thunderbir@moz-6002BAEA.lns20.syd6.internode.on.net) (Ping timeout)
[01:16:31] <strcat> pcwalton: imo assert! is a bad name for what it is
[01:16:32] <strcat> maybe enforce!()
[01:16:40] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[01:16:40] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/DCK3MA
[01:16:40] <ghrust> 13rust/06auto 147bc9708 15Daniel Micay: remove reference counting headers from ~...
[01:16:40] <ghrust> 13rust/06auto 14c375bdc 15Daniel Micay: remove `borrow_offset` as ~ is now free of headers
[01:16:40] <ghrust> 13rust/06auto 1473a6c48 15Daniel Micay: add implementation of `Repr` for `~[T]`
[01:16:42] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[01:17:17] <kimundi> enforce sounds nice :P
[01:17:53] <ChrisMorgan> But "assert" is the industry standard term.
[01:19:25] <strcat> ChrisMorgan: not for code that's still there in a non-debug build
[01:20:27] <ChrisMorgan> I know that Java removes asserts by default and that Python can remove asserts, but I would have thought that it was more generally typical that asserts would run on release builds (I speak without any real knowledge of how such things are done in C/C++).
[01:22:22] <strcat> I don't think that's typically what assert means
[01:22:30] <strcat> if it's in your release builds, it's just a check, not an assert
[01:22:48] <strcat> asserts are there so you can do expensive redundant sanity checks everywhere to make debugging easy
[01:22:57] <strcat> like checking that an array is sorted in binary_search()
[01:25:30] <pcwalton> acrichto: can I change RESCHED_FREQ to 256
[01:25:32] <pcwalton> from 200
[01:25:42] <acrichto> sure
[01:25:46] <pcwalton> we shouldn't be doing division in the channel impl
[01:25:53] <acrichto> is it that high up?
[01:26:06] <pcwalton> yeah
[01:26:07] <pcwalton> it is
[01:26:14] <acrichto> I suppose that's a good sign
[01:26:18] <pcwalton> 15% of the receiving time
[01:26:19] <acrichto> that nothing else is too expensive
[01:26:28] <pcwalton> packet() is just as expensive
[01:26:35] <acrichto> packet() should be super cheap
[01:26:39] <acrichto> it's just looking at an unsafe arc
[01:26:49] <acrichto> but I didn't optimize calling it "only once" and memoizing in a loal
[01:26:50] <acrichto> local*
[01:26:52] <strcat> arcs can be significantly faster
[01:27:00] <acrichto> and LLVM may not realize that it should be not called more than once
[01:27:01] <strcat> all atomic ops are marked volatile atm...
[01:27:50] *** flaper87 is now known as flaper87|afk
[01:30:46] <pcwalton> acrichto: maybe_yield() is going to be a no-op on 1:1 right?
[01:31:25] <pcwalton> wait, it puts the task in TLS?
[01:31:34] <pcwalton> isn't it always there in 1:1 mode?
[01:32:37] <acrichto> pcwalton: it's a no-op once it hits the task itself, but it still has to load/store from TLS
[01:32:37] <aatch> The atomics API is one place that would really benefit from default arguments.
[01:32:45] <pcwalton> acrichto: just because of the M:N case?
[01:32:55] *** Joins: deens (deens@moz-A47475CE.hsd1.ca.comcast.net)
[01:32:58] <acrichto> pcwalton: we have to hit TLS to see what we are
[01:33:09] <pcwalton> so right now the actual SPSC pop doesn't even show up in the profile
[01:33:21] <pcwalton> all of the overhead is resulting from abstracting over M:N and 1:1 scheduling
[01:33:23] <acrichto> it's probably inlined
[01:33:25] <pcwalton> and that is 33% of reflow time
[01:33:30] <pcwalton> it's not inlined
[01:33:38] <pcwalton> I'm looking at the instruction level profiler
[01:33:43] <acrichto> is the overhead from the TLS hit?
[01:34:06] <pcwalton> it's just all the bookkeeping
[01:34:16] <acrichto> bookkeeping on what though?
[01:34:17] <pcwalton> there are 4 frames with tons of "mov"s in between Task::put_runtime
[01:34:22] <pcwalton> and maybe_yield
[01:34:37] *** Quits: deens (deens@moz-A47475CE.hsd1.ca.comcast.net) (Ping timeout)
[01:34:52] <pcwalton> Task::maybe_yield is a ~700 byte function
[01:35:02] <pcwalton> which does nothing but call a method through a vtable
[01:35:38] <acrichto> how is that 700 bytes?!
[01:35:44] <pcwalton> because no TBAA-struct
[01:35:45] <acrichto> is it b/c take_unwrap() can fail?
[01:35:47] <aatch> O.o
[01:35:56] <acrichto> pub fn maybe_yield(mut ~self) {       let ops = self.imp.take_unwrap(); ops.maybe_yield(self);           
[01:35:59] <acrichto> }                                    
[01:36:01] <acrichto> ugh bad paste
[01:36:04] <pcwalton> it's in libnative
[01:36:06] <acrichto> but that function is *tiny*
[01:36:08] <pcwalton> I'm using libnative
[01:36:10] <pcwalton> it's 700 bytes
[01:36:25] <pcwalton> https://gist.github.com/pcwalton/8429257
[01:36:36] <pcwalton> 575 bytes
[01:36:37] <pcwalton> sorry
[01:36:38] <acrichto> that's libstd
[01:36:40] <pcwalton> my hex-decimal version
[01:36:49] <pcwalton> oh
[01:37:00] <acrichto> that is literally just a wall of movs
[01:37:04] <pcwalton> yes
[01:37:09] <acrichto> that should be like 2 instructions
[01:37:18] <pcwalton> 50% of the performance is gone in the movs
[01:37:19] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[01:37:32] <acrichto> they're all unaligned
[01:37:37] <acrichto> movw                21(%rax), %cx
[01:37:37] <pcwalton> yeah
[01:37:43] <acrichto> what in the world is going on here
[01:38:05] <pcwalton> I think adt was done wrong
[01:38:11] <pcwalton> it unaligns too much
[01:38:19] <pcwalton> the discriminant is not always the same size
[01:38:35] <acrichto> what's the discriminant here though?
[01:38:35] <pcwalton> as a result enums explode into movs
[01:38:44] <pcwalton> there's a take_unwrap
[01:38:55] <acrichto> oh hm you're right
[01:38:57] <acrichto> that would make sense
[01:39:08] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[01:39:10] <acrichto> lotsa movement in a take_unwrap()
[01:39:35] * pcwalton sighs
[01:39:57] <pcwalton> that should be like 5 instructions, maybe 10
[01:40:22] <acrichto> good god
[01:40:23] <acrichto> this IR
[01:40:36] <acrichto> https://gist.github.com/8429290
[01:40:49] <acrichto> foo.rs is at the bottom
[01:41:16] <pcwalton> what on earth
[01:41:31] <acrichto> that's with --opt-level=3
[01:41:31] <aatch> why is there a alloca of 7 bytes with align 1?
[01:41:41] <acrichto> ?!?!?!?!
[01:41:48] <pcwalton> probably padding.
[01:42:01] <pcwalton> adt really needs to be audited
[01:42:03] *** Joins: dbaupp (dbaupp@moz-FEA00D24.pa.nsw.optusnet.com.au)
[01:42:34] <dbaupp> Yurume: ping
[01:42:38] <pcwalton> also there's so much fmt in there
[01:42:43] <pcwalton> acrichto: this is what I'm saying
[01:42:48] <pcwalton> fmt appears everywhere because of the asserts
[01:42:55] <acrichto> the pre-opt IR is beautiful
[01:43:05] *** Quits: gwty (gwtypc@C24C93D9.918BC1CC.137C914F.IP) (Connection reset by peer)
[01:43:08] <acrichto> it must be the take_unwrap()
[01:43:13] <acrichto> there's no way that's all fmt
[01:43:16] <acrichto> that's impossible
[01:43:40] <acrichto> https://gist.github.com/pcwalton/8429257#file-gistfile1-asm-L94-L105
[01:43:43] <acrichto> pcwalton: ^ that's fmt
[01:43:44] <acrichto> that's it
[01:43:45] <bjz> r? https://github.com/mozilla/rust/pull/11548
[01:43:49] <bjz> acrichto: ^
[01:43:51] <acrichto> fmt is tiny in that function
[01:43:55] <pcwalton> yeah
[01:43:57] <pcwalton> ok
[01:44:14] <acrichto> pcwalton: it's also off the fast path
[01:44:25] <acrichto> like debugging may be bad, but asserts should actually be good
[01:44:28] <acrichto> and fmt in general is "not that bad"
[01:45:38] <acrichto> pcwalton: I'm opening an issue
[01:45:41] <pcwalton> ok
[01:46:08] *** Joins: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP)
[01:47:35] *** Quits: dbaupp (dbaupp@moz-FEA00D24.pa.nsw.optusnet.com.au) (Client exited)
[01:49:05] *** Joins: dbaupp (dbaupp@moz-FEA00D24.pa.nsw.optusnet.com.au)
[01:49:21] *** Quits: dbaupp (dbaupp@moz-FEA00D24.pa.nsw.optusnet.com.au) (Client exited)
[01:49:43] <bjz> acrichto: sorry - had to rebase
[01:51:47] <acrichto> pcwalton: scumbag me thinking Option<~Trait> is fast
[01:51:50] <acrichto> pcwalton: https://github.com/mozilla/rust/issues/11549
[01:51:54] <acrichto> *1500* lines of IR
[01:51:59] <acrichto> for slot.get_mut_ref().foo();
[01:52:02] <acrichto> bjz: looking
[01:52:40] <pcwalton> acrichto: thanks for filing that
[01:52:51] <acrichto> %tmp.sroa.6.i.i.i.i.i = alloca [7 x i8], align 1
[01:52:55] <acrichto> thanks llvm
[01:53:26] <acrichto> this is so terrifying
[01:53:28] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:55:15] *** Quits: doomlord_ (servitor@moz-CA917A47.range86-184.btcentralplus.com) (Ping timeout)
[01:56:18] <acrichto> pcwalton: omg I don't think this is an enum thing
[01:56:20] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[01:56:26] <acrichto> if you remove the fail!() it's perfect
[01:56:35] <acrichto> I think fail!() is getting inlined
[01:56:42] <pcwalton> hmmm
[01:56:50] <acrichto> trying something
[01:57:56] <pcwalton> yeah, that's what it looks like
[01:57:59] <pcwalton> we should no inline that :)
[01:58:49] <acrichto> yeah trying that
[01:59:19] <acrichto> ah
[01:59:21] <acrichto> it's beautiful
[01:59:50] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[01:59:56] <pcwalton> great
[02:00:07] <pcwalton> that doesn't explain the maybe_yield thing
[02:00:39] <acrichto> can you recompile with inline(never) locally and collect another profile?
[02:00:48] <pcwalton> I can try, yeah
[02:03:50] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: Textual IRC Client: www.textualapp.com)
[02:03:55] <acrichto> pcwalton: https://github.com/mozilla/rust/pull/11550
[02:04:02] <aatch> acrichto, `%tmp.i.i.sroa.4.i.i = alloca [23 x i8], align 1` mine's worse, apparently
[02:04:11] <acrichto> :( :( :(
[02:04:18] <acrichto> I *think* that's just tbaa.struct
[02:04:24] <acrichto> we just saw the worst of it once everything was inlined
[02:05:23] <aatch> i'm still concerned about it outputting unaligned movs though...
[02:05:30] <strcat> aatch: I don't think we output any tbaa.struct info?
[02:05:35] <strcat> er
[02:05:37] <strcat> acrichto: 
[02:05:47] <acrichto> strcat: yeah that's a big problem
[02:05:58] <acrichto> oh sry I mean that's because of the *omission* of tbaa.struct
[02:06:01] <strcat> ah
[02:06:10] <acrichto> as in the discriminant is u8
[02:06:18] <acrichto> but the values make the alignment higher, so there's 7 bytes of padding
[02:06:53] <aatch> acrichto, it's odd though, that's from the same code that you posted, except not through a mutable pointer.
[02:07:32] <acrichto> weird
[02:07:37] <aatch> Same thing if I use the exact code as well.
[02:08:12] <aatch> Though I am running a slightly older version, did Option get updated to use repr(u8)?
[02:09:03] <acrichto> it's just whatever the default is
[02:09:07] <acrichto> "the smallest it can be"
[02:11:22] <acrichto> pcwalton: strcat: aatch: https://github.com/mozilla/rust/issues/11551
[02:11:25] <aatch> Eh, whatever. We really need TBAA...
[02:11:30] <strcat> ugh debug-info broke
[02:11:32] <acrichto> it's not a solution for tbaa.struct
[02:11:35] <acrichto> but it's a good interim solution
[02:11:38] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[02:11:38] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ba3c743 to 14dd8b011: 02http://git.io/N3iJvQ
[02:11:38] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[02:11:38] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:11:38] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Hjmvxg
[02:11:39] <ghrust> 13rust/06auto 14dd95576 15Alex Crichton: Allow more "error" values in try_recv()...
[02:11:39] <ghrust> 13rust/06auto 147bc1b26 15bors: auto merge of #11112 : alexcrichton/rust/issue-11087, r=brson...
[02:11:39] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:11:45] <pcwalton> acrichto: yeah, I agree
[02:13:43] <strcat> acrichto: hm, should I remove the special cases for ~@ from debug info or make them identical to ~?
[02:13:54] <aatch> What about putting the discriminant at the end?
[02:14:23] <aatch> Then letting LLVM deal with the alignment
[02:14:25] <acrichto> strcat: seems correct to me yeah b/c ~ has only one repr now
[02:14:36] <acrichto> aatch: hmm good point, I think there's some weird issues with statics though?
[02:14:39] <acrichto> I'll add a comment
[02:14:44] <strcat> acrichto: removing them or changing them to the same thing? ;p
[02:15:01] <strcat> hm
[02:15:08] <acrichto> oh I dunno how debug info works
[02:15:22] <acrichto> I guess there was special casing for managed-unique
[02:15:26] <acrichto> and that should probably all get removed now
[02:15:34] <aatch> acrichto, I vaguely recall somebody saying something about a problem with putting the discriminant at the end.
[02:15:50] <aatch> Not sure if was legitimate or not though.
[02:15:56] <acrichto> aatch: https://github.com/mozilla/rust/issues/11551#issuecomment-32328868
[02:16:14] <strcat> hm
[02:16:35] *** Quits: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com) (Quit: pcwalton)
[02:18:10] <strcat> I did actually update it...
[02:18:18] <strcat> maybe the tests are just wrong? *shrug*
[02:19:47] *** Quits: TimAbraldes (quassel@125EF623.B2666F0E.66399531.IP) (Connection reset by peer)
[02:20:31] *** Joins: ktt3ja (ktt3ja@moz-515C1363.hsd1.va.comcast.net)
[02:27:45] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:29:30] *** kimundi is now known as zz_kimundi
[02:30:03] *** Joins: dbaupp (Thunderbir@DF3B07E7.D5A1DCF.37681C44.IP)
[02:31:51] <strcat> ughhh debug info
[02:43:09] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[02:43:14] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[02:45:43] <strcat> acrichto: hm, I don't really get how we inline that ;s
[02:46:01] <strcat> not marked #[inline] right? and it has -> ! which should mark it noreturn
[02:46:17] <strcat> I can't even get LLVM to inline '#[inline] fn foo() -> ! { abort() }'
[02:46:24] <strcat> since it weights noreturn so much
[02:46:42] <acrichto> dunno
[02:46:43] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[02:46:43] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/WQBclw
[02:46:43] <ghrust> 13rust/06auto 147abac04 15Florian Hahn: Replace C types with Rust types in libstd, closes #7313
[02:46:43] <ghrust> 13rust/06auto 149130d86 15bors: auto merge of #10943 : fhahn/rust/issue-7313-replace-c-types, r=brson...
[02:46:43] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[02:46:47] <strcat> maybe we fail to mark it noreturn
[02:46:48] <acrichto> might have to do with all the generics
[02:46:54] <acrichto> it's -> !
[02:46:57] <strcat> ah right generics inline it into the crate
[02:47:02] <strcat> acrichto: right but I mean the LLVM attribute
[02:47:07] <dbaupp> maybe https://github.com/mozilla/rust/pull/11538 fixes it?
[02:47:12] <dbaupp> (the noreturns)
[02:47:31] <acrichto> dbaupp: those were mostly meant for extern fns
[02:47:43] <acrichto> strcat: we should mark -> ! with noreturn right now
[02:47:46] <strcat> acrichto: can you check if it's noreturn in the pre-optimized IR?
[02:47:46] <acrichto> on rust fns
[02:47:52] <strcat> acrichto: I know, I added that ;p
[02:47:54] <strcat> but maybe it's wrong
[02:48:14] <strcat> acrichto: afaik LLVM can't inline a noreturn function that's not alwaysinline *shrug*
[02:48:27] <acrichto> strcat: it is indee dnoreturn
[02:48:31] <strcat> hm
[02:48:39] <acrichto> attributes #5 = { noreturn uwtable }
[02:49:05] <acrichto> wait what
[02:49:19] <acrichto> _ZN2rt6unwind12begin_unwind4anon7expr_fn4ahafE
[02:49:22] <acrichto> oh that's a closure
[02:49:25] <acrichto> b/c that had inlinehint
[02:49:27] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[02:49:50] <acrichto> yeah the main one has #5 
[02:49:52] <acrichto> up above
[02:51:01] <strcat> acrichto: ah it seems the LLVM upgrade might have changed this...
[02:51:13] <strcat> acrichto: what if it's #[cold]? that'd be better than just not inlined
[02:51:21] <strcat> then LLVM can order the blocks right for branch prediction
[02:51:46] <aatch> Do we have #[cold]?
[02:51:53] <dbaupp> yes
[02:51:54] <strcat> yes
[02:51:57] * strcat added that too ;p
[02:52:00] <aatch> Awesome.
[02:52:12] <strcat> a cold function weights any branch it's in as cold
[02:53:04] <acrichto> strcat: is there really any case we'd want to inline begin_unwind?
[02:53:13] <acrichto> failure is "super slow"
[02:53:15] <strcat> acrichto: well cold is more information
[02:53:20] <acrichto> really?
[02:53:22] <strcat> it weights the branches right in addition to making it not inline
[02:53:27] <acrichto> but it's already noreturn?
[02:53:28] <strcat> well, unlikely to inline
[02:53:38] <strcat> acrichto: well apparently noreturn doesn't work as it used to
[02:53:41] <strcat> ;p
[02:53:43] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[02:54:01] <strcat> acrichto: anyway I guess marking it that way is fine
[02:54:08] <strcat> it's just strange that LLVM isn't figuring out the right thing itself
[02:54:12] <strcat> when it has a lot of hints already
[02:54:31] <acrichto> dunno
[02:55:06] <aatch> Hmm, what does address_insignificant mean at a crate level?
[02:55:26] <dbaupp> aatch: nothing?
[02:55:37] <dbaupp> a little like #[mutable_doc]; on a module
[02:55:40] <strcat> aatch: it will become obsolete if we mark all globals that way anyway
[02:56:05] <aatch> I was just looking at the list inside lint.rs.
[02:56:10] <acrichto> strcat: weird, it still inlined it with #[cold]
[02:56:17] <strcat> ;[
[02:56:30] <strcat> LLVM is dumb sometimes
[02:56:37] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[02:56:37] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 149130d86 to 14dd8b011: 02http://git.io/N3iJvQ
[02:56:37] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[02:56:37] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[02:56:38] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/Sotjdg
[02:56:38] <ghrust> 13rust/06auto 146b5e63f 15Huon Wilson: std::trie: add benchmarks for insert.
[02:56:38] <ghrust> 13rust/06auto 14e1ebdb8 15Huon Wilson: std::trie: optimise insert slightly....
[02:56:38] <ghrust> 13rust/06auto 14e6d9214 15bors: auto merge of #11546 : huonw/rust/trie-insert, r=alexcrichton...
[02:56:40] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[02:56:44] <acrichto> attributes #5 = { cold noreturn uwtable }                                                                      
[02:56:49] <acrichto> those are the attributes on it
[02:57:09] <strcat> acrichto: imo they broke something about inlining
[02:57:36] <acrichto> nose goes to update llvm!
[02:57:38] * acrichto touches nose
[02:58:07] <strcat> yeah it's different now
[02:58:09] <strcat> ;s
[02:59:49] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[03:00:32] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[03:00:42] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:00:59] <strcat> acrichto: debug-info fixed... tests were wrong ;p
[03:01:04] * strcat was looking in the code ;[
[03:01:11] <strcat> forgot I already fixed it at first
[03:01:12] <acrichto> how so?
[03:01:26] <strcat> acrichto: instead of unique->value they did unique.val->value
[03:01:34] <strcat> where val was to index into the box header
[03:01:45] <acrichto> ah
[03:01:59] * acrichto keeps wishing he had debug-info
[03:02:53] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:03:28] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:03:28] *** ChanServ sets mode: +qo brson brson
[03:03:37] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[03:03:41] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[03:04:03] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[03:05:12] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:05:15] *** Joins: a_m0d|home (a_m0d@moz-322A4DE4.acanac.net)
[03:05:49] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[03:06:31] *** Quits: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP) (Ping timeout)
[03:08:46] *** Joins: brson (brson@981AA104.E81F12CD.76F66111.IP)
[03:08:46] *** ChanServ sets mode: +qo brson brson
[03:11:01] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[03:15:12] *** Quits: zz_kimundi (kimundi@moz-5CD33A8E.dip0.t-ipconnect.de) (Ping timeout)
[03:16:17] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[03:18:33] *** Joins: zz_kimundi (kimundi@moz-FAACE8A8.dip0.t-ipconnect.de)
[03:18:35] *** zz_kimundi is now known as kimundi
[03:26:49] *** a_m0d|home is now known as a_m0d
[03:27:30] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[03:27:31] *** ChanServ sets mode: +ao pcwalton pcwalton
[03:29:46] *** Quits: a_m0d (a_m0d@moz-322A4DE4.acanac.net) (Quit: Leaving.)
[03:30:39] *** Joins: a_m0d1 (a_m0d@moz-322A4DE4.acanac.net)
[03:31:56] *** Parts: a_m0d1 (a_m0d@moz-322A4DE4.acanac.net) ()
[03:38:08] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[03:39:53] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[03:46:27] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[03:47:14] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:47:39] *** Joins: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP)
[03:52:34] *** Quits: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP) (Ping timeout)
[03:53:38] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[03:53:59] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[03:54:25] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[03:55:43] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[04:00:56] *** Quits: brson (brson@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[04:06:46] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:06:47] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Sotjdg
[04:06:47] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:07:57] *** Joins: doomlord_ (servitor@moz-CA917A47.range86-184.btcentralplus.com)
[04:11:45] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:11:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/z-gKcA
[04:11:45] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:11:46] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[04:14:35] *** Joins: jdm (jdm@moz-838161A9.dsl.teksavvy.com)
[04:15:11] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[04:15:50] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[04:16:41] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:16:41] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/rkGB4Q
[04:16:41] <ghrust> 13rust/06auto 140e885e4 15Daniel Micay: remove reference counting headers from ~...
[04:16:41] <ghrust> 13rust/06auto 146809b17 15Daniel Micay: remove `borrow_offset` as ~ is now free of headers
[04:16:41] <ghrust> 13rust/06auto 1477758f0 15Daniel Micay: add implementation of `Repr` for `~[T]`
[04:16:43] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:24:28] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[04:25:14] <bjz> pcwalton: hey, I think I take back what I said about the operator overloading
[04:25:25] <bjz> :)
[04:25:39] <pcwalton> well, I think you may have been right about the ability to shadow being nice
[04:25:48] <pcwalton> it just seems like a lot of work to get it to work and could be added backwards compatibly
[04:26:35] <bjz> I'm constructing algebraic structures that are implemented on the type T
[04:27:51] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[04:28:19] <bjz> so say, a Magma matched with the `+` operator would be: trait AddMagma: Add<Self, Self> {} impl<T: Add<Self, Self> AddMagama for T {}
[04:28:32] <bjz> http://en.wikipedia.org/wiki/Magma_%28algebra%29#Definition
[04:30:32] <bjz> then I would have a trait AssociativeAdd
[04:30:37] <bjz> that would be required by AddSemigroup
[04:31:01] <bjz> AssociativeAdd could have some things to help you create unit tests for associativity
[04:31:31] <bjz> pcwalton: does that kinda make sense?
[04:31:44] <pcwalton> yeah, that makes sense to me
[04:34:56] * bjz is excited
[04:35:10] <bjz> :)
[04:35:30] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[04:35:46] <Yurume> I like the name Magma
[04:36:26] <bjz> heh, they have weird names in mathematics
[04:37:51] <bjz> fields, monoids, rings, groups, lattices
[04:38:18] <dbaupp> what're you talking about? they're all perfectly sensible :P
[04:39:40] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:39:58] <bjz> but the fundamental important thing is that they name specific a relationships between sets of things - it would be good if those names 'fell out' once you defined the necessary relationships
[04:40:53] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:41:09] <bjz> this has probably been done many times before, but it's kinda neat to work this stuff out
[04:43:23] * bjz loves the fact that `T: Mul<T, T>` describes closure over multiplication
[04:44:56] <bjz> or is it 'closure under multiplication'...
[04:45:03] * bjz never knows
[04:49:13] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[04:55:10] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[04:55:33] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[04:56:42] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:56:42] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FXU0pg
[04:56:42] <ghrust> 13rust/06auto 14431e2bb 15b1nd: Removed redundant code, improve performance...
[04:56:42] <ghrust> 13rust/06auto 14e063e96 15bors: auto merge of #11547 : b1nd/rust/rust-doc, r=alexcrichton...
[04:56:43] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:56:44] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[04:56:44] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b7f7fe1 to 14e6d9214: 02http://git.io/N3iJvQ
[04:56:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[05:10:40] *** nrc is now known as nrc|afk
[05:30:52] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[05:33:15] <eddyb> two PRs merged the first try? I guess I should focus on less-than-1k-changed-lines in the future :P
[05:33:45] <dbaupp> eddyb: \o/
[05:34:02] <dbaupp> merge one line at a time, and nothing will ever bounce
[05:34:30] <eddyb> nmatsakis: ping
[05:37:15] <eddyb> dbaupp: I'm anxious, reading this https://github.com/mozilla/rust/wiki/Meeting-weekly-2014-01-14
[05:37:52] <eddyb> "Friend of the tree" brson is too nice :">
[05:39:13] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[05:41:07] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[05:41:19] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[05:42:28] <eddyb> dbaupp: meh, I've delayed default type arguments because I told nmatsakis about my env param removal
[05:42:39] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[05:46:46] <eddyb> dbaupp: I guess I can work on Many while people are asleep. I've drafted it in my head, should be 10-20 lines of code
[05:47:14] <eddyb> worst part is remembering macro syntax and figuring which order (ptr, vtable) &Trait is layed in
[05:48:32] <Luqman> eddyb: i always end up looking in librustc/back/abi.rs :P
[05:49:10] <eddyb> Luqman: cool, it's right in my face in there :D
[05:53:09] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[05:53:09] *** ChanServ sets mode: +ao dherman dherman
[06:04:21] *** Joins: glaebhoerl (glaebhoerl@moz-3590251D.kabelnet.hu)
[06:12:53] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:13:29] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[06:14:27] *** Joins: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net)
[06:14:36] <tikue> is the iterator renaming still open to bikeshed?
[06:14:51] <eddyb> traits are not types... dammit
[06:15:26] <eddyb> so I can't have a function generic over a Trait returning &'a Trait
[06:16:03] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:16:21] <tikue> I like almost all of the iterator name changes except I think Pairs is misleading for key-value identifiers. I think Entries is better
[06:16:44] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[06:16:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/FXU0pg
[06:16:44] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[06:17:21] <tikue> entries or records or something, but i think pair de-emphasizes the key-value relationship
[06:19:01] <eddyb> KV
[06:19:54] <tikue> ehh
[06:20:00] <tikue> i'd probably prefer pairs to KV haha
[06:20:43] <sfackler> Java uses Entry fwiw
[06:20:52] <tikue> yeah, that's what made me think of it
[06:21:05] <tikue> I commented on the pr
[06:21:41] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[06:21:41] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/xgcSXw
[06:21:41] <ghrust> 13rust/06auto 140e885e4 15Daniel Micay: remove reference counting headers from ~...
[06:21:41] <ghrust> 13rust/06auto 146809b17 15Daniel Micay: remove `borrow_offset` as ~ is now free of headers
[06:21:42] <ghrust> 13rust/06auto 1477758f0 15Daniel Micay: add implementation of `Repr` for `~[T]`
[06:21:44] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[06:22:09] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:25:10] <dbaupp> tikue: you can let it land and then change it later?
[06:25:51] <tikue> dbaupp: it hasn't been r+'d yet; there's yet time to discuss it
[06:25:52] <eddyb> oooh, that might actually cut down on the memory usage of rustc
[06:27:04] <sfackler> acrichto: wrt syntax extension tests, I think the best option after trying a couple of things is to just not run these tests at stage1
[06:27:30] <acrichto> sfackler: I would be ok with that, it'll make development of them pretty hard :\
[06:27:41] <acrichto> but alas, another problem for another time
[06:27:45] <sfackler> yeah
[06:28:01] <sfackler> maybe once we have a snapshot that supports all of it we can figure something out
[06:28:13] <sfackler> but I think it's basically unworkable without that
[06:28:14] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[06:29:00] <acrichto> fine by me
[06:29:25] <sfackler> stage-gating tests doesn't exist yet, right?
[06:30:00] <acrichto> not right now, no
[06:30:09] <acrichto> you can edit the makefiles to do something though
[06:31:26] <dbaupp> eddyb: not much
[06:31:28] <sfackler> I think I can either leave it in rpass and add a new header property or move it to a new compiletest category that doesn't run at stage1
[06:31:37] <dbaupp> eddyb: it's only removing the headers from ~[] and ~
[06:31:51] <dbaupp> eddyb: (so it will make it slightly smaller)
[06:32:36] <acrichto> dbaupp: I had a fun time moving around mutable pointers when I wrote my splay tree, but I ended up being able to splay() in a loop after lots of fighting with borrowck
[06:33:16] <dbaupp> acrichto: it's seems obvious in hindsight
[06:33:36] <dbaupp> but I would've taken quite a while to happen upon it myself
[06:33:38] <dbaupp> thanks
[06:33:40] <acrichto> I completely forgot how to do it and I wrestled with your example before I finally looked at my previous code
[06:34:00] <acrichto> I still find it amazing that I could safely write a splay tree
[06:34:05] <acrichto> it's just slow b/c of zeros on moves :(
[06:34:07] <dbaupp> completely safely?
[06:34:16] <acrichto> 0 unsafe blocks
[06:34:19] <dbaupp> <3
[06:34:27] <acrichto> it doesn't have iterators though
[06:34:36] <dbaupp> oh, the mutable one may be tricky
[06:34:49] <acrichto> the mutable iterator is fine, but an immutable iterator I think is impossible
[06:34:59] <acrichto> not without parent pointers at least
[06:35:24] <dbaupp> oh, really?
[06:35:37] <dbaupp> Can't you maintain a stack of parent nodes an operate on the end?
[06:35:51] <acrichto> you mutate the tree on a lookup
[06:35:55] * dbaupp checks to see how a splay tree actually works
[06:35:56] <dbaupp> oh
[06:36:00] <tikue> wait, acrichto, your splay tree uses 0 unsafe code? wowowow
[06:36:01] <tikue> impressive
[06:36:17] <acrichto> ah sry, there is one unsafe block
[06:36:26] <acrichto> but that is supporting "fn find(&self)"
[06:36:31] <tikue> i tried doing a splay tree sometime in september and quickly determined it wasn't worth the effort, because even if i finished it'd be too ugly to be proud of
[06:36:36] <acrichto> https://github.com/alexcrichton/rs-splay/blob/master/lib.rs
[06:36:55] <dbaupp> ah, should iteration really mutate the tree? it doesn't really count as a look up does it?
[06:36:59] <acrichto> the only other unsafe block was a half-hearted attempt to getbetter performance, it wasn't necessary
[06:37:09] <acrichto> dbaupp: iteration doesn't, but you can find() while iterating
[06:37:24] <acrichto> the number of nodes in the tree will remain the same
[06:37:25] <dbaupp> oh
[06:37:34] <acrichto> so in theory if you had a pointer to a node, it would wrk
[06:37:35] <dbaupp> because you've used that unsafe block?
[06:37:39] <acrichto> yeah
[06:37:51] <acrichto> it could be "fn find(&mut self)"
[06:37:51] <dbaupp> ... maybe you shouldn't use it and then you're fixed!
[06:37:55] <acrichto> but sadly that isn't too useful
[06:38:02] <acrichto> yeah lol
[06:38:07] <acrichto> it does support move iterators
[06:38:15] <acrichto> which don't use a stack at all
[06:38:17] <dbaupp> extra::LRUCache doesn't have a find(&self) iirc
[06:38:26] <acrichto> interesting!
[06:38:29] <acrichto> maybe I should just throw it out then
[06:38:39] <acrichto> although I woud rather use Rc + Weak for the nodes
[06:38:49] <acrichto> well no not even that...
[06:38:51] <dbaupp> (as a random data point; but that wasn't written by a super-experienced ruster.)
[06:38:56] <acrichto> having a parent pointer seems like a waste of space
[06:39:04] <dbaupp> LRUCache was ktt3ja's first patch, iirc.
[06:39:27] <dbaupp> Wouldn't the Rc thing always have strong count == 1?
[06:39:33] <sfackler> acrichto: find(&mut self) makes sense to me since it's a splay tree, and the whole *point* of it is that lookups mutate it
[06:39:38] <eddyb> we need a NonStrong Rc :P
[06:39:51] <acrichto> sfackler: although in theory you can lookup multiple things in a splay tree at once
[06:40:07] *** flaper87|afk is now known as flaper87
[06:40:07] <acrichto> sfackler: the nodes themselves never move, it's just the structure of the tree that changes
[06:40:12] <sfackler> yeah, that's true
[06:40:24] <dbaupp> eddyb: why? is the performance/memory difference large enough to justify it?
[06:40:24] <eddyb> acrichto: in my experience, a parent pointer gets you constant-size iterators - but I have close to 0 context here
[06:40:49] <acrichto> eddyb: it would indeed
[06:40:51] <eddyb> dbaupp: not really. *however* I'd use a special Rc for the AST, with only one byte of ref-count, tucked at the end
[06:41:00] <acrichto> with Rc + weak + parent pointers I could do it safely
[06:41:29] <eddyb> unsafe parent pointers are safe, it just means more cost on the designer
[06:41:44] <acrichto> eh I'd just use Rc + weak for less unsafe code
[06:41:51] <acrichto> I'm more concerned about the size bloat of nodes
[06:41:58] <acrichto> not that anyone's using the library anyway :P
[06:42:21] <acrichto> I was thinking of eventually replacing TreeMap with it
[06:42:30] <tikue> what's it use now? rb tree?
[06:42:34] <acrichto> but I don't think I can match the performance until we don't 0 out moves
[06:42:40] <strcat> acrichto: b-tree would be best
[06:42:48] <acrichto> I'm not exactly sure what it is, but it's some flavor of a balancing tree
[06:43:08] <acrichto> strcat: hehe, when you come frm cmu you're brainwashed that splay trees are everything
[06:43:22] <acrichto> (which is not a good thing)
[06:43:39] * strcat has used google's C++ b-tree for crypto puzzles ;p
[06:44:06] <strcat> acrichto: https://code.google.com/p/cpp-btree/wiki/UsageInstructions#Memory_usage_comparison
[06:44:36] <tikue> strcat: where's the splay tree :P
[06:44:46] <acrichto> crazy
[06:44:49] <strcat> you can find another comparison with a splay tree ;p
[06:45:13] <strcat> acrichto: b-trees are really cool.... because they were designed for disks by letting you choose the block size
[06:45:21] <strcat> so caches love them ;p
[06:45:32] <acrichto> I've found that BSTs in generl are like the coolest things
[06:45:37] <acrichto> there's like a billion things you can do with them
[06:45:44] <strcat> r-trees!
[06:45:55] <strcat> not that I'd have a real use for one
[06:47:13] <sfackler> rb trees are interesting to write
[06:47:25] <sfackler> especially since no one talks about deletion
[06:47:28] <sfackler> especially top down
[06:47:40] <strcat> sfackler: well, if you write them the modern way it's easy ;p
[06:47:42] <sfackler> which is weird, because it's really pretty straightforward
[06:48:10] <sfackler> strcat: what's the modern way?
[06:48:11] <strcat> sfackler: http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
[06:49:01] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:49:22] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[06:50:02] <sfackler> strcat: that's pretty cool. they complain about the lack of discussion of deltion there too!
[06:50:30] <sfackler> I think I made it a bit harder on myself by insisting on no parent pointers and no recursion
[06:50:36] <acrichto> strcat: r? https://github.com/mozilla/rust/pull/11550
[06:51:08] <dbaupp> should they be #[cold] as well?
[06:51:08] <strcat> sfackler: by the co-creator of the original rb-tree too if you didn't notice that ;p
[06:51:22] <strcat> dbaupp: if they're the entry point
[06:51:24] <acrichto> dbaupp: it didn't end up helping
[06:51:29] <strcat> for failure
[06:51:39] <strcat> acrichto: it helps by weighting any branches they're in as cold
[06:51:44] <strcat> if they're actually the entry point
[06:51:46] <dbaupp> acrichto: for inlining maybe not, but in general it'll place the blocks better
[06:52:11] <acrichto> strcat: updated
[06:52:11] <strcat> although I think noreturn already weights it anyway...
[06:52:19] <strcat> better to mark it cold though
[06:52:24] <strcat> noreturn is a dumb heuristic ;p
[06:52:57] <strcat> acrichto: the sad part of cold is that it doesn't become branch weight metadata on inlining
[06:53:02] <strcat> I guess just an oversight
[06:53:08] <strcat> and anyway, I don't understand why it *does* inline
[06:53:12] <strcat> LLVM is dumb ;p
[06:53:25] <acrichto> I've wondered recently if it would be possibel for LLVm to inline part of a function bot not the rest
[06:53:34] <acrichto> things like inlining the "fast path" but not inlining the "slow path"
[06:53:34] <strcat> acrichto: yes, there's a partial inline pass
[06:53:36] <strcat> not on by default
[06:53:39] <acrichto> really?!
[06:53:42] <strcat> it's really terrible
[06:53:43] <acrichto> that's pretty crazy
[06:53:45] <strcat> acrichto: gcc can do it well
[06:53:53] <acrichto> that's awesome
[06:53:56] <acrichto> compilers are crazy man
[06:54:02] <strcat> acrichto: http://llvm.org/docs/Passes.html#partial-inliner-partial-inliner
[06:54:03] <strcat> ;p
[06:54:03] <acrichto> *optimizing* compilers are crazy
[06:54:12] <strcat> acrichto: well they're super smart in some ways
[06:54:15] <strcat> and super dumb in others
[06:54:19] <acrichto> I still to this day think loop rotations are the craziest things
[06:54:33] <strcat> they were talking about disabling loop rotation in LLVM ;s
[06:54:43] <strcat> the heuristics are bad
[06:54:51] <acrichto> that's unfortunate :(
[06:54:51] <dbaupp> googling loop rotations turns up http://en.wikipedia.org/wiki/Figure_skating_jumps ...
[06:54:57] <acrichto> hahaha
[06:55:34] <strcat> acrichto: http://llvm.org/docs/Passes.html#gvn-global-value-numbering oh and this thing
[06:55:39] <strcat> eats so much memory.
[06:55:40] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:55:50] <strcat> if you wonder why LLVM uses a lot of memory to compile rust
[06:55:52] <strcat> that.
[06:55:55] <acrichto> brb, train arriving
[06:56:07] <strcat> damn this failed again :|
[06:56:09] <strcat> passed locally
[06:56:19] <strcat> remote object '/data/tmp/tmp/check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu-extra-metrics.json' does not exist
[06:56:21] <strcat> waaaat
[06:56:38] * strcat has bad luck
[07:01:29] *** Quits: jdm (jdm@moz-838161A9.dsl.teksavvy.com) (Quit: Lost terminal)
[07:01:55] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:01:55] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/_Ygl9w
[07:01:55] <ghrust> 13rust/06auto 140e885e4 15Daniel Micay: remove reference counting headers from ~...
[07:01:55] <ghrust> 13rust/06auto 146809b17 15Daniel Micay: remove `borrow_offset` as ~ is now free of headers
[07:01:55] <ghrust> 13rust/06auto 1477758f0 15Daniel Micay: add implementation of `Repr` for `~[T]`
[07:01:57] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:02:15] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:12:22] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[07:22:54] <eddyb> let's nullify zero_1kb without LTO :D
[07:25:07] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[07:25:16] *** Quits: dbaupp (Thunderbir@DF3B07E7.D5A1DCF.37681C44.IP) (Ping timeout)
[07:26:06] <eddyb> are malloc/free calls indirect intentionally?
[07:26:40] <eddyb> exchange_free_ (which is the lang item) calls exchange_free which calls free, none of them do anything more
[07:27:59] <eddyb> acrichto: how do I run check-stage1-std benchmarks-only?
[07:28:12] <acrichto> make check-stage1-std
[07:28:15] <acrichto> kill the test run
[07:28:19] <acrichto> and then run the binary
[07:28:20] <acrichto> :D
[07:28:26] <acrichto> (not sure what the makefile variable is)
[07:28:42] <eddyb> okay, I've thought of that myself, thanks
[07:30:40] <eddyb> acrichto: I'm thinking inlining malloc/free allows LLVM to elide our abort (maybe) and do better in aliasing
[07:30:57] <eddyb> maybe this will fix the aliasing issue with ~[T]
[07:31:15] <acrichto> nice!
[07:31:53] <eddyb> oooh, exchange_free is like that for #[cfg(test)]
[07:31:56] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[07:33:23] <eddyb> can I forge Makefile to use hashes instead of timestamps?
[07:33:26] <eddyb> *force
[07:33:36] <strcat> eddyb: yes they are like that intentionally
[07:33:40] <strcat> from segmented stacks
[07:33:42] <strcat> can be removed now
[07:33:55] <strcat> acrichto: well I compiled rust with libnative...
[07:33:58] <strcat> lets see if rusti works
[07:34:03] <strcat> after I make a new root
[07:34:11] <eddyb> strcat: still required because lang items aren't present for tests
[07:34:29] <strcat> eddyb: what tests it?
[07:35:20] <strcat> ugh it uses the wrong prefix though
[07:35:28] * strcat shrugs
[07:36:58] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[07:37:46] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[07:38:01] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[07:39:22] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:39:25] <strcat> rusti: 2
[07:39:25] -rusti- /usr/local/bin/irc.sh: 12: /usr/local/bin/irc.sh: rustc: not found
[07:39:26] -rusti- /usr/local/bin/irc.sh: 7: /usr/local/bin/irc.sh: rustc: not found
[07:39:26] -rusti- application terminated with error code 127
[07:39:29] <strcat> heh
[07:39:30] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[07:39:39] *** Quits: matthewbot (user@moz-C6814817.ga.at.cox.net) (Client exited)
[07:39:58] <eddyb> strcat: I mean, stdtest contains most std code, but it links against libstd (called "realstd" in the code) and it uses lang items from there
[07:39:58] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[07:41:00] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[07:41:01] <strcat> rusti: 2
[07:41:02] -rusti- <anon>:5:1: 5:85 warning: code is never used: `version`, #[warn(dead_code)] on by default
[07:41:02] -rusti- <anon>:5 static version: &'static str = "rustc 0.10-pre (db7b9a3 2014-01-15 02:09:57 -0500)";
[07:41:05] -rusti-          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[07:41:08] -rusti- 2
[07:41:10] <eddyb> rt::global_heap is stupid, it defines a non-!-returning abort, while libc has the proper definition
[07:41:21] <eddyb> strcat: gg
[07:41:40] <eddyb> #[allow(dead_code)] and then party in #rust
[07:41:53] <strcat> rusti: 2
[07:41:54] -rusti- 2
[07:41:55] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[07:43:05] <strcat> rusti: 2
[07:43:10] -rusti- timeout triggered!
[07:43:12] <strcat> rusti: 2
[07:43:13] -rusti- 2
[07:43:26] <eddyb> what's with the timeout? trying out something?
[07:43:29] <strcat> yes
[07:44:03] <strcat> http://ix.io/9RY just applied this ;p
[07:45:18] <strcat> rusti: 1 + 1
[07:45:19] -rusti- 2
[07:45:32] <strcat> eddyb: don't use libc! use the intrinsic
[07:45:45] <strcat> the intrinsic compiles to an instruction
[07:46:14] <eddyb> strcat: I won't change semantics. though LLVM might assume malloc never fails in some cases
[07:46:24] <strcat> it won't assume it never fails
[07:46:29] <strcat> eddyb: the intrinsic abort has the same semantics
[07:46:41] <strcat> eddyb: LLVM doesn't know libc abort is noreturn, nounwind, etc.
[07:46:45] <eddyb> src/libstd/unstable/stack.rs:        intrinsics::abort();
[07:46:47] <strcat> well, it knows it's noreturn
[07:46:49] <strcat> from the annotation
[07:46:57] <eddyb> strcat: which I've fixed last night
[07:47:15] <strcat> not nounwind though ;p
[07:47:18] <eddyb> the abort exchange_malloc was using didn't even have the -> ! annotation
[07:47:22] <strcat> ah
[07:47:53] <strcat> remote object '/data/tmp/tmp/check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu-extra-metrics.json' does not exist
[07:47:55] <strcat> again
[07:47:56] <eddyb> what I fixed was that -> ! wasn't marking a function as noreturn if it was an extern import
[07:48:07] <strcat> ah it's just android
[07:48:09] <strcat> not important
[07:48:24] <strcat> eddyb: ah
[07:48:38] <strcat> if we read C headers, C functions would have better definitions
[07:48:45] <strcat> from the __attribute__ annotations
[07:49:06] <strcat> rusti: 2
[07:49:07] -rusti- 2
[07:49:08] <strcat> rusti: 2 + 5
[07:49:09] -rusti- 7
[07:49:10] <strcat> rusti: 2 + 5
[07:49:11] -rusti- 7
[07:49:12] <strcat> rusti: 2 + 5
[07:49:12] -rusti- 7
[07:49:22] <eddyb> src/libstd/local_data.rs:fn abort() -> ! {
[07:49:32] <eddyb> it better do more than just call libc:;abort
[07:49:45] <strcat> just remove the libc definition of abort imo
[07:49:53] <strcat> like we removed memcpy/memmove/memset
[07:50:01] <strcat> because they are LLVM intrinsics and call through to the libc one anyway
[07:50:25] <strcat> llvm's abort calls libc abort on... really obscure platforms where no one implemented llvm.trap in a better way ;p
[07:50:48] <strcat> eddyb: http://lists.cs.uiuc.edu/pipermail/llvmdev/2014-January/069375.html
[07:51:50] *** Joins: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP)
[07:52:03] <acrichto> rusti: version
[07:52:04] -rusti- "rustc 0.10-pre (db7b9a3 2014-01-15 02:09:57 -0500)"
[07:52:08] <acrichto> strcat: \o/
[07:52:19] <strcat> still no idea why it fails with libuv i/o
[07:52:32] <acrichto> libuv does scary things with file descriptors
[07:52:38] <strcat> well strace shows a bunch of errors
[07:52:44] <strcat> hard to know what it does wrong
[07:52:45] <acrichto> with libnative?
[07:52:47] <strcat> no
[07:52:50] <strcat> in libuv
[07:52:50] <acrichto> ah
[07:52:52] <acrichto> oh well
[07:52:56] <strcat> it does invalid stuff and doesn't check a lot of error codes :(
[07:53:22] <strcat> seccomp lets you make arbitrary syscalls return an error code
[07:53:24] <strcat> so...
[07:53:29] <strcat> error code of your choice too
[07:56:11] <eddyb> acrichto: objections to removing libc::abort?
[07:56:44] <eddyb> why does libgreen duplicate rt_util?
[07:57:08] <acrichto> eddyb: why remove libc::abort?
[07:57:18] <acrichto> I never got around to removing the duplication :(
[07:57:21] <strcat> acrichto: because the intrinsic calls libc abort only when there's no shorter way
[07:57:41] <eddyb> undefined instructions can be like one byte
[07:57:42] <acrichto> hmm... we'd need a nicer interface for it
[07:57:46] <strcat> not very important, nice for abort to not be considered as maybe unwinding
[07:58:02] <acrichto> intrinsics::abort() is kinda a sad interface
[07:58:07] <acrichto> breaking on abort is also useful sometimes
[07:58:14] <acrichto> although I guess gdb/lldb do that anyway
[07:58:17] <acrichto> when ud2 is executed...
[07:58:18] <strcat> acrichto: yeah, they do
[07:58:25] <strcat> acrichto: and there's a breakpoint intrinsic
[07:58:53] <eddyb> oooh, shiny, I didn't know about it
[07:58:59] <acrichto> I never understood what a breakpoint intrinsic is for
[07:59:03] <acrichto> b/c it kills the program if not in a debugger
[07:59:18] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[07:59:21] <strcat> people run programs outside of debuggers? ;p
[07:59:26] <strcat> acrichto: afaik you can disable that, not sure
[07:59:47] <acrichto> I wish I knew how :(
[08:00:05] <acrichto> we had a MAGIC_BREAK; in my OS class that would do a break if in a debugger, but nothing in the normal case
[08:00:09] <acrichto> it was like the best thing ever
[08:00:19] <strcat> acrichto: you can check if you're in a debugger
[08:00:36] <eddyb> and then people run it in winedbg and bypass it :P
[08:01:26] <eddyb> I can breakpoint in the middle of the battle.net authentication module, in WoW - but only under winedbg </re_rant)
[08:01:29] <eddyb> s/)/>
[08:01:32] <acrichto> strcat: does rusti make static binaries, and if so is it much sloewr than a dynamic one?
[08:01:40] <strcat> acrichto: just dynamic ones
[08:01:44] <acrichto> ah ok
[08:01:52] <strcat> acrichto: https://github.com/thestinger/rust-playpen it's all there
[08:01:54] <strcat> + playpen
[08:01:59] <strcat> bin/irc.sh
[08:02:24] <acrichto> that's static?
[08:02:32] <strcat> hm? it's dynamic
[08:02:38] <acrichto> there's no -Z prefer-dynamic
[08:02:38] * strcat confused
[08:02:45] <acrichto> unless you remove all rlibs
[08:02:55] <strcat> acrichto: oh, it's static by default now?
[08:03:04] <acrichto> yeah
[08:03:05] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[08:03:06] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[08:03:10] <acrichto> if all deps are rlibs
[08:03:12] <strcat> ah yeah
[08:03:17] <strcat> I haven't payed attention to how big the binaries are
[08:03:19] <strcat> ;p
[08:03:36] <acrichto> I *think* static binary creation is just as fast as dynamic
[08:03:37] <acrichto> just curious
[08:03:55] <strcat> huh I guess there are syscalls in the error path I need to add
[08:03:58] <strcat> oh nvm
[08:04:04] <strcat> eddyb was just doing an infinite loop ;p
[08:04:19] <eddyb> I didn't start that
[08:04:33] <strcat> acrichto: dynamic is a bit faster
[08:04:38] <strcat> eddyb: I was just confused
[08:04:41] <strcat> I thought it timed out for no reason ;]
[08:04:42] <acrichto> strcat: by how much?
[08:04:51] <strcat> acrichto: 5ms?
[08:04:57] <acrichto> oh well
[08:04:58] <strcat> it's not very consistent
[08:05:12] <acrichto> oh they both get speed boosts
[08:05:16] <acrichto> b/c reading rlib metadata is superfast
[08:05:27] <acrichto> rusti: [1, 2, 3]
[08:05:28] -rusti- [1, 2, 3]
[08:05:46] <acrichto> rusti: fail!("wut")
[08:05:48] -rusti- pastebinned 10 lines of output: http://ix.io/9RZ
[08:05:55] <acrichto> rusti: fail!("wut"); 2
[08:05:59] -rusti- pastebinned 10 lines of output: http://ix.io/9RZ
[08:06:07] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[08:06:20] <eddyb> acrichto: 2 there has type ! :P
[08:06:20] <acrichto> rusti: fn f() { fail!() } f()
[08:06:21] -rusti- task '<main>' failed at 'explicit failure', <anon>:10
[08:06:21] -rusti- application terminated with error code 101
[08:06:34] <eddyb> it's funny how it can bubble up
[08:06:42] <acrichto> weird
[08:06:47] <strcat> rusti: println("foo"); while true { }
[08:06:49] -rusti- pastebinned 7 lines of output: http://ix.io/9S3
[08:07:00] <strcat> rusti: println!("foo"); while true { }
[08:07:06] -rusti- <anon>:10:26: 10:40 warning: denote infinite loops with loop { ... }, #[warn(while_true)] on by default
[08:07:06] -rusti- <anon>:10         println!("foo"); while true { }
[08:07:06] -rusti-                                    ^~~~~~~~~~~~~~
[08:07:06] -rusti- foo
[08:07:06] -rusti- timeout triggered!
[08:07:12] <acrichto> cool!
[08:07:24] <strcat> magic
[08:07:40] <strcat> https://github.com/thestinger/playpen/blob/master/playpen.c#L442 (I mean magic when I say it)
[08:08:48] <strcat> rusti: extern { fn raise(x: u32) -> u32; } unsafe { raise(9) }
[08:08:49] -rusti- 0u32
[08:08:57] <strcat> wat
[08:09:21] <strcat> oh it needs a syscall
[08:09:23] <strcat> tgkill
[08:09:25] <eddyb> strcat: suicide is noop
[08:09:46] <eddyb> sounds like a nice parallel universe :P
[08:10:01] <strcat> rusti: extern { fn raise(x: u32) -> u32; } unsafe { raise(9) }
[08:10:02] -rusti- 0u32
[08:10:04] <strcat> wat
[08:10:19] <strcat> ah wait
[08:11:16] <strcat> rusti: std::run::process_output
[08:11:16] -rusti- fn(&str, &[~str]) -> std::option::Option<std::run::ProcessOutput>
[08:11:49] <strcat> rusti: print!(std::str::from_utf8(std::run::process_output(["ps", [~"ax"]).output))
[08:11:51] -rusti- pastebinned 9 lines of output: http://ix.io/9S4
[08:12:02] <strcat> rusti: print!(std::str::from_utf8(std::run::process_output(["ps", [~"ax"]]).output))
[08:12:04] -rusti- pastebinned 6 lines of output: http://ix.io/9S5
[08:12:19] <strcat> rusti: print!("{}", std::str::from_utf8(std::run::process_output(["ps", [~"ax"]]).output))
[08:12:21] -rusti- pastebinned 31 lines of output: http://ix.io/9S6
[08:12:23] <strcat> wat
[08:12:37] * strcat is silly
[08:12:46] <strcat> rusti: print!("{}", std::str::from_utf8(std::run::process_output("ps", [~"ax"]).output))
[08:12:47] -rusti- pastebinned 17 lines of output: http://ix.io/9S7
[08:13:09] <strcat> rusti: print!("{}", std::str::from_utf8(std::run::process_output("ps", [~"ax"]).get().output))
[08:13:11] -rusti- pastebinned 17 lines of output: http://ix.io/9S8
[08:13:12] <strcat> rusti: print!("{}", std::str::from_utf8(std::run::process_output("ps", [~"ax"]).unwrap().output))
[08:13:14] -rusti- pastebinned 21 lines of output: http://ix.io/9S9
[08:13:28] * strcat gives up
[08:14:29] *** Quits: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net) (Quit: tikue)
[08:14:47] <Yurume> eddyb: I have a new version of the periodic table, realizing [T, ..n] is missing from the list. could you review it? :) http://cosmic.mearie.org/2014/01/periodic-table-of-rust-types/testing
[08:15:11] <Yurume> the main change is a separation of bare and unsized columns.
[08:15:28] <strcat> rusti: let x = std::run::process_output("ps", [~"ax"]).unwrap(); print!("{}", std::str::from_utf8(x.output))
[08:15:34] -rusti- timeout triggered!
[08:15:37] <strcat> haha
[08:15:44] <acrichto> Yurume: one point I saw is that we'll never support &mut str
[08:16:02] <Yurume> > This also has a side effect that allows for &mut str, though it won't see much use since safe strings cannot be modified via indexing.
[08:16:07] *** Joins: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net)
[08:16:22] <Yurume> afaik &mut str is "valid" but not "usable" in this regard.
[08:16:26] <Yurume> &mut str would made "valid"*
[08:16:40] <acrichto> we're explicitly disallowing &mut str b/c it violates the utf-8 invariant
[08:16:40] <Yurume> or wouldn't it?
[08:16:57] <eddyb> acrichto: you can't assign to a &mut str anyway
[08:16:59] <strcat> rusti: let x = std::run::process_output("pstree", []).unwrap(); print!("{}", std::str::from_utf8(x.output))
[08:17:01] -rusti- pastebinned 2 lines of output: http://ix.io/9Sc
[08:17:27] *** Quits: tikue (tkuehn@moz-879E86A9.hsd1.ca.comcast.net) (Quit: tikue)
[08:17:38] <strcat> rusti: let x = std::run::process_output("pstree", []).unwrap(); print!("{}", std::str::from_utf8(x.output))
[08:17:44] -rusti- timeout triggered!
[08:17:45] * strcat wonders why
[08:18:06] <eddyb> acrichto: the only functions that could modify a &mut str would be library functions with unsafe code in them
[08:18:18] <eddyb> and they would be trusted to do the right thing
[08:18:23] <strcat> I guess rust calls fork
[08:18:28] <strcat> rusti: let x = std::run::process_output("pstree", []).unwrap(); print!("{}", std::str::from_utf8(x.output))
[08:18:33] <strcat> who knows!
[08:18:33] -rusti- timeout triggered!
[08:18:38] <acrichto> eddyb: even then we don't bother allowign it
[08:18:45] <acrichto> not even unsafely
[08:19:19] <eddyb> acrichto: it would be a bit hard with DST, but not unreasonably so
[08:19:47] <eddyb> (it would be a bother to disallow it, rather than just disallowing mutation via indexing)
[08:20:19] <Yurume> is there any possible operation with &mut str anyway? :)
[08:20:55] <eddyb> swapping slices around?
[08:21:04] <eddyb> reversing the string?
[08:21:23] <Yurume> is that useful?
[08:21:40] <Yurume> we can even support ROT13 in &mut str...
[08:21:57] <Yurume> but what we can do is not same as what we should od
[08:21:58] <Yurume> do*
[08:22:04] <eddyb> Yurume: as_ascii_mut
[08:22:07] <strcat> eddyb: what does reversing a string mean though?
[08:22:15] <eddyb> strcat: let's not get started on that
[08:22:18] <strcat> ;p
[08:22:32] <strcat> well I don't think we should add more methods without unicode semantics
[08:23:09] *** Joins: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:23:09] *** Quits: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[08:23:13] <eddyb> with [u8, ..n] on the stack (with variable n, i.e. VLA), we could cast &mut u8 into a GrowableInPlaceString. but maybe that doesn't need &mut str
[08:23:18] *** Joins: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:23:30] <strcat> rusti: while true {}
[08:23:33] <strcat> rusti_: while true {}
[08:23:35] -rusti- <anon>:10:9: 10:22 warning: denote infinite loops with loop { ... }, #[warn(while_true)] on by default
[08:23:35] -rusti- <anon>:10         while true {}
[08:23:35] -rusti-                   ^~~~~~~~~~~~~
[08:23:36] -rusti- timeout triggered!
[08:23:38] -rusti_- <anon>:10:9: 10:22 warning: denote infinite loops with loop { ... }, #[warn(while_true)] on by default
[08:23:39] -rusti_- <anon>:10         while true {}
[08:23:39] -rusti_-                   ^~~~~~~~~~~~~
[08:23:39] -rusti_- timeout triggered!
[08:23:40] <strcat> ;p
[08:23:41] *** Quits: rusti_ (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[08:23:44] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[08:23:47] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[08:23:53] <strcat> hm
[08:24:17] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[08:24:28] <Yurume> eddyb: how about the unsized column? does that make sense?
[08:24:49] <eddyb> Yurume: I guess...
[08:25:07] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[08:26:53] <eddyb> test at_vec::test::bench_from_elem                              ... bench:     13056 ns/iter (+/- 2802)
[08:26:55] *** Joins: dbaupp (Thunderbir@moz-6002BAEA.lns20.syd6.internode.on.net)
[08:27:01] <eddyb> that's not elided :/
[08:27:36] <strcat> that's not exchange_malloc
[08:27:50] <dbaupp> Yurume: "Traits have to be resolved either *at* compile time or *at* runtime."
[08:28:00] <eddyb> I want to see non-explicitly-kept-alive benchmarks go down to 0ns
[08:28:50] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:28:57] <eddyb> test rt::global_heap::bench::alloc_owned_big                    ... bench:         3 ns/iter (+/- 0)
[08:29:09] <eddyb> okay, 3ns is the empty benchmark baseline
[08:29:20] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:29:32] <eddyb> acrichto: test io::buffered::test::bench_buffered_* are all dummies
[08:29:35] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:29:49] <strcat> rusti can only do 5 hello worlds per second per thread ;[
[08:30:19] <strcat> make rustc faster ;p
[08:30:44] <strcat> Requests per second:    21.29 [#/sec] (mean)
[08:30:47] <strcat> all my laptop can do...
[08:30:53] * strcat cries
[08:31:17] <dbaupp> strcat: apparently it's {:?} that kills it
[08:31:33] <strcat> dbaupp: hm?
[08:31:34] <dbaupp> {} is much much faster
[08:31:39] <strcat> compile-time?
[08:31:42] <dbaupp> yeah
[08:31:45] <strcat> ah
[08:31:48] <strcat> yeah
[08:31:50] <strcat> visit glue.
[08:31:51] <Yurume> dbaupp: updated. (though I cannot easily grasp the difference...)
[08:32:27] <dbaupp> strcat: 0.5 vs 0.1 s for me
[08:33:46] <eddyb> acrichto: don't tell me @ allocations go through Task
[08:34:05] <strcat> @ will be dead soon enough
[08:34:06] <dbaupp> Yurume: I guess "compile time" and "runtime" act as if they single points in time, so it's like saying "Traits have to be resolved at 2 o'clock" ("Traits have to be resolved in 2 o'clock" is the corresponding incorrect sentence)
[08:34:08] <dbaupp> eddyb: they do
[08:34:30] <strcat> acrichto: dtors are another thing
[08:34:31] <dbaupp> Yurume: i.e. compilation and running are single actions
[08:34:32] * dbaupp shrugs
[08:34:35] <Yurume> English is difficult for me ;)
[08:34:36] <dbaupp> language...
[08:34:56] <strcat> acrichto: I think they're still external and hang onto a lot of code
[08:35:03] <Yurume> anyway, ship it!
[08:35:21] <dbaupp> Yurume: yours is very good, I rarely pick up something that sounds non-native :)
[08:35:26] <eddyb> can we remove #[lang="borrow_as_mut"]?
[08:35:35] <strcat> eddyb: isn't it gone?
[08:35:40] <eddyb> nope
[08:35:53] <Yurume> dbaupp: I'm seriously bad at speaking though... :S
[08:35:55] <eddyb> also #[lang="return_to_mut"]
[08:36:21] <Yurume> (and I think I normally talk about what I'm interested, that greatly limits the vocabulary and expressions)
[08:36:22] * strcat actually has nice rust seccomp bindings ;p
[08:36:33] <dbaupp> Yurume: as far as I know you've got perfect intonation and pronunciation :P
[08:36:34] <strcat> just revived them
[08:36:43] * dbaupp will continue to believe that
[08:36:47] <strcat> https://github.com/thestinger/rust-seccomp/blob/master/example.rs pretty neat!
[08:37:04] <strcat> need to list out the syscalls as constants
[08:37:10] <dbaupp> strcat: was pcwalton interested in that for servo?
[08:37:32] <strcat> yes I wrote a page about it
[08:37:35] <Yurume> dbaupp: Bayesian probability? XD
[08:37:52] <strcat> dbaupp: https://github.com/mozilla/servo/wiki/Linux-sandboxing
[08:37:58] <dbaupp> Yurume: and every word you've ever spoken to me has been perfect! ;D
[08:38:18] <dbaupp> strcat: ah, yes; that's what I was remembering
[08:39:28] <strcat> whew that thing finally landed
[08:39:37] <strcat> so many ephemeral failures ;s
[08:40:00] <dbaupp> no more headers?
[08:40:04] <strcat> well
[08:40:07] <strcat> closures have them ;p
[08:40:26] <eddyb> strcat: only procs, though?
[08:40:28] <strcat> but yeah no more ~ headers
[08:40:35] <dbaupp> hm, is anyone else getting undefined LIBDIR_RELATIVE errors on make?
[08:40:35] <strcat> eddyb: I think &[T] has a header
[08:40:42] <eddyb> bleh
[08:40:48] <strcat> eddyb: I removed the code initializing most of it
[08:40:51] <dbaupp> strcat: &[T] has a header?? how does that work?
[08:40:52] <eddyb> test rt::local_heap::bench::alloc_managed_big                   ... bench:       959 ns/iter (+/- 196)
[08:40:56] <strcat> dbaupp: er sorry
[08:41:01] <strcat> stack closures* have a header
[08:41:06] <dbaupp> right
[08:41:44] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[08:41:44] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/_Ygl9w
[08:41:44] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[08:42:10] <eddyb> strcat: procs don't actually need the header, do they?
[08:42:19] <strcat> eddyb: they do
[08:42:24] <strcat> eddyb: they use the tydesc
[08:42:26] <strcat> ;]
[08:42:30] <strcat> eddyb: it's sad
[08:42:31] <eddyb> but anything else?
[08:42:36] <strcat> eddyb: no
[08:42:41] <strcat> eddyb: they use the tydesc to call the dtor
[08:42:42] <dbaupp> trait objects?
[08:42:45] <strcat> I plan on fixing it
[08:42:52] <dbaupp> oh, tydesc in the vtable
[08:42:55] <strcat> dbaupp: trait objects I'll fix too! they all have a tydesc
[08:43:05] <strcat> dbaupp: procs have the gc box header and use the tydesc
[08:43:06] <strcat> to call drop glue
[08:43:08] <dbaupp> strcat: just put the dtor in the vtable directly?
[08:43:17] <strcat> dbaupp: yes
[08:43:19] <strcat> that's the plan
[08:43:24] <dbaupp> sounds good
[08:43:33] <eddyb> strcat: merging procs and traits might be a waste of time, considering DST
[08:43:50] <eddyb> that is, all the special code handling closures could be ripped out then
[08:44:44] <eddyb> strcat: that is, if you change traits and it's easy to make the same changes to procs, don't let me keep you from doing that nice change
[08:45:30] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:45:43] <strcat> rusti: 2
[08:45:44] -rusti- 2
[08:46:08] <dbaupp> rusti: (1,)
[08:46:09] -rusti- (1,)
[08:46:38] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Quit: Textual IRC Client: www.textualapp.com)
[08:46:39] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[08:46:39] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/eBrcqQ
[08:46:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[08:46:40] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[08:46:40] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/iXL0EA
[08:46:40] <ghrust> 13rust/06auto 14522d6fa 15Brendan Zabarauskas: Merge Bitwise and BitCount traits and remove from prelude, along with Bounded...
[08:46:40] <ghrust> 13rust/06auto 14b7e4f31 15bors: auto merge of #11548 : bjz/rust/bitwise, r=alexcrichton...
[08:46:41] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[08:46:47] <strcat> rusti: use std::rc::Rc; let x = Rc::new(5); x.downgrade()
[08:46:48] -rusti- std::rc::Weak<int>{ptr: (0x7f603c000e70 as *mut ())}
[08:46:56] <strcat> rusti: use std::rc::Rc; let x = Rc::new(5); x.downgrade().upgrade()
[08:46:57] -rusti- Some(std::rc::Rc<int>{ptr: (0x7fe008000e70 as *mut ())})
[08:47:31] <eddyb> that's not supposed to work, is it?
[08:47:32] <dbaupp> I imagine {:?} will get less and less useful as things move to libraries
[08:47:42] <strcat> eddyb: it is
[08:47:45] <strcat> rusti: use std::rc::Rc; let x = Rc::new(5); let y = x.downgrade(); drop(x); y.upgrade()
[08:47:46] -rusti- None
[08:47:55] <eddyb> aaah, downgrade makes a copy
[08:47:59] <dbaupp> eddyb: downgrade isn't in place
[08:48:00] <dbaupp> yeah
[08:48:49] <dbaupp> yay for repetition http://static.rust-lang.org/doc/master/std/rt/local_heap/index.html
[08:49:08] <eddyb> strcat: I want a maybe_emplace_map in the future Rc for the AST
[08:49:15] <eddyb> do you think that's feasible?
[08:49:48] <dbaupp> eddyb: what would it do?
[08:49:56] <strcat> eddyb: hm?
[08:50:32] <eddyb> dbaupp: you would provide a closure, getting a &T and returning a T. though it's a bit sketchy as you can't move out of a &T
[08:50:50] <eddyb> I basically want to write code that looks like it always allocates new memory, but do it in-place if possible
[08:51:03] <eddyb> (i.e. if refcount == 1)
[08:51:17] <dbaupp> (strong == 1, weak == 0, right?)
[08:51:30] <eddyb> no weak, I did say I want a custom Rc
[08:51:49] <strcat> eddyb: could copy the objc ARC optimization passes for Rc ;p
[08:52:36] <dbaupp> eddyb: I think part of the plan was to put the AST into arenae anyway
[08:52:45] <eddyb> dbaupp: that's harder to get right
[08:53:04] <dbaupp> eddyb: https://github.com/mozilla/rust/issues/7929#issuecomment-21291989
[08:53:08] <eddyb> and you still allocate
[08:53:13] <dbaupp> eddyb: in what way? lifetimes just thread through
[08:53:41] <eddyb> as in, you need to juggle arenas around to get decent memory usage
[08:54:14] <dbaupp> have each AST fold allocate into a new arena and discard the old one?
[08:54:26] <eddyb> still requires allocating a lot of memory and peaking
[08:54:38] <dbaupp> how much memory does our AST use?
[08:55:14] <eddyb> dbaupp: it doubles during each folding pass and the default allocator won't free the memory
[08:55:25] <dbaupp> the AST passes peak at 300 MB
[08:55:35] <dbaupp> everything after than is non-AST
[08:55:42] <dbaupp> eddyb: "default allocator"?
[08:55:43] <eddyb> with massif, you see weird peaks
[08:55:54] <eddyb> glibc whatever-version-I-have-installed
[08:56:14] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[08:56:22] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[08:56:28] *** Joins: jt (quassel@moz-B994FA9E.cs.st-andrews.ac.uk)
[08:56:32] <strcat> eddyb: I'm curious how well tcmalloc/jemalloc do
[08:56:32] <eddyb> anyways, my emplace thing, if it takes |T| -> T, it needs to clone the contents (in the non-emplace case), which is bad for any ~T or ~[T], but not so much for P<T>. if it's in-place almost always, the cost might be worth the semantics
[08:56:36] <dbaupp> eddyb: really, it doesn't return memory to the OS at all?
[08:56:40] *** Quits: sigma (sigma@moz-9EAC972C.range86-184.btcentralplus.com) (Client exited)
[08:56:43] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[08:56:49] <strcat> dbaupp: returning memory to the OS is hard
[08:57:08] *** Joins: sigma (sigma@moz-9EAC972C.range86-184.btcentralplus.com)
[08:57:09] <strcat> reusing freed chunks is what it will do
[08:57:41] <strcat> dbaupp: if you allocate a 4MiB arena (like jemalloc), you can't actually hand it back to the OS until every last allocation in it is freed
[08:57:58] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[08:58:19] <strcat> malloc/free/realloc is a really bad allocator interface ;p
[08:58:23] <strcat> can do a lot better
[08:58:29] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[08:58:34] <dbaupp> I imagine the AST arenas would use chunks almost that large (at least, we could choose that)
[08:59:01] <dbaupp> so discarding them would make it actually sensible to give back to the OS
[08:59:54] <eddyb> remember my memory space invalidation trick?
[09:00:26] <eddyb> with that, it would be cheap to allocate/free in an arena, with no special lifetimes annotations
[09:00:29] <strcat> dbaupp: glibc doesn't really know how
[09:00:35] <strcat> jemalloc uses mmap only
[09:00:38] <strcat> glibc uses sbrk ;p
[09:00:42] <strcat> anyway
[09:00:47] <strcat> glibc is going to switch to that valloc thing
[09:01:08] <dbaupp> we could just do what dmd does and just use a bump allocator
[09:01:35] <eddyb> dbaupp: I guess we should profile allocations in rustc::middle then
[09:01:54] <dbaupp> allocate everything as 'static \o/
[09:02:09] <eddyb> dbaupp: for AST arenas? yes
[09:02:33] <eddyb> do you want me to try that again, with fold_crate swapping out arenas?
[09:02:34] *** Joins: wtw (wtw@moz-D8FB7390.org)
[09:02:39] <dbaupp> that'd be neat
[09:03:25] <eddyb> if we do typed arenas, we need a list of all supported types in one place
[09:03:50] <eddyb> to generate a task-local arena manager structure
[09:04:19] <eddyb> dbaupp: it's actually a similar trick to the Many one, just that you return fields and not vtables
[09:04:32] <dbaupp> I imagine we'd get the biggest benefit from Expr being in a typed arena, and just lump everything else into an untyped one
[09:04:38] * dbaupp isn't sure though
[09:04:43] <eddyb> that's also doable
[09:05:03] <eddyb> (while still maintaining a simple generic function to allocate)
[09:05:24] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[09:05:33] <dbaupp> do note nmatsakis's comment on the issue though
[09:05:36] <dbaupp> *comments
[09:06:11] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[09:07:03] <eddyb> dbaupp: thing is... it still requires allocation and whatnot
[09:07:23] <dbaupp> eddyb: only very occasionally
[09:07:38] <eddyb> folding always reallocates *everything*
[09:07:55] <eddyb> including the owned vectors which aren't in arenas
[09:08:03] <dbaupp> yes, but if you're allocating into an arena, it's ok
[09:08:11] <dbaupp> well, maybe we need arena-vec's
[09:08:19] <dbaupp> that sounds... hard though.
[09:08:26] <eddyb> while in-place folding done right could become - in the case of ast_map, for example - a mutation of the AST
[09:08:48] <eddyb> it just assigns proper ids, 0 allocations
[09:09:20] <eddyb> (though move_iter().map(|x| x).collect() might require trickery to turn into a noop)
[09:10:15] <eddyb> can LLVM optimize out *x = *x; for a mut x: ~T?
[09:10:48] <strcat> eddyb: doubt it
[09:10:55] <strcat> eddyb: LLVM is going to get escape analysis
[09:10:57] <eddyb> hmm, can I just run massif on librustc... but I don't have timings
[09:11:07] <eddyb> strcat: what about noalias?
[09:11:19] <strcat> eddyb: it knows malloc returns a noalias value
[09:11:37] <eddyb> I mean, x is not aliased. you read from it then write back the same value
[09:11:43] <strcat> hm?
[09:11:53] <strcat> eddyb: all it has for malloc/free atm is dead store elimination
[09:12:04] <strcat> eddyb: anyway it could remove a redundant write
[09:12:08] <strcat> and then dead store eliminate it
[09:12:22] <eddyb> I don't need dead store eliminate, just redundant writes
[09:12:49] <strcat> eddyb: well it can probably do it in a local scope...
[09:12:51] <strcat> in the real world no
[09:12:54] <strcat> the alias analysis is really dumb
[09:13:00] <eddyb> strcat: the scope would be local
[09:13:27] <eddyb> read-fold-write. with a noop fold
[09:13:47] <strcat> eddyb: try it and see ;p
[09:13:49] <eddyb> hmpf, might not work for pointers, those can still change if refcounts aren't all 1
[09:13:52] <strcat> I expect it can optimize it out
[09:13:59] <strcat> it can optimize out Rc + Weak ptrs in some case
[09:14:04] <strcat> as long as it's in one function
[09:14:08] <eddyb> (no weak here)
[09:14:27] <eddyb> cfg would just replace some owned vectors, ast_map would write ids (well, it still has to insert in hashmaps)... but that's my fantasy
[09:15:11] <eddyb> btw, there's a large-scale abuse of HashMap in rustc::middle, can we get something cheaper than SipHash (most of those are integer keys)?
[09:15:50] <eddyb> (and maybe trans could stop querying a million things by ID)
[09:16:07] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[09:16:37] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[09:16:45] <eddyb> strcat: I have an idea. trace HashMap::find and print an inner pointer + key hash
[09:16:53] <dbaupp> if we had default type parameters :P
[09:17:07] <dbaupp> (we could change the hash easily)
[09:17:12] <eddyb> dbaupp: oh, yeah. entirely my fault :(
[09:17:25] <dbaupp> eddyb: yup, exactly... all your fault
[09:17:31] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[09:17:34] <dbaupp> it's not that people aren't reviewing your code or anything
[09:17:38] <dbaupp> definitely your fault
[09:18:03] * dbaupp sarcasm
[09:18:17] <eddyb> dbaupp: it actually is... if only I didn't tell nmatsakis about the damned env params
[09:18:18] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[09:18:50] <dbaupp> eddyb: hahaha, I'm sure they would've found something else to talk about
[09:19:13] <eddyb> strcat: then investigate the unique entries which appear most times. I somehow expect some IDs to show up thousands of times
[09:19:19] <strcat> just heavily optimize std::trie
[09:19:25] <strcat> make it a burst trie
[09:19:31] <strcat> ;p
[09:19:44] <dbaupp> strcat: I worked out why we couldn't reverse the chunking btw
[09:19:48] <dbaupp> it's really really obvious
[09:19:54] <strcat> sorting
[09:19:58] <dbaupp> yeah
[09:20:04] <strcat> it does a radix sort, yeah
[09:20:12] * dbaupp spend 20 minutes trying to work out why tests were failing
[09:20:17] <dbaupp> *spent
[09:20:17] <strcat> dbaupp: doesn't necessarily have to be ordered though ;p, if you wanted a specialized one
[09:20:21] * dbaupp embarassed
[09:20:28] <strcat> really slow radix sort
[09:20:40] <dbaupp> strcat: true enough, I really should just take Boehm's trie for the GC though
[09:20:56] <dbaupp> they probably know what they're doing when it comes to storing pointers :P
[09:21:37] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[09:21:52] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[09:22:47] <dbaupp> task 'rustc' failed at 'index out of bounds: the len is 40 but the index is 40', /home/huon/rust/src/librustc/middle/lang_items.rs:71
[09:22:53] <dbaupp> I thought the macro fixed that...
[09:23:15] <dbaupp> oh, there's still 2 places to update... :/
[09:23:21] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[09:23:56] * dbaupp can probably fix that
[09:24:18] <eddyb> strcat: it's not a bad idea... IDs are linear, a trie makes way more sense than a HashMap with SipHash :P
[09:24:42] <dbaupp> eddyb: smallintmap would probably be even better
[09:24:49] <dbaupp> if they actually are strictly lineaer
[09:24:51] <dbaupp> *linear
[09:24:53] <eddyb> "small"?
[09:24:56] <dbaupp> (starting from 0)
[09:25:09] <eddyb> they go up into the millions
[09:25:18] <dbaupp> are they dense?
[09:25:27] <dbaupp> because a hashmap is storing all of them anyway
[09:25:56] <eddyb> dbaupp: ast_map ignores some of the IDs
[09:25:59] <dbaupp> a "small" intmap is storing 0..n as tight as possible, basically
[09:26:03] <dbaupp> how many?
[09:26:20] <eddyb> callee_ids, I think. arguments
[09:26:27] <eddyb> patterns that aren't PatIdent
[09:26:34] <dbaupp> so, maybe 10%?
[09:26:42] <dbaupp> is the overhead of a hashmap > 10%?
[09:26:52] <dbaupp> anyway, dinner time
[09:26:57] <dbaupp> bbl
[09:27:07] <eddyb> dbaupp: remember I thought about just using a vector?
[09:27:15] <eddyb> that would be pretty efficient
[09:27:35] <strcat> dbaupp: memory overhead? 
[09:27:47] <strcat> dbaupp: the overhead is pretty high
[09:27:52] <eddyb> lookups also take time
[09:27:54] <strcat> it has to store hashes in the table
[09:28:18] <strcat> struct Bucket<K,V> {
[09:28:20] <strcat>     hash: uint,
[09:28:22] <strcat>     key: K,
[09:28:24] <strcat>     value: V,
[09:28:26] <strcat> }
[09:28:28] <strcat> it's an array of Option<Bucket> :)
[09:28:38] <eddyb> are you kidding me?
[09:28:45] <strcat> and at 75% capacity, it expands 2x
[09:28:53] <eddyb> strcat: that Option is costing 8 bytes
[09:28:56] <strcat> and SipHash is RIDICULOUSLY slow for integers
[09:29:13] <strcat> eddyb: look at what SipHash compiles to
[09:29:19] <eddyb> I don't want to
[09:29:21] <eddyb> nope
[09:29:23] <strcat> compared to say fibonacci hashing
[09:29:25] <strcat> eddyb: look at it ;p
[09:29:29] <strcat> c'mon
[09:29:48] <eddyb> strcat: it's a hassle unless you can provide a commandline outputting LLVM IR to less
[09:29:54] <eddyb> strcat: oooh, idea I had last night
[09:30:15] <eddyb> [[0]: a, [5]: b, default .. N]
[09:30:31] <eddyb> with that you can manually craft static lookup tables
[09:30:55] <eddyb> (like a hash table's buckets, but without hashing)
[09:31:14] <eddyb> the worst part is that you can't know TypeIds before typeck, at least I don't think so
[09:31:31] <strcat> oh
[09:31:32] <strcat> btw
[09:31:38] <strcat> LLVM is going to learn how to use hashing for switches soon
[09:31:40] <strcat> ;]
[09:31:43] <eddyb> I wanted to generate something like...
[09:31:49] <eddyb> strcat: that's what I wanted to do, OMG
[09:32:02] <eddyb> strcat: have you seen my Many crazyness?
[09:32:12] <strcat> no
[09:32:14] <eddyb> that is going to benefit so much from hash/lookup tables for switches
[09:33:07] <sigma> eddyb: http://article.gmane.org/gmane.comp.compilers.llvm.devel/69383/
[09:33:27] <eddyb> test rt::local_heap::bench::alloc_managed_big                   ... bench:       938 ns/iter (+/- 117)
[09:33:31] <eddyb> I thought I could fix it :/
[09:34:30] *** Quits: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP) (Ping timeout)
[09:34:55] <eddyb> strcat: ignore the macro failure https://gist.github.com/eddyb/f828f8ce819a5f00d42d
[09:35:23] <eddyb> strcat: it's like Any, but for a number of trait interfaces that the implementer wants to expose
[09:36:09] <eddyb> maybe like dynamic_cast from a base class to... wait, no, can dynamic_cast from C++ cast from one virtual base class to another?
[09:36:59] <strcat> eddyb: http://thread.gmane.org/gmane.comp.compilers.llvm.devel/69057/focus=69389
[09:38:07] <eddyb> the labels are hashes already, I hope that most cases will only need to find a small power of 2
[09:38:41] <eddyb> oh, I know. combination of a small power of 2 and a addend
[09:39:03] <eddyb> *an addend
[09:39:29] <eddyb> that should be cheaper than a real hash function
[09:41:01] *** Quits: doomlord_ (servitor@moz-CA917A47.range86-184.btcentralplus.com) (Quit: Leaving)
[09:41:13] <eddyb> strcat: we need to allow a trait optimization for pure functions with no arguments - store the result in the vtable
[09:41:42] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:41:42] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b7e4f31 to 1429070c3: 02http://git.io/N3iJvQ
[09:41:42] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:41:52] <eddyb> that way Any::type_id will be optimized to loading a value from the vtable
[09:43:44] <eddyb> actually, nevermind, it's faster to return vtables anyway
[09:46:28] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[09:52:10] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:52:10] <ghrust> 01[13rust01] 15thestinger merged 06master into 06snap-stage3: 02http://git.io/CeSI4Q
[09:52:10] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:52:58] *** Joins: rca (rcatolino@moz-63C849F5.adsl.proxad.net)
[09:55:32] *** Quits: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[09:57:56] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[09:59:28] <eddyb> acrichto: https://github.com/mozilla/rust/pull/11561
[09:59:53] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[10:00:58] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[10:01:19] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[10:02:01] <eddyb> test-many.rs:11:38: 11:39 error: expected `,` but found `:`
[10:02:11] <eddyb> dbaupp: lol I didn't think to check outside of a macro
[10:02:21] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[10:03:03] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[10:03:09] <eddyb> dbaupp: the correct version is TypeId::of::<&Add:'static<uint, uint>>(),
[10:04:04] <eddyb> error: instantiating a type parameter with an incompatible type `&'<empty> std::ops::Add<uint,uint>:'static`, which does not fulfill `'static`
[10:04:06] <eddyb> oh come on
[10:04:43] *** Joins: glaebhoerl_ (glaebhoerl@moz-3590251D.kabelnet.hu)
[10:04:48] <eddyb> &'static Foo works
[10:04:58] <eddyb> dbaupp: all that crazyness in the macros wasn't required
[10:05:14] *** Quits: glaebhoerl (glaebhoerl@moz-3590251D.kabelnet.hu) (Ping timeout)
[10:05:55] <eddyb> strcat: ouch....
[10:07:03] <eddyb> I need at least 64 buckets so I can have at most one entry in each bucket
[10:07:12] <eddyb> for just 4 random traits
[10:09:55] <eddyb> ids=~[std::unstable::intrinsics::TypeId{t: 10712292393442107703u64}, std::unstable::intrinsics::TypeId{t: 13717732244219016828u64}, std::unstable::intrinsics::TypeId{t: 11444111970501490298u64}, std::unstable::intrinsics::TypeId{t: 6220178578551897442u64}]
[10:09:56] <eddyb> found bits=3, addend=3, map=~[None, None, Some(std::unstable::intrinsics::TypeId{t: 10712292393442107703u64}), None, None, Some(std::unstable::intrinsics::TypeId{t: 11444111970501490298u64}), None, Some(std::unstable::intrinsics::TypeId{t: 13717732244219016828u64})]
[10:10:03] <eddyb> strcat: hahaha, the addend thing worked :D
[10:10:49] <eddyb> 50% fill is pretty good for a dumb bruteforce
[10:12:20] <eddyb> now if I can run that code during trans, that would be cool
[10:14:27] <eddyb> strcat: so instead of a worst case of 4 branches, I have a constant operation: table[((%0 << 6)  + 24) & 63]
[10:16:21] <eddyb> actually, %1
[10:17:34] <eddyb> strcat: you can even implement Many with a HashMap and dynamically add interfaces to an object
[10:17:42] <eddyb> strcat: pretty C++ can't do that magic trick
[10:17:47] <eddyb> *pretty sure
[10:23:21] <dbaupp> strcat: I was talking about memory overhead, yes
[10:24:19] <dbaupp> eddyb: anyway, smallintmap is just a vector
[10:24:23] <dbaupp> but with a Map interface
[10:24:33] <eddyb> what does it do for empty slots?
[10:24:47] <dbaupp> ah, it's Option<T>
[10:24:52] * dbaupp just checked the source
[10:24:56] <eddyb> I was thinking of a NodeInvalid variant for ast_map::Node
[10:25:03] <eddyb> which wouldn't use extra space
[10:25:19] <dbaupp> in any case, it's much better than HashMap in terms of memory use for linear keys starting from zero
[10:25:23] <dbaupp> yeah that'd work too
[10:26:42] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[10:26:42] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/r5C0eg
[10:26:42] <ghrust> 13rust/06auto 1407c733e 15klutzy: rustc::driver: Capitalize struct Options/Config
[10:26:42] <ghrust> 13rust/06auto 1480ba67e 15klutzy: rustc::metadata: Remove trait FileSearch
[10:26:43] <ghrust> 13rust/06auto 14bf713d6 15klutzy: syntax::ast: Remove/Recover tests...
[10:26:45] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[10:27:52] <eddyb> pcwalton: I'd thank you, but you're not here :P
[10:28:30] <eddyb> dbaupp: so I can copy SmallIntMap for this. or not
[10:29:04] <eddyb> the right name would be LinearMap btw
[10:29:15] <dbaupp> eddyb: yeah, but it's not like it does anything hard to just write yourself
[10:29:51] <eddyb> what's it called... the term used to describe things like shared_ptr that reuse a field instead of wrapping the structure
[10:30:24] <eddyb> anyways, I could have a LinearMapWithDefaultForTheLackOfABetterTerm and require T: Default
[10:30:42] <madmoose> Intrusive?
[10:30:50] <eddyb> IntrusiveLinearMap :D
[10:30:54] <eddyb> madmoose: thanks, that was the word
[10:31:21] *** Quits: sigma (sigma@moz-9EAC972C.range86-184.btcentralplus.com) (Client exited)
[10:32:13] * dbaupp prefers LinearMapWithDefaultForTheLackOfABetterTermFeelFreeToSubmitAPRIfYouHaveABetterNameButItShouldBeAtLeastThisLongAndEnterprisey
[10:32:32] <madmoose> *Factory
[10:32:33] <eddyb> dbaupp, strcat: woo, Many works! https://gist.github.com/eddyb/f828f8ce819a5f00d42d
[10:34:53] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[10:36:50] *** kimundi is now known as zz_kimundi
[10:48:00] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[10:56:21] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[11:00:43] *** Joins: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP)
[11:03:10] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[11:03:31] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:05:14] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[11:09:56] *** Quits: pauls (pauls@moz-7140CF01.ccs.neu.edu) (Ping timeout)
[11:11:19] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[11:13:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[11:15:32] *** Joins: pauls (pauls@moz-7140CF01.ccs.neu.edu)
[11:17:15] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:19:09] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[11:21:42] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[11:21:42] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/5nlmpA
[11:21:42] <ghrust> 13rust/06auto 14e9c30eb 15a_m0d: Mark LineIterator as public so its docs get generated.
[11:21:42] <ghrust> 13rust/06auto 14b970b96 15bors: auto merge of #11556 : am0d/rust/docs, r=huonw
[11:21:42] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[11:21:46] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[11:21:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14dffb76d to 1429070c3: 02http://git.io/N3iJvQ
[11:21:46] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[11:22:31] *** Quits: pauls (pauls@moz-7140CF01.ccs.neu.edu) (Ping timeout)
[11:24:14] *** Joins: sigma (sigma@moz-9EAC972C.range86-184.btcentralplus.com)
[11:36:45] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[11:36:45] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14b970b96 to 1429070c3: 02http://git.io/N3iJvQ
[11:36:45] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[11:36:46] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[11:36:46] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/AV3h6Q
[11:36:46] <ghrust> 13rust/06auto 146232290 15Brian Anderson: extra: Ignore time tests on android correctly
[11:36:46] <ghrust> 13rust/06auto 14b549b08 15bors: auto merge of #11557 : brson/rust/anotherandroidfix, r=thestinger
[11:36:46] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[11:39:44] *** zz_kimundi is now known as kimundi
[11:39:48] *** Joins: pauls (pauls@moz-7140CF01.ccs.neu.edu)
[11:44:30] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:45:57] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:46:32] * strcat has broken sleep functionality
[11:47:15] <dbaupp> strcat: only nanosleep?
[11:48:07] <strcat> mostly just busy-wait
[11:48:25] <dbaupp> not at all power efficient
[11:48:44] <dbaupp> you should file a bug with the library implementers
[11:48:58] <strcat> while not_asleep { if admits_default() { break } }
[11:49:01] <strcat> er
[11:49:03] <strcat> admits_defeat*
[11:49:04] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[11:49:15] <dbaupp> hm, why is there this CleanFunction trait, which is only used once?
[11:49:26] <strcat> because that's Clean code
[11:49:35] <strcat> not to be confused with clean
[11:49:48] <strcat> Clean Industries takes *no* responsibility for any sort of confusion.
[11:50:12] <dbaupp> :/
[11:50:19] <strcat> firefox leaked 2400MiB of memory while I was asleep
[11:50:23] <strcat> or rather the new york times did
[11:50:59] <strcat> stop watching it for 30 minutes and it breaks ;\
[11:51:12] * strcat is curious if you can set per-tab resource limits
[11:51:35] <strcat> um
[11:51:38] <strcat> what happened to the snapshot?
[11:51:40] <strcat> the windows bot
[11:51:42] <strcat> there are like 3 builds
[11:51:55] <strcat> the original one failed but there's a successful one?
[11:53:29] <eddyb> fn assert(x: bool) {if !x {unsafe {::std::unstable::intirnsics::abort()}}}
[11:53:33] <eddyb> *intrinsics
[11:53:48] <dbaupp> strcat: servo probably allows that
[11:53:58] <dbaupp> (it's written in Rust, so must be perfect.)
[11:54:25] <eddyb>   %2 = call %"enum.std::option::Option<&'static ()>[#1]" bitcast (%"enum.std::option::Option<&'static ()>[#1]" (i64*, %"struct.std::unstable::intrinsics::TypeId[#1]")* @"Many$uint::get_vtable_for_trait::h177a64006a2f22d3jIag::v0.0" to %"enum.std::option::Option<&'static ()>[#1]" ({ i64, %tydesc*, i8*, i8*, i8 }*, %"struct.std::unstable::intrinsics::TypeId[#1]")*)({ i64, %tydesc*, i8*, i8*, i8 }* %1, %"struct.std::unstable::intrinsics::
[11:54:26] <eddyb> TypeId[#1]" { i64 -7909541679803924858 })
[11:54:38] <eddyb> okay, so I want to optimize that virtual call
[11:54:58] <eddyb> it's... devirtualized
[11:55:29] <eddyb> strcat: good news, LLVM is smart enough, we just have to figure out how to make it inline a statically resolved function call
[11:55:36] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:55:53] <strcat> smart enough to what? ;p
[11:56:14] <strcat> looks like there's a cast there? it won't be happy
[11:56:18] <strcat> run instcombine on it?
[11:56:33] <strcat> instcombine removes static casts
[11:57:01] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[11:57:21] *** Quits: dbaupp (Thunderbir@moz-6002BAEA.lns20.syd6.internode.on.net) (Ping timeout)
[11:57:23] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:58:32] <eddyb> strcat: can I add it to rust LLVM optimization passes with a flag?
[11:58:44] <strcat> well it runs a dozen times already
[11:58:54] <strcat> I was just thinking that you could try running it again via opt on some IR
[11:59:04] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[11:59:23] <strcat> eddyb: opt -S foo.ll -instcombine | sponge foo.ll ;p
[11:59:32] <strcat> anyway probably won't work
[11:59:52] <eddyb> wtf is sponge?
[12:00:04] <strcat> eddyb: soaks up all input, then writes
[12:00:05] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[12:00:07] <strcat> so it doesn't clobber it
[12:00:09] <strcat> it's in moreutils ;p
[12:00:36] <strcat> if you redirect with something that that, it truncates the file before the start of the pipeline is done
[12:00:38] <strcat> *shrug*
[12:00:46] <strcat> temporary files are for suckers
[12:01:52] *** Joins: dbaupp (Thunderbir@moz-F3F7375F.lns20.syd6.internode.on.net)
[12:02:29] <eddyb> strcat: doesn't remove the bitcast
[12:02:50] <strcat> hm
[12:03:15] <strcat> eddyb: well you could try running inline again... how big is the function?
[12:03:57] <eddyb> strcat: it's basically a switch on its argument returning constant pointers
[12:04:15] <eddyb> a trait method with no arguments gets inlined
[12:04:56] <eddyb> that's weird... a trait method with an argument also gets inlined, so what's different for my function?
[12:04:59] <strcat> eddyb: does -Z lint-llvm yell?
[12:05:08] <strcat> I am not sure that bitcasts like that are valid
[12:05:58] <eddyb> nada
[12:08:51] <eddyb> it's... the return type?
[12:11:01] <eddyb>   %2 = call %"enum.std::option::Option<~int>[#1]" bitcast (%"enum.std::option::Option<~int>[#1]" (i64*)* @main::Foo::foo::h1b4811727db01d8aar::v0.0 to %"enum.std::option::Option<~int>[#1]" ({ i64, %tydesc*, i8*, i8*, i8 }*)*)({ i64, %tydesc*, i8*, i8*, i8 }* %1)
[12:12:00] <eddyb> enum Option<T> {Some(T), None} to remove the bloat
[12:12:27] <eddyb>   %2 = call %"enum.Option<~int>" bitcast (%"enum.Option<~int>" (i64*)* @main::Foo::foo::h857e51a20d21cf88ar::v0.0 to %"enum.Option<~int>" ({ i64, %tydesc*, i8*, i8*, i8 }*)*)({ i64, %tydesc*, i8*, i8*, i8 }* %1)
[12:12:49] <eddyb> strcat: the nullable return type is the problem
[12:13:05] <eddyb> %"enum.Option<~int>" = type { i64* }
[12:14:04] <strcat> I don't get why it's mangled?
[12:15:04] <eddyb> the function only has: ret %"enum.Option<&'static int>" zeroinitializer
[12:15:13] <eddyb> strcat: what is mangled?
[12:16:30] <eddyb> (&'static int because I've changed it to remove the dtor, it still exhibits the same problem)
[12:19:54] <eddyb> strcat: returning ~0 gets devirtualized and dead-store-eliminated, lol
[12:20:05] <eddyb> there's something wrong with a structure type
[12:21:06] <eddyb> strcat: scratch that, it's not nullables
[12:21:54] <eddyb>   %2 = call %struct.Bar bitcast (%struct.Bar (i64*)* @Foo::foo::h9a34dc837e77a8fcas::v0.0 to %struct.Bar ({ i64, %tydesc*, i8*, i8*, i8 }*)*)({ i64, %tydesc*, i8*, i8*, i8 }* %1)
[12:22:01] <eddyb> %struct.Bar = type { i8 }
[12:22:43] <eddyb> so, uhm, it can't bitcast two function types that don't differ in the return type just because the return type is a structure?
[12:23:03] <strcat> eddyb: you removed free glue right? I didn't notice it land ;p, but it's gone!
[12:23:12] <eddyb> yupp, some days ago
[12:23:54] <eddyb> also, wtf is wrong with that type?
[12:24:05] <eddyb> trait pointers have just two elements
[12:24:31] <eddyb> { i64, %tydesc*, i8*, i8*, i8 }* smells of *Box<()>
[12:24:38] <strcat> ;p
[12:24:47] <strcat> eddyb: rust likes using that everywhere
[12:24:55] <strcat> eddyb: did you know, once upon a time, like, everything was a box
[12:24:58] <eddyb> { i64, {}* } is the correct type
[12:25:02] <strcat> eddyb: before unique pointers
[12:25:08] <eddyb> strcat: don't make me puke. reminds me of Haskell
[12:25:08] <strcat> eddyb: before fixed-size vectors
[12:25:13] <strcat> before unique vectors
[12:25:18] <eddyb> except Haskell probably optimizes such dynamic nonsense better
[12:25:19] <strcat> everything was a box! ;p
[12:25:29] <strcat> eddyb: yeah rust was slower than python apparently at one point
[12:25:33] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[12:25:36] <strcat> eddyb: it used dynamic type sizes
[12:25:36] <eddyb>  NO
[12:25:53] <eddyb> strcat: now I need to clean my mind of those thoughts
[12:25:53] <strcat> ;p
[12:26:04] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[12:26:07] <strcat> borrowed pointers are pretty 'recent' ;p
[12:26:14] <strcat> eddyb: you weren't here for modes!
[12:26:30] <eddyb> should I replace opaque_box for traits with something simpler?
[12:26:42] <strcat> eddyb: http://smallcultfollowing.com/babysteps/blog/2011/12/08/why-not-modes/
[12:26:43] <eddyb> anyways, something is wrong with LLVM
[12:27:07] <strcat> back when rust had a move keyword
[12:27:09] <strcat> and copied by default
[12:27:11] <strcat> hm
[12:27:16] <strcat> there was that weird last-use analysis
[12:27:27] <strcat> eddyb: you know clone didn't exist, you had to use 'copy' and it only worked on built-ins
[12:27:29] <strcat> rust was weird.
[12:27:40] <strcat> move keyword *and* copy keyword
[12:27:41] <eddyb> pls no
[12:27:47] <dbaupp> modern rust is less weird
[12:27:49] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[12:27:50] <strcat> and unique strings/vectors were implicitly copied
[12:27:51] <dbaupp> <3 progress
[12:27:59] <eddyb> strcat: staph
[12:28:07] <strcat> lol :)
[12:28:20] <strcat> eddyb: well just think about how much better it can get
[12:28:47] <strcat> eddyb: https://github.com/mozilla/rust/issues/4632 all of these weird things
[12:28:52] * strcat shudders
[12:29:10] <strcat> resource blocks were weird
[12:29:15] <strcat> separate from classes
[12:29:17] <strcat> good old drop blocks
[12:29:37] <strcat> I totally forgot about the <- and <-> operators ;p
[12:29:44] * strcat thought <-> was cute :(
[12:29:47] * dbaupp did too
[12:30:14] <strcat> hm, rust actually had do-while loops
[12:30:20] <strcat> rust has basically tried everything
[12:30:20] <dbaupp> we still do!
[12:30:24] <eddyb> let's test a theory
[12:30:25] <eddyb> extern "C" fn foo(_: uint) -> Bar {Bar(0)} let x: extern "C" fn(*()) -> Bar = unsafe {::std::cast::transmute(foo)}; x();
[12:30:26] <strcat> dbaupp: hm?
[12:30:26] * dbaupp trots out his hack
[12:30:35] <strcat> it even had a ternary operator
[12:30:52] <eddyb> well, x(0 as *());
[12:30:53] <strcat> seriously half the features people will ask for existed and were removed :)
[12:30:54] <dbaupp> strcat: https://gist.github.com/huonw/daaccdd54e03d02fd296
[12:31:13] <strcat> dbaupp: ..... wat?
[12:31:13] <eddyb> %1 = tail call { i64 } bitcast ({ i64 } (i64)* @main::foo::hf1dcf864e25c331daQ::v0.0 to { i64 } ({}*)*)({}* null)
[12:31:20] <strcat> um.
[12:31:25] <dbaupp> strcat: yeah, pretty much everytime someone suggests a feature, pcwalton is able to say "we tried it, but it sucked"
[12:31:25] <strcat> dbaupp: wat
[12:31:27] <eddyb> strcat: oi, I think I was right
[12:31:32] <dbaupp> strcat: \o/ it's amazing
[12:31:39] <strcat> dbaupp: it's terrifying
[12:31:43] <strcat> dbaupp: how did you discover this?
[12:31:47] <dbaupp> strcat: magic
[12:31:47] <strcat> HOW DOES IT WORK? ;p
[12:31:57] <dbaupp> blocks are expressions
[12:32:03] <strcat> well
[12:32:04] <dbaupp> it's just while cond {}
[12:32:08] <strcat> there goes any chance of sleeping
[12:32:09] <dbaupp> with a weird condition
[12:32:13] <strcat> that's going to cause nightmares
[12:32:21] * dbaupp laughs
[12:32:36] <eddyb> strcat: why {i64}? WTF?
[12:32:40] <dbaupp> (laughs evilly)
[12:32:43] <strcat> dbaupp: yeah I see what it is now
[12:32:45] <eddyb> strcat: that structure has an u8 in it
[12:32:58] <strcat> eddyb: *shrug*
[12:33:02] * dbaupp will try to get that into a PR and see if it passes review
[12:33:10] <strcat> eddyb: just be glad the compiler doesn't merge random generics now
[12:33:20] <strcat> type-use... and the normalization pass
[12:33:22] <strcat> ugh
[12:33:38] <eddyb> struct Bar(u8); becomes {i64} with "C" ABI
[12:33:43] <strcat> eddyb: it used to do a pass over generics and normalize pointers -> integers, @mut -> @, etc.
[12:33:59] * strcat remembers that
[12:34:01] <eddyb> strcat: haha, still does something like that in glue
[12:34:03] <strcat> and visit glue wasn't considered
[12:34:05] <strcat> just bounds
[12:34:12] <eddyb> see "simplified glue type"
[12:34:20] <strcat> eddyb: well there was a thing called type_use and it collapsed stuff based on size/alignment
[12:34:27] <strcat> eddyb: if it had no trait bounds
[12:34:31] <strcat> terrifying
[12:34:33] <strcat> eddyb: yeah i know
[12:34:36] <eddyb> I've switched it from i32 (wtf?) to ()
[12:34:38] <strcat> type_use was far worse
[12:34:46] <strcat> it collapsed things with a different repr
[12:34:50] <eddyb> the downside is that symbol names are longer
[12:34:53] <eddyb> (oops)
[12:34:53] <strcat> you'd get segfaults
[12:36:45] <eddyb>   %1 = tail call { i64 } bitcast ({ i64 } (i8*)* @main::foo::h334af7fde00e8730aQ::v0.0 to { i64 } (i64)*)(i64 0)
[12:36:57] <eddyb> that is so bad...
[12:37:46] <eddyb> strcat: I'm confused. it's not the structural return type
[12:38:46] <strcat> bitcasting a fn ptr isn't valid
[12:39:01] <strcat> afaik
[12:39:50] <eddyb> tail call void bitcast (void (i8*)* @main::foo::ha2b756b68425218faQ::v0.0 to void (i64)*)(i64 0)
[12:40:35] <eddyb> strcat: hmpf
[12:40:43] <strcat> eddyb: it should cast arguments or the ret value afaik, not the fn
[12:40:55] <strcat> maybe it's valid but LLVm doesn't know how to optimize it 
[12:41:14] <eddyb> strcat: the function is cast from an opaque load
[12:41:26] <strcat> hm
[12:41:36] <strcat> eddyb: shouldn't it be a ptr cast on the fn ptr?
[12:42:11] <eddyb> strcat: I've seen only bitcast in LLVM bytecode
[12:42:17] <strcat> ah right
[12:42:33] <eddyb> we have a PointerCast, maybe it's underused
[12:42:56] <strcat> we used to get llvm lints about this kind of thing
[12:43:04] <strcat> eddyb: maybe it's obsolete, I dunno
[12:43:10] <strcat> the C API is very crufty
[12:43:21] <dbaupp> does C allow casting function pointers?
[12:43:28] <strcat> dbaupp: yes
[12:43:48] <strcat> dbaupp: C really doesn't care when it comes to this - it's valid to pass too many parameters to a function
[12:43:56] <dbaupp> strcat: wouldn't that be a bitcast at the LLVM level? (if not, what does Clang do?)
[12:43:58] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[12:44:16] <strcat> dbaupp: dunno ;p
[12:44:57] <eddyb> dbaupp: some of these casts work
[12:45:05] <eddyb> that is the weird thing...
[12:45:38] <eddyb> uint <-> *type seems to break it
[12:46:17] <dbaupp> wat
[12:46:18] <eddyb> *ty1 <-> *ty2 in arguments + {ty3} <-> {ty3} in return also breaks it
[12:46:27] <dbaupp> clang -emit-llvm crashes with linking errors on my system
[12:46:42] <eddyb> dbaupp: -S
[12:47:12] <dbaupp> eddyb: magic
[12:47:13] <eddyb> strcat: that is very weird, just the pointer cast in arguments is fine
[12:47:14] <dbaupp> thanks
[12:47:32] <eddyb> dbaupp: -emit-llvm outputs .bc not .ll
[12:47:42] <eddyb> (the latter requires adding -S)
[12:48:33] <eddyb> I guess bitcast is broken. yay
[12:48:41] <eddyb> strcat: fix LLVM pls
[12:49:15] <dbaupp> eddyb: https://gist.github.com/huonw/4e55e917f80d8bd79aa7
[12:49:32] <strcat> eddyb: afaik instcombine is supposed to replace a cast of a fn with argument casts...
[12:49:56] <eddyb> dbaupp: lol, that is just cheating
[12:50:38] <eddyb> nmatsakis: want me a single reason why the env param should die in a fire?
[12:50:52] <eddyb> nmatsakis: because it's the self of Fn. there. can't argue with that
[12:51:21] <eddyb> if only I solved that issue before the meeting, default type params might have been already landed
[12:51:39] <dbaupp> eddyb: your first question doesn't make sense... ?
[12:52:13] <eddyb> dbaupp: I still read it right the third time, lol, silly brain
[12:52:17] <eddyb> *want me to give you
[12:52:56] *** Quits: gwty (gwtypc@C3EE6AF0.BB20A64A.49FF672.IP) (Ping timeout)
[12:54:02] <dbaupp> bleugh "requires <new lang item>" when compiling libstd... no spans or anything
[12:54:03] <dbaupp> :/
[12:54:26] <eddyb> strcat: wait a second, it uses opaque_box where *{} would suffice, that's a bug
[12:54:47] <strcat> eddyb: there's a weird lang="opaque" thing
[12:54:48] <strcat> too
[12:54:49] <eddyb> s/would suffice/would make sense
[12:55:02] <strcat> I don't understand why we need lang="opaque"
[12:55:06] <strcat> makes no sense
[12:56:45] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:56:45] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/AV3h6Q
[12:56:45] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:57:04] <eddyb>   %1 = bitcast i64* %x to {}*
[12:57:06] <eddyb>   %2 = call %struct.Bar bitcast (%struct.Bar (i64*)* @Foo::foo::hf924c01168b38420as::v0.0 to %struct.Bar ({}*)*)({}* %1)
[12:57:09] <eddyb> doesn't work either :/
[12:58:09] <eddyb> nope, not *i8
[12:59:25] <eddyb> strcat: playing with arguments doesn't help, it's the darn return type
[13:00:07] *** Joins: lpy (lpy@7360AA58.F09091A8.1348A864.IP)
[13:01:45] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[13:01:49] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[13:01:49] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/d2uHXw
[13:01:49] <ghrust> 13rust/06auto 14e9c30eb 15a_m0d: Mark LineIterator as public so its docs get generated.
[13:01:49] <ghrust> 13rust/06auto 14180ac0c 15bors: auto merge of #11556 : am0d/rust/docs, r=huonw
[13:01:50] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[13:01:53] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:01:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/POx5Nw
[13:01:53] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:02:13] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[13:04:00] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[13:04:10] <eddyb> strcat: PointerCast is used for loading the method from the vtable
[13:04:49] <strcat> ugh my laptop battery is going to run out
[13:05:14] <eddyb> so instcombine is broken in the latest LLVM?
[13:05:18] <eddyb> (that rust uses)
[13:08:59] <dbaupp> "~@condition::Handler<~str,~str>" ... do conditions really use @ internally?
[13:09:04] <dbaupp> eurgh :(
[13:10:19] <eddyb> kill them
[13:10:42] <eddyb> dbaupp: clang optimizes my testcase at -O1
[13:10:48] <dbaupp> um
[13:10:51] <dbaupp> which testcase?
[13:11:01] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[13:11:10] * dbaupp wasn't actually following the discussion other than seeing "bitcasting functions"
[13:11:19] <dbaupp> eddyb: nah, someone else can do that later
[13:11:31] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[13:11:39] <eddyb> ooh, it doesn't create a structure type
[13:11:56] <eddyb> struct Foo {int x;} => i32 not {i32}
[13:12:18] <eddyb> int x, y; becomes i64? wat?
[13:12:48] <eddyb> dbaupp: I need int x, y, z; to get a structure type :/ %struct.Foo = type { i32, i32, i32 }
[13:13:16] <eddyb> %call = tail call { i64, i32 } bitcast ({ i64, i32 } (i32*)* @_Z3fooPi to { i64, i32 } (i16*)*)(i16* null)
[13:13:18] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[13:13:41] <eddyb> does LLVM support returning larger-than-a-register structures? that's weird
[13:13:58] <dbaupp> Apparently we should be using that for all our types
[13:14:07] <dbaupp> and just let it choose when to use an out pointer
[13:15:53] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:16:49] <eddyb> dbaupp: it still breaks devirtualization because it's a structure type
[13:17:51] <eddyb> removing the out pointer is actually an optimization, because it allows us to construct ADTs by value
[13:18:26] <eddyb> enum & struct ctors would be just one instruction. instead of 5 or more, like Some is right now
[13:18:45] * eddyb gusta
[13:19:18] <eddyb> struct Foo {long x;}; typedef Foo (*FooFn)(short*); Foo foo(int*){return Foo();}int main(){FooFn f = (FooFn)foo; f((short*)0);}
[13:19:41] <eddyb> dbaupp: ^ clang optimizes that at -O1 to a ret void (keep in mind this is C++ which doesn't have (...))
[13:20:02] <eddyb> dbaupp: change long x; to long x, y; and it breaks
[13:21:31] <eddyb> dbaupp: maybe we need to put irc://irc.oftc.net/#llvm in the topic
[13:21:42] <eddyb> I like when I can click things
[13:22:20] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[13:22:20] <ghrust> 01[13rust01] 15thestinger created 06snapshot (+2 new commits): 02http://git.io/pzgIxw
[13:22:20] <ghrust> 13rust/06snapshot 14197fe67 15Daniel Micay: register snapshots
[13:22:20] <ghrust> 13rust/06snapshot 1429840ad 15Daniel Micay: remove the concept of managed-unique from libstd...
[13:22:21] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[13:23:19] *** Quits: lpy (lpy@7360AA58.F09091A8.1348A864.IP) (Client exited)
[13:24:15] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[13:24:48] <strcat> dbaupp: https://github.com/mozilla/rust/pull/11565 r? acrichto already reviewed the 2nd commit
[13:24:59] <strcat> anyway laptop battery has 3 minutes left so...
[13:25:06] <eddyb> strcat: I just exposed the problem in #llvm
[13:26:58] <dbaupp> strcat: yay
[13:27:25] <eddyb> and nobody is talking there...
[13:27:42] <dbaupp> say it louder, so they can hear you
[13:28:05] <strcat> eddyb: they are probably mostly in california too..
[13:28:33] <eddyb> strcat: it's hard to remember how wide US is
[13:29:40] <strcat> Battery 0: Discharging, 0%,  remaining
[13:29:43] <dbaupp> it's this wide: [----------------]
[13:29:47] <dbaupp> strcat: bye o/
[13:29:51] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[13:43:42] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[13:48:32] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[13:55:15] <eddyb> dbaupp: wtf... there is no instcombine casts of fn ptrs
[13:55:20] <eddyb> it's.... not there
[13:57:11] <dbaupp> eddyb: do you happen to know why make_free_glue for ~SomeStruct is being passed ~() as the type?
[14:07:23] <eddyb> dbaupp: Ctrl+F "simplified"
[14:07:40] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[14:13:32] <eddyb> oh, I missed this http://llvmweekly.org/issue/2
[14:20:27] *** Quits: luz (lucy@moz-CD18B14B.customer.cdi.no) (Connection reset by peer)
[14:21:41] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:21:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/d2uHXw
[14:21:42] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:24:04] *** Joins: jdm (jdm@CC0122E6.8F96AEA7.2D179A7D.IP)
[14:25:12] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[14:26:40] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:26:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/CYeKPQ
[14:26:40] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:26:40] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:26:41] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Y6kAQw
[14:26:41] <ghrust> 13rust/06auto 147ca3bea 15Eduard Burtescu: libstd: Added more #[inline] annotations and replaced uses of `libc::abort` with the intrinsic.
[14:26:41] <ghrust> 13rust/06auto 147bebdbd 15bors: auto merge of #11561 : eddyb/rust/moar-inlines, r=pcwalton
[14:26:41] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:31:37] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[14:32:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[14:35:20] <eddyb> [16:34] <j`ey_w> eddyb: "return false; // TODO: Handle multiple return values." :P
[14:35:30] <eddyb> dbaupp: ^^ you've got to be kidding me
[14:39:02] *** Quits: sigma (sigma@moz-9EAC972C.range86-184.btcentralplus.com) (Client exited)
[14:39:06] *** Joins: sigma (sigma@moz-9EAC972C.range86-184.btcentralplus.com)
[14:40:00] <eddyb> dbaupp: src/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp, transformConstExprCastCall
[14:40:19] <eddyb> dbaupp: the check for an unimplemented struct type is outside the "if types differ", lol
[14:54:09] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[14:58:37] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[14:59:07] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[15:00:53] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[15:04:24] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[15:06:52] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[15:11:01] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[15:11:08] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[15:11:08] *** ChanServ sets mode: +ao dherman dherman
[15:13:42] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[15:18:21] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[15:32:40] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[15:39:21] <bstrie> so... weird question
[15:39:32] <bstrie> what do we actually use the `char` type for, in practice?
[15:39:45] <bstrie> I'm having a hard time thinking of a situation where it's useful
[15:39:47] <cmr> the type of 'f' literals
[15:39:49] <cmr> :P
[15:40:05] <eddyb> do we need to type it?
[15:40:15] <eddyb> what if we do that lang-item thing?
[15:40:33] <cmr> 'f' needs a type.
[15:40:34] <eddyb> #[lang="code_point"] struct CodePoint;
[15:40:39] <bstrie> cmr: does it?
[15:40:48] <cmr> everything needs a type!
[15:41:01] <bstrie> not if we removed char literals for not being useful
[15:41:03] <eddyb> cmr: sure. it doesn't have to have a name *within the language*
[15:41:04] <bstrie> what I'm asking is
[15:41:10] <bstrie> for you to convince me that they're useful
[15:41:15] <cmr> oh
[15:41:17] <cmr> I hate strings
[15:41:23] <cmr> I think we should remove everything related to them
[15:41:24] <SiegeLord> How would you build up a string one charcter at a time?
[15:41:38] * cmr is wrong person to ask
[15:41:41] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[15:41:41] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Y6kAQw
[15:41:41] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[15:41:45] <bstrie> SiegeLord: define a "character"
[15:41:53] <eddyb> bstrie: me and strcat wanted at some point to move all primitives into the library, with a trick like #[lang="uint"] struct uint;
[15:41:53] <SiegeLord> Unicode code point
[15:42:24] <eddyb> bstrie: then 'a' would have the type std::unstable::lang::CodePoint or whatever
[15:42:51] <eddyb> if you wanted to - you could put it anywhere and name it anyhow
[15:43:17] <bstrie> SiegeLord: if you're building strings one code point at a time, then you're getting input dynamically and can't use literals. so you're just as well off using a u32 and testing for unicode compliance
[15:43:31] <cmr> (std::char::from_u32)
[15:43:32] <SiegeLord> u32 is an unsigned int
[15:43:41] <SiegeLord> char is not an unsigned int
[15:43:51] <SiegeLord> It happens to be the same size, but it's different semantically
[15:43:59] <bstrie> how is it different
[15:44:12] <bstrie> it just tests that it's a valid unicode codepoint
[15:44:18] <cmr> char is 21 bits and has specified valid ranges.
[15:44:40] <bstrie> in what ways is it 21 bits in practice
[15:45:05] <cmr> well it's not in practice, but that's how it's defined.
[15:45:14] <cmr> it's padded out to a u32 of course
[15:45:31] <bstrie> let foo: u32 = get_a_single_char_why_not(); foo.is_unicode_codepoint();
[15:45:42] <SiegeLord> Why have ~str then?
[15:45:52] <cmr> ok, and if you are using u32 instead of char you're no longer typesafe.
[15:45:53] <SiegeLord> Just use [u8] and .is_valid_utf8_string()
[15:46:10] <SiegeLord> Why have type safety at all... is_valid_type() :P
[15:46:13] <bstrie> cmr: SiegeLord's usecase is that you're building up a strign anyway
[15:46:33] <bstrie> you're getting a single character at a time from a buffer
[15:46:38] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[15:46:38] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MFKLsw
[15:46:38] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[15:46:39] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[15:46:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/DiKezA
[15:46:39] <ghrust> 13rust/06auto 148e5f068 15a_m0d: Fix formatting in rust-guide document.
[15:46:39] <ghrust> 13rust/06auto 147232dbf 15bors: auto merge of #11564 : am0d/rust/dox, r=huonw...
[15:46:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[15:47:24] <bstrie> or rather, a single code point at a time from a buffer
[15:47:54] <SiegeLord> I get it from a C library as a 32 bit integer
[15:48:02] <SiegeLord> Sure, I could validate it... but it's a formality
[15:48:39] <bstrie> I'm still not hearing any argument as to how `char` is actually used
[15:48:43] <bstrie> I want to see some code that uses it
[15:48:46] *** kimundi is now known as zz_kimundi
[15:49:14] <cmr> the lexer is based on a char stream
[15:49:49] <SiegeLord> https://github.com/SiegeLord/RustAllegro/blob/master/src/allegro/internal/events.rs#L286
[15:50:17] <SiegeLord> https://github.com/SiegeLord/RustAllegro/blob/master/src/allegro/internal/events.rs#L176
[15:51:41] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[15:51:42] *** Quits: jdm (jdm@CC0122E6.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[15:53:23] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[15:54:54] <bstrie> that's fair then
[15:55:45] <bstrie> I'm just looking at this mailing list thread requesting ascii character literals and wondering if people really aren't just expecting chars to be what C thinks chars are
[15:55:58] <bstrie> which is terrible, but still
[15:56:06] <SiegeLord> The alternative in that case would be to encode it in a statically allocated string, which isn't possible atm
[15:56:20] <SiegeLord> I think macros should just work in the match arms :P
[15:56:24] <bstrie> me too
[15:56:31] <SiegeLord> It's also useful for the bytes! macro
[15:56:41] <bstrie> that seems like a better solution than baking in ascii character literals
[15:56:55] <eddyb> struct CodePoint {priv value: u32}; maybe?
[15:57:10] <eddyb> but then character literals don't have a type
[16:03:04] <eddyb> cmr, dbaupp, acrichto: this entire function (containg 7 virtual calls) is optimized to ret void: https://gist.github.com/eddyb/f828f8ce819a5f00d42d#file-many-rs-L73-L85
[16:05:12] <acrichto> eddyb: nice!
[16:06:06] <eddyb> acrichto: I should prepare the LLVM patch instead of explaining the issue again, look in #rust for me talking about LLVM to cmr, if you're curious
[16:06:27] <eddyb> I'm now testing to see if it improves devirtualization in format!
[16:11:03] <eddyb> acrichto: why is @fmt::format_unsafe::h1d4f9ee6de49946faS::v0.9 not inlined, not even with LTO?
[16:12:02] <acrichto> I guess LLVM just thinks it shouldn't be inlined?
[16:15:33] <eddyb> gaah, I broke my local master
[16:15:38] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[16:15:38] *** ChanServ sets mode: +ao pcwalton pcwalton
[16:15:49] <eddyb> I pulled from origin instead of parent
[16:16:05] <eddyb> pcwalton: thanks for the r+ :D
[16:16:18] <pcwalton> eddyb: no problem, thanks for the PR :)
[16:16:41] <pcwalton> dunno if you saw you were the friend of the tree this week
[16:17:06] <eddyb> pcwalton: yupp :D. you guys are too nice :P
[16:17:10] <pcwalton> :)
[16:17:37] <pcwalton> "friend of the tree" is a mozilla tradition
[16:17:38] <eddyb> now, how do I do "git pull --rebase parent master" with a broken local master?
[16:18:09] <eddyb> wait, I know, I can go back a thousand commits :D
[16:18:53] <eddyb> git reset --hard HEAD~100
[16:18:58] <SiegeLord> Nothing a trip to the reflog can't fix
[16:19:32] <eddyb> "error: The following untracked working tree files would be overwritten by checkout:"
[16:19:38] <eddyb> of course...
[16:21:15] <eddyb> aaaand rebase worked :D
[16:21:26] *** zz_kimundi is now known as kimundi
[16:21:34] <eddyb> pcwalton: a tradition? tell me more :)
[16:22:02] <pcwalton> well, there's been a friend of the tree weekly for Firefox as long as I can remember
[16:22:06] <pcwalton> so I figured we'd do it for Rust as well
[16:26:35] <eddyb> llvm[2]: Compiling YAMLParser.cpp for Release+Asserts build
[16:26:40] <eddyb> well, that's surprising
[16:31:27] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[16:31:38] *** Quits: Kxepal (Miranda@moz-C762CEEA.pppoe.mtu-net.ru) (Ping timeout)
[16:34:17] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[16:35:07] *** Joins: Kxepal (Miranda@moz-EEB2B0E3.pppoe.mtu-net.ru)
[16:35:09] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[16:39:05] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[16:44:57] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Quit: Leaving...)
[16:45:52] *** Quits: glaebhoerl_ (glaebhoerl@moz-3590251D.kabelnet.hu) (Ping timeout)
[16:50:01] <nmatsakis> eddyb: 
[16:50:05] <nmatsakis> oops.
[16:50:16] <eddyb> heh
[16:50:22] <nmatsakis> congrats btw ;)
[16:50:22] <eddyb> hi to you too
[16:50:34] <eddyb> nmatsakis: on the friend of the tree? thanks :)
[16:50:40] <eddyb> do we have a make check-llvm?
[16:50:53] <eddyb> I want to run just one LLVM test and it needs a file generated on the first run
[16:51:03] <nmatsakis> I did want to discuss env pointers with you, though I've been busy this morning, I saw you pinged me at one point.
[16:51:37] <nmatsakis> pcwalton: btw, I'm not sure if we can avoid using inference to influence temporary lifetimes. well, we *can*, but porting some of the tests is really painful
[16:51:50] <nmatsakis> actually rustc as a whole compiles just fine with the syntactic rules I ended up with
[16:52:04] *** Joins: gwty (gwtypc@3CBAFE29.10600D12.137C914F.IP)
[16:52:22] <eddyb> nmatsakis: oh yeah, I want to see you defend the env param when it's moved to the self of the Fn trait
[16:52:46] <eddyb> which is the natural transition we're hoping for
[16:53:15] <eddyb> I should've thought of that yesterday. one week wasted just because I can't argue a point
[16:53:33] <nmatsakis> eddyb: one week?
[16:54:04] <eddyb> nmatsakis: env param pretty much wasted this week's meeting
[16:54:14] <nmatsakis> It's an interesting point. I hadn't thought too much about closures-as-objects, maybe that affects the calculs.
[16:54:24] <eddyb> but hey, I get to fix devirtualization in LLVM in the meanwhile
[16:55:26] <eddyb> nmatsakis: https://gist.github.com/eddyb/f828f8ce819a5f00d42d#file-many-rs-L72-L84 this gets optimized with ret void, with my LLVM change (there's 7 virtual calls in there. oh, wait, I'm wrong, 7 + 3 virtual calls)
[16:55:50] <eddyb> you might find the whole Many thing interesting, if you ignore the macro magic used to implement it
[16:55:54] <nmatsakis> eddyb: unfortunately I've got a meeting now and ... then a bunch more. if I get a spare hour in there I'll ping you, but I'll think about the Fn trait in the meantime
[16:56:06] <nmatsakis> that looks cool tho
[16:56:09] <eddyb> oh, okay, have fun... meeting
[16:56:42] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[16:56:42] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DiKezA
[16:56:42] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[16:56:49] <eddyb> make: *** No rule to make target `llvm-check'.  Stop.
[16:59:07] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[16:59:08] *** ChanServ sets mode: +qo brson brson
[16:59:25] <pcwalton> nmatsakis: if rustc compiles let's see how long we can hold out
[16:59:49] <nmatsakis> pcwalton: I have to rewrite a whole bunch of the tests in libstd, basically...
[17:00:00] <nmatsakis> I'll see how long it takes
[17:00:04] <pcwalton> it's probably not as painful as de-@muting ;)
[17:00:17] <eddyb> pcwalton: about that, you missed borrow_* lang items
[17:00:28] <pcwalton> yeah, I know
[17:00:30] <pcwalton> I left them in for stage0
[17:00:33] <pcwalton> but I think it's been snapshotted
[17:00:43] <eddyb> come to think of it, all of them should be gone since there's nothing dynamic left around
[17:00:48] <eddyb> pcwalton: yay more code to remove :D
[17:00:56] *** Joins: jensnockert (jensnocker@moz-272EFCE5.wireless.lu.se)
[17:01:01] <eddyb> somehow that feels more rewarding than writing new code
[17:01:57] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[17:01:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/t42Z6g
[17:01:57] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[17:01:58] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[17:01:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bLtYWg
[17:01:58] <ghrust> 13rust/06auto 14f3d33fa 15Alex Crichton: Allow more "error" values in try_recv()...
[17:01:58] <ghrust> 13rust/06auto 147806a11 15bors: auto merge of #11112 : alexcrichton/rust/issue-11087, r=brson...
[17:01:58] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[17:02:40] *** Quits: jensnockert (jensnocker@moz-272EFCE5.wireless.lu.se) (Connection reset by peer)
[17:03:02] *** Joins: jensnockert (jensnocker@moz-272EFCE5.wireless.lu.se)
[17:07:47] <eddyb> nmatsakis: I'm tempted to go ahead and implement ImmDeref
[17:08:20] <eddyb> because I want to try something and ast::P is the perfect insertion point, but I don't have smart pointer magic :(
[17:09:15] <nmatsakis> eddyb: I'd be interested to work with you on that
[17:09:40] <nmatsakis> it's probably not too hard, really
[17:09:50] <eddyb> hence, tempted
[17:10:00] <nmatsakis> I don't know, haven't given it a lot of deep thought. I guess it'll touch a lot of things.
[17:10:05] <nmatsakis> we'll have to generalize adjustments to be sure
[17:10:06] <eddyb> but I have 4-5 fronts in rustc alone :/
[17:10:11] <nmatsakis> I know the feeling
[17:10:16] <nmatsakis> I'm trying to just land my outstanding branches atm :)
[17:10:54] <eddyb> now I'm testing inlining the format_unsafe helper, maybe we can get dead-store-elision on format!("boo")
[17:11:15] <eddyb> acrichto: -j2 compiles libgreen and libnative in parallel <3
[17:11:21] <acrichto> and librustuv!
[17:11:38] <eddyb> -j4 is too much for LLVM
[17:13:14] <eddyb>   %2 = call fastcc { i64, i64, [0 x i8] }* @fmt::format::h040ad6e69669f5f6aR::v0.0(%"struct.std::fmt::Arguments[#1]"* %__args)
[17:13:18] <eddyb> >_>
[17:14:59] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[17:16:04] <eddyb> oh, of course, it's not inlined because it's fat. it's fat because exception handling
[17:16:19] <eddyb> invoke fastcc void @fmt::Formatter::run::h0456a1f6ed5da3e8msa0::v0.9(%"struct.std::fmt::Formatter[#1]"* %formatter.i.i, %"enum.std::fmt::rt::Piece[#1]"* %.sroa.0.0.load68.i.i, % "enum.option::Option<&'static str>"* %33)
[17:17:54] <eddyb> acrichto: this is too much for LLVM to inline, which makes it hard to devirtualize :(
[17:18:31] <eddyb> how many Writers do we have, really? I'll try to make it generic now
[17:19:32] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[17:19:44] *** Joins: dherman (dherman@moz-BBE3ABD.mv.mozilla.com)
[17:19:44] *** ChanServ sets mode: +ao dherman dherman
[17:19:44] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[17:22:34] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[17:23:08] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[17:31:40] <eddyb> error: mismatched types: expected `&mut <V18>` but found `&mut io::Writer<no-bounds>`
[17:32:25] <eddyb> I hate that... can't define a generic that takes either a &T:Trait or a &Trait
[17:32:37] <eddyb> even with DST, you have to mark the type as unsized :(
[17:33:35] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[17:35:44] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[17:38:58] <SiegeLord> I don't think that can work, as there are some things you can call on a type implementing the trait but not the trait object
[17:41:19] <eddyb> SiegeLord: yeah... I don't know...
[17:42:22] <SiegeLord> In this case, it'd be nice if &Writer implemented Writer
[17:43:52] <eddyb> pub trait Unsigned { fn fmt(&Self, &mut Formatter); }
[17:43:56] <eddyb> .... wut?
[17:44:05] <SiegeLord> Somebody should add a #[deriving()] for that :P
[17:44:12] <nmatsakis> SiegeLord: it will, with unsized, more-or-less
[17:44:14] <eddyb> why does it have &Self there?
[17:44:19] <nmatsakis> er, with DST
[17:44:37] <eddyb> something takes the address of Unsigned::fmt... how does that work?
[17:44:46] <SiegeLord> nmatsakis: I don't quite see how DST comes into it. What if you have a method with Self?
[17:45:23] <eddyb> SiegeLord: maybe if the trait doesn't have such methods, it can be allowed?
[17:45:34] <nmatsakis> SiegeLord: basically then you wouldn't be able to make an object
[17:45:37] <SiegeLord> Well yes, but that's nothing to do with DST
[17:45:57] <nmatsakis> SiegeLord: or else Writer objects do not implement the Writer trait, either one.
[17:45:59] <SiegeLord> That used to work a few months ago, before I think you, nmatsakis, removed it
[17:46:39] <SiegeLord> The proposed remplacement was a trait to make the derivation automatic, and work through the existing typesystem checks
[17:46:47] <nmatsakis> SiegeLord: sorry, in meeting, probably shouldn't have waded in ;) but short version is that we can make it more automatic with DSt.
[17:46:53] <nmatsakis> subject to fundamental limitations
[17:46:58] <SiegeLord> That'd be cool
[17:47:11] <eddyb> so it's a static method...
[17:47:21] <SiegeLord> It'd be super awesome to have an easy way to opt out of template bloat
[17:47:23] <eddyb> with the first type being &Self
[17:47:55] <eddyb> I'm trying to understand how let f = Unsigned::fmt; is possible, given the above trait definition
[17:48:53] <eddyb> haha, I see, it specializes with inference. smart
[17:51:51] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:51:51] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147806a11 to 147232dbf: 02http://git.io/N3iJvQ
[17:51:51] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:53:46] <eddyb> with_task_stdout eww. EWWWWWW
[17:54:58] <eddyb> acrichto: I hate all these ugly ugly hacks in libstd :(
[17:56:36] <eddyb> which make it close to impossible to have a generic std::fmt
[17:57:00] <eddyb> I mean, it's kind of okay until you meet with_task_stdout
[18:00:03] <eddyb> acrichto: oh, hey, println!("foobar") is designed to work even without a Task
[18:00:31] <eddyb> at least that's cool, outputting without libgreen nor libnative
[18:02:54] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[18:03:36] <eddyb> acrichto: does Task need to hold a ~Write for stdout?
[18:05:04] <eddyb> // FIXME #8302: Dear diary. I'm so tired and confused. There's some interaction in rustc between the box  annihilator and the TLS dtor by which TLS is  accessed from annihilated box dtors *after* TLS is  destroyed.
[18:05:18] <eddyb> why do I even bother?
[18:12:00] *** Quits: gwty (gwtypc@3CBAFE29.10600D12.137C914F.IP) (Connection reset by peer)
[18:12:54] <eddyb> I need to implement a WriterMaybeIndirect trait or something. idk
[18:13:10] <eddyb> acrichto: I hate the current situation
[18:13:41] <eddyb> I'd rather have Writer contain a formatter helper
[18:14:26] <eddyb> time to roll back my attempt at least get the LLVM patch sent
[18:14:47] *** Joins: gwty (gwtypc@77D2A3.3F98A9B1.CF29F6CE.IP)
[18:15:29] *** Joins: tikue (tkuehn@moz-A5B0D32.lightspeed.plalca.sbcglobal.net)
[18:15:40] <eddyb> this has no hope while Task is virtual
[18:16:43] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[18:25:58] *** Quits: Kroisse (Kroisse@7CF4064D.E3B51CAE.ECA1BB11.IP) (Ping timeout)
[18:26:51] *** Quits: tikue (tkuehn@moz-A5B0D32.lightspeed.plalca.sbcglobal.net) (Quit: tikue)
[18:29:33] *** Joins: Kroisse (Kroisse@7CF4064D.E3B51CAE.ECA1BB11.IP)
[18:33:20] <acrichto> eddyb: libstd isn't designed for inlineability right now, but that doesn't mean it can't change
[18:33:32] <acrichto> eddyb: I think it's unreasonable to think that println!() will become write()
[18:33:46] <acrichto> there's just a *lot* of stuff that's gotta happen
[18:33:52] <eddyb> is it unreasonable to hope?
[18:34:17] <eddyb> acrichto: at least I know that print("foo") is a reduced testcase
[18:35:33] <acrichto> eddyb: you don't know where the ~Writer goes to
[18:35:40] <acrichto> you can have any ~Writer for the local stdout
[18:35:55] <acrichto> I think the best hope is to get optimized to writer.write(bytes!("foo"))
[18:37:43] <eddyb> one way to fix format would be to go through the writer, and a default method on the writer would call to fmt, with Self as a type param... but then you have to make Arguments work for... gaah this is annoying
[18:39:48] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[18:46:03] <eddyb> acrichto: so native::setup + std::io::stdio::stdout() should be inlineable
[18:46:16] <eddyb> maybe it needs TBAA
[18:46:19] <acrichto> perhaps yeah
[18:46:34] <acrichto> write!(&mut stdout(), "wut")
[18:46:42] <acrichto> that may be devirtualizeable
[18:48:54] <eddyb> I would be happy to make stdout() return a constant
[18:50:24] <eddyb> acrichto: does that require touching task-local data at all?
[18:50:34] <eddyb> because that's... behind SipHash, seeded from /dev/urandom
[18:52:41] <eddyb> acrichto: dedication for you: for i in range(0, 666) {do spawn {println!("rt loves me{}", if i % 2 == 0 {""} else {"not"})}}
[18:53:11] <eddyb> because just saying "I love and hate Rust at the same time" would be mean
[18:59:23] *** Joins: geoffhill (geoffhill@moz-738DC0DB.org)
[18:59:49] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[18:59:49] *** ChanServ sets mode: +o tjc
[19:02:44] <eddyb> hmm, here's an idea... ast_map::Paths can be annoyingly expensive to construct - so why not provide a PathElem and a parent ID?
[19:03:19] <nmatsakis> pcwalton: ok, I found a way to get the tests to compile without a ton of hand editing and without clever inference...
[19:03:27] <eddyb> then, whenever necessary, the actual path can be constructed, going backwards.
[19:04:20] <eddyb> we can use my stack-abusing trick to allocate the right size vector so it doesn't require unshifting
[19:04:42] <eddyb> nmatsakis: do tell :D
[19:05:03] <pcwalton> nmatsakis: oh cool
[19:06:13] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[19:06:30] <nmatsakis> pcwalton: we may ultimately want to add inference, idk, but in any case I'd like to land the syntactic rules I've got now and write up a post describing the limitations, I've designed it such that we could easily change the rules to incorporate inference if we wanted...
[19:07:01] <pcwalton> sounds good
[19:07:02] <nmatsakis> eddyb: problem is that some code that used to work with the old ad-hoc rules governing temporary lifetimes wasn't working with more structured rules, and I didn't see any way to make rules that would make it work...
[19:07:12] <nmatsakis> but because all the values in question were actually arrays of static bytes,
[19:07:22] <nmatsakis> I just did a hack to get them into static data instead of being on the stack,
[19:07:27] <nmatsakis> so that solves that.
[19:07:31] <nmatsakis> for these tests, anyhow :)
[19:08:07] <eddyb> nmatsakis: clang puts structural constants in static memory
[19:08:47] <eddyb> so it's not a bad hack, as long as it doesn't break anything
[19:08:53] <nmatsakis> eddyb: yes, I was thinking that we could easily change so that things like &[22, 44, 66] always have static lifetime, but I don't want to take that work on in this PR, and we'd have to decide the precise rules for that.
[19:09:00] <nmatsakis> in this case, I did it in the test case itself,
[19:09:02] <nmatsakis> since it was using a macro,
[19:09:13] <nmatsakis> the macro just expands to { static foo: &'static [u8] = ...; foo }
[19:09:16] <eddyb> I know that format_args! produces code like that
[19:09:45] <eddyb> except that requires CTFE
[19:10:17] <eddyb> (it calls std::fmt functions. though those functions don't do much, they could be inlined manually)
[19:15:31] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Input/output error)
[19:16:48] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:16:48] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/GicdSA
[19:16:48] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:17:18] <eddyb> hah, kde4 asks me for my gmail password when using a similar config to this (but without my password in ~/.gitconfig) http://llvm.org/docs/GettingStarted.html#sending-patches-with-git
[19:18:18] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[19:18:43] <eddyb> now if only I knew what path to use for my gmail Drafts folder...
[19:21:46] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[19:21:46] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/235flQ
[19:21:46] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[19:21:47] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[19:21:47] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/L1o0Vw
[19:21:47] <ghrust> 13rust/06auto 14f40d5b1 15Daniel Micay: add an experimental tag for Gc<T> due to cycles...
[19:21:47] <ghrust> 13rust/06auto 14f60d937 15bors: auto merge of #11543 : thestinger/rust/gc, r=cmr...
[19:21:47] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[19:22:26] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[19:26:03] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[19:27:54] *** Joins: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net)
[19:30:40] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Ping timeout)
[19:32:46] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[19:33:58] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[19:34:42] <eddyb> yay for localization
[19:37:12] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[19:46:59] <eddyb> acrichto, pcwalton: http://lists.cs.uiuc.edu/pipermail/llvm-commits/Week-of-Mon-20140113/201613.html
[19:47:23] <acrichto> eddyb: is that commited now?
[19:47:39] <acrichto> oh I see just a path
[19:47:42] <acrichto> but still, nice!
[19:47:48] <eddyb> acrichto: just sent it to the ML
[19:48:22] <eddyb> it's a tiny patch with some interesting implications for us
[19:48:33] <eddyb> too bad I can't tell what changed in the grand scheme of rusty things
[19:48:41] <acrichto> so what does that do for us?
[19:49:03] <acrichto> does that help us in devirtualization?
[19:49:06] <eddyb> yupp
[19:49:09] <acrichto> how so?
[19:49:14] * acrichto understands little of llvm optimizations
[19:49:23] <eddyb> basically anything that isn't a primitive type has a structural LLVM type
[19:50:00] <acrichto> so in that test case
[19:50:04] <acrichto> today it doesn't optimize away the call
[19:50:10] <acrichto> or it doesn't inline it, that is
[19:50:21] <eddyb> acrichto: the bitcast is the issue
[19:50:39] <acrichto> ah so it doesn't look through to the bitcast?
[19:50:46] <eddyb> if it had a structural return type (which would happen in most non-primitive cases for us), it just gave up
[19:50:49] *** Joins: glaebhoerl_ (glaebhoerl@moz-B5B88D72.catv.broadband.hu)
[19:51:01] <acrichto> ah interesting!
[19:51:05] <eddyb> it didn't even check to see if those structural types were identical
[19:51:06] <acrichto> nice find
[19:51:24] <eddyb> well, I only found the issue, someone in #llvm found the TODO :P
[19:51:48] <eddyb> (they said tests don't fail if it's removed, but who knows what it could break)
[19:52:33] <eddyb> acrichto: but it got this close in devirtualization because the fat pointer was constructed in the same stack frame
[19:53:44] <eddyb> I don't really know what traits I could test this with
[19:56:38] <cmr> eddyb: so are we actually going to lose the env ptr?
[19:56:50] <cmr> I can't tell from the mtg notes
[19:57:37] <eddyb> cmr: I found a pretty solid argument. sorry it wasn't in time to stop the time wasting discussion
[19:58:43] <eddyb> if you model closures using anonymous types and traits, there's no place for an env pointer, it's just a... trait
[19:59:05] <cmr> the env ptr is self?
[19:59:09] <eddyb> mhmm
[19:59:19] <cmr> right
[19:59:27] <cmr> that was a statement-question :p
[20:01:18] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[20:01:54] *** Joins: Jesse (jruderman@moz-BBE3ABD.mv.mozilla.com)
[20:05:34] *** Quits: jensnockert (jensnocker@moz-272EFCE5.wireless.lu.se) (Input/output error)
[20:06:06] *** Joins: jensnockert (jensnocker@moz-272EFCE5.wireless.lu.se)
[20:06:38] <eddyb> acrichto: what happened to the fake structs? https://github.com/mozilla/rust/pull/11409#issuecomment-31962261
[20:06:43] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[20:07:18] *** Joins: nrc|afk (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[20:07:54] *** Quits: jensnockert (jensnocker@moz-272EFCE5.wireless.lu.se) (Ping timeout)
[20:08:38] *** Quits: dherman (dherman@moz-BBE3ABD.mv.mozilla.com) (Quit: dherman)
[20:20:03] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[20:21:23] *** jld is now known as jld|lunch
[20:26:09] <acrichto> eddyb: no consensus was ever reached on that
[20:26:22] <acrichto> we talked about it briefly in the meeting
[20:26:32] <acrichto> and I got the feeling that fake structs are just overkill
[20:26:42] <eddyb> acrichto: did you initially implement it with fake structs?
[20:26:47] <acrichto> not yet, no
[20:27:06] <eddyb> ah, okay then
[20:27:29] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[20:27:32] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:27:33] *** ChanServ sets mode: +qo brson brson
[20:29:32] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:32:12] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:32:12] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/L1o0Vw
[20:32:12] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:35:10] <bstrie> so enlighten me, why are closures effectively &mut rather than just & ?
[20:35:20] <bstrie> is it because they can mutate the things in their environment?
[20:35:30] <eddyb> bstrie: kinda. it's a tricky subject
[20:35:39] <eddyb> they do break aliasing rules AFAIK
[20:35:55] <bstrie> what I'm actually curious about is whether a closure that didn't close over anything at all could be considered & rather than &mut
[20:36:06] <bstrie> i.e. just be a convenient notation for anonymous functions
[20:36:13] <eddyb> bstrie: it would be &'static Fn
[20:36:40] <eddyb> like struct Foo; impl Fn for Foo {fn call(....
[20:36:51] <eddyb> it's interesting that you raise the issue, though... I'm not sure
[20:37:00] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[20:37:00] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/G4IsHg
[20:37:00] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[20:37:01] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[20:37:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/v2gWbg
[20:37:01] <ghrust> 13rust/06auto 14adb895a 15Alex Crichton: Allow more "error" values in try_recv()...
[20:37:01] <ghrust> 13rust/06auto 147ce3386 15bors: auto merge of #11112 : alexcrichton/rust/issue-11087, r=brson...
[20:37:02] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[20:37:51] <eddyb> bstrie: you might think of closures as doing mutability trickerly like RefCell...
[20:38:25] <bstrie> eddyb: I ask because someone needed help writing a function that looked like the following: https://gist.github.com/bstrie/8443947
[20:38:59] <bstrie> eddyb: in the original version they weren't returning the function out of the recursive function, and because it got moved deeper into the stack it couldn't divide and conquer
[20:39:22] <bstrie> so you either have to define a named function, or do dumb stuff like this
[20:39:28] <eddyb> wait, what, does that compile?
[20:39:35] <bstrie> eddyb: that program compiles, yes :)
[20:39:48] <eddyb> so... why does it return a closure?
[20:39:54] <bstrie> as I said, originally `integral` was just returning the f32, not a tuple of f32 and the function
[20:39:59] <eddyb> can the closure ever change?
[20:40:12] <bstrie> eddyb: no, the closure never changes
[20:40:21] <bstrie> it doesn't close over anything
[20:40:24] <eddyb> then it can be passed down, no?
[20:40:37] <eddyb> bstrie: 'static || doesn't close over anything, it has similar properties to a bare fn
[20:40:54] <bstrie> eddyb: when you call the first `integral` on line 6, the function gets moved into it
[20:41:06] <bstrie> making the second call to `integral` on line 7 a "using moved value" error
[20:41:09] <eddyb> closures... move?
[20:41:12] <bstrie> apparently
[20:41:27] <eddyb> what happens if you replace 'a with 'static?
[20:41:32] <bstrie> I wasn't aware of 'static
[20:41:49] <eddyb> that is geniunly interesting, maybe they do behave like &mut
[20:42:15] <eddyb> though I thought structures with embedded closures were copiable
[20:43:30] <bstrie> oh wait
[20:43:31] <bstrie> hm
[20:43:39] <bstrie> this is an interesting error message
[20:45:08] <bstrie> eddyb: now updated with the original: https://gist.github.com/bstrie/8443947
[20:45:26] <bstrie> I hadn't read that "note" line the first time
[20:45:40] <bstrie> it probably doesn't help in the case of recursive functions, because you're changing the type...
[20:45:48] <bstrie> but it's strange to consider
[20:46:12] <eddyb> oh wow
[20:46:22] <eddyb> that... looks new
[20:46:44] <eddyb> bstrie: try f: 'static |f32|->f32
[20:47:42] <bstrie> eddyb: doesn't parse
[20:47:45] <bstrie> oh wait
[20:47:48] <bstrie> in the type signatre
[20:47:52] <eddyb> yes
[20:47:53] <bstrie> I was doing 'static |x: f32| x*x
[20:48:08] <bstrie> still gets moved
[20:48:11] <bstrie> same error
[20:48:24] <eddyb> 'static |f32|:Pod->f32
[20:48:33] <eddyb> if that doesn't work, fn(f
[20:48:40] <eddyb> err, staph, enter
[20:48:52] <eddyb> if that doesn't work, fn(f32) -> f32 might work better
[20:49:06] <bstrie> eddyb: well the whole point here was to make a nice *api*
[20:49:10] <eddyb> though closures don't coerce to it
[20:49:15] <bstrie> right
[20:49:23] <bstrie> requiring the user to make a named function is a bit less nice
[20:49:34] <bstrie> when logically it seems like there's no reason it has to move
[20:49:59] <eddyb> bstrie: you might be able to pass &|f32|  -> f32  down the stack
[20:50:01] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[20:50:21] <eddyb> since closures aren't actually &mut, they should be callable through a & reference
[20:50:30] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[20:50:38] <eddyb> (and because the closures are fat pointers, there's no extra indirection at all ;))
[20:50:57] <bstrie> how do you call a &||
[20:51:09] <bstrie> error: expected function but found `&|f32| -> f32`
[20:51:11] <eddyb> (*x)()
[20:51:16] <bstrie> barrrfff
[20:51:18] <eddyb> if that complains about moving, I don't know
[20:51:20] <bstrie> I thought () did autoderef
[20:51:33] <eddyb> bstrie: maybe with Fn :P
[20:53:59] <bstrie> eddyb: aha, &|| works!
[20:54:05] <bstrie> eddyb: and I have NO IDEA WHY :)
[20:54:15] <bstrie> closuuuuuuuresssss
[20:54:33] *** jld|lunch is now known as jld
[20:54:53] <eddyb> bstrie: they're like &mut RefCell or something :P
[21:01:18] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[21:03:11] *** Joins: dherman (dherman@moz-BBE3ABD.mv.mozilla.com)
[21:03:12] *** ChanServ sets mode: +ao dherman dherman
[21:05:38] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[21:05:39] *** ChanServ sets mode: +ao pcwalton pcwalton
[21:08:01] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[21:08:05] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:08:05] *** ChanServ sets mode: +qo brson brson
[21:10:49] *** nrc|afk is now known as nrc
[21:11:19] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[21:15:00] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:15:41] *** Quits: geoffhill (geoffhill@moz-738DC0DB.org) (Ping timeout)
[21:24:59] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[21:30:03] <acrichto> vadimcn: ping
[21:30:15] <vadimcn> acrichto: pong
[21:30:22] <acrichto> vadimcn: I feel like we shouldn't be buliding llvm tests?
[21:31:34] <vadimcn> We shouldn't ?
[21:32:19] <acrichto> we definitely don't run them
[21:32:30] <acrichto> I think we just never figured out what to pass to 'make' to say "only build the libraries"
[21:34:40] <acrichto> vadimcn: hm, maybe "make ONLY_TOOLS=1"
[21:34:49] <acrichto> ifneq ($(ONLY_TOOLS),)                     DIRS := $(filter-out unittests, $(DIRS))
[21:34:52] <acrichto> endif                                     
[21:34:54] <acrichto> ugh copy paste
[21:35:02] <vadimcn> BTW, the cmakefile.txt portion is already fixed upstream
[21:35:25] <acrichto> vadimcn: can you reproduce locally?
[21:35:40] <vadimcn> yes
[21:35:49] <acrichto> try this
[21:36:01] <acrichto> edit mk/llvm.mk
[21:36:08] <acrichto> or hm sec
[21:36:37] <acrichto> yeah in mk/llvm.mk
[21:36:39] <acrichto> on line 31
[21:36:42] <acrichto> add ONLY_TOOLS=1 
[21:37:13] <vadimcn> ok
[21:38:39] <acrichto> hm my build died
[21:38:43] <acrichto> cp: 1/Makefile: No such file or directory
[21:38:48] <acrichto> make[3]: *** No rule to make target `all'.  Stop.
[21:39:49] <acrichto> oh it's not a boolean
[21:41:16] <vadimcn> though llvm-c-test is under 'tools', ONLY_TOOLS only removes 'unittests' dir
[21:41:32] <acrichto> oh it looks like ONLY_TOOLS is a list of tools to build
[21:41:43] <acrichto> excellent
[21:41:58] <acrichto> llvm-ar bugpoint opt llvm-mc 
[21:42:03] <acrichto> I think those are all we need
[21:42:08] <acrichto> llvm-sid
[21:42:11] <acrichto> llvm-dis*
[21:42:26] <acrichto> that won't build llvm-c-test
[21:42:32] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[21:42:33] <acrichto> and it won't build unittest
[21:42:36] <acrichto> unittests*
[21:43:04] <acrichto> vadimcn: Makefile.in line 373, let's add LLVM_TOOLS
[21:43:31] <acrichto> and then pass that to ONLY_TOOLS
[21:43:38] <acrichto> and then the list would be:
[21:43:56] <acrichto> bugpoint llc llvm-ar llvm-as llvm-dis llvm-mc opt
[21:44:17] <vadimcn> ok, will try that
[21:45:29] <vadimcn> why not in mk/llvm.mk though?
[21:45:43] <acrichto> doesn't matter too much
[21:45:48] <acrichto> we have LLVM_COMPONENTS in Makefile.in
[21:45:52] <acrichto> so I figured it'd be in the same place
[21:46:20] <vadimcn> ok
[21:46:56] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:46:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/v2gWbg
[21:46:56] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:50:15] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[21:50:55] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[21:51:52] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:51:52] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/PozePQ
[21:51:52] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:51:53] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[21:51:53] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/nskLJQ
[21:51:53] <ghrust> 13rust/06auto 1486c60b6 15Alex Crichton: Flag failure functions as inline(never)...
[21:51:53] <ghrust> 13rust/06auto 14149fc76 15bors: auto merge of #11550 : alexcrichton/rust/noinline, r=thestinger...
[21:51:53] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[21:53:28] <eddyb> nmatsakis: note to self: trait Add<'lhs, 'rhs, Rhs, Ret> {fn add(&'lhs self, &'rhs Rhs) -> Ret;} and allow both impl Add<X, X> for X; and impl<'a> Add<'a, 'a, X, X> for X;
[21:54:45] <eddyb> nmatsakis: the latter can be used (assuming your rvalue lifetimes) to create DAGs on the stack
[21:57:58] <larsberg> acrichto: ping
[21:58:50] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[21:58:57] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Quit: tikue)
[21:59:33] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[22:01:01] <acrichto> larsberg: pong
[22:01:29] <larsberg> I was thinking it would be really nice to have some debugging support in the channel APIs
[22:01:40] <larsberg> I was playing around the last couple of days with a few race conditions and deadlocks
[22:01:55] <larsberg> slowly changing every send in servo to say "sending msg MSG from task TASK"
[22:02:05] <larsberg> and all the recvs to say "in task TASK received MSG"
[22:02:14] <larsberg> and realized I'd love to automate some of that 
[22:02:49] <acrichto> hm that'd not a bad idea
[22:02:50] <larsberg> maybe too much for the library to support, but before I commit debug!() to every single channel op in servo, I thought I'd see if you'd been thinking about this at all
[22:03:17] <acrichto> I hadn't considered this yet
[22:03:35] <larsberg> cool, it's not urgent, but just wanted to bring it up
[22:03:48] <acrichto> we could do that definitely, although would you be ok recompiling libstd?
[22:03:54] <larsberg> we could also do neat things like transmute the output into a DOT file and visualize the communication :-)
[22:04:00] <acrichto> lol
[22:04:07] <acrichto> that'd be pretty sweet
[22:04:57] <larsberg> yeah, much better than my poor handwriting: http://imgur.com/0Q2yC8D,8lvlulP
[22:05:26] <acrichto> good god
[22:05:26] <larsberg> I'd be OK with recompiling libstd to get it
[22:05:35] <acrichto> that's a lot of tasks
[22:05:51] <acrichto> I'd think that by default you wouldn't want {:?} formats 
[22:05:51] <larsberg> there are several more
[22:05:55] <larsberg> "omitted for clarity"
[22:05:57] <acrichto> but with --cfg debug I'd be fine throwing it all in
[22:05:59] <acrichto> lol
[22:06:59] <larsberg> Oh, yeah, I hadn't thought about whether I wanted message contents printed or not - just the name of the enum was sufficient for my debugging
[22:07:11] <larsberg> but if there are sequence numbers in the messages or similar I could see that being important
[22:07:56] <acrichto> sadly we don't have sequence numbers
[22:07:59] <acrichto> but I imagine we could
[22:08:34] <larsberg> oh, I meant our own internal Servo sequence numbers, nothing required from the runtime, though I appreciate the offer :-)
[22:09:10] <acrichto> printing just the enum name isn't currently possible
[22:09:13] <acrichto> but it would be kinda nice
[22:09:56] <dbaupp> acrichto: format!({:?}, x).slice_to(index of first non alphanumeric character)
[22:10:20] <acrichto> dbaupp: but you have to know what it's an enum, right?
[22:10:34] <dbaupp> acrichto: not really?
[22:10:40] <acrichto> "5"
[22:10:44] <dbaupp> it'll probably do the wrong thing for other values
[22:10:51] <dbaupp> that'll work, because it's numeric
[22:10:57] <acrichto> oh alphanumeric
[22:11:01] <acrichto> not alphabetic
[22:11:09] <dbaupp> 1.2 will just be 1 but I guess we could include '.'
[22:11:12] <dbaupp> anyways
[22:11:15] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[22:11:16] <dbaupp> ugly hacks are ugly
[22:11:27] <acrichto> COMM_SHORT_LOG_MSG=true
[22:13:16] <kimundi> acrichto: Hm, Chans that would automatically update to SharedChan would be implemented with dynamic dispatch, right?
[22:13:35] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[22:13:35] <acrichto> kimundi: not necessarily
[22:13:47] <acrichto> https://github.com/mozilla/rust/pull/11578
[22:13:59] <acrichto> it's an internal branch, but not a dynamic dispatch
[22:14:18] <acrichto> we can enumerate all possible states
[22:14:29] <kimundi> Oh, okay. I was just thinking, if it would be the case, then switching that internal trait object out with something that also does debug output would essential be free API wise
[22:15:07] <kimundi> (re earlier discussion with larsberg)
[22:15:12] <acrichto> the logging would probably be around the Chan::send rather then Packet::send
[22:15:21] <acrichto> so we'd still get it for free on all states of the channel
[22:19:58] <acrichto> vadimcn: any luck?
[22:20:25] <vadimcn> still building
[22:20:26] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[22:20:49] <acrichto> :(
[22:23:33] *** Joins: tjc (tjc@1C4BED8B.36F4E7CF.284344F5.IP)
[22:23:33] *** ChanServ sets mode: +o tjc
[22:23:42] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:25:11] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[22:28:45] *** Joins: deens (deens@moz-A47475CE.hsd1.ca.comcast.net)
[22:32:27] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:32:28] *** ChanServ sets mode: +qo brson brson
[22:33:46] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[22:34:11] <dbaupp> why do we have simplified_glue_type? to reduce the amount of glue we're making?
[22:37:24] *** Quits: rca (rcatolino@moz-63C849F5.adsl.proxad.net) (Ping timeout)
[22:40:24] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[22:41:49] *** Quits: deens (deens@moz-A47475CE.hsd1.ca.comcast.net) (Client exited)
[22:43:55] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[22:44:06] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[22:44:39] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[22:46:22] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[22:46:48] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[22:49:02] *** Quits: tjc (tjc@1C4BED8B.36F4E7CF.284344F5.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:55:59] *** Quits: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP) (Quit: tikue)
[22:59:16] *** flaper87 is now known as flaper87|afk
[23:03:54] *** Quits: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca) (Quit: canhtak)
[23:04:18] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[23:07:02] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:07:02] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nskLJQ
[23:07:02] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:11:45] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[23:11:45] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/5DH-Pw
[23:11:45] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[23:11:45] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[23:11:46] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/aIGsZA
[23:11:46] <ghrust> 13rust/06auto 140c5dd9e 15bors: auto merge of #11565 : mozilla/rust/snapshot, r=huonw
[23:11:46] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[23:19:18] <vadimcn> acrichto: no luck: it still tried to build llvm-c-test
[23:22:07] <acrichto> vadimcn: something is going wrong b/c I did that as well and the first time I ran make it built it, but every other time it didn't build it
[23:22:24] <acrichto> maybe it's something where the first time is configured differently?
[23:23:44] <vadimcn> how do I make it try to build llvm without cleaning it first?
[23:24:35] <acrichto> cd into $target/llvm
[23:24:40] <acrichto> and run make directly
[23:25:10] <vadimcn> that doesn't exercise rust makefile logic though
[23:25:18] <vadimcn> ok, I'll figure it out
[23:25:59] <acrichto> it's true that it doesn't
[23:26:06] <acrichto> I don't wanna make you do a full rebuild again thogh :(
[23:28:10] *** Quits: glaebhoerl_ (glaebhoerl@moz-B5B88D72.catv.broadband.hu) (Quit: )
[23:28:43] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Quit: Ex-Chat)
[23:30:32] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[23:30:47] *** Joins: tjc (tjc@moz-6EB4E533.dsl.tsoft.com)
[23:30:48] *** ChanServ sets mode: +o tjc
[23:33:30] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[23:33:30] <ghrust> 01[13rust01] 15alexcrichton 04force-pushed 06try from 14956f8ed to 14bad983e: 02http://git.io/k471pw
[23:33:30] <ghrust> 13rust/06try 14bad983e 15Alex Crichton: Add an AtomicU64 type to std::sync::atomics...
[23:33:30] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[23:34:10] *** Joins: tikue (tkuehn@268C2DFE.FAD414BA.D74CC41D.IP)
[23:35:13] <acrichto> brson: how easily can you run commands on the android bot?
[23:37:48] <brson> acrichto: pretty easily
[23:38:26] *** Joins: deens (deens@moz-A47475CE.hsd1.ca.comcast.net)
[23:40:23] *** Joins: Sharp (Sharp@1710C26.8381A41.8725677B.IP)
[23:42:21] *** Joins: canhtak (canhtak@moz-4B5B3414.wl.t.ulaval.ca)
[23:43:20] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[23:43:20] *** ChanServ sets mode: +ao pcwalton pcwalton
[23:46:56] *** Quits: Sharp (Sharp@1710C26.8381A41.8725677B.IP) (Quit: Sharp)
[23:53:45] <vadimcn> acrichto: now it works, I was missing quotes around $(LLVM_TOOLS)
[23:54:05] <vadimcn> waiting for full build to complete

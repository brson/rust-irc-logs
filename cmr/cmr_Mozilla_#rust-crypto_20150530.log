[00:04:46] <bascule> https://www.reddit.com/r/Bitcoin/comments/37oxow/the_security_issue_of_blockchaininfos_android/crolfk4
[00:04:50] <bascule> They were using HTTP instead of HTTPS to make the webservice call to random.org. On Jan 4, random.org started enforcing HTTPS and returning a 301 Permanently Moved error for HTTP - see https://www.random.org/news/. So since that date, the entropy has actually been the error message (turned into bytes) instead of the expected 256-bit number. Using that seed, SecureRandom will generate the private key for address 1Bn9ReEocMG1WEW1qYjuDrdFzEFFDCq43F 
[00:04:56] <bascule> Ilari: :(
[00:05:02] <sfackler> !!!
[00:05:09] <sfackler> ~bitcoin~
[00:05:26] <eternaleye> bascule: Wait, random.org? Seriously?
[00:05:34] <eternaleye> bascule: Someone actually uses that?
[00:06:02] <bascule> random.org over plaintext HTTP
[00:06:21] <eternaleye> bascule: I could - *maybe* - imagine them doing a call to random.org, writing that into /dev/random as additional entropy, and then reading 256 bits from /dev/urandom
[00:06:37] <eternaleye> *maaaaaaaybe*
[00:06:37] <eternaleye> But straight using it?
[00:27:18] <bascule> lololololol
[00:27:26] <bascule> the NSA loves you using random data grabbed over plaintext HTTP!
[00:27:30] <bascule> "random"
[00:38:42] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[00:43:28] <o11c> lol, seriously?
[00:43:57] <o11c> if you don't have secure randomness yourself, you can't get it from anyone else either ...
[00:44:00] <eternaleye> bascule: On April Fools, random.org should just return that one XKCD
[00:44:13] <eternaleye> "return 4; // chosen by random die roll"
[00:48:23] <Tiffany> bascule: hahahahaha that's amazing
[00:52:39] <Tiffany> eternaleye: but then people wouldn't take it seriously!
[00:54:32] <eternaleye> Tiffany: PRECISELY.
[00:54:53] <Tiffany> it's so bad
[00:55:24] <Tiffany> how hard would it be to setup a hardware rng to measure atmospheric noise anyway?
[00:55:42] <Tiffany> hook up an AM radio to a serial port and point it at some unallocated frequency?
[00:56:05] <o11c> Tiffany: better question: how hard would it be to compromise an atmospheric-based hardware rng?
[00:56:07] <Tiffany> I don't know how easy it is to make/get a radio for such a purpose
[00:56:25] <Tiffany> o11c: I imagine that depends on the whitening function, I've heard they're quite robust
[00:57:27] <mcpherrin> If you could overload the reciever so it gets a nice constant data, I think it ought to be feasible
[00:57:33] <Tiffany> oh
[00:58:04] <Tiffany> yeah, I suppose if you can cause it to blow out to the maximum measurable value
[00:58:35] <mcpherrin> It would certainly be an interesting failure case to try 
[00:59:07] <Tiffany> I remember having a little kit for assembling my own radio
[00:59:41] <Tiffany> it was kind of black box though, since the FM receiver was all one bundle with some pins
[01:00:17] <Tiffany> I imagine if you ran a sufficiently long stretch of wire from a serial port you could measure noise from it
[01:01:25] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[01:02:20] <mcpherrin> Tiffany: only if you get enough voltage on the wire to make the serial port levels go high, I'd think
[01:02:31] <Tiffany> hm
[01:02:37] <Tiffany> yeah, I guess voltage would be a problem
[01:02:43] <mcpherrin> and for rs232, you need to swing multiple volts (+-12 volt signalling?)
[01:02:44] <Tiffany> you'd need either an amplifier or something other than a serial port
[01:02:46] <mcpherrin> so you may not...
[01:02:56] <mcpherrin> joystick port would work
[01:03:05] <mcpherrin> not that anyone has those anymore
[01:03:08] <Tiffany> hah
[01:03:39] <mcpherrin> microphone jack is probably a better bet
[01:03:42] <Tiffany> I imagine there's some kind of dirt cheap USB voltometer out there that you could run a long wire from
[01:03:46] <Tiffany> ooh yeah
[01:03:59] <Tiffany> I've had my headphones pick up lightning strikes before
[01:04:22] <mcpherrin> I know I've picked up radio noise with unshielded microphone cabling
[01:04:51] <Tiffany> and microphone jacks have the benefit of being available on a wide variety of devices
[01:06:31] <Tiffany> hm, I didn't consider other possibilities because I was wondering about atmospheric noise too much
[01:06:44] <Tiffany> you could use webcams and room noise as random sources too
[01:06:53] <Tiffany> pretty much anything is a noise source if you have a good whitening function
[01:07:54] <mcpherrin> http://randombio.com/webcam.html
[01:08:10] <mcpherrin> alpha particle decay is pretty darn random
[01:08:34] <Tiffany> yeah, I saw something about that
[01:08:45] <Tiffany> lots of ways to build your own random sources
[01:08:48] <mcpherrin> webcam + smoke alarm
[01:09:11] <Tiffany> although using webcam CMOS noise is perhaps easier than building this contraption
[01:09:59] <Tiffany> as long as you assume the device isn't being physically compromised (which is a pretty reasonable assumption, since there are better things to do than try to break the rng in that case)
[01:10:17] <Tiffany> it feels like there should be a lot more built in noise sources in android than there are
[01:10:30] <Tiffany> although I guess you really can't expect SecureRandom to actually be.. secure..
[01:13:23] *** Joins: esclear_ (esclear@moz-71hqke.dip0.t-ipconnect.de)
[01:16:04] *** Quits: esclear (esclear@moz-djivev.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[01:25:10] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[01:30:48] <bascule> < o11c> if you don't have secure randomness yourself, you can't get it from anyone else either ...
[01:31:00] <bascule> let's ask a site on the Internet over plaintext for randomness!
[01:31:42] <bascule> and there are way to build circuits that exhibit quantum mechanical properties based around e.g. thermal noise that power things like RDRAND
[01:31:55] <bascule> that's a source of randomness that's a little more trustworthy if you build it yourself than get it provided by Intel
[01:32:03] <bascule> but like... basically you have to trust your CPU :(
[01:32:31] <bascule> what I do really like are things like SGX that, if implemented correctly, do reduce attack surface down to the CPU itself
[01:32:40] <bascule> SGX seems a *lot* better than TrustZone for example
[01:32:43] <bascule> TrustZone is insane
[01:33:06] <bascule> https://www.blackhat.com/docs/us-14/materials/us-14-Rosenberg-Reflections-On-Trusting-TrustZone-WP.pdf
[01:33:28] *** Quits: jhelwig (jhelwig@moz-m94qqt.technosorcery.net) (Ping timeout: 121 seconds)
[01:33:36] *** Quits: shachaf (shachaf@moz-evr8ss.members.linode.com) (Ping timeout: 121 seconds)
[01:33:45] <bascule> TrustZone has this sort of "locking" model where the secure world can temporarily take control of memory from the insecure world
[01:33:50] <bascule> turns out both worlds are insecure, lol
[01:35:25] <bascule> I wonder if Intel does any physical security around things like CPU private keys
[01:35:55] <bascule> attestation is an... interesting concept, heh
[02:39:07] *** Joins: yourabi (yourabi@moz-q8dqtg.ca.comcast.net)
[02:39:44] *** Quits: yourabi (yourabi@moz-q8dqtg.ca.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[02:52:14] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[02:57:30] <eternaleye> bascule: Oh god dammit we have another one
[02:57:39] <bascule> eternaleye: ?
[02:57:41] <bascule> what now?
[02:58:09] <eternaleye> bascule: Some crank who thinks his modification of ChaCha is Super Awesome Magick because of entropy testing
[02:58:19] <eternaleye> bascule: And feels the need to announce this to the entire CFRG
[02:59:08] <eternaleye> >> So Chicha-qrf uses 'xor rotated sum' as Salsa20's, starts with a:=a+d, and replaces rotation constants to 17,11,7,23 (all prime numbers).
[02:59:19] <eternaleye> oh good fucking lord
[03:00:24] <eternaleye> >> In other words, I rely on earlier randomness of Chicha to back up its higher security claim against Chacha. So a way to disqualify Chicha as such is by showing an attack better than brute-force against Chicha on 7+ rounds.
[03:01:22] <eternaleye> Translation: "I won't go away unless someone spends several months writing a paper on my shit"
[03:04:47] <bascule> eternaleye: oh yeah that
[03:04:50] <bascule> lol
[03:08:42] <sfackler> whatever happened to the christalline guy?
[03:09:07] <bascule> I think everyone stopped responding to him
[03:14:10] <mcpherrin> hopefully
[03:36:48] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[03:37:47] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[03:39:55] *** Quits: atomic (atomic@moz-vo7ult.telostor.ca) (Ping timeout: 121 seconds)
[03:52:32] *** Quits: irobevjodu (ident@moz-mikldi.static-ro.twistednetworks.net) (Connection closed)
[04:10:06] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[04:32:52] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[05:41:17] <Ilari> Ah, new tokbind/unbearable draft version...
[06:02:22] *** Joins: atomic (atomic@moz-1fe1qo.rev.poneytelecom.eu)
[06:19:13] <eternaleye> bascule: lolblockchain: https://github.com/cjb/gittorrent
[06:21:56] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[06:23:22] <eternaleye> bascule: More info: https://github.com/cjb/gittorrent
[06:23:23] <eternaleye> gah
[06:23:26] <eternaleye> http://blog.printf.net/articles/2015/05/29/announcing-gittorrent-a-decentralized-github/
[06:23:35] <eternaleye> >> That’s the real beauty of Bitcoin — this currency stuff is frankly kind of uninteresting to me, but they figured out how to solve distributed consensus in a robust way.
[06:23:37] <eternaleye> lololololol
[06:24:38] <eternaleye> I'm reminded of an entry from http://web.archive.org/web/20141211101025/http://home.xnet.com/~raven/Sysadmin/ASR.Quotes.html
[06:24:54] <eternaleye> > It is possible to cause a Mac to fail to boot by corrupting preference files. Sometimes, the Mac does this for you.
[06:24:55] <eternaleye> > The MacOS is robust only in the sense that a 400-pound lard-arse pro wrestler can be described as `robust'. 
[06:32:11] <sfackler> "First we connect to GitHub to find out what the latest revision for this repository is, so that we know what we want to get."
[06:32:14] *** Joins: jhelwig (jhelwig@moz-m94qqt.technosorcery.net)
[06:39:15] <eternaleye> sfackler: That's just didactic
[06:39:34] <eternaleye> sfackler: He later bootstraps it to opaque IDs in the DHT, and then uses bitcoin to give them names
[06:39:58] <eternaleye> sfackler: Er, just pedagogical
[06:40:03] <eternaleye> (I always mix the two up)
[06:59:59] <eternaleye> ...huh, this is actually kind of fascinating though: https://en.bitcoin.it/wiki/Proof_of_burn
[07:00:19] <eternaleye> Using proof-of-burn to transmute bitcoin's proof-of-work to proof-of-stake
[07:01:24] <Ilari> Doesn't decentralized imply lack of any website that needs to work? :->
[07:02:11] <eternaleye> Ilari: As I said, it's pedagogical.
[07:02:43] <eternaleye> Ilari: He uses it to illustrate the "sync" part without adding complexity to the "discover" part, then replaces the "discover" part with something decentralized
[07:05:56] <Ilari> Yeah, good idea to separate ref negotiation with object transport.
[07:06:18] <Ilari> Decentralized Ref discovery might be more interesting to pull off...
[07:06:51] <Ilari> Well, Keys do have both secure and global uniqueness.
[07:07:20] <Ilari> But one must still beware for "evilgrade" attacks.
[07:07:27] <eternaleye> The comments point out some major issues, though
[07:07:43] <eternaleye> Like that git pack generation is *explicitly and intentionally* nondeterministic
[07:08:16] <eternaleye> Which, well, kind of breaks the bittorrent model of "peers share the same data around"
[07:09:14] <Ilari> I think some earlier Git torrent work had some complicated scheme to make data deterministic (or at least have interchangeable blocks).
[07:09:53] <eternaleye> Yup
[07:09:58] <eternaleye> Even had the same name!
[07:10:02] <eternaleye> Which he bogarted.
[07:10:27] <eternaleye> IIRC, it's actually still ongoing, which makes it kind of rude
[07:11:09] <Ilari> The nondeterminism actually causes a lot of trouble if trying to resume downloads (and is the reason why it is HARD).
[07:13:00] <eternaleye> I'd actually be a fan of a protocol that orders the stuff in chrono order, so that if you truncate it, then you can apply a partial pack and just run a new instance of the sync protocol from a new start-point...
[07:13:21] <eternaleye> Just make it do a depth-first traverse of the commit DAG
[07:13:30] <eternaleye> (in terms of serialization order)
[07:13:53] <eternaleye> Later stuff can delta-compress on earlier, without sacrificing.
[07:14:58] <eternaleye> It'd retain the nondeterminism the git devs stated they want (improvements to delta compression; improvements to overall compression alg (zlib, etc)) while not kicking resume in the nuts
[07:16:08] <Ilari> eternaleye: And how multiple references from single object are ordered?
[07:17:03] <Ilari> eternaleye: E.g. Commit can have multiple parents (and commit also has tree pointer). Trees can reference other trees and blobs. Then there are tags, which can reference one object of arbitrary type (even another tag).
[07:19:47] <Ilari> And if one took the view that trees and blobs "belong" to the chronologically first commit (by commitdate, capped by further commits) that references those, that can tie between multiple commits.
[07:20:01] <Ilari> Plus I have no idea how expensive such sort would be.
[07:22:00] <Ilari> Also, the way git packing works, the newest version tends to be stored whole, and earlier versions tend to be deltas against the later version.
[07:22:56] <Ilari> It seems that it needs to be possible for multiple commits or tags to "own" one single tree/blob object.
[07:22:57] <eternaleye> Ilari: Leftmost depth-first, with "already has" commits as plural roots.
[07:23:09] <eternaleye> Ilari: Order roots by lexicographic sort.
[07:24:12] <eternaleye> Ilari: And trees refer either to a tree already in the repo (no serialization), or another tree (which should immediately follow, because depth-first)
[07:24:20] <eternaleye> Ilari: Blobs similarly.
[07:25:14] <eternaleye> Ilari: And by committing to _an_ ordering, later trees that reference stuff in prefixes of the pack can skip it because "by then" it _is_ "already in the repo"
[07:27:20] <Ilari> Then there is the problem that tips can be disjoint in arbitrary ways.
[07:27:29] <eternaleye> Ilari: On merge points you'd need a check that all parents are already serialized and if not walk backwards until you hit a present commit, then fast-forward
[07:27:42] <eternaleye> Ilari: Disjoint in arbitrary ways is irrelevant
[07:27:48] <eternaleye> Ilari: That's the "plural roots" thing
[07:28:18] <eternaleye> Ilari: You do one head, then another, then another, ordered by lexicographic sort of tip hash
[07:29:00] <eternaleye> Ilari: Backfilling as-needed to satisfy merge commits
[07:29:56] <Ilari> If tips are ordered, then one could treat earlier commits as roots.
[07:30:06] <eternaleye> Ilari: Exactly.
[07:30:21] <eternaleye> Ilari: Of course, you could also just round-robin heads, appending a commit to each as you go
[07:31:01] <eternaleye> Ilari: Basically, anything satisfying "inserting one object at a time to the repository will not yield an invalid repository" would be fine by me
[07:31:29] <eternaleye> back-referenced delta compression doesn't impede that (though forwards-referenced would)
[07:31:56] <eternaleye> Actually, that brings up something I need to correct myself on
[07:32:19] <eternaleye> Blobs and trees should precede their owning trees and commits, not follow them
[07:32:38] <Ilari> Well, the ordering I was thinking has property that adding next object when you have all previous never results in broken reference.
[07:32:43] <eternaleye> Inserting them early yields dangling objects for git gc to clean up; inserting them late yields invalid references
[07:32:58] <eternaleye> Ilari: Yes; it's just that there are multiple ways to do that.
[07:33:15] <eternaleye> Ilari: Depth-first with backfill on merge, breadth-first, various hybrids.
[07:33:40] <eternaleye> Ilari: Depth-first with backfill is nice from the human perspective, as it tends to greedily complete a branch before going on to the next
[07:33:55] <eternaleye> Ilari: Breadth-first is nice from the computer perspective
[07:34:09] <Ilari> Actually, I think that "no broken references" constrains the order, except for parallel histories (before those remerge) and ordering of blobs/trees within single tree.
[07:34:21] <eternaleye> Ilari: Because you can just walk the parents backwards and then reverse the ordering
[07:34:33] <eternaleye> Ilari: Er, yes?
[07:34:54] <eternaleye> Ilari: What I'm describing only apply to diverged parts of a DAG/tree
[07:35:05] <eternaleye> Ilari: There's only one traverse of a singly-linked list...
[07:36:34] <eternaleye> Ilari: Of course, there's actually a LOT more flexibility in it
[07:37:06] <Ilari> One rule that would work with parallel histories that later remerge is to send the smallest commit ID first.
[07:37:14] <eternaleye> Ilari: For instance, one COULD do all blobs early without violating references
[07:37:44] <eternaleye> Ilari: That's lexicographic ordering of the hash.
[07:37:55] <eternaleye> Ilari: You seem to be saying what I am, on a ten-minute delay :P
[07:38:42] <Ilari> I'm thinking of deterministic ordering of objects on single branch, that has the property that as time advances, the old ordering is prefix of new one.
[07:39:18] <eternaleye> Ilari: Divergence in commits and divergence in tree structure are really the same thing
[07:39:35] <eternaleye> Ilari: I just view hashes as strings more than I view them as numbers
[07:39:46] <eternaleye> Ilari: At least where git is concerned
[07:39:57] <eternaleye> Ilari: Hence my use of lexicographic rather than smallest
[07:40:16] <Ilari> And it seems to me that depth first transversal of commits does not work for that.
[07:40:35] <eternaleye> Sure it does. Take the earliest subtree referred to into the tree, etc.
[07:40:56] <eternaleye> Stop when you hit a subtree or blob already in the repo
[07:41:38] <eternaleye> Actually, generating the packfile is pretty much always going to be best done by enumerating from the server tip to the client tip, then reversing the ordering.
[07:41:49] <Ilari> Deterministic ordering of objects in single branch impiles deterministic ordering of commits in single branch. And it has to be topological sort w.r.t. parent relations (to not break refs).
[07:41:58] <eternaleye> It's just what enumeration order to follow that varies.
[07:42:18] <eternaleye> Ilari: Er, yes?
[07:42:38] <eternaleye> Ilari: The commit is hashed. The commit, in its text, contains "Parents: foo bar"
[07:42:46] <eternaleye> Ilari: Exactly one of those, foo, is "leftmost"
[07:43:16] <eternaleye> Ilari: The server enumerates backwards in time, thus can do "leftmost"
[07:43:29] <Ilari> Actually, one/multiple "parent" lines... But those are ordered.
[07:43:34] <eternaleye> Ilari: It then _reverses the ordering it generates_ to get something the client can _apply_ forwards in time.
[07:44:37] <eternaleye> It could honestly be done as a space-efficient graph algorithm, whose output then drives a streaming dumper, which feeds into a streaming delta compressor.
[07:47:13] <eternaleye> In fact, the graph algorithm basically has a small working set of heads, and a stack of resolved objects. The dumper then pops IDs off the stack to dump
[07:47:28] <Ilari> One possible ordering: Pick commit with lexicographically first commit id that only has parents that are in: 1) In root set 2) In parents of root set 3) Already serialized. Repeat until no more commits remain. Blobs and trees are serialized with the first commit in ordering that references those.
[07:48:13] <eternaleye> Ilari: No, it can be even simpler. Like, ludicrously so. "two stacks" simple.
[07:48:34] <eternaleye> The first stack is the workqueue. The second stack is the output.
[07:48:56] <eternaleye> First, push onto the workqueue all server-heads that are being synced, largest first.
[07:49:37] <eternaleye> Second, pop an ID off the WQ, push its parents on the WQ, push its tree on the WQ, and push it itself on the output.
[07:49:49] <Ilari> What ordering rule does that algorithm generate?
[07:50:02] <eternaleye> Ilari: The depth-first one I suggested.
[07:50:54] <eternaleye> Ilari: If you want breadth-first, add a queue, and put trees on the WQ stack, and commits on the queue. Only pull a new commit when the stack is empty.
[07:51:15] <eternaleye> Ilari: (breadth-first is to depth-first as queue is to stack. Neat little transform.)
[07:57:54] <Ilari> The ordering rule this seems to give is follow leftmost parent not in 1) In root set 2) In parents of root set 3) Already serialized  ... and then serialize that. Repeat until no more commits remain.
[07:58:00] <Ilari> This rule does not work.
[08:00:50] <Ilari> Or for that matter: Serialize leftmost commit (via all commits on path to tip) not yet serialized and which would not break refs.
[08:01:40] <eternaleye> Ilari: You're  missing the reversing.
[08:01:55] <eternaleye> Ilari: Clearer explanation: http://ix.io/iPx
[08:04:01] <eternaleye> Ilari: Output being a stack is _crucial_
[08:04:25] <Ilari> What's "latest-rightmost"?
[08:04:38] <eternaleye> Ilari: You mentioned multiple Parent lines.
[08:04:48] <eternaleye> Ilari: Rightmost element of latest line.
[08:05:18] <eternaleye> (so that the commits are actually _processed_ in the reverse of that, because stack)
[08:05:41] <eternaleye> Oh, whoops, I have a typo
[08:06:06] <eternaleye> http://ix.io/iPy
[08:06:17] <eternaleye> Got t2 and t3 backwards a coule times
[08:07:05] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[08:08:45] <eternaleye> Ah, and "client root" should be "client head"
[08:09:57] <eternaleye> Also, since the stacks really only need to store the object IDs, this can be quite compact.
[08:11:00] <Ilari> Okay, either I am misreading how that algorithm works or I managed to make 5 commit example where it does not just break prefix-consistency but also generates broken ordering (commit is sent before its parents).
[08:11:19] <eternaleye> Ilari: Output is not "sent"
[08:11:29] <eternaleye> Ilari: Output is "buffered in reverse of sending order"
[08:11:43] <eternaleye> a is sent after t which is sent after o
[08:11:58] <eternaleye> Ilari: As I said, it being a _stack_ is crucial.
[08:12:34] <Ilari> I reversed the output order. It would send one commit too late.
[08:12:53] <eternaleye> Ilari: How so?
[08:13:11] <eternaleye> Ilari: o would have no owner, then t would have no owner, then a would link everything up
[08:13:19] <eternaleye> Ilari: But at no point is there a reachable broken ref
[08:13:40] <eternaleye> Ilari: Just wasted _space_, which git gc would fix.
[08:14:50] <eternaleye> Ilari: And no commit is sent before its parents
[08:15:16] <eternaleye> Ilari: Objects may be sent before their containing tree, and trees may be sent before their containing commit
[08:15:35] <eternaleye> Ilari: But that's actually mandatory for correctness
[08:15:53] <eternaleye> Ilari: Because otherwise you have a reachable commit with no tree, or a reachable tree with no blob
[08:16:26] <Ilari> I'm only considering commits here (since those need to be ordered)
[08:16:47] <eternaleye> Ilari: The algorithm I describe will never send a commit before its parents
[08:16:59] <eternaleye> Ilari: Because it will _always_ push it to Output before its parents
[08:17:11] <eternaleye> Ilari: And thus, its parents will be popped _from_ output first
[08:17:18] <eternaleye> Ilari: Because it's a stack. LIFO.
[08:19:51] <eternaleye> Ilari: "push to output" is not "send it over the socket"
[08:20:03] <eternaleye> Ilari: "pop FROM output" is "send it over the socket"
[08:28:25] <Ilari> The example I constructed seems to make the algorithm to pop from working (indirect) parent before (indirect) child. Which seems quite broken.
[08:30:17] <eternaleye> Mm, I think I see it now.
[08:30:53] <eternaleye> A -> (diverge B/C) -> Converge D
[08:31:05] <eternaleye> C will be sent before D
[08:32:48] <eternaleye> Wait, no it won't
[08:33:02] <eternaleye> Ilari: I think you're making assumptions about eliding duplicates
[08:33:30] <eternaleye> Ilari: I intentionally left removing duplicates for the post-stage, of popping from output, for this exact reason
[08:34:15] <Ilari> Well, wonder how many dups one could cause then...
[08:34:20] <eternaleye> Ilari: The algorithm will place D in Output _twice_: Once after B, and once after C. When popping from output, it will output D, output B, output C, and then skip the second D.
[08:34:35] <eternaleye> Ilari: One per 'git branch' command.
[08:36:02] <eternaleye> Ilari: Or to put it in graph terms, one per inward edge to a shared parent.
[08:36:35] <eternaleye> Ilari: And as I said, the stacks don't need to store the object itself, just the (fixed-size) ID.
[08:37:28] <eternaleye> Ilari: So it could be a Stack<[u8; 20]>
[08:38:08] <eternaleye> Ilari: With a nice, compact repr (linked-list of Box<http://en.wikipedia.org/wiki/Special:Search?go=Go&search=u8;20> that double in size on each alloc, perhaps)
[08:38:11] <eternaleye> ...
[08:38:15] <eternaleye> ffs
[08:38:33] <eternaleye> Ilari: With a nice, compact repr (linked-list of Box<[[u8;20]]> that double in size on each alloc, perhaps)
[08:40:30] <Ilari> With duplicates generated in output stack and elided when sending, at least this 5 commit example seems to generate consistent ordering...
[08:41:20] <eternaleye> Yeah, I specified that because it needs to elide the "newest", and it's enumerating from newest to oldest (and doesn't know if it'll find another)
[08:41:35] <eternaleye> So it _has_ to either keep duplicates, or delete from the middle of the stack.
[08:47:41] <Ilari> Except I can make up another 5-commit DAG where prefix-consistency gets broken.
[08:48:20] <eternaleye> Ilari: Oh?
[08:49:01] <eternaleye> Hmm, actually, just realized that my number-of-duplicates count is wrong
[08:49:28] <eternaleye> It's the shared prefix of any commit with multiple children, multiplied by the number of children
[08:50:27] <eternaleye> In that it basically reverses the arrows of the DAG, and then splits joins to turn it into a tree
[08:51:31] <Ilari> Wonder what it would do with N rounds of synchronous cross merges...
[08:51:31] <eternaleye> And then does a depth-first preorder traverse, pushing the nodes into a stack, and then popping from the stack to generate the output (eliding duplicates there)
[08:52:22] <eternaleye> It'd be a lot easier if there was an efficient way to ask "what are your children"
[08:53:33] <eternaleye> ...heh, sneaky, disgusting thought.
[08:53:55] <eternaleye> Perpetrate truly horrendous abuse of Drop and Rc
[08:55:04] <eternaleye> Walk from heads down, instantiating parents as holding Rcs to their children, appending more Rcs as you find more children. Stop when you are holding the client's heads and nothing else.
[08:55:46] <eternaleye> Commit's Drop impl puts it in some form of Sync queue that supports concurrent append.
[08:56:07] <eternaleye> Then release the Rc's of client's heads in hash order.
[08:58:03] <Ilari> Looks like I managed to make example of 10 commits where output stack will be pushed/popped 31 times.
[09:00:45] <eternaleye> Hm, I think I can avoid the pruning and excess if I add a third stack.
[09:00:52] <eternaleye> Wait, no
[09:01:12] <eternaleye> That would only work if there was a way to query if the child-count of a node was >1
[09:01:34] <Ilari> And I think it could be extended with fully exponential way...
[09:02:28] <Ilari> So with 60 commits, one could generate ~10^9 pushes/pops...
[09:02:34] <eternaleye> Ilari: I think that if I accept doing two passes over the graph, I can bring it down to O(n) space
[09:03:14] <Ilari> And it rather should not be exponential work either... :->
[09:03:24] <eternaleye> Ilari: In that I'd pass over the graph once to count the inward edges to parents, prune anything with only one, and on the second pass decrement-and-postpone whenever I hit something >1
[09:04:12] <eternaleye> Ilari: That'd be a simple Map<Id,usize>, drain+filter into a Set, and then checking each node against the set
[09:04:22] <eternaleye> Ilari: So total complexity should be O(nlogn)
[09:05:36] <Ilari> And that "N rounds of synchronous merges" has every commit have either parent count of 0 or 2.
[09:06:12] <eternaleye> Ilari: Sure. So it visits once and postpones, and on the second visit it consumes and removes from the set.
[09:06:57] <eternaleye> And not a set, another Map. My mistake there.
[09:07:44] <eternaleye> Ilari: Well, zero parents would also get pruned
[09:07:56] <eternaleye> Ilari: It only cares whether _more things want this_
[09:08:17] <eternaleye> Ilari: And postpones reading through it until it's gotten the last
[09:08:25] <eternaleye> Ilari: To avoid tree-izing the DAG
[09:12:01] <Ilari> Also, one presumably has to handle the case where there is parent pointer from sent commit to parent of client root. One does not want to send the pointed commit (nor any of its parents).
[09:14:15] <eternaleye> True enough.
[09:14:50] <eternaleye> That's isolated to the termination check, though
[09:15:22] <Ilari> Wonder if there are stricter versions of prefix consistency (that are possible) than just merge of consistent partial orderings one..
[09:21:21] <Ilari> In partial ordering sense consistent orderings are no means unique. E.g. one can construct 21 commit graph where there are 2^20 valid orderings.
[09:21:43] <Ilari> Oops, 41 commit, not 21.
[09:25:55] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:26:05] <Ilari> Eeh... It turns out that orderings do not have to be consistent, just that no broken refs are sent.
[09:28:12] <Ilari> Subject to that, you don't even need determinism from single peer.
[09:29:36] <Ilari> But for transfer to work properly, the trees and blobs should be mixed with commits, not being separate.
[09:30:32] <Ilari> And the reason why resuming transfer in Git is so difficult is that git does send broken refs (in transfer order).
[09:34:02] <Ilari> Except if one wants to download parts from multiple peers in parallel, then one needs consistent ordering (for each tip). But one still needs to handle the case where there are multiple client roots, and those take multiple ranges in object order...
[09:35:37] <Ilari> (E.g. say tip A has 500 commits, and client has 1-200 and 300-400 of those).
[11:43:48] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[13:19:44] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[15:14:35] *** Joins: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP)
[15:21:33] <Tiffany> " a:=a+d; 	a:=rot32l(a,17); "
[15:21:46] <Tiffany> you could just say a := rot32l(a+d, 17)
[15:23:52] <Tiffany> I don't even
[15:24:10] <Tiffany> he ran it through a program to measure keystream randomness and got uncomparable results
[15:24:15] <Tiffany> and therefore he thinks it's better?
[15:24:31] <Tiffany> these aren't even significant changes
[15:24:35] <Tiffany> they seem almost entirely arbitrary
[15:25:21] <Tiffany> there's really no reason at all to use this over plain old chacha
[15:26:18] <Tiffany> I'm actually reading the paper where djb describes the differences between chacha and salsa20
[15:26:42] <Tiffany> in both the original paper and the updated chacha paper, he says that the rotation amounts are unimportant
[15:27:46] <Tiffany> the round function is specifically changed to increase diffusion, and this guy doesn't even mention diffusion
[15:28:11] <Tiffany> the initial state matrix layout is changed to make it more amenable to SIMD
[15:28:34] <Tiffany> and the indexes into the matrix
[15:38:43] <Ilari> Wonder what the author would understand of diffrential cryptoanalysis of ciphers (hint: ARX ciphers are infamous for theoretical problems with diffrential cryptoanalysis).
[15:40:34] *** Quits: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP) (Ping timeout: 121 seconds)
[15:40:46] <Tiffany> I still need to learn about that
[15:41:13] <Tiffany> huh, why is that?
[15:41:28] *** Joins: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP)
[15:41:39] <Tiffany> do ARX ciphers tend to not apply enough operations to achieve good diffusion?
[15:45:52] <Ilari> For some reason, there tends to be pretty big gap between lower bound for differential attack complexity and differential attacks that can be found in practice.
[15:53:35] <Tiffany> I'm trying to understand how poly1305-aes works
[15:53:53] <Tiffany> djb seems to be a fan of single-letter function arguments without documenting what they are for
[15:54:00] <Tiffany> a, kr, n, m, l
[15:54:22] <Tiffany> I can tell that a is the authenticator, kr is a combination of the key and 'r', which I want to know what r is, n is nonce, m is message, l is length
[15:54:54] <Ilari> Maybe r is the variable in polynomial?
[15:55:09] <Tiffany> variable in polynomial?
[15:55:53] <Ilari> The polynomial it is evaluating.
[15:56:37] <Tiffany> hm
[15:56:58] <Tiffany> I guess I should read the papers instead of trying to decipher the implementations
[15:57:03] <Tiffany> even though that's what the site suggests
[16:00:14] <Tiffany> r is apparently a "16-byte additional key"
[16:02:24] <Ilari> Tiffany: The way Poly1305 works is to transform message into polynomial f(r) so that no two messages have the same polynomial. Then evaluate f(r)*r+s, where r and s are random (and s is differerent for each message).
[16:04:07] <Tiffany> and in poly1305-aes, s is derived by encrypting a nonce with an AES key?
[16:04:11] <Ilari> Yes.
[16:04:34] <Ilari> Or there seems to be mod 2^128 before adding s, so s is 128-bit.
[16:05:38] <Ilari> And the reason for masking some bits off r is to avoid nasty carries.
[16:29:35] <Ilari> Tiffany: Also, when Poly1305 is used with Chacha20, the variable in polynomial (r) varies from message to message too...
[16:48:41] <Tiffany> where does r come from with chacha?
[16:49:14] <Ilari> From block#0 output.
[16:49:21] <Tiffany> oh
[17:01:28] *** Quits: gsingh93 (gulshan@moz-ln1ktu.st3l.iv8o.0004.2601.IP) (Ping timeout: 121 seconds)
[17:33:08] <Ilari> Problems with "algorithm agility": 1) Won't help if the protocol is broken. 2) Tends to accumulate crypto garbage
[17:34:29] <Ilari> And by crypto garbage, I don't mean likes of AES-192-CTR-HMAC-SHA256-ETM. I mean things like RC4-based ciphers.
[17:35:50] <bascule> eternaleye: yeah saw that re: gittorrent
[17:36:18] <bascule> Ilari: 1TCS accumulates crypto garbage too, but has no way to add better stuff in the future, heh
[17:37:35] <Ilari> Also, Internet environment needs algorithm agility. Not to deal with broken stuff, but to deal with variety of devices.
[17:39:42] <Ilari> For some other environments, 1TCS might actually make sense.
[17:40:02] <Tiffany> 1TCS?
[17:42:00] <Ilari> One True Cipher Suite.
[17:42:31] <Ilari> BTW, does QUIC do 1TCS?
[17:43:53] <Ilari> Regarding 1TCS and crypto garbage, once algorithm turns into garbage, fixing it takes version bump.
[17:44:30] <Tiffany> logistical nightmare if it's widespread though
[17:45:28] <Ilari> Well, if you have widespread deployment of devices that only support garbage, you have nasty situation in your hands anyway.
[17:46:09] <Tiffany> how stable is crypto, actually?
[17:46:18] <Ilari> I think the TLS ciphersuite profiliation is more of a problem for TLS WG than for real world.
[17:46:39] <Tiffany> like, the problem we seem to have with negotiable cipher suites is that there's lots of garbage cipher suites which perhaps never should have existed in the first place
[17:47:08] <Ilari> Yeah, sure there is lots of crap in there, but even if handshake was more orthogonal, that garbage would still exist and cause problems.
[17:47:27] <Tiffany> AES has existed since 2001 and it's still strong
[17:47:40] <Tiffany> presumably you can build 1TCS and expect it to last >20 years if you have a good cipher
[17:48:45] <eternaleye> Ilari: Problems with lack of algorithm agility: 1.) Won't help if the protocol is broken 2.) Can't ever kick out crypto garbage (like RC4)
[17:48:48] <eternaleye> Ilari: IOW, your point 2 is only valid if the original design is perfect and prescient.
[17:48:51] <eternaleye> Ilari: This is a bad bet to make.
[17:48:52] <Ilari> Also, regarding strength of SHA-2, there was scare in late 00s that SHA-2 was soon to break.
[17:48:57] <eternaleye> Ilari: Algorithm negotiation works if crypto garbage can happen (and it can), and the underlying protocol is provably reducible to the primitives.
[17:49:01] <eternaleye> Ilari: See also, SIGMA-based protocols.
[17:49:04] <eternaleye> Ilari: IOW, the protocol being broken can be provably avoided to a much larger degree than the _crypto primitives_ being broken
[17:49:24] <Tiffany> when was RC4 added to TLS?
[17:49:40] <eternaleye> Tiffany: The beginning, or not far from it
[17:49:50] <eternaleye> Tiffany: Probably grandfathered in from SSLv2 or v1
[17:51:05] <Ilari> It was in at least SSLv3 specs.
[17:51:10] <Tiffany> yeah, it is
[17:51:25] <Tiffany> I didn't know that v1 was never publicly released
[17:51:27] <bascule> Tiffany: crypto is finished? ;)
[17:51:42] <Ilari> Tiffany: Yeah, it was broken in hours.
[17:51:54] <Tiffany> nice
[17:51:55] <bascule> Tiffany: if you were using Salsa20 just a few years ago, you might have noticed it's been obsoleted by ChaCha20 :o
[17:52:32] <Tiffany> well
[17:52:33] <bascule> and CAESAR will wrap up soon
[17:52:39] <Tiffany> salsa20 is still perfectly safe
[17:52:39] <bascule> and we'll have nonce reuse resistant AEAD hopefully
[17:52:41] <bascule> that'd be cool
[17:52:42] <Tiffany> afaik
[17:52:49] <Tiffany> chacha20 is just slightly better
[17:52:50] <bascule> "perfectly" unless you reuse a nonce, then it's a catastrophe
[17:52:53] <Tiffany> oh
[17:52:57] <Tiffany> well, don't reuse nonces
[17:52:59] <bascule> lol
[17:53:09] <bascule> http://cr.yp.to/talks/2012.08.08/slides.pdf
[17:54:11] <bascule> Tiffany: Buttcoin uses secp256k1 aaaand, turns out it's not that great
[17:55:26] <Tiffany> bascule: is there more info about salsa20 and nonce reuse?
[17:55:42] <Tiffany> iirc the wikipedia page doesn't mention anything like that
[17:55:45] <bascule> it's a stream cipher... reusing the same nonce produces the same keystream
[17:55:51] <Tiffany> oh
[17:56:08] <Tiffany> I thought you had implied chacha20 was safe from the issue in salsa20
[17:56:19] <bascule> no, but the CAESAR winner will probably be
[17:57:47] <Ilari> And yeah, crypto protocol design is merely very hard. Crypto algorithm design is freaking black magic.
[17:57:51] <Tiffany> so SSLv3 was released in 1996, and RC4 was probably present in v2, which was defined in 1995
[17:58:07] <Tiffany> RC4 was designed in 1987 and "leaked in 1994"
[17:58:40] <bascule> and, depending on how you judge it, killed in 2013 ;)
[17:58:49] <Tiffany> ah
[17:58:56] <Tiffany> it was a trade secret, but it was never patented or anything
[17:59:31] <Tiffany> so RC4 had only been in the public for a year or two before it was incorporated into the base cipher suite of SSL
[18:00:21] <Tiffany> I'd probably feel uncomfortable building a protocol intended to last 10 years using ciphers that aren't 10 years old
[18:00:25] <Tiffany> fortunately for me, salsa20 is 10 years old
[18:00:31] <bascule> hahaha
[18:00:40] <Tiffany> although chacha is only 7
[18:00:44] <bascule> the basic concept is like
[18:00:55] <bascule> 20 years old
[18:01:06] <bascule> oh wait
[18:01:07] <bascule> even older
[18:01:15] <bascule> 1992
[18:01:31] <bascule> https://www.eff.org/files/filenode/bernstein/exhibit.a.html
[18:02:47] <Tiffany> oh
[18:03:08] <Tiffany> I had assumed it was from 2005 because it is alternately named Snuffle 2005
[18:03:15] <bascule> yeah
[18:03:21] <bascule> Snuffle 5.0 was pluggable with any hash function
[18:03:25] <bascule> basically using it in counter mode
[18:03:26] <Ilari> For crypto protocol, one wants solid protocol design and only solid-looking primitives (which may still turn out to be garbage). Because that protocol and ciphers within will probably stay in use for a LONG time.
[18:03:47] <bascule> Ilari: I think the worst part about crypto protocol design is people don't think it's a hard problem :(
[18:04:01] <bascule> go off and homebrew their own protocols
[18:04:06] <bascule> and then they're horribly broken
[18:04:12] <Tiffany> and add their own little twists
[18:04:25] <bascule> http://www.cryptofails.com/post/70059600123/saltstack-rsa-e-d-1
[18:04:29] <bascule> ^^^ that one was fun
[18:05:03] <Tiffany> hahahaha that's incredible
[18:11:05] <Ilari> Also, nasty hack protocols tend to stay in use far longer than planned. :-/
[18:13:15] <bascule> :(
[18:13:21] <bascule> like TACACS+?
[18:13:23] <bascule> *cry*
[18:18:21] <Ilari> There aren't that many that can competently design crypto protocols. Unfortuanately, there are loads more who think they can. :-/
[18:30:14] *** Joins: adu (ajr@moz-0foa9t.md.comcast.net)
[18:35:30] <Ilari> Also, shoehorning complex systems into web probably won't result in anything nice.
[18:38:46] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[18:57:31] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[19:00:09] *** Quits: adu (ajr@moz-0foa9t.md.comcast.net) (Client exited)
[19:04:54] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[19:13:20] <Ilari> Wonder what is the biggest reason people homebrew crypto protocols... Lack of suitable ready-made protocols? Lack of good implementations?
[19:18:35] <Tiffany> because it seems easier than it actually is
[19:18:56] <Tiffany> and measuring security is not intuitive
[19:19:18] <Tiffany> like I said, people like to shove in tweaks
[19:19:31] <Tiffany> you can see telegram's protocol for an example of this
[19:20:16] <Tiffany> they couldn't just use standard constructions, they had to use their own code that's "fast" and "robust" for the arbitrary definitions of "fast" and "robust" which have their implementation as the best examples thereof
[19:20:45] <Tiffany> I suppose what I'm saying is NIH
[19:29:55] <Ilari> It wasn't "fast" or "robust", right?
[19:33:32] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[19:35:06] <Ilari> Well, certainly the situation with ready-made protocols and implementations is not good.
[19:49:53] <o11c> Ilari: lack of good libraries
[19:50:51] <o11c> as for me: I have vague plans to write an implementation of MinimaLT sometimes if the authors don't release their version already
[19:50:57] <o11c> but that's not homebrew
[19:51:13] <o11c> though I'll probably differ in the initial key exchange part
[19:51:21] <o11c> since that's not really specified in the paper
[19:53:12] <Tiffany> ilari: they use SHA-1, which despite being crap, is indeed faster than SHA-2
[19:53:19] <Tiffany> but they also use AES in IGE mode
[19:53:33] <Tiffany> and they have all this complicated other stuff
[19:53:40] <Tiffany> it's certainly not robust
[19:54:02] <bascule> roflamo Telegram
[19:54:21] <bascule> Ilari: one is sometimes people have a legitimate reason to have non-stream oriented semantics
[19:54:24] <bascule> and DTLS sucks
[19:54:48] <Tiffany> that's one of my big reasons for crafting my own crypto protocols
[19:55:08] <Tiffany> but at least I know enough of what I'm doing to not fail hilariously like telegram
[19:55:48] <Tiffany> I suppose I might be able to use noise, but I'm having a hard time figuring out precisely how it works
[19:56:18] <Tiffany> does this "chaining variable" in the box -> pipes deal mean that the protocol must be sequential?
[19:58:00] <Tiffany> it's not just lack of knowledge which is why telegram screws up either, actually
[19:58:04] <Tiffany> they refuse to fix it
[19:58:27] <bascule> Tiffany: it doesn't help that Trevor is trying to redo it to be more generic, heh
[19:58:38] <bascule> Tiffany: they refuse to acknowledge it's broken
[19:58:43] <Tiffany> yeah no, the noise2 docs are even more confusing
[19:58:45] <bascule> there was a day when Steve Weis went through their code
[19:58:50] <bascule> and found like 100+ issues
[19:59:08] <bascule> like, here's one of the best cryptographers in the world giving you free advice
[19:59:16] <bascule> they didn't care!
[20:13:16] *** Quits: blank_na1e (blank_name@moz-pah0nm.mi.frontiernet.net) (Ping timeout: 121 seconds)
[20:14:18] *** Joins: blank_name (blank_name@moz-1gd.aq8.36.50.IP)
[21:04:14] *** Joins: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP)
[21:10:02] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[21:27:58] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[21:55:10] *** Quits: skeuomorf (skeuomorf@moz-a8h.ni9.32.197.IP) (Quit: WeeChat 1.2)
[22:15:43] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[23:08:51] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[23:47:34] <Tiffany> dieharder takes a while to run

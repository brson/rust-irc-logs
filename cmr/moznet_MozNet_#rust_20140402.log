[00:00:10] *** jorendorff is now known as jorendorff_away
[00:00:18] *** Joins: mindcat (mindcat@2B6B6398.2443BAF3.57E3C596.IP)
[00:00:28] *** Quits: japaric_ (japaric@8436FA78.BF52D463.3E85381A.IP) (Ping timeout)
[00:01:00] *** Quits: alan_and_ (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Input/output error)
[00:01:07] *** Quits: alkino_ (alkino@moz-18C36E4E.w92-151.abo.wanadoo.fr) (Ping timeout)
[00:01:18] *** Joins: japaric_ (japaric@2FEED3C6.68214967.A936879B.IP)
[00:01:26] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[00:01:28] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[00:03:12] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Ping timeout)
[00:04:16] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[00:04:53] *** Quits: adonohue (adonohue@CB447DD5.6B10AC3.E2F59BBC.IP) (Quit: adonohue)
[00:05:55] *** Quits: alisdair (textual@moz-A2298D72.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:06:17] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[00:06:29] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:06:54] *** jorendorff_away is now known as jorendorff
[00:07:00] *** Joins: tefter (bmaxa@moz-EBD2E7E5.bvcom.net)
[00:07:12] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[00:07:20] *** Joins: sw17ch (sw17ch@moz-4AF0345C.hfc.comcastbusiness.net)
[00:08:12] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.3)
[00:08:12] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:08:48] *** Joins: adonohue (adonohue@CB447DD5.6B10AC3.E2F59BBC.IP)
[00:08:55] *** Joins: cschneid (cschneid@moz-20C37083.hlrn.qwest.net)
[00:09:36] *** Quits: mib_8ugn3p (Mibbit@moz-B91AE8B.ip.opendns.com) (Quit: http://www.mibbit.com ajax IRC Client)
[00:09:58] *** Quits: lfox (lfox@E8DE57A0.A6ED1BA6.ECED8BE3.IP) (Quit: ZZZzzz…)
[00:12:00] *** Quits: frozendevil (Adium@moz-62FB197F.com) (Quit: Leaving.)
[00:12:03] *** Quits: blank_name (blank_name@BF0550F3.66204B68.6D228269.IP) (Ping timeout)
[00:12:05] *** Joins: blank_name (blank_name@BF0550F3.66204B68.6D228269.IP)
[00:13:12] *** Joins: frozendevil (Adium@moz-62FB197F.com)
[00:13:54] *** Joins: jroweboy (jrowe7@D931AEC7.B8CF4085.71765F8E.IP)
[00:14:02] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[00:14:59] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Broken pipe)
[00:15:05] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:15:22] *** Quits: azakai (alon@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[00:15:41] *** Joins: azita (Azita@moz-62518563.mtv2.mozilla.com)
[00:16:46] *** Parts: Caseus (bacon@moz-9F046088.members.linode.com) (WeeChat 0.3.9.2)
[00:17:17] *** Quits: WalrusPony (retep998@moz-99A61A25.dhcp.oxfr.ma.charter.com) (Ping timeout)
[00:17:38] *** Joins: mawuli (mawuli@moz-781516AB.com.gh)
[00:17:56] *** Joins: WalrusPony (retep998@moz-99A61A25.dhcp.oxfr.ma.charter.com)
[00:18:24] *** Quits: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com) (Ping timeout)
[00:18:24] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[00:18:40] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:20:34] *** Joins: fournm (Aria@moz-ABB60BA0.austin.res.rr.com)
[00:21:16] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[00:21:43] <jxs> aatch, SiegeLord https://github.com/joaoxsouls/coreutils/blob/master/uname/uname.rs thanks!
[00:22:10] *** Joins: darkf (darkf@moz-F9058B8A.net)
[00:25:28] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[00:25:46] *** Quits: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) (Quit: mankyKitty)
[00:26:00] *** Joins: espindola (espindola@moz-2B21D45F.dsl.teksavvy.com)
[00:26:12] *** Quits: espindola (espindola@moz-2B21D45F.dsl.teksavvy.com) (Quit: Leaving...)
[00:26:16] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[00:28:02] *** Quits: Nekit1234007 (Nekit12340@3126F0EA.D0169432.4707F662.IP) (Ping timeout)
[00:28:57] *** Quits: asmyers (quassel@moz-71754EDC.hsd1.md.comcast.net) (Ping timeout)
[00:29:14] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:30:54] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[00:30:58] *** Joins: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net)
[00:32:39] *** Quits: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net) (Ping timeout)
[00:33:12] *** Joins: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net)
[00:33:46] *** Joins: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net)
[00:34:14] *** Joins: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net)
[00:36:31] *** Quits: adonohue (adonohue@CB447DD5.6B10AC3.E2F59BBC.IP) (Connection reset by peer)
[00:37:07] *** Quits: frozendevil (Adium@moz-62FB197F.com) (Quit: Leaving.)
[00:37:39] *** Quits: LU324 (asdf@moz-864C7465.dyn.embarqhsd.net) (Quit: Leaving)
[00:38:30] *** Quits: azita (Azita@moz-62518563.mtv2.mozilla.com) (Quit: azita)
[00:39:20] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[00:39:53] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[00:40:01] <bstrie> four more subscribers until we beat /r/erlang
[00:40:15] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[00:40:15] *** Joins: patpat (patpat@moz-21619C28.as13285.net)
[00:40:36] *** Quits: patpatter (patpat@moz-21619C28.as13285.net) (Ping timeout)
[00:41:28] *** Quits: twi (Adium@moz-429185BE.cust.vodafonedsl.it) (Quit: Leaving.)
[00:41:41] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[00:42:24] *** Joins: Kingsquee (kingsley@moz-8589F7DA.bchsia.telus.net)
[00:42:54] *** Joins: Nekit1234007 (Nekit12340@DC1D6696.9C28A5C7.4707F662.IP)
[00:43:02] *** Quits: tjc (tjc@moz-6EB4E533.dsl.tsoft.com) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[00:43:30] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[00:43:34] <strcat> bstrie: still need rust: the movie
[00:43:44] *** Quits: sw17ch (sw17ch@moz-4AF0345C.hfc.comcastbusiness.net) (Ping timeout)
[00:43:52] <strcat> https://www.youtube.com/watch?v=xrIjfIjssLE
[00:44:18] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[00:44:44] <jxs> and now it doesn't compile giving me error: field `machine` is private for all of the fields from this struct https://github.com/joaoxsouls/coreutils/blob/master/common/c_types.rs#L31, anyone know why?
[00:45:03] *** Joins: alisdair (textual@BB0336C3.D2943E17.C579BC3E.IP)
[00:45:17] *** Joins: sw17ch (sw17ch@moz-4AF0345C.hfc.comcastbusiness.net)
[00:45:41] <sfackler> jxs: fields are now private by default
[00:46:01] <jxs> ok thanks sfackler, thanks 
[00:48:26] <jxs> and i am getting task '<main>' failed at 'assertion failed: is_utf8(v)', /home/rustbuild/src/rust-buildbot/slave/nightly-linux/build/src/libstd/str.rs:1369 on linux
[00:48:30] <jxs> but compiles fine on osx
[00:48:42] *** Quits: q66 (q66@moz-46D931B3.range86-152.btcentralplus.com) (Quit: Leaving)
[00:48:54] *** Quits: blank_name (blank_name@BF0550F3.66204B68.6D228269.IP) (Ping timeout)
[00:49:20] <jxs> haven't tried windows yet
[00:50:35] *** Joins: blank_name (blank_name@BF0550F3.66204B68.6D228269.IP)
[00:50:55] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[00:51:43] *** Quits: Savago (Savago@D8B9C081.E820043D.D4C04133.IP) (Ping timeout)
[00:52:41] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[00:53:10] *** Joins: Savago (Savago@504D6CF1.5315C0D2.4C2245EF.IP)
[00:53:24] *** Quits: fazal (fazal@4035BE2E.DD69F2BB.E8916D75.IP) (Client exited)
[00:53:52] <carllerche> is it preferable to use Vec or [] (or are they the same thing?)
[00:54:09] <acrichto> carllerche: if you need push() or pop(), use Vec
[00:54:09] <mcpherrin> carllerche: If you need it to grow, use Vec
[00:54:26] <acrichto> jxs: try running with RUST_BACKTRACE=1 to see where it's failing
[00:54:36] *** Joins: happy-dude (Adium@moz-B39E1940.alaures.clients.pavlovmedia.com)
[00:55:04] <carllerche> acrichto: I'm calling push() on ~[T] now though
[00:55:06] <carllerche> what does that do?
[00:55:16] <acrichto> that'll just get removed in the future
[00:55:26] <det> carllerche, supposedly ~[T] will lose push
[00:55:31] *** Quits: leowoe (Leo@moz-41F5800.dip0.t-ipconnect.de) (Quit: Leaving.)
[00:55:33] <carllerche> ah, well good to know
[00:56:00] <myname> i wonder why [] isn't the thing that grows and some static sized item gets a typr. i'd expext vec being used way more often
[00:56:12] <jxs> acrichto, got this Linux
[00:56:12] <jxs> ᐷ  B,E% so must be failing on the second flag, the nodename
[00:56:13] <sw17ch> just so i have this clear: ~[T] is an owned … what exactly? what do we call that thing in the future?
[00:56:21] <sw17ch> all i see it referred to is a “[T]"
[00:56:21] <strcat> myname: &[T] and Rc<[T]> can't grow
[00:56:22] *** Joins: frogzilla (Mibbit@3E3094EC.34458CF2.CC1A2609.IP)
[00:56:30] <strcat> sw17ch: slice
[00:56:40] <sw17ch> strcat: so ~[T] is an owned slice?
[00:56:58] <strcat> I don't really think 'owned' is a good name for ~
[00:57:04] <sw17ch> unique slice?
[00:57:11] <strcat> yeah
[00:57:22] <sw17ch> so what do we call a [T, ..10]
[00:57:28] *** Quits: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net) (Ping timeout)
[00:57:29] <sw17ch> an array?
[00:57:32] <strcat> fixed-size array or just array
[00:57:40] <myname> why do you think owned is a bad name?
[00:57:44] <sw17ch> &[T] <— borwwoed slice
[00:57:52] <sw17ch> ~[T] <— unique slice
[00:57:55] <strcat> myname: because T and [1, 2, 3] are just as owned as ~T and ~[1, 2, 3]
[00:57:57] <sw17ch> [T, ..10] <— array
[00:58:06] *** Joins: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net)
[00:58:18] <sw17ch> is there such a thing as ~[T, ..10]?
[00:58:25] <strcat> sw17ch: sure
[00:58:29] <strcat> even exists today
[00:58:31] <sw17ch> so that would be a unique array
[00:58:36] <strcat> [T] doesn't exist as a type today
[00:58:42] *** Joins: mvian (bacon@moz-9F046088.members.linode.com)
[00:58:47] <sw17ch> strcat: i think that’s the part that trips me up
[00:59:00] <sw17ch> a bare [T] doesn’t have any meaning
[00:59:02] <strcat> str and [T] are just tokens appearing in types, not types
[00:59:05] <strcat> like mut
[00:59:06] <sw17ch> and the things around it look like decorators altering the meaning
[00:59:20] <strcat> & vs. &mut
[00:59:21] *** Quits: frogzilla (Mibbit@3E3094EC.34458CF2.CC1A2609.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[00:59:26] <sw17ch> [T] and ~[T] don’t have the same relationship that uint and ~uint have
[00:59:34] <strcat> right, but they will
[00:59:36] <strcat> with DST
[00:59:44] <strcat> but imo ~[T] will not be a very useful type
[00:59:47] <myname> is str supposed to be something itself innthe future?
[01:00:04] <sw17ch> I saw StrBuf in the meeting notes
[01:00:09] <strcat> myname: yes, [T] and str will be types in the future
[01:00:11] <sw17ch> which is supposed to be like Vec for strings
[01:00:11] <strcat> atm they are not types
[01:00:22] <mcpherrin> strcat: I can see ~[T] maybe being used in persistent data structures where &[T] might be hard to get lifetimes right?
[01:00:33] <myname> what will str be?
[01:00:48] <sw17ch> an ungrowable string
[01:00:49] *** jorendorff is now known as jorendorff_away
[01:00:51] <myname> something like [char]?
[01:01:11] <strcat> mcpherrin: I guess, but it's just a space optimization vs. Vec<T>
[01:01:14] *** Quits: tmh (e@6F8495BB.FEF84806.AA32EE5B.IP) (Ping timeout)
[01:01:16] <mcpherrin> strcat: yeah.
[01:01:20] <sw17ch> so in the future, a [T] is going to be a slice
[01:01:29] <sw17ch> yes?
[01:01:33] <strcat> sw17ch: yes, an unsized type
[01:01:35] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[01:01:41] <strcat> SomeTrait will also be an unsized type
[01:01:45] *** Joins: tmh (e@6F8495BB.FEF84806.AA32EE5B.IP)
[01:01:50] <sw17ch> strcat: an unsized type where the size information is embedded in a fat-pointer, yes?
[01:01:57] <sw17ch> so, we can still do bounds checking, but it’s not in the type
[01:02:04] <mcpherrin> imp [T] { } will work, right?
[01:02:10] *** Quits: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net) (Client exited)
[01:02:24] <strcat> mcpherrin: I think so
[01:02:24] *** Quits: onelson_ (owen@moz-DD666EC5.laika.com) (Quit: Leaving)
[01:02:28] *** Parts: judder (maradukewa@BD9E6B94.126EFFE1.78E362FE.IP) ()
[01:02:36] <mcpherrin> modulo my typos.
[01:03:08] <strcat> anyway need to reboot into 3.14 and check if kdbus still breaks the world
[01:03:10] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.3)
[01:03:15] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[01:03:15] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[01:03:30] <myname> linux pi
[01:03:56] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:04:10] *** Quits: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net) (Quit: tobytailor)
[01:04:24] * strcat stabs bus-proxyd
[01:04:44] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:04:55] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[01:05:50] <hoverbear> How's Rust on a Raspberry Pi?
[01:05:59] *** Quits: rofrol (rofrol@moz-8C55345C.static.ptr.magnet.ie) (Ping timeout)
[01:06:03] <hoverbear> Not as a development enviroment, but as a build target.
[01:06:08] *** Joins: Guest (textual@2216D00C.4265C9B5.DC3E9228.IP)
[01:06:13] <mcpherrin> I ran rust on my Pi without problems
[01:06:16] <mcpherrin> On linux, that is.
[01:06:18] *** Quits: sw17ch (sw17ch@moz-4AF0345C.hfc.comcastbusiness.net) (Ping timeout)
[01:06:28] <mcpherrin> rustc is fine too
[01:06:34] <hoverbear> mcpherrin: Ok, that's great to know.
[01:06:40] <hoverbear> I'm also looking at those Minnowboards
[01:06:56] <mcpherrin> I haven't tried bare metal Pi yet
[01:06:59] <strcat> heh
[01:07:04] *** Quits: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net) (Quit: Leaving.)
[01:07:05] <strcat> there's actually a way to find out how much memory is free now
[01:07:16] *** Joins: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP)
[01:07:24] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[01:07:24] <mcpherrin> I'd like to run rust on the pi bare metal at some point, but I'd rather get x86 working first.
[01:07:32] *** Parts: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) ()
[01:07:49] * strcat wonders if/when procps-ng will update free
[01:07:53] <hoverbear> mcpherrin: http://www.minnowboard.org/ This is x86 apparently so it might be a better target for me.
[01:08:20] <mcpherrin> hoverbear: I saw, but haven't had a chance to look over it yet
[01:08:28] *** Joins: sw17ch (sw17ch@moz-6761BA23.members.linode.com)
[01:08:33] <mcpherrin> A lot of these little embedded things are pretty janky peripheral wise
[01:08:48] <strcat> hoverbear: quite expensive
[01:09:01] <hoverbear> strcat: $200 for a quad core 17ghz with 4gb of ram?
[01:09:05] <mcpherrin> I don't want to have to write a whole USB stack to send some ethernet frames...
[01:09:05] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[01:09:09] <mcpherrin> 17ghz!
[01:09:17] <hoverbear> 1.7!
[01:09:19] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[01:09:23] <mcpherrin> :P
[01:09:49] <strcat> hoverbear: doesn't look like it has a quad core
[01:10:02] <strcat> Intel Atom E640
[01:10:06] <mcpherrin> (dual-core, 1.33 GHz)
[01:10:06] <strcat> at least the 220 dollar ones
[01:10:19] <mcpherrin> $129
[01:10:22] <mcpherrin> $99 is single core
[01:10:39] <hoverbear> I think it was just announced
[01:10:54] <mcpherrin> E38xx on the new ones
[01:10:56] <mcpherrin> $99 MSRP: E3815 (single-core, 1.46 GHz)
[01:10:57] <mcpherrin> $129 MSRP: E3825 (dual-core, 1.33 GHz)
[01:11:13] *** Joins: rofrol (rofrol@moz-8C55345C.static.ptr.magnet.ie)
[01:11:30] <hoverbear> I saw it somewhere, can't find the link, sorry. Looking.
[01:11:32] <strcat> that's a lot of money for an old atom
[01:11:55] * strcat shrugs
[01:12:09] <jxs> acrichto, commented the nodename part, and now i got this https://www.friendpaste.com/2CUhbkF0rhyZFTEvsCx4Gp
[01:12:12] <strcat> you could get a used laptop with nehalem or sandy bridge for that ;p
[01:12:19] <hoverbear> http://linuxgizmos.com/intel-unveils-tiny-x86-minnowboard-max-open-sbc/
[01:12:43] *** Quits: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net) (Ping timeout)
[01:12:48] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:13:26] *** Joins: bff (Mibbit@moz-BDFE9B9C.wavecable.com)
[01:13:37] <acrichto> jxs: looks like from_c_str is failing b/c the contents aren't utf8
[01:13:38] <mcpherrin> strcat: it's not *that* old, Q4'13
[01:13:56] <strcat> mcpherrin: but the architecture is old ;p
[01:14:02] *** Joins: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:14:08] <mcpherrin> And you won't get that much laptop for $99 new...
[01:14:13] <strcat> anything that's atom is a ripoff
[01:14:21] <strcat> they are selling haswell tablets for 200 dollars
[01:14:26] <hoverbear> That's my hesitation.
[01:14:28] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:14:33] <mcpherrin> GPIOs and stuff are annoying on laptops
[01:14:40] <strcat> atom is just a super high margin way of selling low-end chips
[01:14:45] <mcpherrin> an extra $10 for usb to serial...
[01:14:55] <jxs> acrichto, ok thanks, and do they have to be utf8? what can i use to parse from ascii then?
[01:15:00] <mcpherrin> and another $5 for a microcontroller... just to flip some pins
[01:15:08] *** Joins: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net)
[01:15:27] <mcpherrin> Dunno, $99 seems reasonable for a single board computer to me.
[01:15:33] <mcpherrin> If you value the size.
[01:15:43] <hoverbear> I don't really need a GPU, I'd rather have an FPGA
[01:15:44] *** Joins: mno2 (mno2@E1E0A0A3.621D86F0.CFF65E33.IP)
[01:15:49] *** jorendorff_away is now known as jorendorff
[01:16:00] <mcpherrin> I'd still rather buy a beaglebone black though.
[01:16:13] <hoverbear> I heard a lot of good things about those. I'd like an ARM for sure.
[01:16:38] <mcpherrin> A lot of these ARM devices connect the network over USB, which is my #1 hate-on
[01:16:47] <hoverbear> mcpherrin: Yeah. :(
[01:17:01] * strcat is so glad there's a way to measure memory usage correctly now
[01:17:15] <acrichto> jxs: ascii is utf8, something may be corrupt somewhere
[01:17:42] *** Quits: alisdair (textual@BB0336C3.D2943E17.C579BC3E.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:18:42] <SiegeLord> 183 pub's added, 62 privs removed... I did not come out on top from that struct privacy change :/
[01:18:59] *** Quits: blank_name (blank_name@BF0550F3.66204B68.6D228269.IP) (Ping timeout)
[01:19:37] *** Quits: Savago (Savago@504D6CF1.5315C0D2.4C2245EF.IP) (Quit: Savago)
[01:19:38] <hoverbear> SiegeLord :(
[01:20:04] *** Quits: bff (Mibbit@moz-BDFE9B9C.wavecable.com) (Quit: http://www.mibbit.com ajax IRC Client)
[01:20:14] *** Joins: blank_name (blank_name@5799AF77.3C877FC9.53C6B850.IP)
[01:22:50] *** Quits: happy-dude (Adium@moz-B39E1940.alaures.clients.pavlovmedia.com) (Quit: Leaving.)
[01:24:06] <SiegeLord> Are inner attributes not allowed in structs anymore?
[01:24:40] <SiegeLord> rusti: struct Foo{ #![cfg(test)] }
[01:24:45] -rusti- pastebinned 7 lines of output: http://ix.io/bq9
[01:26:37] *** Quits: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com) (Quit: Leaving.)
[01:27:27] <SiegeLord> I don't quite get why that is...
[01:27:51] *** Joins: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP)
[01:29:07] <SiegeLord> rusti: fn foo() { #![cfg(test)] }
[01:29:09] -rusti- ()
[01:29:36] <SiegeLord> rusti: enum Foo{ #![cfg(test)] }
[01:29:38] -rusti- pastebinned 7 lines of output: http://ix.io/bqb
[01:29:48] <SiegeLord> rusti: mod Foo{ #![cfg(test)] }
[01:29:49] -rusti- ()
[01:30:14] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[01:30:39] *** Joins: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net)
[01:30:49] *** Quits: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net) (Client exited)
[01:30:52] *** Quits: maxli (Adium@moz-EE42E0E.student.cs.uwaterloo.ca) (Ping timeout)
[01:31:19] *** Joins: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net)
[01:33:14] *** jorendorff is now known as jorendorff_away
[01:34:15] *** Quits: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[01:36:05] <o11c> rusti: version
[01:36:06] -rusti- rustc 0.10-pre (b8ef9fd 2014-03-31 15:51:33 -0700)
[01:36:29] *** Quits: Guest (textual@2216D00C.4265C9B5.DC3E9228.IP) (Quit: Textual IRC Client: www.textualapp.com)
[01:37:22] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[01:37:44] *** Joins: willingc (willingc@moz-F095E013.san.res.rr.com)
[01:38:00] *** Quits: infynyxx_ (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[01:38:20] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:39:58] *** Quits: willingc (willingc@moz-F095E013.san.res.rr.com) (Client exited)
[01:40:03] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[01:40:15] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[01:40:22] *** Quits: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net) (Quit: tobytailor)
[01:41:53] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[01:42:07] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[01:43:18] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[01:43:46] *** Joins: willingc (willingc@moz-F095E013.san.res.rr.com)
[01:43:50] <SiegeLord> Looks like inner comments are also not allowed, so at least it's consistent
[01:43:58] <SiegeLord> But I still don't quite see why
[01:44:12] <jxs> acrichto, ok thanks, found the problem, http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/utsname.h , the fields are different from linux http://linux.die.net/include/sys/utsname.h
[01:44:21] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[01:44:22] <jxs> is there a way to access that c struct in rust?
[01:45:36] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[01:48:42] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:48:54] *** Joins: lpy (lpy@1834E2CB.F09091A8.1348A864.IP)
[01:48:57] *** Joins: andrew-__ (andrew-d_w@2A1732C4.9DFA657C.CC0301A2.IP)
[01:49:19] *** Quits: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) (Quit: mankyKitty)
[01:49:52] *** Quits: andrew-__ (andrew-d_w@2A1732C4.9DFA657C.CC0301A2.IP) (Input/output error)
[01:49:55] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[01:50:12] *** Joins: andrew-d_w (andrew-d_w@2A1732C4.9DFA657C.CC0301A2.IP)
[01:51:25] <sfackler> jxs: you can define the struct twice and use #[cfg(os("linux"))] and #[cfg(os("osx"))] to compile the right one.
[01:51:38] <sfackler> I may be wrong with the exact cfgs though
[01:51:49] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[01:51:58] *** Quits: evanm (evanm@636AC086.5999CED5.71743E61.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[01:52:00] <mcpherrin> it's probably os("darwin") or something.
[01:53:24] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[01:53:36] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[01:53:39] *** Joins: nieksand (Mibbit@moz-90AF4E6E.tukw.qwest.net)
[01:53:53] <jxs> nice thanks, is there doc for that compiler directive?
[01:54:37] *** Quits: andrew-d_w (andrew-d_w@2A1732C4.9DFA657C.CC0301A2.IP) (Ping timeout)
[01:55:08] *** Quits: soumyaC (uid15286@moz-E77DEB21.irccloud.com) (Quit: Connection closed for inactivity)
[01:55:55] <jxs> getting error: expect ident found linux
[01:56:18] <nieksand> Is there a function to determine local machine's endianness?  Also... is there something besides bit twiddling for flipping between big/little endian?
[01:57:17] <mcpherrin> nieksand: yes!
[01:57:25] <nieksand> ! :)
[01:57:36] <mcpherrin> now if I just remember where they are
[01:57:46] <nieksand> ha
[01:58:12] <mcpherrin> std::mem
[01:58:32] <sfackler> there are also cfg options for endianness
[01:58:56] *** Quits: Earnestly (earnest@moz-6CD1AB70.dyn.plus.net) (Ping timeout)
[01:58:59] <mcpherrin> http://static.rust-lang.org/doc/master/src/std/home/rustbuild/src/rust-buildbot/slave/doc/build/src/libstd/mem.rs.html#105
[01:59:03] <nieksand> nice!
[01:59:05] <nieksand> thank you very much
[01:59:14] <nieksand> std::mem is exactly what I was looking for
[01:59:41] *** Joins: p1start (rewi@moz-E7F3D014.org)
[02:01:27] *** Quits: Ralith (ralith@A8995AA9.62B6AF6A.922221DB.IP) (Ping timeout)
[02:01:42] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[02:01:51] *** Joins: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net)
[02:02:02] *** Quits: lpy (lpy@1834E2CB.F09091A8.1348A864.IP) (Client exited)
[02:02:47] *** jorendorff_away is now known as jorendorff
[02:03:22] *** Joins: lfox (lfox@E8DE57A0.A6ED1BA6.ECED8BE3.IP)
[02:03:22] *** Quits: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net) (Quit: Leaving...)
[02:03:51] *** Quits: nszceta (nszceta@moz-E458A7C0.pharm.pitt.edu) (Quit: Textual IRC Client: www.textualapp.com)
[02:10:03] *** Joins: ChrisMorgan (chris@moz-8DCBEA52.vic.adsl.internode.on.net)
[02:10:58] *** Joins: alisdair (textual@moz-7E6FA9C4.bchsia.telus.net)
[02:11:22] *** Joins: apes (aaron@moz-CB981A9A.com)
[02:13:10] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Ping timeout)
[02:13:51] *** Quits: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net) (Ping timeout)
[02:13:58] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[02:14:13] *** Joins: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net)
[02:16:22] <jxs> found it, it's #[cfg(target_os = "macos")] and #[cfg(target_os = "linux")]
[02:16:25] <jxs> thanks sfackler 
[02:16:48] *** Quits: tefter (bmaxa@moz-EBD2E7E5.bvcom.net) (Quit: Leaving)
[02:17:30] *** jorendorff is now known as jorendorff_away
[02:18:10] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[02:18:23] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Ping timeout)
[02:19:07] *** Joins: kanru (kanru@moz-DB4A9C19.scl3.mozilla.com)
[02:19:13] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[02:19:24] *** Quits: brson (brson@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[02:20:01] *** Quits: willingc (willingc@moz-F095E013.san.res.rr.com) (Client exited)
[02:23:23] *** Quits: janra (Janus@1CDC5701.A48867D7.52E4E107.IP) (Ping timeout)
[02:23:23] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[02:24:02] *** Quits: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net) (Quit: tobytailor)
[02:24:16] *** Joins: willingc (willingc@moz-F095E013.san.res.rr.com)
[02:24:49] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[02:28:30] *** Joins: EastByte_ (EastByte@moz-351D7C56.ewe-ip-backbone.de)
[02:29:02] *** Quits: EastByte (EastByte@moz-3A0C2AD1.ewe-ip-backbone.de) (Ping timeout)
[02:29:40] <johnsoft> has explicit immutability on struct fields been discussed anywhere?
[02:30:03] <johnsoft> that could solve the optimization issue brought up on http://www.reddit.com/r/rust/comments/21lyw4/internal_vtables_again/cgebipz
[02:30:26] *** Joins: brendan (brendaneic@moz-62518563.mtv2.mozilla.com)
[02:32:50] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[02:33:14] <mcpherrin> johnsoft: not only has it been discussed, we used to have it
[02:33:23] *** Joins: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net)
[02:33:35] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[02:33:40] *** Joins: nical (nico@moz-99690620.hinet-ip.hinet.net)
[02:34:38] *** Quits: zz_kimundi (kimundi@moz-EBF89014.dip0.t-ipconnect.de) (Ping timeout)
[02:35:18] *** Parts: jroweboy (jrowe7@D931AEC7.B8CF4085.71765F8E.IP) ()
[02:35:36] *** Joins: Rusky (russell@moz-37E87AF7.slkc.qwest.net)
[02:35:39] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[02:35:39] *** Quits: Rusky1 (russell@moz-37E87AF7.slkc.qwest.net) (Ping timeout)
[02:36:04] <johnsoft> heh, alright
[02:36:20] <johnsoft> I guess the bikeshed pages were the wrong place to look then
[02:37:37] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[02:37:52] *** Joins: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net)
[02:37:53] *** ChanServ sets mode: +ao pcwalton pcwalton
[02:38:07] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[02:38:08] *** Joins: zz_kimundi (kimundi@moz-CEAAC5E6.dip0.t-ipconnect.de)
[02:38:09] *** Joins: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net)
[02:38:25] *** zz_kimundi is now known as kimundi
[02:38:26] *** Joins: aurynj (Eon@583ABBE5.60FA2E28.B9E25744.IP)
[02:40:31] *** Joins: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP)
[02:40:50] <johnsoft> any chance you'd know where to find the mailing list posts about the change?
[02:40:51] *** Parts: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) ()
[02:41:11] <johnsoft> or maybe the commit? my google-fu has failed me
[02:42:14] *** Quits: Sorella_ (queen@9D963F5D.DF5D8AE7.54BCAB54.IP) (Quit: It is tiem!)
[02:42:16] *** Joins: andrezs (andrezs@moz-DAAC2056.carolina.res.rr.com)
[02:42:20] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (No route to host)
[02:42:28] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[02:42:38] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[02:42:41] *** Quits: tikue (tkuehn@CB7FC854.FAD414BA.D74CC41D.IP) (Quit: tikue)
[02:43:24] *** Joins: Titof (Titof@moz-44331C97.w81-248.abo.wanadoo.fr)
[02:44:15] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[02:44:25] *** Joins: adonohue (adonohue@3332E4C0.6B10AC3.E2F59BBC.IP)
[02:44:44] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[02:46:01] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Input/output error)
[02:46:08] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[02:46:20] <mcpherrin> johnsoft: see Inherited mutability in rust 0.6 release notes
[02:46:45] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[02:47:31] <mcpherrin> that at least gets you a time frame
[02:47:35] *** Quits: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net) (Ping timeout)
[02:47:43] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[02:48:34] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[02:50:01] *** Quits: drawoc (drawoc@moz-BAC1D3AB.res-cmts.sesh.ptd.net) (Quit: WeeChat 0.4.3)
[02:51:30] <johnsoft> ty
[02:51:42] *** Joins: mib_nll4x2 (Mibbit@3E3094EC.34458CF2.CC1A2609.IP)
[02:52:10] <acrichto> jxs: glad you found it! those bugs are always a little tricky...
[02:52:17] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[02:53:32] <jxs> acrichto haven't yet found it ehe, really can't find here http://www.scs.stanford.edu/histar/src/pkg/uclibc/include/sys/utsname.h what's the _UTSNAME_LENGTH
[02:53:54] <acrichto> jxs: grep -R UTSNAME_LENGTH /usr/include
[02:53:58] <acrichto> I've done that way too often
[02:54:01] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[02:54:28] <jxs> oh awesome thanks!
[02:54:47] *** Quits: mib_nll4x2 (Mibbit@3E3094EC.34458CF2.CC1A2609.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[02:54:56] <jxs> only to find that i have given it the right size and it's segfaulting now :D
[02:55:07] *** Quits: claudiu (claudiu@moz-6F0C4397.thefacebook.com) (Input/output error)
[02:55:28] *** Joins: claudiu (claudiu@moz-70F9251D.thefacebook.com)
[02:57:45] *** Quits: patpat (patpat@moz-21619C28.as13285.net) (Ping timeout)
[02:57:53] *** Joins: patpat (patpat@moz-21619C28.as13285.net)
[02:58:00] *** Quits: p1start (rewi@moz-E7F3D014.org) (Ping timeout)
[02:59:23] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[03:00:14] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[03:00:17] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: pupoque)
[03:01:32] <jxs> seen where it segfaults, but it's too late, continue tomorrow, thanks guys
[03:01:53] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[03:02:40] *** Quits: adonohue (adonohue@3332E4C0.6B10AC3.E2F59BBC.IP) (Quit: adonohue)
[03:03:35] *** Joins: nszceta (nszceta@moz-E642D2FB.hsd1.pa.comcast.net)
[03:03:50] *** Quits: oxum (anonymous@A8E74FA7.A3DB4D3F.520CDC98.IP) (Quit: ...)
[03:05:22] <nieksand> how can I get a std::slice of u8 to place nice with format!() and lowerhex ?  (I've been poking through docs for a bit now...still no dice)
[03:05:37] <nieksand> grr.. stupid smileys.   std :: slice
[03:05:44] <acrichto> nieksand: take a look serialize::hex
[03:07:17] <nieksand> ah.  thank you
[03:07:42] *** Joins: ssira (ssira@moz-F6206352.kanagawa.ocn.ne.jp)
[03:07:43] *** Joins: bpicolo (Mibbit@moz-44D38470.hsd1.ca.comcast.net)
[03:08:12] <carllerche> Is there something to strings like Vec is to &/~[]?
[03:08:32] <acrichto> carllerche: not yet, but it's coming (pcwalton was implementing it today)
[03:08:52] <carllerche> is this all part of the DST stuff?
[03:08:53] <pcwalton> acrichto: carllerche: yup, coming along nicely. will hopefully have the PR today or tomorrow!
[03:09:04] <acrichto> carllerche: it will happen before DST
[03:09:08] <carllerche> cool
[03:09:09] <pcwalton> the backwards incompatible parts of DST will hopefully be all done this week!
[03:09:16] <pcwalton> the ones that are likely to break code
[03:09:19] <bpicolo> What's the difference between Vec and ~[] exactly? I keep reading but I haven't got the clear picture
[03:09:20] <pcwalton> it'll be smooth sailing from then out
[03:09:24] *** Quits: ssira (ssira@moz-F6206352.kanagawa.ocn.ne.jp) (Ping timeout)
[03:09:29] <bpicolo> (Also what does DST stand for?)
[03:09:32] <carllerche> looking forward to it!
[03:09:35] <acrichto> "smooth sailing"
[03:09:35] <acrichto> :P
[03:09:42] <acrichto> bpicolo: Dynamically Sized Types
[03:09:56] *** Quits: Sharp (Sharp@moz-633F3606.hsd1.ca.comcast.net) (Ping timeout)
[03:10:04] <acrichto> the idea of the compiler possibly not knowing the size of a type at compile-time, but only at runtime
[03:10:38] <bpicolo> Are there no ways to do that currently?
[03:10:46] *** Quits: luz (lu.cy@moz-CD18B14B.customer.cdi.no) (Connection reset by peer)
[03:10:52] <acrichto> sadly no
[03:11:00] *** Joins: Sharp (Sharp@moz-633F3606.hsd1.ca.comcast.net)
[03:11:12] <bpicolo> What makes a Vec NOT a DST?
[03:11:44] <acrichto> bpicolo: nmatsakis has a series of blog posts on this, I recommend brushing up on the most recent one (part 5 I think), it's quite informative!
[03:11:51] <acrichto> soon I hear an RFC and such will be posted as well
[03:12:11] <bpicolo> Think I'm currently on his article hah
[03:13:10] *** Joins: luz (lu.cy@moz-CD18B14B.customer.cdi.no)
[03:13:24] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[03:13:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[03:13:58] *** Joins: dranov (dranov@62D43C56.42CAD9AB.FCAAE698.IP)
[03:14:08] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:15:06] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[03:15:19] <bpicolo> acrichto:  Awesome block, thanks for referring me to it
[03:15:21] <bpicolo> glog*
[03:15:25] <bpicolo> blog* typing is too ahrd
[03:15:28] <bpicolo> ...
[03:16:47] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[03:16:56] *** Quits: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com) (Quit: Computer has gone to sleep.)
[03:19:22] *** Quits: lfox (lfox@E8DE57A0.A6ED1BA6.ECED8BE3.IP) (Quit: ZZZzzz…)
[03:20:11] *** Quits: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com) (Quit: Leaving.)
[03:20:45] *** Joins: phay (phay@16E8BAAB.D2C4A785.91986DB5.IP)
[03:24:38] <carllerche> is there a way to get the max value of uint?
[03:25:10] <carllerche> (to check for overflows when casting from a u64
[03:25:12] *** Joins: richo (richo@moz-E6FCD5A0.hsd1.ca.comcast.net)
[03:25:25] <bpicolo> pub static bits: uint = ::int::bits
[03:25:28] <bpicolo> seems useful?
[03:25:48] <bpicolo> http://static.rust-lang.org/doc/master/std/uint/index.html
[03:25:55] <bpicolo> looks like max is defined on uint
[03:25:59] <carllerche> i must be reading the docs wrong
[03:26:07] <carllerche> ah, bpicolo yeah, i was looking at int too
[03:26:12] <carllerche> and it seemed like it was hardcoded to 64
[03:26:36] <bpicolo> I mean, for a u64 it is 
[03:26:37] <bpicolo> : P
[03:26:38] <bpicolo> right
[03:26:40] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[03:26:51] <carllerche> hmm, it seems to pull in int::bits. Are the docs showing values from whatever platform they are generated on?
[03:27:05] <bpicolo> It's the same number of bits
[03:27:07] <bpicolo> for int vs uint
[03:27:11] <bpicolo> should be anyway
[03:27:24] <carllerche> bpicolo: yeah, but it could be 32bits i'm assuming
[03:27:29] <carllerche> on a 32bit platform
[03:27:36] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[03:27:39] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: pupoque)
[03:27:48] <carllerche> the docs say `pub static BITS: uint = 64` (http://static.rust-lang.org/doc/master/std/int/index.html)
[03:27:59] <bpicolo> true they do
[03:28:04] <carllerche> which, would be wrong on a 32bit system?
[03:28:12] <carllerche> unless it's always 64 in rust?
[03:28:12] *** Quits: claudiu (claudiu@moz-70F9251D.thefacebook.com) (Input/output error)
[03:28:21] <bpicolo> depends on whether doc is wrong or what
[03:28:35] *** Joins: claudiu (claudiu@moz-6F0C4397.thefacebook.com)
[03:28:44] <bpicolo> 32 bit systems can still do 32 bit math no? Just slower?
[03:28:45] *** jorendorff_away is now known as jorendorff
[03:28:47] <bpicolo> 64*
[03:28:47] *** Joins: frozendevil (Adium@moz-A9D8109F.hsd1.wa.comcast.net)
[03:28:48] <carllerche> the manual says it's equivalent to uintptr_t
[03:29:07] *** Joins: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net)
[03:29:09] *** Quits: dranov (dranov@62D43C56.42CAD9AB.FCAAE698.IP) (Ping timeout)
[03:29:48] <sfackler> carllerche: yeah, the docs show values for the platform their built on
[03:29:56] <carllerche> ah, that would explain it :)
[03:30:00] <bpicolo> There you go :D
[03:30:18] *** Quits: claudiu (claudiu@moz-6F0C4397.thefacebook.com) (Ping timeout)
[03:30:30] <bpicolo> Are traits a pretty new thing?
[03:30:47] <sfackler> carllerche: if you're checking for overflow when casting, you might want to use FromPrimitive instead: http://static.rust-lang.org/doc/master/std/num/trait.FromPrimitive.html
[03:31:06] <carllerche> sfackler: ah yes, that's what I want
[03:31:22] *** Joins: wilmoore (wilmoore@moz-4EF3CEBC.hsd1.co.comcast.net)
[03:32:02] <bpicolo> What does Option<Self> mean?
[03:32:14] <bpicolo> is that self of the trait?
[03:32:15] <sfackler> Self is a stand-in for the type the trait is implemented for
[03:32:22] <bpicolo> Gotcha
[03:32:51] <bpicolo> I'm actually going to need that soon
[03:32:51] <bpicolo> hah
[03:35:52] *** Joins: evanm (evanm@moz-4D6F9A00.hsd1.ca.comcast.net)
[03:38:04] *** Quits: Zor (alexrp@moz-B01F40E3.rev.stofanet.dk) (Ping timeout)
[03:41:28] <Eridius> bpicolo: FYI, if a trait function uses the type Self, you can't call it on a trait object, only on a concrete type that implements the trait
[03:42:07] <bpicolo> Eridius:  When can you call it on a trait object? Not sure I've seen a trait object before
[03:42:31] *** Joins: oxum (anonymous@77FDBEE3.3AABCBEA.520CDC98.IP)
[03:43:00] <Eridius> bpicolo: if Foo is a trait, then ~Foo is a trait object (as is &Foo)
[03:43:24] *** Quits: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca) (Quit: canhtak)
[03:43:57] <bpicolo> Aha, found it
[03:44:03] <Eridius> trait objects are how you do virtual function calls
[03:44:11] <Eridius> a trait object is basically a vtable coupled with a pointer to the real object
[03:46:04] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Quit: Leaving.)
[03:46:35] *** Joins: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net)
[03:46:43] *** Quits: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net) (Quit: tobytailor)
[03:47:01] *** Quits: oxum (anonymous@77FDBEE3.3AABCBEA.520CDC98.IP) (Quit: Bye..)
[03:47:14] *** Joins: oxum (anonymous@77FDBEE3.3AABCBEA.520CDC98.IP)
[03:48:19] <bpicolo> Ahhhh
[03:48:21] *** Quits: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net) (Ping timeout)
[03:48:34] <bpicolo> So inherited trait methods only work on trait objects?
[03:49:18] <Eridius> ? no
[03:49:22] <bpicolo> Oh =[
[03:49:34] <Eridius> any method that you can call on a trait object you can also call on a concrete implementation of the trait
[03:49:57] <Rusky> is there any plan to make closures interop with c function pointer + void* pattern?
[03:50:00] <bpicolo> Then what do you mean by trait objects are how you do virtual calls?
[03:50:15] <Rusky> or will we need to wrap them in extern "C" with the closure itself as the void*?
[03:50:32] <rchar> the tutorial has a great section on trait objects iirc
[03:50:44] <bpicolo> rchar:  Yeah I'm looking at it atm
[03:50:50] *** Quits: brendan (brendaneic@moz-62518563.mtv2.mozilla.com) (Quit: brendan)
[03:51:41] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[03:51:56] <Eridius> bpicolo: if I have a trait object ~Foo, the concrete type enclosed by the trait object could be any type that implements the trait
[03:52:02] <rchar> trait objects allow you to cast heterogeneous types that implement a common trait to a common type which might be worked with more easily
[03:52:03] <Eridius> and yet the code that uses the ~Foo doesn't know what the concrete type is
[03:52:09] <Eridius> so when it calls a method on the trait object, it goes through a vtable
[03:52:11] <bpicolo> Ah okay
[03:52:17] *** Quits: ofeldt (ofeldt@moz-73B0BFEC.dip0.t-ipconnect.de) (Ping timeout)
[03:52:26] <bpicolo> That makes sense then, thanks for clarifying
[03:52:32] <dsrx> huh? can you do that? enum Whatever { Thing(~SomeTrait) } ?
[03:53:02] <Eridius> I guess the most general example is the Any trait, which is explicitly designed to be used as a trait object. ~Any can contain any type (because all types implement Any), and it exposes a method that lets you test for and extract the wrapped concrete type, using generics
[03:53:06] *** Joins: Zor (alexrp@moz-B01F40E3.rev.stofanet.dk)
[03:53:18] *** Joins: ofeldt (ofeldt@moz-73B0BFEC.dip0.t-ipconnect.de)
[03:53:19] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[03:53:47] <dsrx> rusti: enum Foo { Bar(~Eq) }
[03:53:48] -rusti- <anon>:11:9: 11:30 warning: code is never used: `Foo`, #[warn(dead_code)] on by default
[03:53:48] -rusti- <anon>:11         enum Foo { Bar(~Eq) }
[03:53:48] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~
[03:53:48] -rusti- ()
[03:54:12] <Eridius> rusti: trait Foo { fn foo(&self); } impl Foo for uint { fn foo(&self) { println!("foo on uint: {}", *self); } } impl Foo for () { fn foo(&self) { println!("foo on ()"); } } fn useFoo(obj: ~Foo) { obj.foo() } useFoo(3u); useFoo(())
[03:54:13] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[03:54:16] -rusti- pastebinned 8 lines of output: http://ix.io/bqj
[03:54:30] <Eridius> rusti: trait Foo { fn foo(&self); } impl Foo for uint { fn foo(&self) { println!("foo on uint: {}", *self); } } impl Foo for () { fn foo(&self) { println!("foo on ()"); } } fn useFoo(obj: ~Foo) { obj.foo() } useFoo(~3u); useFoo(~())
[03:54:32] -rusti- foo on uint: 3
[03:54:32] -rusti- foo on ()
[03:54:32] -rusti- ()
[03:54:49] <Eridius> useFoo() isn't a generic method. It's a single instance that takes a trait object and calls a method on it
[03:54:58] <Eridius> and yet it behaved differently depending on what Foo impl I passed it
[03:55:03] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[03:55:13] <bpicolo> Aha! Excellent
[03:55:15] *** Quits: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net) (Client exited)
[03:55:17] <dsrx> ah so that's how you do dynamic dispatch
[03:55:21] <rchar> is the ~Trait syntax new? I thought the only way to use trait objects was to cast types bound by the trait to the trait object
[03:55:25] *** Quits: brandon (brandon@moz-C052BBCD.nat.asu.edu) (Ping timeout)
[03:55:29] *** Joins: meyer (meyer@moz-A9CF56E4.hsd1.ca.comcast.net)
[03:55:31] <bpicolo> Eridius: Thanks very much for taking the time to explain.
[03:55:44] *** jorendorff is now known as jorendorff_away
[03:56:02] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[03:56:19] *** Joins: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net)
[03:57:34] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[03:57:39] <sfackler> rchar: there's implicit casting to trait objects now in some cases
[03:57:39] *** Joins: rpearl (rpearl@moz-2B41ACB5.andrew.cmu.edu)
[03:58:34] *** Joins: brandon (brandon@moz-C052BBCD.nat.asu.edu)
[03:58:50] <rchar> neat
[04:00:02] *** Quits: bpicolo (Mibbit@moz-44D38470.hsd1.ca.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:03:50] <Eridius> rchar: trait objects aren't new, only the implicit casting is
[04:05:29] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Quit: )
[04:09:01] *** Joins: mib_5rnpeu (Mibbit@moz-E8AAFE.dhcp.insightbb.com)
[04:09:21] *** Quits: mib_5rnpeu (Mibbit@moz-E8AAFE.dhcp.insightbb.com) (Quit: http://www.mibbit.com ajax IRC Client)
[04:10:23] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[04:10:25] *** Joins: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca)
[04:10:47] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Quit: Leaving)
[04:11:08] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[04:12:05] *** Quits: willingc (willingc@moz-F095E013.san.res.rr.com) (Quit: Leaving...)
[04:13:38] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[04:13:54] *** Joins: c74d3 (c74d3a4ebb@moz-E2EAC718.oc.oc.cox.net)
[04:14:17] <pcwalton> rustc strbufified
[04:14:27] <pcwalton> now to do the tests
[04:14:34] <pcwalton> and rustdoc
[04:18:08] *** Quits: mno2 (mno2@E1E0A0A3.621D86F0.CFF65E33.IP) (Connection reset by peer)
[04:18:24] *** Joins: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net)
[04:19:27] *** Joins: Budrose (Budrose@moz-474A4A27.hsd1.dc.comcast.net)
[04:19:52] <Budrose> what is the syntax to accept a vector as a function argument?
[04:20:18] <Eridius> do you want to accept a Vec<T>? Or do you just need a slice?
[04:20:49] <Budrose> I guess a Vec<T>
[04:20:56] <Eridius> do you have a particular element type in mind?
[04:21:12] *** Quits: maxiepoo (mnew@moz-6F50ADE.hsd1.il.comcast.net) (Quit: Leaving)
[04:21:12] <Budrose> ints
[04:21:19] <Eridius> fn foo(v: Vec<int>)
[04:21:42] <Eridius> note that when you pass the vector to the function you're giving up ownership of it and handing ownership to the function. You should only do this if you actually need to
[04:21:49] <Eridius> typically you use a slice, e.g. &[int], if you only need to read data from the vector
[04:22:01] <Budrose> Eridius: Oh, ok. What does that look like than>
[04:22:07] <Eridius> fn foo(v: &[int])
[04:22:13] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[04:22:38] <Budrose> Eridius: awesome, thanks! Just learning here. Rust seems incredible, but a I'm experiencing a tad of a learning curve =)
[04:22:52] <Eridius> Budrose: what have you tried reading so far to learn about it/
[04:23:19] <Eridius> I've heard good things about Rust For Rubyists (http://www.rustforrubyists.com), which is really ok to read even if you don't know Ruby, but I haven't actually read it myself
[04:23:22] *** Quits: andrezs (andrezs@moz-DAAC2056.carolina.res.rr.com) (Quit: Leaving)
[04:23:29] <Budrose> Well I am taking a class online about operating systems "rust-class.org" and they have their own tutorial, other than that, I have been going through the docs
[04:23:33] <Eridius> ah
[04:23:36] *** Quits: oxum (anonymous@77FDBEE3.3AABCBEA.520CDC98.IP) (Ping timeout)
[04:23:57] <Eridius> there's a tutorial and a reference manual and a bunch of guides at http://static.rust-lang.org/doc/0.9/index.html (I assume rust-class.org is targeting Rust 0.9?)
[04:24:12] <Eridius> on that note, in Rust 0.9, Vec<T> doesn't exist, it's ~[T] instad
[04:24:14] <Eridius> *instead
[04:24:19] <Budrose> Eridius: Yeah 0.9
[04:24:21] *** Joins: oxum (anonymous@77FDBEE3.3AABCBEA.520CDC98.IP)
[04:24:52] *** Quits: detrino (chris@moz-EAECB432.lv.lv.cox.net) (Client exited)
[04:27:07] *** Joins: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net)
[04:28:54] *** Quits: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net) (Ping timeout)
[04:29:26] *** Joins: p1start (rewi@moz-E7F3D014.org)
[04:29:29] <Budrose> Eridius: How would I return a vector from a function? Would doing ~[int] be acceptable?
[04:29:38] <Eridius> yes
[04:29:48] <Budrose> sweet
[04:30:09] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[04:31:03] *** Quits: [o__o] (~o__o@604A2740.DB688352.F4ADE383.IP) (Ping timeout)
[04:31:12] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[04:34:26] *** Quits: nszceta (nszceta@moz-E642D2FB.hsd1.pa.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[04:35:55] *** Quits: oxum (anonymous@77FDBEE3.3AABCBEA.520CDC98.IP) (Ping timeout)
[04:38:38] *** Joins: [o__o] (~o__o@604A2740.DB688352.F4ADE383.IP)
[04:39:38] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[04:40:00] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[04:40:20] *** Quits: andrewd18 (andrew@moz-DAC9D29F.wi.res.rr.com) (Quit: Leaving.)
[04:42:09] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Ping timeout)
[04:42:20] *** Quits: osa1 (omer@E41EB272.2545CD3.3688B332.IP) (Ping timeout)
[04:42:30] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[04:43:17] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[04:45:11] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[04:47:58] *** Quits: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com) (Quit: Leaving.)
[04:49:32] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[04:51:02] *** Quits: tobytailor (tobytailor@moz-CBD810C7.hsd1.ca.comcast.net) (Quit: tobytailor)
[04:53:01] *** Joins: joebobjoe (mckin_000@1EEF8F2.50A2C647.5A42B74E.IP)
[04:53:30] *** Joins: benjamin_ (benjamin@moz-5894B012.dip0.t-ipconnect.de)
[04:53:36] *** Parts: joebobjoe (mckin_000@1EEF8F2.50A2C647.5A42B74E.IP) ()
[04:53:51] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[04:54:04] *** Joins: DAddYE (DAddYE@26AF7704.2A034839.284344F5.IP)
[04:55:17] *** Joins: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net)
[04:55:39] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[04:55:54] *** Joins: kris (kris@177D1A6A.BCA0057D.A509ECBA.IP)
[04:57:06] *** Quits: Budrose (Budrose@moz-474A4A27.hsd1.dc.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[04:58:03] <frozendevil> the rust-class tutorial is pretty frustrating with how often it does the parenthetical "(we'll address <X concept> later)"
[04:58:12] *** Joins: erickt_ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[04:59:22] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[05:00:29] *** Quits: erickt_ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[05:01:04] *** Joins: panitaliemom (Mibbit@3E3094EC.34458CF2.CC1A2609.IP)
[05:01:45] *** Quits: kris (kris@177D1A6A.BCA0057D.A509ECBA.IP) (Ping timeout)
[05:01:52] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[05:03:17] *** Quits: rchar (chatzilla@moz-9AC54D4D.lv.lv.cox.net) (Input/output error)
[05:04:24] *** Joins: hjr3 (hradtke@moz-699EABC0.lsanca.fios.verizon.net)
[05:05:13] *** Quits: pcwalton (pcwalton@moz-DA87EE4.hsd1.ca.comcast.net) (Quit: pcwalton)
[05:07:32] *** Quits: panitaliemom (Mibbit@3E3094EC.34458CF2.CC1A2609.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:07:48] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[05:11:57] *** Joins: mno2 (mno2@E1E0A0A3.621D86F0.CFF65E33.IP)
[05:13:11] *** Quits: evanm (evanm@moz-4D6F9A00.hsd1.ca.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[05:14:06] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[05:14:25] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Ping timeout)
[05:14:32] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[05:14:56] *** Joins: rootnode (rootnode@moz-EE68AA20.pools.arcor-ip.net)
[05:15:03] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[05:15:47] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[05:17:11] * dougxxx coughs
[05:17:26] <dougxxx> unlike some other languages almost at 1.3 who 'will address generics later'
[05:18:05] <dougxxx> seriously though, anything specific?
[05:18:14] <dougxxx> I thought the class tutorial was pretty straight forward
[05:18:19] *** Joins: edwardw (Mibbit@EE646FE3.EE06708D.4BFBD933.IP)
[05:18:32] *** fredy is now known as fredy_test
[05:20:03] *** fredy_test is now known as fredy
[05:21:14] *** Joins: eddyb (eddy@F8B50789.F33C1089.FB866788.IP)
[05:21:14] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[05:23:20] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[05:24:42] *** Joins: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com)
[05:25:31] <frozendevil> oh, no, in general the tutorial is great
[05:27:15] <frozendevil> dougxxx: I just find the parentheticals in particular distracting
[05:27:23] *** Joins: skade (skade@moz-331C9291.dip0.t-ipconnect.de)
[05:27:57] <frozendevil> It's more a formatting question, I think?
[05:28:32] *** Joins: fabiand (fabiand@moz-3C5B0258.adsl.alicedsl.de)
[05:29:03] *** Quits: brianm (brianm@moz-F76565E4.hsd1.ca.comcast.net) (Quit: Linkinus - http://linkinus.com)
[05:30:28] *** Quits: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com) (Quit: Leaving.)
[05:31:30] *** Joins: osa1 (omer@8A668854.BEF1EF69.8633E8B5.IP)
[05:31:42] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[05:33:09] <franckverrot> Hello everyone. I've released an implementation of a Rust version manager (https://github.com/franckverrot/chrust), are these kind of projects announced on the rust-dev ML or do we have another ML for that?
[05:36:53] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[05:37:17] <mcpherrin> franckverrot: there's only really the one mailing list
[05:37:21] <mcpherrin> Also, reddit.com/r/rust
[05:39:27] *** Quits: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com) (Ping timeout)
[05:40:15] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Ping timeout)
[05:40:40] *** Quits: nieksand (Mibbit@moz-90AF4E6E.tukw.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[05:43:14] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Taking a nap.)
[05:45:03] <carllerche> how would one pass a trait object to and from C? are they always 2 x uintptr_t?
[05:45:27] *** Joins: kris (kris@moz-A7897749.gjk.dk)
[05:45:28] <cmr> carllerche: yes.
[05:45:36] <cmr> carllerche: there's a struct somewhere in std::raw that contains their layout
[05:46:06] <carllerche> thanks
[05:47:09] *** Joins: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net)
[05:49:05] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[05:49:47] <franckverrot> mcpherrin: thanks, I'll post to both !
[05:50:00] *** Quits: heftig (heftig@moz-98E1815B.dip0.t-ipconnect.de) (Quit: Quitting)
[05:51:27] *** Joins: matematikaadit (adit@FB46008F.BEE8536A.E99CBB2C.IP)
[05:51:38] *** Quits: matematikaadit (adit@FB46008F.BEE8536A.E99CBB2C.IP) (Connection reset by peer)
[05:53:58] *** Joins: DAddYE_ (DAddYE@26AF7704.2A034839.284344F5.IP)
[05:54:20] *** Quits: DAddYE (DAddYE@26AF7704.2A034839.284344F5.IP) (No route to host)
[05:54:22] *** Joins: ozkriff (Mibbit@6014F6.BC46A4C1.71211713.IP)
[05:54:32] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[05:54:59] *** Quits: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca) (Input/output error)
[05:55:22] *** Quits: osa1 (omer@8A668854.BEF1EF69.8633E8B5.IP) (Ping timeout)
[05:55:37] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[05:56:15] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[05:58:09] *** Joins: erickt_ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[05:58:10] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Ping timeout)
[05:59:24] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[05:59:39] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[05:59:42] *** Quits: skade (skade@moz-331C9291.dip0.t-ipconnect.de) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[05:59:58] *** Joins: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP)
[06:00:01] *** Quits: DAddYE_ (DAddYE@26AF7704.2A034839.284344F5.IP) (Ping timeout)
[06:00:13] <mcpherrin> Should the rust installers include editor syntax files?
[06:00:27] *** Joins: Ferreus (ferreus@moz-77E6A138.dip0.t-ipconnect.de)
[06:00:32] *** Quits: erickt_ (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[06:01:08] *** Joins: Budrose (Budrose@moz-474A4A27.hsd1.dc.comcast.net)
[06:01:44] *** Joins: sigma (sigma@moz-6739E92E.range86-184.btcentralplus.com)
[06:02:34] *** Joins: DAddYE (DAddYE@26AF7704.2A034839.284344F5.IP)
[06:02:48] *** Quits: Cromulent (Cromulent@moz-C2470BE2.cable.virginm.net) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:04:13] *** Joins: aravindavk (aravinda@moz-BD0CADEE.redhat.com)
[06:04:45] *** Quits: rweir (rob@moz-B98DF6FB.members.linode.com) (Ping timeout)
[06:05:31] *** Quits: edwardw (Mibbit@EE646FE3.EE06708D.4BFBD933.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[06:05:33] *** Quits: nical (nico@moz-99690620.hinet-ip.hinet.net) (Quit: nical)
[06:08:20] *** Joins: rweir (rob@moz-B98DF6FB.members.linode.com)
[06:09:05] *** Quits: Titof (Titof@moz-44331C97.w81-248.abo.wanadoo.fr) (Quit: Titof)
[06:11:11] *** Quits: rweir (rob@moz-B98DF6FB.members.linode.com) (Ping timeout)
[06:12:22] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Quit: Leaving.)
[06:14:07] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Connection reset by peer)
[06:14:28] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[06:14:28] *** Joins: rweir (rob@moz-B98DF6FB.members.linode.com)
[06:15:32] *** Quits: sigma (sigma@moz-6739E92E.range86-184.btcentralplus.com) (Client exited)
[06:16:12] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[06:17:04] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Ping timeout)
[06:19:47] *** Quits: Budrose (Budrose@moz-474A4A27.hsd1.dc.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[06:19:52] *** Quits: ChrisMorgan (chris@moz-8DCBEA52.vic.adsl.internode.on.net) (Ping timeout)
[06:21:04] *** Joins: skade (skade@moz-331C9291.dip0.t-ipconnect.de)
[06:22:05] *** Joins: pczarn (pczarn@moz-69A55FA.izacom.pl)
[06:22:52] *** Tomcat|afk is now known as Tomcat
[06:24:15] *** Quits: LRN (LRN@moz-EA80C63C.nationalcablenetworks.ru) (Connection reset by peer)
[06:24:38] *** Quits: DAddYE (DAddYE@26AF7704.2A034839.284344F5.IP) (Quit: Leaving...)
[06:24:52] *** Joins: LRN (LRN@moz-EA80C63C.nationalcablenetworks.ru)
[06:27:04] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Connection reset by peer)
[06:27:11] *** Joins: Ms2ger (Ms2ger@moz-98421F60.adsl-dyn.isp.belgacom.be)
[06:27:27] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[06:28:26] *** Quits: zw01 (zev@3C32E5CD.21A2D65F.BCF77D2A.IP) (Ping timeout)
[06:29:17] *** Quits: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) (Ping timeout)
[06:30:15] *** Joins: Blub\w (wry@620605B3.71150E1A.237AE2BA.IP)
[06:30:36] *** Quits: wry (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[06:31:49] *** Joins: zw01 (zev@3C32E5CD.21A2D65F.BCF77D2A.IP)
[06:32:56] *** Quits: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[06:34:17] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[06:34:32] *** Quits: pczarn (pczarn@moz-69A55FA.izacom.pl) (Input/output error)
[06:35:20] *** Joins: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP)
[06:36:07] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[06:36:38] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[06:36:54] *** Joins: alkino_ (alkino@moz-18C36E4E.w92-151.abo.wanadoo.fr)
[06:38:18] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[06:38:29] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[06:40:49] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[06:40:49] *** ChanServ sets mode: +o pnkfelix
[06:42:00] *** Joins: ofeldt- (ofeldt@moz-C0E19F61.dip0.t-ipconnect.de)
[06:42:53] *** Joins: twi (Adium@moz-429185BE.cust.vodafonedsl.it)
[06:43:07] *** Quits: ofeldt (ofeldt@moz-73B0BFEC.dip0.t-ipconnect.de) (Ping timeout)
[06:43:26] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[06:44:01] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[06:44:32] *** Quits: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) (Quit: mankyKitty)
[06:45:21] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[06:45:50] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[06:46:22] *** Quits: hjr3 (hradtke@moz-699EABC0.lsanca.fios.verizon.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[06:48:03] *** Tomcat is now known as Tomcat|sheriffduty
[06:48:18] *** Joins: willingc (willingc@moz-F095E013.san.res.rr.com)
[06:51:10] <frozendevil> does rustc do any idiomatic checks?
[06:51:52] <mcpherrin> frozendevil: what do you mean?
[06:53:18] <frozendevil> well, checks for idiomatic-ness. Like, go verifies your brace style and capitalization and whatnot, right?
[06:53:36] <frozendevil> does rust do anything similar?
[06:53:38] <Vermeille> coding style?
[06:53:43] <frozendevil> yeah
[06:53:51] <Vermeille> they check for CamelCase, AFAIK
[06:54:06] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Ping timeout)
[06:55:17] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[06:55:34] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[06:56:06] *** Joins: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP)
[06:57:00] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[06:57:10] <Ms2ger> I think there's a tool that does checks like that
[06:59:38] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Ping timeout)
[06:59:46] *** Quits: skade (skade@moz-331C9291.dip0.t-ipconnect.de) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:00:56] <sfackler> frozendevil: there are a couple of style lints
[07:01:10] <sfackler> camel case types, superfluous parens
[07:01:28] <sfackler> unused imports
[07:02:09] <frozendevil> ah, ok. I noticed unused imports and extra parens with rustc
[07:02:50] *** Joins: ahunt (ahunt@moz-6D6D79D6.cable.virginm.net)
[07:03:14] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[07:04:32] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[07:05:32] *** Joins: rylev (rylev@moz-8487EC6.cust.telecolumbus.net)
[07:06:19] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[07:06:33] *** Joins: edwardw (Mibbit@E9739E5B.EE06708D.4BFBD933.IP)
[07:12:04] *** Joins: TheHydroImpulse_ (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[07:12:05] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[07:12:05] *** TheHydroImpulse_ is now known as TheHydroImpulse
[07:12:48] *** Joins: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP)
[07:14:40] *** flaper87|afk is now known as flaper87
[07:16:46] <Eridius> frozendevil: are you Izzy?
[07:18:57] *** Joins: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com)
[07:19:02] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[07:19:15] <frozendevil> yep :)
[07:19:55] <Eridius> ohai :)
[07:20:16] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[07:20:24] <frozendevil> fancy seeing you here
[07:20:30] <Eridius> I've been here for quite a while
[07:21:21] <frozendevil> part of the reason I'm here is because of your advocacy, honestly
[07:21:52] *** Joins: nkoep (nik@moz-4AFAB9A1.pool.mediaways.net)
[07:21:55] <Eridius> :D
[07:21:58] <Eridius> <3 Rust
[07:22:09] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[07:22:20] <Eridius> it sure will be nice once we finally get 1.0 out the door and can start relying on it for production software
[07:23:21] <frozendevil> yeah, trying to read up on old blog posts/SO answers/etc has been an interesting exercise
[07:23:59] <Boscop> i'm contemplating using rust for gamedev
[07:24:47] *** Quits: alisdair (textual@moz-7E6FA9C4.bchsia.telus.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[07:25:43] <frozendevil> that seems like a good place for a "better than C++" language
[07:26:07] <Boscop> the question is, is it fast enough
[07:26:19] <Eridius> Boscop: there's a community of game developers using rust already
[07:26:38] <Eridius> There's a channel here on Mozilla for it. Probably called something like #rust-gamedev but I don't know for a fact
[07:26:49] <Boscop> yeah, i'm idling there
[07:27:21] <Boscop> Eridius: do you know of any finished games?
[07:27:26] <Eridius> frozendevil: Working on Cocoa lately I keep wanting to use Rust features
[07:27:44] <Eridius> Boscop: sorry, no. Aside from being aware that the community exists, I haven't paid any attention to gamedev in rust.
[07:27:52] <frozendevil> People write games in Java and Python, I can't imagine Rust is slower than those
[07:27:57] <Eridius> but I think multiple people were working on game engines and the like.
[07:28:04] <frozendevil> Eridius: yeah, I'm a little worried about that
[07:28:43] <Boscop> frozendevil: sure but those games don't use heavy processing
[07:28:54] <frozendevil> what do you mean?
[07:29:49] *** Quits: fournm (Aria@moz-ABB60BA0.austin.res.rr.com) (Quit: Leaving)
[07:29:54] <frozendevil> Eridius: I'm also not sure that I'll ever fully get over typing ' @ ' before ' " '
[07:29:59] <Boscop> the games i've seen that use java or python don't do much in terms of physics simulation, real-time audio processing etc. (stuff that the GPU doesn't do)
[07:30:32] <Eridius> frozendevil: haha. @"foo" used to be a valid thing in Rust. But of course we decided that @-pointers should go away
[07:31:00] <Eridius> Boscop: one of the goals of Rust is to be comparable to C++ in terms of performance. So I would hope Rust is fast enough for game dev
[07:31:13] <Boscop> do you think rust would be a good fit for a multiplayer game with a highly dynamic world (much physics processing incl. fluid and bullets) and on the fly audio synthesis?
[07:31:23] <mcpherrin> Yes.
[07:31:27] <Eridius> I would think that it's just as much a fit as C++ is
[07:31:51] <frozendevil> I think that's more bounded by skill/dedication than Rust's performance characteristics
[07:32:00] <Vermeille> Welllllllllllll
[07:32:16] <Vermeille> C++ Has well known patterns, best practices and pitfalls
[07:32:37] *** Quits: nkoep (nik@moz-4AFAB9A1.pool.mediaways.net) (Ping timeout)
[07:32:40] <Vermeille> It's mature and stable, a lot of libs and content is available, and C++11 made it better
[07:32:46] <Eridius> C++ also has no safety
[07:32:52] <Vermeille> that said, if you feel adventurous, use Rust :D !
[07:32:52] <Eridius> well, very little safety
[07:32:59] <Eridius> Rust's safety is a _huge_ win for this sort of thing
[07:33:06] <Vermeille> I *do* agree
[07:33:10] <Boscop> i tried D before, it was too slow (because of the GC) and isn't functional enough for my taste, and doesn't have AST macros
[07:33:22] *** Joins: nkoep (nik@moz-4AFAB9A1.pool.mediaways.net)
[07:33:32] <Vermeille> But Rust being new does not help finding pitfalls or patterns
[07:33:32] <Eridius> although until Rust 1.0 comes out you have to be prepared for using a pre-release language (and Rust 1.0 won't even freeze the standard libraries, only the language itself)
[07:33:50] <Boscop> Eridius: can large blocks of data be shared among threads in rust?
[07:34:15] <frozendevil> is there a roadmap for features/changes that are needed before 1.0 can ship?
[07:34:20] *** Quits: devbug (quassel@moz-8C40558B.bchsia.telus.net) (Client exited)
[07:34:34] <ross> yeah on github there's a 1.0 milestone
[07:34:35] <edwardw> 1.0 issues: bit.ly/1dM8ii2
[07:35:19] <Eridius> Boscop: Data can be shared among threads safely.
[07:35:34] <Boscop> does rust have something like Sierra for SIMD?
[07:35:42] <Eridius> Boscop: by that I mean there's a language construct that allows for read-only access to shared data without using a lock, and language constructs for allowing write access to shared data using locks
[07:35:55] * Eridius has no idea what Sierra is, and is almost completely unfamiliar with SIMD
[07:36:00] <Eridius> although I know people have been talking about SIMD in Rust lately
[07:36:23] <Boscop> Eridius: it allows writing normal code that is automatically "templated" to also work as SIMD
[07:36:26] <Eridius> by "language construct" I actually mean standard library construct
[07:36:30] <Boscop> without having to do it manually
[07:36:48] <frozendevil> "rustpkg" is "crate" now, right?
[07:37:02] <Eridius> again, I'm largely unfamiliar with SIMD, but people have been discussion lately things to do with SIMD in Rust, so I gather there are people working on how to make SIMD better
[07:37:08] <Eridius> frozendevil: rustpkg is gone, completely.
[07:37:15] <mcpherrin> We have some SIMD support today.
[07:37:21] <Boscop> Eridius: http://www.cdl.uni-saarland.de/papers/lhh14.pdf
[07:37:34] <Eridius> Mozilla hired a couple of guys who have experience writing packagers to create a new one called cargo, but it's in early development
[07:37:37] <frozendevil> maybe I should have said "superseded by"?
[07:37:39] <Vermeille> frozendevil: "cargo", if I'm not mistaken
[07:37:40] <Boscop> http://www.cdl.uni-saarland.de/projects/sierra/
[07:37:45] <frozendevil> ah, yeah
[07:37:45] <mcpherrin> std::unstable::simd
[07:37:47] * frozendevil needs sleep
[07:37:54] <Eridius> "crate" is just the name for a library/program that is compiled by rust
[07:38:08] <frozendevil> I was thinking of cargo
[07:38:19] <frozendevil> lots of vocab picked up in the past few days
[07:38:26] <Eridius> ok then yes, cargo is the replacement for rustpkg, but it's not ready yet
[07:38:31] <frozendevil> right
[07:38:41] <Eridius> for the time being I just use submodules and Makefiles
[07:39:06] <frozendevil> that seems to be the most common thing
[07:39:14] <Eridius> Boscop: If you're interested in having something like Sierra for Rust, you should look into the existing SIMD efforts and see if you can help out ;)
[07:39:23] *** Joins: nik_ (nik@moz-2DFF8760.pool.mediaways.net)
[07:39:26] <Boscop> Eridius: yeah, i was thinking about that
[07:39:34] <Boscop> that's why i asked
[07:39:45] *** Quits: nkoep (nik@moz-4AFAB9A1.pool.mediaways.net) (Ping timeout)
[07:40:23] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[07:40:23] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[07:40:31] <Eridius> frozendevil: let me know if you do anything interesting in Rust ;)
[07:40:35] <edwardw> Boscop: there's a RFC https://github.com/rust-lang/rfcs/pull/15
[07:40:40] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[07:40:44] <dsrx> stupid question... is the "rust standard library" just std, or all the crates that appear on the sidebar here? http://static.rust-lang.org/doc/master/std/index.html
[07:40:44] <edwardw> about SIMD*
[07:40:54] <Eridius> dsrx: all the crates in the sidebar
[07:41:07] <Eridius> libstd means std (although I have occasionally used it as shorthand for "rust standard library")
[07:41:13] <frozendevil> I don't know much about SIMD and friends, but would that be related to the auto vectorization work LLVM is doing?
[07:41:16] <Eridius> but all the crates in the sidebar are installed by Rust
[07:41:45] <mcpherrin> frozendevil: manual SIMD use is different than llvm doing it automatically, though the end goal is a bit similar
[07:42:13] <frozendevil> Eridius: Will do… it'll probably be a while before before I get anything useful done :P
[07:42:14] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[07:42:32] <Boscop> frozendevil: auto vectorization is under the hood, SIMD language support would be explicit
[07:42:37] <frozendevil> so SIMD is similar to CUDA markup?
[07:42:39] <frozendevil> right
[07:42:39] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[07:42:55] <Boscop> CUDA is for GPU
[07:43:13] <frozendevil> right
[07:43:31] <mcpherrin> CUDA is a form of SIMD
[07:43:52] <Vermeille> SIMD on GPU
[07:43:59] <Boscop> yea
[07:44:13] <frozendevil> ok, that makes sense
[07:44:46] *** Quits: doomlord_ (servitor@moz-56F8DA57.range86-148.btcentralplus.com) (Connection reset by peer)
[07:45:16] <lerc> to be pedantic.  GPU's are more single program multiple data than Single Instruction Multiple Data.
[07:46:48] <frozendevil> I guess really what I'm wondering is if the goals of auto vectorization are lofty enough to eliminate the 80% case for using explicit parallelization?
[07:46:57] <frozendevil> or is it just like "loop unrolling 2.0"
[07:47:04] <Ms2ger> More like the latter
[07:47:14] <Ms2ger> In my limited understanding
[07:47:31] *** Quits: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[07:47:43] *** Joins: alex-abreu (alex@moz-7421D6C9.mc.videotron.ca)
[07:47:46] <Boscop> frozendevil: especially considering function calls
[07:47:50] <frozendevil> that was were they were at last time I checked, but I don't really keep up
[07:47:54] *** Quits: onelson (owen@18CF7301.95770028.5B6BFE7D.IP) (Ping timeout)
[07:48:03] <Boscop> frozendevil: look at the sierra paper
[07:48:06] <Boscop> they have an example
[07:48:14] <Boscop> of a raytracer
[07:49:05] *** Quits: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP) (Ping timeout)
[07:49:59] <frozendevil> will do, but for the time being I need sleep
[07:50:03] * frozendevil waves
[07:50:06] *** Quits: frozendevil (Adium@moz-A9D8109F.hsd1.wa.comcast.net) (Quit: Leaving.)
[07:51:26] *** Joins: [squiddy] (squiddy@moz-7B493F09.dip0.t-ipconnect.de)
[07:53:17] *** Quits: alonlevy_ (alon@moz-B6210BD6.red.bezeqint.net) (Ping timeout)
[07:54:34] *** Joins: killerswan (kevin.cant@moz-1F697F7B.uvs.sntcca.sbcglobal.net)
[07:55:53] *** Quits: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net) (Quit: QUIT)
[07:56:06] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[07:56:57] *** Quits: edwardw (Mibbit@E9739E5B.EE06708D.4BFBD933.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:57:23] *** Joins: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP)
[07:57:56] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[07:58:07] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[07:59:34] *** Quits: alkino_ (alkino@moz-18C36E4E.w92-151.abo.wanadoo.fr) (Ping timeout)
[08:00:34] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[08:00:48] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[08:01:29] *** Quits: Kingsquee (kingsley@moz-8589F7DA.bchsia.telus.net) (Quit: Konversation terminated!)
[08:02:35] *** Joins: Hail_Spacecake (frank@682FC60C.A4ACDD73.AED9BA81.IP)
[08:02:43] *** Joins: W0rmDr1nk (wormdrink@moz-CEAF0263.access.mtnbusiness.co.za)
[08:02:47] <Hail_Spacecake> is the current preferred format in rust fmt! or format! ?
[08:03:07] <mcpherrin> isn't fmt! gone?
[08:03:13] <Vermeille> in which language is the rustc bootstrap written? How did you handle tagged unions/enums in it?
[08:03:33] <mcpherrin> Vermeille: Ocaml
[08:03:37] <Vermeille> mcpherrin: AFAIK it's only deprecated
[08:04:05] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[08:04:10] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: pupoque)
[08:04:31] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[08:05:19] *** Quits: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) (Ping timeout)
[08:05:56] <Yurume> Hail_Spacecake: use format!.
[08:06:10] <Vermeille> Hum, I'm having a lot of troubles with ~-ptrs and borrowed pointers to them, how does that work? How does the "ref" keyword exactly works?
[08:07:34] <Vermeille> (I also don't understand if "mut" belongs to the type, is an operator, or whatever, but that's nother thing)
[08:08:00] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[08:08:06] <mcpherrin> Vermeille: Are you reasonably well versed in C or C++?
[08:08:30] <Vermeille> mcpherrin: Definitely.
[08:08:32] <Yurume> Vermeille: for the first question -- the bootstrap compiler was originally written with Ocaml, and nowadays we are using a prior version of compiler to compile a newer version of compiler.
[08:08:41] <Yurume> (called "snapshoting")
[08:08:43] <mcpherrin> Vermeille: good! explaining pointers would make this take longer ;)
[08:08:48] *** Quits: drbawb (drbawb@moz-444F91EA.wi.res.rr.com) (Ping timeout)
[08:09:22] <mcpherrin> Vermeille: Roughly, a ~-ptr is a std::unique_ptr in C++, or more simply a pointer that malloc() returned, with a destructor that free()s it
[08:09:32] <Vermeille> mcpherrin: I understand ~-ptr as being an almost exact synonym to std::unique_ptr, and a borrowed ptr as a raw pointer to the data they hold
[08:09:44] <mcpherrin> Vermeille: A borrowed pointer is more like a C++ reference
[08:09:45] <Vermeille> good.
[08:09:51] <Yurume> there is a separate raw pointer out ther
[08:09:52] <Yurume> e
[08:10:20] *** Joins: zmack (zmack@EFEB97D9.20AB2BFB.E400A05F.IP)
[08:10:20] <Yurume> yeah, a comparison with C++ reference is more adaquate (but not very correct)
[08:10:50] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[08:11:01] <mcpherrin> Vermeille: as an example, consider a function that takes a buffer, and returns a pointer to something in it.  Like a strstr or something
[08:11:13] <Vermeille> They still need to be *'ed
[08:11:26] <mcpherrin> Vermeille: As soon as you `free` the buffer, that other pointer is dangling now, and you can crash by reading through it
[08:11:26] <Vermeille> that would be borrowed
[08:11:43] <Vermeille> Yup, and that's where lifetimes comes
[08:11:59] <mcpherrin> We can statically, at compile time, prove that the "borrowed" pointer has a shorter "lifetime" than what it is borrowing from
[08:12:20] <Vermeille> Proving that statically is really awesome :D
[08:12:30] <mcpherrin> that's basically rust's whole trick
[08:12:35] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[08:12:36] * dougxxx wishes lifetimes were a bit easier to use though.
[08:13:27] <Vermeille> dougxxx: I think that once books, articles, tutorials will be written, it will be simple. I think it's not hard, just unusual
[08:13:28] *** Joins: b5k (sid28134@moz-A42E5B7B.irccloud.com)
[08:13:37] *** Joins: FrozenCow (FrozenCow@moz-54300F7F.upc-j.chello.nl)
[08:13:43] <dougxxx> I just wish lifetimes were attached to blocks, not variables.
[08:13:50] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[08:13:53] <dougxxx> I often want something for the lifetime of a { }
[08:14:01] <dougxxx> and end up having to either use the lifetime of an object
[08:14:08] <dougxxx> or the lifetime of a temporary variable in the block 
[08:14:35] <Vermeille> mcpherrin: So okay, let's say I'm pattern matching against something which *contains* ~-ptr
[08:14:43] <Vermeille> how do I wrote that?
[08:14:48] <Vermeille> write*
[08:14:52] *** Quits: Ms2ger (Ms2ger@moz-98421F60.adsl-dyn.isp.belgacom.be) (Quit: bbl)
[08:15:00] <mcpherrin> Vermeille: Let's take a little example, a linked list
[08:15:17] <mcpherrin> enum List {Node(~List), Nil};
[08:15:54] <mcpherrin> so a list will look like Node(~Node~(Node(~Nil)));
[08:15:58] <eddyb> dougxxx: 'a: {...}
[08:16:11] <eddyb> dougxxx: 'a doesn't become usable for anything, though, atm
[08:16:16] <Vermeille> A list that contains nothing :D
[08:16:26] <Vermeille> Hum okay
[08:16:27] *** Quits: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com) (Quit: Computer has gone to sleep.)
[08:16:31] <mcpherrin> Vermeille: right, we could add data to Node if we wanted, but that's not important
[08:16:34] <dougxxx> eddyb: that's interesting
[08:16:34] <Vermeille> no surprise right there
[08:16:41] <Yurume> eddyb: is that available for arbitrary blocks, not just loops?
[08:16:52] <mcpherrin> So say I've got that list in a variable, and I want to write a function that tells me how long the list is
[08:16:59] <eddyb> rusti: ({ 'a: {} })
[08:17:00] -rusti- <anon>:11:16: 11:17 error: expected `for` or `loop` after a label
[08:17:00] -rusti- <anon>:11         ({ 'a: {} })
[08:17:00] -rusti-                          ^
[08:17:00] -rusti- playpen: application terminated with error code 101
[08:17:05] <eddyb> Yurume: awww
[08:17:14] *** Joins: heftig (heftig@moz-33D186ED.unitymedia.biz)
[08:17:15] <eddyb> dougxxx: it shouldn't even be hard to implement
[08:17:16] <Yurume> eddyb: yeah, that's my concern
[08:17:29] <eddyb> (as long as the lifetime is in the same function
[08:17:30] <Yurume> I don't know why is there such restriction
[08:17:40] <eddyb> Yurume: fixit
[08:17:48] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[08:18:22] <mcpherrin> fn count(list: &List) -> uint { match *list { Node(~ref next) => 1+count(next), Nil=> 0 } }
[08:18:33] <mcpherrin> so let's walk through this function!
[08:18:54] <mcpherrin> First, the signature.  It's a function taking 1 parameter, a borrowed pointer to a list.  It returns a uint.
[08:19:11] <Vermeille> Okay, just go to the ~ref stuff, the following is familiar
[08:19:29] <mcpherrin> So we're matching on *list, which is a dereferenced borrowed pointer
[08:19:31] <mcpherrin> it has type List
[08:19:54] <mcpherrin> Node(_) matches a List, which has contents ~List
[08:20:22] <mcpherrin> If I wrote Node(~rest), I'd get a List out of it
[08:20:34] <eddyb> (but only if you owned the node)
[08:20:35] <mcpherrin> but that would "move" the rest out of the pointer
[08:20:43] <mcpherrin> we can't do that since we don't own the list
[08:21:02] <Vermeille> pause :D !
[08:21:38] <Vermeille> Hum okay, so basically, we cannot move an internal unique_ptr of a borrowed pointer?
[08:21:43] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[08:21:51] <eddyb> Vermeille: nope
[08:22:01] <eddyb> Vermeille: there could be a million & to the same object
[08:22:07] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Connection reset by peer)
[08:22:35] <mcpherrin> Instead, we want a &List
[08:22:44] <mcpherrin> so we add the keyword "ref"
[08:22:45] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[08:23:14] <mcpherrin> saying "ref variable_name" means that you want a reference (aka borrowed ptr) to the thing variable_name matches in the pattern
[08:23:28] *** Joins: osa1 (omer@94EFD94F.BD5FF59B.AAC341FF.IP)
[08:23:42] <Vermeille> mcpherrin: matching Node(~next) would mean "take ownership of the next uniq ptr"?
[08:24:01] <eddyb> Vermeille: (sorry, phonecall). if you were able to move out of &T, you'd ruin it for everyone else, cause dangling pointers, etc.
[08:24:02] <Boscop> mcpherrin: if you owned the list and did Node(~rest), would rest be a duplicate (different memory)?
[08:24:08] <eddyb> Boscop: no
[08:24:26] <Vermeille> (and then needs to move/extract "next" out of the list we're matching against)
[08:24:52] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Ping timeout)
[08:24:53] *** Joins: alonlevy_ (alon@moz-EB7C9CF3.telavivmakers.org)
[08:24:56] <Vermeille> eddyb: that completely make sense, I never thought about that when doing C++, damn
[08:25:13] <Vermeille> (thankfully I don't write a lot of multithreading stuff)
[08:25:17] <eddyb> Vermeille: then you probably wrote buggy code :P
[08:25:19] <Boscop> mcpherrin: why isn't the syntax Node(~&rest) ?
[08:25:26] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[08:25:27] <eddyb> Boscop: because & unpacks a &
[08:25:31] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[08:25:32] <mcpherrin> Boscop: & and ref are opposites
[08:25:35] <Boscop> ok
[08:25:48] <eddyb> so (&ref x) is a noop
[08:25:48] *** Quits: kris (kris@moz-A7897749.gjk.dk) (Ping timeout)
[08:25:56] <Boscop> yeah
[08:26:07] *** Joins: kris (kris@moz-A7897749.gjk.dk)
[08:26:12] <Vermeille> okay, so why ~ref and not just ref?
[08:26:15] <eddyb> (except in the case of &mut or reborrow workarounds)
[08:26:20] <eddyb> Vermeille: you can use just ref
[08:26:35] <eddyb> Vermeille: but you have to do &**node to access the interior
[08:26:44] <Vermeille> O_O
[08:26:45] <mcpherrin> Vermeille: if you do Node(ref next), you will have type &~List
[08:27:00] <mcpherrin> double pointer.
[08:27:04] * dougxxx waits for them to explain that one~
[08:27:21] <eddyb> Vermeille: two derefs for the two pointers, then a borrow for the contents
[08:27:33] <Vermeille> that make sense, I took a ref to the uniq box, not the data it holds
[08:27:41] <eddyb> mhmm
[08:27:52] *** Quits: W0rmDr1nk (wormdrink@moz-CEAF0263.access.mtnbusiness.co.za) (Ping timeout)
[08:30:52] <Vermeille> Okay, I think I got it
[08:30:53] *** Joins: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP)
[08:30:56] *** Joins: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP)
[08:31:16] <Vermeille> Obviously, there's no need for such a thing with Rc and Gc since you can safely copy them etc
[08:31:21] <Vermeille> right?
[08:31:36] <Vermeille> Hum, that's not that obvious
[08:32:17] <mcpherrin> Borrowing out of an Rc is common
[08:32:28] <mcpherrin> you avoid the churn of incrementing and decremnting refcounts
[08:32:33] *** Joins: W0rmDr1nk (wormdrink@moz-CEAF0263.access.mtnbusiness.co.za)
[08:32:33] <eddyb> Vermeille: you can only copy Gc
[08:32:51] *** Quits: erickt (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[08:32:53] <eddyb> Vermeille: you have to clone Rc (even if it's just a refcount bump)
[08:33:20] <Vermeille> How do you do that with pattern matching?
[08:33:31] <eddyb> you take a ref and call clone
[08:33:38] <Vermeille> okay
[08:33:44] <eddyb> or you can just do &**x on x: &Rc<T> to get &T
[08:33:55] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Ping timeout)
[08:34:08] <Vermeille> weird
[08:34:12] <eddyb> Vermeille: we may get a pattern to borrow the interior of a smart pointer (i.e. overloaded Deref)
[08:34:14] <Vermeille> is that a common pattern?
[08:34:24] <Boscop> eddyb: so both & and * dereference a &?
[08:34:46] <eddyb> Boscop: patterns destructure, they do the opposite of their expression counterparts
[08:35:00] <eddyb> &** dereferences twice and takes a reference to that lvalue
[08:35:12] <eddyb> & in a pattern dereferences &T or &mut T
[08:35:35] <kimundi> let x = *foo; let &x = foo; // identical
[08:35:40] <Boscop> yeah, so ref creates a new reference?
[08:35:45] <kimundi> yup
[08:35:49] <Boscop> ok
[08:36:12] <eddyb> Vermeille: I've been thinking "box" could be used to dereference any smart pointer
[08:36:40] <eddyb> Vermeille: so let box ref y = x; could be let y = &*x;
[08:36:55] <dougxxx> (but watch out for &&, which is and, not & &)
[08:36:58] <Vermeille> Okay, so, let's say I want to pattern match against Option<~(int, MyStruct)>, how would you write that? I tried to match against Just (~ref(a, b)), and the compilers screamed :D
[08:37:03] <eddyb> dougxxx: that's a parser bug
[08:37:14] <eddyb> rusti: &&0
[08:37:14] -rusti- <anon>:11:9: 11:11 error: unexpected token: `&&`
[08:37:14] -rusti- <anon>:11         &&0
[08:37:14] -rusti-                   ^~
[08:37:14] -rusti- playpen: application terminated with error code 101
[08:37:16] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[08:37:21] <eddyb> it works fine with || and closures
[08:37:26] <eddyb> rusti: || 0
[08:37:29] -rusti- pastebinned 8 lines of output: http://ix.io/bqs
[08:37:32] <kimundi> Vermeille: match { Some(~(a, m)) => ...
[08:37:45] <Vermeille> arrrggglll
[08:37:45] <eddyb> Vermeille: haha, Just
[08:37:50] <eddyb> first look at the variants ;)
[08:38:08] *** Joins: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com)
[08:38:12] <Vermeille> Sorry, I obviously wrote Some
[08:38:23] <eddyb> Vermeille: ref is for bindings
[08:38:33] <eddyb> Vermeille: Some(~(ref a, ref b))
[08:38:56] <Vermeille> daaaaaaaaaaaamn
[08:38:58] <Vermeille> okay
[08:38:59] *** Quits: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP) (Quit: leaving)
[08:39:03] <Vermeille> I think I really got it now
[08:40:06] <Vermeille> what do you adviise, Rc or Gc?
[08:40:14] <kimundi> Rc
[08:40:20] <kimundi> Becuase Gc does not work yet
[08:40:32] <Vermeille> seems legit
[08:40:40] <kimundi> But in principle, it depends on your usecase
[08:40:52] *** Joins: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP)
[08:40:55] *** Joins: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP)
[08:41:13] <Vermeille> it depends on  if you want the destructor to be called deterministically?
[08:41:23] *** Quits: osa1 (omer@94EFD94F.BD5FF59B.AAC341FF.IP) (Ping timeout)
[08:41:35] <eddyb> Vermeille: and your heap to not be 3x :P
[08:41:35] <kimundi> True shared ownership => gc. determinstic tree-like ownership with backlinks: Rc
[08:41:37] <kimundi> yeah
[08:42:08] <eddyb> Vermeille: you rarely need to even consider the presence of GC, thankfully
[08:42:20] * eddyb gets excited about removing @
[08:42:23] *** Joins: Titof (Titof@moz-44331C97.w81-248.abo.wanadoo.fr)
[08:42:47] * eddyb still has an impossible error
[08:42:55] <Vermeille> eddyb: hmmm okay, that's not very clear to me since there's not direct C++ synonym
[08:43:04] <eddyb> Vermeille: for?
[08:43:09] <Vermeille> Gc
[08:43:58] <Vermeille> Rc is a shared_ptr, if I'm not wrong
[08:45:01] <eddyb> shared_ptr is more like Arc
[08:46:20] <mcpherrin> Rc isn't thread-safe
[08:46:24] <mcpherrin> Arc is
[08:46:27] <Vermeille> I don't know what Arc is, and I don't want to dive into Rust's details before being really familiar with the surface
[08:46:47] <mcpherrin> Like Rc but more Atomic ;)
[08:46:56] <eddyb> Vermeille: it's literally Atomic Rc
[08:46:57] <Vermeille> Oh okay.
[08:47:10] <eddyb> shared_ptr is pretty costy
[08:47:12] <eddyb> *costly
[08:47:39] <Vermeille> I know ._. I almost never use them
[08:47:40] <eddyb> I heard LLVM got some kind of fancy atomic refcount elision optimization just to deal with shared_ptr
[08:47:56] <eddyb> ah, there we go
[08:48:07] <eddyb> Vermeille: shared_ptr<T> is Option<Arc<T>>
[08:48:13] <eddyb> (I knew I was missing something)
[08:48:21] <eddyb> Vermeille: it's pretty bad compared to Rc<T>
[08:48:49] <Vermeille> Option because they can be set to nullptr?
[08:48:59] <eddyb> yupp
[08:49:25] *** Quits: killerswan (kevin.cant@moz-1F697F7B.uvs.sntcca.sbcglobal.net) (Quit: Leaving)
[08:49:33] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Connection reset by peer)
[08:49:40] <Vermeille> Hum okay. Is Option the only to represent an unset/uninitialized value?
[08:49:48] <Vermeille> +way
[08:49:57] <eddyb> Vermeille: any isomorphic enum will do ;)
[08:50:01] <eddyb> like Result<T, ()>
[08:50:04] <Vermeille> Sure
[08:50:27] <Vermeille> I mean, there is nothing less high level?
[08:50:44] <eddyb> Vermeille: you can use the unsafe init (zero) / uninit (undef) intrinsics, when dealing with FFI and such
[08:50:44] <Vermeille> I'm quite worried by all those enums and ADT, I don't know how much they cost
[08:51:00] <mcpherrin> The costs are fairly minimal
[08:51:13] <eddyb> and we try to add more and more optimizations to them
[08:51:24] <mcpherrin> Option<~T> just ends up being a nullable pointer, which is an important optimization
[08:51:34] <eddyb> Option<&T>, Result<~T, ()> etc. are just a nullable pointer
[08:52:03] <Vermeille> Good. I feared it was not handled by an underlying pointer.
[08:52:28] <eddyb> Vermeille: Rc/Arc are not currently considered non-null. soon to be fixed
[08:52:34] <mcpherrin> An important part of rust is that the abstractions should have minimal cost
[08:52:42] <eddyb> I also would like to optimize Option<Option<(~T, ~T)>> to be just two pointers :D
[08:52:57] <eddyb> (we already have some of the logic to handle that, just not recursively)
[08:53:09] *** Joins: soumyaC (uid15286@moz-E77DEB21.irccloud.com)
[08:53:33] <Vermeille> Great. This language is really wonderful.
[08:53:59] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[08:54:36] <Vermeille> Thank you guys :)
[08:54:51] <Vermeille> I promise I'll do a talk on Rust at my school :D
[08:55:15] *** Joins: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP)
[08:55:15] *** Quits: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP) (Input/output error)
[08:55:37] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:55:39] *** Joins: mihneadb (mihneadb@moz-6B31F5AA.static.ziggozakelijk.nl)
[08:55:50] <Vermeille> What about mut?
[08:56:01] <eddyb> what about it?
[08:56:10] <Vermeille> is that a qualifier for the variable, for the type, an operator?
[08:56:29] <eddyb> Vermeille: qualifier for bindings and the &mut operator
[08:56:34] *** Quits: Hail_Spacecake (frank@682FC60C.A4ACDD73.AED9BA81.IP) (Ping timeout)
[08:56:38] <eddyb> Vermeille: well, also the type
[08:56:48] <eddyb> &mut T, &mut x and let mut x = ...;
[08:57:08] <Vermeille> and as a parameter?
[08:57:35] <Vermeille> let mut x: int = 42 or let mut x: mut int = 42 ?
[08:57:59] <kimundi> Vermeille: Its never a explicit operator for a type
[08:58:13] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Ping timeout)
[08:58:17] <kimundi> Vermeille: &mut T is the only type that contains the "mut" keyword
[08:58:27] <Vermeille> Okay.
[08:58:35] <Vermeille> That's what confused me.
[08:58:39] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[08:58:46] <kimundi> Vermeille: Apart from that, mut is just a modifier for a pattern binding, like ref
[08:59:07] <Vermeille> ok
[08:59:10] <kimundi> let mut x = foo; let ref x = foo; let ref mut = foo;
[08:59:34] <kimundi> mutable x, immutable &x, immutable &mut x
[08:59:53] *** Joins: Hail_Spacecake (frank@682FC60C.A4ACDD73.AED9BA81.IP)
[08:59:57] <kimundi> theoreticaly, let mut ref mut x = foo; should also be valid, but it isn't for some reason.
[08:59:57] <mcpherrin> let mut ref mut x = foo?
[09:00:10] <Boscop> can refs be reassigned?
[09:00:31] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[09:01:02] <kimundi> Boscop: You can only change the thing a reference points at with `&mut` references. Changing the reference itself is only allowed if it is itself mutable.
[09:01:03] *** Joins: Earnestly (earnest@moz-6CD1AB70.dyn.plus.net)
[09:01:23] <Vermeille> let mut x = foo; let ref x = foo; let ref mut = foo; ====> say x is of type T, T; const T* const; T* const; ?
[09:01:39] <kimundi> let mut x = &foo(); // can change to contain a different reference
[09:01:42] <Boscop> is immutability transitive?
[09:01:47] <eddyb> Vermeille: pls
[09:01:54] <eddyb> Vermeille: C/C++ type grammar is unreadable
[09:02:21] <Vermeille> Sorry, that's the only I'm proficient in.
[09:02:38] <eddyb> *even after working for years with it*
[09:02:46] <eddyb> Vermeille: you will embrace sanity :D
[09:03:15] <Boscop> e.g. in D you have a way to apply the mutability of a symbol to another symbol's declaration
[09:03:38] <kimundi> Boscop: mutability "inherits" through owned types. Its not a clear defined concept though, and types can manually break this chain of mutability inheritance.
[09:03:49] <Vermeille> eddyb: That's why I'm trying to learn Rust ;) I want a better daily language
[09:04:06] <Boscop> so you can have a const LinkedList where each of the payloads are const but the pointers aren't
[09:04:16] <kimundi> Boscop: let x = ~~~~~5; // x is immutable, therefore every single layer of ~ is too
[09:04:37] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[09:05:09] <kimundi> Boscop: Depends. What would be the usecase of it?
[09:05:11] <Boscop> kimundi: but how does it work with custom smart pointers?
[09:05:33] <Boscop> (that is the problem in D)
[09:05:45] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Client exited)
[09:05:51] *** Quits: sanxiyn (tinuviel@B4104EBB.3CC170B1.1E14B209.IP) (Ping timeout)
[09:06:04] <Boscop> in D const(*T) == *const(T), but there is no way to do this for custom smart pointers
[09:06:28] <Boscop> err, const(*const(T))==const(*T)
[09:06:33] *** Quits: Titof (Titof@moz-44331C97.w81-248.abo.wanadoo.fr) (Ping timeout)
[09:06:49] *** Parts: dougxxx (dougxxx@moz-2801788.perm.iinet.net.au) (Leaving...)
[09:06:59] <kimundi> Boscop: A custom smartpointer is a type that exposes functions/methods that take self either by value, by mutable reference, or by immutable reference. Depending what those operations are, you can either also mutate the content, or not.
[09:07:09] *** Joins: Titof (Titof@moz-143B5C19.w92-160.abo.wanadoo.fr)
[09:07:36] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Ping timeout)
[09:08:12] *** Joins: nical (nico@moz-99690620.hinet-ip.hinet.net)
[09:08:17] <kimundi> Boscop: immutability in Rust is not a direct property of a type. But you could write a custom smartpointer that has mutation methods for itself, but only exposes immutable &T access to its contents
[09:09:04] <Boscop> kimundi: can you transfer the mutability of the type parameter to a member declaration?
[09:09:11] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[09:09:13] <Boscop> or part of it
[09:09:30] *** Quits: Titof (Titof@moz-143B5C19.w92-160.abo.wanadoo.fr) (Quit: Ash nazg durbatulûk, ash nazg gimbatul, ash nazg thrakatulûk agh burzum-ishi krimpatul.)
[09:09:32] <kimundi> Boscop: No, because type paramters have no concept of mutability.
[09:10:06] <eddyb> nor members
[09:10:31] <kimundi> Its the location where the _value_ is allocated that either permits you to mutate, or not, but allowing you to either borrow a & to it, or both a & and &mut
[09:10:36] <Boscop> kimundi: e.g. in D you get implicit conversion from a const(*const(T)) to a const(*T). how would you achieve a similar impl conversion in rust for custom smart pointers?
[09:10:56] <kimundi> Boscop: Well, for one we don'T have const pointers, so... :P
[09:11:06] <Boscop> immutable then
[09:11:30] *** Quits: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com) (Quit: Computer has gone to sleep.)
[09:11:58] <eddyb> Boscop: both of your examples look like &T
[09:12:08] <eddyb> (in Rust)
[09:12:11] <Boscop> eddyb: yes but for custom smart pointer types
[09:12:29] <Boscop> how would you get the implicit conversion / the immutability transitivity
[09:12:29] <eddyb> Boscop: I mean, what you wrote doesn't parse
[09:12:51] <eddyb> *const T would be &T
[09:12:59] <eddyb> const(*T) is what?
[09:13:06] <eddyb> &mut T in an immutable slot?
[09:13:25] <Boscop> const(*T) == const(*const(T))
[09:13:30] <Boscop> it's transitive
[09:13:47] <Boscop> but only for built-in pointer types
[09:14:04] <Yurume> eddyb: lol, it's unsafe to adventure alone indeed!
[09:14:21] <eddyb> Boscop: Rust doesn't distinguish
[09:14:25] <Yurume> (this time I PM'ed him/her though)
[09:14:47] <eddyb> Boscop: I mean, your example doesn't make sense in the context of Rust
[09:15:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[09:16:03] <farcaller> I can't figure out what is the source for sha256 sum in lib name. Is that the text in #[crate_id = "whatever#4.2"]; ? 
[09:16:13] <kimundi> Boscop: I think this is the closest: let x = &mut 5; let y = &x; **y = 10; // ERROR: can not assign to a &mut through an immutable reference
[09:16:20] <Vermeille> Is there a way to take a &T (or a T) inside an Option? it seems that unwraps moves out the content
[09:16:46] <eddyb> Vermeille: .as_ref(), maybe?
[09:17:03] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[09:17:06] <kimundi> Vermeille: without explicit pattern matching, as_Ref().unwrap() gives you a &T
[09:17:07] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[09:17:24] <kimundi> opt.as_ref().unwrap()
[09:18:02] <Vermeille> eww
[09:18:02] <kimundi> its the same as doing let x: &T = match t { Some(ref v) => v; None => fail!() }
[09:18:04] <Vermeille> okay
[09:18:18] *** Quits: p1start (rewi@moz-E7F3D014.org) (Ping timeout)
[09:19:22] <kimundi> Vermeille: eww is alright, usually you should not use unwrap() often :) There are a lot of methods defined for Option which allow you to work with a possible content without unwraping it first
[09:20:00] <eddyb> farcaller: more like a hash of the AST
[09:20:02] <eddyb> (AFAIK)
[09:20:10] <Vermeille> I agree, though I'm just prototyping right now, I don't really care if my code is not safe
[09:20:31] <eddyb> failure-safe, you mean :P?
[09:20:39] <Vermeille> if you prefer
[09:20:41] <kimundi> Safe it will be in eitehr case :)
[09:20:53] <kimundi> err, "memory safe"
[09:21:03] <Vermeille> if it does not crash*
[09:21:22] <farcaller> eddyb: I'm not sure how can I make a dependency rule for external create, if I don't know the file name for resulting .rlib
[09:21:29] <kimundi> which it won'T in a bug free rustc
[09:21:35] <kimundi> fail!() is not a crash
[09:21:47] <eddyb> farcaller: run rustc with --make-deps?
[09:21:49] * eddyb is not sure
[09:21:50] <Vermeille> Still, you got my point.
[09:21:54] <kimundi> yeah
[09:22:01] <farcaller> eddyb: https://github.com/mozilla/rust/commit/b349036e5f4f5f42e34ae9dd7859f3dc7a79de94 this one supposed to drop dependency of hash on  anything other than pkgid
[09:22:08] *** Quits: Jesse (jruderman@moz-9754CB0.hsd1.ca.comcast.net) (Quit: Jesse)
[09:22:14] <kimundi> Just trying to make the distinction here, because its important :)
[09:22:26] <farcaller> eddyb: error: Unrecognized option: 'make-deps'.
[09:22:33] <Vermeille> that's anyway an abnormal termination for 99% of programs
[09:22:49] <kimundi> But a _controlled_ one
[09:23:07] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Client exited)
[09:23:08] <eddyb> farcaller: that precedes SVH by months
[09:23:23] <Vermeille> I don't get why it's so important to you, but ok
[09:23:41] <eddyb> failure is not `unsafe`, abort is
[09:23:45] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[09:23:51] <eddyb> (failure unwinds and cleans up resources)
[09:23:54] <kimundi> It cleanly unwinds the stack, runs destructors etc. A crash might do anything, including stealing your credit cards numbers and selling your house on ebay if exploited. ;)
[09:24:17] <eddyb> Vermeille: you can treat tasks as disposable workers
[09:24:24] <Vermeille> True, I did not think about that.
[09:24:43] <eddyb> not unlike Erlang (or Hydra)
[09:24:52] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[09:24:52] <eddyb> (the latter from mythology)
[09:25:36] <eddyb> unwinding is not an efficient error handling mechanism, but it is a pretty good bailing one
[09:25:45] <Vermeille> *my_option.as_ref().unwrap() does not work, cannot dereference or move out&-ptr
[09:26:06] <eddyb> Vermeille: of course it doesn't work for moving out :)
[09:26:13] <farcaller> eddyb: apparently, I can name the crate libwhatever-0-0.0.rlib and rustc will find it anyway :-)
[09:26:16] <Vermeille> :'(
[09:26:24] <dsrx> Vermeille: look at Option.take()
[09:26:25] <Vermeille> I'm way too old to learn a new language
[09:26:28] <eddyb> farcaller: oh, that will work. but not intended
[09:27:14] <Vermeille> dsrx: that's exactly what I want to avoid
[09:27:18] <farcaller> eddyb: given that I abuse rust in many other ways with rustc-llc-as, I don't think this is the worst I did :-)
[09:27:50] <eddyb> Vermeille: you have to either move out or not :)
[09:28:21] <farcaller> eddyb: all the __morestack stuff adds up to 30% of binary size and the only thing it does is loop{} in case if I run out of stack, which would happen anyway if I go outside of ram bounds :)
[09:28:32] <Vermeille> Why? it's a &ptr, why can't I just look at its value?
[09:28:53] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Ping timeout)
[09:29:01] <eddyb> Vermeille: you can look at its value, but you can't move it out
[09:29:10] <farcaller> eddyb: also loop{}'ed away __aeabi_unwind_cpp_pr0 as there's nowhere to unwind. So, having incorrectly named libs (as long as they work) should be fine
[09:29:13] <eddyb> Vermeille: Rust actually has (second-class) lvalues
[09:29:32] <eddyb> Vermeille: *x with x a &T will not move out unless used as a value
[09:29:54] <Vermeille> what means "used as a value"?
[09:30:37] <Vermeille> Ooooooooooooooooooooh yeaaaah, there's not automatic copy construction, right?
[09:30:42] <eddyb> :)
[09:30:43] <kimundi> let x = *foo; // used as a value, will move is foo moves
[09:31:02] <kimundi> let x = &*foo; // used as a reference, will not move even if foo moves
[09:31:09] <eddyb> Vermeille: pattern matching doesn't use as a value ;)
[09:31:18] <eddyb> in let x = *foo;, the thing that moves out is `x`
[09:31:26] <eddyb> let ref x = *foo; will work just fine
[09:31:32] <kimundi> pattern matching only goes purely after the structure
[09:31:34] <eddyb> same for match *x
[09:31:46] <kimundi> the bindings are the thing that might cause it to move or borrow only
[09:31:49] <Vermeille> I think I see
[09:31:52] <Vermeille> Wow.
[09:32:02] <Vermeille> zero implicit copy in rust?
[09:32:05] <eddyb> yupp
[09:32:23] <Vermeille> Wow.
[09:32:27] <eddyb> (other than, uhm, large Copy-able values, like [u8, ..1024])
[09:32:28] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Quit: Leaving.)
[09:33:05] <kimundi> Well, we have implicuit copy, but only for explict by value passing or assignment
[09:33:10] <Vermeille> if I want to copy a custom struct, I have to do that either with an explicit .clone() or explicit =?
[09:33:19] <kimundi> let x = 5;m let y = x; // Does a implicit copy of course
[09:33:37] <Vermeille> "=" is not that implicit :D
[09:33:52] <eddyb> Vermeille: you can copy structs as long as they're Copy
[09:34:02] <eddyb> i.e. made out of copyable values
[09:34:34] <Vermeille> implicitly?
[09:34:51] <kimundi> Vermeille: If the struct is Copy, a = will leave the original accessible, so you get a copy. If the struct is not Copy, it moves, which still does a copy internally, but invalidates the source, so you still only have one useable value.
[09:35:33] <kimundi> let x = 5; let y = x; // shallow copy, both x and y useable
[09:35:37] <eddyb> Vermeille: there is a distinctions between shallow copies (Copy-able types) and Clone
[09:35:48] <kimundi> let x = ~5; let y = x; // shallow copy, only y useable
[09:36:06] <Vermeille> okay, the distinction between shallow and deep copy is clear to me
[09:36:11] <kimundi> CLone is just a library feature that gives you a T for a &T
[09:36:15] <eddyb> Vermeille: copy stuff from C++ is equivalent to Clone. only move ctors/operators are close to Rust's semantics
[09:36:29] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[09:37:12] <Vermeille> doesnt all this implies some boilerplate code or complexity?
[09:37:46] <eddyb> Vermeille: only if you want to be inefficient ;)
[09:37:51] <kimundi> Clone is defined as doing the least amount of work to get a T from a &T. So for ~T, it needs to allocate a new box on the heap to turn &~T into ~T, but for Rc<T> it can just do a refbump and return a new handle
[09:37:53] <eddyb> Clone is despised in general
[09:38:50] <Vermeille> which is understandable
[09:39:01] <Vermeille> would you qualify Rust as a simple language?
[09:39:30] <kimundi> Vermeille: It does indeed get a bit more verbose, but thats all intentional: The user of the language should be able to see where a non-shallow copy is being made, and have control over it.
[09:39:45] <kimundi> Vermeille: Its certainly not simple
[09:40:11] <Vermeille> kimundi: I clearly understand the intent. Sometimes the C++'s implicit copy just tricks you.
[09:42:01] *** Joins: io2 (io2@moz-EE406A5.home.otenet.gr)
[09:42:15] <kimundi> Vermeille: Rust is memory safe and fast, and tries to not develop in the convoluted thing of partially unsafe, non-orthogonal overlapping features that C++ is, but its not simple in general. I would claim it to be simpler than C++ though. :)
[09:42:42] <Vermeille> Pffffffffffffff, there's no simple static language today :(
[09:42:58] *** Joins: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be)
[09:43:03] <eddyb> because it's not a simple problem :P
[09:43:06] <Vermeille> No, I don't consider Java as a language, that's a toy, at most.
[09:43:09] <kimundi> Go is a simple language, apparently :P
[09:43:17] <eddyb> Go is not systems programming
[09:43:34] <kimundi> That was not listed as a requirement ;)
[09:43:36] <eddyb> even though its silly marketing dept considers it as such
[09:43:38] * Ms2ger wanders into #bashingprogramminglanguages
[09:44:02] <eddyb> systems programming is not "dumb as C" but rather "low level control"
[09:44:04] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[09:44:04] <Vermeille> C# is not that bad, after all
[09:44:15] <eddyb> C# has GC and IL ;)
[09:45:10] <Vermeille> and?
[09:45:32] <eddyb> => not a systems programming language
[09:45:44] <Vermeille> Ah, right
[09:45:57] <kimundi> For the record, I think all languages mentioned here have their place and target user group.
[09:46:00] <eddyb> (also its typing is quite dynamic)
[09:46:03] <eddyb> kimundi: sure
[09:46:12] <eddyb> but not this user group :D
[09:46:15] <eddyb> THIS ONE WANTS MORE
[09:46:22] <Vermeille> No, Java just diserves to die
[09:46:24] <Vermeille> In Hell.
[09:46:29] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Quit: Leaving.)
[09:46:33] <Ms2ger> That's not nice
[09:46:42] <eddyb> Ms2ger likes his Java beans
[09:46:53] <Ms2ger> I don't like Java
[09:46:59] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Ping timeout)
[09:47:05] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[09:47:06] <kimundi> Vermeille: But... It got lambdas now, certainly thats a redeeming quality? ;D
[09:47:08] <Ms2ger> I don't feel like hating it is good for anything, though
[09:47:16] <eddyb> Ms2ger: coffee >_>
[09:47:33] *** Joins: oxum (anonymous@55D1CC88.D2D0C1C4.520CDC98.IP)
[09:47:55] <Vermeille> kimundi: hahaha, yes, thankfully Python, Haskell, and EVEN C++ had them before x)
[09:47:59] <Ms2ger> Btw
[09:48:00] <Ms2ger> http://krijnhoetmer.nl/irc-logs/whatwg/20140402#l-61
[09:48:41] <kimundi> Ms2ger: Agreed. While I like to make jokes about it, actually hating and bashing a programming language always struct me as totally pointless.
[09:50:02] *** Joins: skade (skade@moz-594FF438.web.vodafone.de)
[09:50:24] *** Joins: marc_ (uid5324@moz-31ABA2C0.irccloud.com)
[09:50:43] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[09:50:46] <Vermeille> I personally really like that Rust's verbosity is really reduced
[09:51:24] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: Leaving.)
[09:51:55] <Vermeille> noob question : how can rust be a system PL with such a runtime?
[09:52:43] <kimundi> Vermeille: THe runtime is optional
[09:53:02] *** Quits: skade (skade@moz-594FF438.web.vodafone.de) (Ping timeout)
[09:53:21] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[09:53:47] <kimundi> Vermeille: You can compile freestanding rust, which means you need to either not-use or defined each part iof the language that needs library support, like allocators, or failure.
[09:54:40] <farcaller> Vermeille: it actually works quite well as a free-standing compiler
[09:54:42] <Vermeille> Oh yeah. And ~ are not actually in the runtime, but fully handled by the compiler 
[09:55:34] <kimundi> Vermeille: ~T is handled by the compiler, but it ultimativly just emits call to a malloc() and free() lang item, which you have to defined yourself in freestanding rust.
[09:55:36] <Vermeille> True. What about enums? Does it implies a runtime?
[09:55:47] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[09:56:03] <kimundi> enums are just tagged unions, which is just integers and structs basically.
[09:56:33] *** Joins: osa1 (omer@1F124F9F.AD1E507F.3688B332.IP)
[09:57:40] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[09:57:44] <Vermeille> What about the pattern matching? There shoul be some kind of Unify() algorithm, unless it's less powerful than Haskell's
[09:58:05] <kimundi> pattern matching just compiles down to some kind of switch
[09:58:27] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[09:58:34] <kimundi> err, "match" does that. pattern matching itself can compile down to nothing, depedning on what you are mathcing
[09:58:36] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.3.1)
[10:00:08] <kimundi> let Foo(Bar(Baz(value))) = foo(); // If those are all all unit structs around a uint, then this can all disappear during compilation and get reduced down to "let x: uint = casted_foo()"
[10:00:31] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[10:00:59] <kimundi> Vermeille: I'm not actually sure what you mean with Unify() there
[10:01:48] <kimundi> Do you have a example?
[10:02:19] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Client exited)
[10:04:12] <Vermeille> Not a linkable one
[10:04:56] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[10:05:13] <Vermeille> If you have the AI: a modern approach by Peter Norvig and S Russel, you can check it out in the chapter about their first order logic language
[10:06:20] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[10:06:42] <Vermeille> (Or Maybe second order, I don't remember)
[10:06:44] <kimundi> Well, I don't own that book so I still have no idea what this is about :)
[10:07:24] <Vermeille> It's a way to do some pattern matching by matching two ASTs, a pattern and the value
[10:07:41] *** Joins: paraze (paraze@moz-F2628701.w90-27.abo.wanadoo.fr)
[10:08:41] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[10:08:41] *** Quits: bjz_ (bjz@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[10:09:27] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[10:10:03] <kimundi> Huh, this sounds more complicated than what rust does.
[10:10:27] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Ping timeout)
[10:10:53] <kimundi> pattern matching is rust is just pattern + value => codegen with conditional branches for all possible cases.
[10:11:09] *** Quits: nical (nico@moz-99690620.hinet-ip.hinet.net) (Ping timeout)
[10:11:43] *** jorendorff_away is now known as jorendorff
[10:11:52] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[10:12:31] <Vermeille> Well, yes, right, it's not the same environment
[10:12:36] <kimundi> which is a fairly local, and does require zero work at runtime apart from the actual pointer and memcpy shuffling of bindings.
[10:13:00] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[10:13:30] <Vermeille> True, "my" approach is valid in an interpreter, you can't do switches.
[10:13:49] <Vermeille> (unless you generate code at runtime on an executable page, but heh.)
[10:14:13] <kimundi> Vermeille: Is this the distincion you talked about: http://stackoverflow.com/questions/9780779/pattern-matching-prolog-vs-haskell ?
[10:14:48] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[10:15:10] *** Quits: Earnestly (earnest@moz-6CD1AB70.dyn.plus.net) (Quit: WeeChat 0.4.4-dev)
[10:16:21] *** Joins: vgeddes (vincent.ge@moz-102C6E36.access.mtnbusiness.co.za)
[10:16:52] <Vermeille> kimundi: yes
[10:16:57] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[10:17:25] <kimundi> I see, in that case we are similar to haskell in that its only unidirectional pattern matching.
[10:19:06] *** Joins: Earnestly (earnest@moz-6CD1AB70.dyn.plus.net)
[10:19:54] *** Quits: EKK (kviiri@moz-4C25427B.cs.helsinki.fi) (Ping timeout)
[10:20:38] <Vermeille> There's too much things to learn ._.
[10:21:07] <Havvy> rusti:  isNaN("true")
[10:21:07] -rusti- <anon>:11:10: 11:15 error: unresolved name `isNaN`.
[10:21:07] -rusti- <anon>:11          isNaN("true")
[10:21:08] -rusti-                    ^~~~~
[10:21:08] -rusti- error: aborting due to previous error
[10:21:08] -rusti- playpen: application terminated with error code 101
[10:21:41] <Vermeille> they are* I'll start with english.
[10:21:51] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[10:23:12] *** Joins: NiccosSystem (NiccosSyst@moz-ED196BB4.customer.lyse.net)
[10:23:18] *** Quits: Hail_Spacecake (frank@682FC60C.A4ACDD73.AED9BA81.IP) (Ping timeout)
[10:23:59] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[10:24:54] *** Joins: nical (nico@moz-99690620.hinet-ip.hinet.net)
[10:25:24] *** Quits: mankyKitty (Instantbir@19559281.CA335678.BC02889B.IP) (Quit: mankyKitty)
[10:27:09] *** Joins: EKK (kviiri@moz-4C25427B.cs.helsinki.fi)
[10:28:47] *** Quits: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com) (Connection reset by peer)
[10:31:10] *** Joins: BossKonaSegway (Michael@moz-2986F42D.col.wideopenwest.com)
[10:31:37] <Vermeille> Let's say I write a software in Rust, do my users need to install a redistributable or something?
[10:31:53] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Client exited)
[10:32:09] *** Quits: benjamin_ (benjamin@moz-5894B012.dip0.t-ipconnect.de) (Ping timeout)
[10:32:17] <Havvy> Vermeille:  No.
[10:32:52] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[10:32:52] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[10:33:42] *** Quits: benbangert (bbangert@moz-B1FEE9C0.org) (Ping timeout)
[10:34:46] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[10:35:21] <kimundi> Vermeille: It depends
[10:37:09] *** Joins: benbangert (bbangert@moz-B1FEE9C0.org)
[10:39:52] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[10:40:04] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[10:42:54] *** Quits: mno2 (mno2@E1E0A0A3.621D86F0.CFF65E33.IP) (Quit: mno2)
[10:43:58] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[10:44:18] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[10:46:43] *** Quits: phay (phay@16E8BAAB.D2C4A785.91986DB5.IP) (Quit: phay)
[10:49:12] *** Quits: james4k (james@moz-9BB5AE72.consolidated.net) (Ping timeout)
[10:49:29] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[10:49:56] *** Joins: leowoe (Leo@moz-CEF2400C.inf.uni-konstanz.de)
[10:50:11] *** Joins: philix (felipe@moz-3F4DCEE1.host.telemar.net.br)
[10:51:10] *** Quits: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be) (Ping timeout)
[10:55:02] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[10:55:20] *** Quits: willingc (willingc@moz-F095E013.san.res.rr.com) (Client exited)
[10:57:28] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[10:58:12] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[10:59:23] <Vermeille> http://pastebin.com/vbdnGkeD I seriously don't get why I'm having those issues (in the bottom of the file, lines numbers are preserved)
[10:59:25] *** Joins: mib_akgrk8 (Mibbit@3E3094EC.34458CF2.CC1A2609.IP)
[10:59:27] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[10:59:36] *** jorendorff is now known as jorendorff_away
[10:59:38] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[10:59:40] *** Quits: mib_akgrk8 (Mibbit@3E3094EC.34458CF2.CC1A2609.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:59:56] <Vermeille> (except the one about mutability ofc)
[11:00:03] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[11:00:03] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[11:00:16] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[11:00:16] *** ChanServ sets mode: +o pnkfelix
[11:01:12] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[11:02:13] *** jorendorff_away is now known as jorendorff
[11:02:26] <SiegeLord> Hmm... freestanding num methods were removed
[11:02:37] <SiegeLord> I bet that permanently breaks my code, as I can't use the trait methods
[11:02:57] <SiegeLord> *freestanding functions
[11:04:13] <kimundi> Vermeille: looking...
[11:04:26] *** Quits: FrozenCow (FrozenCow@moz-54300F7F.upc-j.chello.nl) (Ping timeout)
[11:05:30] *** Quits: oxum (anonymous@55D1CC88.D2D0C1C4.520CDC98.IP) (Ping timeout)
[11:06:33] <kimundi> get(idx) returns a &T, so you have non-owning access to the "val" field. calling unwrap() on val would require val to move out of the &T, which requires ownership.
[11:06:52] <Vermeille> Errrrrrrrrrrrrr
[11:06:55] <Vermeille> Solution?
[11:07:41] <Vermeille> How can I have an owning access to the value of a Vec?
[11:08:20] <kimundi> you need to take a reference to val, can clone it to get a new Rc handle. .val.as_ref().unwrap().clone()
[11:08:48] <Vermeille> ._.
[11:08:49] <kimundi> Vermeille: to transfer ownership out of the vec, you need to remove the element from i. LIke with pop() or similar
[11:09:09] <pnkfelix> Vermeille: e.g. swap_remove
[11:09:26] <Vermeille> But I don't want to transfer the ownership
[11:09:29] <kimundi> Thats assuming you want to change the vector of course
[11:09:40] <Vermeille> I just want to copy the Rc inside
[11:09:52] <kimundi> Then you just want to increase the refcount, which theat lone line that terminates in clone() above does :)
[11:10:25] <Vermeille> Wow.
[11:10:28] <kimundi> Clone on &Rc<T> returns a Rc<T> and bumps the refcount
[11:11:00] <Vermeille> there's really nothing better than .as_ref().unwrap() ?
[11:11:04] <kimundi> as_ref() takes a reference to the .val field and returns a Option<&T>, which unwrap unwraps to the &T
[11:11:35] <kimundi> I think there is also get_ref()
[11:11:39] *** Joins: andre (andre@CA528A4A.45A4338E.8EE27E6.IP)
[11:11:40] <kimundi> which does the same
[11:11:42] <eddyb> pls no get_ref. very confusing
[11:12:03] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[11:12:13] <kimundi> I tend to forget about it because its just the combination of those two 
[11:12:26] <eddyb> .as_ref().unwrap().clone() is .clone().unwrap() btw
[11:12:32] *** Quits: aravindavk (aravinda@moz-BD0CADEE.redhat.com) (Ping timeout)
[11:12:41] <kimundi> true
[11:12:56] <eddyb> and then you can remove the outer unwrap or replace it with expect
[11:13:25] <kimundi> clone turns the &Option<Rc<T>> into a Option<Rc<T>> with a refbumped rc, which you can the unwrap()
[11:14:11] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[11:14:31] <Vermeille> Okay
[11:14:37] <Vermeille> Any plan for null pointers =D ?
[11:14:55] <kimundi> Option<~T> or Option<&T> optimize to a nullpointer
[11:15:11] <kimundi> Option<Rc<T>> don't currently, but will
[11:15:24] <Vermeille> I know, but they are strange to deal with :D
[11:15:32] <kimundi> (we need a way to write custom smartpointers that can use this optimization)
[11:15:45] <kimundi> Vermeille: You get used to it :)
[11:15:46] <eddyb> kimundi: already in the pipeline ;)
[11:15:54] *** Joins: tigrou3tac (fabien@moz-6E2397FF.fbx.proxad.net)
[11:18:56] <Boscop> kimundi: is that hardcoded into the compiler?
[11:19:30] <Boscop> or is there a general way to merge non-overlapping value spaces of variants?
[11:22:36] <eddyb> Boscop: not very general
[11:22:41] <eddyb> (but it could be more so)
[11:22:44] <Boscop> how general?
[11:22:56] <pnkfelix> Boscop: https://github.com/mozilla/rust/pull/6001
[11:23:17] <pnkfelix> Boscop: so its not special cased to just Option
[11:23:29] *** Joins: dranov (dranov@46290EAA.42CAD9AB.FCAAE698.IP)
[11:23:31] <pnkfelix> Boscop: but it also is not as aggressive/general as what you outlined.
[11:23:59] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[11:24:06] <Boscop> ok
[11:25:08] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[11:25:09] <eddyb> it shouldn't be hard to make Option<Option<(~T, ~T>> optimize to two null pointers
[11:25:40] <eddyb> it can already pick one point from a variant with more than one element
[11:25:45] <eddyb> just needs to do it recursively
[11:25:58] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[11:27:45] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[11:28:00] *** Joins: aravindavk (aravinda@moz-BD0CADEE.redhat.com)
[11:29:09] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[11:29:11] <Boscop> but inlining one level of Option removes the available slot in the domain of the value
[11:29:39] <Boscop> it would still need an indirection to encode the 2nd level
[11:30:08] <eddyb> Option<(~T, ~T)> would become (Nullable<~T>, ~T)
[11:30:27] <eddyb> and then Option<(Nullable<~T>, ~T)> would become (Nullable<~T>, Nullable<~T>)
[11:30:37] <eddyb> Boscop: it's an additive process
[11:32:14] <kimundi> eddyb: How would references into the interior factor into this?
[11:32:53] <eddyb> the original tuple, the one Option version and the two Option one would all have the same repr
[11:32:58] <eddyb> {T*, T*}
[11:34:33] <Boscop> so it would work with arbitrarily nested data structures where at some point there is a free slot in the domain?
[11:34:52] *** Quits: philix (felipe@moz-3F4DCEE1.host.telemar.net.br) (Ping timeout)
[11:34:59] <eddyb> Boscop: yupp
[11:36:02] <eddyb> I can see Option<(uint, bool)> be optimized to (uint, u8) where enum bool {false, true}
[11:36:24] *** Joins: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be)
[11:36:48] <Boscop> yes, i wished more languages would have that
[11:37:31] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Ping timeout)
[11:37:42] <Boscop> you can model every type as the domain of 2^(it'sbitwidth) and then find empty slots
[11:37:53] *** Joins: mye (mye@moz-BDEE7985.swh.uni-giessen.de)
[11:38:05] <eddyb> Boscop: char has 21 bits btw ;)
[11:38:13] <Boscop> to generalize it beyond Option
[11:38:22] <Boscop> eddyb: why 21?
[11:38:26] <eddyb> (not considered currently, but we do want generic ranges)
[11:38:29] <eddyb> Boscop: because Unicode
[11:38:41] <Ms2ger> Well, not 21 full bits
[11:38:56] <Ms2ger> Range 0-10FFFF
[11:38:58] <Zr40> Unicode codepoints go up to U+10FFFF, which you can represent with only 21 bits
[11:39:00] <Boscop> i thought rust uses utf8?
[11:39:15] <eddyb> ;)
[11:39:17] <Ms2ger> str != [char]
[11:39:24] <Boscop> yeah
[11:39:31] <Boscop> so will char be officially 21 bits?
[11:39:56] <Ms2ger> More like smallest power of two >= 21
[11:39:58] <Ms2ger> i.e. 32
[11:40:12] <farcaller> how can I disable array bounds checking (if I really need to)?
[11:40:18] <eddyb> farcaller: do you really need to?
[11:40:24] <huon> unsafe code
[11:40:27] <Boscop> you could also allow programmers to specify the int ranges they are using
[11:40:29] <eddyb> (hint: you can't. you need unsafe code for boundless access)
[11:40:30] <Ms2ger> But its value space is 0-10FFFF
[11:40:35] <huon> `unsafe { v.unsafe_get(i) }`
[11:40:48] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[11:40:50] <huon> is the bounds-checks-less version of v[i]
[11:40:53] <eddyb> Boscop: char is u32 atm
[11:41:00] *** Quits: aravindavk (aravinda@moz-BD0CADEE.redhat.com) (Ping timeout)
[11:41:02] *** Joins: Sorella (quildreen@89788746.FDF9B0F2.A95FAE2B.IP)
[11:41:02] <Boscop> like in Ada
[11:41:04] <eddyb> Boscop: and yes, we do want a ranged integer type
[11:41:04] <huon> eddyb: not just u32
[11:41:10] <Boscop> nice
[11:41:12] <eddyb> u32 with restrictions
[11:41:17] <farcaller> eddyb, huon: it's 100% safe, code like while i < 128 { self.wr_dat(self.videobuf[i]); i += 1; } whele i strictly < 512
[11:41:25] <huon> since it's legitimately UB to store a non-Unicode-scalar value
[11:41:33] <huon> farcaller: sounds like you want an iterator
[11:41:40] <eddyb> farcaller: that's not safe :P
[11:41:44] <eddyb> an iterator is safe
[11:41:44] *** Quits: meyer (meyer@moz-A9CF56E4.hsd1.ca.comcast.net) (Quit: meyer)
[11:41:49] <kimundi> farcaller: You can not disable existing bound checking, as it would invalidate the existing memory safety guarantees. But for your own code, you have the option of accessing arrays without bounds checking if you can ensure there is never an out-of-bounds error
[11:41:50] <huon> `for dat in self.videobuf.iter() { self.wr_dat(*dat) }
[11:41:51] <huon> `
[11:42:10] <huon> iterators + for are far better than a manual while loop, too. :)
[11:42:14] <kimundi> Iterators already employ this kind of optimization
[11:42:15] <farcaller> huon: https://gist.github.com/farcaller/5c803119e17beb452039
[11:42:20] <farcaller> I have 4 of those loops
[11:42:23] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[11:42:29] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:43:11] <farcaller> it's not like it has extremely bad performance, but it's kind of visible of slower clock speeds
[11:43:45] <farcaller> also I don't [yet] have iterators copied over from libstd :-)
[11:44:07] *** Quits: hacker_sam (hacker_sam@moz-A5916F4A.public.wayport.net) (Ping timeout)
[11:44:20] <eddyb> farcaller: do that then ;)
[11:44:37] <eddyb> farcaller: they are faster than using a counter
[11:44:39] <huon> without copying iterators over then unsafe {} is the only way
[11:45:07] <kimundi> Could also use slices unsafe_get() method, but that also requires porting it over
[11:46:14] <farcaller> huon: unsafe_get based on unsafe_ref based on transmute & offset. Fun ^_^
[11:48:34] *** Quits: kvanb (kvanb@moz-797C6BA.lnse5.lon.bigpond.net.au) (Ping timeout)
[11:48:49] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[11:49:10] <farcaller> now the only two things I need is to figure out inheritance and how to dispatch statically on traits (similar to C++ static polymorphism with templates)
[11:49:35] <kimundi> farcaller: using trait bounds will always dispatch statically
[11:49:48] *** Quits: nical (nico@moz-99690620.hinet-ip.hinet.net) (Client exited)
[11:49:59] <kimundi> fn foo<T: MyTrait>(t: T) { t.my_trait_method(); } // statically dispatched
[11:50:22] <kimundi> farcaller: We don't have data inheritance, only trait inheritance
[11:50:45] <farcaller> kimundi: oh, awesome. but I can't make that foo a "method" in struct, right?
[11:51:31] <kimundi> struct Foo { ... } impl Foo { fn my_struct_method(&self) { ... } } let t = Foo { ... }; t.my_struct_method(); // also statically dispatched
[11:52:02] <kimundi> The only kind of dynamic dispatch we currently have is trait objects
[11:52:02] <eddyb> farcaller: C++ dispatches virtually way more often than Rust ;)
[11:52:14] <eddyb> s/virtually/dynamically/
[11:52:15] <kimundi> (And hopefully that remains true)
[11:52:41] <farcaller> kimundi: what if I have struct and struct B both implementing a method foo from trait C. How do I call that foo with static dispatch?
[11:53:13] <eddyb> farcaller: how can A and B overlap?
[11:53:21] <eddyb> they are distinct types
[11:53:26] <farcaller> eddyb: that depends. C++ gives you more control on how things happen (which brings me to the third thing I miss in rust: placement new)
[11:53:26] <eddyb> (there is no inheritance ;))
[11:53:51] <eddyb> C++ doesn't, really
[11:53:58] <eddyb> see copy & move constructors
[11:54:08] <eddyb> virtual calls are the norm in the stdlib
[11:54:10] <farcaller> eddyb: no inheritance, just a problem :) so, speaking of a real example. I have to distinct LCD drivers
[11:54:18] <eddyb> farcaller: they are distinct types
[11:54:21] <kimundi> we will get placment new in form of the box operator
[11:54:23] *** Joins: asmyers (quassel@3F39C117.9A737B8F.FAA4474F.IP)
[11:54:27] <eddyb> farcaller: you can't have something that's A *and* B
[11:54:59] <kimundi> fn foo<T: MyTrait>() // can be instantiated with either A or B
[11:55:02] <eddyb> (I hope Rust never gets structural inheritance)
[11:55:05] <farcaller> eddyb: both of them have fn puts(). Now I will know at compile-time which one of those I will use, e.g. in main() I will create one of those
[11:55:10] *** Joins: kvanb (kvanb@45145DD1.9FF56AB5.1611EE05.IP)
[11:55:36] <farcaller> eddyb: but in some hello() that's called from main() I don't really know which one LCD do I deal with, so I get to traits and dynamic dispatch
[11:55:46] *** Quits: rylev (rylev@moz-8487EC6.cust.telecolumbus.net) (Client exited)
[11:56:00] <eddyb> farcaller: you can make hello generic over the trait
[11:56:01] <farcaller> kimundi: anything to read on that box operator? sounds great
[11:56:07] *** Joins: rylev (rylev@moz-8487EC6.cust.telecolumbus.net)
[11:56:07] <eddyb> farcaller: not yet implemented
[11:56:20] <eddyb> and might need unboxed closures otherwise it will be a massive hack
[11:56:21] *** Joins: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca)
[11:56:27] <SiegeLord> Is it possible to expand $($(x:tt))*?
[11:56:48] <eddyb> SiegeLord: sure
[11:56:56] <SiegeLord> How?
[11:56:56] <eddyb> (you have an extra set of parens btw)
[11:57:00] <eddyb> SiegeLord: it's macro-by-example
[11:57:03] <kimundi> farcaller: basically, the placement part without the new part. let x: Rc<uint> = box 5; let y: ArenaHandle<uint> = box(my_arena) 5;
[11:57:12] <eddyb> SiegeLord: $(A $x B)* will expand it
[11:57:28] <eddyb> SiegeLord: it even works in lock-step
[11:57:29] <SiegeLord> error: unexpected token: `an interpolated tt`
[11:57:43] <eddyb> SiegeLord: you need to pass the tt to another macro for it to be parsed
[11:57:51] *** Quits: rylev (rylev@moz-8487EC6.cust.telecolumbus.net) (Ping timeout)
[11:57:57] <SiegeLord> And what does that macro need to look like?
[11:57:59] <eddyb> I don't know why, though
[11:58:11] <eddyb> SiegeLord: uhm... basically identity
[11:58:19] <eddyb> not sure if it needs tt or expr as its imput
[11:58:21] <eddyb> *input
[11:58:33] <SiegeLord> I'm already writing an identity macro :P
[11:58:45] <eddyb> lol
[11:58:47] *** Quits: mihneadb (mihneadb@moz-6B31F5AA.static.ziggozakelijk.nl) (Quit: Computer gone to sleep - Zzzz...)
[11:58:52] <kimundi> farcaller: If you need code that uses _either_ the one type _or_ the other, use generics. If you need something that support _both_ at the same time, like a heterogeneous list, you need trait objects, or wrapping all possible values into a custom enum
[11:58:53] <SiegeLord> Let's see what I can do though
[11:58:53] <eddyb> maybe I should just go ahead and fix the darn thing
[11:59:26] <farcaller> kimundi: thanks, trying the genrerics approach now
[11:59:31] <eddyb> an interpolated tt within a tt should just be iterated
[11:59:40] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Quit: Leaving.)
[11:59:42] <eddyb> farcaller: keep in mind that it's monomorphized, like C++
[11:59:54] *** Quits: Ferreus (ferreus@moz-77E6A138.dip0.t-ipconnect.de) (Ping timeout)
[11:59:56] <eddyb> farcaller: so it might hurt your binary size
[12:01:32] <SiegeLord> I'm trying to populate a function body via a macro
[12:01:41] <SiegeLord> I'm getting a sinking feeling that I'm going to have to use a block
[12:02:06] *** Joins: autra_ (augustin@59A75E1D.496E6210.41DC420.IP)
[12:02:10] *** Tomcat|sheriffduty is now known as Tomcat|sheriffduty|mtg
[12:02:11] <Boscop> eddyb: why does placement new need unboxed closures?
[12:02:16] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Ping timeout)
[12:02:24] <eddyb> Boscop: because of a return value optimization
[12:02:33] <eddyb> where you return via a pointer
[12:02:55] <eddyb> Boscop: there is no safe way of having a pointer to uninitialized data
[12:03:14] <eddyb> usually a copy from the stack to the body of a smart pointer can be elided by LLVM
[12:03:26] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[12:03:27] *** Quits: kvanb (kvanb@45145DD1.9FF56AB5.1611EE05.IP) (Ping timeout)
[12:03:30] <eddyb> but not all the time, which is what a placement "new" would do
[12:03:41] *** Joins: rylev (rylev@moz-8487EC6.cust.telecolumbus.net)
[12:04:00] <Boscop> placement new isn't a safe feature anyway
[12:04:05] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Quit: Leaving.)
[12:04:06] <farcaller> eddyb: what hurts my binary size is loop unfolding :)
[12:04:08] <Boscop> you can use a random address
[12:04:10] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[12:04:11] <eddyb> palcement new isn't
[12:04:15] <eddyb> placement box will be
[12:04:21] <eddyb> it's not the silly C++ thing
[12:04:22] *** Joins: Kynes (Kynes@moz-3DC6C6E7.mit.edu)
[12:04:32] <Havvy> Favorite part of Rust:  Lack of `new`.
[12:04:35] <Boscop> so you can't create an object at a given address with it?
[12:04:40] <eddyb> Boscop: uhm, no
[12:04:47] <Boscop> so how would you do that?
[12:04:54] <eddyb> that? with unsafe code
[12:04:54] <farcaller> second that question
[12:05:14] <kimundi> Boscop: You could write you custom unsafe allocator that allows to allocate to arbitrary addresses
[12:05:18] <Boscop> so placement new is only used for optimization where llvm can't do it?
[12:05:19] <eddyb> there's an intrinsic to write a value at a pointer location without calling the destructor first
[12:05:44] <eddyb> v8 has a pretty neat usage of placement new, pretty much what we'd want
[12:05:54] <eddyb> new(zone) Object(...);
[12:05:57] <eddyb> where zone is an arena
[12:05:58] <kimundi> let x = Foo<T> = box(unsafe_address_alloc(0xfefb419ef)) my_Value;
[12:06:06] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[12:06:06] <eddyb> hehe, you could do that
[12:06:22] <eddyb> but we'd need a way to make it unsafe
[12:06:31] <Boscop> but box frees the memory, right?
[12:06:31] *** Quits: autra_ (augustin@59A75E1D.496E6210.41DC420.IP) (Ping timeout)
[12:06:41] <eddyb> Boscop: box?
[12:06:47] <eddyb> box x is ~x right now
[12:06:50] <Boscop> box's destructor
[12:06:56] <eddyb> box isn't a type
[12:07:29] <Boscop> but if x goes out of scope it'll try to free the memory, right?
[12:07:40] *** Joins: skade (skade@moz-7202D7C0.web.vodafone.de)
[12:07:41] <kimundi> Boscop: box would be concerned about initializing a memory location inplace with the value of an expression. everything else depends from the allocator itself, which would be a library type and could have arbitrary semantic.
[12:07:51] <Boscop> ok
[12:08:35] <eddyb> I think ~x is always in-place
[12:08:45] <kimundi> box foo; would return somekind of smartpointer usually, like~T for the primitive case, or Rc<T>, or MyArenaHandle<T> or so. the destructor of that smartpointer would be used to properly handle destruction of the handle
[12:08:54] <eddyb> but, for example, Rc::new(x) needs certain optimizations to write directly to the heap
[12:08:57] <SiegeLord> Is there a statement specifier for macros?
[12:09:07] <eddyb> especially if you have something like Rc::new(f())
[12:09:11] <eddyb> SiegeLord: stmt?
[12:09:44] <Boscop> will the allocator be a template argument like in C++?
[12:10:11] <eddyb> Vec<T, A = DefaultHeap> etc.
[12:10:13] <kimundi> Boscop: Thats the plan atm as far as I know.
[12:10:18] <farcaller> my reasoning for some kind of placement new is that I'd like to create some objects in functions that return them to main() (as opposed to creating the objects on main's stack frame) and I don't have generic-purpose heap.
[12:10:21] <eddyb> not sure why we haven't fiddled with allocators yet
[12:10:31] *** Joins: lpy (lpy@186A8F3A.F09091A8.1348A864.IP)
[12:10:37] <eddyb> farcaller: can't you just return them by value?
[12:10:39] <huon> farcaller: can't you just return them?
[12:10:42] <kimundi> eddyb: waiting for a workweek rfc writeup afaik
[12:11:02] *** Quits: mindcat (mindcat@2B6B6398.2443BAF3.57E3C596.IP) (Ping timeout)
[12:11:12] * farcaller feels like missing some secret chapter of rust tutorial :-/
[12:11:17] <eddyb> farcaller: huh?
[12:11:19] <farcaller> how do I do that?
[12:11:24] <eddyb> farcaller: you just return them?
[12:11:27] <eddyb> values are values
[12:11:32] <kimundi> farcaller: fn main() { let x = foo(); } // would use return value optimization where applicable
[12:11:32] <eddyb> Rust doesn't discriminate
[12:11:52] <farcaller> oh. time for *facepalm*
[12:11:54] <eddyb> yeah, it even uses main's stack to construct the value - but that's not required for it working
[12:13:46] *** Quits: lpy (lpy@186A8F3A.F09091A8.1348A864.IP) (Connection reset by peer)
[12:13:49] *** Joins: lpy_ (lpy@207F51B2.F09091A8.1348A864.IP)
[12:14:11] *** lpy_ is now known as lpy
[12:14:46] *** Joins: Ferreus (ferreus@moz-31EB2708.dip0.t-ipconnect.de)
[12:15:56] *** Quits: alonlevy_ (alon@moz-EB7C9CF3.telavivmakers.org) (Quit: Leaving)
[12:16:08] *** Quits: rylev (rylev@moz-8487EC6.cust.telecolumbus.net) (Client exited)
[12:16:24] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[12:17:43] <farcaller> hm. Actually yes, returning by value just works :)
[12:17:56] <farcaller> I need to develop a rust way of thinking
[12:18:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[12:18:33] *** Joins: benjamin_ (benjamin@moz-5894B012.dip0.t-ipconnect.de)
[12:19:05] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[12:19:14] <eddyb> farcaller: value flow /o/
[12:21:09] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Client exited)
[12:21:15] <SiegeLord> Maybe I should write a procedural macro for this... what I want is foo!(body) => fn foo() { body }
[12:21:55] *** Joins: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP)
[12:22:04] *** Joins: claudiu (claudiu@81B10C62.5F4BC945.49B2C1AE.IP)
[12:22:21] <huon> SiegeLord: `macro_rules! foo( ($body: expr) => { fn foo() { $body } } )`?
[12:22:24] *** Joins: sankha93 (sankha93@7061CD01.D6BD0D91.22D41759.IP)
[12:23:21] <huon> oh, erm, unless you want multiple things
[12:23:22] <SiegeLord> error: found `let` in ident position
[12:23:27] * huon thinks
[12:24:08] *** Joins: qwerty_nor (Thunderbir@A5447B90.EDC74FC5.E19950A4.IP)
[12:24:15] <farcaller> compared to golang, where the official suggestion is to use *Struct everywhere where your struct is big enough (to cut on copy expenses), do I just prefer pass-by-value in rust? When is a good time to pass a &Struct then?
[12:24:26] <huon> SiegeLord: macro_rules! expr( ($e: expr) => { $e }) macro_rules! foo( ($($things: tt)*) => { fn foo() { expr!({ $($things)* }) } } )
[12:24:33] <huon> note the {} inside the expr!() call
[12:24:39] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[12:25:07] <huon> farcaller: essentially: pass by reference always, unless you need ownership, in which case pass by-value.
[12:25:40] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[12:25:42] <SiegeLord> Hah, oh wow... that worked
[12:25:45] <SiegeLord> Thanks
[12:25:46] <huon> (for reasonably small structs that don't move by default, passing by value might be faster, e.g. Point { x: f32, y: f32 })
[12:26:06] <farcaller> sgtm
[12:26:54] <huon> but... with move semantics, you can have small structs for which passing by-value is not workable (e.g. Vec<T> is small (3 words), but passing by value everywhere would require a lot of copies and allocations)
[12:27:05] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Quit: Leaving)
[12:27:49] <kimundi> (in the form of explicit clone() calls)
[12:28:13] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[12:28:41] <det> Does Rust have trait for doing copy assignment ?
[12:29:05] *** Quits: skade (skade@moz-7202D7C0.web.vodafone.de) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[12:29:09] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[12:29:23] *** Joins: ssira (ssira@moz-F6206352.kanagawa.ocn.ne.jp)
[12:29:48] <huon> det: clone has x.clone_from(&y)
[12:29:54] *** Joins: ganitsu (ganitsu@moz-11D467C8.dialup.adsl.anteldata.net.uy)
[12:30:03] <det> Thanks
[12:30:05] <huon> but that's essentially just for optimising x = y.clone()
[12:30:38] <huon> so that e.g. an already instantiated vector can reuse its allocation, instead of creating a new one
[12:31:02] <kimundi> But almost none of the implementors of clone implement that at the moment.
[12:31:18] <kimundi> Only ~T profits of it right now ;)
[12:31:48] <huon> someone should do it for Vec
[12:32:25] <kimundi> for Vec it could reuse the existing capacity directly, right?
[12:32:29] <SiegeLord> Woo... now I can use a macro to avoid remembering the special #[start] function invocation :D
[12:32:41] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:32:54] <eddyb> haha
[12:33:03] <kimundi> drop all values in it, clone into the uninitialized allocation
[12:33:06] <eddyb> boot_me_up!
[12:33:14] <huon> kimundi: something like `if self.capacity > other.len() { /* reuse */ } else { /* normal */ }` yeah
[12:33:34] <huon> well I guess you don't need the if
[12:33:36] <eddyb> "normal"
[12:33:56] <det> kimundi, thats what C++ vector typically does on copy assignment
[12:33:58] <huon> actually you do... but "normal" is just a realloc call
[12:34:00] <kimundi> right, call clone_from for all that exist, drop the rest if size smaller or fill the rest with normal clone if size bigger
[12:34:23] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[12:34:44] <det> for Vec I imagine it could just be truncate + extend
[12:35:21] <SiegeLord> rusti: println![""]
[12:35:31] <kimundi> That wouldn't recursivly call clone_from on substructures
[12:35:36] -rusti- <anon>:11:17: 11:18 error: expected ident, found `[`
[12:35:36] -rusti- <anon>:11         println![""]
[12:35:36] -rusti-                           ^
[12:35:36] -rusti- playpen: application terminated with error code 101
[12:35:38] <huon> det: as kimundi says, calling clone_from on the current contents is nice
[12:35:42] <SiegeLord> rusti: println!{}
[12:35:44] <huon> Rusky: version
[12:35:47] -rusti- <anon>:11:9: 12:6 error: requires at least a format string argument
[12:35:47] -rusti- <anon>:11         println!{}
[12:35:47] -rusti- <anon>:12     };
[12:35:47] -rusti- error: aborting due to previous error
[12:35:47] -rusti- playpen: application terminated with error code 101
[12:35:48] <huon> erm
[12:35:54] <huon> sorry Rusky
[12:35:57] <huon> rusti: version
[12:36:01] -rusti- rustc 0.10-pre (b8ef9fd 2014-03-31 15:51:33 -0700)
[12:36:02] <kimundi> let v: Vec<~T> = ...; v.clone_from(...) // could reuse all allocations.
[12:36:20] *** Joins: espadrine (Thunderbir@moz-9BC91D35.w92-128.abo.wanadoo.fr)
[12:36:50] <strcat> farcaller: btw there's not really a good reason to reinvent all of the stdlib, there's already rust-core
[12:36:56] <SiegeLord> Oh I see, it's only for statement and expr macro invocations
[12:37:02] <SiegeLord> Strangely, not for item invocations
[12:37:08] <huon> SiegeLord: what is?
[12:37:09] <strcat> if you want to, great, but there's already a freestanding library available
[12:37:21] <SiegeLord> huon: The [] macro delimieters
[12:37:24] <farcaller> strcat: right, but I can't compile that for some reason: https://github.com/thestinger/rust-core/issues/43
[12:37:29] <huon> SiegeLord: really?
[12:37:29] *** Quits: mye (mye@moz-BDEE7985.swh.uni-giessen.de) (Quit: sleep message)
[12:37:30] <huon> weird
[12:37:42] <SiegeLord> At least, it's not working for me in an item macro
[12:37:48] <det> huon, I mean, that is how you could implement clone_from to reuse the allocation if it is large enough already
[12:37:56] <huon> SiegeLord: I guess i must be
[12:38:12] <huon> det: that doesn't reuse the allocations (or whatever) of the contents of the vector
[12:38:40] <huon> e.g. Vec<Vec<T>>, it would be nice if a clone_from on the outer one attempted to reuse the inner ones too
[12:38:54] <huon> but yeah, truncate + extend would be better than what we have now
[12:39:14] *** Joins: edwardw (Mibbit@E9739E5B.EE06708D.4BFBD933.IP)
[12:39:23] <strcat> farcaller: works fine for me
[12:39:28] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.3)
[12:39:29] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:39:31] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[12:39:41] <strcat> farcaller: works fine for me
[12:40:34] <huon> farcaller: what platform are you on?
[12:40:38] <strcat> farcaller: if you're using a target that people weren't using before, then you'll have to add support for it
[12:41:00] <huon> (well, I guess "what target are you aiming for" is the correct question)
[12:41:07] <farcaller> strcat: https://gist.github.com/farcaller/95d8d165ff3bf46e1970
[12:41:08] <strcat> anyway if you want to reinvent it all rather than add a cfg() line to rust-core, feel free
[12:41:18] <huon> farcaller: since c_types is currently only supported on linux https://github.com/thestinger/rust-core/blob/master/core/lib.rs#L70
[12:41:23] <strcat> which platform is this on?
[12:41:27] <farcaller> I'm on os x targeting os x
[12:41:27] <strcat> I'm aware
[12:41:31] <det> huon, reusing the allocations of the content is a bit much to expect... :)
[12:41:38] <strcat> you need to add os x support to c_types then
[12:41:43] <huon> det: I don't think so :)
[12:41:53] <farcaller> ah, that lib.rs#L70 makes sense
[12:42:19] <huon> det: it's probably requires a little finesse to get it to be correct, but it shouldn't be *too* hard.
[12:42:41] * huon puts implementing clone_from for things on his todo list
[12:42:52] *** Joins: hacker_sam (hacker_sam@moz-23CA551A.kennesaw.edu)
[12:43:48] <det> huon, perhaps
[12:43:53] *** Joins: hacker_s_ (hacker_sam@moz-23CA551A.kennesaw.edu)
[12:44:05] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[12:44:09] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[12:44:32] *** Quits: hacker_sam (hacker_sam@moz-23CA551A.kennesaw.edu) (Ping timeout)
[12:44:35] <kimundi> In principle, anything the overrides clone_from can recursively call it on substructures.
[12:45:17] *** Quits: EastByte_ (EastByte@moz-351D7C56.ewe-ip-backbone.de) (Ping timeout)
[12:45:51] <det> But then you'll want to specialize for when memcpy is the right thing or a recursive clone_from is
[12:45:51] <huon> hm, actually, maybe not, `if self.len() > other.len() { self.truncate(other.len()) } for (write, read) in self.mut_iter().zip(other.iter()) { write.clone_from(read) } for thing in other.slice_from(self.len()) { self.push(thing.clone()) }`
[12:46:02] *** Joins: EastByte_ (EastByte@moz-5386EBF.ewe-ip-backbone.de)
[12:46:04] <huon> theoretically, that works
[12:46:28] <det> for example, C++ std::copy is a memcpy when it can be
[12:46:36] <huon> det: unfortunately(?) the only way to handle that in Rust is to let the optimiser recognise when it can just be a plain memcpy
[12:46:36] <strcat> det: clone_from will be too
[12:46:45] <farcaller> strcat: any hints on this one? core/cell.rs:41:9: 41:19 error: cannot move out of dereference of `&`-pointer
[12:46:52] *** Joins: rylev (rylev@moz-2FE7071.cust.telecolumbus.net)
[12:46:55] <strcat> farcaller: update rust-core
[12:47:10] <strcat> it's not going to work on the latest rust due to priv field changes though
[12:47:20] <farcaller> strcat, just did that, at 7441de7
[12:47:33] <det> strcat, I mean, if you implement the clone_from for vector using recursive clone_from calls, you want the common case to still be a memcpy, which may be tricky
[12:48:22] <strcat> farcaller: your rust is too out of date then
[12:48:39] *** Quits: rylev (rylev@moz-2FE7071.cust.telecolumbus.net) (Ping timeout)
[12:48:40] <huon> det: they will be inlined
[12:48:42] <strcat> det: hm?
[12:48:46] <huon> if they can be
[12:48:53] <farcaller> strcat: that might be true, recompiling it now
[12:49:07] <strcat> farcaller: yeah, but then you'll run into the fact that priv fields changed
[12:49:11] <strcat> so either way you need to update it
[12:49:13] <farcaller> :)
[12:49:30] <kimundi> det: Its a trait, that will get specialized for each possible type you instantiate it for. If clone_from just does a memcpy internally, all the call overhead will inline and optimize away
[12:50:52] *** Joins: otnb (Mibbit@moz-2FE82A80.soundnetworking.com)
[12:51:12] *** jorendorff is now known as jorendorff_away
[12:51:42] *** jorendorff_away is now known as jorendorff
[12:53:42] <kimundi> It might not always manage to remove everything unnecessary, but it certainly won't lead to a vector of thousands of integers doing an actual clone_from function call for each of them in optimized builds
[12:55:22] <otnb> Is there any way to get an externed function's signature?
[12:55:44] <otnb> (After it is compiled in a library?)
[12:56:06] *** Tomcat|sheriffduty|mtg is now known as Tomcat|sheriffduty
[12:56:10] <otnb> (By rustc. Wow, that was a really badly formatted question. Sorry.)
[12:56:35] *** Joins: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com)
[12:57:17] *** Quits: osa1 (omer@1F124F9F.AD1E507F.3688B332.IP) (Ping timeout)
[12:57:41] <huon> not really exposed to users, but the information is there in the metadata; it's how rustc itself type-checks calls to functions in other crates.
[12:57:57] <huon> theoretically we could have tooling for reading info from crate metadata
[12:58:06] <huon> but we don't have on yet
[12:58:20] <huon> s/on/one/
[12:59:51] <otnb> Related question, then: I'm trying to figure out what signature my functions will have when called from C, so that I can input the correct data structure and/or stick the result in the correct type of stuff.
[13:00:20] <otnb> What is wrong with me, that wasn't even a question. "Where would I find the information necessary for me to accomplish that?"
[13:00:22] <otnb> There, better.
[13:02:12] <Tari> if you're calling into rust from non-rust, declare your function as extern to make it use the C ABI
[13:02:19] <Tari> http://static.rust-lang.org/doc/master/complement-lang-faq.html#can-c-code-call-rust-code?
[13:03:27] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Quit: Leaving.)
[13:03:48] <strcat> otnb: rust structs are guaranteed to have the same ABI as C structs
[13:04:18] <strcat> just stick to fixed-size integers, pointers, pointer-size integers (int, uint), structs and enums with an explicit repr(type)
[13:04:32] <strcat> you might also want #[no_mangle]
[13:04:36] <strcat> on the function
[13:04:52] <strcat> (not if you're passing it as a function pointer - just if you're linking against rust from another language)
[13:05:16] <strcat> a single #[no_mangle] function will prevent multiple versions of a library from being included in the same binary
[13:05:35] <strcat> unless you put a version in the symbol yourself like sqlite...
[13:05:55] <det> kimundi, but even after inlining, LLVM doesnt seem very good about turning stuff into memcpy: http://goo.gl/IF3b8Q
[13:05:55] <otnb> Thanks. Now I just need to learn myself some more C I guess
[13:06:32] *** Joins: jackneill (jackneill@moz-782B761E.pool.digikabel.hu)
[13:06:34] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[13:06:56] <huon> det: your link there is for GCC, not clang ;P
[13:07:14] <det> huon, sorry, clang is the same :)
[13:07:42] *** Quits: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net) (Connection reset by peer)
[13:07:49] <otnb> strcat: are C arrays off-limit?
[13:08:18] <huon> det: seems so
[13:08:36] <strcat> otnb: rust has fixed-size arrays, they're laid out like C arrays
[13:08:52] <otnb> So a rust array will translate properly into a C array
[13:09:15] <strcat> they are laid out the same
[13:09:16] *** Joins: skade (skade@B4A5FE21.505237C9.CAE22B62.IP)
[13:09:21] *** Quits: Sorella (quildreen@89788746.FDF9B0F2.A95FAE2B.IP) (Ping timeout)
[13:09:28] *** Quits: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca) (Quit: canhtak)
[13:09:33] <huon> det: weird; not even icc is optimising to a memcpy
[13:09:55] <det> I just woke up, hope i didnt make a mistake in this very simple code
[13:10:13] <otnb> strcat: thanks
[13:10:23] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[13:11:13] <det> haha, I did
[13:11:23] <det> forgot to increment dest
[13:11:29] * det slinks away
[13:11:57] <strcat> det: clang vectorizes it manually because loop-vectorize is clever and loop-idiom isn't
[13:12:00] <otnb> Really trying not to sound exquisitely stupid, I'm trying out Rust in the context of using it to build c-compatible libraries, but I lack a bit on the C side of things as well... So thanks for the help, really.
[13:12:27] <strcat> det: if you wrote it a bit differently, loop-idiom would kick in
[13:12:29] <strcat> but anyway...
[13:12:38] *** Quits: asmyers (quassel@3F39C117.9A737B8F.FAA4474F.IP) (Ping timeout)
[13:13:04] <strcat> loop-vectorize generates a better memcpy than glibc has with core-avx-i/core-avx2 as the target
[13:13:18] <strcat> so loop-idiom can be counter-productive beyond code size
[13:13:45] *** Quits: lpy (lpy@207F51B2.F09091A8.1348A864.IP) (Ping timeout)
[13:13:46] <strcat> (although loop-idiom technically turns it into an LLVM memcpy instruction, which can be lowered in different ways)
[13:13:56] *** Joins: lpy (lpy@207F51B2.F09091A8.1348A864.IP)
[13:13:56] <det> Ya, it gets vectorized: http://goo.gl/jaFQt9
[13:14:31] *** Quits: StarLight (StarLight@moz-4B9C690C.dynamic.avangarddsl.ru) (Ping timeout)
[13:14:44] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Quit: Leaving.)
[13:15:08] <strcat> det: btw -emit-llvm passed to clang is useful, so you can see what the optimization passes did vs. CodeGen
[13:15:19] <strcat> (with -S so you get IR)
[13:15:48] <strcat> I think if you use an index, loop-idiom will output a memcpy/memmove
[13:15:51] *** Quits: skade (skade@B4A5FE21.505237C9.CAE22B62.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[13:15:56] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[13:16:00] *** Joins: asmyers (quassel@F8C86AB2.9A737B8F.FAA4474F.IP)
[13:16:46] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[13:18:20] <det> an index is vectorized as well, not memcpy
[13:18:32] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[13:18:41] * strcat shrugs ;)
[13:18:56] <det> (signed index too, to make Chandler happy)
[13:19:22] <strcat> http://llvm.org/docs/doxygen/html/LoopIdiomRecognize_8cpp_source.html it's not very clever
[13:20:27] *** Joins: nszceta (nszceta@moz-E458A7C0.pharm.pitt.edu)
[13:20:43] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[13:22:28] *** Joins: doomlord_ (servitor@moz-56F8DA57.range86-148.btcentralplus.com)
[13:23:10] <doomlord_> yikes,  i read that struct fields are going to be priv by default
[13:23:34] <det> icc is the only one clever enough to generate a memcpy
[13:23:38] *** Joins: willingc (willingc@moz-F095E013.san.res.rr.com)
[13:23:40] <strcat> doomlord_: already are
[13:24:07] <strcat> det: I don't think there's much interest in LLVM's loop-idiom pass atm, sadly
[13:24:11] <strcat> vectorization is a lot more general
[13:24:43] <strcat> sure would be nice if it worked though
[13:24:45] <strcat> ;p
[13:26:09] *** Joins: judder (maradukewa@BD9E6B94.126EFFE1.78E362FE.IP)
[13:26:16] *** Joins: Sorella (quildreen@AA4589ED.97245BEB.1ED99692.IP)
[13:26:28] *** Joins: skade (skade@B4A5FE21.505237C9.CAE22B62.IP)
[13:27:06] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[13:27:19] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[13:27:29] *** vfetwnuncszu is now known as dcrewi
[13:27:42] <det> Maybe when Rust becomes popular they will focus on that :)
[13:28:23] <det> It benefits C programmers way less as they use memcpy directly, and C++ less as they have <type_traits> and std::copy
[13:28:30] *** Joins: nimish (quassel@6CD90D4F.B586C2A4.5F29FBA5.IP)
[13:30:10] <strcat> det: most C++ code still doesn't go out of the way to specialize everything
[13:30:26] <strcat> det: std::vector in libstdc++/libc++ isn't clever enough to do it for example
[13:30:27] *** Quits: nimish (quassel@6CD90D4F.B586C2A4.5F29FBA5.IP) (Quit: http://quassel-irc.org - Chat comfortably. Anywhere.)
[13:30:37] <strcat> compare std::vector push performance vs. rust's Vec<T>
[13:30:47] * strcat shrugs
[13:30:48] *** Quits: W0rmDr1nk (wormdrink@moz-CEAF0263.access.mtnbusiness.co.za) (Ping timeout)
[13:30:50] *** Joins: pczarn (pczarn@moz-69A55FA.izacom.pl)
[13:31:24] *** Joins: Budrose (Budrose@moz-347764CB.hfc.comcastbusiness.net)
[13:31:35] <det> I thought "std::vector<int> v{first, last};" is smart enough to memcpy for pointers
[13:31:36] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Quit: Leaving.)
[13:31:39] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[13:31:40] <det> in g++ at least
[13:31:52] <doomlord_> i see that decision was taken based on stats from the library compiler, but i would have thought 'closed world code' is written less frequently than 'open-world code' - the point of writing something closed world is you expect many people to use it, wheras when writing 'open-world' code people are still experiemnting and haven't established how things will work.. its like you'd start with everything public, then see what you n
[13:31:52] <doomlord_> eed to encapsulate
[13:32:11] *** Joins: W0rmDr1nk (wormdrink@moz-CEAF0263.access.mtnbusiness.co.za)
[13:32:20] <doomlord_> ^library+compiler
[13:32:24] <cmr> also servo.
[13:32:32] <cmr> not just the compiler/stdlib
[13:32:55] <SiegeLord> I added 180 pubs and removed 60 privs yesterday, so it wasn't the right default for my code
[13:32:57] <doomlord_> isn't servo full of unsafe hacks at the minute, which will be cleaned up with internal vtables
[13:33:32] <det> Indeed it is: http://goo.gl/OiseNQ
[13:33:32] <doomlord_> well its not a disaster but i definitely prefered pub default
[13:34:07] <doomlord_> IMO solid immutability is more useful than priv
[13:34:27] <strcat> det: sure, rust will too
[13:34:35] <strcat> but measure push performance of both
[13:34:52] <det> strcat, why is Rust better here (I assume you mean better :)
[13:35:05] <eddyb> http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22MQSwdgxgNgrgJgUwAQB4BuCIBcD2AnAPgCgiBnLOALko23xXCwKQFsBDAawQApGkAqJADMQecgBokfQVDbkAlEQDeRAJB4EWGHjBIlIsVkmzyAXwDcRU0AAA%22%2C%22compiler%22%3A%22%2Fusr%2Fbin%2Fg%2B%2B-4.8%22%2C%22options%22%3A%22-O3%20-std%3Dc%2B%2B11%22%7D%5D%7D
[13:35:10] <eddyb> oh that's long :/
[13:35:18] <eddyb> (yay readable Intel syntax)
[13:35:24] *** Quits: cschneid (cschneid@moz-20C37083.hlrn.qwest.net) (Client exited)
[13:35:32] <det> eddyb, ya, use permalink button to get a better link
[13:35:45] <eddyb> thanks :)
[13:36:11] <eddyb> is it just me, or is that output waaay too long?
[13:36:40] <det> eddyb, did you change anything from my link ?
[13:36:42] <eddyb> unless that's the std::vector constructor
[13:36:50] <eddyb> det: 56 lines
[13:37:10] <det> then godbolt is broken
[13:37:12] <det> I get my paste
[13:37:51] <doomlord_> with priv struct members I guess that precludes users creating instances with struct initializer syntax, i guess for POD you'll just have to declare pub members
[13:38:54] <det> eddyb, doesnt seem too long to me
[13:39:06] <doomlord_> i like the fact that in c++ you have struct (public default) and class (private default)
[13:39:29] <strcat> public-by-default goes against rust's decision elsewhere to make exposing parts of the API explicit
[13:39:32] <det> allocates memory, copies data, has unwinding code for exception safety
[13:40:02] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[13:40:06] <eddyb> det: clang 3.3 is shorter
[13:40:22] <cmr> by *3* lines
[13:40:25] <strcat> I never use `class` in C++, useless imo ;p
[13:40:36] <strcat> a class without a single public field/method is useless
[13:40:43] <strcat> and I put public methods before anything else
[13:40:44] <eddyb> cmr: 8 here
[13:40:48] <strcat> so I gain nothing by using `class`
[13:40:53] <strcat> as I'd just have a public:
[13:40:57] <eddyb> cmr: there's 3 empty lines after clang's output
[13:41:02] <doomlord_> yeah thats why i like struct, its public default :)
[13:41:44] <strcat> doomlord_: privacy in C++ doesn't work as it does in rust
[13:41:47] * cmr forks godbolt, adds newer clang and rustc
[13:41:54] <strcat> in C++, you already have to put that type in a header
[13:42:09] <strcat> and C++ privacy isn't module based (not that it has modules)
[13:42:21] <strcat> if C++ did have modules, privacy still wouldn't be module based
[13:42:32] <doomlord_> ok i guess thats something, i'm writing 'pub' where in c++ i'd be faffing around with headers
[13:42:33] <det> I like struct for aggregates, class elsewhere
[13:42:52] <strcat> det: but why? :P
[13:42:58] <eddyb> det: looks like clang does less copies than g++
[13:42:59] <strcat> you probably start them all with a public:
[13:43:06] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Ping timeout)
[13:43:08] <strcat> they need something public to be usable
[13:43:25] <det> strcat, I usually start them with private: even though its redundant :p
[13:43:45] <strcat> rust is moving to not having a priv keyword, and making exposing an API explicit in every case
[13:43:48] <doomlord_> ah, priv fields are still accessible in the module? (people keep saying 'doesn't work like in c++'..
[13:43:59] <cmr> doomlord_: correct, and all child modules.
[13:44:00] <otnb> Would this be of any use to me? http://publications.gbdirect.co.uk/c_book/ <-- I intend to use rust to generate libs that I'd call from other languages when and if it makes sense
[13:44:09] <strcat> doomlord_: privacy has no impact inside a module
[13:44:09] <otnb> (And by generate I mean write)
[13:44:16] <eddyb> det: or, hmm, is g++ inlining std::__throw_bad_alloc()?
[13:44:56] <det> eddyb, ill take a look
[13:45:07] <doomlord_> ok thats not so bad then
[13:45:13] <eddyb> (the equivalent thereof, I mean)
[13:45:24] <eddyb> det: would be fun to have diffs between C++ and Rust :D
[13:45:47] <doomlord_> and i guess its easy to make a macro for aload of default accessor methods , or whatever
[13:45:52] <cmr> eddyb: I wasn't joking when I said I'm forking it and adding rustc support :p
[13:46:02] <eddyb> cmr: <3
[13:46:26] <eddyb> cmr: can it show IR?
[13:46:39] <strcat> doomlord_: you're not supposed to make getters/setters... that's not the intent
[13:46:43] <cmr> eddyb: I'm going to add that, it can't right now.
[13:46:43] <det> eddyb, looks like they handle errors somewhat differently, clang has no delete in the generated code at all, for instance
[13:46:44] <strcat> it's to make exposing an API explicit
[13:46:45] <strcat> a field is an API
[13:46:55] <strcat> for the same reason, functions/methods are private by default
[13:46:58] <strcat> types are private by default
[13:47:04] <strcat> fields are now no different from everything else
[13:47:04] <doomlord_> strcat, ok , you'll use 'pub' more than making getters and setters,
[13:47:08] <eddyb> in the case of clang and rustc, you can compare LLVM IR to peek at the reason for certain optimizations
[13:47:29] <eddyb> det: why would that function throw, anyway?
[13:47:31] <doomlord_> i had worried 'priv by default' moves it more toward the OOP getter/setter accessors for everything  world
[13:47:32] *** Joins: rylev (rylev@moz-85B5C025.cust.telecolumbus.net)
[13:47:35] <det> eddyb, new can throw
[13:47:35] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[13:47:41] <strcat> doomlord_: nothing to do with that
[13:47:48] <strcat> if you wrote getters/setters, they'd be private by default too
[13:47:50] <strcat> there's no connection
[13:47:52] <eddyb> det: aah, that? it's an abort in Rust
[13:47:54] <doomlord_> as opposed to the idea of 'data' and 'functions' , serperatem which I much prefer
[13:48:01] *** Quits: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be) (Ping timeout)
[13:48:04] <eddyb> det: though I'm pretty sure LLVM removes the abort :P
[13:48:06] *** Joins: drbawb (drbawb@moz-444F91EA.wi.res.rr.com)
[13:48:15] <doomlord_> open world declaration of data, and add functions to create/consume data anywhere
[13:48:17] <eddyb> det: because allocations can't fail, apparently :P
[13:48:24] <strcat> pub struct Foo { x: int } impl Foo { fn bar(&self) {} }
[13:48:30] <strcat> that's a private field and a private method
[13:48:30] <det> eddyb, interesting
[13:48:33] <strcat> it's consistent
[13:48:59] <strcat> the only remaining usage of priv is enum variants
[13:49:03] <strcat> don't know if that's going to change too
[13:49:22] *** Quits: rylev (rylev@moz-85B5C025.cust.telecolumbus.net) (Ping timeout)
[13:49:39] <strcat> would be nice to drop the keyword completely and have a consistent private-by-default everywhere
[13:49:40] *** Joins: goffrie_ (goffrie@moz-3599CB4E.dsl.ncf.ca)
[13:49:47] <det> eddyb, im not sure what g++ is doing to be honest, the throw shouldn't matter because then there would not be anything to delete
[13:49:48] <doomlord_> pub struct Foo { x:int} ;   fn bar(Foo&) { ... this can still use Foo.x ? }
[13:49:50] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[13:49:55] <det> eddyb, and the jmp is before new is called
[13:50:16] *** Quits: goffrie (goffrie@moz-A7232E8.dsl.ncf.ca) (Ping timeout)
[13:50:24] <strcat> doomlord_: yes, privacy has no effect inside a module
[13:50:36] <eddyb> echo 'pub fn foo(x: &[int]) -> Vec<int> {Vec::from_slice(x)}' | ./x*/stage0/bin/rustc - --crate-type=lib --opt-level=3 --emit=ir -o /dev/stdout | rustfilt | less
[13:50:41] <eddyb> oh dear it's so bad X_X
[13:50:49] <strcat> doomlord_: privacy has to do with API boundaries between modules/crates
[13:50:50] *** Quits: ksf (ksf@moz-3BD9FE6F.adsl.hansenet.de) (Ping timeout)
[13:50:51] *** Joins: ksf (ksf@moz-625AFBB9.adsl.hansenet.de)
[13:51:03] <det> eddyb, apparently it throws if you try to allocate more than "4611686018427387903"
[13:51:12] <strcat> as it does in languages like Go and Haskell with proper module systems
[13:51:20] <eddyb> rusti: format!("{:x}", 4611686018427387903)
[13:51:21] -rusti- 3fffffffffffffff
[13:51:29] <eddyb> det: we have that as well
[13:51:36] <doomlord_> c++ tries to use types as modules i guess :)
[13:51:42] <eddyb> det: length * sizeof type overflow
[13:51:50] *** Joins: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be)
[13:51:52] <det> eddyb, ahh, right
[13:52:05] *** Quits: Budrose (Budrose@moz-347764CB.hfc.comcastbusiness.net) (Connection reset by peer)
[13:52:06] <doomlord_> like with nested classes, which i use quite a bit, but they seem to have negative effects sometimes
[13:52:11] *** Joins: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca)
[13:52:27] <det> eddyb, clang doesnt do that check it seems
[13:52:43] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: rcirc on GNU Emacs 24.3.1)
[13:52:45] <eddyb> det: huh?
[13:53:01] <eddyb> det: try to allocate a vector of large arrays such that it overflows
[13:53:10] <eddyb> s/it/the multiplication
[13:53:30] <eddyb> det: and then use checked methods to read the entire address space :P
[13:53:30] <det> eddyb, in the generated code, g++ checks it wont overflow, clang++ does not
[13:53:50] <eddyb> .at won't save you now
[13:54:00] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[13:54:02] <det> unless its doing it in a more clever way
[13:54:26] <strcat> you can count overflow as OOM
[13:54:33] *** Joins: Florob (Florob@moz-39532932.de)
[13:54:40] <det> actually clang++ is checking it just uses a shift by 62
[13:54:43] *** Quits: lpy (lpy@207F51B2.F09091A8.1348A864.IP) (Client exited)
[13:55:24] <eddyb> det: hah, smart
[13:55:47] <eddyb> so that's what __throw_bad_alloc is for
[13:57:54] <eddyb> echo 'pub fn foo(x: &[int, ..1]) -> Vec<int> {Vec::from_slice(x.as_slice())}' | ./x*/stage0/bin/rustc - --crate-type=lib --opt-level=3 --emit=ir -o /dev/stdout | rustfilt | less
[13:57:55] *** Joins: vikstrous (v@moz-1E061984.cpe.distributel.net)
[13:58:00] <eddyb> strcat: ^^ why is that so bloated?
[13:58:05] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[13:58:05] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[13:58:13] <cmr> -o - works
[13:58:21] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[13:58:30] *** Joins: erickt_ (erickt@49C4075F.3AC15C18.2321E71E.IP)
[13:58:31] <eddyb> cmr: the number of rm -- - commands I've had to issue
[13:58:36] <cmr> heh
[13:58:50] <eddyb> but thanks, it does work with rustc :)
[13:59:05] <cmr> eddyb: also where is the source for rustfilt, I've tried to find it like 10 times in the last two days :p
[13:59:27] <eddyb> cmr: https://gist.github.com/eddyb/3a233c4709018e92b866
[13:59:37] *** Quits: nik_ (nik@moz-2DFF8760.pool.mediaways.net) (Ping timeout)
[13:59:37] <eddyb> sorry for the top sekrit gists
[13:59:39] <cmr> eddyb: open a PR adding that to src/etc :p
[14:00:27] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[14:01:16] <eddyb> c"capacity overflow\00"
[14:01:25] *** Quits: otnb (Mibbit@moz-2FE82A80.soundnetworking.com) (Quit: http://www.mibbit.com ajax IRC Client)
[14:01:32] *** Quits: sw17ch (sw17ch@moz-6761BA23.members.linode.com) (Ping timeout)
[14:01:39] <erickt_> acrichto: ping
[14:01:58] *** Quits: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca) (Quit: canhtak)
[14:02:05] <eddyb> strcat: there's some ridiculous going on
[14:02:17] *** Tomcat|sheriffduty is now known as Tomcat|mtg
[14:03:47] <Tobba> emscripten is a bit weird
[14:03:49] <eddyb> store <2 x i64> <i64 1, i64 1>, <2 x i64>* %4, align 8
[14:03:59] <Tobba> I have like, an absolute ton of missing symbols
[14:04:05] <Tobba> and it just limps along and prints a -1 to the console
[14:04:20] <eddyb> det, strcat: haha, {let mut v = Vec::with_capacity(1); v.push(0); v} gets overoptimized to the point where it uses vectors to set both capacity and length at once
[14:04:29] <Tobba> it also completely wrecks the LLVM optimizer, oh well
[14:05:18] <strcat> eddyb: if you're asking why it's bloated -> failure
[14:05:28] <strcat> remove unwinding from rust and everything would be great
[14:05:32] *** Joins: abinader (sid21713@moz-A42E5B7B.irccloud.com)
[14:05:40] <eddyb> strcat: failure shouldn't be reachable though
[14:05:41] <det> Whats the best way to iterate a 0 to N in Rust ?
[14:05:46] <eddyb> range(0, N)
[14:05:53] <eddyb> or range_inclusive, if you want that
[14:05:56] <Tobba> the scary part is that it works at all
[14:06:04] *** Joins: jviereck (Adium@moz-7F99FDDF.ethz.ch)
[14:06:10] <Tobba> I just have to build a linux version of libstd, somehow
[14:06:13] <eddyb> Tobba: JS :D
[14:06:15] <strcat> rusti: range(0, 20).zip(range(20, 40)).collect::<collections::HashMap<int, int>>()
[14:06:18] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[14:06:20] -rusti- pastebinned 1 lines of output: http://ix.io/bqI
[14:06:26] <erickt_> eddyb: did you add the Deref support to RefCell? If so, do you know if there was any talk about replacing RefCell.borrow() with getting it to directly implement Deref?
[14:06:30] *** Quits: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be) (Ping timeout)
[14:06:38] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:06:38] <strcat> rusti: range(0, 10).zip(range(20, 30)).collect::<collections::HashMap<int, int>>()
[14:06:39] -rusti- {2: 22, 5: 25, 6: 26, 9: 29, 0: 20, 4: 24, 7: 27, 8: 28, 3: 23, 1: 21}
[14:06:44] <Tobba> "missing function: _write"
[14:06:47] <Tobba> it is pretty awesome yeah
[14:06:49] <erickt_> Tobba: emscriptem support?!
[14:06:52] <eddyb> erickt_: it's not possible right not to implement it
[14:06:58] <eddyb> erickt_: *right now
[14:07:01] <erickt_> heh
[14:07:05] <Tobba> erickt_: sort of
[14:07:18] <Tobba> I'm just gonna have to build a linux version of libstd through... magic, basicaly, since I'm on windows
[14:07:29] <Tobba> then implement dummy POSIX functions
[14:07:33] <erickt_> that's awesome
[14:07:34] <eddyb> Tobba: x-compile
[14:07:38] <Tobba> or we could add proper support but who wants that
[14:07:46] <Tobba> yeah I just remember libstd being kinda convoluted to build
[14:07:53] <Tobba> maybe I remember wrong
[14:08:05] <eddyb> strcat: the failure I was seeing is "capacity overflow" but it should never happen
[14:08:09] <Tobba> building outside of the makefile, that is
[14:08:13] *** Joins: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca)
[14:08:15] <eddyb> strcat: something breaks constant folding, methinks
[14:08:25] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[14:08:30] * eddyb keeps staring at the glorious vectors
[14:08:46] *** Tomcat|mtg is now known as Tomcat|afk
[14:09:06] <eddyb> strcat: pub fn foo() -> Vec<u8> {let mut v = Vec::with_capacity(1); v.push(0); v.push(0); v}
[14:09:08] <doomlord_> was there an RFC for the idea of vtable sugar, or has that proven an unpopular idea and been shot down
[14:09:20] <eddyb> strcat: that can abort if either the malloc or realloc fail, but it can't unwind
[14:09:45] <doomlord_> ^(sugar & typesafety for extracting vtable ptrs .. like an intrinsic VTable<Type,Trait> type
[14:10:11] <eddyb> doomlord_: needs DST
[14:10:14] <strcat> eddyb: it checks on push for overflow
[14:10:19] <strcat> you can't expect failure to optimize out.
[14:10:22] <doomlord_> (intrinsic  make_trait_obj(data:&Type,   vtable:&VTable<Type,Trait>) )
[14:10:27] <strcat> it chops up the code into too many unoptimizable pieces
[14:10:33] <eddyb> strcat: push *works* though
[14:10:34] <strcat> unwinding and performance are mutually exclusive
[14:10:36] <strcat> ;p
[14:10:43] <doomlord_> VTable &'static
[14:10:46] <eddyb> strcat: the example above has no unwinding
[14:10:47] <Tobba> actually
[14:10:56] <Tobba> I'm fairly sure emscripten does the POSIX emulation stuff out of the box
[14:11:02] <eddyb> strcat: just two branches, one on malloc and one on realloc
[14:11:04] <Tobba> std works at least
[14:11:24] <eddyb> strcat: from_slice with a &[int, ..1] has unwinding code
[14:11:28] <eddyb> strcat: see an issue :D?
[14:11:35] *** jorendorff is now known as jorendorff_away
[14:11:42] <strcat> eddyb: no
[14:11:47] <strcat> the issue is having unwinding
[14:11:50] <strcat> from_slice probably uses push
[14:11:51] <eddyb> strcat: from_slice is worse than manually pushing
[14:12:01] <eddyb> something breaks along the way
[14:12:07] <det> does Rust have literals for different int types ?
[14:12:09] <strcat> yeah, that's what happens when there's failure
[14:12:12] <cmr> det: 42u8
[14:12:13] <strcat> that's what I am saying
[14:12:14] <cmr> etc
[14:12:21] <strcat> optimizers cannot deal with unwinding
[14:12:27] <strcat> it breaks most
[14:12:31] *** Quits: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca) (Ping timeout)
[14:12:38] <eddyb> strcat: it works when it's not a loop
[14:13:00] <strcat> yes
[14:13:02] <eddyb> LLVM can't see a loop has only one iteration because of unwinding, and as such can't remove the unwinding?
[14:13:07] <strcat> optimizers break when there's unwinding
[14:13:09] <eddyb> seems legit
[14:13:11] <strcat> it's too hard for them to handle
[14:13:28] *** Joins: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca)
[14:13:30] <strcat> if you want performance you can't use unwinding, at least with LLVM
[14:13:32] <eddyb> strcat: that's why I used abort in hot loops :P
[14:13:38] *** jorendorff_away is now known as jorendorff
[14:13:44] <strcat> that's why rust should give the option of using abort
[14:13:55] <strcat> and give the option of not doing dynamic dispatch on all I/O + concurrency stuff
[14:14:05] *** Joins: nik_ (nik@moz-824307E1.vpn.rwth-aachen.de)
[14:14:14] <eddyb> there's no need to do dynamic dispatch for IO if you only have on runtime linked, though
[14:14:19] <eddyb> weak items would solve that ;)
[14:14:29] <strcat> other ways of solving it without new language features
[14:14:29] <Tobba> if only the libstd rlib would contain a linux version too somehow
[14:15:03] <eddyb> Tobba: just build it with a different target triple
[14:15:09] <eddyb> Tobba: rustc is a cross-compiler
[14:15:14] <Tobba> yeah
[14:15:28] <Tobba> libstd takes ages though, and I'd need to mess around with the prelude
[14:15:29] <strcat> it would be great if landing pads didn't have to be output from the start
[14:15:33] <strcat> it'd make compilation 2x as fast
[14:15:34] <Tobba> it also requires some annoying --cfg's iirc
[14:15:40] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[14:15:54] <strcat> especially with -O0
[14:16:03] *** Joins: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be)
[14:16:08] <strcat> fastisel can't handle unwinding
[14:16:16] <cmr> oh, ouch.
[14:16:19] <Tobba> rustc also has some completely messed up triple system
[14:16:24] <strcat> it makes optimized compilation much slower too
[14:16:28] <strcat> and breaks *many* optimizations
[14:16:28] <Tobba> time to find a triple that works I guess
[14:16:37] *** Quits: heftig (heftig@moz-33D186ED.unitymedia.biz) (Ping timeout)
[14:16:42] <cmr> Tobba: it's not messed up? we pass it straight to llvm.
[14:16:45] <strcat> it's only zero cost in the sense that it doesn't execute instructions in the non-exceptional paths
[14:16:51] <Tobba> cmr: you dont, actually
[14:16:53] <strcat> it still seriously hurts performance by hurting optimization
[14:16:55] <Tobba> it gets parsed somewhere
[14:17:07] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[14:17:09] <strcat> there's a *reason* LLVM forbids exceptions
[14:17:13] <Tobba> its not possible to pass unknown for example
[14:17:31] <cmr> yes, we have a list of supported targets in the configure script for the build system.
[14:17:46] <cmr> but --target is passed straight to llvm.
[14:17:50] <Tobba> its not
[14:17:55] <Tobba> try passing an unknown target
[14:17:59] <Tobba> it wont like that
[14:18:06] <Tobba> i.e unknown os
[14:18:43] <cmr> feh that's annoying, when did that change.
[14:18:43] <det> strcat, I ran your push_back loop test, with reserve g++ beats rustc, without reserve rustc beats g++, am I seeing realloc in action ?
[14:18:44] <Tobba> it may get passed through tho
[14:18:49] <Tobba> https://github.com/mozilla/rust/blob/master/src/librustc/driver/driver.rs
[14:18:52] <Tobba> scroll down a bit
[14:18:55] <cmr> yeah I see it
[14:19:01] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Ping timeout)
[14:19:27] <eddyb> det: reserve in both?
[14:19:40] <Tobba> oh dear it just does string matching too
[14:19:50] <det> eddyb, for the reserve test yes
[14:19:50] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[14:19:54] *** Quits: NiccosSystem (NiccosSyst@moz-ED196BB4.customer.lyse.net) (Quit: Leaving)
[14:19:58] *** Quits: ozkriff (Mibbit@6014F6.BC46A4C1.71211713.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:20:11] <eddyb> det: odd results
[14:20:13] *** Joins: NiccosSystem (NiccosSyst@moz-ED196BB4.customer.lyse.net)
[14:20:21] *** Quits: NiccosSystem (NiccosSyst@moz-ED196BB4.customer.lyse.net) (Client exited)
[14:20:41] <eddyb> det: hmm, maybe we have better automatic reserve behavior
[14:21:12] *** Joins: oxum (anonymous@BE14E3DD.378E99F2.520CDC98.IP)
[14:21:14] <det> eddyb, Dont you guys have realloc ?
[14:21:24] <doomlord_> r.e. dst/vtable sugar, is that because you still want to expose the fact the vtable is a *pointer* - it can't be used by the type system without the type-system knowing the size of the pointee?
[14:21:25] <det> C++ has to always new + memcpy
[14:21:35] <eddyb> det: lol?
[14:21:41] <eddyb> I didn't realize that
[14:22:31] <Tobba> ah yes
[14:22:42] <Tobba> libstd needs me to also cross compile morestack, rustrt, libc, backtrace and compiler-rt
[14:22:57] *** Quits: edwardw (Mibbit@E9739E5B.EE06708D.4BFBD933.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:23:07] <cmr> Tobba: we have a build system you know
[14:23:08] <Tobba> which is certified pure suck, maybe I can away with using the windows version in my code then linking to linux bc
[14:23:13] <strcat> det: well, compare to clang ;p
[14:23:26] <Tobba> cmr: which is wizardry, basicaly
[14:23:28] <cmr> ./configure --target=x86_64-unknown-linux-gnu,i686-mingw32
[14:23:33] <Tobba> oh
[14:23:33] <Tobba> hm
[14:23:35] <strcat> det: but yes, realloc
[14:23:36] <Tobba> for once
[14:23:41] <strcat> det: especially with large vectors (very large)
[14:23:50] <Tobba> cmr: any way to specify output location
[14:23:50] <strcat> det: for example, lets say you need to resize a 200MiB one to 400MiB
[14:23:54] <eddyb> Tobba: time to write emscripten-rust-rt
[14:24:00] <Tobba> its not gonna try to build libc tho
[14:24:00] <strcat> det: with realloc, the allocator can fall through to mremap
[14:24:08] <Tobba> so I still need that, somehow
[14:24:08] <strcat> det: which doesn't even have to perform a copy
[14:24:15] *** Quits: jviereck (Adium@moz-7F99FDDF.ethz.ch) (Quit: Leaving.)
[14:24:22] <cmr> Tobba: no? it will build into cwd/$TARGET
[14:24:31] <Tobba> ah, yeah
[14:24:32] <strcat> det: since it will just expand the reserved memory in-place or adjust the page tables
[14:24:47] <strcat> at smaller sizes it doesn't matter as much
[14:24:52] *** Joins: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca)
[14:24:55] *** Joins: mib_mamdem (Mibbit@3E3094EC.34458CF2.CC1A2609.IP)
[14:25:09] <strcat> ideally rust would use an allocator API where it can find out the size of an allocation without overhead
[14:25:17] <strcat> so it would set the capacity to the real capacity
[14:25:27] <strcat> like kemalloc
[14:25:29] <strcat> jemalloc*
[14:25:42] <strcat>        The nallocx function allocates no memory, but it performs the same size computation as the mallocx function, and
[14:25:43] <strcat>        returns the real size of the allocation that would result from the equivalent mallocx function call. Behavior is
[14:25:45] <strcat>        undefined if size is 0, or if request size overflows due to size class and/or alignment constraints.
[14:26:15] <strcat> (sallocx is like malloc_usable_size, which implies the overhead of finding where the allocation is)
[14:26:18] <det> I think I made a mistake in this test by not using sized ints
[14:26:29] <det> rust seems to allocate 2x more memory
[14:26:36] <strcat> det: rust's int/uint are pointer-size
[14:26:48] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[14:26:49] <cmr> (ie, [u]intptr_t)
[14:27:07] <strcat> or size_t/ssize_t on non-segmented architectures (which the stdlib will never run on anyway)
[14:28:33] *** Quits: mib_mamdem (Mibbit@3E3094EC.34458CF2.CC1A2609.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[14:28:38] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[14:30:51] *** Joins: phay (phay@59D4F566.F31CC24A.5AB2926A.IP)
[14:31:50] *** Quits: Ferreus (ferreus@moz-31EB2708.dip0.t-ipconnect.de) (Ping timeout)
[14:31:58] *** Joins: mihneadb (mihneadb@moz-6B31F5AA.static.ziggozakelijk.nl)
[14:32:09] *** Joins: mye (mye@moz-776D854C.swh.uni-giessen.de)
[14:32:09] *** Joins: Kruppe (user@moz-253119B0.esg.uwaterloo.ca)
[14:33:37] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[14:35:11] <det> benchmarks are hard, clang + libc++ optimizes too much
[14:35:20] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[14:35:22] <eddyb> det: we have a black box
[14:35:38] <eddyb> det: you can probably copy it over to C++
[14:35:45] *** Quits: vikstrous (v@moz-1E061984.cpe.distributel.net) (Ping timeout)
[14:35:57] *** Quits: willingc (willingc@moz-F095E013.san.res.rr.com) (Ping timeout)
[14:36:14] <det> you pass values to this box or something ?
[14:36:58] *** Quits: Ms2ger (Ms2ger@moz-4A14BC33.ugent.be) (Quit: bbl)
[14:37:32] *** Quits: bjustin (bjustin@moz-8FC28563.sierrabravo.net) (Connection reset by peer)
[14:37:43] <eddyb> det: yupp and it has inline assembly that LLVM won't optimize around
[14:37:43] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[14:38:27] <det> eddyb, how do I use it in Rust
[14:38:39] <eddyb> det: it's in the test crate, look at the docs
[14:38:44] <det> k
[14:38:55] <eddyb> det: usually I'd pass a &mut T or &mut [T] in
[14:39:03] <eddyb> det: even &mut &mut [T]
[14:39:24] <eddyb> det: that will be considered as "anything can happen to it" even after we get TBAA
[14:39:33] <eddyb> (which is important to keep in mind when writing benchmarks)
[14:40:04] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[14:41:38] *** Joins: bjustin (bjustin@moz-8FC28563.sierrabravo.net)
[14:42:13] <farcaller> got rust-core to compile, having a strange visibility problem: error: type `&str` does not implement any method in scope named `len` in 's.len()' where s is &str
[14:42:21] <farcaller> isn't it defined in str.rs?
[14:42:42] <cmr> farcaller: you need the Container trait in scope
[14:44:11] *** Quits: asmyers (quassel@F8C86AB2.9A737B8F.FAA4474F.IP) (Ping timeout)
[14:44:28] <det> k, Rust indeed slaughters clang without reserve (2x faster)
[14:44:46] <strcat> det: what about with reserve (and integers of the same size)?
[14:44:56] <det> its the same then
[14:45:02] <strcat> good ;)
[14:45:20] <det> Rust without reserve is the same speed as with
[14:45:25] *** Joins: maxli1 (Adium@moz-EE42E0E.student.cs.uwaterloo.ca)
[14:45:26] <strcat> we can do better anyway
[14:45:31] <strcat> if we used a better allocator API
[14:45:37] <strcat> malloc/realloc/free is a terrible crippled API
[14:45:54] <det> I heard talk of jemalloc
[14:46:01] <strcat> det: yeah
[14:46:15] <strcat> for one thing, if the allocator API can cheaply tell you the real allocation size, then you do fewer realloc calls
[14:46:21] *** Joins: voxpopuli (fanservice@EE3832E.191E59C5.689607DE.IP)
[14:46:23] <farcaller> undefined reference to `str::_$BP$$x27a$x20str.Container::len::h8f792d9d985b2345Whd::v0.0'
[14:46:24] <farcaller> huh.
[14:46:33] <strcat> so less work calling it and searching through metadata only to essentially do nothing
[14:46:39] *** Quits: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca) (Ping timeout)
[14:46:42] <farcaller> I need to rework my linking
[14:47:08] *** Quits: maxli1 (Adium@moz-EE42E0E.student.cs.uwaterloo.ca) (Ping timeout)
[14:47:15] <strcat> det: linux will be changing this playing field soon though... new allocation API is on the way ;)
[14:47:40] <strcat> det: https://lkml.org/lkml/2013/3/12/105
[14:47:41] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Client exited)
[14:47:44] * strcat is sad that it hasn't landed yet
[14:48:11] <strcat> there's newer work on it since then
[14:48:15] *** Joins: rylev (rylev@67C897F6.EC25D36F.59369754.IP)
[14:48:19] <det> Rust is so forward looking, I love it :)
[14:48:19] <strcat> but that post has benchmarks with jemalloc
[14:48:57] *** Joins: asmyers (quassel@3F39C117.9A737B8F.FAA4474F.IP)
[14:49:19] *** Joins: jviereck (Adium@moz-66CB1F7B.ethz.ch)
[14:49:55] *** Quits: rylev (rylev@67C897F6.EC25D36F.59369754.IP) (Ping timeout)
[14:51:03] *** Joins: dschatzberg (dschatzber@moz-4CB3F0EE.bu.edu)
[14:51:45] <farcaller> seems that ld doesn't really like libcore-blahblah.rlib, as the symbol is actually defined correctly in there
[14:51:46] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[14:52:03] <benh> rust documentation actually improved a lot since i last checked
[14:52:08] <benh> you are all great
[14:52:36] *** Joins: aravindavk (aravinda@B04D3E6C.1666E08B.C28A6AA4.IP)
[14:52:38] <cmr> farcaller: you may need to de-ar the rlib and link the .o directly, if your linker doesn't like unrecognized files
[14:52:44] <cmr> (we have metadata and a .bc in there too)
[14:53:01] <farcaller> cmr: trying that right now
[14:54:05] <farcaller> cmr: seems to work that way, dozens of undefined libgcc symbols now for whatever reason :)
[14:54:18] *** Joins: jviereck1 (Adium@moz-66CB1F7B.ethz.ch)
[14:54:36] *** Quits: jviereck (Adium@moz-66CB1F7B.ethz.ch) (Ping timeout)
[14:54:38] *** Joins: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP)
[14:57:29] *** Quits: Zr40 (zr40@EE4BB9F5.926C319A.BE2F4011.IP) (Quit: leaving)
[14:57:42] <farcaller> acutally only one I'm missing is __mulodi4. Time to switch away from libgcc
[14:57:46] *** Quits: EastByte_ (EastByte@moz-5386EBF.ewe-ip-backbone.de) (Ping timeout)
[14:58:18] <strcat> farcaller: yeah without compiler-rt some stuff is missing
[14:58:22] *** Quits: jviereck1 (Adium@moz-66CB1F7B.ethz.ch) (Quit: Leaving.)
[14:58:26] <strcat> that's for overflow-checked 64-bit multiplication
[14:58:28] *** Joins: EastByte_ (EastByte@moz-E1DF5B1E.ewe-ip-backbone.de)
[14:58:43] <farcaller> strcat: I guess I can survive without that on cortex-m0 :)
[14:58:44] <strcat> rusti: 100u8.checked_mul(&2)
[14:58:45] -rusti- Some(200)
[14:58:54] <strcat> rusti: 100u8.checked_mul(&3)
[14:58:54] -rusti- None
[15:00:35] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[15:00:35] *** ChanServ sets mode: +o jdm
[15:01:09] *** Quits: vgeddes (vincent.ge@moz-102C6E36.access.mtnbusiness.co.za) (Ping timeout)
[15:01:20] <farcaller> arm-none-eabi-ld: build/app.elf section `.ARM.exidx' will not fit in region `rom'
[15:01:20] <farcaller> arm-none-eabi-ld: region `rom' overflowed by -928 bytes
[15:01:31] <farcaller> plan B: don't use rust-core :-D
[15:01:37] *** Quits: wilmoore (wilmoore@moz-4EF3CEBC.hsd1.co.comcast.net) (Ping timeout)
[15:02:54] <strcat> farcaller: optimize
[15:02:56] <strcat> it will all optimize out
[15:02:59] *** Quits: aravindavk (aravinda@B04D3E6C.1666E08B.C28A6AA4.IP) (Ping timeout)
[15:03:00] *** Joins: StarLight (StarLight@28F0D88.EC84A0AD.F1EF1E39.IP)
[15:03:01] <farcaller> strcat: is there anything like -ffunction-sections -fdata-sections?
[15:03:03] <strcat> -O -Z lto
[15:03:10] <strcat> farcaller: don't need it, we have cross-crate lto
[15:03:17] <farcaller> ah
[15:03:35] <farcaller> does that work with external linker?
[15:03:39] <strcat> farcaller: yeah
[15:03:43] <strcat> rust does the LTO itself
[15:03:49] <benh> What's the effect of explicitly saying extern crate native; #[start] fn start(...) {...} etc rather than just defining main?
[15:03:57] *** Joins: vikstrous (v@moz-1E061984.cpe.distributel.net)
[15:04:00] <strcat> in C the linker is needed since you have .o files
[15:04:01] <strcat> with cyclic deps
[15:04:02] <farcaller> strcat: lto can only be run for executables and static library outputs (rust-core is rlib)
[15:04:14] <strcat> farcaller: rlib is static/lto
[15:04:32] <farcaller> strcat: so I just add -Z lto to rustc for my code?
[15:04:40] <strcat> farcaller: yeah, and -O
[15:04:46] <strcat> look at `ar t foo.rlib`
[15:04:56] <strcat> there's a .o, metadata and then bytecode for link-time optimization
[15:05:14] <strcat> so without -Z lto you link in the .o, with LTO it merges the bytecode into what your stuff produces
[15:05:53] <Tobba> (this is extremely useful with emscripten, by the way)
[15:06:02] <Tobba> no need for .bc inflate shitshuffling
[15:06:11] <Tobba> holy shit its still building rustc
[15:06:13] *** Joins: cschneid (cschneid@moz-CA025D57.ip.mcleodusa.net)
[15:06:21] <farcaller> yay, 12000 bytes
[15:06:51] <strcat> farcaller: also -Z no-landing-pads might help
[15:07:03] <strcat> disables handling of unwinding
[15:07:05] <farcaller> that's only 148 bytes overhead compared to my homegrown libstd
[15:07:15] <farcaller> strcat: already have that one
[15:07:24] *** Joins: benjamin_____ (benjamin@moz-E33D9812.dip0.t-ipconnect.de)
[15:07:33] *** Quits: kris (kris@moz-A7897749.gjk.dk) (Ping timeout)
[15:07:35] <strcat> farcaller: and --gc-sections to the linker :)
[15:07:38] <strcat> to kill the stupid crate map
[15:07:43] *** Quits: oxum (anonymous@BE14E3DD.378E99F2.520CDC98.IP) (Ping timeout)
[15:07:49] <farcaller> but it doesn't seem to disable anything, I still had to drop my empty versions of __aeabi_unwind_cpp_pr0/__aeabi_unwind_cpp_pr1
[15:07:56] <acrichto> erickt_: pong
[15:07:56] <farcaller> I did :)
[15:08:01] *** Quits: benjamin_ (benjamin@moz-5894B012.dip0.t-ipconnect.de) (Ping timeout)
[15:08:07] <cmr> strcat: crate map is gone on master
[15:08:15] <strcat> farcaller: I think the overhead probably comes from destructors
[15:08:17] <strcat> cmr: ah
[15:08:19] <strcat> right
[15:08:28] <strcat> farcaller: atm rust thinks all dtors are external
[15:08:35] <strcat> although you'd think lto would zap them
[15:08:35] <Tari> benh: #[start] overrides the default runtime startup so you can specify your own
[15:08:37] <strcat> haven't checked
[15:08:59] <Tari> benh: see the example in the libnative docs
[15:09:10] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[15:09:18] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:09:26] <strcat> benh: your main function is really just called by the startup function in either libgreen or libnative
[15:09:28] <benh> Tari: I'm curious because libnative already is the default, so I wonder if doing that dance is just a no-op, or what exactly I'm overriding
[15:09:36] <strcat> benh: main doesn't define the entry point
[15:09:40] <strcat> libnative is calling your code
[15:09:43] <strcat> and doing stuff before/after
[15:09:51] <strcat> such as waiting for all threads to be joined after
[15:09:51] <cmr> benh: with libnative you don't need a #[start] to use it.
[15:10:07] *** Joins: ChrisOei (ChrisOei@moz-53A9266A.blurb.com)
[15:10:12] <benh> cmr: yeah. but what's the effect if i do use a #[start]? Is there a chance to break something?
[15:10:16] <strcat> benh: yes
[15:10:26] <strcat> benh: you won't be initializing and shutting down the runtime
[15:10:36] <strcat> benh: look at the definition of the entry point in libnative if you want
[15:10:41] <cmr> (if you don't use native::start)
[15:10:42] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[15:11:02] <strcat> cmr: src/libnative/lib.rs fn start
[15:11:04] <strcat> er
[15:11:06] <strcat> benh: *
[15:11:25] *** Joins: vgeddes (vincent.ge@moz-102C6E36.access.mtnbusiness.co.za)
[15:11:26] <benh> yeah i'm looking at that, since that code snippet is calling that...
[15:11:36] <benh> I mean what is #[start] fn start() in user code specifically overriding?
[15:11:44] <strcat> benh: this
[15:11:46] <cmr> the entry point of the binary.
[15:12:05] <strcat> benh: 'fn main() {}' isn't the entry point, it's called by native::start
[15:12:16] <benh> strcat: ok
[15:12:16] <farcaller> error: type `&mut [u8]` does not implement any method in scope named `iter`. I thought rust-core support iters?
[15:12:21] <benh> does rustc check if there's a #[start] function and if not it emits a funtion that looks like fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) }?
[15:12:31] <strcat> benh: yes
[15:12:38] <strcat> benh: -S --emit=ir -o -
[15:12:43] <strcat> on fn main() {}
[15:12:45] <benh> ok 8)
[15:12:56] *** Joins: alexandp (weBeThread@BCD2EF9E.335C641C.D3B5A672.IP)
[15:13:05] <cmr> strcat: specifically it calls the function with specifies #[lang="start"]
[15:13:13] <strcat> farcaller: it does but it defines them with free functions
[15:13:18] <benh> so doing #[start] fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, main) } is precisely a no-op right now?
[15:13:22] <strcat> farcaller: well
[15:13:31] <strcat> it's core::slice::iter or something
[15:14:04] <farcaller> error: type `&mut core::slice::Items<,u8>` does not implement any method in scope named `next`
[15:14:08] <farcaller> :-|
[15:14:13] <strcat> farcaller: need Iterator in-scope
[15:14:19] <strcat> traits need to be in-scope to call methods from them
[15:14:22] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[15:14:29] *** Quits: espadrine (Thunderbir@moz-9BC91D35.w92-128.abo.wanadoo.fr) (Ping timeout)
[15:14:37] <strcat> you can't add methods to built-in types except via traits which is why it uses free functions in those cases at all
[15:14:49] <strcat> fixable language limitation
[15:15:03] *** Quits: twi (Adium@moz-429185BE.cust.vodafonedsl.it) (Connection reset by peer)
[15:15:07] *** Joins: twi (Adium@moz-429185BE.cust.vodafonedsl.it)
[15:15:30] <benh> i'm asking because i don't get the point of the section http://static.rust-lang.org/doc/master/guide-runtime.html#force-booting-with-libnative since libnative is the default now
[15:15:32] *** Quits: zmack (zmack@EFEB97D9.20AB2BFB.E400A05F.IP) (Ping timeout)
[15:15:44] <benh> just trying to figure out whether doing that is a no-op effectively
[15:15:54] <benh> or if there's a subtle difference in what mode the runtime is booted in or whatever
[15:16:04] <strcat> that's just what it does by default
[15:16:04] <cmr> there's no difference.
[15:16:07] <Tari> it's probably just a leftover from when libgreen was default
[15:16:19] <farcaller> sorry for all this flow of errors. error: only `u8` can be cast as `char`, not `&u8` in for i in iter(bsl) { self.putc(i as char); }. *i  fails even more strange: error: unreachable pattern
[15:16:40] <benh> thank you for clearing that up
[15:16:42] <cmr> farcaller: `for &i`, or `putc(*i as char)`
[15:16:54] <strcat> farcaller: rust's char isn't a byte
[15:17:02] <strcat> it's a unicode scalar value
[15:17:28] <farcaller> both result in unreachable pattern (while func: https://gist.github.com/farcaller/f72cb68c4a11dfd2ddfd)
[15:18:24] <farcaller> *whole func
[15:18:37] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Ping timeout)
[15:18:45] *** Joins: espadrine (Thunderbir@moz-9BC91D35.w92-128.abo.wanadoo.fr)
[15:18:57] *** Joins: kngl (Adium@moz-18BD1C.ipv4.evonet.be)
[15:19:12] *** Joins: edwardw (edwardw@6B6F4036.AB331A3B.FAED9FFC.IP)
[15:20:41] <kimundi> farcaller: can you post the actual errors?
[15:21:22] <farcaller> kimundi: updated the gist
[15:21:47] <Tobba> whats a trait for all integers?
[15:22:04] <cmr> Tobba: http://static.rust-lang.org/doc/master/num/trait.Integer.html
[15:22:06] <Tobba> numeric traits are such a clusterfuck I'll probably find int not implementing Integer
[15:22:10] <Tobba> oh-
[15:22:14] <Tobba> for once...
[15:22:55] <Tobba> does that include unsigned integers?
[15:23:06] <cmr> look at the list of implementors.
[15:23:14] <kimundi> farcaller: Huh, thats a failry non specific error indeed. It either has a problem with the &i, or with the SOme/None the for loop syntax uses internally
[15:23:14] <Tobba> ah right
[15:23:20] <Tobba> for once, a number trait that actually makes sense
[15:23:33] <kimundi> farcaller: Try importing Some and None if they aren't
[15:23:48] <cmr> oh, yeah, from the for expansion.
[15:24:00] <SiegeLord> Will UFCS allow me to do use foo = Trait::<for Bar>::foo; foo(x)?
[15:24:05] <farcaller> kimundi: improting None helped
[15:24:20] <cmr> SiegeLord: I believe it would be Bar::foo
[15:24:22] <strcat> cmr: which is a terrible hack ;\
[15:24:26] <strcat> Iterator should just be a lang item
[15:24:31] <farcaller> still at 12000 bytes of .text, a bit more readable though :)
[15:25:46] <jxs> acrichto, given the utsname struct the right size according to linux, 65, but now it segfaults, it i use the osx size 256, it doesn't segfault, but also only reads the first field, sysname, then get's corrupted, any idea?
[15:26:22] <acrichto> jxs: you're sure the structs all line up with each platform?
[15:26:36] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[15:26:41] <strcat> jxs: glibc has more than one uname
[15:26:53] <benh> The rust function name mangling scheme goes something like name of the function ignoring the module it's in, a hash, rust version?
[15:27:02] *** Quits: voxpopuli (fanservice@EE3832E.191E59C5.689607DE.IP) (Ping timeout)
[15:27:09] <Tobba> ah, crap
[15:27:11] <strcat> jxs: look at the expansion of C code calling uname with/without -D_GNU_SOURCE
[15:27:21] <Tobba> I cant match an Integer
[15:27:36] <Tobba> I guess they should all in theory implement equals
[15:27:43] <strcat> benh: the hash is based on the types and crate versions
[15:27:55] <strcat> afaik
[15:27:58] <Tobba> its quite ridiclous I have to import a bignum module to get an Integer trait tho
[15:28:35] <benh> I'm just sad I can't easily go from the mangled name to the whole path, though I guess there's not necessarily a unique path for functions anyway
[15:28:54] <strcat> libnum isn't a bignum crate
[15:28:55] <strcat> it's just an everything-numeric-not-use-by-libstd crate
[15:28:55] <benh> Easily as in "by hand, looking at the ir output"
[15:28:56] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:29:01] <Tari> Tobba: huh? num::Integer isn't in a bignum module..
[15:29:15] <Tobba> num:: is bignum though
[15:29:20] <Tobba> mostly
[15:29:25] <Tari> it provides bignum, eh
[15:29:35] <Tobba> binary size spiralling out of control, oh well
[15:29:41] <jxs> acrichto, strcat, yup you are right, missed another field called domainname  
[15:29:43] <strcat> Tobba: -Z lto then
[15:29:46] * strcat shrugs
[15:29:48] <Tobba> well yeah
[15:29:49] <Tobba> slower tho
[15:29:58] <Tobba> actually, that doesnt matter right now
[15:30:07] <strcat> jxs: they do have another uname not requiring that field
[15:30:16] <strcat> different symbols, expands to a different one based on _GNU_SOURCE
[15:30:20] <jxs> # ifdef __USE_GNU
[15:30:21] <jxs>     char domainname[_UTSNAME_DOMAIN_LENGTH];
[15:30:21] <jxs> # else
[15:30:21] <jxs>     char __domainname[_UTSNAME_DOMAIN_LENGTH];
[15:30:21] <jxs> # endif
[15:31:00] <strcat> hm
[15:31:02] * strcat shrugs
[15:31:06] <strcat> I thought they had two symbols
[15:31:06] *** Joins: josh (josh@moz-C350AC70.hsd1.mn.comcast.net)
[15:31:15] <jxs> it's dependent of the _GNU_SOURCE flag, what is this flag?
[15:31:40] <strcat> jxs: allows you to use linux-specific stuff, much like _POSIX_C_SOURCE and _BSD_SOURCE
[15:31:46] <Tari> magic feature flag, basically
[15:31:58] *** Quits: espadrine (Thunderbir@moz-9BC91D35.w92-128.abo.wanadoo.fr) (Ping timeout)
[15:32:02] <Tari> what's more fun is that a number of them are implied by default
[15:32:30] <Tari> gcc defaults to -std=gnu89, which implies _GNU_SOURCE among others
[15:32:38] <Tobba> argh
[15:32:43] <Tobba> turns out comparing an Integer to normal ints
[15:32:50] <Tobba> is not a good thing to attempt
[15:32:52] <jxs> ok, so even if i make the struct with the domainname field it might not work on linux depending on that flag being enabled or not? 
[15:33:00] <Tobba> but I need this to work for any builtin integer
[15:33:00] <Tobba> fuck
[15:33:21] <Tari> jxs: it's a compile-time flag, so you just need to be consistent and it should work
[15:33:57] <Tari> but being consistent might be difficult due to the maze that is glibc includes
[15:34:15] <jxs> ehe, i was going to ask that, what being consistent was :P
[15:34:22] <Tobba> ... goddamnit how am I even meant to
[15:34:35] *** Joins: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net)
[15:34:36] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[15:35:28] <Tari> Tobba: Primitive might be more appropriate than Integer
[15:35:32] <Tobba> yeah uh
[15:35:34] *** Joins: espadrine (Thunderbir@moz-9BC91D35.w92-128.abo.wanadoo.fr)
[15:35:36] <Tobba> that would be awkward as hell though
[15:35:41] <Tobba> oh well
[15:36:36] <jxs> anyway, solved the segfault, thanks a lot guys!
[15:37:26] *** kimundi is now known as zz_kimundi
[15:38:21] *** Joins: thewonderidiot (mstewart@moz-E41129BA.ipnetworksinc.net)
[15:38:36] *** Quits: mawuli (mawuli@moz-781516AB.com.gh) (Ping timeout)
[15:38:36] *** Joins: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[15:38:40] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[15:38:59] *** Joins: mawuli (mawuli@moz-781516AB.com.gh)
[15:40:35] *** Joins: wilmoore (wilmoore@moz-7EE4D9D6.mystrotv.com)
[15:42:36] *** Joins: voxpopuli (fanservice@EE3832E.191E59C5.689607DE.IP)
[15:48:35] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[15:48:53] *** Joins: hoverbear (hoverbear@726D908C.44E18222.E74D50F2.IP)
[15:49:03] *** Joins: rylev (rylev@moz-5C408D5C.cust.telecolumbus.net)
[15:49:31] *** Quits: untitaker (untitaker@moz-B015CD5B.adsl.highway.telekom.at) (Ping timeout)
[15:49:57] *** Joins: Matthias247 (Miranda@moz-678B5E4A.hsi2.kabel-badenwuerttemberg.de)
[15:50:01] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[15:50:30] *** Quits: ssira (ssira@moz-F6206352.kanagawa.ocn.ne.jp) (Client exited)
[15:50:43] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[15:50:43] *** ChanServ sets mode: +o pnkfelix
[15:50:50] *** Quits: rylev (rylev@moz-5C408D5C.cust.telecolumbus.net) (Ping timeout)
[15:50:51] *** Joins: ssira (ssira@moz-F6206352.kanagawa.ocn.ne.jp)
[15:51:05] *** Joins: mno2 (mno2@C9C55379.F9BA5024.DA359910.IP)
[15:51:20] *** Quits: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: tobytailor)
[15:51:48] *** Joins: adonohue (adonohue@3332E4C0.6B10AC3.E2F59BBC.IP)
[15:51:54] *** Joins: FrozenCow (FrozenCow@moz-54300F7F.upc-j.chello.nl)
[15:52:32] *** Quits: ssira (ssira@moz-F6206352.kanagawa.ocn.ne.jp) (Ping timeout)
[15:53:07] *** Joins: bpicolo (Adium@moz-B475EB64.static-ip.telepacific.net)
[15:53:32] *** Joins: m-r-r (m-r-r@moz-12251648.rev.sfr.net)
[15:54:59] *** Quits: [squiddy] (squiddy@moz-7B493F09.dip0.t-ipconnect.de) (Quit: Leaving)
[15:55:20] *** Quits: mye (mye@moz-776D854C.swh.uni-giessen.de) (Quit: So long, and thanks for all the fish!)
[15:56:56] *** Quits: benjamin_____ (benjamin@moz-E33D9812.dip0.t-ipconnect.de) (Ping timeout)
[15:57:07] *** Joins: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[15:57:29] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[15:58:01] *** Joins: untitaker (untitaker@moz-C9BFA0EA.adsl.highway.telekom.at)
[15:58:20] *** Joins: jxv (jxv@moz-8FB92450.lightspeed.irvnca.sbcglobal.net)
[15:58:31] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[15:59:30] *** Quits: edwardw (edwardw@6B6F4036.AB331A3B.FAED9FFC.IP) (Ping timeout)
[15:59:34] *** Quits: mno2 (mno2@C9C55379.F9BA5024.DA359910.IP) (Quit: mno2)
[16:00:31] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[16:02:04] *** Quits: leowoe (Leo@moz-CEF2400C.inf.uni-konstanz.de) (Quit: Leaving.)
[16:03:09] *** Quits: alexandp (weBeThread@BCD2EF9E.335C641C.D3B5A672.IP) (Quit: alexandp)
[16:04:38] *** Joins: osa1 (omer@8A668854.BEF1EF69.8633E8B5.IP)
[16:05:22] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:05:42] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[16:06:54] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[16:07:24] *** Joins: onelson (owen@moz-DD666EC5.laika.com)
[16:07:30] *** Quits: phay (phay@59D4F566.F31CC24A.5AB2926A.IP) (Quit: phay)
[16:07:32] *** Quits: skade (skade@B4A5FE21.505237C9.CAE22B62.IP) (Connection reset by peer)
[16:07:38] *** Joins: skade (skade@B4A5FE21.505237C9.CAE22B62.IP)
[16:07:57] *** Quits: adonohue (adonohue@3332E4C0.6B10AC3.E2F59BBC.IP) (Quit: adonohue)
[16:09:50] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Ping timeout)
[16:09:52] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[16:12:32] *** Joins: IanCormac84 (Hakim2@38FB8D31.2A8D8854.67DFF8B4.IP)
[16:13:07] *** Quits: ktos (ktos@moz-91C103D0.swidnica.mm.pl) (Ping timeout)
[16:15:13] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[16:16:29] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[16:16:44] *** Quits: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net) (Input/output error)
[16:17:17] <det> Would this proposal mean that Rust could rewrite pass by reference into pass by value for types with a sizeof() under some threshold: http://smallcultfollowing.com/babysteps/blog/2014/02/25/rust-rfc-stronger-guarantees-for-mutable-borrows/
[16:17:48] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[16:18:22] <cmr> det: I don't believe so?
[16:18:48] <cmr> I mean, we *could* do that already, can't we?
[16:19:30] <Tobba> ugh
[16:19:36] <Tobba> this cross compiling thing really isnt working out
[16:19:38] <Tobba> -fPIC ignored for target (all code is position independent) [-Werror]
[16:19:41] <Tobba> with -Werror specified
[16:20:30] *** Quits: patpat (patpat@moz-21619C28.as13285.net) (Ping timeout)
[16:20:31] <det> cmr, it would be unsafe now I believe (with my limited knowledge of Rust) because const doesnt imply immutable
[16:20:37] *** Joins: patpat (patpat@moz-21619C28.as13285.net)
[16:21:17] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[16:21:36] *** Joins: kris (kris@177D1A6A.BCA0057D.A509ECBA.IP)
[16:21:57] *** Quits: TinFox (TinFox@F3D0A69D.9F4E79F1.F7512391.IP) (Ping timeout)
[16:21:59] <cmr> det: & and &mut borrows still can't overlap, without that proposal.
[16:22:10] *** Joins: TAL (Mibbit@6961AF8E.D44E7E3B.79045CC5.IP)
[16:22:16] <cmr> rusti: fn foo(x: &int) -> int { *x } let mut x = 42; let y = &mut x; foo(&x)
[16:22:17] *** Quits: mihneadb (mihneadb@moz-6B31F5AA.static.ziggozakelijk.nl) (Quit: Computer gone to sleep - Zzzz...)
[16:22:22] <TAL> :d
[16:22:33] <TAL> Hi 
[16:22:47] *** Quits: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca) (Quit: canhtak)
[16:22:52] <cmr> rusti: 2 + 2
[16:23:11] <cmr> strcat: rusti broken?
[16:23:11] *** Joins: kris_ (kris@moz-A7897749.gjk.dk)
[16:23:18] *** Quits: josh (josh@moz-C350AC70.hsd1.mn.comcast.net) (Quit: josh)
[16:23:22] *** Quits: kris (kris@177D1A6A.BCA0057D.A509ECBA.IP) (Ping timeout)
[16:23:52] -rusti- pastebinned 13 lines of output: http://ix.io/bqL
[16:23:52] -rusti- 4
[16:23:56] *** Joins: TinFox (TinFox@F3D0A69D.9F4E79F1.F7512391.IP)
[16:24:10] <cmr> heh
[16:24:15] <cmr> det: see http://ix.io/bqL
[16:24:40] <det> cmr, thanks, I was not aware of this restriction
[16:24:42] <cmr> det: if you have a &T, and T does not contain any Unsafe fields, it's immutable.
[16:24:54] *** Joins: frozendevil (Adium@moz-62FB197F.com)
[16:25:43] <strcat> cmr: ix.io is just really really slow
[16:26:44] *** Joins: edwardw (edwardw@4112974A.B4358688.30F15291.IP)
[16:28:19] *** Quits: erickt_ (erickt@49C4075F.3AC15C18.2321E71E.IP) (Ping timeout)
[16:29:00] *** Joins: evanm (evanm@636AC086.5999CED5.71743E61.IP)
[16:29:36] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:29:44] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[16:30:27] <Tobba> rust-sdl2 is weird
[16:30:36] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[16:30:40] <Tobba> SDL somehow manages to summon a window that looks like winxp on windows 8
[16:30:57] <Tobba> I have no idea but that has to be on purpose
[16:31:11] <strcat> Tobba: what do you mean 'like XP'?
[16:31:32] <Tobba> imagiane a window that looks like they did in XP with the classic theme
[16:31:32] <strcat> sdl2 works great for me, in contrast to 1.2 which is pretty hopelessly broken
[16:31:40] <Tobba> it creates those, for some reason
[16:31:47] <Havvy> Pic?
[16:31:57] <strcat> well I would expect that compositing gets disabled when in full screen
[16:32:05] *** Joins: Ferreus (ferreus@moz-E036D928.lsn.wtnet.de)
[16:32:07] <strcat> so the dwm windows will revert to the classic style
[16:32:14] <Tobba> https://dl.dropbox.com/u/4838268/ShareX/2014-04/2014-04-02_18-32-08.png
[16:32:15] <eddyb> Tobba: classic theme is not winXP
[16:32:19] <eddyb> Tobba: it's more like '95
[16:32:28] <Tobba> ye, but XP came to mind
[16:32:34] <Tobba> because who in their right mind ran the default XP theme
[16:32:52] <eddyb> Tobba: my brother sometimes used the silvery one
[16:32:57] <Tobba> not even the win8 classic theme looks like that, I'm pretty sure you would need to draw a window manually for it to look like that
[16:32:58] <eddyb> can't say I didn't complain :P
[16:33:18] <Tobba> hahhahaah
[16:33:23] <Havvy> The olive theme.
[16:33:40] <eddyb> because someone really hates olives
[16:33:56] <TAL> hello 
[16:34:16] <cmr> TAL: hi
[16:34:34] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[16:34:45] <TAL> Hello cmr !
[16:34:46] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Ping timeout)
[16:34:53] <TAL> New to rust
[16:35:13] <SiegeLord> Maybe it's a wrong subsystem version? I remember I had issues with D and Allegro because D used an older subsystem
[16:35:34] *** Joins: esummers (esummers@moz-3B015C90.wi.res.rr.com)
[16:35:45] <eddyb> microsoft don't joke around backwards compat
[16:35:48] <Tobba> could be it
[16:35:51] <Tobba> still straaaaaaange though
[16:36:02] <eddyb> you could even go as far as claiming it's the only thing they're good at :P
[16:36:03] <Tobba> oh jeez SDL blend modes are per surface?
[16:36:04] <SiegeLord> In my case the symptom was no window borders at all
[16:36:06] <Tobba> this is gonna be a lot of shuffling
[16:36:20] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[16:36:20] <eddyb> (keeping broken crap work forever)
[16:36:22] <cmr> eddyb: except with IE compat modes :|
[16:36:40] <eddyb> cmr: because we really needed that
[16:36:42] <cmr> and .NET
[16:36:50] <eddyb> how can we live without IE5?
[16:36:53] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[16:37:17] <cmr> eddyb: no, if you use for example IE6/7/8 compat in IE9/10, it... still acts differently, often in subtly broken ways.
[16:37:27] <cmr> you actually need to test on the older browsers.
[16:37:34] <eddyb> cmr: oh, I have an open question
[16:37:44] <eddyb> where the heck did .NET's name come from?
[16:37:54] <Tobba> I love how they added modes for emulating their own bugs
[16:37:57] <Tobba> they just liked them that much
[16:38:01] <Yurume> is there any way to perform 64x64->128 multiplication in Rust?
[16:38:21] <eddyb> Yurume: I don't think we expose intrinsics for it
[16:38:22] <Tobba> I dont think we even have 128 bit ints
[16:38:29] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[16:38:31] <bpicolo> https://github.com/jsanders/rust-bignum
[16:38:33] <strcat> eddyb: there aren't platform independent intrinsics for it
[16:38:34] <Yurume> Tobba, 64x64->(64,64) to be exact
[16:38:40] <eddyb> Yurume: you can always do it "manually"
[16:38:47] *** Joins: bollu (bollu@moz-AF1E4A33.clients.kiwiirc.com)
[16:38:49] <cmr> eddyb: http://stackoverflow.com/questions/1495287/what-does-net-stand-for-is-it-an-acronym
[16:38:51] <eddyb> and hope that it will be optimized to the relevant instructions
[16:38:57] *** Quits: W0rmDr1nk (wormdrink@moz-CEAF0263.access.mtnbusiness.co.za) (Ping timeout)
[16:38:59] *** Joins: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca)
[16:39:01] <Yurume> yeah, though it would be suboptimal to do it manually
[16:39:04] <eddyb> cmr: right, because SO knows all the answers to my questions
[16:39:13] <eddyb> Yurume: just do it and check if it gets optimized
[16:39:15] <eddyb> this is like rot
[16:39:32] <Yurume> really?
[16:39:34] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[16:39:35] *** Joins: leowoe (Leo@moz-F1E78404.dip0.t-ipconnect.de)
[16:39:52] <Yurume> well, I'd better try it anyway
[16:40:12] <eddyb> "actually passed legal/trademark review (surprisingly difficult!)"
[16:40:15] <eddyb> cmr: too easy IMO
[16:40:25] *** Joins: azakai (alon@moz-62518563.mtv2.mozilla.com)
[16:42:02] *** Joins: dherman (dherman@moz-C07D5168.p2p.sfo1.mozilla.com)
[16:42:02] *** ChanServ sets mode: +ao dherman dherman
[16:43:08] *** Quits: voxpopuli (fanservice@EE3832E.191E59C5.689607DE.IP) (Ping timeout)
[16:43:56] *** Joins: radford (Adium@moz-A69E09BD.warp2biz.com)
[16:44:34] *** Quits: ganitsu (ganitsu@moz-11D467C8.dialup.adsl.anteldata.net.uy) (Ping timeout)
[16:44:58] <jxs> wow, just noticed, a simple rust hello world has 1.8m size, is there a special reason for that?
[16:45:20] <strcat> jxs: static linking, + you're not stripping debug symbols
[16:45:23] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:45:34] <strcat> the size of a -Z lto -O binary is a bug, that should be 10k
[16:46:01] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[16:46:16] <strcat> jxs: it dynamically links against system libs by default but statically links rust ones
[16:46:25] <cmr> jxs: you can use -C prefer-dynamic to get a smaller but dynamically linked binary.
[16:46:29] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[16:46:34] <strcat> -Z lto *should* result in a minimal binary though
[16:46:41] <strcat> it'll be fixed one way or another
[16:46:54] <jxs> ok, thanks strcat, i was going to ask that, because if i ldd the rust binary on linux it shows a lot of dynamic libs 
[16:47:37] *** Quits: TinFox (TinFox@F3D0A69D.9F4E79F1.F7512391.IP) (Ping timeout)
[16:47:57] <strcat> the reason it doesn't currently optimize out is trait objects used to abstract the runtime dynamically
[16:48:04] *** Joins: zztr (Thunderbir@moz-CA50D606.dsl.static.sonic.net)
[16:48:15] <strcat> because whether a task is 1:1 or M:N is a dynamic thing
[16:48:23] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[16:48:24] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[16:48:24] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[16:48:42] <jxs> oh, ok 
[16:48:50] <jxs> by the way, also, does rust dynamic link c libs by default? i didn't need the link compiler directive to access the utsname.h
[16:49:07] <cmr> jxs: libstd links to libc.
[16:49:09] *** Joins: TinFox (TinFox@F3D0A69D.9F4E79F1.F7512391.IP)
[16:49:19] <strcat> and libm, libpthread, etc.
[16:49:37] <jxs> oh ok i see, thanks a lot :)
[16:49:53] *** Joins: rylev (rylev@moz-2721FC62.cust.telecolumbus.net)
[16:50:09] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[16:50:17] *** Quits: ahunt (ahunt@moz-6D6D79D6.cable.virginm.net) (Ping timeout)
[16:51:13] *** Joins: khodzha (khodzha@557CE0BA.2AEE264E.CA6E2165.IP)
[16:51:16] *** Quits: leowoe (Leo@moz-F1E78404.dip0.t-ipconnect.de) (Quit: Leaving.)
[16:51:39] *** Quits: khodzha1 (khodzha@BA0B862B.2AEE264E.CA6E2165.IP) (Ping timeout)
[16:51:39] *** Quits: rylev (rylev@moz-2721FC62.cust.telecolumbus.net) (Ping timeout)
[16:52:03] *** Joins: TimAbraldes (quassel@moz-7FD19BDC.hsd1.or.comcast.net)
[16:52:06] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[16:52:41] *** Joins: mrshankly (mrshankly_@moz-A56896CA.rev.vodafone.pt)
[16:53:20] *** Quits: Sharp (Sharp@moz-633F3606.hsd1.ca.comcast.net) (Ping timeout)
[16:53:46] *** Joins: Sharp (Sharp@moz-633F3606.hsd1.ca.comcast.net)
[16:53:56] <Yurume> strcat, is the post-LTO binary bloat problem intrinsic to the use of trait objects?
[16:54:12] *** Quits: mrshankly (mrshankly_@moz-A56896CA.rev.vodafone.pt) (Quit: leaving)
[16:54:57] *** Quits: TAL (Mibbit@6961AF8E.D44E7E3B.79045CC5.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:54:59] *** Joins: q66 (q66@moz-46D931B3.range86-152.btcentralplus.com)
[16:55:40] <strcat> Yurume: well it's caused by this specific usage of trait objects
[16:55:43] <SiegeLord> rusti: let __log_level = 1;
[16:55:44] -rusti- ()
[16:56:00] <strcat> Yurume: trait objects are dynamic dispatch, so there are references to methods in vtables
[16:56:06] <strcat> LLVM is unable to optimize them out
[16:56:11] <strcat> devirtualization is a rare exception
[16:56:26] <strcat> so it pulls in a huge amount of code
[16:56:38] <strcat> it also increases the code size significantly even if you do use it all
[16:56:53] <Yurume> that's what I was wondering about, so LLVM is currently not able to perform devirtualization enough to strip this particular usage, right?
[16:57:07] <strcat> it can't be expected to perform that much devirtualization imo
[16:57:22] <strcat> Sufficiently Smart Compilers don't exist and that drives the design of rust elsewhere
[16:57:34] <strcat> bloated code size hurts performance a lot too
[16:57:39] <strcat> bloats the instruction cache
[16:57:45] <strcat> code has to be churning in and out from memory
[16:58:38] *** Quits: q66 (q66@moz-46D931B3.range86-152.btcentralplus.com) (Ping timeout)
[16:59:16] *** Joins: Ted_ (Ted@moz-27688FB8.cm-5-8c.dynamic.ziggo.nl)
[16:59:22] *** Parts: Ted_ (Ted@moz-27688FB8.cm-5-8c.dynamic.ziggo.nl) (Leaving)
[17:01:59] <Yurume> strcat, I was recently thinking about splitting IoFactory into mutually related set of smaller trait objects, though I might have been misguided
[17:02:13] <SiegeLord> Is 0.10 already frozen? Or will it be frozen at release second?
[17:02:20] <SiegeLord> *release moment
[17:02:38] <strcat> it's not tagged yet
[17:02:45] <strcat> probably will change
[17:02:51] <SiegeLord> So it might get the privacy change
[17:02:59] <strcat> Yurume: I don't think smaller trait objects will solve it
[17:03:09] <SiegeLord> The release candidate was made a tiny bit before that landed, I thought
[17:03:17] *** Joins: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP)
[17:03:18] *** ChanServ sets mode: +o jdm
[17:03:18] <strcat> if rust wants to play in the C/C++ sandbox, pay for what you use is the name of the game
[17:03:27] <strcat> and atm it's not there
[17:03:31] *** Joins: ahunt (ahunt@moz-6D6D79D6.cable.virginm.net)
[17:03:33] *** Quits: kngl (Adium@moz-18BD1C.ipv4.evonet.be) (Ping timeout)
[17:03:36] <strcat> everyone pays a lot for unwinding, and everyone pays a lot of M:N threading
[17:03:39] *** Joins: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com)
[17:04:05] <strcat> especially in compile-time
[17:04:30] <strcat> (which some people care a lot about - like Go)
[17:04:56] *** Quits: marc_ (uid5324@moz-31ABA2C0.irccloud.com) (Quit: Connection closed for inactivity)
[17:05:05] <det> M:N threading cost is only for IO ?
[17:05:17] *** Quits: rootnode (rootnode@moz-EE68AA20.pools.arcor-ip.net) (Ping timeout)
[17:05:19] *** Quits: evanm (evanm@636AC086.5999CED5.71743E61.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[17:05:35] <strcat> det: I/O and any concurrency stuff
[17:05:41] <strcat> det: there's dynamic dispatch on mutex methods, etc.
[17:05:41] <Yurume> strcat, my expectation was that various parts of libnative do not share common dependencies (e.g. fs ops do not depend on net ops afaik) so it can get rid of some burdens
[17:05:50] <Yurume> though I should test that first
[17:06:07] <strcat> imo the default should be static dispatch to libnative
[17:06:17] <strcat> if you link against libgreen, switch to dynamic dispatch
[17:06:26] <strcat> I don't think trait objects work
[17:06:32] <strcat> never going to be competitive with C that way
[17:06:32] *** Quits: autra (augustin@A14DAE84.7F753DD1.EE2CA32B.IP) (Ping timeout)
[17:06:37] *** Joins: japaric (japaric@32EABCAF.E00EBC6F.F29ED47E.IP)
[17:06:44] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[17:07:06] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[17:07:10] *** Quits: japaric_ (japaric@2FEED3C6.68214967.A936879B.IP) (Ping timeout)
[17:07:52] *** Quits: eddyb (eddy@F8B50789.F33C1089.FB866788.IP) (Ping timeout)
[17:09:04] *** Quits: espadrine (Thunderbir@moz-9BC91D35.w92-128.abo.wanadoo.fr) (Quit: espadrine)
[17:09:13] <det> strcat, have you written anywhere about the problems with trait objects and stack unwinding ?
[17:09:16] *** Parts: bollu (bollu@moz-AF1E4A33.clients.kiwiirc.com) ()
[17:09:18] <strcat> det: no
[17:09:53] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Ping timeout)
[17:09:55] *** Joins: rootnode (rootnode@moz-5B1AE0C8.pools.arcor-ip.net)
[17:10:19] <strcat> http://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions it's a widely known issue though (the latter)
[17:10:21] *** Quits: IanCormac84 (Hakim2@38FB8D31.2A8D8854.67DFF8B4.IP) (Ping timeout)
[17:10:21] *** Quits: Kxepal (Miranda@moz-5BF1FD2C.pppoe.mtu-net.ru) (Ping timeout)
[17:10:23] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[17:10:44] <strcat> exceptions add a lot of code bloat, although nothing in the non-exceptional path
[17:10:46] *** Joins: DAddYE (DAddYE@moz-61EB081B.hfc.comcastbusiness.net)
[17:10:53] *** Joins: eddyb (eddy@F8B50789.F33C1089.FB866788.IP)
[17:11:00] <strcat> but the other problem is that they cause control flow to be much more complicated
[17:11:18] <strcat> they make many functions impure, compared to using abort
[17:11:37] *** Joins: IanCormac84 (Hakim2@38FB8D31.2A8D8854.67DFF8B4.IP)
[17:11:50] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (No route to host)
[17:11:51] <strcat> and the extra control flow prevents many optimizations or reorganizations of the code that would lead to optimizations
[17:11:51] <benh> "The spawn function has a very simple type signature: fn spawn(f: proc()). Because it accepts only owned closures, and owned closures contain only owned data, " <- is 'proc' pronounced 'owned closure' still or should that be updated?
[17:11:54] *** Joins: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca)
[17:11:59] <strcat> bounds checks with abort can be more easily optimized out
[17:12:12] <strcat> because llvm has an easier time fiddling around with the loop
[17:12:21] <farcaller> am I right that it's impossible to implement memset in rust itself?
[17:12:26] <cmr> farcaller: no.
[17:12:26] <det> Isnt a trait object pretty much equivalent to a C++ class implementing virtual functions, except the vtable pointer not being stored in the object
[17:12:27] <strcat> farcaller: no
[17:12:45] <cmr> farcaller: you can use unsafe code, and `extern "C"`
[17:12:47] <farcaller> cmr, strcat: it generates the assembly that recursively calls to itself
[17:12:50] <strcat> det: it's (object_ptr, vtable_ptr) where the vtable is [drop_glue, method, method2, ...]
[17:12:51] <SiegeLord> Will 'priv' ever cease to be a keyword?
[17:13:18] <det> strcat, that seems like a small win over C++
[17:13:27] <benh> SiegeLord: https://github.com/mozilla/rust/issues/8122 seems to be up for debate
[17:13:38] <det> where the vtable has an indirection, but otherwise equivalent
[17:13:39] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Connection reset by peer)
[17:13:54] <strcat> det: the problem here is that LLVM sees all this pointers in vtables
[17:14:08] <strcat> it sees trait objects created from them
[17:14:13] <benh> https://github.com/rust-lang/rfcs/pull/26 rather, so "yes"
[17:14:16] *** Joins: Kxepal (Miranda@moz-B69B305D.pppoe.mtu-net.ru)
[17:14:20] <cmr> farcaller: oh, lol. we might need to expose nobuiltin
[17:14:20] <strcat> but it would be impossible to track them throughout the code
[17:14:23] <farcaller> cmr, strcat: something like this: https://gist.github.com/farcaller/bed4b50d4e1e89850a06
[17:14:41] <strcat> farcaller: https://github.com/thestinger/rust-core#freestanding-usage
[17:14:43] <strcat> it's covered there
[17:14:55] <strcat> cmr: meh it's still a good optimization
[17:15:03] <strcat> you don't really want to turn off optimizing to memset loops
[17:15:04] <det> strcat, isnt this a classic pay for what you use situation though? Rust would only generate the vtable for types that get bound to a trait object somewhere ?
[17:15:30] <strcat> det: yes, but I am talking about the stdlib using trait objects
[17:15:36] <strcat> det: not them existing
[17:15:38] <det> ahh
[17:15:55] <strcat> det: a rust task can be 1:1 or M:N scheduled
[17:15:58] <strcat> this is a dynamic choice
[17:16:11] <strcat> depending on that, it needs to call entirely different methods
[17:16:18] <farcaller> strcat: well, that one needs __aeabi_memset
[17:16:21] <det> Oh, I see
[17:16:32] <strcat> for concurrency (mutexes, etc.), I/O, or anything else that uses a syscall that would block
[17:16:55] <farcaller> strcat: and if I provide it with one, then rust's memset will call aeabi_memset and vice versa
[17:17:23] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[17:17:26] <farcaller> strcat: or "-passes inline" thing somehow fixes that?
[17:17:27] <strcat> farcaller: it's explained in that section in rust-core's readme
[17:17:28] <strcat> the solution
[17:17:30] <strcat> farcaller: yes
[17:17:33] <strcat> see the linked bug
[17:17:38] <farcaller> ah
[17:17:41] <strcat> it's caused by rust defining extern "C" functions with 2 layers
[17:17:47] <strcat> a C ABI wrapper an internal rust ABI function
[17:17:56] <strcat> LLVM is smart enough to not compile memset to a call to itself
[17:18:10] <strcat> but rust is defining an inner and outer memset
[17:18:17] <strcat> and it compiles the inner one to a call to the outer one
[17:18:25] <strcat> running -inline *alone* on a separate crate fixes it
[17:18:42] *** Joins: andrew-d_w (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[17:18:44] <strcat> otherwise it weaves in inlining with the other passes
[17:19:07] *** Quits: TinFox (TinFox@F3D0A69D.9F4E79F1.F7512391.IP) (Quit: No Ping reply in 180 seconds.)
[17:19:19] *** Joins: TinFox (TinFox@F3D0A69D.9F4E79F1.F7512391.IP)
[17:19:20] *** Quits: radford (Adium@moz-A69E09BD.warp2biz.com) (Ping timeout)
[17:19:27] *** Joins: radford (Adium@moz-A69E09BD.warp2biz.com)
[17:19:29] *** Joins: azita (Azita@moz-62518563.mtv2.mozilla.com)
[17:19:34] <farcaller> is there any simple way to disable all inlining?
[17:20:25] <strcat> farcaller: you control the inline threshold
[17:20:32] <strcat> farcaller: you don't want to fully disable it... the code will get bigger
[17:20:34] *** Joins: meyer (meyer@moz-A9CF56E4.hsd1.ca.comcast.net)
[17:20:47] <strcat> just drop the threshold down to where it stops making code bigger, but only smaller
[17:20:48] *** Joins: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[17:20:50] <farcaller> strcat: gdb'ing the binary gets harder
[17:20:54] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[17:20:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:21:02] <strcat> farcaller: LLVM doesn't support debugging with optimizations on at all
[17:21:09] <strcat> all of the debug info will be wrong
[17:21:30] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[17:21:36] <farcaller> strcat: yes, that's why I'm debugging an assembler listing, but having the ability to break on func boundaries would be awesome
[17:22:35] <strcat> farcaller: well you can specify optimization passes yourself but there's no -Z no-inline
[17:22:44] <farcaller> I see, thanks
[17:23:59] *** Quits: Kynes (Kynes@moz-3DC6C6E7.mit.edu) (Quit: Leaving)
[17:26:12] *** Quits: IanCormac84 (Hakim2@38FB8D31.2A8D8854.67DFF8B4.IP) (Quit: Leaving.)
[17:28:48] *** Joins: alexandp (weBeThread@BCD2EF9E.335C641C.D3B5A672.IP)
[17:29:52] *** Quits: Sorella (quildreen@AA4589ED.97245BEB.1ED99692.IP) (Ping timeout)
[17:30:54] *** Joins: brson (brson@moz-62518563.mtv2.mozilla.com)
[17:30:54] *** ChanServ sets mode: +ao brson brson
[17:31:09] *** Joins: Kynes (Kynes@moz-3DC6C6E7.mit.edu)
[17:31:21] *** Joins: alonlevy (alon@ED4E6C42.4C7F9E23.C34CC6C5.IP)
[17:31:36] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[17:31:43] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[17:32:10] *** Joins: dpc (Mibbit@3CA2DD5F.FAD414BA.D74CC41D.IP)
[17:32:16] <dpc> Good morning.
[17:32:18] <dpc> error: failed to find an implementation of trait ai::Actor for ~ai::Actor:Send
[17:32:22] <dpc> What is this about?
[17:32:47] *** Joins: janra (Janus@1CDC5701.A48867D7.52E4E107.IP)
[17:32:52] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[17:32:53] *** Quits: radford (Adium@moz-A69E09BD.warp2biz.com) (Ping timeout)
[17:33:54] *** Joins: evanm (evanm@636AC086.5999CED5.71743E61.IP)
[17:33:59] <benh> Boxed trait objects don't technically implement the trait in question
[17:34:17] <benh> because you can't use a trait object type in functions with Self-type arguments
[17:34:18] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[17:34:46] <dpc> I don't understand. :/
[17:34:54] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[17:35:01] <sfackler> dpc: ~Foo doesn't implement Foo
[17:35:09] <dpc> What does then?
[17:35:22] <sfackler> stuff that implements it?
[17:35:27] <sfackler> impl Foo for int { ... }
[17:35:36] <dpc> *ptr ...
[17:35:44] <benh> you can call the methods on a ~Foo value, it just doesn't implement that trait I guess
[17:35:57] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[17:37:06] <dpc> I got it! It works. Muahahaha....
[17:37:33] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[17:37:44] <SiegeLord> acrichto: Will the struct privacy switch make it into 0.10?
[17:38:04] *** Joins: japaric_ (japaric@350B7307.551A521E.212E9B57.IP)
[17:38:11] <acrichto> SiegeLord: I don't think so, I was hoping to keep it out (tuples haven't landed yet)
[17:38:19] *** Quits: japaric (japaric@32EABCAF.E00EBC6F.F29ED47E.IP) (Connection reset by peer)
[17:38:22] <SiegeLord> Aha, I see
[17:38:28] <SiegeLord> That's good to know
[17:38:38] *** Joins: Savago (Savago@504D6CF1.5315C0D2.4C2245EF.IP)
[17:39:45] <geal> I made a small script to automate fixes following language development. Would someone like to test it? https://github.com/Geal/rustfix
[17:40:30] <geal> it's easy, just point me to your repo, if you need fixes for things like the #[...]; attribute syntax, the priv attribute, the extra crate removal, and I'll launch the script :)
[17:40:47] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[17:41:06] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[17:41:09] *** Joins: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP)
[17:41:22] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[17:41:26] *** Quits: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com) (Quit: Computer has gone to sleep.)
[17:41:38] <geal> otherwise, I can just select project on rust-ci and start batching the pull requests :p
[17:42:57] *** Quits: lucian (lucian@303F9692.4304AE1E.CE5E78F6.IP) (Ping timeout)
[17:44:19] <hoverbear> geal: Feel free to use rust-rosetta, https://github.com/Hoverbear/rust-rosetta/ lots of simple code samples that tend to break. :)
[17:47:48] *** Quits: steveklabnik (steev@B1BA5385.27F34CF7.5670445F.IP) (NickServ (GHOST command used by steve))
[17:47:49] *** Joins: steveklabnik (steev@B1BA5385.27F34CF7.5670445F.IP)
[17:47:52] *** Quits: patpat (patpat@moz-21619C28.as13285.net) (Ping timeout)
[17:47:56] *** Joins: patpat (patpat@moz-21619C28.as13285.net)
[17:48:05] <geal> hoverbear: unfortunately, the few regexp I implemented for now do not apply to that repo. Good for you, I guess ^^
[17:48:17] *** Quits: steveklabnik (steev@B1BA5385.27F34CF7.5670445F.IP) (NickServ (GHOST command used by steve))
[17:48:18] <alan_andrade> You have a new contributor to rust-rosetta hoverbear :)
[17:48:29] *** Quits: alonlevy (alon@ED4E6C42.4C7F9E23.C34CC6C5.IP) (Ping timeout)
[17:48:36] *** Joins: steveklabnik (steve@moz-668C1CFE.public.wayport.net)
[17:49:00] <hoverbear> alan_andrade: =D! My favourite!
[17:49:07] <steveklabnik> hey all, quick question: I'm updating rust for rubyists to 0.10, and one of my examples was 'print everything in this vector'. but now, apparently, T doesn't have a default implementation for Show. what should I do?
[17:49:28] *** Joins: heftig (heftig@moz-D7C4C580.dip0.t-ipconnect.de)
[17:49:39] *** Quits: patpat (patpat@moz-21619C28.as13285.net) (Ping timeout)
[17:49:46] *** Joins: patpat (patpat@moz-21619C28.as13285.net)
[17:49:51] <steveklabnik> i guess the shorter question is "I want to println! a T. what do?"
[17:49:52] <steveklabnik> heh
[17:50:19] <Tari> bound it to T: Show
[17:50:24] <hoverbear> steveklabnik: println!("{}") doesn't work?
[17:50:24] <steveklabnik> ahhhhhhhhh
[17:50:30] <steveklabnik> Tari: duh. thanks. 
[17:50:42] *** Joins: rylev (rylev@D900DBD7.841B7A6.59369754.IP)
[17:50:56] <hoverbear> rusti: let thing = [1,2,3]; println!("{}", thing);
[17:50:58] -rusti- pastebinned 8 lines of output: http://ix.io/bqQ
[17:51:13] <hoverbear> rusti: let thing = [1,2,3]; println!("{:?}", thing);
[17:51:14] -rusti- [1, 2, 3]
[17:51:14] -rusti- ()
[17:51:22] <steveklabnik> hoverbear: in that case, rusti can know those are all ints do to inference
[17:51:55] <steveklabnik> fn<T>(n: T) { println!("{}", n); }
[17:52:00] <steveklabnik> is what i'm doing, basically
[17:52:05] *** Quits: rylev (rylev@D900DBD7.841B7A6.59369754.IP) (No route to host)
[17:52:21] *** Joins: rylev (rylev@D900DBD7.841B7A6.59369754.IP)
[17:52:34] <det> Does Option<~T> compile to a null pointer for the empty case in Rust ?
[17:52:44] <sfackler> det: yes
[17:52:51] *** Joins: stevekla1nik (steev@B1BA5385.27F34CF7.5670445F.IP)
[17:53:46] <det> Thanks
[17:54:09] *** Quits: rylev (rylev@D900DBD7.841B7A6.59369754.IP) (Ping timeout)
[17:54:14] *** Quits: Kynes (Kynes@moz-3DC6C6E7.mit.edu) (Quit: Leaving)
[17:54:46] <alan_andrade> I just visited SiegeLord website. You're hell of an artist! I'm impressed.
[17:55:08] <steveklabnik> of course, i can't read my own tutorial, and that example wasn't SUPPOSED to compile. heh
[17:55:09] *** Quits: hacker_s_ (hacker_sam@moz-23CA551A.kennesaw.edu) (Client exited)
[17:55:11] <SiegeLord> Eh... more like a jack of all trades, master of none :/
[17:56:12] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[17:57:14] *** Quits: azita (Azita@moz-62518563.mtv2.mozilla.com) (Quit: azita)
[17:58:50] *** Quits: brson (brson@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[17:59:02] <alan_andrade> I wonder id da Vinci though that as well
[17:59:09] <alan_andrade> *thought
[17:59:11] *** Quits: vikstrous (v@moz-1E061984.cpe.distributel.net) (Ping timeout)
[17:59:57] *** Quits: jackneill (jackneill@moz-782B761E.pool.digikabel.hu) (Ping timeout)
[18:00:02] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[18:00:42] *** Quits: evanm (evanm@636AC086.5999CED5.71743E61.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[18:00:56] *** Quits: dranov (dranov@46290EAA.42CAD9AB.FCAAE698.IP) (Ping timeout)
[18:01:18] *** Quits: patpat (patpat@moz-21619C28.as13285.net) (Ping timeout)
[18:01:24] *** Joins: brson (brson@moz-62518563.mtv2.mozilla.com)
[18:01:24] *** ChanServ sets mode: +ao brson brson
[18:01:32] *** Joins: patpat (patpat@moz-21619C28.as13285.net)
[18:03:20] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[18:03:58] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[18:04:05] *** Joins: jackneill (jackneill@moz-782B761E.pool.digikabel.hu)
[18:05:12] *** Joins: vikstrous (v@moz-1E061984.cpe.distributel.net)
[18:05:16] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Ping timeout)
[18:06:58] *** Joins: Florob (Florob@moz-39532932.de)
[18:07:19] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[18:07:36] *** Joins: guest2222 (guest2222@1EEF8F2.50A2C647.5A42B74E.IP)
[18:08:51] <guest2222> Is anyone able to build rustc on Windows using LLVM tooolchain yet?
[18:09:32] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.3)
[18:11:02] *** Joins: pcwalton (pcwalton@moz-C07D5168.p2p.sfo1.mozilla.com)
[18:11:02] *** ChanServ sets mode: +ao pcwalton pcwalton
[18:11:48] *** Quits: Sharp (Sharp@moz-633F3606.hsd1.ca.comcast.net) (Quit: Sharp)
[18:13:02] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[18:13:08] *** Joins: azita (Azita@moz-62518563.mtv2.mozilla.com)
[18:13:36] *** Quits: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net) (Ping timeout)
[18:13:46] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[18:14:28] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[18:15:23] *** Joins: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP)
[18:15:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[18:16:03] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[18:16:18] *** Joins: bollu (bollu@moz-AF1E4A33.clients.kiwiirc.com)
[18:16:45] <meyer> Is there any way to get a view of a HashMap as HashSet of the keys, to support difference / intersection and whatnot? I think such operations are frequently useful on maps in addition to sets.
[18:17:02] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[18:17:04] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:17:34] <cmr> meyer: .keys() gets you an iterator
[18:17:37] <steveklabnik> if anyone is curious: https://github.com/steveklabnik/rust_for_rubyists/commit/9e55c5702915d6f514c2ee493b174c891219a70c
[18:17:41] *** Quits: mgax (mgax@moz-B9399889.grep.ro) (Quit: WeeChat 0.3.8)
[18:17:46] <steveklabnik> pretty small diff. would have been even smaller without the println change
[18:18:11] <bollu> meyer:you can use map() and filter_map()  on an iterator if I remember correctly
[18:19:46] <Ms2ger> steveklabnik, would be better to use println! instead
[18:19:53] *** Joins: tikue (tkuehn@CB7FC854.FAD414BA.D74CC41D.IP)
[18:19:59] <meyer> cmr + bollu: Thanks. Implementation of the set operations on HashSet are pretty simple an with zip/filter_map (viewing source). I'll just reimplement, I guess.
[18:20:36] *** Joins: Sharp (Sharp@moz-3301C7AB.static-ip.telepacific.net)
[18:20:37] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[18:21:22] <det> Is "let ref x = y" the same as "let x = &y" ?
[18:21:37] <cmr> det: yes.
[18:22:57] *** Joins: p1start (rewi@moz-E7F3D014.org)
[18:23:26] <steveklabnik> Ms2ger: as I mentioned on the ML, println!("{}", foo) is really gross compared to println(foo);
[18:24:24] <Eridius> det: yes, but `ref` is more powerful, because you can use it while destructuring
[18:24:38] *** Joins: csherratt (csherratt@moz-7685819.cpe.teksavvy.com)
[18:24:49] *** Quits: csherratt (csherratt@moz-7685819.cpe.teksavvy.com) (Quit: csherratt)
[18:24:50] <Eridius> det: `let MyStruct{ ref x, ... } = someMyStructVal` will destructure the value, and turn x into a reference to the x field from the value
[18:24:51] <det> Eridius, that's why I had to use it, and i was wondering the implications
[18:24:54] <Eridius> you can't express that with &
[18:25:14] <Eridius> there's also `ref mut x` if you need a &mut
[18:25:28] <khodzha> Is it possible to convert owned vec to slice?
[18:25:44] <Tari> .as_slice()
[18:25:44] <cmr> khodzha: they are implicitly coerced, but you can do it explicitly with .as_slice()
[18:27:10] <khodzha> thanks
[18:27:59] *** Joins: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP)
[18:28:41] <khodzha> And how can I convert &str to ~str?
[18:28:57] <strcat> to_owned, but ofc that involves a memory allocation
[18:29:10] *** Parts: bollu (bollu@moz-AF1E4A33.clients.kiwiirc.com) ()
[18:29:14] *** Joins: dmsky (dmsky@moz-FF2573B1.pppoe.spdop.ru)
[18:29:24] *** Joins: bollu (bollu@moz-AF1E4A33.clients.kiwiirc.com)
[18:29:42] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[18:29:56] <khodzha> strcat: thank you
[18:30:09] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[18:30:13] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[18:31:00] *** Quits: dmsky (dmsky@moz-FF2573B1.pppoe.spdop.ru) (Ping timeout)
[18:31:36] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[18:31:44] *** Quits: GeneralMaximus (textual@FCE8EAE7.24AECFC8.8037CBEF.IP) (Ping timeout)
[18:32:31] *** Quits: p1start (rewi@moz-E7F3D014.org) (Ping timeout)
[18:33:02] *** Quits: steveklabnik (steve@moz-668C1CFE.public.wayport.net) (Ping timeout)
[18:33:03] <det> This borrow checker is cruel.
[18:33:22] <Ms2ger> It always is
[18:34:10] <cmr> det: memory safety is a pain, eh? :p
[18:34:36] <pcwalton> feel free to suggest lints for automated borrow-checker-satisfying refactorings…
[18:34:43] <det> Probably just learning pains :)
[18:34:44] <pcwalton> in general I don't find the borrow checker to be a problem anymore
[18:34:52] <pcwalton> but I have ingrained in me how to satisfy it
[18:34:55] <cmr> especially with ktt3ja's recent work.
[18:35:03] <det> I'm trying to write a simple binary tree.
[18:35:06] <pcwalton> yes, that was huge
[18:35:18] <cmr> det: writing data structures is probably the hardest thing to do in rust
[18:35:24] <cmr> just a heads up :p
[18:35:27] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[18:35:27] <pcwalton> well
[18:35:30] <pcwalton> uniquely owned ones
[18:35:33] <pcwalton> if you use reference counting it's easy
[18:35:38] <pcwalton> or unsafe code
[18:35:39] <cmr> that's true
[18:36:07] <pcwalton> writing safe data structures using only unique pointers, that's the hard one
[18:36:31] <det> The borrow checker doesn't like line 26: https://gist.github.com/anonymous/9940282
[18:37:04] <det> trying to implement the standard "double pointer" implementation of binary tree insertion
[18:37:08] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[18:37:53] <pcwalton> det: try to do it recursively
[18:38:02] <pcwalton> instead of using a loop
[18:38:09] <det> pcwalton, but no TCO
[18:38:22] <Tari> no *guaranteed* TCO
[18:38:25] <pcwalton> yes, that's an issue
[18:38:31] <Eridius> I'm pretty sure I've figured out how to get it to happen in a loop before, but it's tricky to make borrowck happy about it
[18:38:43] <pcwalton> by doing it recursively, the borrow checker will be free to assign different lifetimes for each recursive call
[18:39:00] <pcwalton> I wonder if we could make the borrow checker use SSA… or something
[18:39:02] <pcwalton> that would probably fix the issue
[18:39:15] *** Joins: phildawes (Mibbit@moz-6FFBC57E.cable.virginm.net)
[18:39:27] *** Quits: Florob (Florob@moz-39532932.de) (Max SendQ exceeded)
[18:39:31] <Eridius> although I don't actually understand why borrowck doesn't like that code
[18:39:38] <det> In C++ I would never write this using recursion even though compilers typically will do the right thing, I suspect this would be good practice in Rust as well.
[18:39:48] <cmr> I am eagerly awaiting when middle operates on a cfg.
[18:39:52] <Eridius> `ref mut node` should produce a reference with the same lifetime as option, no? And &mut node.right should again use that same lifetime?
[18:39:59] *** zz_kimundi is now known as kimundi
[18:40:01] <cmr> it will make emitting lifetime+invariant annotations to llvm super nice.
[18:40:01] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[18:40:06] *** Joins: dmsky (dmsky@moz-FF2573B1.pppoe.spdop.ru)
[18:40:13] <Eridius> oh right, the value is borrowed
[18:40:17] <Eridius> that's the issue
[18:40:17] <phildawes> Hello! Am I right in thinking rust can no longer return owned closures from a function?  e.g. so I can't write an iterator as a closure?
[18:40:29] *** Quits: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com) (Quit: Leaving.)
[18:40:38] <cmr> phildawes: you can return owned closures -- the type is written `proc()`
[18:40:39] *** Joins: Moodyen (bzlandfill@moz-4A445224.getinternet.no)
[18:40:41] <Eridius> phildawes: why would you write it as a closure? Write it as an Iterator
[18:40:45] <cmr> phildawes: but it's once-callable.
[18:40:59] <pcwalton> Eridius: ah yeah, if it used SSA and lifetimes then it would know that the borrowed option's lifetime goes dead, whereas if you use recursion it will be reborrowed
[18:41:01] <cmr> phildawes: you can't return stack closures (written `|args| -> rettype`)
[18:41:02] <pcwalton> sneaky
[18:41:05] <pcwalton> that's an interesting case
[18:41:15] <det> maybe I can just refactor this to satisfy the borrow checker
[18:41:15] <Eridius> phildawes: also if you want to make an arbitrary iterator out of a closure and a state value, check out std::iter::Unfold
[18:41:17] <Moodyen> Press F1 in Rust, net.connect 216.172.106.9:28065    Rust Canada . com - Where Canadians Play Rust when there is not hockey on the TV.   Server Settings: PVP: On Sleepers: Off Mods: Essentials Plugin Player Slots: 50  Owner: Filmgrip 
[18:41:19] <Moodyen> Press F1 in Rust, net.connect 216.172.106.9:28065    Rust Canada . com - Where Canadians Play Rust when there is not hockey on the TV.   Server Settings: PVP: On Sleepers: Off Mods: Essentials Plugin Player Slots: 50  Owner: Filmgrip 
[18:41:20] <Moodyen> Press F1 in Rust, net.connect 216.172.106.9:28065    Rust Canada . com - Where Canadians Play Rust when there is not hockey on the TV.   Server Settings: PVP: On Sleepers: Off Mods: Essentials Plugin Player Slots: 50  Owner: Filmgrip 
[18:41:20] <Moodyen> Press F1 in Rust, net.connect 216.172.106.9:28065    Rust Canada . com - Where Canadians Play Rust when there is not hockey on the TV.   Server Settings: PVP: On Sleepers: Off Mods: Essentials Plugin Player Slots: 50  Owner: Filmgrip 
[18:41:21] <Moodyen> Press F1 in Rust, net.connect 216.172.106.9:28065    Rust Canada . com - Where Canadians Play Rust when there is not hockey on the TV.   Server Settings: PVP: On Sleepers: Off Mods: Essentials Plugin Player Slots: 50  Owner: Filmgrip 
[18:41:26] *** Moodyen was kicked by jdm (jdm)
[18:41:26] *** cmr sets mode: +b *!bzlandfill@moz-4A445224.getinternet.no
[18:41:33] <cmr> heh
[18:41:36] <jdm> ^5
[18:41:40] <Eridius> pcwalton: borrowck's inability to tell that a borrow ends before the scope does drives me up the wall
[18:41:41] <pcwalton> not only in the wrong channel, but a spammer
[18:41:46] <pcwalton> Eridius: yeah, we're gonna fix it
[18:42:03] <cmr> that's https://github.com/mozilla/rust/issues/6393 right?
[18:42:16] <Eridius> phildawes: anyway, std::iter::Unfold::new() can let you basically create bespoke iterators without defining your own struct
[18:42:16] <jdm> I will give the person who fixes that bug the best high five of their life
[18:42:25] <jdm> This I promise today, in the presence of witnesses
[18:42:28] <phildawes> Eridius: I want to write an iterator, but is easier written as a closure (I'm searching through code and returning code-completion matches)
[18:42:41] * Ms2ger looks at it
[18:42:42] <phildawes> Eridius: What I really want is something like python yield
[18:42:43] <Ms2ger> ... nope
[18:42:58] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Input/output error)
[18:43:04] <strcat> phildawes: well, like C#'s yield
[18:43:13] <khodzha> Is it possible to bind variable in match _ wildcard?
[18:43:24] <o11c> phildawes: maybe do something crazy like make a proc returning a proc?
[18:43:38] <o11c> or more specifically, a tuple (T, Option<proc>)
[18:43:44] <strcat> use a trait object
[18:43:51] <Tari> khodzha: x @ _ => ...
[18:44:07] <pcwalton> gonna have most of the DST stuff for strings done today
[18:44:15] <pcwalton> the backwards incompatible bits anyway
[18:44:24] <pcwalton> then onward to vectors, which shouldn't be that tough I don't think
[18:44:53] <cmr> Tari: khodzha: or just use `x => ...`
[18:45:00] <Eridius> boy I love when borrowck says "cannot borrow ... as mutable more than once at a time", then points to the _exact same borrow_ when listing the "previous borrow"
[18:45:30] <strcat> Eridius: that can be correct
[18:45:31] *** Joins: jesse98 (jjones@6251EDC2.15651213.B46B86FA.IP)
[18:45:32] <strcat> if it's a loop
[18:45:33] <benh> don't mutable-borrow in a loop!
[18:45:47] <strcat> loop { xs.push(&mut x) }
[18:46:04] <Eridius> it's a very hard-to-decipher error
[18:46:06] <Tari> cmr: I suppose that's a bit nicer, heh. My reflex is _ as wildcard for some reason
[18:46:08] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:46:31] <strcat> rusti: let mut x = 5; let mut xs = Vec::new(); loop { xs.push(&mut x) }
[18:46:40] -rusti- pastebinned 8 lines of output: http://ix.io/bqZ
[18:46:52] <strcat> rusti: let mut x = 5; let mut xs = Vec::new(); loop { xs.push(&mut x) } 2
[18:46:56] -rusti- pastebinned 8 lines of output: http://ix.io/bqZ
[18:46:58] <det> The recursive implementation indeed works.
[18:47:00] <strcat> rusti: let mut x = 5; let mut xs = Vec::new(); while true { xs.push(&mut x) }
[18:47:05] -rusti- pastebinned 13 lines of output: http://ix.io/br0
[18:47:29] <strcat> luckily the compiler is too dumb to realize while true never ends
[18:47:30] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[18:47:34] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:47:39] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[18:47:53] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[18:47:56] <pcwalton> Java's compiler is smart enough to know that :)
[18:47:58] <pcwalton> but only true
[18:48:01] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[18:48:03] <bollu> strcat: isn't that why loop {} exists?
[18:48:04] <pcwalton> 0 == 0 doesn't work
[18:48:10] <strcat> bollu: it would be easy to teach it
[18:48:12] <strcat> it's just a hoke
[18:48:14] <strcat> joke *
[18:48:24] <strcat> because there it's hitting a type inference error from !
[18:48:24] <pcwalton> that's the main reason why loop {} exists, it's cleaner than special casing booleans like Java does IMO
[18:48:33] <Eridius> pcwalton: we already fold constant expressions that evaluate into booleans when dead-code-stripping `if constant-that-is-false { ... }`, right? Theoretically we could do the same for while
[18:48:43] <benh> rusti: while false {}
[18:48:44] <pcwalton> Eridius: well, that's a trans optimization
[18:48:44] *** Joins: awidegreen (awidegreen@8A668854.BEF1EF69.8633E8B5.IP)
[18:48:45] -rusti- ()
[18:48:47] <pcwalton> it's not part of the language semantics
[18:48:49] <Eridius> ah, fair enough
[18:48:51] <strcat> rusti: while true {}
[18:48:54] <cmr> geal: thanks for the hgl fixes!
[18:48:54] <pcwalton> i.e. it wouldn't be spec'd if we had a spec
[18:48:57] -rusti- <anon>:11:9: 11:22 warning: denote infinite loops with loop { ... }, #[warn(while_true)] on by default
[18:48:57] -rusti- <anon>:11         while true {}
[18:48:57] -rusti-                   ^~~~~~~~~~~~~
[18:48:57] -rusti- playpen: timeout triggered!
[18:49:00] <strcat> rusti: loop {} // error!
[18:49:02] -rusti- pastebinned 8 lines of output: http://ix.io/bqZ
[18:49:09] <pcwalton> the Java spec actually has the bool thing
[18:49:09] <geal> cmr: you're welcome :) I hope it did not bother you
[18:49:10] <benh> rusti: let mut x = 0; while x < 5 { x += 1 }
[18:49:11] <pcwalton> in gory detail
[18:49:11] -rusti- ()
[18:49:12] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[18:49:30] <det> Sorry to bikeshed syntax, but any reason match expressions and trailing return types are inconsistent with other parts of the language? -> instead of : for return types and match could be "match ... case ... {} case ... {}" for consistency with if (and less indendation!)
[18:50:01] <strcat> pcwalton: do you think it would be sane to output a different for loop expansion depending on whether it's an identifier or a non-identifier expression?
[18:50:10] <strcat> so it doesn't freeze the iterator for an lvalue iterator in the loop body
[18:50:16] <strcat> by borrowing it unnecessarily
[18:50:21] <pcwalton> strcat: hmm, that might be a good idea, it's bugged me
[18:50:33] <cmr> det: trailing return types is to be easier to read in type signatures, and I'm not sure match like that is possible to parse in LL(1)
[18:50:44] <cmr> det: (well, that first one, I think)
[18:50:48] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:50:57] <Eridius> det: `let x: uint` isn't a return type. It's a type annotation
[18:50:58] <strcat> pcwalton: I thought it would have to be in librustc for that but I can't think of a reason a hack like that wouldn't work ;p
[18:50:59] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[18:51:02] <Eridius> det: -> is a return type, not a type annotation
[18:51:04] <pcwalton> det: nobody brought that up, I think everyone wanted {} around the entire match because of C
[18:51:05] *** Quits: daschl (Adium@5E96199A.34ABE8B1.F7B46C9A.IP) (Quit: Leaving.)
[18:51:15] <Eridius> and I love not needing {} in single-line match expressions
[18:51:21] * strcat shudders thinking of `switch` in C/C++
[18:51:24] <strcat> such a horrible thing
[18:51:25] *** Joins: mgax (mgax@moz-B9399889.grep.ro)
[18:51:36] <det> braces on switch in C is really weird
[18:51:43] <pcwalton> I wanted match foo { 1: foo 2: bar 3: baz }
[18:51:44] <bollu> pcwalton: that's hilarious.
[18:51:45] <Eridius> also `pat => val` just looks better than `case pat: val`. I also don't see how it's any less consistent, it's not like we use `case` elsewhere
[18:51:52] <strcat> well without braces you can't declare new variables in it
[18:51:56] <det> most people dont indent inside them and its super ugly
[18:51:57] <strcat> which is really annoying
[18:51:57] <pcwalton> but it's ambiguous all over the place
[18:52:02] <Tobba> now for the really shitty part
[18:52:08] <Tobba> writing a PNG loader
[18:52:09] <strcat> det: I leave case at the same indent because it doesn't introduce a scope
[18:52:11] <Eridius> det: what's weird is that the C spec explicitly a) does not establish a scope for a case statement, and b) does not allow a variable declaration as the first line of a case statement
[18:52:11] <Tobba> SDL2 seems to work
[18:52:13] <strcat> I obviously indent the code inside
[18:52:16] <pcwalton> Tobba: we have one in Rust
[18:52:17] <pcwalton> rust-png
[18:52:21] <pcwalton> eddyb wrote it
[18:52:23] <strcat> Eridius: it's worse than not establishing a scope
[18:52:28] <Tobba> pcwalton: not public yet afaik
[18:52:30] <strcat> Eridius: you can have scopes overlapping multiple case statements
[18:52:32] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[18:52:32] <strcat> :D
[18:52:34] <strcat> and loops
[18:52:34] <Eridius> switch expr { case 1: int x = 3; } is invalid
[18:52:39] <strcat> you can do
[18:52:40] <eddyb> Tobba: kinda public
[18:52:43] <Tobba> theres the servo rust-png which exposes like 5 features
[18:52:43] <Eridius> but switch expr { case 1:; int x = 3; } is valid, and that's kind of hilarious
[18:52:44] <pcwalton> Tobba: ? https://github.com/mozilla-servo/rust-png
[18:52:47] <det> strcat, is that the only place in Rust where you dont indent {} ?
[18:52:48] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:52:49] <eddyb> Tobba: cmr made a copy of it with TEMP in its name
[18:52:49] <benh> what libpng the thing that uses setjmp/longjmp for error handling?
[18:52:51] <pcwalton> ah, ok, you wanted more than it provides
[18:52:53] <pcwalton> carry on then :)
[18:52:53] <Eridius> strcat: yes, and that's the secret behind Duff's Device. It's still bizarre
[18:52:54] <bollu> tobba: if you're using SDL, SDL_image can load PNG's
[18:52:56] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[18:53:00] <eddyb> pcwalton: I didn't make rust-png :P
[18:53:02] <Tobba> bollu: not found
[18:53:04] <Tobba> and I need text chunks
[18:53:04] *** Joins: rylev (rylev@B52D7D8B.63E16806.2DB0BBA1.IP)
[18:53:06] <strcat> switch foo { case 1: while (true) { case 3: puts("foo") } }
[18:53:08] <det> Eridius, ya switch in C sucks
[18:53:08] <strcat> or w/e
[18:53:13] <pcwalton> oh, for some reason I thought you did
[18:53:17] <Tobba> this makes things VERY tricky as literally no PNG loader ever supports these stupid things
[18:53:37] <Tobba> only really libpng does and its a pretty bad library
[18:53:41] <pcwalton> oh, it's just a wrapper around libpng anyway
[18:53:41] *** Parts: phildawes (Mibbit@moz-6FFBC57E.cable.virginm.net) ()
[18:53:41] <Eridius> write your own!
[18:53:43] <strcat> C strings are still the worst thing C cursed us with though
[18:53:45] <strcat> ;p
[18:54:00] <Eridius> strcat: at least it ain't pascal strings
[18:54:01] <pcwalton> hey, I think Apple still has the Pascal string extension in its compiler!
[18:54:02] <pcwalton> "\pfoo"
[18:54:07] <strcat> Eridius: pascal strings > C strings :(
[18:54:17] <Eridius> pcwalton: I would hope so. Who knows when you'll need to compile 30-year-old code!
[18:54:20] <pcwalton> wellll… if 256 bytes are enough for anybody ;)
[18:54:24] <Eridius> strcat: not if you need more than 255 bytes in your string
[18:54:25] <pcwalton> Eridius: like iTunes? :D
[18:54:29] <strcat> pcwalton: they'd have increased the size though ;p
[18:54:30] <det> Pretty sure "match ... case ... {} case ... {}" can be parsed in LL(1) and is a whole lot nicer, I cant try to implement it in Rust.
[18:54:31] <Eridius> pcwalton: iTunes is C :P
[18:54:32] <bollu> strcat: why not generalize? pascal > c :)
[18:54:38] <det> can*
[18:54:45] <pcwalton> Eridius: I wrote a visualizer plugin for it once and it wanted Pascal strings everywhere
[18:54:46] *** Quits: rylev (rylev@B52D7D8B.63E16806.2DB0BBA1.IP) (Ping timeout)
[18:54:48] <pcwalton> this was a long time ago though
[18:54:49] <Eridius> det: I disagree it's nicer. It only feels that way to you because you're used to C (I assume)
[18:55:04] <strcat> pcwalton: I dread not having slices when I write C ;s
[18:55:12] <strcat> having to stick \0 into the string to split, etc. is so fun
[18:55:17] <det> Eridius, My preference has nothing to do with the "case"
[18:55:23] <strcat> a common pattern I end up doing in C is...
[18:55:27] <pcwalton> strcat: yeah, it's the source of security vulns when you get it wrong too :(
[18:55:31] <Eridius> pcwalton: heh, not surprised. IIRC pascal strings were used back in the old Metrowerks days
[18:55:31] <strcat> char *split = strchr('a');
[18:55:41] <strcat> if (split) { *split = '\0'; ... }
[18:55:52] <Eridius> det: then why are you suggesting "case" if it's irrelevant?
[18:55:53] <strcat> and strtok_r.
[18:55:55] <det> Eridius, although languages like ML/SML also have a "case"-like token there
[18:56:15] <strcat> pcwalton: and those wonderful strtod/strtoull functions
[18:56:30] <det> Eridius, its necessary to eliminate the braces around switch and bring the syntax in line with if and function definitions
[18:56:40] <strcat> where you can't parse an integer without a) copying out the string b) clobbering the string
[18:56:52] <strcat> I know projects where they allocate a string on the stack with alloca for strtoull
[18:57:03] * strcat sighs
[18:57:03] <Eridius> det: oh huh, I didn't notice you removed the braces around match. That seems kind of confusing to me
[18:57:08] <pcwalton> heh
[18:57:14] <Eridius> my match shouldn't end merely because the next token didn't happen to be the `case` keyword
[18:57:28] <Eridius> strcat: <3 alloca ;)
[18:57:44] <pcwalton> goodbye -fomit-frame-pointer
[18:57:45] <benh> why do you need to clobber the string for strtoull?
[18:57:47] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[18:58:08] <strcat> gcc/clang don't check for alloca overflow
[18:58:10] <Eridius> pcwalton: hello dynamically-sized strings that are compatible with longjmp()
[18:58:11] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[18:58:12] *** ChanServ sets mode: +o tjc
[18:58:15] <strcat> benh: because it wants a \0-terminated string
[18:58:21] <strcat> so lets say you have a comma-separated list of ints
[18:58:23] <strcat> you want to parse them out
[18:58:26] <Eridius> tbh, alloca() in Rust would be rather handy for clients of rust-lua
[18:58:37] <strcat> you either have to replace the commas with \0 (that's how strtok/strtok_r work) or copy out strings
[18:58:58] <benh> doesn't it just parse up to the first non-numeric char?
[18:59:00] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:59:04] <pcwalton> Eridius: <kmc>
[18:59:04] <pcwalton> pcwalton: so it occurred to me that rust-cocoa could now provide syntax like  let string = objc![[NSString alloc] initWithCString: "Hello, world!"];
[18:59:12] <pcwalton> thought you might be interested
[18:59:13] <strcat> benh: yes, so in some cases you can do that
[18:59:21] <strcat> benh: but 'non-numeric' depends on locale
[18:59:23] <kmc> yeah Objective C++ is a thing, so why not Objective Rust? :D
[18:59:27] <benh> cripes
[18:59:32] *** Joins: csherratt (csherratt@moz-F23E0824.eng.wind.ca)
[18:59:38] <bollu> kmc: plz no
[18:59:39] <Ms2ger> Rust.NET
[18:59:50] <strcat> benh: anyway I hate it ;p
[18:59:56] <pcwalton> I think it'd be useful for Obj-C interop and the semantics wouldn't be too messed up
[18:59:58] <kmc> Visual Rust.NET 2008
[19:00:00] <benh> yeah, slices are clearly neater
[19:00:02] <det> Eridius, https://gist.github.com/anonymous/9940772 I find the last most readable by far
[19:00:02] <Eridius> pcwalton: hmmm. I should look at what you guys are doing with rust-cocoa
[19:00:03] <bollu> Ms2ger: .NET is a framework right?
[19:00:09] <pcwalton> Eridius: it's super minimal
[19:00:13] <pcwalton> at the moment
[19:00:14] <bollu> Ms2ger:so you *could* port it (theoretically)
[19:00:18] <Eridius> I want to use Rust in Cocoa ;) but I'm kind of ignoring that until 1.0
[19:00:20] <strcat> benh: https://github.com/thestinger/playpen/blob/master/playpen.c#L69 all the C code I write doing string handling ends up looking like that
[19:00:23] <kmc> I don't think the semantics are any more messed up than https://github.com/mozilla-servo/rust-cocoa/blob/master/base.rs#L57-L66
[19:00:24] <strcat> this is a simple case at least
[19:00:25] <strcat> ;)
[19:00:36] <benh> lgtm ;)
[19:00:39] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:00:43] <Eridius> det: whoa, that's some serious indentation you have there
[19:00:47] <strcat> benh: it's horrible ;p
[19:00:51] <det> Eridius, meh, tabs :)
[19:00:55] <Eridius> det: also, #1 is indented wrongly. The match should establish its own indentatino scope
[19:00:57] <benh> yep, looks like C string handling code all right
[19:00:58] <Eridius> *indentation
[19:01:02] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[19:01:06] <strcat> benh: strtok_r clobbers the commas with \0, then I clobber a space with strchr + writing
[19:01:10] * strcat sighs
[19:01:31] <strcat> https://github.com/thestinger/playpen/blob/master/playpen.c#L179 then you've got this beautiful thing
[19:01:33] <det> Eridius, Other people in this channel already said they dont indent switch, and in C/C++ is common to not indent them, indenting switch is really awful.
[19:01:45] <strcat> strtoull is useless because it handles -200 without an error
[19:01:53] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[19:01:53] <strcat> you have to use the signed one and check yourself
[19:02:00] <det> Eridius, but }\n} is also really awful
[19:02:02] <strcat> I don't want to even think about what happens if you set a locale
[19:02:04] <benh> haha, that seems boneheaded
[19:02:18] *** Joins: sigma (sigma@moz-6739E92E.range86-184.btcentralplus.com)
[19:02:23] <strcat> you should see the C++ mediawiki parser I wrote
[19:02:24] <strcat> ugh
[19:02:27] *** Joins: evanm (evanm@636AC086.5999CED5.71743E61.IP)
[19:02:32] <bollu> strcat: unfortunately, std::string has it's own problems
[19:02:36] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[19:02:42] <strcat> such as putting \0 at the end...
[19:02:52] <strcat> rust used to
[19:02:57] <eddyb> strcat: what character is 0x100? :P
[19:03:02] <strcat> eddyb: no idea
[19:03:05] <strcat> that's just getopt hell
[19:03:08] <Eridius> kmc: one of my worries with a rust-cocoa thing like this is different architectures use objc_msgSend() vs objc_msgSend_stret() at different times
[19:03:11] <strcat> you make up arbitrary values
[19:03:12] *** Quits: jackneill (jackneill@moz-782B761E.pool.digikabel.hu) (Quit: WeeChat 0.4.3)
[19:03:25] <strcat> eddyb: optarg is a global
[19:03:27] <kimundi> rusti: '\u0100'
[19:03:28] -rusti- Ā
[19:03:30] <strcat> getopt shuffles around argv in-place
[19:03:32] <bollu> strcat: your C code is neater than my C++ code
[19:03:45] *** Quits: hoverbear (hoverbear@726D908C.44E18222.E74D50F2.IP) (Quit: Taking a nap.)
[19:03:47] <Eridius> kmc: which means that either you need to target a particular architecture when calling methods that return structs, or you need to figure out how to get the glue code to determine when stret is appropriate by itself
[19:03:55] <strcat> bollu: this was C++ but I ported it to C because it uses so much POSIX stuff that it's hopeless
[19:03:57] <kmc> mm
[19:04:12] <kmc> I don't really know anything about ObjC :/
[19:04:13] <eddyb> strcat: wow opt sounds like fun /s
[19:04:14] <pcwalton> yes, objc_msgSend_stret was a pain
[19:04:22] <strcat> eddyb: it's kind of neat
[19:04:28] <bollu> strcat: were you the one who popularized snake_case for rust? :)
[19:04:31] <strcat> for example some things like gtk handle certain cli arguments
[19:04:34] <Eridius> kmc: objc_msgSend_stret() is used if the method returns a struct that uses the pointer-to-struct-as-first-arg function call behavior
[19:04:35] <pcwalton> bollu: no, that is my fault.
[19:04:39] <Tobba> ugh
[19:04:40] <pcwalton> or genius idea.
[19:04:41] <pcwalton> either one.
[19:04:42] <strcat> bollu: no
[19:04:44] <Tobba> these libpng bindings were never meant for windows
[19:04:47] <strcat> bollu: I just use the native language conventions
[19:04:52] <Tobba> and suffer from the mysterious ass-pulled linker errors of death
[19:05:01] <bollu> strcat: was just wondering
[19:05:03] <pcwalton> Eridius: kmc: we're going to have to declare the signatures of methods somewhere
[19:05:04] <pcwalton> which is just fine
[19:05:07] <strcat> I use all lowercase except for macros in C
[19:05:08] <bollu> strcat: do you use C99 or ANSI C ?
[19:05:09] <Tobba> i.e ld is silently erroring on something like usual and just printing the aftermath
[19:05:12] <strcat> including types
[19:05:17] <pcwalton> the naming conventions for Rust are from Python, btw
[19:05:18] <strcat> bollu: C89 isn't ansi C :P
[19:05:25] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:05:25] <strcat> bollu: they retracted the standard >:)
[19:05:32] <Eridius> pcwalton: I can't decide if it makes more sense to use something like objc![[NSString alloc] initWithString:foo] or to provide glue that lets you just say NSString::alloc().initWithString(foo)
[19:05:36] <bollu> strcat: what?!
[19:05:37] <benh> did they apologize for it too
[19:05:45] <strcat> bollu: when they release a new C standard, they retract the old one
[19:05:47] <strcat> ;p
[19:05:51] <pcwalton> Eridius: well, we need something for the named parameters
[19:05:54] <Eridius> I suppose the former could translate to the latter
[19:05:57] <strcat> you could even say that C89/C99 aren't standard C anymore if you wanted to be super pedantic
[19:06:05] <strcat> they might be ISO standards still but they aren't ANSI standards
[19:06:07] <Eridius> pcwalton: the classic way of translating -doFoo:bar: is as .doFoo_bar_()
[19:06:20] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[19:06:25] <pcwalton> macros could be less ugly though I think
[19:06:26] <bollu> strcat: ah xD I thought they were all "screw this, it's hopeless".
[19:06:27] <strcat> bollu: anyway I use c99/c++11
[19:06:30] <pcwalton> internally it could be that
[19:06:36] <pcwalton> but then you could write it with the objc![] notation
[19:06:36] <pcwalton> if you wanted
[19:06:40] <strcat> bollu: but c99 has nice initializers
[19:06:45] <bollu> strcat: agreed
[19:06:45] <Eridius> pcwalton: with various bridges allowing you to omit the final _, although I don't know if you can do that here because you can't just dynamically investigate the arguments to see if the caller wanted -doFoo or -doFoo:
[19:06:45] <strcat> so it's nicer for POSIX than C++ in some cases
[19:06:54] <Eridius> pcwalton: sure, and that may be the best approach
[19:06:55] <strcat> C++ can do {0, 1, "foo"} but...
[19:06:56] <bollu> strcat: arrays are so much nicer
[19:07:08] *** Quits: bpicolo (Adium@moz-B475EB64.static-ip.telepacific.net) (Quit: Leaving.)
[19:07:22] <strcat> POSIX often says that the order/layout of the struct is totally implementation defined
[19:07:26] <strcat> it can have extra fields
[19:07:27] <bollu> pcwalton: macros look intimidating in Rust (as a newbie)
[19:07:29] <det> Eridius, actually, the => isnt necessary in that paste's last example, was a mistake
[19:07:41] <strcat> so in C++ you'd write 'foo a = {}; a.b = 100; bar(a);'
[19:07:42] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[19:07:49] <strcat> where in C99 you can write it bar(temporary)
[19:07:55] <strcat> because of { .b = 100 }
[19:07:57] * strcat shrugs
[19:07:59] <Eridius> det: isn't it? You need some token to indicate that the pattern is done. { isn't sufficient because { can occur in patterns
[19:08:39] *** Joins: zenware (zenware@moz-89193695.hsd1.il.comcast.net)
[19:08:40] <det> Eridius, example pattern with { ?
[19:08:46] <bollu> strcat: thoughts on std::move?
[19:08:46] <Eridius> det: MyStruct { x }
[19:09:00] <det> Eridius, still think its fine
[19:09:13] *** Parts: Ms2ger (Ms2ger@B7B2FF50.C60A97A6.F9FB0584.IP) (Leaving)
[19:09:18] <strcat> bollu: well.... value semantics in C++ are nicer than not having value semantics
[19:09:25] <strcat> rust's value semantics >>>> C++
[19:09:29] <strcat> std::move is an ugly hack
[19:09:29] <bollu> strcat: xD fair enough
[19:09:38] <strcat> bollu: you know std::move is just a cast
[19:09:57] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[19:10:01] <strcat> it's static_cast<typename std::remove_reference<T>::type &&>(foo)
[19:10:06] *** Joins: q66 (q66@moz-46D931B3.range86-152.btcentralplus.com)
[19:10:10] <strcat> (std::move(foo))
[19:10:12] *** Quits: guest2222 (guest2222@1EEF8F2.50A2C647.5A42B74E.IP) (Ping timeout)
[19:10:12] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[19:10:23] <bollu> strcat: yep. I read the SO thread ( I was confused as to how it worked and why it was in the stdlib)
[19:10:25] *** Quits: zenware (zenware@moz-89193695.hsd1.il.comcast.net) (Quit: leaving)
[19:10:26] <Eridius> det: it's not. In values, Identifier { x: ... parses as a struct because it sees the identifier followed by a : after the {
[19:10:35] *** Quits: azita (Azita@moz-62518563.mtv2.mozilla.com) (Quit: azita)
[19:10:39] <Eridius> det: but in patterns, the : isn't present, and an identifier by itself is valid code
[19:10:47] <strcat> C++ calls the copy constructor by default
[19:10:55] <Eridius> so the parser can't tell if Foo { x } is a struct pattern, or an identifier Foo followed by the valid block { x }
[19:10:59] <strcat> so to add move ctors in a backwards compatible way, they had to essentially make it an overload of the copy ctor
[19:11:09] <strcat> where it can fall back to the copy ctor if there's no move ctor
[19:11:22] <strcat> so a move ctor is just a more specialized copy ctor for rvalue refs
[19:11:24] <strcat> such a pain
[19:11:26] <benh> Struct { fieldname, fieldname, fieldname } patterns are so nice too~
[19:11:43] <strcat> and they had to add programmable noexcept due to move ctors throwing
[19:11:46] *** Quits: brson (brson@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[19:11:47] <eddyb> I see det wasn't struck by our lookaheads yet :P
[19:11:50] <strcat> maybe it's useful elsewhere, but that's why they added it
[19:11:52] <bollu> strcat: hm, I didn't know it in detail
[19:12:01] <strcat> bollu: there's also std::move_if_noexcept
[19:12:06] <Eridius> eddyb: I was surprised when I realized how struct literals are detected ;)
[19:12:11] <strcat> std::vector uses it when it moves over the elements on a reallocation
[19:12:21] <Eridius> "oh, it looks ahead to see if there's a colon. That's.... nice"
[19:12:33] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[19:12:43] <eddyb> det: I tried to add shorthands for struct fields. guess how if a == b {x} {x} would parse :P
[19:12:43] <bollu> strcat: my god.
[19:12:51] <strcat> bollu: C++ can't use realloc
[19:12:51] <benh> It makes for some weird errors sometimes but I can't recall one now :(
[19:12:52] *** Joins: azita (Azita@moz-62518563.mtv2.mozilla.com)
[19:12:54] <det> Eridius, perhaps you are right then
[19:13:07] *** Quits: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: tobytailor)
[19:13:11] <strcat> bollu: it has to allocate a new memory allocation, and in C++98 it would copy over each element with the copy ctor
[19:13:17] <strcat> bollu: and the copy ctor can throw
[19:13:21] <strcat> so it has to do it as a transaction
[19:13:24] <strcat> to provide exception safety
[19:13:25] <det> eddyb, :<
[19:13:33] <bollu> strcat: yep, reading this - http://en.cppreference.com/w/cpp/utility/move_if_noexcept
[19:13:35] <strcat> if it throws, it has to free the new temporary storage
[19:13:40] <strcat> and leave the old one in place
[19:13:51] <bollu> strcat: do you approve of exceptions?
[19:13:51] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[19:13:56] <eddyb> det: it doesn't have a field shorthand
[19:13:56] <strcat> so that's why std::move_if_noexcept is there - if move could throw, then the old vector would be ruined
[19:13:56] *** Joins: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[19:14:00] <strcat> bollu: no
[19:14:02] <strcat> I hate unwinding
[19:14:04] <strcat> ;p
[19:14:09] * eddyb too
[19:14:14] <benh> C++>=11 is scary :(
[19:14:17] <bollu> strcat: yep.
[19:14:18] <eddyb> they make IR so smushy and ugly
[19:14:25] <strcat> benh: not having value semantics is scarier
[19:14:25] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[19:14:28] <eddyb> det: but you could make it so with a , after the first x (the change was never merged)
[19:14:31] <bollu> eddyb: ir?
[19:14:35] <strcat> proper resource types are a real pain in C++98
[19:14:38] <eddyb> LLVM IR
[19:14:40] *** vfetwnuncszu is now known as dcrewi
[19:14:41] <bollu> ah
[19:14:41] <det> benh, its way nicer than before
[19:14:42] <strcat> since you can't do anything with them
[19:15:04] *** Quits: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: tobytailor)
[19:15:08] <benh> well, you heapallocate them or you just don't move them around~
[19:15:08] <strcat> anything like a file or db connection shouldn't have a copy ctor (except in rare cases)
[19:15:19] <strcat> benh: heap allocate them and manage memory yourself? :p
[19:15:25] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[19:15:34] <bollu> strcat: seems reasonable enough
[19:15:34] <strcat> then you can leak the file *and* the db handle
[19:15:42] <strcat> and memory
[19:15:47] <benh> scoped_ptr!
[19:15:52] <benh> or uh unique!
[19:15:57] <benh> whatever! i don't remember them anymore!
[19:16:01] <strcat> benh: scoped_ptr/auto_ptr is broken
[19:16:03] <strcat> unique_ptr is C++11
[19:16:06] <strcat> uses move semantics
[19:16:09] <eddyb> auto_ptr LOLZ
[19:16:14] <eddyb> I remember that
[19:16:27] <eddyb> might as well have named it derp_ptr
[19:16:28] <benh> i was thinking whatever is in boost and isn't shared_ptr
[19:16:34] <strcat> benh: unique_ptr ;p
[19:16:36] <strcat> well
[19:16:38] <strcat> they have a bunch
[19:16:45] <eddyb> strcat: am I remembering right that it was useless?
[19:16:48] <benh> Probably meant unique_ptr then ;)
[19:17:00] <strcat> eddyb: well... it was as useful as __attribute__((cleanup(a)) is
[19:17:07] <eddyb> haha
[19:17:15] <bollu> strcat: smart pointers are brittle IMHO
[19:17:26] <strcat> bollu: I don't think so
[19:17:28] <eddyb> bollu: in a brittle language everything is brittle :P
[19:17:30] <strcat> you just usually don't want unique_ptr
[19:17:35] <strcat> just like you usually don't want ~ in rust
[19:17:44] <eddyb> (except when you do)
[19:17:49] <bollu> ^
[19:17:53] <kmc> what's attribute cleanup?
[19:17:55] <strcat> you usually don't have enormous objects
[19:17:58] <strcat> kmc: GNU C RAII
[19:18:04] <strcat> kmc: calls a function when the variable goes out of scope
[19:18:08] <benh> I suppose for most people the solution is to work on problems that can be solved in python or c# instead
[19:18:13] <strcat> kmc: used heavily in linux kernel-style code
[19:18:21] <eddyb> benh: so the solution is to give up?
[19:18:33] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Ping timeout)
[19:18:34] <strcat> kmc: for example...
[19:18:49] <strcat> void cleanup_free(void **ptr) { free(*ptr); }
[19:18:52] <benh> eddyb: not everybody needs to be a kernel engineer!
[19:18:56] <bollu> strcat: the annoying part of C is the lack of a destructor :/
[19:19:13] <benh> and not everybody could afford to invent rust :D
[19:19:15] <strcat> #define UNIQUE(T) __attribute__((cleanup(cleanup_free)) *T
[19:19:29] <strcat> UNIQUE(int) foo = malloc(sizeof(int));
[19:19:31] <eddyb> benh: with that mentality, my desktop uses 1GB of RAM without starting anything
[19:19:37] <strcat> kmc: GNU C 'smart pointer' ;p
[19:19:49] <bollu> eddyb: which OS?
[19:20:00] <strcat> kmc: although the cleanup attribute can only be attached to a variable, not a type - at least atm
[19:20:02] <benh> bollu: the hypothetical OS that I implement in python I guess
[19:20:08] <strcat> don't worry they'll probably add it to types eventually
[19:20:10] <strcat> ;p
[19:20:25] <strcat> kmc: when you hear people say that linux is coded in C, don't believe them
[19:20:28] <eddyb> python? more like SnailOS
[19:20:45] <bollu> strcat: it's code in a language that gets preprocessed to C?
[19:20:49] <bollu> coded*
[19:20:51] <strcat> GNU C
[19:20:52] <eddyb> bollu: GNU C
[19:20:56] <eddyb> which ain't the same thing
[19:20:57] <bollu> strcat: ah
[19:21:05] <eddyb> it's like ObjC
[19:21:09] <bollu> strcat: quick differences?
[19:21:16] <strcat> bollu: a whole pile of extensions
[19:21:20] <eddyb> but with __attribute__((...)) instead of [...]
[19:21:26] <strcat> __attribute__((cleanup(a)) being one of many
[19:21:38] <strcat> there are also GNU C closures
[19:21:38] <benh> wonder if there's space for shipping kernel modules written in rust yet
[19:21:43] <kmc> strcat: wow I didn't know about that feature
[19:21:45] <eddyb> strcat: pls no
[19:21:46] <strcat> they removed the last of the GNU C closures from the linux kernel
[19:21:50] <eddyb> haha
[19:21:53] <strcat> because I think clang refuses to implement it
[19:21:54] <kmc> although I do know about a lot of other GNU C hax in Linux
[19:21:54] *** Quits: evanm (evanm@636AC086.5999CED5.71743E61.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[19:21:56] <o11c> GNU C is C++ with worse syntax for political reasons
[19:22:01] <cmr> (for llvm-linux)
[19:22:08] <kmc> benh: I've only seen "hello world" Linux kernel modules but eventually...
[19:22:13] <kmc> I want to write a Linux rootkit in Rust :D
[19:22:19] <eddyb> strcat: and for good reason?
[19:22:26] <strcat> eddyb: executable stack...
[19:22:26] <eddyb> kmc: without using unsafe, amirite?
[19:22:31] <benh> kmc: i'm just afraid the sheer disapproval of actual kernel developers will incapacitate me over the internet if i try
[19:22:31] <eddyb> strcat: haha what?
[19:22:33] <kmc> haha
[19:22:38] <eddyb> strcat: trampolines on the stack?
[19:22:41] <strcat> eddyb: yes
[19:22:45] *** Joins: brendan (brendaneic@moz-62518563.mtv2.mozilla.com)
[19:22:47] <strcat> I think clang supports it though
[19:22:47] <eddyb> ugh
[19:22:49] <strcat> there's some part missing
[19:22:50] <eddyb> why?
[19:22:57] <strcat> eddyb: fast? *shrug*
[19:23:00] <bollu> strcat: what? "executable stack" ?
[19:23:01] <eddyb> I guess "no type system"
[19:23:03] <benh> though I guess with FUSE there's people writing file systems in perl and that sort of thing?
[19:23:04] <strcat> bollu: yes
[19:23:11] <strcat> bollu: if you use GNU closures you get an executable stack
[19:23:12] <eddyb> bollu: that was the norm :P
[19:23:27] <strcat> bollu: keep in mind that even 32-bit x86 doesn't have executable permissions on memory
[19:23:40] * strcat shrugs
[19:23:42] <eddyb> I remember the days where a stack buffer overflow let you have complete control over the process
[19:23:58] <strcat> eddyb: that's what JIT compilation is for
[19:24:01] <eddyb> (from stories that people told me)
[19:24:19] <strcat> eddyb: it still does anyway
[19:24:23] <strcat> return based programming
[19:24:41] <strcat> eddyb: https://en.wikipedia.org/wiki/Return-oriented_programming
[19:24:43] <eddyb> ROPes
[19:24:52] <strcat> https://en.wikipedia.org/wiki/Return-to-libc_attack
[19:24:54] <bollu> strcat: you have made me lose faith in programming
[19:25:08] <strcat> https://en.wikipedia.org/wiki/Heap_spraying here's the wonderful thing JIT compilers give you
[19:25:13] <eddyb> strcat: yeah, I know, I watch most CCC talks, ever since I found out about it (CCC that is)
[19:25:17] <strcat> just fill all the memory with long nop sleds leading to evil code
[19:25:22] <bollu> strcat: the whole "trampoline code" is crazy!
[19:25:28] <strcat> then cause some dangling function pointer to be derefed
[19:25:34] <eddyb> bollu: it's not when it's not on the stack :P
[19:25:52] <eddyb> strcat: oh dear I remember a specific ActionScript heap spray
[19:26:01] <eddyb> strcat: that abused the precise layout of objects in memory
[19:26:28] <bollu> eddyb: you take the address of a function, which GNU C figures out at *run time* .
[19:26:36] <bollu> what the hell? that is just nuts
[19:27:02] <strcat> bollu: look at JIT compilers though ;s
[19:27:12] <strcat> dynamically creating machine code on the heap
[19:27:20] <strcat> what could go wrong
[19:27:36] <eddyb> https://en.wikipedia.org/wiki/JIT_spraying
[19:27:40] <bollu> strcat: they're a pretty well known technique right? :)
[19:27:51] <strcat> bollu: sure, also well known as being bad for security
[19:28:09] <kmc> (32-bit x86 does have NX if you enable PAE, which has been supported by all processors since forever)
[19:28:22] <strcat> kmc: PAE has a cost though
[19:28:24] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:28:35] <strcat> and you might as well use long mode, been supported since essentially forever ;p
[19:28:38] <eddyb> kmc: for some recent value of "forever"?
[19:28:44] <strcat> eddyb: like 2000?
[19:28:48] *** Joins: bpicolo (Adium@moz-B475EB64.static-ip.telepacific.net)
[19:28:59] <kmc> there are recent-ish 32-bit-only chips (Atom) but I think they have PAE
[19:29:07] <strcat> kmc: atom is a scam though
[19:29:07] <kmc> (not current Atom I mean, but within the past few years)
[19:29:13] <kmc> well whatever, they exist :P
[19:29:30] <kmc> JIT spraying takes advantage of the x86 variable length instruction encoding in a basically hilarious way
[19:29:40] *** Joins: brson (brson@moz-62518563.mtv2.mozilla.com)
[19:29:40] *** ChanServ sets mode: +ao brson brson
[19:29:47] <kmc> maybe i can promote another one of my blog posts http://mainisusuallyafunction.blogspot.com/2012/11/attacking-hardened-linux-systems-with.html
[19:29:58] *** Quits: alexandp (weBeThread@BCD2EF9E.335C641C.D3B5A672.IP) (Ping timeout)
[19:30:01] <eddyb> kmc: CC padding for debugging
[19:30:19] <eddyb> kmc: heh, as long as it's interesting ;)
[19:30:28] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:30:47] <eddyb> strcat: haha look at this, BPF =))
[19:30:51] <strcat> sure
[19:30:56] <strcat> the JIT isn't enabled by default though
[19:31:00] <cmr> I'm writing a jit in the upcoming weeks :\
[19:31:03] <strcat> cause it's probably a bad idea
[19:31:11] <cmr> libjit and llvm are too principled for what I want to be doing
[19:31:15] <eddyb> cmr: for what?
[19:31:28] <cmr> (rewriting programs in-place, with nop padding )
[19:31:30] <eddyb> (JIT is fun once you get a clean API going)
[19:31:39] <cmr> eddyb: corewars jit
[19:31:46] <eddyb> core or code?
[19:31:54] <cmr> core.
[19:31:57] <cmr> it's a game.
[19:32:01] * eddyb looks it up
[19:32:04] <cmr> an old game, but a game.
[19:32:08] <bollu> eddyb: old school AFAIK.
[19:32:10] <cmr> I've pointed you at it before :p
[19:32:14] <eddyb> aah that one
[19:32:30] <eddyb> cmr: I was hoping for something less... eighties :P
[19:32:31] <bollu> you have to write programs that rewrite another player's memory if I remember correctly.
[19:32:44] <bollu> cmr: you were around during that time?
[19:33:12] <cmr> bollu: no
[19:33:44] <bollu> is it still around? it seems fun!
[19:33:53] <cmr> there's a small community.
[19:33:57] <YourBestFriend> rusti: fn test(x: u8 = 7) {}
[19:33:58] -rusti- <anon>:11:23: 11:24 error: expected `,` but found `=`
[19:33:58] -rusti- <anon>:11         fn test(x: u8 = 7) {}
[19:33:58] -rusti-                                 ^
[19:33:58] -rusti- playpen: application terminated with error code 101
[19:34:42] <YourBestFriend> does rust not have default values?
[19:35:05] <cmr> no.
[19:35:13] <YourBestFriend> 0,4WHY not
[19:35:23] <det> Trying to refactor a bit, is the find_end function just impossible to write without resorting to recursion? https://gist.github.com/anonymous/9941441
[19:35:25] <bpicolo> Something I desire as well hah
[19:35:32] <strcat> YourBestFriend: other ways to skin a cat
[19:35:34] <cmr> YourBestFriend:  
[19:35:40] <bpicolo> YourBestFriend you can implement Default but you still have to call it
[19:35:42] <bpicolo> =/
[19:35:49] <cmr> YourBestFriend: https://github.com/mozilla/rust/issues/6973
[19:35:53] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[19:35:56] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:35:59] <cmr> (stupid wifi is crapping itself)
[19:36:01] <strcat> bpicolo: Default isn't really related to optional function parameters
[19:36:19] <strcat> the alternative to optional function parameters is composable functions
[19:36:19] <benh> i guess it comes down to "no one could agree on a plan how to do it that was convincing enough to be implemented"
[19:36:20] <bpicolo> strcat Oh I thought he meant default struct values! My mistake
[19:36:57] * strcat will happily tirade against any optional parameters proposal, especially a positional rather than keyword-based one
[19:37:20] <bpicolo> Is there any plan for default constructors?
[19:37:26] <strcat> no
[19:37:32] <strcat> I doubt rust would ever get ctors
[19:37:36] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[19:37:37] <bpicolo> Gotcha ; )
[19:37:45] <bpicolo> So I'll stick to .default() then, hah
[19:37:48] <strcat> imo once closures are settled, we could have sugar for partial application
[19:37:53] <bollu> strcat: what's wrong with keyword based system?
[19:38:04] <strcat> bollu: I'm saying position-based is really bad
[19:38:07] <strcat> and keyboard based is less bad
[19:38:07] <eddyb> why is it "keyword" though?
[19:38:12] <strcat> keyword*
[19:38:12] <eddyb> keyboard lol
[19:38:16] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:38:24] <eddyb> "named arguments" makes more sense for me
[19:38:27] <o11c> I use keyboards for every langauge
[19:38:28] <strcat> eddyb: as in foo(a=2, c=10)
[19:38:30] <bollu> eddyb: shush, don't get pedantic ;)
[19:38:41] <strcat> eddyb: as opposed to it letting you omit them based on position
[19:38:48] <strcat> as in you can omit the last, the last 2, the last 3
[19:38:52] <eddyb> I know python names them kiwis
[19:38:52] <strcat> unreadable garbage imo
[19:38:54] <strcat> ;)
[19:39:03] <eddyb> strcat: no, I mean, why "keyword"?
[19:39:04] <bpicolo> python has the mess of both, yes, heh
[19:39:11] <eddyb> they are names, not keywords :/
[19:39:14] <eddyb> identifiers to be precise
[19:39:35] <bollu> does anyone have any idea how "heap feng shui" is done?
[19:40:13] * eddyb googles out of confuse and curiosity
[19:40:41] <bollu> eddyb: all I found was a small wikipedia article
[19:40:51] <eddyb> https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf
[19:41:01] <det> Is it possible to express that the return type of a reference has the same mutability as some input, for a function that doesn't need mutability itself?
[19:41:06] <bollu> eddyb: the only reference, I checked ;)
[19:41:08] <cmr> det: no.
[19:41:21] <det> thanks
[19:41:23] <bollu> strcat:  let zo = zo.get_or_default(42); <- this seems like a great implementation of optional args
[19:41:37] <cmr> bollu: it's not optoinal though
[19:41:40] <bollu> using Option<T>
[19:41:41] <cmr> you still have to specifiy None
[19:41:54] <bollu> cmr: ah. could that not be "
[19:41:58] <bollu> changed?
[19:42:12] <eddyb> why would it?
[19:42:18] <strcat> bollu: meh
[19:42:24] <bollu> eddyb: precisely for this use case?
[19:42:28] <strcat> composable APIs are nicer
[19:42:48] <eddyb> bollu: mmmaybe you mean to say that you wish trailing Option arguments could be omitted
[19:42:55] <bollu> eddyb: yeah
[19:42:55] <strcat> if you really reach the point where a few functions isn't enough, put the options in a type
[19:42:55] <eddyb> pretty sure Option is not a lang item atm ;)
[19:43:03] <eddyb> it's library code only
[19:43:04] <bollu> eddyb: but it was before right?
[19:43:06] <strcat> then you can reuse a set of options for multiple calls too
[19:43:13] <eddyb> bollu: do you have proof?
[19:43:19] <bollu> eddyb: zilch :)
[19:43:40] <cmr> it's going to need to be for Iterator though.
[19:44:35] <bollu> cmr: why?
[19:45:06] <eddyb> hah, I want to see someone try heap feng shui on a modern GC (SM/v8)
[19:45:40] *** Quits: andrew-d_w (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP) (Input/output error)
[19:45:44] <cmr> bollu: for Iterator to be a lang item, for integration with `for` loops, its return type (Option) also needs to be.
[19:46:02] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[19:46:09] <bollu> cmr: no, i mean, what do you gain?
[19:46:17] <bollu> with it being a lang item?
[19:46:22] <cmr> bollu: for loops not bbeing a hacky expansion?
[19:47:09] <benh> If Option is a lang item, can we forbid null ptrs for raw pointers/fn pointers and allow Option<raw/fn ptr> in ffi?
[19:47:21] <bollu> cmr: hmm. Now you've made me curious - how *are* they implemented?
[19:47:26] <cmr> benh: we already do.
[19:47:31] <cmr> bollu: go look :)
[19:47:36] <cmr> rustc --pretty=expanded
[19:47:38] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:47:41] <benh> we forbid raw null pointers?
[19:47:49] <bollu> cmr: I don't know where to look :(
[19:47:51] <bollu> cmr: ah
[19:47:58] *** Quits: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca) (Quit: canhtak)
[19:48:09] <cmr> rusti: std::mem::size_of::<Option<fn()>()
[19:48:10] -rusti- <anon>:11:41: 11:42 error: expected `,` but found `(`
[19:48:10] -rusti- <anon>:11         std::mem::size_of::<Option<fn()>()
[19:48:10] -rusti-                                                   ^
[19:48:10] -rusti- playpen: application terminated with error code 101
[19:48:11] *** Quits: brson (brson@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[19:48:15] <cmr> rusti: std::mem::size_of::<Option<fn()>>()
[19:48:16] -rusti- 8
[19:48:21] <cmr> benh: yes.
[19:48:24] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:48:27] <benh> rusti: std::mem::size_of::<Option<*()>>()
[19:48:28] -rusti- 16
[19:48:33] <cmr> benh: function pointers are non-nullable.
[19:48:36] <bollu> cmr: why the extra > ?
[19:48:41] <bollu> cmr: nvm I'm blind >_>
[19:49:01] *** Quits: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com) (Quit: Leaving.)
[19:49:21] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[19:49:23] <SiegeLord> What does it mean to forbid null raw pointers?
[19:50:04] <benh> I guess it is a somewhat questionable proposition what with pointer arithmetic being a thing :/
[19:50:44] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:50:45] <SiegeLord> If a C function returns a null raw pointer, where does the mistake lie?
[19:50:52] <benh> though going between null pointers and non-null pointers with arithmetic is undefined in C already
[19:51:05] <benh> SiegeLord: In the extern fn decl for not declaring the return type as Option<>
[19:51:20] <SiegeLord> Is that seriously what we have to do today?
[19:51:28] <benh> no, that's what I'm suggesting
[19:51:35] <cmr> Oh, raw pointers.
[19:51:36] <benh> I think it has been suggested before, though
[19:51:41] <SiegeLord> What is is_null() for then?
[19:51:43] <cmr> derp, I need to learn to read.
[19:51:48] <cmr> raw pointers are nullable.
[19:51:57] <cmr> see https://github.com/mozilla/rust/issues/10571
[19:52:03] <benh> cheers
[19:52:28] *** Joins: mye (mye@moz-476E65B2.swh.uni-giessen.de)
[19:52:55] *** Joins: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[19:53:22] <bollu> night all
[19:53:44] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[19:53:47] *** Quits: bollu (bollu@moz-AF1E4A33.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[19:53:53] *** Joins: rylev (rylev@moz-C6BCB695.cust.telecolumbus.net)
[19:55:16] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[19:55:16] *** ChanServ sets mode: +o pnkfelix
[19:55:37] *** Quits: rylev (rylev@moz-C6BCB695.cust.telecolumbus.net) (Ping timeout)
[19:57:02] *** Joins: claudiu_ (claudiu@CB447DD5.6B10AC3.E2F59BBC.IP)
[19:57:12] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[19:57:12] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[19:57:28] *** vfetwnuncszu is now known as dcrewi
[19:57:38] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[19:58:01] *** Quits: claudiu (claudiu@81B10C62.5F4BC945.49B2C1AE.IP) (Ping timeout)
[19:58:06] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[19:58:32] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:59:14] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[20:00:01] *** Quits: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP) (Input/output error)
[20:00:10] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:00:21] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[20:00:26] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:00:47] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[20:00:49] *** Joins: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[20:01:36] *** Quits: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP) (Input/output error)
[20:01:37] *** Quits: claudiu_ (claudiu@CB447DD5.6B10AC3.E2F59BBC.IP) (Connection reset by peer)
[20:01:40] *** Joins: claudiu (claudiu@81B10C62.5F4BC945.49B2C1AE.IP)
[20:01:57] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Connection reset by peer)
[20:01:59] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[20:03:25] *** Quits: claudiu (claudiu@81B10C62.5F4BC945.49B2C1AE.IP) (Ping timeout)
[20:03:39] <m-r-r> Hello
[20:04:01] *** Quits: skade (skade@B4A5FE21.505237C9.CAE22B62.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:04:03] *** Quits: sigma (sigma@moz-6739E92E.range86-184.btcentralplus.com) (Ping timeout)
[20:05:02] <m-r-r> I have a method with unused parameters, how can I deactivate the warnings ?
[20:05:03] *** Joins: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net)
[20:05:15] *** Quits: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net) (Quit: carllerche)
[20:05:25] <pnkfelix> m-r-r: you can put an underscore prefix on the names of the unused parameters.
[20:05:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[20:05:29] *** Joins: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net)
[20:06:06] <m-r-r> @pnkfelix: ok, i'm trying that ...
[20:06:09] <pnkfelix> m-r-r: (or you can disable the lint via the directive it gives you in the warning; such disabling can be applied to individual items, it need not be a global property change)
[20:07:06] <pnkfelix> m-r-r: i.e. `#[allow(unused-variable)] fn my_fun(x:int) -> int { 3 }`
[20:07:14] *** Joins: brson (brson@moz-62518563.mtv2.mozilla.com)
[20:07:14] *** ChanServ sets mode: +ao brson brson
[20:07:52] <strcat> rusti: Some(~())
[20:07:52] -rusti- None
[20:08:05] *** Quits: Kruppe (user@moz-253119B0.esg.uwaterloo.ca) (Ping timeout)
[20:08:26] <strcat> rusti: trait Foo {} struct Bar; impl Foo for Bar {} Some(~Bar as ~Foo)
[20:08:29] *** Quits: Jesin (Jesin@moz-3A2C5D36.washdc.fios.verizon.net) (Quit: Leaving)
[20:08:34] -rusti- pastebinned 8 lines of output: http://ix.io/br3
[20:08:45] <strcat> rusti: trait Foo {} struct Bar; impl Foo for Bar {} Some(~Bar as ~Foo).is_none()
[20:08:46] -rusti- false
[20:09:06] *** Quits: mceier (mceier@moz-C1591437.dynamic.chello.pl) (Ping timeout)
[20:09:24] <m-r-r> pnkfelix: i've added underscores, and it works fine. But my methods are in a trait. Does that means people who will use my trait will have to use the same parameter names ?
[20:09:37] <pnkfelix> m-r-r: no, they can pick their own names
[20:09:53] <m-r-r> pnkfelix: ok, thanks
[20:11:29] <strcat> I regret not fixing that bug before fixing it became controversial ;s
[20:12:51] *** Joins: autra (augustin@moz-BE76895F.fbx.proxad.net)
[20:13:23] <o11c> rusti: ~()
[20:13:24] -rusti- ()
[20:13:32] *** Quits: mawuli (mawuli@moz-781516AB.com.gh) (Client exited)
[20:14:09] <sfackler> strcat: what's the issue with returning 0x1 for zero sized allocations and checking for it in free?
[20:14:44] *** Quits: asmyers (quassel@3F39C117.9A737B8F.FAA4474F.IP) (Ping timeout)
[20:14:46] <strcat> sfackler: it adds a branch to every free (which is bad for stuff like arena allocators) and is something every allocator has to worry about themselves
[20:15:07] <sfackler> ah
[20:15:20] *** Quits: csherratt (csherratt@moz-F23E0824.eng.wind.ca) (Quit: csherratt)
[20:15:36] <o11c> either define alloc(0) to return NULL or define it as alloc(1)
[20:15:39] <strcat> considering how long this has been broken in rust (forever - it relied on implementation defined behaviour that broke when I tried musl)... it is not an obvious thing for every allocator implementation to deal with
[20:15:41] <o11c> that wway you only branch in alloc
[20:15:44] <strcat> o11c: it can't return null
[20:15:51] <strcat> rusti: Some(~())
[20:15:51] -rusti- None
[20:15:53] <strcat> it's broken
[20:16:04] <strcat> clamping to 1 would work, sure
[20:16:14] <strcat> ~Trait would now have to do an allocation for unit structs
[20:16:18] <strcat> imo that's a real use case that's hurt
[20:16:37] <strcat> and to me, this is far more important that sometimes not having to carry around a capacity field
[20:16:42] <o11c> in other words ... you *want* ~Trait to do no alloc?
[20:16:45] <strcat> (if you don't want to call shrink_to_fit())
[20:16:48] <whitequark> strcat: define it to always return the same canary?
[20:16:52] <strcat> o11c: it already does no allocation with zero-size types
[20:17:01] <eddyb> oh imagine ~Many with no allocation
[20:17:03] <whitequark> oh, right, 0x1 would essentially do that
[20:17:12] <strcat> whitequark: yeah but that means a branch on it every free
[20:17:31] *** Joins: jroweboy (jrowe7@1FDFE12E.D092120A.71765F8E.IP)
[20:17:32] <eddyb> whitequark: instead of branching on a constexpr
[20:17:40] <whitequark> strcat: just do & ~0x1 on the input pointer
[20:17:47] <pcwalton> sfackler: IMHO rust-phf is amazing and is worth a presentation or blog post if you ever get time
[20:17:54] <o11c> strcat: wait, what about putting the check in Option (well, every enum) ?
[20:17:55] *** Parts: jroweboy (jrowe7@1FDFE12E.D092120A.71765F8E.IP) ()
[20:17:55] <whitequark> strcat: free has to handle passed NULL already
[20:18:01] <pcwalton> it's a perfect (no pun intended) example of rust macro use to do something a LOT of programs need and is really irritating in C++
[20:18:05] <strcat> whitequark: free does, but not new allocators
[20:18:20] <strcat> like a simple bump allocator
[20:18:30] <whitequark> hmm
[20:18:32] *** Quits: sankha93 (sankha93@7061CD01.D6BD0D91.22D41759.IP) (Client exited)
[20:18:40] <whitequark> well, no free lunch, I guess
[20:18:41] <strcat> or an arena allocator
[20:18:50] <strcat> imo taking a size is pretty close to a free lunch...
[20:18:57] <o11c> rusti: ~() as *()
[20:18:58] -rusti- <anon>:11:9: 11:19 error: non-scalar cast: `~()` as `*()`
[20:18:58] -rusti- <anon>:11         ~() as *()
[20:18:59] -rusti-                   ^~~~~~~~~~
[20:18:59] -rusti- error: aborting due to previous error
[20:18:59] -rusti- playpen: application terminated with error code 101
[20:19:02] <strcat> + it makes allocators faster
[20:19:08] <o11c> hm
[20:19:09] *** Joins: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[20:19:10] <strcat> you immediately know which size class you have
[20:19:13] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[20:19:14] <whitequark> strcat: you mean passing size to free() ?
[20:19:21] <strcat> whitequark: yes
[20:19:23] <whitequark> interesting
[20:19:28] <eddyb> you remove an indirect pointer access in certain models
[20:19:32] <strcat> whitequark: C++ allocators do this, deallocate takes a size
[20:19:42] <eddyb> and maybe allow for smaller size classes
[20:19:43] <whitequark> sounds good
[20:20:14] <strcat> and apparently having the overloadable operator delete take a size is part of C++14
[20:20:24] <strcat> but that's optional so... not as incredibly helpful
[20:20:25] <o11c> strcat: so, ~() would be defined as NULL, but ~
[20:20:36] <o11c> but Some(~()) would be 0x1
[20:20:37] <eddyb> strcat: with a proper allocator shrink_to_fit could be noop most of the time though
[20:20:45] <eddyb> o11c: you can't really do that
[20:20:46] <benh> would the size-taking-free's malloc return a size or do you just pass the same size you passed to malloc and it figures out the rest?
[20:20:53] <o11c> eddyb: why not?
[20:20:54] <strcat> eddyb: if you consider an mremap call a noop
[20:21:27] *** Quits: brendan (brendaneic@moz-62518563.mtv2.mozilla.com) (Quit: brendan)
[20:21:34] <eddyb> strcat: with a proper allocator you'd always have a capacity  that is the maximum of the current size class
[20:21:35] <strcat> benh: it doesn't matter, since it's based on size classes
[20:21:49] <strcat> eddyb: pretty sure tcmalloc/jemalloc are proper allocators
[20:21:52] <strcat> and they don't
[20:21:56] <meyer> I have a bit of a design / architecture / idiomatic rust question. I'm working on a VCS, and have enum Change { CreateTree(Path), DeleteTree(Path), [...], ModifyBlob(Path, DiffID), ApplyChanges(Path, ChangesetID) }. The issue is that in different situations I want different ways of referencing other objects. So, the Changes will be serialized as written (with DiffID and ChangesetID), but whe
[20:21:57] <meyer> n building the changes, it is much more convenient to just have an owned pointer to the diff, and Vec<Change> instead of a ChangesetID. Then, after reading them, it'd make more sense to have Changes store pointers to a diff and other changeset in memory, with the lifetime from the datastore that I create after reading the repository metadata from the disk. Is there a good way to make a gener
[20:22:00] <meyer> ic Change?
[20:22:08] <eddyb> good job on those three lines :P
[20:22:09] <strcat> eddyb: I don't think you're going to have size classes for 200MiB, 500MiB, etc.
[20:22:16] <eddyb> strcat: hmm
[20:22:28] *** Quits: Ferreus (ferreus@moz-E036D928.lsn.wtnet.de) (Quit: WeeChat 0.4.4-dev)
[20:22:36] <eddyb> strcat: but does it at least make sense for smaller vectors?
[20:22:37] <strcat> eddyb: it's not really shrink_to_fit if it's not saving memory when it can...
[20:23:08] <eddyb> I'm not advocating wide-spread use of ~[T] btw
[20:23:20] *** Joins: Zolrath (Zolrath@moz-858414B5.dhcp.snlo.ca.charter.com)
[20:23:22] <eddyb> just making sure the AST doesn't feel the cost
[20:23:51] *** Quits: autra (augustin@moz-BE76895F.fbx.proxad.net) (Quit: by!)
[20:25:25] <sfackler> pcwalton: thanks :)
[20:25:46] *** Joins: mib_u4flkf (Mibbit@3E3094EC.34458CF2.CC1A2609.IP)
[20:25:57] *** Quits: andre (andre@CA528A4A.45A4338E.8EE27E6.IP) (Quit: leaving)
[20:26:46] *** Quits: qwerty_nor (Thunderbir@A5447B90.EDC74FC5.E19950A4.IP) (Ping timeout)
[20:27:30] *** Joins: claudiu (claudiu@moz-70F9251D.thefacebook.com)
[20:27:53] *** Joins: alkino_ (alkino@moz-18C36E4E.w92-151.abo.wanadoo.fr)
[20:28:05] <strcat> eddyb: it wants TinyPtrVector anyway
[20:28:09] <strcat> eddyb: and you will want shrink_to_fit
[20:28:13] <meyer> Actually, I guess there's no reason I can't just have two separate type parameters for DiffID and ChangesetID. That should work.
[20:28:31] <eddyb> strcat: what's TinyPtrVector?
[20:28:44] <strcat> eddyb: the 'old' vector representation, be rewritten as a lib
[20:28:51] <eddyb> ugh
[20:28:54] *** Joins: lkuper (lkuper@moz-AD4C50F5.dhcp-bl.indiana.edu)
[20:28:59] <eddyb> I don't really like the "old" representation
[20:29:07] <strcat> slow push, ptr aliasing issues
[20:29:12] <eddyb> strcat: maybe with a custom allocator
[20:29:13] <strcat> but it's compact for a recursive type
[20:29:27] *** Quits: Matthias247 (Miranda@moz-678B5E4A.hsi2.kabel-badenwuerttemberg.de) (Connection reset by peer)
[20:29:28] <eddyb> and trying to actually solve of its issues
[20:29:34] <eddyb> *solve some of its
[20:29:55] <strcat> they aren't being grown, are they?
[20:30:02] <pnkfelix> strcat: i'm trying to think of other solutions to the problem you posed in your latest email
[20:30:21] <strcat> pnkfelix: I can think of other problems :)
[20:30:26] <eddyb> <3
[20:30:46] <eddyb> strcat: push? hmm, no, so I guess that wouldn't be an issue
[20:30:52] <eddyb> we need benchmarks :/
[20:31:32] <pnkfelix> strcat: e.g. maintaining the invariant that in ~[T] or &[T], the length is zero iff ptr is null
[20:31:43] <eddyb> pnkfelix: pls no
[20:31:44] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[20:31:50] <pnkfelix> strcat: but that alone probably is not enough
[20:31:51] <eddyb> I want a non-null ptr for empty slices
[20:31:52] *** Quits: dschatzberg (dschatzber@moz-4CB3F0EE.bu.edu) (Input/output error)
[20:32:04] <pnkfelix> strcat: i was musing to niko some time ago that DST doesn't want just Sized/Unsized
[20:32:08] <strcat> pnkfelix: then you have to call shrink_to_fit in some cases
[20:32:12] <eddyb> why? Option<&[T]> & friends
[20:32:13] *** Quits: edwardw (edwardw@4112974A.B4358688.30F15291.IP) (Quit: Leaving...)
[20:32:14] *** Joins: mceier (mceier@moz-C1591437.dynamic.chello.pl)
[20:32:36] <strcat> pnkfelix: shrink_to_fit reallocs to the new size
[20:32:37] <pnkfelix> eddyb: ah right
[20:32:40] *** Quits: mib_u4flkf (Mibbit@3E3094EC.34458CF2.CC1A2609.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:32:52] <pnkfelix> eddyb: but the ptr is still conceptually null there
[20:32:59] <strcat> so if you represent 0-size allocations as null (which breaks the Option optimization), shrink_to_fit would produce a null ptr
[20:33:01] <pnkfelix> eddyb: i.e. the idea isn't that you'd ever *look* at the ptr
[20:33:08] <strcat> but what it really needs to do is return a sentinel
[20:33:10] <strcat> like 0x1
[20:33:19] <pnkfelix> eddyb: but rather that if you have 0 size, then there is never anything to free.
[20:33:24] <eddyb> sure
[20:33:30] <strcat> if the allocator has to check for a sentinel...
[20:33:37] <strcat> that's an added branch even when the length is known constantly
[20:33:44] <strcat> like ~(int, int, int, int)
[20:33:45] *** Quits: jmbto (jmbto@moz-B2BEB013.net) (Quit: WeeChat 0.4.1)
[20:33:56] <strcat> which is going to matter for a bump allocator / arena
[20:34:07] <carllerche> is there any way to do an alias when using? use i_am_a_super_long_lib as alib; or something?
[20:34:07] <strcat> or just little size class free lists
[20:34:20] <eddyb> carllerche: use x = y;
[20:34:31] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:34:37] * eddyb takes a look at https://github.com/cleeus/obstack
[20:34:52] *** Joins: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[20:35:00] *** Quits: bytbox (s@moz-E1E7FAC3.washdc.fios.verizon.net) (Ping timeout)
[20:35:01] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[20:35:08] <strcat> pnkfelix: anyway imo if someone wants Vec<T> -> ~[T] to be a no-op, solving Some(~()) differently without a perf hit becomes their problem ;)
[20:35:20] <strcat> because atm I have a branch fixing it as a *bug fix*
[20:35:22] <strcat> by using the length
[20:35:26] <strcat> and I don't see another way
[20:35:46] <strcat> beyond adding 'if ptr == &EMPTY as *mut T { return; }' to each
[20:35:53] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[20:36:08] *** Quits: mceier (mceier@moz-C1591437.dynamic.chello.pl) (Ping timeout)
[20:36:17] <pnkfelix> strcat: the DST variation that I was alluding to above
[20:36:35] <pnkfelix> strcat: was one where sizeof(~T) == 0 for a zero-sized T
[20:36:40] <eddyb> strcat: hmpf, I don't really get it from obstack's obtuse README :(
[20:36:47] <strcat> pnkfelix: ah
[20:36:54] <pnkfelix> strcat: but I'm sure that breaks all sorts of stuff
[20:36:55] <eddyb> pnkfelix: I thought of that
[20:37:01] <eddyb> it just ruins everything
[20:37:07] <strcat> pnkfelix: yeah, this null ptr representation already breaks stuff :)
[20:37:11] <strcat> and it breaks optimizations...
[20:37:15] <strcat> consider..
[20:37:30] <strcat> fn foo(x: &int) -> bool { Some(x) == None }
[20:37:39] <strcat> that optimizes down to a null check at --opt-level=3
[20:37:52] <strcat> LLVM isn't a magician ;)
[20:38:01] <pnkfelix> but it should be a constant, no?
[20:38:04] <strcat> pnkfelix: no
[20:38:09] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[20:38:10] <strcat> we don't tell LLVM that `x` is null
[20:38:12] <strcat> er
[20:38:14] <strcat> is *not* null
[20:38:19] <pnkfelix> oh
[20:38:20] <strcat> we can't - there's no way to express it
[20:38:25] <strcat> so LLVM thinks it can be null
[20:38:27] <strcat> and Some(x) is a no-op
[20:38:33] *** Joins: evanm (evanm@636AC086.5999CED5.71743E61.IP)
[20:38:36] <pnkfelix> okay, well, that's a "problem" with LLVM
[20:38:44] *** Joins: bytbox (s@moz-E1E7FAC3.washdc.fios.verizon.net)
[20:38:52] <eddyb> range analysis pls
[20:39:06] <eddyb> strcat: oooh, bump allocators are what I called "dumb linear allocators"
[20:39:08] <strcat> pnkfelix: yeah, just an example of where an 'optimization' can go wrong
[20:39:17] <strcat> pnkfelix: this used to optimize down to a no-op
[20:39:21] <zwarich> LLVM's CorrelatedValuePropagation really needs an overhaul
[20:39:22] <strcat> this hurts iterators btw
[20:39:27] <eddyb> strcat: I used one as the page allocator for my Slam/Blam allocator :P
[20:40:07] <strcat> zwarich: we really need a way to communicate that a ptr is non-null
[20:40:09] <strcat> ;s
[20:40:20] <strcat> and on parameters via an attribute isn't really enough
[20:40:24] *** Joins: mihneadb (mihneadb@moz-6B31F5AA.static.ziggozakelijk.nl)
[20:40:28] *** Joins: mib_tm8zoz (Mibbit@3E3094EC.34458CF2.CC1A2609.IP)
[20:40:28] <strcat> and perhaps won't really help, since that implies call overhead already
[20:40:42] *** Quits: mib_tm8zoz (Mibbit@3E3094EC.34458CF2.CC1A2609.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:40:46] <strcat> and LLVM would lose it on inlining since it's not very bright when it comes to that stuff
[20:40:55] <zwarich> the only thing you can really do is put some metadata on the memop
[20:41:05] <zwarich> then change some optimizations to preserve it / optimize based on it
[20:41:10] <strcat> zwarich: well there are range assertions for loads already
[20:41:24] <strcat> but doesn't work anywhere else, or for ptrs
[20:41:40] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Connection reset by peer)
[20:41:40] <strcat> we do output range assertions on loads of bools and enum discriminants fwiw
[20:42:52] <zwarich> hmm, this is a real pain
[20:43:28] <strcat> it's a big issue because the Iterator signature is...
[20:43:33] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[20:43:34] <strcat> fn next(&mut self) -> Option<T>
[20:43:41] <strcat> where T is often &U
[20:43:52] <strcat> so inside the next implementation, there's a check for an end ptr
[20:43:58] <strcat> and outside, the for loop does a null check
[20:44:15] <strcat> without extra information, our loops end up with 2 checks and don't hit any of the loop optimizations
[20:44:34] <strcat> before we optimized Option<&T> down to a single ptr with no tag, iterators were never slower than C++ ones
[20:44:42] <benh> strcat: how do you fix Some(~())? Do you prevent the Option<~T> optimization if sizeof(T)=0?
[20:44:46] <zwarich> ouch, do you have a gist or something of the IR?
[20:44:55] <strcat> sec
[20:44:55] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[20:44:59] <zwarich> I don't have Rust installed at work sadly
[20:45:24] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[20:46:13] *** Joins: mceier (mceier@moz-C1591437.dynamic.chello.pl)
[20:47:09] <strcat> zwarich: if only I could remember which cases this happens in ;)
[20:47:14] *** Joins: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net)
[20:47:17] <strcat> I think there's a bug open
[20:47:19] * strcat looks
[20:48:00] <strcat> zwarich: https://github.com/mozilla/rust/issues/11751 here
[20:48:34] <strcat>   %7 = icmp eq i64* %6, %5
[20:48:35] <strcat>   %8 = icmp eq i64* %6, null
[20:48:37] <strcat>   %or.cond = or i1 %7, %8
[20:48:39] <strcat> ;s
[20:49:12] <strcat> it's really sad because it's totally obvious that it can't be null based on rust's semantics, and we could communicate it if we had a way...
[20:49:33] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[20:49:58] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[20:51:46] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[20:51:46] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[20:53:26] *** Joins: guest2222 (guest2222@1EEF8F2.50A2C647.5A42B74E.IP)
[20:54:29] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[20:54:38] *** Joins: rylev (rylev@moz-91741E1A.cust.telecolumbus.net)
[20:55:28] *** Joins: rylev_ (rylev@moz-91741E1A.cust.telecolumbus.net)
[20:55:28] *** Quits: rylev (rylev@moz-91741E1A.cust.telecolumbus.net) (Connection reset by peer)
[20:56:15] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[20:56:18] *** Joins: arturo (Thunderbir@moz-E83B14F0.superkabel.de)
[20:56:35] *** Quits: lerc (quassel@moz-82B68322.telstraclear.net) (Ping timeout)
[20:58:25] *** Joins: csherratt (csherratt@moz-F23E0824.eng.wind.ca)
[20:59:04] *** Joins: Sorella (quildreen@AA4589ED.97245BEB.1ED99692.IP)
[20:59:46] *** Joins: hoverbear (hoverbear@moz-6543792B.wireless.uvic.ca)
[21:00:13] *** Joins: grok2 (Mibbit@E00F4076.76B1575.8FE2F0CE.IP)
[21:00:55] <pnkfelix> benh: I was wondering something similar.  From what strcat said above, I'm inferring that he has some different change in mind
[21:01:12] <strcat> benh: no
[21:01:17] <strcat> benh: because you can have a trait object
[21:01:24] <strcat> well
[21:01:25] *** Quits: grok2 (Mibbit@E00F4076.76B1575.8FE2F0CE.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:01:32] <strcat> or here, Vec<T>
[21:01:35] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:01:55] <strcat> Vec::new() makes a new vector, shrink_to_fit essentially results in the same
[21:01:58] <strcat> what should it set ptr to?
[21:02:30] *** Joins: onelson_ (owen@18CF7301.95770028.5B6BFE7D.IP)
[21:02:34] <strcat> if you use null, then the null ptr optimization doesn't apply to it
[21:02:34] <pnkfelix> strcat: by "results in the same", you mean `Vec::new().shrink_to_fit()` ends up with the same representation as `~()` ?
[21:02:35] <strcat> but it should
[21:02:46] <strcat> pnkfelix: I mean the ptr issue there is the same
[21:02:52] <strcat> if the Option<> optimization applies to it
[21:03:29] <strcat> you can omit the free calls to zero-size types when the type is statically known, you can set the glue code to a no-op
[21:03:50] <strcat> but there are places like slices and Vec where this doesn't really work
[21:04:01] *** Joins: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net)
[21:04:01] *** ChanServ sets mode: +o tjc
[21:04:07] <strcat> if the slice thinks it's zero-size, that doesn't mean it has no allocated memory
[21:04:21] <strcat> rusti: std::mem::size_of::<Option<~[int>>()
[21:04:25] -rusti- pastebinned 7 lines of output: http://ix.io/br5
[21:04:28] <strcat> rusti: std::mem::size_of::<Option<~[int]>>()
[21:04:29] -rusti- 8
[21:04:46] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[21:06:09] <strcat> with (ptr, len), you can't really trust the len
[21:06:17] <strcat> you have at least that much memory
[21:06:29] *** Quits: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net) (Input/output error)
[21:06:33] <strcat> the ptr can never be null, because otherwise it would break the Option optimization
[21:07:31] <pnkfelix> strcat: okay, and we don't want an extra-check for `if len == 0 { ... }` before attempting to free the ptr?
[21:07:49] <strcat> pnkfelix: that's not the issue
[21:07:59] <strcat> lets say you build a Vec<T>
[21:08:08] <strcat> it has 22 elements now, but 40 capacity
[21:08:12] <strcat> because it just doubled after 20
[21:08:15] <strcat> you convert to ~[T]
[21:08:22] <strcat> so you have (ptr_to_40_alloc, 22)
[21:08:35] <strcat> you can also have (ptr_to_40_alloc, 0)
[21:08:52] <strcat> you have to call free(ptr)
[21:09:00] <strcat> you have no idea how much memory it has (if any)
[21:09:00] <det> Do self-recursive calls have to always be qualified, ie: Node::insert(...) instead of just insert(...) ?
[21:09:10] <pnkfelix> strcat: the invariant I was proposing above
[21:09:19] <pcwalton> det: yes, unless it's a method using dot notation
[21:09:32] <pnkfelix> strcat: was that if you ever drop down to 0, you'd be reponsible for free'ing at that point, immediately
[21:09:38] <det> pcwalton, thanks
[21:09:43] *** Quits: jdm (jdm@FCCEA34F.7672369.D8E68FF6.IP) (Quit: Lost terminal)
[21:09:49] <arielb1> can't the Vec<T> -> ~[T] realloc the vector
[21:09:54] <arielb1> to fit the size
[21:09:56] <strcat> pnkfelix: imo you might as well be calling shrink_to_fit at that point though
[21:10:16] *** Quits: onelson_ (owen@18CF7301.95770028.5B6BFE7D.IP) (Ping timeout)
[21:10:39] <pnkfelix> strcat: ... I feel like there are a couple different issues that you are pointing out here, and they are getting mixed together but I'm not sure if they should be mixed together
[21:10:54] <strcat> pnkfelix: I think they should be, because there's a single solution for all of them
[21:11:01] *** Joins: asmyers (quassel@moz-71754EDC.hsd1.md.comcast.net)
[21:11:02] <strcat> pnkfelix: calling shrink_to_fit means dropping excess capacity
[21:11:07] *** Quits: bpicolo (Adium@moz-B475EB64.static-ip.telepacific.net) (Quit: Leaving.)
[21:11:11] <strcat> if there are 0 elements, it makes the capacity 0
[21:11:19] <eddyb> i.e. free?
[21:11:43] *** Quits: lkuper (lkuper@moz-AD4C50F5.dhcp-bl.indiana.edu) (Quit: lkuper)
[21:12:08] <strcat> eddyb: yes
[21:12:22] <arielb1> capacity 0 =/= free
[21:12:28] <strcat> it does
[21:12:32] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[21:12:34] <strcat> malloc(0) is implementation defined, we don't call it
[21:12:54] <arielb1> you don't have to put null
[21:12:54] <strcat> realloc(ptr, 0) is implementation defined too
[21:12:58] <arielb1> if that gives you trouble
[21:13:05] <arielb1> realloc(ptr, 0) is buggy
[21:13:10] <strcat> it's not buggy
[21:13:11] <arielb1> it can free ptr AND return NULL
[21:13:15] <strcat> it's just implementation defined
[21:13:22] *** Joins: jviereck (Adium@moz-7859BAFE.dclient.hispeed.ch)
[21:13:23] <strcat> arielb1: that's not buggy
[21:13:30] <arielb1> just broken
[21:13:31] *** Joins: dranov (dranov@F9D59147.3B6BC09B.A5830293.IP)
[21:13:33] <eddyb> that's what I expect, actually :D
[21:13:34] <strcat> it's not broken or buggy
[21:13:40] *** Quits: csherratt (csherratt@moz-F23E0824.eng.wind.ca) (Quit: csherratt)
[21:13:41] *** Joins: alan_andrade (alan_andra@moz-B2C44770.car1.sanfrancisco1.level3.net)
[21:13:45] *** Quits: awidegreen (awidegreen@8A668854.BEF1EF69.8633E8B5.IP) (Ping timeout)
[21:13:46] <eddyb> arielb1: how is "perfect solution" broken and buggy :P?
[21:13:59] *** Quits: io2 (io2@moz-EE406A5.home.otenet.gr) (Quit: ...take irc away, what are you? genius, billionaire, playboy, philanthropist)
[21:14:07] <arielb1> because in every other situation if realloc returns null ptr is left unchanged
[21:14:17] <eddyb> huh
[21:14:24] <strcat> arielb1: they set errno if there's OOM, according to POSIX
[21:14:31] <arielb1> if it isn't they don't
[21:14:33] <strcat> we just don't want to pay for an errno check
[21:14:41] <strcat> I don't know if windows sets it also
[21:14:59] <eddyb> hang on, isn't it supposed to return the same pointer if l doesn't change it?
[21:15:10] <arielb1> if the resizing fails
[21:15:11] <arielb1> from OOM
[21:15:14] <strcat> (anyway we don't want to call malloc(0) because it allocates memory with glibc)
[21:15:27] <det> There is no way to do a.cmp(b) -> some enum with Lt/Gt/Eq ? You must use if a < b {} else if a > b {} else {} ?
[21:15:46] *** Quits: mye (mye@moz-476E65B2.swh.uni-giessen.de) (Ping timeout)
[21:15:57] <eddyb> det: #[deriving(TotalOrd)]?
[21:15:57] <strcat> pnkfelix: I have a choice between a) implement compiler solution that won't work for slices and b) pass length to free
[21:16:00] <strcat> I'll just do a)
[21:16:09] <det> eddyb, ahh, I see it now
[21:16:11] <strcat> becomes the problem of the DST implementation
[21:16:11] <arielb1> you can just put a out-of-heap non-null pointer there
[21:16:22] <arielb1> to represent a zero-length allocation
[21:16:34] <det> Would it be a bad thing for a collection to require TotalOrd instead of just Ord for its keys ?
[21:16:40] <strcat> det: no
[21:16:43] <arielb1> det: it should
[21:16:44] <strcat> det: TotalOrd is the usual bound
[21:17:05] <strcat> det: Ord is usually broken for generics
[21:17:07] <pnkfelix> strcat: when you say slices, do you mean `&[T]` ?
[21:17:11] <strcat> pnkfelix: ~[T]
[21:17:13] <det> ok, thanks
[21:17:18] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[21:17:24] <strcat> where [T] is a slice
[21:17:43] <pnkfelix> strcat: ...
[21:17:52] <strcat> hm?
[21:18:00] <pnkfelix> strcat: I don't think the way you're using terminology matches my mental model
[21:18:12] <pnkfelix> strcat: to me, slice == (ptr-to-data, len)
[21:18:12] *** Quits: asmyers (quassel@moz-71754EDC.hsd1.md.comcast.net) (Ping timeout)
[21:18:25] <huon> pnkfelix: that's a DST ~[T] too?
[21:18:30] <pnkfelix> strcat: so the statement "where [T] is a slice" seems strange at best?
[21:18:33] <arielb1> hion: yes
[21:18:35] <arielb1> huon: yes
[21:18:53] <strcat> pnkfelix: well, I'm using slice to mean 'block of memory' but not a fixed-size array
[21:18:59] <strcat> which is why they're in std::slice now
[21:19:11] <pnkfelix> huon: okay, I should perhaps have said "(ptr-to-potentially-shared-data, len)"
[21:19:18] <arielb1> isn't [T] simply an array?
[21:19:22] <strcat> std::array would be [T, ..n] stuff if and when we get it
[21:19:30] <huon> arielb1: [T] itself isn't anything
[21:19:35] <strcat> it will be though
[21:19:52] <huon> it's basically "some contiguous sequence of T's with unknown length"
[21:20:01] <huon> but it will never be a "real" type like int
[21:20:02] <strcat> pnkfelix: anyway I'm going to fix it because it's a bug and someone else can worry about the consequences down the road ;p
[21:20:04] <arielb1> [T] is a DST
[21:20:15] *** Quits: hoverbear (hoverbear@moz-6543792B.wireless.uvic.ca) (Quit: Taking a nap.)
[21:20:16] <pnkfelix> strcat: okay.  I will go re-read the log with this interpretation in mind
[21:20:17] <strcat> this already broke HashMap...
[21:20:20] *** Quits: maxli (Adium@moz-F47DD19B.student.cs.uwaterloo.ca) (Ping timeout)
[21:20:31] *** Joins: maxli (Adium@moz-B19F68ED.student.cs.uwaterloo.ca)
[21:21:35] *** Quits: ahunt (ahunt@moz-6D6D79D6.cable.virginm.net) (Ping timeout)
[21:25:14] <det> Would a Rust iterator usually use parent pointers for navigation or allocation some stack?
[21:25:22] <strcat> stack
[21:25:40] <strcat> parent pointers imply the tree needs to use unsafe code or refcounting
[21:25:48] <strcat> + they're silly
[21:25:50] <strcat> ;p
[21:25:57] <strcat> (at least for a balanced binary search tree)
[21:26:11] <eddyb> strcat: can confirm silliness
[21:26:19] *** Joins: bpicolo (Adium@moz-B475EB64.static-ip.telepacific.net)
[21:26:19] <det> well, they give you constant time operators
[21:26:24] *** Quits: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP) (Input/output error)
[21:26:27] <eddyb> but they're still pretty efficient
[21:26:43] <strcat> det: you know the worst case depth of a balanced binary search tree is O(log(n))
[21:26:45] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[21:26:57] <strcat> something like 2*log(n) in reality
[21:27:05] <strcat> plus or minus one or two
[21:27:17] <det> strcat, ya, i know, i've implemented a b+tree with a fixed size stack before, even used constexpr c++ stuff to compile time compute the maximum stack size :p
[21:27:24] <eddyb> strcat: given how hard generic back-references are to design, it makes you wonder how say an unsafe abstraction is
[21:28:01] <eddyb> det: with n = address_space_size / sizeof T?
[21:28:32] <det> eddyb, compile time log2 + some other stuff
[21:28:57] <strcat> pnkfelix: I'm just going ahead with finishing my compiler hack fix for now
[21:29:19] <eddyb> det: I mean, log2 of what :P?
[21:29:44] <det> eddyb, ill have to look it up, sec
[21:29:56] *** Joins: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[21:30:19] <det> eddyb, log(MaximumSize / MinimumBlockSize, MinimumOrder);
[21:30:26] <det> eddyb, not even log2
[21:30:27] <strcat> pnkfelix: 1778b6361627c5894bf75ffecf427573af02d390
[21:30:46] <strcat> pnkfelix: ~[T] won't be allowed to call free if the capacity was non-zero
[21:30:49] <pnkfelix> strcat: looking
[21:30:59] <strcat> pnkfelix: this is what I started before
[21:31:04] <det> eddyb, it was for text, maximum size was typically the size of the address space
[21:31:05] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[21:31:06] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[21:31:06] *** ChanServ sets mode: +o jdm
[21:31:14] <strcat> because this way it never calls it statically (known size) and sets the glue for ~Trait to a no-op
[21:31:16] <arielb1> det: you don't need constexpr - sizeof(size_t)*8*2 is fine and works in C
[21:31:40] *** Quits: mihneadb (mihneadb@moz-6B31F5AA.static.ziggozakelijk.nl) (Quit: Computer gone to sleep - Zzzz...)
[21:32:33] <det> arielb1, not the same thing
[21:33:11] <arielb1> det: what's the difference?
[21:33:38] *** Joins: bvssvni (Mibbit@moz-A47B6F8E.bb.online.no)
[21:33:49] *** Quits: tigrou3tac (fabien@moz-6E2397FF.fbx.proxad.net) (Ping timeout)
[21:33:58] *** Quits: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP) (Ping timeout)
[21:34:15] *** Joins: franckverrot (Franck_Ver@C3033BF6.B86F1645.C91367C6.IP)
[21:34:31] *** Quits: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP) (Input/output error)
[21:34:51] *** Quits: tjc (tjc@moz-7EE2AFFC.hfc.comcastbusiness.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:34:51] *** Joins: eholk_ (eholk@moz-F70D5031.hsd1.in.comcast.net)
[21:34:54] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[21:34:58] <det> arielb1, its not ceiling(log((2 ** bits_in_size_t) / smallest_fill_size_for_a_leaf, smallest_fill_size_for_a_branch))
[21:35:07] *** Quits: vgeddes (vincent.ge@moz-102C6E36.access.mtnbusiness.co.za) (Ping timeout)
[21:35:23] <bvssvni> ??? https://gist.github.com/bvssvni/9943662
[21:35:41] <arielb1> but?
[21:35:54] <pnkfelix> strcat: okay, i think this may end up approximating something similar to what I was thinking about
[21:36:00] <pnkfelix> strcat: thank you for the ptr
[21:36:16] <arielb1> bssvni: what is that code supposed to do?
[21:36:21] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[21:36:22] <strcat> pnkfelix: it does mean Vec<T> -> ~[T] can't be a no-op though.
[21:36:29] *** Quits: Nekit1234007 (Nekit12340@DC1D6696.9C28A5C7.4707F662.IP) (Ping timeout)
[21:36:37] <strcat> pnkfelix: calling free(ptr) when capacity == 0 is a subset of what shrink_to_fit does, which is why I was talking about it
[21:36:38] <bvssvni> arielb1: insert into a HashMap
[21:36:45] <arielb1> Vec != HashMap
[21:36:48] <arielb1> it inserts into a Vec
[21:37:04] <strcat> pnkfelix: I actually forgot this bug still existed
[21:37:07] <strcat> because I 'fixed' it
[21:37:10] <bvssvni> arielb1: Thanks
[21:37:12] <strcat> but it had to be snapshoted
[21:37:17] <bvssvni> arielb1: did not see that name collision
[21:37:19] <strcat> and iirc the snapshot bots were down or something
[21:37:21] <strcat> heh
[21:38:00] <det> For the stack for an iterator would this typically be something fixed size as a value in the allocator or growable Vec ?
[21:38:10] <arielb1> strcat: how can Vec<T> -> ~[T] be a no-op?
[21:38:18] <det> s/allocator/iterator/
[21:38:19] <strcat> arielb1: dropping the capacity field
[21:38:27] <strcat> {ptr, len, cap} -> {ptr, len}
[21:38:34] <strcat> except if cap == 0, it will have to call free(ptr)
[21:38:46] <strcat> so imo, it might as well also shrink it - and then free can always be told the true capacity
[21:39:02] <strcat> shrink as in if cap == 10 and len == 5, shrink cap to 5
[21:39:06] <arielb1> it should probably shrink it
[21:39:09] <strcat> which is what shrink_to_fit does
[21:39:16] <arielb1> to avoid strings being twice as large as they should be
[21:39:19] <arielb1> that kind of stuff
[21:39:31] <strcat> but I'm saying it *must* shrink it
[21:39:40] <strcat> which is different than providing both
[21:39:50] <strcat> because if it's only an option, then free can't be told the true size
[21:39:57] *** Joins: slashus2 (slashus2@moz-17D062C1.snl.wku.edu)
[21:39:59] <arielb1> or you could put a dummy value for len==0
[21:40:06] <strcat> it's not just len == 0 though
[21:40:27] <arielb1> you want free to know the true size?
[21:40:30] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[21:40:49] <strcat> yes
[21:40:49] *** Joins: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[21:40:55] <arielb1> actually, that would be nicer than glibc's malloc behaviour of allocating n+1 pages
[21:40:59] <arielb1> when you allocate n*4096 bytes
[21:41:34] <strcat> pnkfelix: *** Error in `x86_64-unknown-linux-gnu/stage1/bin/rustc': free(): invalid pointer: 0x00007fb01afdacf8 ***
[21:41:35] <strcat> heh
[21:41:50] * strcat sighs
[21:41:51] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[21:42:09] <pnkfelix> strcat: I've been trying to think of a way to encode both scenarios, i.e. having statically dispatched Allocators, where one kind of allocator supports malloc/free protocol, and in the other free requires the size
[21:42:22] *** Quits: brson (brson@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[21:42:35] <strcat> pnkfelix: both would still work if you happened to always have the size though
[21:43:02] <pnkfelix> strcat: yes, but I would like to have the option of making Vec<T> -> ~[T] cheap when it can be
[21:43:18] *** Quits: bytbox (s@moz-E1E7FAC3.washdc.fios.verizon.net) (Ping timeout)
[21:43:30] <arielb1> the realloc is amortized
[21:43:30] <pnkfelix> strcat: it may be a moot point, given that there are other good arguments to not try to use ~[T] throughout the stdlib
[21:43:35] <arielb1> shouldn't be too expensive
[21:44:38] *** Joins: bytbox (s@moz-E1E7FAC3.washdc.fios.verizon.net)
[21:44:52] *** Joins: gavinb (gavinb@B421F273.56843BDB.354B30E7.IP)
[21:45:13] *** Quits: nik_ (nik@moz-824307E1.vpn.rwth-aachen.de) (Ping timeout)
[21:45:18] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[21:45:38] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:46:50] <arielb1> through it could be painful if you build lots of short-lived short strings
[21:46:57] *** Joins: ahunt (ahunt@moz-6D6D79D6.cable.virginm.net)
[21:47:04] <kimundi> pnkfelix: Does the solution for that that someone mentioned earlier not work? Have the allocator provide a shrink_to_fit feature, that does nothing for malloc/free, and does the right thing for things that use the size.
[21:47:23] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:47:30] <pnkfelix> kimundi: it wouldn't resolve strcat's problem
[21:47:39] <strcat> kimundi: then you can't pretend Vec<T> -> ~[T] is free
[21:47:45] <strcat> you have to program as if it isn't
[21:47:54] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[21:48:05] <strcat> our default allocator is eventually going to take advantage of it if the guarantee is there
[21:48:20] <kimundi> pnkfelix> ... but I would like to have the option of making Vec<T> -> ~[T] cheap when it can be // I was just responding to this
[21:48:29] <arielb1> It isn't so bad - for every such conversion there is a malloc, and probably a free
[21:48:55] <pnkfelix> kimundi: right, but the (probably over-engineered) approach I was musing about was to address strcat's problem
[21:48:58] <arielb1> you won't suddenly get O(n) allocations
[21:48:58] <strcat> if only I knew why this segfaulted
[21:49:01] *** Joins: sp3d (sp3d@6361F3B1.19CD1E54.8354FB35.IP)
[21:49:08] <pnkfelix> kimundi: in the context of *also* supporting cheap Vec<T> -> ~[T].
[21:49:20] <kimundi> pnkfelix: Okay, carry on then :)
[21:49:50] <kmc> is there still a generic (not error-oriented) Either type somewhere?
[21:49:55] <strcat> no
[21:49:59] <kimundi> kmc: no
[21:50:28] <kimundi> kmc: The canonical way is to define a custom enum
[21:50:39] *** Joins: csherratt (csherratt@moz-F23E0824.eng.wind.ca)
[21:50:41] *** Joins: Nekit1234007 (Nekit12340@A4D1747.7796E3F4.4707F662.IP)
[21:51:07] <kmc> yeah
[21:51:25] <kmc> makes sense... usually it's good to name your sums / products
[21:51:31] <kmc> but it's useful for very local stuff
[21:51:37] <Havvy> Either<A, Either<B, Either<C, ...>>...>
[21:52:16] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[21:53:10] *** Quits: paraze (paraze@moz-F2628701.w90-27.abo.wanadoo.fr) (Client exited)
[21:53:16] *** Quits: slashus2 (slashus2@moz-17D062C1.snl.wku.edu) (Quit: Leaving)
[21:54:54] <eddyb> Havvy: because Right Right Right ...?
[21:54:58] *** Quits: fabiand (fabiand@moz-3C5B0258.adsl.alicedsl.de) (Quit: Verlassend)
[21:55:51] *** Joins: harish (harish@moz-A9E56CFE.hfc.comcastbusiness.net)
[21:56:19] <Havvy> Just nonsensical type abuse, but yeah.
[21:56:42] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[21:56:47] *** Parts: harish (harish@moz-A9E56CFE.hfc.comcastbusiness.net) ()
[21:57:02] *** Quits: Ralith (ralith@moz-67D4EB93.customer.broadstripe.net) (Ping timeout)
[21:57:06] *** Joins: ehsanul (harish@moz-A9E56CFE.hfc.comcastbusiness.net)
[22:00:34] *** Quits: aatch (James@moz-B437F499.pocketrent.com) (Ping timeout)
[22:00:54] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:01:11] *** Joins: aatch (James@moz-B437F499.pocketrent.com)
[22:01:45] <gavinb> A type constraint in an impl just says what traits the templated type must support, right? Like a category on a funciton in Haskell?
[22:02:33] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:02:34] <kmc> category?
[22:02:46] <gavinb> so if you had: “impl<T: Zero> Foo<T>” then you’re just saying T must implement Zero somewhere.
[22:02:49] <kmc> yes
[22:03:02] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:03:04] <eddyb> gavinb: that "somewhere" is misleading though
[22:03:06] <kmc> you can have multiple "impl" bodies with different constraints, too
[22:03:29] *** Quits: nszceta (nszceta@moz-E458A7C0.pharm.pitt.edu) (Quit: Textual IRC Client: www.textualapp.com)
[22:03:52] <eddyb> gavinb: a type can implement a trait iff either the type or the trait are in the same crate as the impl
[22:04:08] *** Joins: leowoe (Leo@moz-F1E78404.dip0.t-ipconnect.de)
[22:04:28] <gavinb> eddyb: hm - that’s very - interesting…
[22:04:41] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:05:11] <gavinb> eddyb: so if you’re writing a library and you have no idea what types could be used with your code at the time the library is built, all you can do is say what traits they must implement elsewhere, right?
[22:05:38] <eddyb> gavinb: uhm, yeah, I guess
[22:05:45] <eddyb> gavinb: again, "elsewhere" is misleading
[22:05:54] <eddyb> gavinb: Rust doesn't have orphan instances
[22:06:01] <gavinb> eddyb: still confused by “elsewhere” :/
[22:06:19] <gavinb> eddyb: what does that mean?
[22:06:26] <eddyb> either a type T implements a trait Trait, or it never does
[22:06:54] *** Joins: ChrisMorgan (chris@moz-8DCBEA52.vic.adsl.internode.on.net)
[22:08:01] <gavinb> I think there’s some subtleties about context there that I’m missing…
[22:08:16] <eddyb> gavinb: you can't get new impls on combinations of already existing types and traits by adding crates (i.e. no orphan instances)
[22:08:49] <eddyb> gavinb: there is no notion of location associated with impls
[22:09:02] *** Quits: abaez (a__@moz-8D618AC3.nycmny.fios.verizon.net) (Client exited)
[22:09:08] <gavinb> location, as in - which crate it is defined in?
[22:09:11] <eddyb> "somewhere" or "elsewhere" imply a location
[22:09:30] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[22:09:42] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[22:09:53] *** vfetwnuncszu is now known as dcrewi
[22:09:56] <meyer> Is there a standard iterator for always yielding 0 elements?
[22:10:09] <eddyb> there is only one crate where you can have an impl of a trait for a type (for a combination of a type and a trait)
[22:10:23] <eddyb> if you can have it, that is
[22:10:35] <eddyb> meyer: there's None.move_iter() and .iter()
[22:10:50] <meyer> That's a std::option::Item?
[22:10:58] <eddyb> I think so
[22:10:59] <sfackler> yep
[22:11:01] *** Quits: arturo (Thunderbir@moz-E83B14F0.superkabel.de) (Ping timeout)
[22:11:27] <gavinb> eddyb: So vec::Vec defines impl<T: Clone> Vec<T> {} which can work with any type T, provided it implements Clone. But Vec is in its own crate, and you can build another crate which uses this Vec support. I guess that’s all I’m trying to do…
[22:11:37] <kimundi> Heh, my iterable design taking self by value would also allow "for x in None"
[22:11:53] <eddyb> gavinb: Clone is in libstd
[22:12:07] <eddyb> gavinb: that means any crate other than libstd can only implement Clone for its own types
[22:12:19] <meyer> That's what I have right now, but I feel like (although this is almost certainly not a bottleneck) I shouldn
[22:12:23] <eddyb> gavinb: you can't add Clone to a type outside of your own crate, from within that crate
[22:12:29] <gavinb> So you couldn’t define Vec outside of libstd, because it has to be in the same crate as Clone?
[22:12:32] <meyer> *shouldn't use Item when I only need an empty struct
[22:12:40] <eddyb> gavinb: aaaah, that is the question?
[22:12:49] <kimundi> gavinb: No
[22:12:59] *** Joins: Jesse (jruderman@moz-62518563.mtv2.mozilla.com)
[22:13:00] <eddyb> gavinb: it doesn't have to be in the same crate as Clone
[22:13:14] <gavinb> whew! :)
[22:14:34] <gavinb> So in a lib, I get “error: failed to find an implementation of trait std::clone::Clone for T” when T is coming from outside this crate. So T must be defined “elsewhere”. Back to locations - or not. (!)
[22:14:56] *** Quits: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net) (Ping timeout)
[22:15:07] <eddyb> gavinb: is T a generic type?
[22:15:10] <gavinb> yes
[22:15:16] <eddyb> then put Clone as a bound on it
[22:15:18] <kimundi> gavinb: T is the thing coming from outside the crate then. And it apparently doesn't implement clone
[22:15:25] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Ping timeout)
[22:15:28] *** Joins: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP)
[22:15:28] *** ChanServ sets mode: +o jdm
[22:15:28] <eddyb> this isn't a matter of crates
[22:15:32] <eddyb> or locations
[22:15:40] *** Joins: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net)
[22:15:44] <eddyb> gavinb: you just didn't bound your own code
[22:15:53] <kimundi> bound or impl?
[22:15:57] <eddyb> bound
[22:16:01] * kimundi confused what this is all about
[22:16:15] <eddyb> kimundi: fn foo<T>(x: T) {x.clone();}
[22:16:21] <eddyb> from what I can gather
[22:16:46] <eddyb> and here I thought gavinb was asking a complicated question :P
[22:17:00] <eddyb> *sigh* Haskell fancy terms causing confusion
[22:17:01] <gavinb> But isn’t <T: Zero, Clone> the bound?
[22:17:03] <kimundi> See, thats not what I gathered :) - gavinb: What does actually cause that error message?
[22:17:08] <eddyb> gavinb: hahaha
[22:17:14] <eddyb> gavinb: we really ought to add a lint for that
[22:17:15] *** Quits: dranov (dranov@F9D59147.3B6BC09B.A5830293.IP) (Ping timeout)
[22:17:16] <kimundi> gavinb: Aaahhhh
[22:17:19] <eddyb> kimundi: wait
[22:17:20] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:17:23] <eddyb> I want to relevate
[22:17:34] * gavinb still waiting for the penny to drop
[22:17:37] <eddyb> gavinb: how would you write a generic over two params, T and U
[22:17:44] <eddyb> gavinb: and T has a Zero bound?
[22:18:04] *** Joins: tyna (liadon@moz-BB1BAD9A.dynamic.chello.pl)
[22:18:12] <eddyb> kimundi: it's better when you get them to explain it to themselves :P
[22:18:36] * kimundi has to fight the urge to answer a fully detailed explanation.
[22:18:48] <gavinb> eddyb: I’m guessing something like impl<T: Zero> Foo<T> is wrong then? :P
[22:19:02] <eddyb> gavinb: no, it's not, answer my question please
[22:19:17] <Jesse> rusti: Some(~())
[22:19:18] -rusti- None
[22:19:40] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:19:53] <gavinb> oh two params, duh. impl<T: Zero, U> Foo<T, U> ?
[22:20:10] <kimundi> yes
[22:20:12] <eddyb> gavinb: right
[22:20:20] <eddyb> gavinb: now rename U to Clone
[22:20:27] <pnkfelix> "and therefore ... a witch!"
[22:20:27] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:20:48] <gavinb> pnkfelix: “Burn ‘er!”
[22:20:51] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[22:21:21] <eddyb> gavinb: so, what do you get?
[22:21:22] <gavinb> well then impl<T: Zero, Clone> Foo<T, Clone> {} I guess
[22:21:36] <kimundi> correct
[22:21:45] <eddyb> gavinb: and you previously tried <T: Zero, Clone>
[22:21:48] <eddyb> gavinb: see an issue?
[22:22:03] *** Joins: abaez (a__@moz-8D618AC3.nycmny.fios.verizon.net)
[22:22:04] *** Quits: abaez (a__@moz-8D618AC3.nycmny.fios.verizon.net) (Client exited)
[22:22:05] <gavinb> OH!
[22:22:07] <eddyb> :D
[22:22:12] *** Quits: ahunt (ahunt@moz-6D6D79D6.cable.virginm.net) (Ping timeout)
[22:22:27] <eddyb> cmr: I got a tip [01:22] <xvilka> eddyb: so if anyone will ask you about ocaml vs rust - just say 'utf8 in the core'
[22:22:35] *** Joins: abaez (a__@moz-8D618AC3.nycmny.fios.verizon.net)
[22:22:55] <hoverbear> eddyb: +1
[22:22:55] *** Quits: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net) (Ping timeout)
[22:23:03] *** Joins: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net)
[22:23:14] <gavinb> eddyb: ting!
[22:23:22] <bvssvni> what is the most pleasant way of having a reference counted str? Rc<~str>?
[22:23:31] <hoverbear> eddyb: Rust initially attracted me with the "match" statement which reminded me of a F#, an Ocaml derivative.
[22:23:43] <pnkfelix> gavinb: and so: for a given type param, its list of bounds uses `+` to separate entries on the list, not `,`
[22:24:04] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[22:24:08] <gavinb> pnkfelix: yes, that was the sound of _my_ penny dropping :)
[22:24:27] *** Quits: vikstrous (v@moz-1E061984.cpe.distributel.net) (Ping timeout)
[22:24:55] <gavinb> oh man, such a simple thing - but the error msg was kinda confusing.
[22:25:06] <gavinb> eddyb: *thanks*
[22:25:21] <eddyb> I did mention a lint
[22:25:34] <eddyb> you rarely need more than one character for a type parameter
[22:25:45] *** Quits: guest2222 (guest2222@1EEF8F2.50A2C647.5A42B74E.IP) (Ping timeout)
[22:26:01] <eddyb> aaand when is it legitimately the same name as a trait in scope?
[22:26:04] <gavinb> when I used the word category earlier, I of course meant typeclass :/
[22:26:15] <eddyb> aaah that also makes more sense :P
[22:26:34] *** flaper87 is now known as flaper87|afk
[22:26:41] <gavinb> eddyb: when it’s a recursive type…??
[22:26:58] <kimundi> Once again, a place where naming convention helps readability of code, and can guide to discover errors.
[22:27:25] <eddyb> gavinb: recursive type?
[22:28:26] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[22:28:28] <gavinb> eddyb: argh, bear with me - learning Rust and Haskell at the same time, after many years of C++, where terminology is abused.
[22:28:42] <gavinb> eddyb: I meant like a linked list
[22:28:51] <benh> > A planned future improvement (net yet implemented at the time of this writing) is to have a guard page at the end of every rust stack.
[22:28:54] <eddyb> recursive data structure :P
[22:28:55] <benh> Are guard pages really not in yet?
[22:29:00] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[22:29:10] *** Joins: skade (skade@moz-6444221B.dip0.t-ipconnect.de)
[22:29:11] <gavinb> eddyb: It took me ages to grok functors in Haskell because it means something quite different in C++.
[22:29:16] <benh> b/c if they are, someone could update the docs and remove that typo in 'not yet' ;)
[22:29:18] <eddyb> gavinb: lol
[22:29:35] <gavinb> eddyb: but I figure if it doesn’t hurt my brain, I’m not trying hard enough :)
[22:29:57] <kimundi> gavinb: So, whats the actual question with recursive data structures?
[22:30:34] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:30:54] <gavinb> I can’t seem to find an example of <T:A+B> in the Reference Manual…
[22:30:55] <benh> also, in http://static.rust-lang.org/doc/master/guide-tasks.html wouldn't it make more sense for 3.1 to be, like, 2.2 or 2.1.2 or something?
[22:31:14] <gavinb> kimundi: oh just trtying to take a stab in the dark to answer eddyb’s question above
[22:31:21] <eddyb> gavinb: very dark
[22:31:26] <eddyb> gavinb: traits have explicit names
[22:31:27] *** Quits: jviereck (Adium@moz-7859BAFE.dclient.hispeed.ch) (Ping timeout)
[22:31:31] <gavinb> eddyb: :-P
[22:31:43] <eddyb> gavinb: <T: Trait> has short T and long Trait for a reason
[22:31:57] <strcat> benh: we have guard pages but...
[22:31:58] <kimundi> gavinb: Ah, you mean "In case A and B are generic type paramters themself" ?
[22:32:12] <strcat> benh: LLVM doesn't know how to use them to implement guaranteed stack safety like GCC can with -fcheck-stack
[22:32:13] *** Joins: brson (brson@moz-62518563.mtv2.mozilla.com)
[22:32:13] *** ChanServ sets mode: +ao brson brson
[22:32:14] <eddyb> kimundi: I hope not
[22:32:18] <strcat> benh: so we still use the segmented stack prelude
[22:32:23] <kimundi> gavinb: Traits are not types, so that is not possible
[22:32:25] *** Joins: eibwen (kvirc@moz-A47B471B.dip0.t-ipconnect.de)
[22:32:35] <eddyb> kimundi: pretty sure they mean <T: TraitA + TraitB> :P
[22:32:40] <benh> just wondering how to fix that quoted bit from the ffi guide
[22:33:30] *** Joins: jviereck (Adium@moz-839AFA2F.dclient.hispeed.ch)
[22:33:35] <gavinb> yeah, a type constrained by more than one trait.
[22:33:50] <eddyb> gavinb: impossible atm
[22:34:04] *** Joins: Jesse_ (jruderman@moz-62518563.mtv2.mozilla.com)
[22:34:11] <eddyb> also, no inheritance (hopefully ever) so I don't see what that could do
[22:34:17] *** Quits: Jesse (jruderman@moz-62518563.mtv2.mozilla.com) (Connection reset by peer)
[22:34:19] <eddyb> gavinb: aaah
[22:34:24] <eddyb> gavinb: it's late here :P
[22:34:34] <eddyb> gavinb: I read that as "by more than a trait"
[22:34:46] <eddyb> gavinb: as you were
[22:34:52] <pcwalton> gavinb and gavin are not the same person, I assume
[22:34:56] <gavinb> eddyb: heh s’ok, I’m rushing to work and operating with zero caffeine in my system!
[22:35:00] *** Quits: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP) (Input/output error)
[22:35:11] <eddyb> I should rush to bed before it's morning
[22:35:21] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[22:35:33] <gavinb> pcwalton: I don’t use another handle here, if that’s what you mean
[22:35:40] *** Quits: brson (brson@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[22:35:41] <pcwalton> ok :)
[22:35:53] *** Joins: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[22:36:11] *** Quits: jdavis (jdavis@moz-1BE8A6A1.hsd1.ca.comcast.net) (Ping timeout)
[22:36:16] *** Quits: Armavica (virgile@moz-AD428ED7.ens.fr) (Quit: leaving)
[22:36:26] <gavinb> pcwalton: is there some other dude who comes in here randomly and asks vague questions and abuses type terminology? :-P
[22:36:28] *** Joins: Armavica (virgile@moz-AD428ED7.ens.fr)
[22:36:36] <pcwalton> I was just curious
[22:36:36] *** Joins: ktt3ja (ktt3ja@moz-8D2A07E1.hsd1.va.comcast.net)
[22:36:51] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[22:37:01] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[22:37:11] <o11c> pcwalton: which one is the gavinbot of lore?
[22:37:13] <bpicolo> gavinb: I abuse all terminology
[22:37:15] *** Joins: pongad (pongad@moz-7E8AAD2E.res.gatech.edu)
[22:37:22] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[22:37:26] <gavinb> bpicolo: that’s what it’s there for. Like standards.
[22:37:45] <bpicolo> gavinb: I just don't know it yet so it's all like, "Yeah, the type thing in the name place"
[22:37:54] <bpicolo> with the attr and stuff
[22:37:55] *** Joins: lerc (quassel@moz-82B68322.telstraclear.net)
[22:38:05] <gavinb> bpicolo: totes :)
[22:38:12] *** Joins: calatalee (Mibbit@moz-D676F490.dhcp.embarqhsd.net)
[22:38:13] <cmr> https://github.com/mozilla/rust/wiki/The-Rusticon
[22:38:20] <cmr> never be confused with terms again!
[22:38:24] <bpicolo> oooh
[22:38:27] <bpicolo> thank you.
[22:38:34] <eddyb> cmr: can I get a hard cover edition?
[22:38:44] <bpicolo> cafepress? : P
[22:38:45] <eddyb> cmr: with spider skin covers, preferably :D
[22:38:49] <gavinb> cmr: Oh how apropos!
[22:39:02] <gavinb> eddyb: off to work I go - thanks for your patience… I think a few more pennies and I’ll have something useful working.
[22:39:03] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[22:39:11] *** Quits: calatalee (Mibbit@moz-D676F490.dhcp.embarqhsd.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:39:22] <eddyb> gavinb: and I thought I was poor :P
[22:39:37] *** Quits: csherratt (csherratt@moz-F23E0824.eng.wind.ca) (Quit: csherratt)
[22:39:53] <gavinb> heh, as in “pennies dropping”
[22:40:23] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[22:40:34] *** Quits: gavinb (gavinb@B421F273.56843BDB.354B30E7.IP) (Quit: gavinb)
[22:40:39] *** vfetwnuncszu is now known as dcrewi
[22:40:46] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[22:41:45] *** Joins: brson (brson@moz-62518563.mtv2.mozilla.com)
[22:41:45] *** ChanServ sets mode: +ao brson brson
[22:42:01] <eddyb> cmr: "Refers both to the type (&fn, ~fn)" pffft needs update
[22:42:08] *** Joins: raisin (Mibbit@moz-A16C0390.hsd1.md.comcast.net)
[22:42:09] *** Quits: Axord (xord@moz-BC8E2FBC.static.rvsd.ca.charter.com) (Quit: I'm sure it's perfectly safe)
[22:42:22] *** kimundi is now known as zz_kimundi
[22:42:22] <cmr> eddyb: it's a wiki, you have a github account.
[22:42:24] *** Quits: abaez (a__@moz-8D618AC3.nycmny.fios.verizon.net) (Connection reset by peer)
[22:42:54] <eddyb> cmr: I totally read that last part as "you have a shovel"
[22:43:05] <pongad> I just read Alex's reminder that ~[T] is not going away. Is there any advantage to using it instead of Vec<T>? It seems Vec can be made to implement everything ~[T] has but it's growable.
[22:43:20] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[22:43:24] <cmr> pongad: it's a word smaller.
[22:43:36] *** Quits: raisin (Mibbit@moz-A16C0390.hsd1.md.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:43:41] <eddyb> pongad: i.e. you know when you'll need it
[22:43:54] <eddyb> pongad: (because your structures will be hundreds of MBs in size)
[22:44:18] <pongad> Ahh...33% reduction in mem footprint. Gotcha :D
[22:44:31] <pongad> Thanks cmr and eddyb :D
[22:44:40] <jxs> hey guys, is version .10 locked? if so is it going to include the new priv by default fields of struct?
[22:44:49] <eddyb> 33% if literally everything you allocate is vectors
[22:44:55] *** Joins: abaez (a__@moz-8D618AC3.nycmny.fios.verizon.net)
[22:45:01] *** Joins: jdavis (jdavis@moz-1BE8A6A1.hsd1.ca.comcast.net)
[22:45:25] <mcpherrin> jxs: There's release candidates out, you could check
[22:45:52] <cmr> The release notes are in, too, so it's unlikely.
[22:46:24] *** Quits: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net) (Quit: carllerche)
[22:46:27] <pongad> eddyb: You are right xD Vectors that don't contain anything
[22:46:48] <eddyb> pongad: Vec<Vec<Vec<()>>>
[22:47:05] <pongad> eddyb: Dammit
[22:47:13] <eddyb> (hint: the inner Vec<()> is kinda equivalent to an oversized uint :P)
[22:48:34] <o11c> there are use cases where you're likely to have a lot of empty and almost-empty vectors 
[22:48:55] *** Quits: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net) (Ping timeout)
[22:49:09] <eddyb> or enums with vectors where the variants bloated by the vectors are rare
[22:49:15] *** Joins: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net)
[22:49:22] <eddyb> but in some of those cases you'd rather reach for Rc<[T]> & friends
[22:49:45] <zwarich> strcat: I need to increase the scrollback for this channel, but did you find the bug / the IR for the excess null pointer check?
[22:49:48] *** Quits: Sorella (quildreen@AA4589ED.97245BEB.1ED99692.IP) (Quit: Ex-Chat)
[22:49:54] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[22:50:13] *** Quits: rootnode (rootnode@moz-5B1AE0C8.pools.arcor-ip.net) (Ping timeout)
[22:50:14] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[22:50:39] <strcat> zwarich: yes https://github.com/mozilla/rust/issues/11751
[22:50:41] *** vfetwnuncszu is now known as dcrewi
[22:50:43] *** Joins: jensnockert (jensnocker@moz-33279404.customers.ownit.se)
[22:51:27] <strcat> zwarich: there are irc clients with infinite scrollback ;p
[22:51:37] <strcat> they just start loading from on-disk logs
[22:51:46] <eddyb> strcat: I know when I broke my N900 console
[22:51:54] <zwarich> strcat: I freely admit I have no rational reason for using Colloquy
[22:51:56] <eddyb> strcat: by increasing the xterm scrollback to infinity
[22:52:17] *** Quits: brson (brson@moz-62518563.mtv2.mozilla.com) (Ping timeout)
[22:52:28] *** Joins: andrewd18 (andrew@moz-DAC9D29F.wi.res.rr.com)
[22:52:33] *** Quits: jensnockert (jensnocker@moz-33279404.customers.ownit.se) (Ping timeout)
[22:53:06] *** Joins: dpc_ (Mibbit@moz-88B014CD.nvidia.com)
[22:53:07] <zwarich> strcat: in this case, I think that better LLVM optimizations could catch this without any attribution
[22:53:36] <dpc_> Rustydoc does not produce any files except sekeleton ones (css, js). What could be the reason?
[22:53:42] <zwarich> strcat: the pointer comes from a phi, and both incoming branches are control dependent on a load from the phi operand
[22:54:03] <strcat> zwarich: I think it has even learned to optimize *some* since we discovered this, but it would still be nice to be able to leverage what we know about references
[22:54:09] <cmr> dpc_: no public items.
[22:54:18] <dpc_> Hmm ...
[22:54:37] <zwarich> this same general problem comes up with anything that propagates a constraint on a value, LLVM is so bad at dealing with this
[22:54:42] *** Joins: canhtak (canhtak@moz-4FB0FBC1.wl.t.ulaval.ca)
[22:54:50] <strcat> zwarich: one of the things that the sret attribute does is tell LLVM that the pointer points at dereferenceable memory, which is why we use it at all
[22:55:07] <strcat> if you could mark parameters as being able to dereference the memory they point at, that'd help
[22:55:13] <strcat> (even more than non-null)
[22:55:24] *** Quits: Nekit1234007 (Nekit12340@A4D1747.7796E3F4.4707F662.IP) (Input/output error)
[22:55:32] <strcat> because we know an &T in a parameter points at a valid object
[22:55:47] <zwarich> it's tricky after inlining, since the parameter attribute will go away and LLVM doesn't have 'type attributes' or something similar for arbitrary IR values
[22:55:53] <strcat> LLVM doesn't really have any infrastructure for telling it that we know the *contained* stuff it non-null/valid though
[22:55:55] <strcat> zwarich: yeah
[22:55:56] <zwarich> you could use an intrinsic that just copies the value, but that's ugly too
[22:56:05] <strcat> tbaa metadata could have 'non-null'...
[22:56:06] *** Joins: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP)
[22:56:12] <zwarich> and will make SSA optimizations not work
[22:56:26] *** Quits: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net) (Ping timeout)
[22:56:39] <strcat> can you put tbaa metadata on parameters?
[22:56:43] *** Joins: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net)
[22:56:58] *** Joins: Nekit1234007 (Nekit12340@A4D1747.7796E3F4.4707F662.IP)
[22:57:02] <zwarich> strcat: yeah, but since TBAA data goes on the mem op, you would have to mark the load as "this load doesn't load from a non-null pointer" and then work backwards to eliminate the check, which seems hard
[22:57:16] <zwarich> err
[22:57:22] <zwarich> "this load doesn't load from a null pointer"
[22:57:32] *** Quits: dcrewi (david@moz-AB8667CE.gyrae.net) (Ping timeout)
[22:57:57] *** Quits: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com) (Quit: Leaving.)
[22:58:50] *** Joins: vfetwnuncszu (david@moz-AB8667CE.gyrae.net)
[22:58:54] *** Joins: brson (brson@moz-62518563.mtv2.mozilla.com)
[22:58:54] *** ChanServ sets mode: +ao brson brson
[22:59:00] *** jorendorff is now known as jorendorff_away
[22:59:00] <pongad> Actually...what's the fate of ~str?
[22:59:05] *** vfetwnuncszu is now known as dcrewi
[23:00:06] *** Joins: radford (Adium@moz-AC76BE6B.dhcp.mtpk.ca.charter.com)
[23:00:56] <bvssvni> pongad: StrBuf will have .push(), but if you don't need it you can use ~str
[23:01:41] <Tobba> uhhh
[23:01:47] <Tobba> I'm find()'ing something out of a TreeMap
[23:01:59] <pongad> bvssvni: So... Vec<T>:~[T] <-> StrBuf:~str kind of?
[23:02:02] <Tobba> this somehow borrows the entirety of self immutably and prevents me from mutating it
[23:02:04] <dpc_> But how do I use rustydoc on a binary? Should I mark everything as public?
[23:02:08] <strcat> pongad: s/kind of/exactly/
[23:02:13] *** Quits: Savago (Savago@504D6CF1.5315C0D2.4C2245EF.IP) (Quit: Savago)
[23:02:18] *** Joins: Axord (xord@moz-BC8E2FBC.static.rvsd.ca.charter.com)
[23:02:24] <pongad> Alrighty
[23:02:25] <SiegeLord> If StrBuf is used often, hopefully it won't be called StrBuf :P
[23:02:34] <strcat> dpc_: maybe run it on a specific module?
[23:02:42] *** Quits: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP) (Input/output error)
[23:03:03] *** Quits: arielb1 (arielb1@moz-8F646A97.red.bezeqint.net) (Ping timeout)
[23:03:04] *** Joins: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net)
[23:03:35] *** Joins: krdln (krdln@moz-C271714F.dynamic.chello.pl)
[23:03:39] <zwarich> strcat: I might try to fix the LLVM CorrelatedValuePropagation pass to handle this case
[23:03:43] *** Parts: krdln (krdln@moz-C271714F.dynamic.chello.pl) ()
[23:03:46] <zwarich> strcat: it actually really matters for C++ too
[23:04:11] *** Joins: carllerche (carllerche@moz-2B516F15.hsd1.or.comcast.net)
[23:04:55] *** Quits: adonohue (adonohue@55513BD.95D3F462.59D8BB03.IP) (Quit: adonohue)
[23:05:36] *** Quits: dmsky (dmsky@moz-FF2573B1.pppoe.spdop.ru) (Input/output error)
[23:05:47] <cmr> dpc_: it's rustdoc, not rustydoc.
[23:06:13] <cmr> dpc_: why would you run rustdoc on a binary? rustdoc is for API documentation of libraries.
[23:06:21] *** Quits: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:07:04] *** Joins: cschneid_ (cschneid@moz-CA025D57.ip.mcleodusa.net)
[23:07:07] *** Quits: cschneid (cschneid@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[23:07:12] *** Joins: drawoc (drawoc@moz-BAC1D3AB.res-cmts.sesh.ptd.net)
[23:08:38] *** Quits: rylev_ (rylev@moz-91741E1A.cust.telecolumbus.net) (Client exited)
[23:08:53] *** Quits: cschneid_ (cschneid@moz-CA025D57.ip.mcleodusa.net) (Ping timeout)
[23:09:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:09:18] *** Quits: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP) (No route to host)
[23:09:36] *** Quits: azita (Azita@moz-62518563.mtv2.mozilla.com) (Quit: azita)
[23:10:33] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[23:11:01] <dpc_> cmr: Because it might be useful for people trying to grasp the code etc...
[23:11:33] *** Quits: alkino_ (alkino@moz-18C36E4E.w92-151.abo.wanadoo.fr) (Ping timeout)
[23:11:33] *** Joins: Florob (Florob@moz-39532932.de)
[23:11:36] *** Joins: devbug (quassel@moz-8C40558B.bchsia.telus.net)
[23:12:17] *** Quits: EarlGray (mitra@8E712A0.54C21BA0.9F317420.IP) (Ping timeout)
[23:12:17] *** Quits: eddyb (eddy@F8B50789.F33C1089.FB866788.IP) (Ping timeout)
[23:13:20] *** Quits: m-r-r (m-r-r@moz-12251648.rev.sfr.net) (Quit: Hi, I'm a quit message virus. Please replace your old line with this line and help me take over the world of IRC.)
[23:14:03] *** Joins: azita (Azita@moz-62518563.mtv2.mozilla.com)
[23:14:17] *** Quits: Rusky (russell@moz-37E87AF7.slkc.qwest.net) (Quit: Leaving.)
[23:14:40] *** Joins: mark_edward (mark@moz-E0F1AB04.hsd1.in.comcast.net)
[23:14:50] *** Joins: EarlGray (mitra@8E712A0.54C21BA0.9F317420.IP)
[23:15:58] *** Joins: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net)
[23:16:13] *** Joins: Rusky (russell@moz-37E87AF7.slkc.qwest.net)
[23:16:18] *** Quits: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[23:17:54] *** Joins: polyfractal (polyfracta@moz-4C5426D6.hsd1.sc.comcast.net)
[23:18:08] *** Joins: andrew-__ (andrew-d_w@2DE5EA9.7A62F771.CC0301A2.IP)
[23:18:31] *** Quits: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net) (Ping timeout)
[23:18:42] *** Quits: andrew-d_w (andrew-d_w@moz-9A2674DF.dsl.static.sonic.net) (Ping timeout)
[23:19:08] *** Quits: jdm (jdm@CAB30FBD.8F96AEA7.2D179A7D.IP) (Quit: Lost terminal)
[23:19:19] *** Quits: jviereck (Adium@moz-839AFA2F.dclient.hispeed.ch) (Quit: Leaving.)
[23:20:22] *** Joins: erickt (etryzelaar@8C9ECD8F.3A598286.F12515B4.IP)
[23:21:29] *** Joins: Sgeo (quassel@moz-4E71E7BB.dyn.optonline.net)
[23:22:14] *** Quits: pczarn (pczarn@moz-69A55FA.izacom.pl) (Input/output error)
[23:23:06] *** Joins: pczarn (pczarn@moz-69A55FA.izacom.pl)
[23:23:10] *** Quits: skade (skade@moz-6444221B.dip0.t-ipconnect.de) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[23:23:40] *** Joins: ryeguy (ryeguy@9C569A0.5D1143CD.E8644521.IP)
[23:23:46] *** Joins: csherratt (csherratt@moz-F23E0824.eng.wind.ca)
[23:24:23] *** Quits: csherratt (csherratt@moz-F23E0824.eng.wind.ca) (Quit: csherratt)
[23:24:57] *** Quits: pczarn (pczarn@moz-69A55FA.izacom.pl) (Broken pipe)
[23:25:19] *** Quits: ktt3ja (ktt3ja@moz-8D2A07E1.hsd1.va.comcast.net) (Quit: Leaving)
[23:27:52] *** Quits: twi (Adium@moz-429185BE.cust.vodafonedsl.it) (Quit: Leaving.)
[23:28:05] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[23:28:06] *** Joins: asmyers (quassel@moz-71754EDC.hsd1.md.comcast.net)
[23:32:56] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:37:04] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[23:37:31] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:38:38] *** Quits: azita (Azita@moz-62518563.mtv2.mozilla.com) (Quit: azita)
[23:38:49] *** Joins: jviereck (Adium@moz-839AFA2F.dclient.hispeed.ch)
[23:39:54] *** Quits: dpc_ (Mibbit@moz-88B014CD.nvidia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[23:41:21] <kmc> what's the current best practice for profiling rust code?
[23:41:42] <strcat> kmc: existing C/C++ debuggers work
[23:41:47] *** Quits: eibwen (kvirc@moz-A47B471B.dip0.t-ipconnect.de) (Ping timeout)
[23:41:49] <strcat> (and profilers)
[23:41:50] *** Quits: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com) (Quit: tobytailor)
[23:42:01] * strcat is happy with perf
[23:42:24] <strcat> perf record / perf trace
[23:43:17] *** Quits: tethra (tethra@moz-87614AA7.default.tethra.uk0.bigv.io) (Client exited)
[23:46:25] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[23:51:19] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[23:52:33] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[23:53:46] *** Quits: jviereck (Adium@moz-839AFA2F.dclient.hispeed.ch) (Quit: Leaving.)
[23:55:36] *** Quits: bpicolo (Adium@moz-B475EB64.static-ip.telepacific.net) (Quit: Leaving.)
[23:56:13] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[23:56:28] <meyer> The "master" documentation doesn't match the current "master" Rust. 
[23:57:00] <meyer> Specifically, (probably among more), https://github.com/mozilla/rust/commit/c5d85560a98940e7938d0b074d7d0a9ec6a417c5#diff-7c3a74d1b972a44ba2bae67631f2aae4R206 is not reflected in http://static.rust-lang.org/doc/master/rand/index.html
[23:57:13] <cmr> meyer: known problem, the doc bot is no longer in a state of existence.
[23:57:54] <meyer> Alright. 
[23:58:21] *** Joins: tobytailor (tobytailor@moz-DFAA4E15.p2p.sfo1.mozilla.com)
[23:58:49] <sfackler> the docs builds do seem to have updated
[23:59:07] <sfackler> the rand changes may just be too new
[23:59:15] <meyer> 7 days ago

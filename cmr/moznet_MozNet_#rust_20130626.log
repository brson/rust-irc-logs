[00:01:20] *** Quits: jedestep (jedestep@moz-2C53377F.natpool.nyu.edu) (Quit: jedestep)
[00:02:41] *** Joins: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au)
[00:02:53] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:03:03] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[00:03:52] <aatch> strcat, ok, this is a wierd line from the IR:
[00:04:07] <aatch>   br i1 icmp eq (i64* getelementptr inbounds ([5 x i64]* @const, i64 0, i64 0), i64* inttoptr (i64 add (i64 ptrtoint ([5 x i64]* @const to i64), i64 40) to i64*)), label %_ZN4main16_d7d397690bb61803_00E.exit, label %_ZN3vec14__extensions__9next_295816_3923985398cb8903_00E.exit.i.i
[00:04:53] <strcat> huh
[00:05:11] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[00:06:38] <aatch> That instruction does a branch based on whether the pointer to the first element equals a pointer to 1 element _after_ the array.
[00:06:49] *** Joins: joelteon (joel@moz-317E8D0C.io)
[00:06:51] <strcat> aatch: yep that's fine
[00:07:17] <strcat> C++ uses the same 'end iterator' thing
[00:07:24] <strcat> just visible externally
[00:07:37] <aatch> strcat, really? but it's the first line in the block...
[00:07:41] <aatch> The function I mean
[00:07:58] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[00:08:00] <strcat> aatch: well dit doesn't make sense that it's comparing a pointer to the first element...
[00:08:13] <strcat> aatch: unless that's the whole check
[00:08:23] <strcat> here's what it's supposed to do
[00:08:31] <aatch> It's only got constants in the expression, too
[00:08:39] <strcat> let begin = ptr_to_start; let end = ptr_one_past_end;
[00:09:10] <strcat> loop { if begin == end { break } /* do stuff */ begin++; }
[00:09:34] <strcat> s/begin/current/
[00:09:35] <doener> that looks like it's the stuff that happens with "al"
[00:10:04] <aatch> Hmm, I think it's just that our passes aren't quite tuned correctly yet.
[00:10:07] <strcat> aatch: are you looking at the unoptimized IR?
[00:10:12] <aatch> strcat, no
[00:10:15] <strcat> we are generating undef IR
[00:10:19] <strcat> it doesn't mean anything about LLVM
[00:10:21] <strcat> it can do whatever
[00:10:39] <strcat> can't accuse LLVM of having bugs or not optimizing well if our IR is invalid ;p
[00:11:02] <strcat> http://ix.io/6mK anyway that's the full next call
[00:11:21] <aatch> strcat, yeah, but that exact line can be optimized down via constant folding. Like I said, I think our passes aren't tuned correctly.
[00:11:27] <strcat> http://ix.io/6mL and that's fold
[00:11:34] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[00:11:46] <strcat> aatch: it won't necessarily be optimized down if there's undef behaviour
[00:12:16] <strcat> and there is undef behaviour with each iteration of the loop from cast::transmute being implemented incorrectly
[00:13:02] <aatch> strcat, LLVM isn't like that though. The most likely explanation here is that, that^^^, was created by licm, but nothing came along later to deal with it.
[00:13:09] * strcat shrugs
[00:13:21] <strcat> I don't think we can reason about it before fixing the undef behaviour
[00:13:26] <strcat> it wasn't inlining glue before because of that
[00:13:30] <strcat> it does seem to work that way.
[00:13:58] <strcat> and it doesn't always inline transmute because we do undef casts on it
[00:14:07] <jclements> rusti: 3
[00:14:08] -rusti- 3
[00:14:25] <jclements> rusti: ptr_eq(@~"abc",@~"abc")
[00:14:25] -rusti- <anon>:9:9: 9:15 error: unresolved name `ptr_eq`.
[00:14:25] -rusti- <anon>:9          ptr_eq(@~"abc",@~"abc")
[00:14:25] -rusti-                   ^~~~~~
[00:14:25] -rusti- error: aborting due to previous error
[00:14:26] -rusti- application terminated with error code 101
[00:14:32] <aatch> strcat, it doesn't do _some_ things because of undef behaviour. More often than not it does things it _shouldn't_ because of undef.
[00:14:45] <jclements> rusti: std::managed::ptr_eq(@~"abc",@~"abc")
[00:14:46] -rusti- false
[00:14:55] <strcat> aatch: we don't have any guarantees on what it will/won't do
[00:14:59] <jclements> rusti: std::managed::ptr_eq(@"abc",@"abc")
[00:15:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/IRGG
[00:15:26] <jclements> simple rtfm-style question: why can't I use ptr_eq on values of type @str?
[00:15:27] <strcat> it could just not optimize, or it could remove the whole function body - pointless to reason about before fixing it imo
[00:15:37] <cmr> jclements: good question :s
[00:15:40] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[00:15:41] <strcat> jclements: @str isn't @T
[00:15:47] <strcat> it's a type by itself
[00:15:48] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[00:15:48] *** ChanServ sets mode: +o dherman
[00:16:05] <jclements> strcat: is there a way to perform a constant-time pointer comparison on two values of type @str?
[00:16:47] <strcat> jclements: with transmute
[00:16:53] <aatch> strcat, I know, but just as you're saying that we can't reason about anything until we fix the undef, I'm saying it's silly to to not think about other reasons in the meantime.
[00:16:54] <cmr> jclements: you are/were a parser guy, right?
[00:17:02] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[00:17:14] <jclements> cmr: have my parser powers been revoked? :)
[00:17:17] <jclements> cmr: yes.
[00:17:21] <strcat> jclements: http://smallcultfollowing.com/babysteps/blog/2013/04/30/dynamically-sized-types/ related to that, btw
[00:17:37] <cmr> jclements: no, but I've been doing some cleanup in libsyntax and would like to bump heads if you're going to be touching stuff
[00:18:16] <bblum> steven_is_false: i had a couple of bones to pick on your RWARC pull request;
[00:18:24] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[00:18:28] <jclements> cmr: yes, I have all kinds of pending changes. typically I just cry and rebase when someone changes something. It's generous of you to warn me ahead of time, though. ...
[00:18:32] <bblum> steven_is_false: also, if you could explain why you think the interface is a mess, i am curious why you think that
[00:18:41] <jclements> cmr: what kind of changes
[00:18:55] <aatch> cmr, if you want to be really, really awesome in terms of cleaning up libsyntax, re-writing the AST visitor as a trait would be magnificent
[00:19:01] <cmr> jclements: well right now I've been trying to kill @str :p
[00:19:44] <jclements> cmr: sounds like funâ€¦ I'm consciously trying to avoid that kind of housekeeping work right now, to get hygiene working in the next three weeks.
[00:20:06] <cmr> jclements: I have https://github.com/mozilla/rust/pull/7365 pending right now (originally I had a new generic interner but it turned out to be too frustrating to deal with)
[00:20:13] <jclements> cmr: I should warn you that those projects always seem to balloon out of control for me.
[00:20:17] <cmr> aatch: to my list
[00:20:30] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[00:20:43] <cmr> jclements: well I don't plan on finishing until libsyntax is good and efficient.
[00:20:46] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[00:20:46] <aatch> cmr, I may get there first, but since you're working around there anyway.
[00:20:58] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[00:20:59] <cmr> aatch: I won't be getting to the AST visitor for a bit
[00:21:08] <cmr> jclements: my scope is already as big as it can get I think :p
[00:21:27] <cmr> jclements: if it's going to interfere with your real work I can work on rustdoc instead
[00:21:37] <cmr> (which I defered so I wouldn't have to use @ everywhere in it)
[00:21:43] <jclements> cmr: well, I'll tell you if a change conflicts with hygiene. no, definitely don't stop working on syntax.
[00:21:49] <cmr> jclements: ok :)
[00:22:59] <cmr> Btw it'd be nice if someone could r+ https://github.com/mozilla/rust/pull/7365
[00:23:24] <cmr> I don't want to be rebasing it constantly :p
[00:23:34] <aatch> jclements, when you're done with hygiene, could you get empty sequences (ala [ $($a:indent) ] ) working :P
[00:24:08] *** Quits: jst (quassel@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:24:20] *** Joins: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com)
[00:24:49] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[00:25:11] <aatch> cmr, any reason why you have `extern mod extra` in attr.rs?
[00:25:31] *** Quits: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net) (Quit: Leaving.)
[00:25:33] <cmr> aatch: uses extra::sort
[00:25:34] *** Joins: Diamond (dick@moz-C01E1CD1.ks.ks.cox.net)
[00:25:45] <aatch> since it's already in syntax.rs
[00:25:49] <cmr> aatch: and that didn't resolve until I added extern mod extra, dunno why, it's in syntax.rs
[00:25:57] <jclements> aatch: right now there is pretty much no chance of my getting anything other than hygiene done while I'm full-time at Mozilla....
[00:26:19] <aatch> jclements, aww... Oh well...
[00:26:24] <dbaupp> cmr: you probably need `use extra` or `use extra::sort`, or `::extra::sort::...`
[00:26:39] <cmr> dbaupp: silly!
[00:26:45] *** Joins: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de)
[00:27:03] <cmr> anyway it may have been me doing something in an interim state
[00:27:11] <cmr> like not writing to syntax.rs before trying the build
[00:27:22] <aatch> I can just imagine it causing problems, it shouldn't, but it might.
[00:27:53] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:27:54] <cmr>  "use extra;" worked
[00:27:58] <aatch> Otherwise, it looks fine to me.
[00:28:01] <cmr> *why* is that necessary :S
[00:28:18] <cmr> aatch: pushed the removal
[00:29:12] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[00:29:18] <cmr> guh silly shell expansion replaced my `...`
[00:29:24] <cmr> ah well
[00:29:25] *** Joins: jedestep (jedestep@moz-C68A1C79.natpool.nyu.edu)
[00:29:30] <aatch> cmr, because `extern mod extra;` only says that you use the mod in the crate, it also brings the crate-module into the current module's scope.
[00:29:49] <cmr> aatch: Shouldn't it already be in scope since it's in the toplevel mod?
[00:29:59] <aatch> cmr, hmm, maybe
[00:30:12] <aatch> I'm not sure about how resolve works.
[00:30:15] <cmr> neither am I
[00:30:22] <cmr> I don't think anyone is
[00:30:22] <aatch> I don't think anyone other than pcwalton is.
[00:30:25] <cmr> heh
[00:30:36] <pcwalton> I know how resolve works
[00:30:39] <pcwalton> more or less
[00:30:55] <cmr> When I was rutting around resolve it *seemed* well-written...
[00:31:04] <cmr> or, at least, well organized
[00:31:07] <pcwalton> it's not bad
[00:31:08] <pcwalton> it's just big
[00:31:08] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[00:31:10] <cmr> there's just so much of it
[00:31:12] <cmr> yeah
[00:31:19] <pcwalton> name resolution in Rust is complicated and nobody believes me when I say that it is :)
[00:31:40] * pcwalton grumbles about everyone wanting "just one more feature"
[00:31:41] <pcwalton> anyway
[00:32:22] <pcwalton> resolve could be less complicated
[00:32:25] *** Quits: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au) (Ping timeout)
[00:32:28] <pcwalton> it doesn't need a fixed point algorithm
[00:32:34] <pcwalton> that was needed to resolve earlier versions of Rust
[00:32:39] <pcwalton> but it is not needed now
[00:32:45] <aatch> pcwalton, I wasn't saying it was bad, just that is was complicated.
[00:32:53] <pcwalton> I know :)
[00:33:12] <bblum> good, we all agree that it is complicated
[00:33:15] <pcwalton> privacy should be yanked out of resolve too and moved into privacy.rs
[00:33:52] * pcwalton is currently working with something far worse than rustc
[00:33:56] <pcwalton> (Xlib)
[00:34:02] <aatch> pcwalton, why?
[00:34:03] <cmr> so sorry :(
[00:34:07] <pcwalton> XCB actually
[00:34:12] <pcwalton> creating off-screen GL contexts for servo
[00:34:20] <aatch> pcwalton, hey, xcb isn't that bad...
[00:34:23] <cmr> is that even possible with GLX?
[00:34:29] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:34:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/N9Kl3g
[00:34:29] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:34:30] <pcwalton> well, XCB-GLX is almost totally undocumented :)
[00:34:34] <Luqman> pcwalton: you closed 3446 but there's still a FIXME in middle/trans/meth. is it still relevant?
[00:34:35] <pcwalton> I believe it is
[00:34:41] <aatch> pcwalton, I'll give you that.
[00:34:53] * cmr thought mesa/egl had its own indirect render code separate from glx
[00:34:55] <seth> weird. why might some modules not appear in the output of RUST_LOG=::help?
[00:34:58] <cmr> I could be wrong about that though
[00:35:04] <pcwalton> Luqman: hmm, I guess it is still relevant
[00:35:16] *** Joins: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[00:35:16] <seth> it's actually not just that they're not listed; i can't seem to log from them either
[00:35:24] <steven_is_false> pcwalton: I thought one had to use xlib xcb interop to get that working. They might have changed things though.
[00:35:34] <pcwalton> steven_is_false: oh, so this won't work?
[00:35:45] <pcwalton> there are a bunch of GLX methods that claim to do what I want to do
[00:35:54] <aatch> seth, well the two are probably linked.
[00:36:07] <seth> aatch: yeah, i figured, just wanted to be clear about the symptoms
[00:36:19] <steven_is_false> pcwalton: Some of it didn't work in the past (I'm sure a few things worked.) I don't know if what you want to do will work now.
[00:36:29] <pcwalton> well, I'll try
[00:36:39] *** Joins: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au)
[00:36:42] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[00:36:49] <aatch> seth, stupid question time: Have you tried making sure that the code in those modules is called at all?
[00:37:06] <seth> aatch: it definitely is
[00:37:30] <seth> aatch: i use several types from that module in other crates, so i know it's both called and exported
[00:37:31] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:37:31] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/atRrow
[00:37:31] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:37:33] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[00:37:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/e8_70Q
[00:37:34] <ghrust> 13rust/06auto 141dd749e 15Luqman Aden: Change finalize -> drop.
[00:37:34] <ghrust> 13rust/06auto 14017d25d 15bors: auto merge of #7269 : luqmana/rust/drop, r=thestinger,cmr...
[00:37:34] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[00:37:46] <aatch> seth, ok. Have you tried replacing the log calls with printlns?
[00:37:50] <strcat> no more 'each' (on vectors at least)
[00:37:58] <strcat> https://github.com/mozilla/rust/compare/4967bd0508a4...efd1438770ae \o/
[00:39:13] *** Joins: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net)
[00:39:13] *** ChanServ sets mode: +o tjc
[00:39:40] <incDec> how do you use str::as_bytes() within a source file?
[00:39:56] <cmr> rusti: use std::str; str::as_bytes("foo")
[00:39:58] -rusti- <anon>:9:23: 9:36 error: unresolved name `str::as_bytes`.
[00:39:59] -rusti- <anon>:9          use std::str; str::as_bytes("foo")
[00:39:59] -rusti-                                 ^~~~~~~~~~~~~
[00:39:59] -rusti- error: aborting due to previous error
[00:39:59] -rusti- application terminated with error code 101
[00:40:06] <cmr> oh it's bytes_iter now
[00:40:09] <incDec> doesn't compile for me
[00:40:17] <cmr> incDec: are you using 0.6?
[00:40:20] <dbaupp> incDec: what version of rust?
[00:40:24] <incDec> 0.6
[00:40:34] <dbaupp> what's the error message you get?
[00:40:41] <incDec> let try it again
[00:40:55] <cmr> you shouldn't need to do anything in 0.6 to use str::as_bytes
[00:40:55] <incDec> *let me try it again
[00:40:56] <Eridius> strcat: I wonder if it's worth having a variant of rusti that uses the latest official release (e.g. 0.6 right now)
[00:41:05] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[00:41:07] <Eridius> strcat: so you could say rusti-0.6: foo
[00:41:11] <strcat> Eridius: why?
[00:41:19] <strcat> I don't think there's a reason to suggest using 0.6
[00:41:26] <Eridius> strcat: to help people who come here and are using the latest release
[00:41:36] <aatch> Eridius, people should be using the latest master most of the time.
[00:41:38] <Eridius> strcat: well people new to the language aren't going to want their very first act to be "spend an hour compiling"
[00:41:48] <cmr> dbaupp: I wrote a matplotlib plotter
[00:41:54] <strcat> Eridius: so why don't we have nightly build of master?
[00:42:08] <dbaupp> cmr: cool! example? :)
[00:42:11] <Eridius> strcat: maybe we should
[00:42:13] *** Quits: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au) (Ping timeout)
[00:42:17] <strcat> I provide them in an Arch Linux repository, don't know why they aren't available for other OSes
[00:42:20] <dbaupp> strcat: we sorta do
[00:42:21] <pcwalton> we should
[00:42:32] <acrichto> r? https://github.com/mozilla/rust/pull/7113
[00:42:36] <incDec> I'm trying to print out the converted string using println and fmt!, but which format specifier do I use?
[00:42:39] <dbaupp> strcat: each auto build could be a "nightly" build, couldn't it?
[00:42:40] <aatch> I wonder if we could use the snapshots as pseudo releases.
[00:42:49] <Eridius> but I mean if the general attitude is "don't use 0.6, use master" for everyone, then why even provide dot-releases?
[00:42:55] <strcat> http://pkgbuild.com/~thestinger/repo/x86_64/ wouldn't be surprised if these worked on most Linux distros though
[00:43:06] <strcat> ;p
[00:43:08] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[00:43:12] <strcat> Eridius: they are milestones
[00:43:22] <strcat> they're just an arbitrary milestone for marking progress
[00:43:29] <Eridius> incDec: use %?
[00:43:30] <strcat> I don't think they're a useful thing to *use*
[00:43:38] <cmr> dbaupp: http://i.imgur.com/wKFANnj.png
[00:43:38] <incDec> That doesn't work
[00:43:48] <Eridius> incDec: that prints out the structure of whatever you give it, so if you give it a ~[u8] you'll see something like ~[23, 45, 69] as the output
[00:44:02] <Eridius> incDec: doesn't work how?
[00:44:03] <cmr> dbaupp: runs in like 1/15 the time as the R script
[00:44:07] <strcat> there's no doubt that master is way less buggy than 0.6 was
[00:44:08] <dbaupp> incDec: we can be more helpful you if tell us the error messages :)
[00:44:12] <dbaupp> cmr: heh :D
[00:44:20] <dbaupp> cmr: looks good
[00:44:28] <incDec> The error message given is that there is an unterminated conversion at end of the string
[00:44:33] <cmr> dbaupp: plus matplotlib has an interactive gui so I can do p.show() and be able to zoom/pan
[00:44:41] <dbaupp> cmr: nice
[00:45:00] <cmr> still trying to figure out the Y axis scale and whyt the X axis has the extra padding
[00:45:00] <Eridius> unterminated conversion? I'm not sure what that means. incDec, can you post some code?
[00:45:11] <incDec> by pastebin?
[00:45:15] <cmr> incDec: yes
[00:45:24] <cmr> https://gist.github.com/ is a good one
[00:45:29] <Eridius> <3 gist
[00:45:29] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[00:45:38] <strcat> cmr: also, http://jakevdp.github.io/blog/2012/10/07/xkcd-style-plots-in-matplotlib/
[00:45:41] <strcat> ;p
[00:45:51] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:45:56] <incDec> Here: http://mibpaste.com/smZzi2 
[00:46:09] <MaikKlein> every coder these days uses github.io :D
[00:46:20] <aatch> pcwalton, would it be possible to change the version numbering so that the 0.7 release is '0.7', but the master branch from then is called '0.8pre', in the actual binary.
[00:46:32] <cmr> MaikKlein: because it is so easy and simple
[00:46:32] <Eridius> MaikKlein: github.io isn't a pastebin, it's a gh-pages thing
[00:46:32] <incDec> Sorry, wrong paste
[00:46:47] <pcwalton> I guess so, but brson would know better
[00:46:48] <incDec> Here's the correct one: http://mibpaste.com/wf8wTS 
[00:46:50] <Eridius> aatch: maybe it should use the output of `git describe`
[00:47:23] <aatch> because at the moment, if somebody says 0.6, we don't know if it's 6 months old or 6 hours old.
[00:47:27] <Eridius> incDec: what is this? fmt!("%~[u8]", i)
[00:47:31] <Eridius> that doesn't look like %?
[00:47:37] <Eridius> incDec: you want to just say fmt!("%?", i)
[00:47:44] <incDec> No, that was the incorrect paste
[00:47:47] <MaikKlein> Eridius, I know, he just posted a github.io link
[00:47:58] <incDec> This is the right one: http://mibpaste.com/wf8wTS 
[00:48:09] <Eridius> incDec: that one is literally just %. that's not a format specifier
[00:48:15] <Eridius> the ? is part of the specifier
[00:48:17] <brson> aatch: is the current binary not called 0.7-pre?
[00:48:20] <cmr> brson: no
[00:48:23] <incDec> Oh
[00:48:25] <aatch> brson, not in the binary itself.
[00:48:29] <cmr> rustc 0.6 (d5ed72c 2013-06-24 18:22:44 -0400)
[00:48:33] <aatch> all the libraries are 0.7
[00:48:40] <aatch> 0.7pre, rather
[00:48:44] <pcwalton> where did xcb_pixmap_new go?
[00:48:54] <pcwalton> some tutorials say to use this function but it seems to have gone away
[00:48:56] <cmr> strcat: my graphs are actually used for interpretating data though :p
[00:48:59] <brson> aatch cmr: ok, let's not make that mistake next time ;)
[00:49:05] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[00:49:07] <MaikKlein> I wonder how github is making money.. the private repos must pay them pretty good
[00:49:19] <Eridius> MaikKlein: that and probably the enterprise installs
[00:49:37] <cmr> MaikKlein: I have a paid account, even though I don't use any private repos... supporting the awesome service they provide
[00:50:14] <aatch> I have a couple private repos, mostly for not-ready-for-the-public stuff.
[00:50:40] <aatch> I've learned my lesson about leaving half-finished stuff out in the open. People expect you to finish!
[00:50:45] <cmr> heh
[00:50:48] <MaikKlein> :D
[00:50:48] <Eridius> cmr: I've been using github since day 1 and I've never had a paid account :/ (never needed private repos)
[00:50:56] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[00:50:58] <brson> aatch: the binary version number problem may be due to a bug with snapshots or some other infrastructure. I guess we'll have to test
[00:51:00] <cmr> Eridius: right, nothing wrong with that
[00:51:15] <Eridius> they actually bumped my public repo size limit once, because I had a git mirror of an svn repo that was already over the limit by itself
[00:51:26] <incDec> I tried it with the question mark as part of the format specifier, but now I get these errors: http://mibpaste.com/1DSnku 
[00:51:59] * aatch has recieved emails from people wanting support for half-finished libraries written in a language I hadn't touched in over a year.
[00:52:10] <Eridius> incDec: that pastebin site isn't being very responsive. maybe you should use gist.github.com
[00:52:18] <MaikKlein> how much traffic does the rust repo produce in one month? Any guesses?
[00:52:20] *** Parts: ecr (ereed@2557E599.66715431.D25A875A.IP) ()
[00:52:37] <strcat> brson: nightly builds should use 'git describe' btw
[00:52:45] <strcat> it's an ever-increasing number
[00:52:56] <strcat> last_tag-commits_since_tag-uniqueid
[00:53:14] <strcat> it'd be nice if we named the tags just "0.7" instead of "release-0.7"
[00:53:20] <incDec> Alright, here's the source and the errors: https://gist.github.com/anonymous/5863837
[00:53:21] <Eridius> incDec: as_bytes actually takes a closure that is given the byte buffer. it's the wrong function to use
[00:53:31] <Eridius> incDec: you probably want .to_bytes
[00:53:44] <Eridius> incDec: let i = str::to_bytes("Hello, world!")
[00:53:44] <dbaupp> incDec: you could probably use as_bytes_no_callback
[00:53:48] <dbaupp> (or something)
[00:54:00] <cmr> nice, ICE on your first program. must be a record or something :p
[00:54:14] <Eridius> dbaupp: he's probably going to end up writing a function that takes a &str and returns a ~[u8], so he's going to want .to_bytes eventually
[00:54:20] <MaikKlein> rusti, str::to_bytes("Hello, world!")
[00:54:31] <MaikKlein> rusti: str::to_bytes("Hello, world!")
[00:54:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/EgLS
[00:54:34] <dbaupp> MaikKlein: it got deleted since 0.6
[00:54:53] <cmr> Now it'd be s.bytes_iter().collect::<~[u8]>() I think
[00:55:00] <MaikKlein> dbaupp,  I could swear I used sth similar 2 days ago
[00:55:18] <dbaupp> MaikKlein: maybe x.to_bytes()?
[00:55:28] <aatch> MaikKlein, possibly. strcat and dbaupp have been deleting like crazy
[00:55:28] <dbaupp> cmr: s.as_bytes() gives a &[u8] without allocating
[00:55:40] <dbaupp> aatch: not in the last few days though
[00:55:40] <Eridius> incDec: try this: https://gist.github.com/kballard/5863846
[00:55:41] <cmr> dbaupp: right but it's the to_bytes equivalent
[00:55:47] *** Joins: ssbr (ssbr@moz-141F89C6.block0.gvtc.com)
[00:55:50] <MaikKlein> rusti: str::from_bytes(5u8)
[00:55:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OTMb
[00:56:04] <dbaupp> cmr:  I guess, s.as_bytes().to_owned() is more efficient
[00:56:10] <dbaupp> but possibly not
[00:56:26] <cmr> Well, maybe, it could be a memcpy, right?
[00:56:28] <MaikKlein> rusti: "Dasdasdas".as_bytes()
[00:56:29] -rusti- &[68, 97, 115, 100, 97, 115, 100, 97, 115]
[00:56:33] <incDec> Huh, must have looked over that method on the webpage
[00:56:42] <brson> strcat: why is 0.7 better than release-0.7?
[00:56:42] <MaikKlein> rusti: ("Dasdasdas".as_bytes()).to_str()
[00:56:44] -rusti- ~"[68, 97, 115, 100, 97, 115, 100, 97, 115]"
[00:56:57] <strcat> brson: because the version names of nightlies are very long right now
[00:56:59] <Eridius> brson: release-0.7 is an unnecessarily verbose name for a version
[00:57:05] <strcat> release-0.6-2570-g032dcc5
[00:57:07] <MaikKlein> do we have a from bytes method?
[00:57:10] <Eridius> release-0.7 makes sense for a git tag because it indicates this tag represents a release
[00:57:18] <Eridius> but in the context of a version string, you already know it's a release
[00:57:29] <strcat> Eridius: all tags are going to be releases of some sort afaik
[00:57:29] <Eridius> MaikKlein: str::from_bytes(), yes, but it fails if the input is not valid utf-8
[00:57:40] <dbaupp> rusti: std::str::from_bytes(bytes!("foo"))
[00:57:41] -rusti- ~"foo"
[00:57:43] <Eridius> strcat: maybe in this particular repo, but in the context of git repos in general that's not true
[00:57:43] <strcat> it's not a very useful namespace if it's the only one we'll ever have
[00:57:53] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[00:57:59] <MaikKlein> rusti: str::from_bytes(("Dasdasdas".as_bytes()))
[00:58:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WcdK
[00:58:05] <strcat> Eridius: git assumes annotated tags on master are releases
[00:58:09] <Eridius> strcat: by using release-0.7 in tags, even if you think tags will always represent releases, gives you flexibility later to do what you want
[00:58:09] <strcat> git describe assumes that
[00:58:18] <incDec> It finally compiled
[00:58:19] <Eridius> strcat: only ones that are reachable
[00:58:21] <MaikKlein> rusti: std::str::from_bytes(("Dasdasdas".as_bytes()))
[00:58:22] -rusti- ~"Dasdasdas"
[00:58:25] <incDec> Thanks for the help
[00:58:26] <MaikKlein> Eridius, thanks
[00:58:27] <cmr> http://rustlog.octayn.net/post/53886591487/status-update good night
[00:58:28] <dbaupp> cmr: it might be, but internally it's a loop, because .to_owned() doesn't always operate on POD
[00:58:32] <engla> 0.7 is an ok tag name
[00:58:35] <dbaupp> (I think.)
[00:58:43] <Eridius> strcat: for example, you could stuff your PGP key into a blob and tag that, which is what's done in git.git
[00:58:51] <strcat> well... rust is one of the few projects I know of using prefixes on the version tags
[00:59:01] <Eridius> strcat: in my personal projects I usually use v0.7
[00:59:01] <strcat> and it makes the versions in the package versions long
[00:59:06] <eevee> even if you tag for other things, 0.7 is pretty unambiguous
[00:59:06] *** Joins: alisdair (textual@moz-EA60A466.dedicated.allstream.net)
[00:59:24] <strcat> Eridius: so it still ends up as noise in a package version
[00:59:30] <brson> strcat: can nightly bins be named differently from tags?
[00:59:36] <MaikKlein> rusti: 256.as_bytes()
[00:59:36] -rusti- <anon>:9:9: 10:5 error: type `<VI0>` does not implement any method in scope named `as_bytes`
[00:59:36] -rusti- <anon>:9          256.as_bytes()
[00:59:36] -rusti- <anon>:10     };
[00:59:37] -rusti- error: aborting due to previous error
[00:59:37] -rusti- application terminated with error code 101
[00:59:52] <MaikKlein> rusti: 256i32.as_bytes()
[00:59:53] -rusti- <anon>:9:9: 10:5 error: type `i32` does not implement any method in scope named `as_bytes`
[00:59:53] -rusti- <anon>:9          256i32.as_bytes()
[00:59:54] -rusti- <anon>:10     };
[00:59:54] -rusti- error: aborting due to previous error
[00:59:54] -rusti- application terminated with error code 101
[01:00:05] <strcat> brson: yes, but it's just a minor annoyance
[01:00:22] <strcat> it's nice having it line up with git describe
[01:00:26] <strcat> you can take the package version and...
[01:00:31] <strcat> 'git show release-0.6-2570-g032dcc5
[01:00:31] <brson> strcat: it seems like post-0.7 we would not want '0.7' to be in the version name, but instead 0.8-pre
[01:01:01] <brson> i guess we want to do whatever git encourages
[01:01:01] <strcat> brson: git is basically describing it as last version + 1321 commits though
[01:01:35] <strcat> release-0.6-2570-g032dcc5 means release-0.6 plus 2570 commits
[01:01:54] <strcat> and 'git show release-0.6-2570-g032dcc5' or 'git checkout release-0.6-2570-g032dcc5' will work
[01:01:57] <Eridius> for the record, git itself uses the output of `git describe` as its version
[01:01:58] <MaikKlein> when will 0.7 be released on the first?
[01:02:30] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[01:02:38] <strcat> brson: for example if we had a history of nightlies, you could just pass the nightly version to git bisect
[01:02:38] <aatch> MaikKlein, well the milestone says 4 days
[01:02:45] <strcat> brson: once you found a good/bad one
[01:03:13] <strcat> just convenient to be using what git wants you to use ;p
[01:03:41] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[01:03:54] *** Quits: royw (royw@31A094F3.6B10AC3.E2F59BBC.IP) (Quit: royw)
[01:04:22] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[01:04:22] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14017d25d to 14efd1438: 02http://git.io/N3iJvQ
[01:04:22] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[01:04:24] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[01:04:24] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/QU9XyQ
[01:04:24] <ghrust> 13rust/06auto 140d471d3 15Corey Richardson: great renaming propagation: syntax
[01:04:24] <ghrust> 13rust/06auto 14a616531 15Corey Richardson: Remove extra
[01:04:24] <ghrust> 13rust/06auto 14e9ac719 15bors: auto merge of #7365 : cmr/rust/syntax_cleanup, r=Aatch...
[01:04:25] <brson> strcat: what platforms do you make nightlies for?
[01:04:25] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[01:04:58] <strcat> brson: arch linux x86_64 packages
[01:05:07] <strcat> on the official arch linux build server so... ;p
[01:05:42] <strcat> brson: we could just set up buildbot to make them though
[01:06:05] <strcat> every time it builds master and it passes, it could put up a new latest build
[01:06:13] <steven_is_false> bblum: Thanks for commenting on my pull request. I fixed things up a bit. I'm not sure why you closed the pull request right away though. I understand that you thought it had issues, and didn't like some things about it but before closing a pull request it's fairer to talk through things a bit more first.
[01:06:28] <strcat> err, well
[01:06:32] <strcat> I also make silly i686 packages
[01:06:36] <strcat> but I doubt anyone uses them ;p
[01:06:56] <MaikKlein> what is i686 btw?
[01:07:04] <strcat> pentium pro or something
[01:07:10] <aatch> Luqman, it seems your PR silently conflicted with one of my changes
[01:07:14] <MaikKlein> wow ok
[01:07:20] <aatch> So you ended up missing a test.
[01:07:22] <strcat> just slightly less bad than building for i386
[01:07:27] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[01:07:36] <Eridius> is there any way to request that rustdoc inline a nested module's docs into its parent?
[01:07:43] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[01:08:07] <aatch> Eridius, probably not, add it to the wiki though, since cmr's working on a new version of rustdoc
[01:08:32] <dbaupp> Eridius: https://github.com/mozilla/rust/wiki/Bikeshed-rustdoc
[01:08:41] <Luqman> aatch: :(
[01:08:41] <Eridius> dbaupp: thanks
[01:08:50] *** Joins: jst (quassel@2557E599.66715431.D25A875A.IP)
[01:08:50] <aatch> Luqman, sowwy
[01:09:13] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:09:14] <strcat> MaikKlein: yep, i686 is the pentium pro was 1995
[01:09:19] <strcat> ;p
[01:09:28] <bblum> steven_is_false: sure, sorry for closing it
[01:09:42] <steven_is_false> bblum: Thank you.
[01:09:47] <dbaupp> strcat: good to see rust is targeting the latest and greatest architectures :P
[01:10:14] <aatch> Is there a 32-bit x86 after i686?
[01:10:23] <strcat> aatch: i686 is just an arbitrary point
[01:10:28] *** Quits: jst (quassel@2557E599.66715431.D25A875A.IP) (Input/output error)
[01:10:29] <strcat> you can build x86 packages with SSE4.2
[01:10:30] <bblum> steven_is_false: i didn't mean to suggest it's an unwelcome feature or anything
[01:10:32] <bblum> so let's think it through
[01:10:32] <strcat> and AVX
[01:10:38] <steven_is_false> bblum: Fair enough.
[01:10:38] *** Joins: jst (quassel@2557E599.66715431.D25A875A.IP)
[01:10:40] <strcat> just pointless.
[01:10:47] <strcat> there's only a use case for x86_64
[01:11:04] <strcat> you can use x32 if you have something that *really* wants smaller pointers
[01:11:06] <Eridius> bikeshed: term::color::bright_red or term::color::bright::red?
[01:11:22] <strcat> https://en.wikipedia.org/wiki/X32_ABI could have a full x32 userland
[01:11:25] <aatch> Eridius, bright_red
[01:11:28] <strcat> don't really think anyone would want that
[01:11:40] <bblum> Eridius: term::color::bright::<Red> obviously
[01:11:46] <Eridius> aatch: that's how it is right now, but using a nested module for namespacing would let me attach a docstring saying "these colors are only usable if num_colors > 8"
[01:11:53] *** Joins: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP)
[01:12:08] *** Quits: erickt1 (erickt@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:12:11] <aatch> Eridius, nah, just have some documentation about it and silently fall back.
[01:12:17] <strcat> aatch: anyway Arch is ever closer to just being on x86_64... because hardly any of us uses i686
[01:12:18] <bblum> steven_is_false: so, tell me about your use case for rwarcs
[01:12:24] <strcat> we never get signoffs on i686 packages anymore
[01:12:42] <doener> strcat, aatch, brson: eliminating the lint warnings for transmute results in exactly the same asm
[01:12:48] <MaikKlein> term::color::bright::<ÎºÏŒÎºÎºÎ¹Î½Î¿Ï‚> because we can use greek
[01:12:58] <Eridius> aatch: well, the behavior I'm implementing right now will not emit a color at all if num_colors is too low. I can see the argument that bright_red should turn into red if num_colors == 8, but what if I pass a custom color, e.g. 197? what does that become?
[01:13:19] <doener> strcat, aatch, brson: ... for brson's iter example (https://gist.github.com/brson/5863454) that is
[01:13:21] <Eridius> also, I'm not sure I like the idea that it will say "oh I can't do what you want, so let me do something that I think is similar"
[01:13:22] <strcat> doener: well I guess we need to look at the pre-optimization IR and figure out what's going wrong
[01:13:31] <strcat> I don't understand where that first check comes from
[01:13:41] * strcat looks agaib
[01:13:43] <strcat> n
[01:14:17] <strcat> so
[01:14:32] <aatch> doener, is that still with the standard optimization passes?
[01:14:52] <steven_is_false> bblum: Primarily I'm going to be writing to a RWARC variable that a game simulator thread shares with a render thread.
[01:14:55] <strcat> vec::raw::to_ptr is the first call, and that has 2 transmutes
[01:15:12] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[01:15:22] <strcat> and then iter sticks the start and end in the iterator
[01:15:23] *** Quits: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com) (Connection reset by peer)
[01:15:29] <doener> aatch: yes, using "rustc -OS -Z lint-llvm  -Z no-monomorphic-collapse" and normalize_for_monomorphization() disabled in the compiler
[01:15:31] <strcat> the iterator only has a current == end check
[01:15:34] <steven_is_false> bblum: It might happen that at runtime parts of the game engine crash due to misconfiguration, or misdetected features.
[01:15:38] * strcat doesn't understand where it comes from ;[
[01:16:18] <steven_is_false> bblum: When these parts of the game engine crash, I could simply popup an error message, and quit the game.
[01:16:30] *** Joins: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au)
[01:16:40] <steven_is_false> bblum: But it'd be nicer to simply reset the game engine to a known good default state.
[01:17:08] <steven_is_false> bblum: For that reason I'd like to reset RWARC variables using the unpoison method.
[01:18:11] <steven_is_false> bblum: So, I guess for my use case it might be needed to have some form of checking integrated with the unpoison method.
[01:18:13] <strcat> I like the way poison works right now because even if it wasn't the intended goal, it makes fail == no more using memory associated with the failure
[01:18:16] <aatch> strcat, hmm, we don't seem to actually /have/ a constprop pass...
[01:18:21] <strcat> so no worries about exception safety
[01:18:28] <strcat> aatch: uh, can we just copy this stuff from clang?
[01:18:33] <aatch> strcat, I did.
[01:18:46] <strcat> aatch: also I think clang has loop vectorize at -O2 now
[01:18:47] <aatch> But it's possible I missed something.
[01:18:52] <bblum> steven_is_false: the state inside the RWARC would be the engine state, presumably?
[01:18:55] <strcat> aatch: in svn
[01:19:07] <strcat> need to measure it I guess
[01:19:17] <steven_is_false> bblum: Parts of it. Most of the engine state should be private to threads, or collections of threads.
[01:19:18] <aatch> strcat, in that case, I'd prefer waiting for our LLVM to get updated.
[01:19:24] <strcat> aatch: I think it is
[01:19:28] <strcat> aatch: 3.3 was branched ages ago
[01:19:38] <strcat> we're on 3.4-svn, aren't we?
[01:19:45] <bblum> steven_is_false: 2 threads max using the RWARC?
[01:19:53] <aatch> strcat, not sure. I don't think so actually.
[01:20:02] <aatch> We've been having trouble updating...
[01:20:05] <strcat> aatch: their main branch was on 3.4 before 3.3 was released
[01:20:09] <steven_is_false> bblum: Usually. I might also have one to many relationships though.
[01:20:42] <bblum> steven_is_false: reason i ask is that with 2 threads max, if you detect that the RWARC is poisoned, you know you're the only one left trying to use it, so you could just create an entirely new RWARC with the known-good state you're presumably hanging onto
[01:20:46] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[01:20:58] <aatch> strcat, if I use the in-tree `llvm-config --version`, I get 3.3svn
[01:21:07] <strcat> aatch: oh so we're really behind.
[01:21:10] *** Joins: royw (royw@D36B3245.C90B32B9.E305BD61.IP)
[01:21:13] <aatch> strcat, yes.
[01:21:23] <bblum> you could emulate this using task::try { ... }.is_err() to check if it's poisoned, but that's a pretty bad solution because of the task spawn
[01:21:32] <Luqman> aatch: ok, hopefully goes through this time
[01:21:47] <steven_is_false> bblum: Yes, there are definitely many cases where an unpoison method could be replaced by simply creating an entirely new RWARC variable.
[01:21:59] <bblum> steven_is_false: with 1-to-many though, you gotta make sure if multiple tasks could potentially try to unpoison, that they won't race
[01:21:59] <aatch> there are some issues open about it. So maybe you could attempt updating it?
[01:22:07] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[01:22:35] <bblum> like: task A fails; task B tries to unpoison, and then operate on the state; tsak C tries to unpoison and then operate on the state
[01:22:46] <bblum> you want both B's and C's changes to make it through
[01:22:50] <steven_is_false> bblum: Usually, I try to stick to one writer to many readers. The other way is confusing.
[01:23:02] <bblum> hmm
[01:23:19] <steven_is_false> bblum: If I had multiple writers, I'd have multiple RWARC values anyways because I wouldn't want lock contention.
[01:23:33] <bblum> well, then you wouldn't have multiple writers :P
[01:23:34] <dbaupp> strcat, aatch: I think acrichto was trying to upgrade LLVM and met some problems
[01:23:56] <bblum> steven_is_false: what's your plan for when a 2nd reader tries to access a poisoned RWARC? you can't safely unpoison in read mode.
[01:24:17] <strcat> doener: I can't understand the source of the initial check in the IR >.<
[01:24:19] *** Quits: MaikKlein (maik@moz-3D9AD16.dip0.t-ipconnect.de) (Ping timeout)
[01:24:20] <bblum> and presumably you don't want a nondeterministic number of your other threads to fall over
[01:25:06] <steven_is_false> bblum: Right. Having an unpoison method complicates semantics because then a reader thread might have to become a writer thread (to reset things to a known good state.)
[01:25:09] *** Quits: jst (quassel@2557E599.66715431.D25A875A.IP) (Ping timeout)
[01:25:19] <doener> strcat: I'd guess it's the match in fold()
[01:25:22] <steven_is_false> bblum: Personally, I'd deal with that by going up a level in threads.
[01:25:27] *** Quits: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:25:30] <bblum> 'up a level'?
[01:25:43] *** Quits: eatkinson (eatkinson@2557E599.66715431.D25A875A.IP) (Quit: eatkinson)
[01:25:43] <steven_is_false> bblum: I have a top level system which spawns a reader, and a writer thread.
[01:26:03] <steven_is_false> bblum: Both threads fail when the RWARC is poisoned.
[01:26:06] <strcat> doener: strange that it doesn't optimize out though, it does with std::accumulate in C++
[01:26:17] <strcat> or the adaptor in boost range
[01:26:22] <doener> strcat: err, no, that's the one against rax, which I've been looking for. I guess you mean the "al" one?
[01:26:28] <strcat> doener: yes
[01:26:35] <doener> ok, no clue about that yet
[01:26:35] <steven_is_false> bblum: The top level thread is waiting on the threads, and when things fail it resets things to a known good state, and then recovers.
[01:27:50] <bblum> you mean you can afford to respawn all the readers?
[01:28:07] <strcat> doener: just seems like something is wrong with our optimization passes or we have undef behaviour ;\
[01:28:25] <bblum> ughhhhhhh, 2/3 of my open PRs bitrotted
[01:28:31] <strcat> trivial for it to prove that it's not null there
[01:28:37] *** Quits: jclements (jclements@43CB6079.66715431.D25A875A.IP) (Quit: jclements)
[01:29:00] <steven_is_false> bblum: Hmm, I guess I'd have to have the read_unless_poisoned method, and have the readers block waiting on a condvar until things get restored to a good state (by the top level master thread.)
[01:29:04] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[01:29:07] <strcat> but not necessarily on the first iteration.... whatever is making the weird dead branch with al is probably related
[01:29:19] <steven_is_false> bblum: If I couldn't afford respawning stuff.
[01:29:25] <bblum> steven_is_false: it's not possible to block on a condvar in read-mode unfortunately
[01:29:29] <doener> strcat: there's a similar weirdness with with_capacity
[01:29:31] <bblum> but what you could do would be something like this
[01:29:51] <steven_is_false> bblum: Okay, I'm not sure of the exact implementation then.
[01:30:13] *** Joins: mib_s1o5hu (Mibbit@moz-B5F5E1BE.dsl.teksavvy.com)
[01:30:15] <steven_is_false> But it'd be some kind of blocking until the situation recovers.
[01:30:35] <doener> strcat: you get something like "movq 4, %rax; cmpq %rax, 1024"
[01:30:37] <steven_is_false> Or actually for my case it'd be polling, and just reusing old known good state.
[01:30:47] <strcat> doener: huh.
[01:30:50] <bblum> steven_is_false: loop { let mut try_again = true; do arc.read_unless_poisoned |opt| { do opt.map |data| { try_again = false; operate(data); } } if try_again { unpoison_port.recv(); } else { break; } }
[01:30:56] <steven_is_false> For example, the render thread would just continuously redraw the last screen.
[01:31:01] <bblum> where the writer holds the other end to the unpoison_port
[01:31:34] *** Quits: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au) (Ping timeout)
[01:31:36] <steven_is_false> Give me five seconds to parse that.
[01:31:39] *** Quits: EXetoC (ex@moz-2DBEB1E4.customer.t3.se) (Quit: WeeChat 0.4.1)
[01:32:19] <doener> strcat: https://gist.github.com/dotdash/5864023 -- lines 4 and 6
[01:32:33] *** Joins: jst (quassel@2557E599.66715431.D25A875A.IP)
[01:32:35] <aatch> strcat, doener, it couldn't be from valgrind, could it?
[01:32:57] <aatch> Actually, scratch that.
[01:33:00] <doener> that's for: let x: ~[u8] = std::vec::with_capacity(1024); -- the "4" is the initial capacity
[01:33:08] <bblum> steven_is_false: i'm also wondering if what you really want is an RWARC that doesn't poison, and some other way of the failable task alerting the parent task that it failed
[01:33:10] <aatch> it wouldn't do it.
[01:33:12] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (Ping timeout)
[01:33:24] <bblum> the writer-parent would esseentially be "polling" on the RWARC to restart the failed task anyway
[01:33:41] <steven_is_false> bblum: I don't know if that'd be actually cleaner though.
[01:34:03] <strcat> doener: with_capacity does a malloc and a realloc? heh. we really do everything wrong :(
[01:34:05] <bblum> it would at least prevent you from having all the other readers have to deal with poison
[01:34:23] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[01:34:23] *** ChanServ sets mode: +o dherman
[01:34:50] <bblum> no other reader is trying to do anything but "wait until i can read" if it's poisoned, right? only the writer has to take action then
[01:34:59] *** Joins: brendan (brendaneic@moz-C252503F.public.wayport.net)
[01:35:36] <steven_is_false> bblum: I'm going to have deal with poison at some level anyways though. I can't ensure that a RWARC can't be poisoned unless I make methods like fn update(&self, T) which is basically my unpoison method.
[01:35:38] *** Quits: mib_s1o5hu (Mibbit@moz-B5F5E1BE.dsl.teksavvy.com) (Quit: http://www.mibbit.com ajax IRC Client)
[01:35:51] <doener> strcat: required because we currently can't tell whether ~ contains @ without an instance (we have to look in the ref_count field)
[01:35:54] <steven_is_false> bblum: Maybe it'd be nicer to make an unpoisonable RWARC.
[01:35:58] <bblum> steven_is_false: well, right now i'm thinking about an RWARC that didn't do poisoning at all
[01:36:00] <bblum> right
[01:36:11] <strcat> doener: could add an is_managed::<T> intrinsic
[01:36:11] <doener> strcat: I once had a patch that added a typedesc flag instead to avoid the realloc
[01:36:22] <strcat> doener: we shouldn't have headers on ~[] though
[01:36:23] <strcat> or ~
[01:36:31] <strcat> if it doesn't contain @
[01:36:37] <steven_is_false> And sure maybe one could have an unsafe_write method for it. But most of the time people would just use an update method.
[01:36:42] <strcat> and once the gc lands we shouldn't have headers on anything but @mut ;\
[01:36:55] <doener> getting the typedesc works without an instance, that's why I added the flag there
[01:37:15] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Ping timeout)
[01:37:29] <doener> that was when I was just getting started and had absolutely no clue what I'm doing though
[01:37:45] <doener> I wonder where that patch is hiding on my disk...
[01:37:58] <strcat> doener: I'm more worried about the codegen ghosts anyway
[01:38:03] <strcat> don't comprehend what it's doing
[01:38:36] <steven_is_false> bblum: Okay, so there's three ideas here. One, your idea RWARC::new_without_poisoning, my first idea; RWARC::unpoison, and my second idea UnpoisonableRWARC.
[01:38:58] <bblum> UnpoisonableRWARC and new_without_poisoning are basically the same
[01:39:07] <bblum> i was thinking about what you said about making RWARC a trait instead of a type
[01:39:33] <bblum> 2 disadvantages of that: 1, it always has to be behind a ~-pointer (traits are 2nd-class), and (2) you get dynamic dispatch on all the methods
[01:39:34] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[01:39:55] <steven_is_false> bblum: Would one ever need existential quantification over it though?
[01:40:02] *** Joins: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net)
[01:40:06] *** Quits: lkuper (lkuper@66AE1C4.B4544612.EA8B5958.IP) (Ping timeout)
[01:40:26] <steven_is_false> bblum: Most of the time people would have it be template polymorphism.
[01:40:40] <bblum> fn foo<U, T: RWARC<U>> ?
[01:40:49] <steven_is_false> Yes.
[01:40:51] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[01:41:10] <doener> strcat: must be the self.ptr == self.end check
[01:41:12] *** Quits: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com) (Client exited)
[01:41:19] <steven_is_false> bblum: One should actually have higher order generics to make it nice though. Unfortunately, Rust doesn't.
[01:41:26] <strcat> doener: that's the one at the end of the loop block though
[01:41:32] <bblum> it's conceivable to do it that way
[01:41:37] <bblum> i kind of wanna avoid having a bunch of types though
[01:41:38] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[01:41:39] * pcwalton is amazed by the number of merge conflicts after just a couple of days
[01:41:51] <strcat> pcwalton: I just landed more each removal ;p
[01:41:54] <bblum> i don't mind the "toggling the behaviour based on which constructor you called" thing too much
[01:42:00] <pcwalton> yeah, that's a bunch of them
[01:42:01] <bblum> it already does that with how many condvars you want to use
[01:42:06] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[01:42:13] <bblum> strcat: you bitrotted my patches *again*
[01:42:19] *** Joins: cowboyd (cowboyd@moz-39762A31.sw.biz.rr.com)
[01:42:32] <strcat> bblum: heh :), sorry
[01:42:51] <strcat> it's close to done!
[01:42:54] <steven_is_false> bblum: You've convinced that there's probable a better way than unpoison for at least ninety percent of cases.
[01:42:57] <strcat> % git grep '\.each ' | wc -l   
[01:42:58] <strcat> 39
[01:43:20] <bblum> steven_is_false: you've convinced me that poisoning is not what you want in most cases :P
[01:43:22] <seth> is there an equivalent of str::substr that takes character offsets rather than byte offsets?
[01:43:38] <dbaupp> seth: .slice_chars
[01:43:39] <strcat> bblum: it needs to poison on fail to avoid opening up the exception safety can of worms though
[01:43:40] <steven_is_false> bblum: I think people might ask for something similar later on anyways but there should probable be a better alternative for most cases.
[01:43:52] <seth> dbaupp: thanks!
[01:43:54] <strcat> bblum: for one simple example, a less-than compare fails during a binary tree rebalancing
[01:44:00] <doener> strcat: hm, true. The only other cmp i8 left is in nonzero_sys_of
[01:44:09] <dbaupp> seth: (hm, wait, that was added in the last 2 weeks or so)
[01:44:09] <steven_is_false> strcat: Which is why I wanted a version of RWARC which would only have an update method.
[01:44:23] <bblum> steven_is_false: i agree there should probably be a way to just reinitialize a new value without being at risk for failure... i dunno whether i want that, or the option functions i suggested, or both
[01:44:33] <seth> dbaupp: ah, yes, i don't seem to have it. sadface
[01:44:36] <bblum> strcat: i am not convinced these are unsafe -- can you run me through the rebalancing example
[01:44:45] *** Quits: alisdair (textual@moz-EA60A466.dedicated.allstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[01:44:50] <dbaupp> seth: yeah, I can't remember if there was an equivalent :(
[01:44:52] <strcat> bblum: well that example isn't unsafe if the tree is implemented with safe code
[01:44:57] <strcat> bblum: but you do end up with an invalid tree
[01:45:14] <steven_is_false> , I'll need to find a 
[01:45:17] <steven_is_false> Oops.
[01:45:30] <bblum> strcat: sure, assertion failures where you don't expect them
[01:45:57] <bblum> yeah, that's why i added poison to begin with
[01:46:13] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[01:46:15] <steven_is_false> Anyways, I'll try to find a cleaner, and better alternative for my personal use case. When I work on, and accomplish something better I'll submit a new pull request.
[01:46:42] <strcat> bblum: it would only be unsafe if unsafe code was written depending on 'fail' wiping out any possibly-referenced objects
[01:47:00] <strcat> which I think is a valid thing to do right now
[01:47:38] <bblum> steven_is_false: if you make either a "reinitialize()" function or a new_without_poison() constructor i'd r+ it
[01:48:28] <steven_is_false> bblum: I'll think about it. Thanks for the talk. I'm going to take a break.
[01:48:39] <bblum> likewise thanks for the motivating use case :)
[01:48:54] <bblum> it's always good when someone wants to use your library
[01:49:02] <bblum> strcat: i'm concerned about interactions with stuff like Cell, like: do arc.write |cell| { do cell.take_with |data| { fail!(); } }
[01:49:11] <bblum> strcat: but i think in that case it will just leave the cell in a taken state
[01:49:14] <bblum> which is fine
[01:49:36] *** Quits: brendan (brendaneic@moz-C252503F.public.wayport.net) (Quit: brendan)
[01:49:53] <strcat> bblum: since we abort on out-of-memory, we have much fewer cases where it would be useful than C++
[01:50:48] *** Quits: royw (royw@D36B3245.C90B32B9.E305BD61.IP) (Quit: royw)
[01:50:52] <strcat> but I think there are probably still cases depending on lack of catchable exceptions already
[01:51:32] <bblum> i'd like to see one
[01:51:40] <bblum> my hunch is such a case doesn't exist
[01:53:18] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[01:53:45] <strcat> bblum: well you want to see one where it would be unsafe, rather than just not-well-defined in library terms
[01:54:01] <bblum> right
[01:54:06] <strcat> libraries do often depend on their internal data structures being in a valid state
[01:54:20] <bblum> those libraries should assert rather than crash though
[01:54:23] <bblum> and i don't care about making assertions fail in tasks that don't expect it --
[01:54:32] <bblum> that's a burden the user takes on by using an unpoisonable RWARC
[01:55:13] <strcat> bblum: if I was writing an FFI binding and needed a map, I don't think it would unreasonable to expect the map to be in a valid state if I was using it correctly
[01:55:25] <strcat> auditing for potentially failing things is hard
[01:55:30] <strcat> there's no way to easily tell what can fail
[01:55:41] <bblum> hmm ffi
[01:56:13] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[01:57:23] *** Joins: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au)
[01:57:37] <bblum> i'll have to think on this; for now, my work day is over
[01:59:04] <strcat> anyway I just don't think catchable exceptions and unpoisoned RWARCs are different
[01:59:12] <strcat> so it should be the same conversation
[01:59:46] *** Quits: joelteon (joel@moz-317E8D0C.io) (Ping timeout)
[02:00:32] *** Joins: joelteon (joel@moz-317E8D0C.io)
[02:05:33] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Ping timeout)
[02:05:34] *** Quits: KindOne (KindOne@E313C970.A337191.EC6A1518.IP) (Ping timeout)
[02:08:00] *** Joins: ysuzuki_ (ysuzuki@moz-36FBA934.net124047241.t-com.ne.jp)
[02:08:15] *** Quits: ysuzuki (ysuzuki@moz-285468F7.net219126120.t-com.ne.jp) (Ping timeout)
[02:08:27] <steven_is_false> What is the kind of a value such that it's reference can be safely shared between threads?
[02:09:50] <aatch> steven_is_false, elaborate?
[02:09:59] *** Joins: KindOne (KindOne@moz-D53C683A.dynamic.ip.windstream.net)
[02:10:04] <steven_is_false> aatch: The whole RWARC story is too complicated.
[02:10:16] *** Quits: Aetherspawn (Aetherspaw@moz-F96BF16B.swin.edu.au) (Quit: Leaving)
[02:10:20] <steven_is_false> aatch: I'm looking for ways to simplify it.
[02:10:48] <steven_is_false> aatch: I'm wondering why RWARC<T> can't simply be Atomic<RC<T>>?
[02:10:59] <strcat> what's Atomic?
[02:11:19] <steven_is_false> strcat: Atomic would be an unboxed value that is accessed atomically.
[02:11:20] <strcat> Rc doesn't use atomic reference counting (and won't)
[02:11:53] <aatch> steven_is_false, because atomic types aren't locked, whereas RWARC is, their different structures.
[02:11:56] <aatch> they're*
[02:11:56] <strcat> you couldn't make copies concurrently, you have to lock it to copy
[02:12:16] <strcat> and Rc is non-Send
[02:12:27] <steven_is_false> strcat: Okay. I'll think about this more, and then ask some questions later.
[02:12:48] <aatch> steven_is_false, hang on, just let me make sure I've been following correctly.
[02:12:55] <steven_is_false> aatch: alright.
[02:13:26] <aatch> steven_is_false, so you have a single writer, writing to a buffer that is read by n readers concurrently, correct?
[02:13:40] <steven_is_false> aatch: Sure.
[02:14:40] <aatch> Ok, so what is the intended behaviour when the buffer is re-written, while the readers are reading.
[02:14:59] <steven_is_false> aatch: There'd have to be locking
[02:15:30] *** Joins: yong_ (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[02:15:59] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[02:16:12] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Ping timeout)
[02:16:23] <aatch> steven_is_false, is it sane to have readers potentially reading different buffers?
[02:16:28] *** yong_ is now known as yong
[02:16:43] <steven_is_false> aatch: Not sure. I really don't want to talk right now okay?
[02:16:49] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[02:22:33] *** Quits: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net) (Quit: Places to go, people to annoy)
[02:24:13] <pcwalton> ok, patch bomb submitted https://github.com/mozilla/rust/pull/7396
[02:24:37] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Quit: )
[02:24:51] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Connection reset by peer)
[02:25:08] *** Joins: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP)
[02:25:14] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[02:26:54] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:28:07] *** Quits: hjr3 (hradtke@374E545A.3A8E9B0C.F9D9C60E.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[02:31:46] *** Joins: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net)
[02:31:46] *** ChanServ sets mode: +o tjc
[02:32:37] <aatch> pcwalton, heh, I find it amusing that gihub reports the date as 20 days ago
[02:33:29] <aatch> pcwalton, so this completely removes op=?
[02:33:57] <strcat> until it's rewritten to use traits
[02:34:09] <aatch> So temporary measure?
[02:34:40] <strcat> yes
[02:34:58] <strcat> need AddAssign, SubAssign, MulAssign, etc.
[02:35:05] *** Quits: cowboyd (cowboyd@moz-39762A31.sw.biz.rr.com) (Client exited)
[02:35:44] <aatch> Good. I would actually quite like that for the Atomic* types
[02:35:54] *** Quits: illissius (illissius@A518C422.3F1C0C4.3AEF08B3.IP) (Quit: )
[02:36:20] <aatch> I deliberately didn't overload the operators because += wouldn't do what you expect.
[02:37:23] <aatch> even though (atomic + int) makes sense as an atomic load then an add
[02:37:31] *** Joins: sankha93 (Instantbir@D4A9A006.DC7B5F6F.8B6C1D65.IP)
[02:38:37] <aatch> pcwalton, am I right in thinking that some of this has already been approved?
[02:38:40] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[02:38:46] *** Quits: jedestep (jedestep@moz-C68A1C79.natpool.nyu.edu) (Quit: jedestep)
[02:39:29] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[02:39:46] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Quit: leaving)
[02:43:13] *** Joins: rubber-duck (rubber-duc@3CAAC67.A9F41D41.76F1346C.IP)
[02:43:47] *** Joins: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net)
[02:44:14] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Connection reset by peer)
[02:45:26] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[02:45:45] <rubber-duck> why does iterator len have a _ postfix ? 
[02:45:46] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[02:46:02] <strcat> rubber-duck: method resolve bugs
[02:46:13] <strcat> that's why map is called transform and why a bunch of methods have an _ at the end
[02:46:17] <dbaupp> rubber-duck: issue #5898
[02:46:20] <strcat> they won't when method resolve works
[02:48:03] <rubber-duck> oh ok I thought it was a internal fn or something
[02:48:15] <strcat> if it was internal it would be pub ;p
[02:48:18] <strcat> wouldn't*
[02:49:13] <a_m0d> Could someone provide me with insight into a "partial move" issue that came up recently?
[02:49:21] <a_m0d> This file: https://github.com/am0d/rust-projects/blob/master/sorting/insertion-sort.rs#L15 no longer compiles
[02:49:26] *** Quits: dylukes (dylukes@moz-E4DF3FED.pitbpa.fios.verizon.net) (Quit: Computer has gone to sleep.)
[02:49:54] <a_m0d> output here: https://gist.github.com/am0d/5864381
[02:50:36] <a_m0d> This was actually working until sometime in the last week or two.  It may be a valid error message (although the code ran fine before), but I'd love to know what I can do to get the code to compile again.
[02:51:03] <Eridius> a_m0d: implicit copies became moves
[02:51:18] <Eridius> a_m0d: you should say `let valueToInsert = &result[index]` to restore the old behavior
[02:51:19] <a_m0d> Eridius: so that was doing an implicit copy before?
[02:51:25] <strcat> a_m0d: yes
[02:51:27] <Eridius> or possibly use &result[index] to skip the copy
[02:51:33] <strcat> a_m0d: you have a Copy bound on the fn
[02:51:41] <strcat> you probably don't want one
[02:51:51] <dbaupp> Eridius: well, `let valueToInsert = copy result[index];` to get the old behaviour
[02:52:03] <Eridius> dbaupp: yeah
[02:52:22] <strcat> a_m0d: well, and you probably want to make it use &mut [T] and do an in-place sort
[02:52:39] <strcat> you take arr by-value so you already have ownership of it
[02:52:44] <strcat> no need to copy it at least
[02:52:56] <Eridius> or maybe take a &[T] if the intention is to not sort in-place
[02:53:07] <strcat> Eridius: no, then just take ~[T]
[02:53:15] <strcat> but without making an internal copy
[02:53:28] <a_m0d> strcat: I probably don't need the Copy bound; I was just trying to keep the signature the same across all the implementations.  Also, at least one implementation can't do an in place sort, so I made them all do the copy for consistency
[02:53:29] <strcat> taking something as ~[T] gives you ownership of it - the caller handed you over a copy already
[02:53:34] <Eridius> strcat: I'm saying if the intention is to produce a sorted version of the existing vector, you should take a &[T] and copy the elements
[02:53:48] <Eridius> but if you don't care about leaving the unsorted version alone, then yeah, in-place is nicer
[02:54:42] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[02:56:11] <a_m0d> Thanks guys, I'll have to play with these tips a bit and see if I can find a way to implement all the sorts in a way that I like
[02:56:43] *** Quits: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net) (Quit: eatkinson)
[02:57:35] <dcolish> what are some rust libs which are good to read for examples of idiomatic code?
[02:58:17] *** Quits: zz_kimundi (kimundi@moz-DE7C650.dip0.t-ipconnect.de) (Ping timeout)
[02:59:11] *** Quits: pcwalton (pcwalton@2557E599.66715431.D25A875A.IP) (Quit: pcwalton)
[02:59:37] <aatch> dcolish, very good question
[03:00:17] <aatch> The problem is that "idiomatic" is somewhat ill-defined right now.
[03:00:29] <dbaupp> dcolish: idiomatic for which version of Rust? (0.5, 0.6, Rust 2 weeks ago, Rust now... it changes very fast :( )
[03:00:37] <aatch> There are common patterns, but they are often work-arounds for missing issues.
[03:00:47] <aatch> s/issues/features
[03:00:57] <dcolish> well i guess I'd like to know whats keeping up with the bleeding edge?
[03:01:11] <aatch> A very good example is extension traits vs default methods.
[03:01:19] *** Joins: zz_kimundi (kimundi@moz-CFAE5EB7.dip0.t-ipconnect.de)
[03:01:27] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[03:01:34] <aatch> Almost all usages of extension traits are obsoletely by default methods.
[03:01:45] *** zz_kimundi is now known as kimundi
[03:01:57] <dcolish> makes sense
[03:02:24] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[03:02:49] <aatch> dcolish, currently, idiomatic is a synonym for "works and doesn't make my eyes bleed"
[03:02:52] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[03:03:05] <dbaupp> (and, allocates as little as possible)
[03:03:20] <aatch> Oh yeah, that's a good point.
[03:03:41] <dcolish> haha
[03:03:59] <aatch> Good rust code should almost never need to allocate on the heap, other than for ~[T] and ~str
[03:04:03] <dcolish> so is explicit allocation kind not as preferred these days?
[03:04:05] <dcolish> hmm
[03:04:09] <dcolish> thats interesting
[03:04:25] <dcolish> thats not the sense i got from the tutorial, for whatever reason
[03:04:44] <aatch> dcolish, well with the lifetimes+borrowing system, you can pass around &-ptrs instead of ~ or @
[03:04:58] <dcolish> sure
[03:04:58] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:05:32] <dbaupp> so, yeah, trying to get as much as possible on the stack is good, rather than in the heaps
[03:05:50] <dbaupp> (especially since there's no risk of stack overflows, modulo compiler bugs.)
[03:05:56] <aatch> If we can get the more common construction patterns optimized, it's even better.
[03:06:16] <dbaupp> getting the out pointer to be smarter would be awesome
[03:06:32] <strcat> dcolish: everything should be unboxed on the stack until you have a very good reason to do a heap allocation
[03:06:47] <strcat> mostly should have stack allocations with some & and &mut
[03:07:02] <strcat> ~ is generally an implementation detail of a tree-like container
[03:07:08] <aatch> Right now, a constructor function with a body like: `{ Foo { a: a, b: b } }`, will actually store things straight into the passed out-pointer (if it's not an immediate)
[03:07:15] <Eridius> dcolish: if you were writing C you wouldn't be calling malloc() all over the place, would you? That's what sprinkling ~ or @ everywhere is like
[03:07:42] <dcolish> yeah that makes a lot of sense
[03:07:55] <Eridius> aatch: is there a return-value optimization like C++ has, so `{ let a = Foo { bar: 3 }; doSomething(a); a }` will use the out-pointer?
[03:08:07] <dbaupp> Eridius: not yet
[03:08:09] <aatch> Eridius, not right now, unfortunately
[03:08:10] <Eridius> damn
[03:08:15] <aatch> There is an issue open for it.
[03:08:16] <strcat> Eridius: it shouldn't in that case
[03:08:20] <Eridius> strcat: no?
[03:08:23] <strcat> that struct is 1 word
[03:08:29] <dbaupp> Eridius: https://github.com/mozilla/rust/issues/7298
[03:08:31] <Eridius> strcat: ok pretend it's larger
[03:08:39] <Eridius> strcat: I didn't want to type a: a, b: b :P
[03:08:41] <strcat> Eridius: then yes, it's supposed to do RVO but it's broken in some cases
[03:08:57] <aatch> strcat, that '3' is clearly a 256-bit integer :P
[03:09:03] <Eridius> 3i256
[03:09:07] <strcat> it makes an out pointer but doesn't seem to use it directly ;\
[03:09:13] <strcat> rustc has major issues
[03:09:26] <dbaupp> to say the least
[03:09:36] <aatch> strcat, yeah, it's because rustc looses the connection between the out-pointer and the inner expressions.
[03:09:50] <Eridius> what's the simplest way to ask rust to rebuild just stage2, in a manner that allows me to `make install` afterwards?
[03:09:51] <aatch> or more accurately, never makes them.
[03:12:00] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[03:12:45] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[03:12:50] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[03:15:42] <aatch> Ok, so RVO is actually done by rustc itself.
[03:15:57] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:16:19] *** Joins: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net)
[03:16:27] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[03:16:39] <strcat> aatch: yes LLVM can't do it because it's an ABI thing
[03:16:47] <strcat> clang does it in the frontend too
[03:16:58] <strcat> one of the two optimizations that the frontend knows about (devirtualization and RVO)
[03:17:05] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[03:17:57] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[03:18:12] <aatch> strcat, I wonder... there is an sret attribute for out-args that's only valid for the first argument.
[03:18:15] *** Joins: RMF (RMF@moz-9DB2BEB.dsl.telepac.pt)
[03:18:37] <strcat> aatch: I think it's mostly an ABI thing + the minor guarantees it provides
[03:18:50] <strcat> it'd probably be useful to use, *assuming* we fulfill the requirements
[03:19:07] <strcat> 'his pointer must be guaranteed by the caller to be valid: loads and stores to the structure may be assumed by the callee not to trap and to be properly aligned. '
[03:19:12] <strcat> that's all it would tell LLVM
[03:19:30] <strcat> don't know what it can do with that information...
[03:20:18] <aatch> strcat, it may be able to do something... I dunno. I might investigate quickly.
[03:20:56] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[03:21:02] <strcat> aatch: we also shouldn't have that param when we return not-by-outptr
[03:21:06] <Eridius> damn `make check` takes a while
[03:21:15] <aatch> strcat, we actually don't
[03:21:25] <strcat> aatch: really? we still seem to always have it...
[03:21:27] <aatch> it's just the env arg that stays
[03:21:30] <strcat> oh
[03:21:32] <strcat> they're separate?
[03:21:36] <aatch> yes.
[03:21:43] <strcat> all functions have an env param?
[03:21:48] <aatch> because rustc sucks at functions.
[03:21:53] <strcat> ugh that's worse than I though
[03:21:55] <strcat> t
[03:21:57] <aatch> strcat, yep.
[03:22:11] <strcat> aatch: well that's not all it sucks at ;p
[03:22:17] *** Quits: ysuzuki_ (ysuzuki@moz-36FBA934.net124047241.t-com.ne.jp) (Ping timeout)
[03:22:22] <strcat> anyway another mailing list post about iterators coming right up
[03:22:35] <aatch> Seriously, if I had to pick the "worst" part of rustc, I'd say the way it handles functions is by far and away the winner.
[03:22:49] * strcat personally finds the handling of allocations to be the worst
[03:22:54] <strcat> but that's also a runtime/library issue
[03:23:02] <strcat> stupid 32-byte headers
[03:23:04] *** Joins: ysuzuki_ (ysuzuki@moz-36FBA934.net124047241.t-com.ne.jp)
[03:23:13] <strcat> but we have no_drop_flag soon!
[03:23:20] <strcat> so I can write my own Unique and forget about ~ for now
[03:23:22] <aatch> strcat, it alreadly landed...
[03:23:26] <strcat> ;0
[03:23:37] * strcat needs to try treemap with a proper unique pointer
[03:24:21] <aatch> strcat, the test I added caused Luqman's PR to fail because he didn't change the Drop impl in it, but it didn't conflict because it was a new file.
[03:26:33] <aatch> strcat, also, you are correct that LLVM won't do the appropriate RVO even with sret
[03:27:50] <aatch> I mean, if it gets inlined, it doesn't end up mattering.
[03:27:57] *** Joins: brson (brson@72B1AFF8.AD1E507F.3688B332.IP)
[03:27:57] *** ChanServ sets mode: +o brson
[03:28:26] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[03:28:26] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/QU9XyQ
[03:28:26] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[03:29:22] <dcolish> anyone run into this? https://gist.github.com/dcolish/5864535
[03:29:42] <dcolish> i cant figure out why u8 isnt known, because I can use it elsewhere in that file
[03:30:28] <aatch> odd, that's not normally the error that gives.
[03:30:46] <aatch> at any rate, you want vec::with_capacity::<u8>()
[03:31:26] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[03:31:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Rb3N9A
[03:31:26] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[03:31:27] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:31:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/F41SFA
[03:31:27] <ghrust> 13rust/06auto 14ca2966c 15Luqman Aden: Change finalize -> drop.
[03:31:27] <ghrust> 13rust/06auto 1422408d9 15bors: auto merge of #7269 : luqmana/rust/drop, r=thestinger...
[03:31:27] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:31:47] <dcolish> ah yes, so i do
[03:31:49] <Eridius> strcat: r? https://github.com/mozilla/rust/pull/7399
[03:33:02] <strcat> Eridius: ah that's a good way to do it
[03:33:28] <Eridius> ty
[03:33:43] *** Quits: Earnestly (earnest@E7C44CA8.F365B115.4FA5093E.IP) (Ping timeout)
[03:40:16] <aatch> I finally figured out what the Use/User api in LLVM is good for.
[03:40:26] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[03:41:16] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[03:41:16] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 1475bf7e2 to 14e65d0cb: 02http://git.io/k471pw
[03:41:16] <ghrust> 13rust/06try 1429d8300 15Brian Anderson: core::rt: Move uv idle tests to idle mod
[03:41:16] <ghrust> 13rust/06try 148072690 15Brian Anderson: core::rt: Add bindings for async uv handles
[03:41:16] <ghrust> 13rust/06try 146d8d73c 15James Miller: Add AtomicUint newtype
[03:41:17] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[03:41:23] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[03:42:15] *** Parts: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) ()
[03:42:20] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[03:43:00] *** Quits: heftig (heftig@moz-7371B0A7.dip0.t-ipconnect.de) (Ping timeout)
[03:43:46] *** Joins: heftig (heftig@moz-D222EE86.dip0.t-ipconnect.de)
[03:47:43] <dcolish> damn it, 'internal compiler error' :(
[03:49:35] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[03:49:35] *** ChanServ sets mode: +o dherman
[03:52:43] <aatch> dcolish, ok, so an ICE is bad, but nowadays it's more likely to indicate a hole in an earlier check than some actual bug.
[03:53:18] <aatch> In your case, it should fail to compile that example.
[03:53:34] <aatch> Probably during region-checking.
[03:54:39] *** Joins: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com)
[03:54:39] <aatch> Basically, you're allocating a ~[], then borrowing a slice into it, and returning a struct that contains that slice.
[03:54:56] <aatch> However, the lifetime of `f` is actually too short.
[03:55:06] <aatch> since it "dies" at the end of the block.
[03:55:44] <Eridius> what's he compiling?
[03:56:01] <aatch> https://github.com/mozilla/rust/issues/7400
[03:56:54] <Eridius> yeah, you can't have a lifetime on the return value if it's not present anywhere else and expect that to make any sense whatsoever (unless it's 'static)
[04:00:21] <dcolish> ah i see
[04:00:34] <dcolish> i dont even know why i thought i needed a lifetime for that code
[04:00:52] <Eridius> well I mean if you actually wanted to do something strange like take a pointer back into the same struct, you might have the struct annotated with a 'self lifetime, but that would be quite odd
[04:01:04] <Eridius> err, take a pointer back into the same struct and store it in that struct
[04:01:18] <Eridius> dcolish: anyway you presumably want to make that v: ~[u8]
[04:01:24] <dcolish> yeah i fixed it
[04:01:59] <dcolish> i'm still pretty shakey on when to use ~ vs lifetimes
[04:02:32] <aatch> dcolish, it's fine. I'm giving you an explanation on the issue.
[04:02:40] <Eridius> dcolish: use ~ when you need to own something (and can't embed it directly in the struct for various reasons, e.g. in this case it's an unsized value)
[04:03:28] <dcolish> aatch: no, i really appreciate the help
[04:04:49] <strcat> dcolish: the only use of ~ is indirection (it's always pointer size)
[04:05:15] <strcat> you don't want ~ unless you need a recursive data structure or you have a huge struct you want to cheaply pass by-value
[04:05:29] <Eridius> damn, the removal of &[u8].foldl() is making me hit the rvalue issue. I had a nice elegant chaining of methods and now I need a temporary :(
[04:05:41] <strcat> Eridius: yep, evil rvalue bug
[04:05:55] <Eridius> strcat: or you need to be able to swap out chunks of the structure without the overhead of copying (which I guess is similar to the pass by-value bit)
[04:06:31] <strcat> ~T just acts like other types with destructors
[04:06:39] <strcat> doesn't provide anything useful in regards to lifetime semantics
[04:06:58] <aatch> dcolish, posted
[04:09:20] <aatch> strcat, how goes the Unique<T>?
[04:09:59] <dcolish> aatch: i think it has something to do with the reuse of 'self in the fn
[04:10:12] <dcolish> when i change that lifetime var to 'a it fails in a saner way
[04:10:30] <aatch> dcolish, the actual error? yeah. because 'self is still treated a little oddly.
[04:10:37] <dcolish> yeah
[04:10:43] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Client exited)
[04:10:56] <aatch> I'm pretty sure it's a duplicate, but I'll leave it for now.
[04:11:36] <aatch> dcolish, I'm guessing it say's something along the lines of "value does not live long enough?"
[04:12:07] <dcolish> right
[04:12:24] <dcolish> and that follows with your previous explination
[04:12:42] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[04:12:55] <aatch> dcolish, don't worry, borrowing and lifetimes in Rust are quite complex.
[04:13:05] <aatch> but once you get the hang of them...
[04:14:27] <Eridius> dcolish: in my limited experience so far, lifetimes have rarely been an issue
[04:14:44] <Eridius> the few times I've had to use one, it's always been to tie the lifetime of a function result to one of its arguments
[04:15:22] <dcolish> so in this case the best thing to do is to use ~[u8] for that vector in the struct?
[04:15:46] <aatch> dcolish, correct.
[04:16:03] <aatch> since the BitVector is the owner of the data.
[04:16:32] <dcolish> so ~ is kind of like unique_pointer?
[04:16:48] <aatch> dcolish, almost identical, yes
[04:16:56] <dcolish> i need to read that rust for CXX
[04:16:57] <dcolish> again
[04:17:01] *** Joins: bytbox (s@moz-2E27684C.student.umd.edu)
[04:17:03] <aatch> and @ is like shared_pointer
[04:18:24] <dcolish> the positioning of <> in fucntions is really screwing me up too :)
[04:22:14] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:26:28] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[04:26:51] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[04:26:51] *** ChanServ sets mode: +o dherman
[04:27:36] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[04:33:05] <dcolish> are there such things as mutable owned pointers?
[04:33:18] <aatch> dcolish, they inherit mutability.
[04:33:34] <dcolish> so what about inside an impl?
[04:33:41] <strcat> &mut self instead of &self
[04:33:41] <aatch> since there can only be one owner, it doesn't make sense to have something like `~mut`
[04:33:59] <strcat> or ~self, or self, where it hands you ownership
[04:37:50] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[04:38:36] <dcolish> i must be doing something wrong here, that vector is getting a size of 0
[04:39:15] <dcolish> oh with_capacity doesnt mean what i though
[04:39:17] <dcolish> t
[04:39:42] <aatch> dcolish, you can use vec::from_elem(0, size);
[04:40:41] <dcolish> oh nice, i was going to use build_sized but thats a lot better
[04:44:54] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements)
[04:46:20] *** Joins: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[04:47:25] *** Quits: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:47:41] <strcat> aatch: ~[0, ..size] works now
[04:47:46] <strcat> rusti: ~[0, ..10]
[04:47:47] -rusti- ~[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[04:47:47] <aatch> strcat, it does?
[04:47:50] <strcat> yep
[04:48:00] <aatch> what if size isn't constant?
[04:48:06] <strcat> aatch: dunno
[04:48:07] <strcat> it should work
[04:48:12] <strcat> might not
[04:48:15] <aatch> rusti: let n = 10; ~[0,..10]
[04:48:16] -rusti- <anon>:9:13: 9:14 warning: unused variable: `n` [-W unused-variable (default)]
[04:48:16] -rusti- <anon>:9          let n = 10; ~[0,..10]
[04:48:16] -rusti-                       ^
[04:48:16] -rusti- ~[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[04:48:17] *** Quits: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com) (Quit: brendan)
[04:48:21] <aatch> rusti: let n = 10; ~[0,..n]
[04:48:22] -rusti- <anon>:9:27: 9:28 error: expected constant integer for repeat count but found variable
[04:48:22] -rusti- <anon>:9          let n = 10; ~[0,..n]
[04:48:22] -rusti-                                     ^
[04:48:22] -rusti- error: aborting due to previous error
[04:48:23] -rusti- application terminated with error code 101
[04:48:26] <strcat> aatch: should fix it
[04:48:27] <Luqman> constant expressions work
[04:48:33] <strcat> Luqman: yeah but that's a ~[]
[04:49:07] <aatch> Luqman, this case is somebody constructing a ~[] inside a function using one of the args
[04:49:11] <dcolish> yeah i went that route first
[04:49:24] <dcolish> it wont work
[04:49:32] <Jeaye> rusti: let n = 10; &[0, ..n]
[04:49:33] -rusti- <anon>:9:28: 9:29 error: expected constant integer for repeat count but found variable
[04:49:33] -rusti- <anon>:9          let n = 10; &[0, ..n]
[04:49:33] -rusti-                                      ^
[04:49:33] -rusti- error: aborting due to previous error
[04:49:33] -rusti- application terminated with error code 101
[04:51:22] <Luqman> aatch: strcat afaik i'm not sure it could tell at trans whether it's fixed sized array or ~[]
[04:51:32] <Luqman> at least the way it is now
[04:51:45] <aatch> Luqman, I'm pretty sure you're right.
[04:52:46] *** Quits: rubber-duck (rubber-duc@3CAAC67.A9F41D41.76F1346C.IP) (Quit: Leaving)
[04:55:25] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[04:58:49] *** Quits: qmx (qmx@B42C1175.A82378F3.A2BF9DEB.IP) (Quit: Textual IRC Client: www.textualapp.com)
[05:01:16] *** Quits: indirect (indirect_m@moz-770AB053.hsd1.ca.comcast.net) (Connection reset by peer)
[05:02:08] *** Joins: indirect (indirect_m@moz-770AB053.hsd1.ca.comcast.net)
[05:02:40] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:02:50] *** Quits: sankha93 (Instantbir@D4A9A006.DC7B5F6F.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[05:05:56] *** Joins: royw (royw@CB447DD5.6B10AC3.E2F59BBC.IP)
[05:09:59] *** Joins: bjz (brendanzab@moz-E17AB2AB.lnse2.cha.bigpond.net.au)
[05:10:07] <strcat> rusti: 5
[05:10:08] -rusti- 5
[05:10:37] <strcat> rusti: struct Foo { x: int } impl Drop for Foo { fn finalize(&self) {} } std::sys::size_of::<Foo>()
[05:10:38] -rusti- 16
[05:10:47] <strcat> rusti: #[no_drop_flag] struct Foo { x: int } impl Drop for Foo { fn finalize(&self) {} } std::sys::size_of::<Foo>()
[05:10:48] -rusti- 8
[05:11:06] <strcat> rusti: #[no_drop_flag] struct Foo { x: int } impl Drop for Foo { fn finalize(&self) { println("drop") } } let x = Foo { x: 2 }; let y = x;
[05:11:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ITNI
[05:11:15] <strcat> yay
[05:11:30] <aatch> strcat, :D
[05:11:36] <strcat> rusti: #[no_drop_flag] struct Foo { x: int } impl Drop for Foo { fn finalize(&self) { println(self.x.to_str()) } } let x = Foo { x: 2 }; let _y = x;
[05:11:37] -rusti- 2
[05:11:37] -rusti- 0
[05:11:37] -rusti- ()
[05:11:52] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[05:12:15] <dcolish> is Drop like a destructor?
[05:12:24] <strcat> it is a destructor
[05:12:36] <dcolish> nifty
[05:12:56] <strcat> if a type implements Drop, it moves like ~T does
[05:13:13] <strcat> ~ doesn't behave any different than a custom library type
[05:13:53] <aatch> strcat, I just realized that it means you could make ~ a lang item.
[05:14:04] <strcat> aatch: almost
[05:14:09] <strcat> aatch: there's no rooting API for @
[05:14:22] <strcat> so you have to restrict it to T: Owned, or potentially T: NonManaged if we add it
[05:14:22] <aatch> Or right ~-containing-@
[05:14:27] <aatch> I keep forgetting about that...
[05:14:53] <aatch> stupid managed_unique
[05:18:43] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[05:19:55] *** Quits: bytbox (s@moz-2E27684C.student.umd.edu) (Ping timeout)
[05:22:50] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[05:22:57] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[05:23:51] <strcat> woo
[05:23:57] <strcat> no more 'finalize'
[05:24:14] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[05:24:15] <Luqman> \o/ finally!
[05:25:25] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[05:25:26] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[05:25:26] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/F41SFA
[05:25:26] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[05:25:40] <brson> \o/
[05:26:07] <strcat> pcwalton's stuff still needs to land
[05:26:22] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[05:26:28] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[05:27:14] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[05:27:19] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[05:27:42] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[05:27:47] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[05:28:02] <strcat> aatch: http://ix.io/6mZ just edited the one I added to the ffi tutorial a while ago
[05:28:11] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Quit: Coyote finally caught me)
[05:28:19] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[05:28:25] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[05:28:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/7QgWZg
[05:28:25] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[05:28:28] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[05:28:28] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/bVyO9g
[05:28:28] <ghrust> 13rust/06auto 147f61b31 15Alex Crichton: Stop passing --disable-threads to LLVM
[05:28:28] <ghrust> 13rust/06auto 14ebed4d0 15bors: auto merge of #7393 : alexcrichton/rust/enable-threads, r=catamorphism...
[05:28:28] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[05:29:01] <strcat> sys::size_of::<Unique<int>>() == 8
[05:29:02] <strcat> \o/
[05:29:28] <strcat> anyway going to benchmark treemap with it just to see what the headers cost us
[05:29:34] <aatch> strcat, nice.
[05:30:13] <aatch> even it's not friendly enough for normal usage, it at least might net some gains in the libraries.
[05:30:23] <strcat> aatch: well treemap can't use it
[05:30:25] *** Joins: victorporof (victorporo@70DEDDA.9004F55.9B1E38F4.IP)
[05:30:28] <strcat> because then treemap couldn't contain @
[05:30:38] <aatch> Bah, who needs @ anyway
[05:31:08] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[05:32:50] <strcat>  guess it should just call abort on OOM
[05:33:31] *** Joins: dzbarsky (Adium@moz-A7CDB794.dia.static.qwest.net)
[05:33:39] *** Parts: dzbarsky (Adium@moz-A7CDB794.dia.static.qwest.net) ()
[05:37:59] <strcat> aatch: we could still make ~ a lang item
[05:38:11] <strcat> if it contains managed -> just don't use the library unique ptr
[05:38:18] <aatch> strcat, good point.
[05:38:35] <strcat> we can just make a library version *not using exchange/local alloc*
[05:38:45] <strcat> and use it when possible
[05:39:03] <strcat> I think that's probably a good way forward... just start stripping things out of the compiler bit by bit
[05:39:11] <strcat> we could remove exchange alloc
[05:39:16] <aatch> strcat, that seems possible, _right now_.
[05:40:02] <aatch> since we already distinguish between unique and managed_unique
[05:40:12] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[05:40:30] *** Joins: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com)
[05:40:31] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:40:35] <aatch> Hmm, I think this deserves at least a GitHub RFC.
[05:41:50] <strcat> don't think so
[05:41:53] <strcat> not a language change really
[05:42:42] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:43:11] <aatch> What is the purpose of the exchange heap btw?
[05:43:11] *** Quits: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net) (Quit: eatkinson)
[05:43:37] <strcat> aatch: there's not really one yet.
[05:43:47] <strcat> it's what non-managed ~ uses for allocations
[05:43:49] <strcat> but it still has headers
[05:43:53] <strcat> so it needs to be ripped out anyway
[05:44:04] <strcat> ~fn, etc. also use exchange alloc
[05:44:16] <strcat> and that's harder to change than just non-managed ~
[05:44:28] <strcat> because ~fn actually *uses* the header
[05:44:55] <aatch> strcat, I know....
[05:47:01] *** Quits: tjc (tjc@moz-D530ECE9.lightspeed.irvnca.sbcglobal.net) (Quit: Places to go, people to annoy)
[05:48:07] *** bent is now known as bent|zzz
[05:48:59] * strcat replaces all the ~ sigils with Unique and Unique::new
[05:49:23] <strcat> I didn't provide a way to move out of Unique >.<
[05:51:04] <aatch> strcat, wouldn't that just be a `fn move(self) -> T;` method that just does `*self.ptr`?
[05:51:14] <strcat> it won't let you move out of a *T 
[05:51:15] <strcat> ;\
[05:51:22] <strcat>             let x = intrinsics::uninit();
[05:51:23] <strcat>             replace_ptr(self.ptr, x)
[05:51:44] <aatch> that works.
[05:52:27] <aatch> and the take glue, err, takes care of everything else
[05:52:54] *** Joins: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net)
[05:53:01] *** Quits: eatkinson (eatkinson@moz-A7CDB794.dia.static.qwest.net) (Quit: eatkinson)
[05:53:25] <strcat> well actually it will explode
[05:53:26] <strcat> hm
[05:53:44] <strcat> s/uninit/init/
[05:54:02] <aatch> Oh right.
[05:54:17] <aatch> since it'll do the drop, which will try to free it.
[05:54:37] <strcat> anyway too much pain to port treemap to think without sugar ;\
[05:55:01] <strcat> http://ix.io/6n0
[05:55:06] * strcat wants a pointer trait ;[
[05:55:20] <strcat> I'll benchmark something more boring
[05:55:49] <aatch> strcat, well, good news is that there only seem to be like 3-4 places in the compiler that need changing. I think.
[05:56:26] <strcat> take glue, drop glue, etc. ?
[05:57:02] <aatch> Oh right. all those places that expect a box...
[05:57:26] <strcat> yeah it's really a huge problem
[05:57:38] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[05:57:45] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[05:58:08] <aatch> Ok, so I actually meant, 3 or 4 places where you need to change the allocator.
[05:58:19] <strcat> ;p
[05:58:57] <strcat> anyway I don't think it will be easy
[05:59:11] <strcat> this works but we need a Pointer trait to overload the syntax
[05:59:16] <strcat> and it can't contain @ so....
[05:59:20] <strcat> it can't be a drop-in replacement
[06:00:05] *** Joins: alisdair (textual@moz-EBE9F394.bchsia.telus.net)
[06:00:11] *** Quits: alisdair (textual@moz-EBE9F394.bchsia.telus.net) (Client exited)
[06:02:07] <aatch> Ok, well there is only place that handles ~(expr), and only one place for ~[].
[06:02:16] <aatch> I don't know where ~str happens though.
[06:02:17] <strcat> this won't touch ~[]
[06:02:19] <strcat> or ~str
[06:02:21] <strcat> they aren't ~
[06:02:44] <aatch> strcat, good point.
[06:02:44] <strcat> fixing them is even more work
[06:02:53] *** Quits: Houm (Houm@moz-25669AA8.fbx.proxad.net) (Ping timeout)
[06:03:27] <strcat> I could just write myself a faster vector, hashmap, treemap and unique pointer...
[06:03:34] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:04:12] <strcat> annoying to have the whole language pay for @
[06:04:29] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:05:27] <strcat> aatch: and Option<Unique<T>> won't optimize to a nullable pointer
[06:05:44] <strcat> we're going to need an attribute for that too.
[06:06:11] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:06:18] <aatch> strcat, is let a = ~T; let b = a; supposed to copy the entireity of a?
[06:06:25] <strcat> aatch: no
[06:06:29] <strcat> it moves it
[06:06:41] <strcat> supposed to be a ptr copy
[06:06:46] <aatch> Hmm, I must be reading the code wrong.
[06:07:11] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:07:48] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Quit: Leaving)
[06:08:06] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[06:10:40] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:10:51] *** Quits: bent|zzz (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[06:11:12] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:14:13] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:14:24] <aatch> Oh, I was mis-reading the code.
[06:14:36] <aatch> was reading take_ty_immediate.
[06:14:56] <aatch> Which I think is let a = copy b;
[06:15:46] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:16:39] <aatch> Also, I misread the duplicate code, which actually only copies the _box_
[06:17:54] <strcat> aatch: it's supposed to do a deep copy, doesn't it?
[06:18:01] <strcat> well nvm
[06:18:02] <strcat> it's not
[06:18:15] <strcat> if you have ~~T
[06:18:19] <strcat> it needs to copy both
[06:18:32] <aatch> strcat, there's a uniq::duplicate() fn that I was reading wrong.
[06:18:40] <strcat> aatch: what does it actually copy?
[06:18:47] <aatch> strcat, just the box.
[06:18:58] <strcat> aatch: it doesn't duplicate the thing inside the box too?
[06:19:14] <aatch> no, presumable that's somewhere else.
[06:19:17] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Ping timeout)
[06:19:18] <aatch> presumably*
[06:19:32] <aatch> this is actually just let a = b; for ~T
[06:39:48] <aatch> man, having the new iterators would be nice right about now...
[06:45:46] <strcat> you mean the new for loop?
[06:45:50] <aatch> strcat, yes
[06:47:27] *** Joins: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com)
[06:56:04] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[07:00:39] <brson> what order does bors integrate 0-priority pull requests?
[07:00:48] <aatch> brson, issue number
[07:00:59] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[07:01:45] <brson> bors has a lot on his plate tonight
[07:02:03] <Eridius> brson: you r+'d the last version of PR #7216, but it had to get rebased due to a subsequent merge conflict. Could I get a new r+? https://github.com/mozilla/rust/pull/7216
[07:02:42] *** Quits: robert (robertknig@moz-C34822AC.range86-166.btcentralplus.com) (Ping timeout)
[07:02:58] <Eridius> thanks
[07:03:15] *** Quits: bjz (brendanzab@moz-E17AB2AB.lnse2.cha.bigpond.net.au) (Quit: Leaving...)
[07:05:10] *** Joins: nano (nano@moz-972880B.superkabel.de)
[07:05:54] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[07:06:11] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[07:09:17] <pnkfelix> is it just me or is github buggy with respect to not consistently rendering the comments on commits ?
[07:09:29] <cmr> pnkfelix: not just you
[07:09:54] <pnkfelix> or, oh I see, the comment is ending up in the repo we are pulling from ...
[07:11:28] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[07:11:45] *** Joins: fabiand (fabiand@5327474A.8B38C502.16E13E53.IP)
[07:13:25] <cmr> ugh the queue exploded again
[07:13:32] * cmr doesn't think it will ever get smaller
[07:14:00] *** Joins: berak (chatzilla@D010092E.4742BCFA.1A5CC7E5.IP)
[07:14:39] <aatch> cmr, hey, do you think a nicer ast visitor would make your life easier?
[07:14:53] <cmr> aatch: definitely
[07:15:24] <aatch> cmr, sweet, because I've almost finished a first draft of one that uses default methods on trait.
[07:15:33] <cmr> aatch: nice! does it work? :
[07:15:35] <cmr> p
[07:15:48] <aatch> cmr, no idea, I've gotta finish it before it compiles...
[07:20:07] <aatch> but it should make removing more @-ptrs from the compiler possible. Might not have much of an effect on the rest of libsyntax though
[07:20:52] *** Parts: berak (chatzilla@D010092E.4742BCFA.1A5CC7E5.IP) ()
[07:21:28] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[07:23:25] <pnkfelix> aatch: hmm, I've been working on something similar
[07:23:34] <pnkfelix> aatch: https://github.com/mozilla/rust/issues/7081
[07:24:07] *** Joins: dbaupp (Thunderbir@368DC27E.D5A1DCF.37681C44.IP)
[07:24:19] <aatch> pnkfelix, I saw that.
[07:24:56] <pnkfelix> aatch: my work so far is in: https://github.com/pnkfelix/rust/commits/fsk-visitor-refactoring
[07:25:32] <pnkfelix> aatch: but i have been looking at issue 7183 yesterday/today because I had thought that would  be a show-stopper for it
[07:26:01] <aatch> pnkfelix, any reason why?
[07:26:09] *** Quits: timot (timot@9EBCF91B.ABED94CE.898DC978.IP) (Ping timeout)
[07:26:51] <pnkfelix> aatch: because I want the default methods to call out to helper routines?
[07:27:08] <aatch> pnkfelix, I've got around that by having the helper routines in the trait
[07:27:35] <aatch> most visit_* methods are paired with a visit_*_contents method.
[07:27:45] <aatch> since that's what most of them do.
[07:27:47] <pnkfelix> aatch: yeah, I didn't like that because I didn't want people to think that the helpers were meant to be overridden
[07:28:03] <aatch> pnkfelix, I'm not sure it matters.
[07:29:14] <aatch> I generally work on the idea that if an API is sane, then incorrect usage is a user issue.
[07:29:55] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[07:30:33] <pnkfelix> aatch: My view is that it pollutes the trait to have a bunch of methods that are never meant to ever be reimplemented.  But this may just be a matter of taste.
[07:31:00] <aatch> pnkfelix, I think so, since I see it as giving more options to developers.
[07:31:17] <aatch> I mean, this isn't a general-usage thing here...
[07:32:35] <pnkfelix> aatch: in any case, if your approach works, that is nice to know.
[07:34:17] <dbaupp> it seems that supertraits work with default methods
[07:34:26] <dbaupp> rusti: trait Foo { fn foo(&self) {} } trait Bar: Foo { fn bar(&self) { self.foo() } } impl<F:Foo> Bar for F {} impl Foo for uint {} (1u.bar(), 1u.foo())
[07:34:27] -rusti- ((), ())
[07:34:44] <dbaupp> So a `VisitorUtil: Visitor` trait might work?
[07:36:07] <ross> I'm trying to do FFI (I think that's the term), calling a function from a C library I have installed. it compiles, but at runtime I get "cannot open shared object file: no such file or directory"
[07:36:19] <ross> I'm not sure what I'm doing wrong, but it's probably many things
[07:37:19] <ross> the name of the object file it can't find is installed in /usr/local/lib
[07:37:26] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[07:37:26] <strcat> dbaupp: \o
[07:37:26] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/bVyO9g
[07:37:26] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[07:37:40] <dbaupp> strcat: hi
[07:37:41] <cmr> ross: is /usr/local/lib in your LD_LIBRARY_PATH/ld.so.conf
[07:37:51] <strcat> dbaupp: https://mail.mozilla.org/pipermail/rust-dev/2013-June/004599.html
[07:38:04] <dbaupp> strcat: I saw
[07:38:12] <dbaupp> Looks good!
[07:38:37] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[07:39:00] <dbaupp> I don't quite understand why we need T: Iterator<A> in the trait bound though
[07:39:08] <strcat> dbaupp: because otherwise it's not *useful*
[07:39:10] <dbaupp> since typeck can just catch it whenever you try to use it
[07:39:24] <strcat> if you take Iterable<A>, you need the compiler to let you treat the return value as an Iterator<A>
[07:39:28] <pnkfelix> aatch: do you have a draft of your changes up on your github repo yet?
[07:39:36] <aatch> pnkfelix, not yet.
[07:39:42] <aatch> They're not even in the tree.
[07:39:45] <strcat> dbaupp: atm it won't treat the T return value as Iterator<A>
[07:39:50] <dbaupp> strcat: yeah... ?
[07:39:52] <ross> cmr: I have no idea. what/where is that?
[07:39:55] <strcat> dbaupp: so you can't use the trait
[07:40:02] <aatch> I have a visit_new.rs file that's a standalone binary...
[07:40:05] <cmr> ross: it's an environment variable/config file in /etc
[07:40:06] <dbaupp> strcat: but whenever it is used, it'll be infered to have the Iterator<A> bound
[07:40:12] <ross> k
[07:40:14] <strcat> dbaupp: no
[07:40:17] <strcat> generics don't work that way
[07:40:25] <strcat> you can take an Iterable<A> as a parameter
[07:40:25] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:40:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xTscpw
[07:40:25] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:40:27] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[07:40:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/3UveRQ
[07:40:27] <ghrust> 13rust/06auto 1400d5a86 15Brian Anderson: rt: Release big stacks immediately after use to avoid holding on to them through yields...
[07:40:27] <ghrust> 13rust/06auto 1413b8c0d 15bors: auto merge of #7111 : brson/rust/stack, r=brson...
[07:40:28] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[07:40:34] <strcat> when you call .iter(), it needs to return an Iterator<A>
[07:40:40] <strcat> but atm rust doesn't know what it returns
[07:40:44] * strcat shrugs
[07:40:50] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[07:40:53] <dbaupp> strcat: you take a Iterable<A, T>
[07:41:00] <strcat> true
[07:41:00] <dbaupp> strcat: so you can put a bound on the T
[07:41:09] <strcat> that's really annoying though
[07:41:14] <dbaupp> yes
[07:41:29] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[07:41:29] <dbaupp> but how often will someone be taking Iterable, rather than Iterator?
[07:41:31] <strcat> <A, T: Iterator<A>, U: Iterable<T>>
[07:41:38] <strcat> dbaupp: dunno
[07:41:40] <strcat> ;p
[07:42:07] <dbaupp> So, yeah, I think there's nothing blocking a basic Iterable trait (which can be made more usable later)
[07:42:19] <ross> cmr: it looks like yes. it's in /etc/ld.so.conf.d (which seems to be included be ld.so.conf)
[07:42:30] <ross> libc.conf *
[07:42:50] <dbaupp> however, I don't know if bounds-in-trait actually remove the requirement for T: Iterator, U: Iterable<T>
[07:43:15] <cmr> brson: rustc doesn't quite work under the newrt it seems, zsh: segmentation fault (core dumped)  RUST_NEWRT=1 ./x86_64-unknown-linux-gnu/stage2/bin/rustc --passes="" --cfg  -
[07:43:43] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[07:43:57] <aatch> pnkfelix, this what I have so far: https://gist.github.com/Aatch/5865492
[07:44:12] <aatch> It compiles. That's all I've tested so far.
[07:44:18] <aatch> It's also incomplete.
[07:45:39] <ross> looking more carefully, it seems the particular version of the library it's looking for is a link to a newer one. is that a problem?
[07:47:33] <dbaupp> strcat: we could even have "auto-borrowing" of Iterable to Iterator, but that might be too magical
[07:47:39] <strcat> dbaupp: python does
[07:47:43] <strcat> so why not us
[07:47:59] <strcat> magic is fine if it's intuitive and has no corner cases
[07:48:00] <hoelzro> I was converting some code I wrote last night from 0.6 to HEAD and it seems that the value of for expressions have changed; is it indeed the case that a for expression may only have a boolean value now?
[07:48:02] <dbaupp> that's slightly different, right?
[07:48:05] <strcat> dbaupp: not really
[07:48:14] <strcat> dbaupp: python has magic methods names
[07:48:18] <dbaupp> strcat: since Python essentially consumes iterators via for always
[07:48:28] *** Joins: artagnon (uid7560@moz-A588D045.irccloud.com)
[07:48:31] <strcat> dbaupp: hm?
[07:48:35] <cmr> hoelzro: for now (probably going to change in the next few days). http://smallcultfollowing.com/babysteps/blog/2013/01/16/revised-for-loop-protocol/
[07:48:36] <strcat> dbaupp: it has other ways of doing it
[07:48:44] <hoelzro> ah, thanks cmr
[07:48:49] <artagnon> Is there some way to get rust to compile faster?  The turnaround time is getting on my nerves.
[07:49:03] <dbaupp> strcat: where as we can have `fn do<T, I: Iterator<T>>(it: I)` `do(~[1,2,3])`
[07:49:07] <aatch> artagnon, fix the performance issues?
[07:49:12] <artagnon> How?
[07:49:16] <mcpherrin> artagnon: LOL :)
[07:49:17] <strcat> dbaupp: you can do it other ways in python
[07:49:21] <artagnon> Some pointers to get me started?
[07:49:23] <dbaupp> strcat: such as?
[07:49:32] <aatch> artagnon, most of trans
[07:49:37] <mcpherrin> artagnon: become an expert in rust, and rewrite the compiler to be faster ;)
[07:49:40] <artagnon> Is there some profiler I can use?
[07:49:40] <strcat> dbaupp: well let me explain how it works in python ;p
[07:49:51] <cmr> artagnon: what OS are you using?
[07:49:57] <artagnon> Linux.
[07:50:02] <pnkfelix> aatch: okay.  I wanted to compare against my own version, see how much overlap/redundancy in work we were looking at
[07:50:09] <cmr> https://perf.wiki.kernel.org/index.php/Main_Page
[07:50:13] <cmr> Best tool for the job IMO
[07:50:33] <artagnon> I was hoping for something like Valgrind.
[07:50:36] <strcat> dbaupp: there are 4 magic methods involved, .__iter__, .__reversed__, .__length_hint__ and .__next__
[07:50:45] <artagnon> I use Callgrind quite a bit.
[07:50:45] <dbaupp> strcat: yup
[07:51:00] <strcat> dbaupp: an iterator in python has a .__next__ method, and you get one from an iterable with .__iter__
[07:51:06] <strcat> or __reversed__ via reversed()
[07:51:06] <artagnon> Also, what takes time is the stage0 -> stage1 -> stage2.
[07:51:10] <strcat> iter() calls .__iter__
[07:51:13] <artagnon> Is that really necessary every single time?
[07:51:15] <strcat> next() calls .__next__
[07:51:19] <artagnon> For even the trivial changes?
[07:51:29] <strcat> a for look calls .iter()
[07:51:32] <strcat> always
[07:51:36] <cmr> artagnon: no, quite frequently you only need to do make rustc-stage1
[07:51:41] <strcat> err
[07:51:43] <strcat> .__iter__
[07:51:51] <artagnon> cmr: Excellent.  Thanks for the tip.
[07:51:51] <strcat> and then it calls .__next__ until it throws StopIteration
[07:51:54] *** Joins: Earnestly (earnest@C3C47836.2F03E712.4FA5093E.IP)
[07:52:00] <artagnon> That'll shave off some time for sure.
[07:52:01] <strcat> python iterators are iterables
[07:52:03] <cmr> artagnon: and you can test the compiler in $arch/stage1/bin/rustc
[07:52:10] <artagnon> Right.
[07:52:20] <strcat> at least some of them...
[07:52:22] <artagnon> I currently test the one in stage2/
[07:52:23] <strcat> not all are
[07:52:35] <cmr> Callgrind works with rust, too, btw
[07:52:45] <dbaupp> strcat: right
[07:52:57] <artagnon> Oh, does it compile with all the debugging symbols?
[07:52:59] <dbaupp> strcat: but when does automatic iterable -> iterator coercion happen?
[07:53:07] <artagnon> Equivalent of -g -O0?
[07:53:20] <strcat> dbaupp: for pattern in iterator_or_iterable: pass
[07:53:21] <dbaupp> strcat: (the only time I know is in a for loop/comprehension/generator expression)
[07:53:22] *** Joins: nano (nano@moz-972880B.superkabel.de)
[07:53:28] <cmr> artagnon: -Z debug-info
[07:53:37] <dbaupp> strcat: right
[07:53:46] <aatch> artagnon, no. and if you compiled without opimizations, it would actually take longer after stage1
[07:53:52] <strcat> dbaupp: ok well I'm not really getting what you mean then
[07:54:00] <dbaupp> strcat: so currently the plan for Rust is for loops "coerce" Iterable -> Iterator
[07:54:15] <strcat> dbaupp: well they'll check if it's an Iterator
[07:54:16] <dbaupp> strcat: even though there are other situations when one wants to convert Iterable -> Iterator
[07:54:18] <strcat> if not, they'll try getting one
[07:54:23] <dbaupp> (because we have a type system.)
[07:54:32] <artagnon> cmr: Where do I pass the -Z?  Not to make?
[07:54:35] <strcat> dbaupp: can always just call .iter() though
[07:54:44] <strcat> the only reason to have for do it is sugar
[07:54:46] <artagnon> aatch: I only care about stage1 now.
[07:54:52] <dbaupp> strcat: yes, and I'm asking if we want to make it sugared?
[07:55:08] <artagnon> make check works with stage1, right?
[07:55:19] <cmr> make check-stage1 or something similar
[07:55:24] * cmr can never remember all the targets
[07:55:36] <dbaupp> strcat: i.e. sugared for 'for' loops and for the `do(~[1,2,3])` example above
[07:55:46] <artagnon> Ok, good.
[07:55:50] <aatch> specifically make check-stage1 NO_REBUILD=1 if you've only changed tests.
[07:55:50] <strcat> dbaupp: I think that's too magical
[07:56:05] <dbaupp> strcat: I don't disagree
[07:56:08] <pnkfelix> aatch: (there might be a lot of overlap in the approaches, I'm not sure yet.  I'll know more after I finish adopting your workaround for #7183)
[07:56:15] <dbaupp> strcat: anyway, I've got to go
[07:56:18] <strcat> \o
[07:56:47] <artagnon> aatch: Shouldn't the build system auto-detect that?
[07:56:52] <artagnon> And not rebuild the entire thing?
[07:57:00] <aatch> artagnon, not if you change the tests in the crates
[07:57:06] <aatch> the things marked #[test]
[07:57:08] <artagnon> Ah, ok.
[07:57:14] <cmr> I have an issue open about teaching it to do that
[07:57:48] <artagnon> Also, why do incremental builds take so long?
[07:57:57] <strcat> incremental builds?
[07:57:58] <artagnon> If I change one line in one file, why does it rebuild the entire thing?
[07:58:05] *** Quits: dbaupp (Thunderbir@368DC27E.D5A1DCF.37681C44.IP) (Ping timeout)
[07:58:07] <aatch> artagnon, beacuse they're not incremental builds
[07:58:08] <cmr> We don't have incremental builds, that's the problem :)
[07:58:13] <artagnon> It should have the *.o files, no?
[07:58:16] <artagnon> Damn it.
[07:58:16] <aatch> the unit of compilation is an entire crate
[07:58:18] <aatch> artagnon, nope
[07:58:23] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[07:58:24] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1413b8c0d to 14ebed4d0: 02http://git.io/N3iJvQ
[07:58:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[07:58:24] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:58:24] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/JDmcYQ
[07:58:24] <ghrust> 13rust/06auto 14c109bed 15Alex Crichton: Deny common lints by default for lib{std,extra}
[07:58:24] <ghrust> 13rust/06auto 1409b4525 15bors: auto merge of #7113 : alexcrichton/rust/banned-warnings, r=cmr...
[07:58:24] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:58:35] <strcat> and the crates generally all depend on each other in a serial chain
[07:58:39] <strcat> for rust
[07:58:43] <strcat> libextra depends on libstd
[07:58:49] <strcat> libsyntax depends on libextra and libstd
[07:58:53] <artagnon> Okay, in the worst case, it should rebuild one crate, right?
[07:58:53] <strcat> librustc depends on all 3
[07:58:58] <strcat> artagnon: nope
[07:59:00] <artagnon> Damn it.
[07:59:09] <aatch> artagnon, nope, worst case is 4
[07:59:27] *** Quits: brson (brson@72B1AFF8.AD1E507F.3688B332.IP) (Quit: leaving)
[07:59:31] <artagnon> Is something being done to improve this?
[07:59:38] <strcat> not right now
[07:59:43] <strcat> rustc could be 100x faster
[07:59:44] <strcat> that'd help
[07:59:48] <aatch> artagnon, it's very difficult to fix.
[07:59:57] <artagnon> I see.
[08:00:02] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[08:00:03] <aatch> artagnon, it's not like we don't know about these issues.
[08:00:16] <artagnon> Ofcourse, everyone must be super-annoyed with the build time.
[08:00:19] <aatch> The one about incremental compilations has been open for over a year.
[08:01:16] <strcat> artagnon: sure but at this point someone can spend 5 hours and speed up rustc overall by 10% if they clean up trans
[08:01:27] <strcat> incremental builds are a lot harder to implement
[08:01:46] <aatch> trust me, I've looked into it...
[08:01:47] <strcat> you'd need to get librustc to figure out the dependencies within the crate
[08:01:54] <strcat> and that's just the starting point
[08:01:58] <strcat> and dependencies are hard to figure out
[08:02:03] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[08:02:03] *** Joins: bugweiser (Mibbit@moz-1FEAB537.ucsf.edu)
[08:02:18] *** Quits: bugweiser (Mibbit@moz-1FEAB537.ucsf.edu) (Quit: http://www.mibbit.com ajax IRC Client)
[08:02:18] <artagnon> Okay, although I don't think I'm experienced enough to clean up trans.
[08:02:38] <artagnon> And 10% doesn't seem like much at all, considering that I have to wait 20+ minutes for a build :/
[08:02:40] <aatch> artagnon, that's fine. trans is a mess to work with.
[08:03:03] <aatch> artagnon, but 10% for 1 change in one days work.
[08:03:04] <artagnon> Let me know if there are some easy bugs that I can help out with at the moment.
[08:03:10] <strcat> lots
[08:03:28] <strcat> https://github.com/mozilla/rust/issues?direction=desc&labels=E-easy&page=1&sort=created&state=open
[08:03:30] <strcat> ;p
[08:03:36] <aatch> https://github.com/mozilla/rust/issues?labels=E-easy
[08:03:49] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[08:03:51] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[08:03:54] <artagnon> Yeah, I saw those; they're not "easy" :/
[08:04:11] <artagnon> Anyway, I'll try.
[08:04:12] <artagnon> Thanks.
[08:04:32] <strcat> artagnon: https://github.com/mozilla/rust/issues/7360 this is an especially easy one
[08:04:46] <aatch> artagnon, they're relatively easy, just not necessarily quick.
[08:04:50] <strcat> just need to wrap std::vec::VecIterator
[08:04:58] <strcat> anyway there are a lot
[08:05:02] <artagnon> Okay, cool.  I'll pick 7360.
[08:05:20] <artagnon> And 4536 that cmr gave me.
[08:06:05] <aatch> pnkfelix, ok, so trying to actually _use_ that trait doesn't seem to work
[08:06:07] <strcat> I think I'll kick most of std::iter into libextra
[08:06:24] <aatch> I hit an ICE
[08:06:25] <strcat> Times can stay for now...
[08:07:01] *** Parts: artagnon (uid7560@moz-A588D045.irccloud.com) ()
[08:09:55] * strcat wonders where to put it
[08:11:01] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[08:12:48] <pnkfelix|rcirc> aatch: interesting.  i guess that is to be expected
[08:13:01] *** Joins: timot (timot@moz-BB6B16A1.cust.telenor.se)
[08:13:38] *** Quits: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP) (Ping timeout)
[08:13:41] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[08:13:45] <strcat> the remaining each calls are mostly SmallIntMap ;p
[08:14:00] <strcat> and broken docstring examples...
[08:14:21] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[08:14:26] *** Joins: cr (anonymous@moz-9D6CBECC.dip0.t-ipconnect.de)
[08:15:36] *** Quits: fabiand (fabiand@5327474A.8B38C502.16E13E53.IP) (Ping timeout)
[08:17:15] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[08:19:54] *** Quits: timot (timot@moz-BB6B16A1.cust.telenor.se) (Ping timeout)
[08:21:08] <ross> yay it finally works. feels awesome
[08:22:13] <ross> my error was downloading the library and doing make, make install. it put it some place that couldn't be found I guess (I am bad at linux). eventually I found the package in apt and installed it that way
[08:26:34] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[08:30:41] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:33:29] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[08:36:04] *** Quits: royw (royw@CB447DD5.6B10AC3.E2F59BBC.IP) (Quit: royw)
[08:36:45] *** Joins: sebcrozet (Mibbit@moz-D8879CC3.w80-13.abo.wanadoo.fr)
[08:37:54] <sebcrozet> Hi.
[08:38:17] *** Joins: Blub\w (wry@moz-8E0843B9.wireless.dyn.drei.com)
[08:38:21] <sebcrozet> I got the error:  value may contain borrowed pointers; add `'static` bound
[08:38:34] <aatch> sebcrozet, post code
[08:40:40] <sebcrozet> aatch: I dont have a minimal exemple. But it is like in https://github.com/graydon/rust/blob/2bed5dc528c120e571a75ef77349cd3222ce4cd3/src/test/compile-fail/kindck-owned-trait-scoped.rs
[08:40:53] <sebcrozet> aatch: I dont understant what is going on there
[08:41:35] <sebcrozet> aatch: what does 'static mean?
[08:41:46] <aatch> sebcrozet, 'static is a lifetime bound.
[08:42:03] <aatch> http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[08:42:35] <sebcrozet> aatch: yes, but, what is the special meaning of 'static
[08:42:40] <pnkfelix> sebcrozet: it is a special lifetime bound that means "I live forever."
[08:43:27] <sebcrozet> pnkfelix: ok. And why is this needed for the struct-to-trait-object cast?
[08:43:28] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:43:29] <pnkfelix> sebcrozet: thus constraining the kinds of values that can be assigned that bound.  (e.g. not stack-allocated stuff, or even heap-allocated stuff IIUC)
[08:44:29] <aatch> It's a limitation in the current system. Though it is being worked on.
[08:45:56] <sebcrozet> so on a function like fn foo<T: 'static>(t: &T); t cannot be a pointer to anything but a static object?
[08:47:41] <pnkfelix> sebcrozet: (I'm still trying to interpret the comments in the test case you posted, which do not 100% jibe with my understanding of "'static")
[08:49:58] <sebcrozet> pnkfelix: I tend to think that the 'static is needed for any type parameter which is not known by the trait we are casting to (here T is known by F, but not by the trait foo itself).
[08:52:17] <pnkfelix> sebcrozet: ah, I see why the comments were misleading me 
[08:52:21] <doomlord> interesting, "filter_map" .. list-comprehension done with option
[08:52:39] <doomlord> as opposed to (predicateFunc, mapperFunc)
[08:52:46] <pnkfelix> sebcrozet: the test case talks e.g. about "owned" in the comments and in the test's filename
[08:52:46] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[08:53:33] <pnkfelix> sebcrozet: but the bound referenced here is 'static.
[08:54:37] <pnkfelix> sebcrozet: so maybe 'static does not mean what I thought it meant, if it really now is a replacement for "T: Owned"
[08:55:14] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (Quit: pyrac)
[08:56:07] <sebcrozet> pnkfelix: interesting. You seem to be right: replacing both 'static and Owned work in my code.
[08:56:27] <sebcrozet> pnkfelix: s/replacing/using/
[08:56:48] <aatch> pnkfelix, that's not strictly true.
[08:56:51] <pnkfelix> sebcrozet: it is also possible that "'static" and "Owned" are not the same
[08:56:59] <aatch> since &Trait is not owned
[08:57:04] <aatch> but must have a static bound
[08:57:25] <aatch> Same with @Trait
[08:57:34] <aatch> Owned is actually a misnomer.
[08:58:11] <sebcrozet> aatch: mmh maybe I misunderstand Owned. Owned means "pointer owned by one and only one object at a time" right?
[08:58:14] <pnkfelix> aatch: did the term "Owned" actually go away (i.e. get replaced by "static bound"), or are they distinct concepts? 
[08:58:33] <aatch> pnkfelix, well Owned is a kind, but it's more to do with the sendability.
[08:58:49] <aatch> Which is why I was sure it had already been renamed...
[08:58:54] <aatch> I don't know.
[08:59:48] <sebcrozet> aatch: Owned should be renamed by what?
[09:00:01] <aatch> pnkfelix, anyway, I think the source of my ICE is the same as the source of your error at: https://github.com/mozilla/rust/issues/7183
[09:00:07] <aatch> sebcrozet, to Send(able)
[09:00:50] <strcat> aatch: it's an open PR
[09:01:03] <aatch> strcat, how long has it been open!
[09:01:07] <strcat> aatch: https://github.com/mozilla/rust/pull/7396
[09:01:13] <strcat> aatch: well it's all of pcwalton's work for a while
[09:01:15] <strcat> ;p
[09:01:21] <aatch> strcat, grr.
[09:01:43] <aatch> pcwalton has a habit of dumping a PR then buggering off for the night.
[09:02:25] <aatch> so by the time he gets back, it's bit-rotted and he has to rebase. Which he may-or-may not do.
[09:03:26] <strcat> anyway, sleep ;p
[09:03:29] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[09:03:35] *** aatch is now known as aatch|gone
[09:04:43] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[09:13:23] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[09:13:58] *** Quits: sebcrozet (Mibbit@moz-D8879CC3.w80-13.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[09:14:00] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[09:14:57] *** Quits: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com) (Quit: tav)
[09:17:29] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Input/output error)
[09:17:38] *** Joins: z0w0 (zack@moz-C2225B9E.lnse3.cha.bigpond.net.au)
[09:32:54] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[09:35:49] *** Joins: bjz (brendanzab@moz-E17AB2AB.lnse2.cha.bigpond.net.au)
[09:36:15] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[09:38:12] *** Joins: fabiand (fabiand@moz-58695F16.adsl.alicedsl.de)
[09:39:16] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:48:04] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Connection reset by peer)
[09:48:24] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:49:59] *** Quits: fabiand (fabiand@moz-58695F16.adsl.alicedsl.de) (Ping timeout)
[09:50:43] *** Joins: roo (jesse.rudo@moz-DC85D82C.dynamic.ip.windstream.net)
[09:52:38] *** Joins: snearch (snearch@moz-CF918F37.pool.mediaways.net)
[09:53:58] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[09:54:47] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:55:52] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[09:56:11] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[09:57:38] *** Joins: Seldaek (seld@moz-5DEA7688.ch)
[09:59:50] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[09:59:58] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[10:00:18] *** Quits: roo (jesse.rudo@moz-DC85D82C.dynamic.ip.windstream.net) (Ping timeout)
[10:00:21] *** Joins: pyrac (pyrac@moz-C4B13AD4.math.u-bordeaux1.fr)
[10:01:28] <engla> things bitrot over just one night?
[10:06:34] *** Quits: bjz (brendanzab@moz-E17AB2AB.lnse2.cha.bigpond.net.au) (Quit: Leaving...)
[10:07:25] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[10:07:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/JDmcYQ
[10:07:25] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[10:07:28] <engla> doomlord: filter_map is practical because you only have to pattern match on the argument once, and can use the same variable in both test and mapping.. which I guess is why it's just like a list comprehension
[10:09:41] <doomlord> i guess its easier to have shared intermediates between the predicate and the map function
[10:10:23] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[10:10:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/43CELA
[10:10:24] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[10:10:24] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[10:10:24] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/Q7Rj6g
[10:10:24] <ghrust> 13rust/06auto 14b8b2d1e 15Kevin Ballard: Make task_rng() return @mut R instead of @@mut R
[10:10:24] <ghrust> 13rust/06auto 144ec05e0 15bors: auto merge of #7216 : kballard/rust/task_rng, r=brson
[10:10:24] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[10:20:45] <engla> doomlord: someone asked for python list comprehensions, so I made this macro http://paste.debian.net/plain/12759
[10:21:29] <doomlord> a macro to combine a predicate and mapper function i presume 
[10:22:20] <engla> it's trivial to be honest
[10:22:34] <engla> the macro just rewrites the syntax 
[10:23:12] <doomlord> thats rather nice, how that worked out in rust
[10:23:54] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[10:23:58] *** Quits: pyrac (pyrac@moz-C4B13AD4.math.u-bordeaux1.fr) (Quit: pyrac)
[10:25:45] *** kimundi is now known as zz_kimundi
[10:30:53] *** Joins: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP)
[10:30:55] *** Joins: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se)
[10:31:12] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Ping timeout)
[10:34:16] *** Joins: artagnon (uid7560@moz-A588D045.irccloud.com)
[10:34:30] <artagnon> So I'm not 100% sure I've not done something stupid: https://github.com/mozilla/rust/pull/7404
[10:34:56] <artagnon> Oh, strcat isn't here now; I'd appreciate it if someone could quickly check.
[10:35:18] *** Joins: Blei (philipp@moz-7077963E.ethz.ch)
[10:39:08] *** Joins: mw (mw@moz-8D77CF86.adsl.highway.telekom.at)
[10:40:54] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[10:41:21] <engla> well it looks like it should work fine artagnon 
[10:41:35] <artagnon> Cool, thanks for the sanity check.
[10:41:47] <engla> it should also be possible to implement an iterator that consumes the PQ and yields the values in order right
[10:42:38] <artagnon> What is the "right" order?  The original order from the vector that was fed in?
[10:42:52] <artagnon> Is that ordering information present in the pq in the first place?
[10:43:18] <engla> the order you get if you .pop() repeatedly
[10:43:50] <artagnon> Yeah, that's the order you get.
[10:44:00] <artagnon> See test_top_and_pop()
[10:44:16] <artagnon> heap.pop() is compared with sorted.pop().
[10:44:50] <engla> that's not the order you get from .data
[10:44:51] <engla> just to be clear
[10:45:52] <artagnon> It is, no?  fn pop(&mut self) -> T just calls self.data.pop().
[10:46:20] <engla> no it does siftdown too
[10:46:22] <engla> to adjust the heap
[10:46:38] <artagnon> Oh, ok.
[10:46:43] <engla> the heap structure is that   data[0] is always the best element, but the rest is just a heap structure
[10:47:18] <engla> as in Wikipedia: Heap (data structure)
[10:47:20] <artagnon> Right, so my iterator returns it in more-or-less a "random" order.
[10:47:38] <artagnon> I failed to notice that .data is a heap.
[10:48:25] <artagnon> Hm, it just "seems" to work in my test incidentally.
[10:48:35] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[10:48:35] <artagnon> I'll amend the commit message to make this clear.
[10:48:41] <artagnon> Thanks for pointing this out.
[10:49:07] <engla> sure. the iterator does the same as the old each so it seems fine
[10:49:20] <engla> just saying that a consuming ordered iterator would probably make sense too
[10:50:03] <artagnon> Most certainly.
[10:51:19] <ross> I feel dumb, can't get this to work. I have an enum in one file, and I'm trying to match on it
[10:51:40] <artagnon> Fixed.
[10:51:41] <ross> it can resolve the enum name for a function parameter, but when I try to match on it, it says unresolved enum variant for both
[10:52:06] <artagnon> I also did s/sorted/iterout/ to make sure that the variable name isn't misleading.
[10:53:33] <engla> artagnon: another thing, not saying you need to change this, but I prefer to say Arbitrary to mean "no guarantees" instead of Random ("deliberately jumbled")
[10:53:47] <artagnon> Yeah, I just fixed that :)
[10:54:12] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[10:54:36] <engla> note that hashmaps still say arbitrary order even if it's actually almost random order (due to keyed hashing with random key)
[10:54:56] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[10:56:18] <engla> ross: do you import the variant names?
[10:56:53] * artagnon goes off to work on more patches
[10:56:55] *** Parts: artagnon (uid7560@moz-A588D045.irccloud.com) ()
[10:56:56] <ross> nope. but that fixed it
[10:57:36] <ross> the enum is called Color, in video.rs. I had earlier tried: use video::Color::*
[10:57:47] <ross> but I got an error so I gave up without trying the variants specifically
[10:58:19] <ross> the error said: cannot import from a trait or type implementation
[10:58:26] <ross> engla thanks :)
[11:00:00] *** Joins: roo (jesse.rudo@moz-6351173F.dynamic.ip.windstream.net)
[11:05:26] *** Quits: roo (jesse.rudo@moz-6351173F.dynamic.ip.windstream.net) (Ping timeout)
[11:06:05] *** Joins: roo (jesse.rudo@moz-CFB877C8.dynamic.ip.windstream.net)
[11:07:28] *** Joins: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP)
[11:07:34] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[11:08:05] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:15:33] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[11:16:26] *** Quits: LimeBurst (me@247D1419.D73964AC.27A8748.IP) (Ping timeout)
[11:17:57] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[11:18:09] *** Joins: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[11:21:43] *** Joins: LimeBurst (me@247D1419.D73964AC.27A8748.IP)
[11:22:22] *** Joins: testing (Mibbit@moz-D5A41FD7.bbtec.net)
[11:23:15] *** Quits: ysuzuki_ (ysuzuki@moz-36FBA934.net124047241.t-com.ne.jp) (Quit: Tiarra 0.1+svn-39209: SIGINT received; exit)
[11:23:23] *** Joins: ysuzuki (ysuzuki@moz-36FBA934.net124047241.t-com.ne.jp)
[11:25:13] *** Joins: fabiand (fabiand@BABB0116.DC24CC58.16E13E53.IP)
[11:25:26] *** Quits: testing (Mibbit@moz-D5A41FD7.bbtec.net) (Quit: http://www.mibbit.com ajax IRC Client)
[11:25:29] <engla> is there a way to create a "virtual tuple"?    create a type &(A, B)  from &A and &B for the duration of a method call?
[11:25:30] *** Quits: roo (jesse.rudo@moz-CFB877C8.dynamic.ip.windstream.net) (Ping timeout)
[11:26:23] <engla> something like   match (1,2) { (ref a, ref b) => (*a, *b).method() }  
[11:26:44] <pnkfelix|rcirc> engla: I don't think so, unless you can copy them; isn't the type &(A, B) making a statement about the memory layout (A followed by B) that you can't satisfy with &A and &B alone?
[11:27:02] <engla> you are probably right
[11:27:27] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:28:00] <pnkfelix|rcirc> engla: but, wait
[11:28:02] *** Joins: bjz (brendanzab@moz-E17AB2AB.lnse2.cha.bigpond.net.au)
[11:28:13] <engla> it's a good point. the implementation probably wants a contiguous tuple
[11:28:19] <pnkfelix|rcirc> engla: are you literally just trying to write code after the "(ref a, ref b) => ..."  case?
[11:28:41] <pnkfelix|rcirc> engla: because you can bind the whole structure in addition to binding references to its substructure.
[11:28:46] <engla> basically. it's for a tuple enum
[11:29:06] <engla> match tree { Node(a,b,c) => (a,b,c).method() 
[11:29:16] <engla> something like that
[11:30:00] *** Parts: mw (mw@moz-8D77CF86.adsl.highway.telekom.at) ()
[11:30:00] <engla> right now I do   match tree.clone() {    and I can move the parts to a tuple and call the method
[11:30:07] <pnkfelix|rcirc> engla: oh okay, that's a little different than what I was thinking
[11:30:19] <engla> yeah I should have used the real example
[11:30:20] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[11:32:20] <engla> so the question is actually is there a way to get a type   &(A,B) from an enum variant like  Node(A, B)
[11:32:23] *** Joins: roo (jesse.rudo@moz-5D6062B5.dynamic.ip.windstream.net)
[11:32:39] <engla> in that case the underlying representation is maybe even the same
[11:33:11] <Blei> transmute! (no, don't do that)
[11:33:32] <engla> I might try it just for curiosity
[11:33:59] <doener> probably won't work, the tag has to be somewhere, so it should complain about sizes I guess
[11:34:35] <Blei> well, then: unsafe pointers!
[11:34:48] <Blei> actually, i don't know the memory layout of tuples
[11:34:59] <engla> killjoy
[11:35:25] <engla> normal struct layout makes sense
[11:35:28] <engla> for tuples
[11:35:47] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[11:35:52] <Blei> then i'd guess you'd have to cast the address to the first enum element to the tuple
[11:36:59] <Blei> something like  match foo { Node(ref a, _) => let t: (int, int) = unsafe{ &*((a as *int) as *(int, int)) }; t.foo() }  ?
[11:38:29] <doener> doesn't t need type &(int, int)=
[11:38:33] <doener> s/=/?/
[11:38:50] <Blei> ah, right
[11:38:53] *** Joins: rubber-duck (rubber-duc@E34C8909.13F85533.76F1346C.IP)
[11:39:05] <engla> Blei: casting the ref to the first element seems to work
[11:39:11] <engla> just for fun, mind you
[11:39:21] <Blei> don't do this at home, kids
[11:39:39] <pnkfelix|rcirc> engla: it actually sounds like a reasonable feature request [being able to borrow the enum variant Node(A, B) to the tuple (A, B), that is].  Maybe ask Niko what he thinks of it.
[11:39:41] <doener> yeah, at work it's totally fine :-p
[11:39:43] <Blei> or rather: don't do this at work, colleagues
[11:40:44] *** Quits: roo (jesse.rudo@moz-5D6062B5.dynamic.ip.windstream.net) (Ping timeout)
[11:40:53] <rubber-duck> is there a pattern to do while foo() Some(bar) { bar.... }  ?
[11:41:39] <engla> pnkfelix|rcirc: ok
[11:42:01] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[11:42:05] *** Joins: roo (jesse.rudo@moz-8D7BCDC3.dynamic.ip.windstream.net)
[11:42:43] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Quit: Leaving)
[11:42:44] <doener> rubber-duck: I don't think I understand what that snippet is supposed to do
[11:42:51] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[11:43:09] <rubber-duck> I want to loop while the result of Foo is Some and capture value of Some inside of loop 
[11:43:17] <roo> rubber-duck: i don't believe so, I generally do something like loop { match foo() { Some(bar) { ... } _ => break; }
[11:44:03] <rubber-duck> but isn't this a common practice if you want to use Option<T> to signal "end of stream"
[11:44:44] <doener> rubber-duck: looks like your foo() is next() on an iterator
[11:44:56] <engla> nmatsakis: ping (about discussion above)
[11:45:01] *** Quits: roo (jesse.rudo@moz-8D7BCDC3.dynamic.ip.windstream.net) (Ping timeout)
[11:45:02] <rubber-duck> donri, it is but there's more than one method
[11:45:19] <doener> rubber-duck: if you implement the Iterator trait, you could use "for iter.advance |bar| { bar }"
[11:45:45] <donri> rubber-duck: mistab
[11:45:47] *** Joins: roo (jesse.rudo@moz-FD430DFD.dynamic.ip.windstream.net)
[11:45:50] <rubber-duck> donri, sry
[11:45:50] <doener> or just "for iter |bar| { bar }" (or sth. like that) once the new for loop lands
[11:45:54] <donri> np
[11:46:16] <rubber-duck> doener, sure but I need to advance the "iterator" inside the loop and use different methods
[11:46:48] <rubber-duck> doener, so it won't fit as iterator 
[11:47:07] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[11:49:00] <doener> rubber-duck: looking through Option revealed while_some()
[11:50:05] *** Quits: jclements (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Ping timeout)
[11:50:13] *** Quits: roo (jesse.rudo@moz-FD430DFD.dynamic.ip.windstream.net) (Ping timeout)
[11:50:21] *** Joins: pyrac (pyrac@moz-C4B13AD4.math.u-bordeaux1.fr)
[11:50:38] <doener> hm, misread the signature, won't fit quite as is
[11:53:01] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[11:53:06] <hoelzro> what library does rust-lang.org use for highlighting the example code on the frontpage?
[11:53:29] *** Quits: snearch (snearch@moz-CF918F37.pool.mediaways.net) (Quit: Verlassend)
[11:53:42] *** Joins: vittorioromeo (quassel@moz-15A9910A.retail.telecomitalia.it)
[11:54:29] <rubber-duck> doener, actually you're right I could fit a iterator over it :)
[11:56:01] <doener> rubber-duck: with while_some you get something like:   do foo().while_some |v| { println(v.to_str()); foo() }
[11:57:36] *** Joins: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de)
[11:58:51] <indutny> hoya
[11:58:58] <indutny> can I create a vector from *c_void
[11:59:41] <doener> indutny: std::vec::from_buf should do
[11:59:53] <indutny> thanks!
[12:00:04] <indutny> ah, no
[12:00:10] <indutny> that's not it
[12:00:12] <indutny> it'll copy memory
[12:00:18] <indutny> I need to cast memory
[12:00:24] <indutny> and add my custom destructor to it
[12:00:28] <indutny> is it possible?
[12:00:39] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:00:41] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[12:00:50] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[12:01:37] <doener> I don't think so. A vector has a single chunk of memory that contains the metadata (alloc size, used size) as well as the contents, which get freed together
[12:01:46] <doener> you'd need a structure that has them separated
[12:01:51] <indutny> hm...
[12:01:52] <indutny> ok
[12:01:55] <doomlord> (syntax highlighting... i was just trying to improve  the support there is for gedit, but not managing to get it to highlight all theoperators)
[12:01:57] <indutny> probably better just return *c_void
[12:02:35] <doomlord> (i wondered if it would be possible to get that syntax highlighting engine to highlight *all* types, by virtue of appearing after a ":"
[12:03:56] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Ping timeout)
[12:13:13] *** zz_kimundi is now known as kimundi
[12:17:35] *** Quits: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de) (Ping timeout)
[12:17:44] *** Joins: snearch (snearch@moz-CF918F37.pool.mediaways.net)
[12:19:29] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[12:19:29] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/Q7Rj6g
[12:19:29] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[12:21:52] *** Joins: roo (jesse.rudo@moz-43AC1E22.dynamic.ip.windstream.net)
[12:22:02] *** Quits: z0w0 (zack@moz-C2225B9E.lnse3.cha.bigpond.net.au) (Client exited)
[12:22:09] <roo> what is the difference between an internal and external iterator?
[12:22:26] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[12:22:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/SShJTg
[12:22:26] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[12:22:27] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[12:22:27] <ghrust> 01[13rust01] 15bors pushed 7 new commits to 06auto: 02http://git.io/cNPD5Q
[12:22:27] <ghrust> 13rust/06auto 145d5311d 15Michael Woerister: Added overview of the debuginfo module at the beginning of debuginfo.rs.
[12:22:27] <ghrust> 13rust/06auto 14f1bd3e7 15Michael Woerister: Fixed compiler warnings about unnecessary string allocations in debuginfo.rs
[12:22:27] <ghrust> 13rust/06auto 14290d353 15Michael Woerister: Reordered debuginfo.rs and commented public fns
[12:22:29] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[12:24:49] *** Quits: roo (jesse.rudo@moz-43AC1E22.dynamic.ip.windstream.net) (Ping timeout)
[12:25:29] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[12:25:58] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[12:26:07] <gavinb> roo: This post explains it pretty well: http://www.marshut.com/nxyuu/the-future-of-iterators-in-rust.html
[12:26:15] <bstrie> roo is gone! you are too late
[12:26:31] <bstrie> now they will toil forever in ignorance
[12:26:49] <gavinb> d'oh! so close!
[12:27:47] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[12:28:35] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[12:29:37] *** Joins: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de)
[12:30:30] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:30:54] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[12:31:10] <MaikKlein> what is the difference between external and internal iterators? it is just that I can use .next with external and with internal the implementation is hidden? 
[12:31:15] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[12:31:53] <bstrie> MaikKlein: http://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/
[12:32:29] <MaikKlein> thanks
[12:32:45] <bstrie> that link is probably the single best answer to that question on the internet
[12:33:02] <bstrie> if roo comes back, give them that one
[12:33:57] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[12:35:01] <bstrie> the tl;dr is that external iterators and more flexible and more composable, but harder to write. internal iterators are easy to write, but more restricted in what they can do
[12:38:02] <MaikKlein> ah ok, the article is really good btw
[12:38:54] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:40:57] *** Joins: roo (jesse.rudo@moz-9AD91C4C.dynamic.ip.windstream.net)
[12:41:01] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[12:41:26] <doener> I must be blind... I can't figure out where "self" is passed when calling a method on a trait object
[12:41:30] <roo> gavinb, bstrie: its ok, I spend more time in the irc logs than the channel :)
[12:41:42] <bstrie> very tricksy
[12:41:50] <bstrie> doener: you mean, in the compiler?
[12:42:11] <doener> bstrie: yeah, I don't see any call to trans_self_arg in that codepath
[12:42:13] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[12:42:42] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[12:42:45] <doener> neither do I see any other code there that would stuff it into llenv
[12:42:46] <bstrie> doener: I think one of the long-term goals was to treat self the same as any other parameter, which implies that it has some weird treatment currently
[12:43:08] *** Quits: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de) (Ping timeout)
[12:43:25] <doener> to say the least ;-)
[12:43:43] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Ping timeout)
[12:44:10] <Blei> callee.rs:533 ?
[12:44:26] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[12:45:06] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Quit: dbaupp)
[12:45:28] *** Joins: sankha93 (Instantbir@30B304BF.8E165DD6.8B6C1D65.IP)
[12:46:03] <doener> Blei: oh, d'oh, llenv is set to llself. I expected llself to be Store'd to it
[12:46:06] <doener> Blei: thanks
[12:46:12] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[12:46:14] <doener> Blei: as I said, I'm blind today
[12:46:16] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[12:46:20] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Input/output error)
[12:46:58] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[12:47:26] <Blei> i stumbled over that yesterday when trying to remove llvm lint warnings
[12:48:50] <doener> Blei: the ones for monomorphized functions?
[12:49:01] <Blei> yeah
[12:49:15] <Blei> it's quite hacky, but it mostly works
[12:49:22] <Blei> nearly no warnings left!
[12:49:42] <Blei> but it's not really worth it, same speed, slightly larger binaries
[12:49:54] * doener simply killed the simplification and collapsing of monomorphized functions
[12:49:56] <Blei> so i'm not really working on it anymore
[12:50:05] <Blei> oh, completely?
[12:50:13] <Blei> that's another approach :)
[12:50:17] <doener> yeah, just for testing 
[12:50:28] <bstrie> Blei: you mean you stopped working on removing llvm lint warnings?
[12:50:29] <doener> tried to see if the warnings made the optimizer go stupid
[12:50:30] <bstrie> or something else
[12:50:33] <Blei> i tried to not bitcast the function pointers, but instead cast the arguments and return values
[12:50:45] <doener> yeah, that's probably the right approach
[12:50:50] <doener> but too heavy for a quick test
[12:51:04] <Blei> heh, yeah ~.~
[12:51:48] <Blei> bstrie: i stopped trying to make the lints disappear
[12:53:00] <bstrie> well the problem is that we are generating invalid ir, right?
[12:53:12] <bstrie> fixing that should be top priority, whether or not it makes the binaries larger and slower
[12:53:53] <Blei> bstrie: according to #llvm it's not invalid, just a false positive of the linter
[12:56:25] *** Joins: RageOfThou (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:57:00] *** Joins: dissing (chatzilla@moz-B1E3B326.dk.customer.tdc.net)
[12:57:10] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[12:58:55] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[13:03:35] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:05:31] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[13:05:33] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[13:06:06] *** Quits: pyrac (pyrac@moz-C4B13AD4.math.u-bordeaux1.fr) (Ping timeout)
[13:06:24] <dbaupp> r? https://github.com/mozilla/rust/pull/7297
[13:08:04] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[13:08:33] <dbaupp> cmr: thanks
[13:08:38] <cmr> n[
[13:08:42] <cmr> np*
[13:08:48] <Blei> no bracket, man
[13:09:57] <doener> building without optimizations is sooooo slow :-/
[13:10:13] *** Quits: igl (igl@moz-AB9DA8DE.adsl.alicedsl.de) (Ping timeout)
[13:10:48] *** Joins: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de)
[13:11:10] *** Quits: dissing (chatzilla@moz-B1E3B326.dk.customer.tdc.net) (Quit: ChatZilla 0.9.90 [Firefox 21.0/20130512194445])
[13:11:29] *** Joins: igl (igl@moz-603150FA.adsl.alicedsl.de)
[13:12:59] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:14:02] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:20:26] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[13:21:58] *** Quits: roo (jesse.rudo@moz-9AD91C4C.dynamic.ip.windstream.net) (Ping timeout)
[13:22:06] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:26:14] *** Joins: Guest (textual@moz-BB21156B.dynamic.csail.mit.edu)
[13:26:20] *** Guest is now known as Sergio965
[13:33:30] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:33:36] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: SiegeLord)
[13:33:58] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[13:34:47] *** Quits: fabiand (fabiand@BABB0116.DC24CC58.16E13E53.IP) (Ping timeout)
[13:34:58] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[13:37:23] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[13:38:06] *** Joins: roo (jesse.rudo@moz-A055DA33.ip.windstream.net)
[13:41:47] *** Quits: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de) (Ping timeout)
[13:42:47] *** Quits: snearch (snearch@moz-CF918F37.pool.mediaways.net) (Quit: Verlassend)
[13:46:00] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:46:14] <roo> I want to work on a syntax extension, so i touched fmt.rs to see what would happen if i wanted to rebuild libsyntax. It is re-bootstrapping the whole compiler. Is there a way to avoid this, given that I know a certain extension isn't going to be used anywhere outside of libsyntax?
[13:47:13] <dbaupp> not
[13:47:14] <dbaupp> really
[13:47:19] <roo> :( ok
[13:47:42] <dbaupp> you can bootstrap once, and then run `make check-stage2-syntax NO_REBUILD=1` to just check it compiles & run the tests
[13:47:50] <Sergio965> Are the statements that look like "#[â€¦]" called decorators in Rust?
[13:47:55] <cmr> Sergio965: Attributes.
[13:48:13] <cmr> Sergio965: they provide additional information to rustc at compile-time, no intrinsic run-time affect
[13:48:13] <dbaupp> roo: (i.e. do a full bootstrap to begin with, and then use that to incrementally check any changes you make)
[13:48:27] <Sergio965> cmr: Wonderful. Thanks for the quick info, as always.
[13:48:32] <roo> i see, I will give that a try
[13:48:45] <Sergio965> It's hard to look through the documentation if you're not sure what they're called. :)
[13:49:00] <dbaupp> roo: however, I'm not 100% sure it works for libsyntax
[13:49:24] <dbaupp> oh, also, to check it compiles, you can just call `rustc syntax.rs` yourself
[13:49:37] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[13:49:40] <dbaupp> (you'll need your system rustc to be fairly recent though)
[13:50:06] <roo> my system rustc is the same as the source version
[13:51:06] <dbaupp> what do you mean?
[13:51:09] <cmr> Hahah, "Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation magic." (http://static.rust-lang.org/doc/std/local_data.html)
[13:51:19] <dbaupp> roo: (what's rustc --version say?)
[13:51:34] <roo> both are the master from yesterday
[13:51:50] <dbaupp> right, so that'll be recent enough, probably
[13:52:19] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:53:08] <Sergio965> I wish Rust was easier to install.
[13:53:21] <Sergio965> Having to build from source, and having to build LLVM along with it, is a bit cumbersome.
[13:53:40] <cmr> Sergio965: want to upstream our llvm patches? ;)
[13:54:26] <Blei> soooo many @s
[13:54:54] <jdm> go whole hog
[13:54:56] <jdm> remove all ~
[13:54:59] <jdm> replace with @
[13:55:04] *** Quits: roo (jesse.rudo@moz-A055DA33.ip.windstream.net) (Ping timeout)
[13:55:07] <dbaupp> Blei: git ls-files '*.rs' | xargs sed -i 's/@//g'
[13:55:09] *** Joins: roo (jesse.rudo@moz-619651BC.dynamic.ip.windstream.net)
[13:55:09] <Sergio965> cmr: What kind of changes does Rust make to LLVM?
[13:55:11] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: rcirc on GNU Emacs 24.2.1)
[13:55:21] <Blei> dbaupp: :D
[13:55:26] <Blei> and watch the world explode
[13:55:28] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[13:55:34] <dbaupp> :D
[13:55:56] <SiegeLord> Sergio965: "All" one needs is somebody to provide nightlies for your system
[13:56:15] <SiegeLord> Switch to Arch, and it becomes easy (after you install Arch XD)
[13:56:41] <Sergio965> I would have though there'd be a Debian package in some PPA somewhere, but alas, I haven't found it.
[13:56:43] <cmr> Sergio965: afaik it's mostly segmented stack stuff.
[13:57:23] <Sergio965> It'd be awesome if I could do: sudo apt-get install rust, and a couple (!) of minutes later, Rust is up and running.
[13:58:41] *** Quits: roo (jesse.rudo@moz-619651BC.dynamic.ip.windstream.net) (Ping timeout)
[13:59:59] <Sergio965> Are there any plans (or perhaps they already exist) to add more safety features to Rust such as contracts, pre/post conditions, or invariants?
[14:00:25] *** Joins: roo (jesse.rudo@moz-884EEB9B.dynamic.ip.windstream.net)
[14:00:47] <cmr> Sergio965: I wasn't around for it but I thought the old typestate system had stuff like that and they weren't used much (and can be implemented in terms of modern rust features)
[14:02:03] <AutomatedTester> hey, are there any koans for learning rust? teaching myself isnt working( because I am lazy) so hoping there is some structure I could follow
[14:02:28] <Sergio965> There's the tutorial.
[14:02:39] <Sergio965> http://static.rust-lang.org/doc/0.6/tutorial.html
[14:02:45] <cmr> AutomatedTester: and there's http://www.rustforrubyists.com/book/index.html
[14:03:50] <Sergio965> I feel like there are really elegant design patterns that Rust makes achievable. Someone should write a book/article about it.
[14:04:40] <dbaupp> Sergio965: it'd be really, really hard to do it, and keep it up-to-date and idiomatic, at the moment.
[14:04:59] <Sergio965> dbaupp: Indeed. I've noticed the language is quite heavily in flux.
[14:05:20] <Sergio965> I'm just not sure what the "unique" features of Rust are.
[14:05:32] <AutomatedTester> thanks people :)
[14:05:40] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Input/output error)
[14:05:53] <hoelzro> I'd say it takes a lot of nice features from other languages and allows them to be used in a compiled form
[14:06:12] *** Joins: jclements (jclements@moz-BE33DA21.fw1.sfo1.mozilla.net)
[14:06:25] <hoelzro> also, the multiple pointer types allow you to write systems code that doesn't suffer from some of the pitfalls that C and C++ have
[14:06:47] *** Quits: roo (jesse.rudo@moz-884EEB9B.dynamic.ip.windstream.net) (Ping timeout)
[14:06:54] <AutomatedTester> for me immutable by default is my favourite feature
[14:06:55] <SiegeLord> Lifetimes of borrowed pointers are pretty unique, afaik
[14:06:59] <AutomatedTester> and why I want to learn it :)
[14:07:04] *** Quits: jclements (jclements@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: jclements)
[14:07:09] <dbaupp> Sergio965: lifetimes are basically it
[14:07:35] *** Quits: Earnestly (earnest@C3C47836.2F03E712.4FA5093E.IP) (Ping timeout)
[14:07:45] <SiegeLord> There's also mentions of 'affine types' which I'm not 100% sure about
[14:07:48] <Sergio965> Lifetimes of the different object pointer types?
[14:07:48] <dbaupp> Sergio965: the "unique"-est part of Rust seems to be taking ideas from other languages, which haven't been put together much before
[14:07:54] *** Joins: roo (jesse.rudo@moz-B63B33EA.dynamic.ip.windstream.net)
[14:08:11] <cmr> which is kinda the point, rust isn't supposed to innovate language features
[14:08:22] <dbaupp> Sergio965: http://static.rust-lang.org/doc/tutorial-borrowed-ptr.html
[14:09:50] <roo> The tutorial/manual are helpful for getting familiar enough with the language to read the source of libstd. That the tact I am taking at the moment.
[14:10:47] <Sergio965> Ah yeah. I saw the 'lifetime syntax and proceeded to avoid it. :)
[14:10:51] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[14:11:03] <Sergio965> Named lifetimes, I suppose.
[14:11:09] <dbaupp> it's the one of the best bits of Rust!
[14:11:29] <cmr> Question about TLS: https://gist.github.com/cmr/5867652, shouldn't `key` be run eventually, to destruct the value?
[14:11:50] <dbaupp> Sergio965: (no allocations necessary + guaranteed memory safety)
[14:11:57] <dbaupp> cmr: I don't think that's used
[14:12:22] <dbaupp> cmr: i.e. all the other uses I've seen just have `fn key(_: @SomeType) {}`
[14:12:31] <cmr> dbaupp: mm, okay
[14:12:34] <dbaupp> cmr: with a destructor on SomeType if it's needed
[14:12:37] <Sergio965> dbaupp: I'll certainly read more about it. I was under the impression that lifetimes were a heap-allocated only thing.
[14:12:47] <cmr> Sergio965: nooo, not at all.
[14:12:58] <dbaupp> Nope, lifetimes are more a stack thing
[14:13:00] <kimundi> The most unique part of rust is the whole borrowed pointer / liefetimes stuff / borrowcheck stuff
[14:13:20] <dbaupp> (one can regard a lifetime as connecting an object with the stack-frame it lives in)
[14:13:27] <Sergio965> Interesting.
[14:13:42] *** Joins: Earnestly (earnest@moz-DF22208.dyn.plus.net)
[14:16:20] <kimundi> Sergio965: This is a bit too generalised, but the point of naming lifetimes is basically to annotate "this function takes a pointer to some data, and returns/stores away a pointer into the same data"
[14:17:01] *** Joins: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au)
[14:17:45] <Sergio965> I don't quite understand it yet. I'll read through all the material on it and see if I can wrap my head around it. :)
[14:17:51] <kimundi> Wich the compiler can then use to know "if the object I pass in is alive at this point, the so is the pointer the function returns"
[14:17:57] <cmr> Sergio965: do you know C/C++?
[14:17:59] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[14:18:04] <Sergio965> I do.
[14:18:08] <engla> in particular a lifetime is NOT: here's a lifetime, tie this newly allocated object to it.
[14:19:28] <dcolish> there's no overloading or default args in rust, right?
[14:19:55] <engla> right dcolish
[14:20:00] <Sergio965> dcolish: No. :(
[14:20:15] <Sergio965> Default arguments would be fantastic, especially given the do syntax sugar.
[14:20:17] <engla> overloading is accomplished with traits
[14:20:17] <cmr> Well there's http://smallcultfollowing.com/babysteps/blog/2012/10/04/refining-traits-slash-impls/
[14:21:15] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[14:21:23] *** Joins: figaro (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:21:29] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[14:21:57] <dcolish> traits dont allow you to name multiple fn with differnt signatures do they?
[14:21:58] *** Joins: jclements (jclements@moz-BE33DA21.fw1.sfo1.mozilla.net)
[14:21:59] <Sergio965> I suppose I don't see what lifetimes afford me. What can I do with lifetimes that I couldn't do before? It seems to me (though I don't claim to understand them) that all they do is allow me to mark a pointer with "where it came from".
[14:22:23] <cmr> Sergio965: They are what guarantee memory safety without requiring runtime checks or a GC
[14:22:30] <Sergio965> Is the point to allow the compiler to statically guarantee safety?
[14:22:38] <kimundi> Sergio965: yes
[14:22:39] <cmr> They allow the compiler to prove that a pointer never outlives what it points to
[14:22:46] <Sergio965> Ah.
[14:23:09] <SiegeLord> I used to like default arguments, but now I think they lead to confusion: you can silently change the behavior of code that uses them by changing the defaults
[14:23:39] <dcolish> i do agree with default args being a bad idea
[14:23:54] <dcolish> i prefer overloading because i really just want to narrow the api in some cases
[14:23:57] <Sergio965> I disagree, especially when the do syntax exists.
[14:24:14] <SiegeLord> Not sure what the do syntax has to do with it
[14:25:20] <Sergio965> I have a function that looks like this: pub fn range(begin: uint, end: uint, incr: uint, op: &fn(&uint)). When I call it, I call it like: "do range(0, len, 1) | i | { â€¦ }". It'd be really nice if the "incr" argument was 1 by default.
[14:27:11] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[14:27:13] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[14:27:45] <dcolish> default args always lead to misuse in a large project. they dont scale
[14:27:58] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[14:30:06] *** Quits: roo (jesse.rudo@moz-B63B33EA.dynamic.ip.windstream.net) (Ping timeout)
[14:30:23] *** Joins: roo (jesse.rudo@moz-4CBE3284.dynamic.ip.windstream.net)
[14:31:05] *** Quits: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net) (Ping timeout)
[14:31:25] <Sergio965> dcolish: Most things can be misused. I'm of the opinion that as long as you use a language feature appropriately, you'll stand to gain from it.
[14:31:30] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[14:31:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/cNPD5Q
[14:31:30] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[14:31:33] <roo> You can still use a macro for that sort of pattern
[14:32:25] <cmr> I think I like default args, but I'm not sure how well they interact with traits, which would make them kinda useless
[14:32:33] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[14:32:52] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[14:33:01] <Sergio965> cmr: Why?
[14:33:14] <engla> Sergio965: with the new iterators a better protocol could be implemented
[14:33:22] <Sergio965> engla: New iterators?
[14:33:28] <cmr> Sergio965: If you can't have default args in methods, that would remove 98% of the utility I see in them
[14:33:29] <engla> Sergio965: something like  count(0).to(10).step(2)
[14:33:44] <engla> where the methods just modify parameters on the same iterator value
[14:34:03] <cmr> Don't need iterators for that
[14:34:14] <engla> maybe not
[14:34:22] <Sergio965> cmr: I don't see why you could have default args in functions but not methods.
[14:34:31] <Sergio965> (IE, why you'd implement one and not the other)
[14:34:33] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:34:33] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_4hQng
[14:34:33] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:34:34] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[14:34:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/S1W_kQ
[14:34:34] <ghrust> 13rust/06auto 1473e3dbf 15Huon Wilson: driver: perform stripping before and after macro expansion....
[14:34:34] <ghrust> 13rust/06auto 144e5b480 15bors: auto merge of #7297 : huonw/rust/strip-expand-strip, r=cmr...
[14:34:34] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[14:34:57] <Sergio965> engla: That doesn't look very elegant. Is there documentation on this?
[14:35:01] *** Joins: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de)
[14:35:05] <cmr> Sergio965: I'm not sure it's even possible to have default args in functions. It breaks trait objects among other things.
[14:35:21] <cmr> Err, s/functions/methods/
[14:35:33] <engla> Sergio965: it doesn't exist, just a proposed API. not sure what's bad about it, you can just say count(0) if you don't need other arguments
[14:35:55] *** Joins: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com)
[14:36:01] <engla> (Sergio965: but it's an API that can be implemented in your code today)
[14:36:42] <dcolish> Sergio965: while I agree on some part with the notion that developers will always do the right thing, i've seen default args become a great way to ruin an api without anyone else noticing
[14:36:43] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[14:37:08] <Sergio965> cmr: Sorry, perhaps I don't understand traits well enough to understand what you're saying. How would it break trait objects? This would only apply to function/methods.
[14:37:44] <Sergio965> engla: I see. It simply looks a bit clumsy to me. It looks a lot like Ruby code that wasn't written correctly.
[14:38:40] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:39:07] <engla> ok, so you mean this pattern does exist in ruby?
[14:39:12] <Sergio965> dcolish: Certainly. I'm not arguing that they aren't easy to misuse. I'm trying to argue that their utility outweighs their shortcomings.
[14:39:18] <cmr> Sergio965: pattern like https://gist.github.com/cmr/714c06ea843b19cd833a doesn't work.
[14:39:37] <cmr> Sergio965: although maybe it does
[14:39:43] <kimundi> Sergio965, even though I hate that answer myself: It can always be done with a macro.
[14:40:06] <Sergio965> cmr: Why wouldn't that be implementable?
[14:40:13] <kimundi> for range!(0) {  }; for range!(0, 5, 3) {  }; //...
[14:40:37] <Sergio965> cmr: The compiler knows that the variable x must be an int, and so it's okay to set x to 42 by default (though this isn't the syntax I would use. :P)
[14:40:44] <cmr> Sergio965: The Foo vtable wants an argument to the foo method, and thus you can't have impls that use default arguments without wrappers.
[14:41:15] <engla> Sergio965: the compiler doesn't know that the object implementing trait Foo is a Bar.
[14:41:51] <cmr> And while you *could* have wrappers, it'd require combinatorial codegen... for every combination of default args.
[14:41:59] <cmr> Haven't thought this all the way through yet.
[14:42:01] <Sergio965> engla: Why would it need to know it's a Bar? Isn't knowing it's a foo enough?
[14:42:13] <Sergio965> Oh, I see the argument.
[14:42:16] <cmr> But it's non-trivial, and I'm not convinced it's possible yet.
[14:42:29] <cmr> (Nor am I convinced it's not possible!)
[14:42:37] <engla> cmr: having a default value could be part of the trait
[14:42:46] <engla> and the default value an associated constant to the trait :-)
[14:42:47] <Sergio965> engla: That was my initial though, too.
[14:42:50] <dcolish> my issue is that even with traits to change behavior, you still have the same signature arity
[14:43:10] *** Joins: artagnon (uid7560@moz-A588D045.irccloud.com)
[14:43:23] <Sergio965> kimundi: Yeah, but it'd be nice to do it without macros.
[14:43:25] <cmr> engla: does that work with parameterized traits and args?
[14:43:34] <Sergio965> kimundi: It's too "simple" of a thing to need macros for.
[14:43:47] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[14:43:52] <artagnon> I didn't understand the point of implementing a RevIterator, MutIterator, and MutRevIterator independently.
[14:44:15] <Sergio965> In my opinions, default arguments are wonderful when it makes sense to have a default argument. IE, an argument that, 90% of the time, is the same should be 'default'.
[14:44:17] <artagnon> Er, implementing Iterator for those things.
[14:44:19] <Sergio965> opinion*
[14:44:28] <artagnon> ... because fn next is independent of those things.
[14:44:38] <artagnon> And it just results in code duplication, no?
[14:45:00] <artagnon> Look at https://github.com/jedestep/rust/commit/376042a2 for example.
[14:45:15] <engla> fn next is different if you go reverse
[14:45:40] <Sergio965> Sorry, this is a bit out of context, but are all macro appended with a "!"?
[14:45:43] <Sergio965> macros*
[14:45:47] <SiegeLord> Someone could have hoisted them
[14:45:49] <cmr> Sergio965: yes
[14:45:59] <jclements> Sergio965: the idea is to make sure people know when they're using a macro.
[14:46:12] <artagnon> engla: Then is the code wrong?
[14:46:23] <Sergio965> macros*
[14:46:34] <engla> artagnon: the next implementations are different
[14:46:40] <engla> artagnon: uses -= 1 for reverse
[14:46:43] <Sergio965> jclements: Certainly, makes sense.
[14:46:51] <artagnon> Ah, my bad.
[14:47:01] <artagnon> engla: What about Mut and MutRev?
[14:47:08] <engla> but yes maybe it should be possible to combine it all into one implementation
[14:47:21] *** Quits: BigEndian (hurp@moz-1B6DD81E.members.linode.com) (Ping timeout)
[14:47:33] <artagnon> It seems like a lot of duplication to me.
[14:47:35] <engla> let the step +1, -1 be a member variable. And let type generics handle the mut T/T thing?
[14:47:42] <artagnon> Yep.
[14:47:44] <jedestep> artagnon: mut and mutrev are identical to non-mutable versions other than type fudging
[14:48:14] <SiegeLord> artagnon: The forward and reverse iteration might be different for other containers
[14:48:27] <engla> I'm not sure it's possible to be generic over &mut T vs &T
[14:48:31] <artagnon> SiegeLord: Can you give me an example?
[14:48:43] <artagnon> jedestep: Right, I noticed that.
[14:48:50] <artagnon> ... but I find it quite unfortunate.
[14:48:50] <cmr> artagnon: imagine an Iterator over a file
[14:48:54] <SiegeLord> Well, maybe a singly linked list
[14:48:59] <SiegeLord> It has no reverse iterator :P
[14:49:11] <artagnon> Ah, good point.
[14:49:14] <SiegeLord> (Well, it could have a very inefficient one)
[14:49:17] <jedestep> artagnon: the reverse iterator of something like a B-tree
[14:49:25] <engla> The HashSet iterator needs no rev since there is no order specified. it could have one, sure.
[14:49:31] <jedestep> may have fairly different behavior
[14:49:46] <jedestep> *implementation
[14:50:00] <artagnon> cmr: I just have to +/- seek from SEEK_CUR, no?
[14:50:09] <artagnon> I don't need to SEEK_BEG or SEEK_END.
[14:50:23] <artagnon> jedestep: Makes sense.
[14:50:40] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[14:50:48] *** Joins: BigEndian (hurp@moz-1B6DD81E.members.linode.com)
[14:50:50] <artagnon> However, in the 90% case, it's possible to infer the reverse from the forward.
[14:50:59] <artagnon> So, we should not have duplication in that case, no?
[14:51:10] <cmr> artagnon: maybe. talk to strcat about it
[14:51:14] <artagnon> In the other 10% cases, we can override the default implementation.
[14:51:16] <cmr> iterators are his pet project
[14:51:28] <MaikKlein> how would I make sth simple as https://gist.github.com/MaikKlein/5867986 ?
[14:51:32] <artagnon> Okay, I'll ask him when he comes online.
[14:51:44] <MaikKlein> I am not sure what lifetime I have to specify
[14:51:59] <cmr> MaikKlein: you need to specify the 'self lifetime, it's not implicit.
[14:52:01] <artagnon> ... or I'll email him.  Thanks for the information.
[14:52:07] *** Parts: artagnon (uid7560@moz-A588D045.irccloud.com) ()
[14:52:08] <jedestep> MaikKlein struct Node<'self> {...}
[14:53:01] <cmr> MaikKlein: https://gist.github.com/cmr/b6693aceb8204a53ad19
[14:53:52] <MaikKlein> cmr, ahh okay thanks
[14:55:43] <jedestep> mut and mutrev iterators can be implemented in terms of immutable ones via cast::transmute_mut if having an unsafe call is acceptable
[14:55:43] *** Quits: roo (jesse.rudo@moz-4CBE3284.dynamic.ip.windstream.net) (Ping timeout)
[14:57:13] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (NickServ (GHOST command used by Amanieu_))
[14:57:26] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[14:57:35] *** Joins: robertkn_ (robertknig@moz-54528EE0.wby.mendeley.com)
[14:57:44] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[14:57:49] *** Joins: roo (jesse.rudo@moz-38306A6D.dynamic.ip.windstream.net)
[15:00:45] *** Joins: Sindwiller (sindwiller@moz-743130B2.dynamic.hispeed.ch)
[15:00:46] *** Quits: gavinb (gavinb@moz-9EC182F0.lowrp3.vic.optusnet.com.au) (Quit: gavinb)
[15:01:55] <engla> jedestep: you can use the macro method that std::vec does.
[15:02:12] <jedestep> engla: ah wonderful
[15:03:10] *** Quits: roo (jesse.rudo@moz-38306A6D.dynamic.ip.windstream.net) (Ping timeout)
[15:03:27] *** Joins: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP)
[15:04:18] <jedestep> will this just have MutIterator work the same as iterator?
[15:04:20] <cmr> jclements: ping
[15:05:19] <jclements> cmr: pong
[15:05:42] <engla> jedestep: yes, apart from having the types in the right places
[15:06:34] <cmr> jclements: Would it be possible/feasible to wrap all of libsyntax's state into a tidy struct and using methods/functions on that struct for manipulation? This would especially allow removing the interner from TLS (which causes @-explosion) and should be a good step towards making the ast sendable, I think
[15:08:15] <jclements> cmr: I should read your paragraph more carefully again, but I've been moving in the other directionâ€¦ it looks like pauls gave up on passing the interner around explicitly when he ran into serialization.
[15:08:36] <pauls> jclements: Ah, yes. I think I did.
[15:08:48] <pauls> There wasn't any way to do it, so I resorted to TLS.
[15:08:57] <cmr> How long ago was this?
[15:09:02] <jclements> pauls: right, that's how it looked to me.
[15:09:07] <jclements> cmr: last summer, I think.
[15:09:18] <cmr> Might it be possible now?
[15:09:23] <MaikKlein> cmr, how would I implement methods in Node? because impl Node<'self>{} doesn't work. Or is this not possible yet?
[15:09:35] <jclements> cmr: has something changed that would make it possible?
[15:09:53] <cmr> Well, what made it impossible in the first place?
[15:10:04] <jclements> cmr: also, can you describe in more detail the problem with putting it in TLS? I'm probably just slow, but I don't see how this causes a problem.
[15:10:32] <jclements> cmr: serialization of tokens requires the interner....
[15:10:51] <cmr> jclements: putting it in tls requires the interner to be a @-ptr, and beyond @-ptrs' being considered for removal, they cause all sorts of performance problems.
[15:11:02] *** Quits: Blei (philipp@moz-7077963E.ethz.ch) (Quit: WeeChat 0.4.1)
[15:11:06] <cmr> 40% of rustc's execution time right now is take/drop glue for @-ptrs iirc
[15:11:13] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[15:11:37] <jclements> cmr: butâ€¦ you're talking about getting rid of just *one* @-ptr, right?
[15:11:53] <jedestep> engla: where is the iterator macro defined?
[15:11:59] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[15:12:02] <jedestep> rustc can't find it
[15:12:35] <cmr> jclements: gotta start somewhere right? :)
[15:12:52] <cmr> I admit I'm not too familiar with syntax and its requirements yet, so my ideas could be completely unreasonable
[15:13:35] *** Joins: snearch (snearch@moz-CF918F37.pool.mediaways.net)
[15:13:52] <jclements> cmr: I think you want to start with the places that are going to have the highest payoff, and I'm not convinced that this is it. Butâ€¦ who knows?
[15:14:17] <cmr> jclements: I figured this would be the place with least impact though, thus an easy one
[15:14:35] <Sindwiller> Random question: Are there any efforts towards C++ compatibility? :)
[15:14:40] <cmr> Sindwiller: no
[15:14:42] <Sindwiller> kk
[15:14:54] <cmr> Sindwiller: there's an issue about thiscall ffi somewhere
[15:14:54] <jclements> cmr: urrgggâ€¦ well, I've spent more time than I'd like to admit, messing around with this. 
[15:14:58] <MaikKlein> ah ahah it is impl<'self> Node<'self>{
[15:15:04] <dcolish> is bind_res similar to gensym?
[15:15:05] <MaikKlein> crazy syntax
[15:15:23] <Sindwiller> hmmhm
[15:16:01] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:17:05] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[15:17:37] <xLII> Can i ask a question?
[15:17:43] <cmr> xLII: of course
[15:17:46] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[15:17:47] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[15:18:04] <xLII> Why this piece of code cannot be compiled?
[15:18:07] <xLII> struct t(int); impl<V,T> std::ops::Add<V,T> for t { fn add(&self,rhs:&V)->T{true}}
[15:18:59] <xLII> I overload the '+' operator for my own type t
[15:19:08] <Kauhsa> it's likely I'm doing something fundementally wrong, but I'm confused about what compiler is trying to tell me https://gist.github.com/Kauhsa/7ebf5e10a0b205f84451
[15:19:21] <Kauhsa> I'm rather green with low-level languages, but bear with me :-)
[15:19:23] <engla> jedestep: here https://github.com/mozilla/rust/blob/master/src/libstd/vec.rs#L2408
[15:19:52] <cmr> Kauhsa: you want fn print_stuff<T: Iterator<int>>(input: T), probably
[15:20:47] <Kauhsa> oh
[15:20:49] <Kauhsa> I see
[15:21:01] <Kauhsa> I can't use traits on parameters directly?
[15:21:49] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:22:04] <MaikKlein> does this compile on your machine https://gist.github.com/MaikKlein/5868310 ?
[15:22:05] <cmr> You can (they're called trait objects, and involve dynamic dispatch), but the Iterator implementation isn't complete yet I think
[15:22:09] <MaikKlein> it get exitcode -6
[15:23:03] *** Quits: cr (anonymous@moz-9D6CBECC.dip0.t-ipconnect.de) (Quit: cr)
[15:23:22] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[15:24:43] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[15:24:45] <jedestep> macro undefined: 'iterator!'
[15:25:10] <jedestep> already using vec
[15:25:17] <engla> jedestep: the macro impl is just above the code I linked
[15:25:32] <engla> jedestep: yeah macros can't leave their module at the moment
[15:25:39] *** Joins: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[15:25:44] <engla> jedestep: I didn't literally mean you'd 'use' that macro, but use the idea
[15:25:46] <Kauhsa> cmr, right. thanks, maybe I can advance forward a bit now :)
[15:25:48] *** Joins: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[15:25:51] <jedestep> oh
[15:26:04] <doener> MaikKlein: takes really long before it fails, exit code 134, works if I use Option<~Node>
[15:27:18] <doener> MaikKlein: makes sense though, you have a type with infinite size
[15:27:22] <xLII> Can someone solve my problem?:'(
[15:28:02] <MaikKlein> doener, ah right 
[15:28:18] <jdm> xLII: what's the error you see?
[15:29:01] <xLII> Mismatched types: expected 'U' but found 'bool'
[15:29:08] <jclements> engla: jedstep: waitâ€¦ what about #[macro_escape] ?
[15:29:09] <dcolish> is there a way in marcos to apply typing to an ident?
[15:29:17] *** Quits: infynyxx_ (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[15:29:35] <cmr> dcolish: macros are purely syntactic, no type information available yet.
[15:30:05] <dcolish> ok so i'd have to use :pat or something to try and match a structure?
[15:30:07] <jdm> xLII: so you're trying to add a struct and a boolean?
[15:30:14] <jdm> xLII: why are you returning a boolean, exactly?
[15:30:27] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[15:30:48] <xLII> I want to overload the '+' operator
[15:30:48] <engla> jclements: no idea
[15:30:55] *** Quits: snearch (snearch@moz-CF918F37.pool.mediaways.net) (Quit: Verlassend)
[15:31:02] <bstrie> xLII: search for "impl Add" in the codebase
[15:31:12] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[15:31:29] <jclements> engla: you can use #[macro_escape] to allow macros to escape from a module.
[15:31:42] <dcolish> is there something like instanceof?
[15:31:44] <erickt> ! we can export macros now?!
[15:31:51] <bstrie> what, no way
[15:32:00] <jclements> erickt: this is a cheap hack, not a real export solution. ...
[15:32:01] <engla> jclements: I didn't know that, sounds good
[15:32:10] <bstrie> is this just the include! hack
[15:32:49] *** Joins: roo (jesse.rudo@moz-680FD586.dynamic.ip.windstream.net)
[15:32:55] <jclements> erickt: basically, when a macro is parsed, it's added to the innermost module that doesn't have the #[macro_escape] flag, so you can add macros to parent modules. Honestly, it's pretty icky.
[15:33:17] <jclements> erickt: I can say that, because I added it....
[15:33:20] <erickt> :)
[15:33:32] <engla> jclements: what I want is macros to escape crates
[15:33:33] <erickt> Does it work across a crate?
[15:33:49] <jclements> engla: no, definitely not. That's a horse of an entirely different color.
[15:34:28] <MaikKlein> n rust i can't overload function right? how should I name my new if I need several of them? like Node::new_with_foo() ?
[15:34:42] <jedestep> engla: thank you for the suggestion. it works now :)
[15:35:07] <bstrie> jclements: how much longer do we have you for?
[15:36:15] *** Quits: Sindwiller (sindwiller@moz-743130B2.dynamic.hispeed.ch) (Quit: Konversation terminated!)
[15:40:31] *** Joins: eholk (eholk@moz-FF3718FD.uconnect.utah.edu)
[15:40:44] *** Quits: Earnestly (earnest@moz-DF22208.dyn.plus.net) (Ping timeout)
[15:40:45] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[15:44:38] <engla> MaikKlein: new_with_foo  works. If it's the same number of arguments you could create a trait instead and use just one ::new<T: MyTrait>(x: T)
[15:45:30] <MaikKlein> engla, ah nice thanks
[15:45:54] <MaikKlein> how do I return a mutable varaible? like new() -> mut ~Node ?
[15:46:04] <MaikKlein> ah
[15:46:04] <MaikKlein> nvm
[15:46:07] <MaikKlein> I am stupid
[15:46:07] <rubber-duck> http://static.rust-lang.org/doc/rust.html#number-literals - how would this parse "0" ? shouldn't the second line be "| '0'   [ dec_digit | '_' ] * num_suffix ?" - also random open bracket after '0' ?
[15:46:50] <cmr> rubber-duck: the grammar in the manual is, aiui, incomplete and only an approximation
[15:47:26] <cmr> yeah, see http://static.rust-lang.org/doc/rust.html#disclaimer
[15:47:52] *** Quits: roo (jesse.rudo@moz-680FD586.dynamic.ip.windstream.net) (Ping timeout)
[15:48:11] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:48:16] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[15:48:19] <bstrie> rubber-duck: don't trust the manual, it hasn't been given any rigorous editing
[15:49:06] *** Joins: royw (royw@CB447DD5.6B10AC3.E2F59BBC.IP)
[15:49:13] <pnkfelix> rubber-duck: I think there is a more accurate formal grammar floating around somewhere on github that jclements made, let me look
[15:49:37] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: Don't tell them I was here...)
[15:49:44] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[15:49:58] <pnkfelix> rubber-duck: yeah, if you can read antlr, then you might look here: https://github.com/jbclements/rust-antlr  (it may not be 100% up-to-date).
[15:50:48] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:55:11] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:58:34] *** Joins: bent (chatzilla@moz-BE33DA21.fw1.sfo1.mozilla.net)
[15:59:31] *** Quits: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com) (Quit: brendan)
[16:02:10] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Quit: Leaving.)
[16:03:26] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[16:03:35] <MaikKlein> hm can I force a function to always return a mutable variable?
[16:03:50] <cmr> MaikKlein: &mut.
[16:03:50] <bstrie> MaikKlein: only if you return @mut
[16:03:51] <MaikKlein> because in my case a immutable variable doesn't make much sense
[16:03:54] <cmr> MaikKlein: or @mut
[16:04:00] <bstrie> does returning &mut actually work?
[16:04:03] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[16:04:08] <engla> MaikKlein: you don't need to normally. Node or ~Node, the receiver decides mutability
[16:04:09] <cmr> with a lifetime, I think?
[16:04:14] <engla> bstrie: sure
[16:04:29] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[16:05:11] <MaikKlein> okay thanks
[16:05:13] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[16:05:43] <bstrie> MaikKlein: even if an immutable variable doesn't make much sense, I think it's still better to let the caller decide
[16:06:18] *** Quits: jpochyla (jpochyla@E1DB45DB.1AFA5C43.5DC06702.IP) (Ping timeout)
[16:06:41] <engla> MaikKlein: HashMap::new() -> HashMap.  Caller can decide, let mut m = ~HashMap::new();  let v = @mut HashMap::new(); etc.  let mut map = HashMap::new()
[16:08:05] <MaikKlein> I just wanted to make a  RootNode, and a rootnode that can't add children because it is immutable is a little bit weird.
[16:08:15] *** Quits: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP) (Quit: Lost terminal)
[16:10:58] <engla> what does &'static fn()  mean? Can a @fn() be converted to it?
[16:11:14] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[16:12:37] <MaikKlein> hm
[16:12:43] <MaikKlein> can u even generate a function at runtime?
[16:13:16] <doomlord> sounds like the wrong language for that
[16:13:23] <engla> I'm experimenting and writing a lazy list using a "chained" list of  @fn pointers as thunks. not sure how useful it will be :-)
[16:13:44] <sp3d> a function itself would take some unsafety but it seems like the type system should be ok with it after that?
[16:14:17] <doomlord> sounds hard to port
[16:14:57] <cmr> engla: ask bblum when he's around, he works a lot with that stuff recently I think
[16:15:39] <bblum> i'm here
[16:16:27] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:16:34] <engla> bblum: do you know of an existing lazy list implementation?
[16:16:38] *** Joins: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP)
[16:16:53] <bblum> nope
[16:17:10] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[16:17:19] <bblum> try to write it with ~fns if you can
[16:18:47] <engla> hm ok. I don't know rust well enough. it compiles fine with just replacing @fn with ~fn
[16:18:50] * cmr fails to see how an iterator isn't a lazy list
[16:19:26] <engla> the lazy list struct implements the iterator trait
[16:19:42] <engla> it's supposed to be composable way to make an iterator.. that you can return from a function
[16:20:06] <cmr> but you can return an Iterator from a function?
[16:20:25] <bblum> engla: difference is with @fn you are allowed to have multiple pointers to the inside of the list at the same time
[16:20:27] <engla> yes sure.. but you have implement a new iterator for each thing?
[16:20:32] <bblum> but with ~fn you can share + send the list between tasks
[16:20:36] <cmr> I suppose
[16:21:00] <engla> cmr: try it, it's tricky with types and traits
[16:21:52] <engla> hm it's related to my previous questions.. the only way to have iterator return values in traits are to use trait objects
[16:22:00] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[16:22:53] <engla> cmr: also you can't return a MapIterator from a function
[16:23:03] *** Quits: sankha93 (Instantbir@30B304BF.8E165DD6.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[16:23:04] <engla> because the closure you defined in that function can't leave it
[16:23:16] <engla> the closure you passed to Iterator::transform
[16:23:22] *** Joins: Earnestly (earnest@moz-464C7EDD.dyn.plus.net)
[16:23:57] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Connection reset by peer)
[16:24:50] <engla> or can it?
[16:24:58] *** Joins: sankha93 (Instantbir@30B304BF.8E165DD6.8B6C1D65.IP)
[16:25:00] <engla> I don't know if you have to give it a ~fn
[16:25:39] *** Quits: royw (royw@CB447DD5.6B10AC3.E2F59BBC.IP) (Quit: royw)
[16:25:48] *** Joins: josh (josh@moz-C350AC70.hsd1.mn.comcast.net)
[16:26:05] *** Quits: bzzzz (bzzzz@moz-7A6060F0.in) (Ping timeout)
[16:26:42] *** Joins: allbets (allbets@moz-8121C36A.vie.surfer.at)
[16:27:09] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Ping timeout)
[16:27:17] <engla> I guess someone will eventually figure out how to use them and write about it
[16:27:41] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[16:28:00] *** Quits: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de) (Ping timeout)
[16:28:01] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:29:36] <allbets> hi does anyone know how to get the windows build to work? says always "__gxx_personality_v0 could not be located" when executing rustc
[16:30:45] <cmr> allbets: do you have mingw installed?
[16:30:53] <allbets> yes
[16:30:58] *** Joins: themgt (themgt@moz-85CD28BB.hfc.comcastbusiness.net)
[16:31:01] *** Quits: themgt (themgt@moz-85CD28BB.hfc.comcastbusiness.net) (Client exited)
[16:31:06] <cmr> ok, that's the extent of my ability to help, sorry!
[16:31:07] <allbets> got it in the path and everything
[16:32:13] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:32:40] *** Joins: cr (anonymous@moz-9D6CBECC.dip0.t-ipconnect.de)
[16:32:54] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[16:33:05] *** Joins: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca)
[16:33:18] *** Quits: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Input/output error)
[16:34:21] <allbets> i tried different mingw builds is there a specific version that is needed except the dwarf support?
[16:35:28] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[16:40:16] *** Quits: josh (josh@moz-C350AC70.hsd1.mn.comcast.net) (Quit: josh)
[16:41:35] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Quit: Bye)
[16:42:09] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[16:42:26] *** Quits: figaro (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[16:43:16] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[16:44:57] <kimundi> allbets, afaik yes you need a specific one
[16:45:13] <kimundi> there should be notes somewhere on the wiki
[16:46:40] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:46:40] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/S1W_kQ
[16:46:40] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:47:46] <cmr> "error: cannot root managed value long enough" /that/ doesn't sound good
[16:48:18] <allbets> huh nevermind just got it working
[16:48:35] <allbets> 4.6.2 did the trick
[16:49:23] *** Joins: qmx (qmx@B42C1175.A82378F3.A2BF9DEB.IP)
[16:49:34] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[16:49:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MNz0gg
[16:49:34] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[16:49:39] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[16:49:39] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FjnNbg
[16:49:39] <ghrust> 13rust/06auto 146291702 15blake2-ppc: iterator: Add `IteratorUtil::flat_map_` method...
[16:49:39] <ghrust> 13rust/06auto 143433851 15bors: auto merge of #7345 : blake2-ppc/rust/iterator-flat-map, r=thestinger...
[16:49:39] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[16:54:23] *** Joins: xLII (xLII@FF04F06F.9FFB2C04.81CDC09E.IP)
[16:56:19] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[16:58:37] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[16:58:49] <cmr> acrichto: does the LLVM threadsafety stuff actually work now? iirc it was the cause of some of the breakage before?
[16:59:16] <acrichto> cmr: I don't remember a specific reason for breakage which wasn't fixed later
[16:59:21] <cmr> ok
[16:59:22] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[16:59:32] <acrichto> cmr: although we'll find out soon :)
[16:59:35] <cmr> yup!
[17:01:03] <acrichto> although this won't pass unless LLVM workspaces are cleaned soon
[17:02:08] *** Joins: jyeo (user@F2D29657.F60B0462.67AC9B1.IP)
[17:03:22] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:05:38] <allbets> im trying to call MessageBoxA via ffi but linking fails with error message "undefined reference to `MessageBoxA'", any ideas?
[17:06:22] <allbets> i did exactly what the tutorial said
[17:07:36] <sp3d> you're using extern "C" fn?
[17:07:51] *** Joins: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch)
[17:08:21] *** Joins: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com)
[17:08:27] <sp3d> I think that's necessary, but I'm not an expert
[17:08:38] <allbets> extern mod user32 { ... }
[17:08:44] <allbets> like described here http://static.rust-lang.org/doc/0.6/tutorial-ffi.html#foreign-calling-conventions
[17:08:45] <Eridius> allbets: this is 0.6?
[17:08:50] <allbets> yes
[17:09:00] <Eridius> allbets: nad you're calling it as user32::MessageBoxA()?
[17:09:12] <allbets> yes
[17:09:24] <Eridius> allbets: can you paste code? use a pastebin (such as gist.github.com)
[17:09:32] <allbets> sure one moment
[17:10:44] <allbets> http://pastie.org/private/shlernrts6pzyyzgwplfaq
[17:10:47] <allbets> here it is
[17:11:29] *** Joins: brson (brson@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:11:29] *** ChanServ sets mode: +o brson
[17:11:35] <allbets> its supposed to be a lib i forgot to mention
[17:11:42] *** Joins: doomsplayer (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[17:11:43] *** Quits: doomsplayer (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Quit: doomsplayer)
[17:11:57] <Eridius> oh wait you said it fails at link time, not compile-time
[17:12:03] *** Joins: doomsplayer (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[17:12:04] <allbets> yep
[17:12:10] <Eridius> that means you're not linking against the library that exposes that symbol
[17:13:03] *** Quits: xLII (xLII@FF04F06F.9FFB2C04.81CDC09E.IP) (Ping timeout)
[17:13:21] <Eridius> allbets: could the library name be case-sensitive? What if you use User32
[17:14:19] <allbets> nope didnt help
[17:14:34] <Eridius> hmm, I don't know anything about windows :/
[17:15:33] <allbets> hm what is strange is that the example from the tutorial doesnt work, too
[17:15:41] *** Joins: gnittala (gnittala@905F18E1.8E6D85B5.274D17D6.IP)
[17:16:00] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[17:18:53] *** Joins: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:20:20] *** Joins: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de)
[17:20:49] <bstrie> allbets: are you running the compiler with "rustc -L path/to/thing/I/want/to/link foo.rs" ?
[17:21:17] <Eridius> bstrie: extern mod should be providing the appropriate -l flag automatically to the linker
[17:21:22] <Eridius> although again I don't know jack about Windows
[17:21:36] <allbets> well yes its part of the winapi
[17:22:05] <allbets> i can try to give explicit reference to system32 dir :0
[17:22:28] <MaikKlein> can I have two selfs in a method like fn foo(&mut self, &self1)?
[17:22:38] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:22:42] <Eridius> MaikKlein: what is &self1?
[17:22:44] <cmr> MaikKlein: no, why do you think that would make sense?
[17:22:47] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:22:59] <MaikKlein> sec
[17:22:59] <Eridius> MaikKlein: if you're trying to write a trait function that takes a second object of the same type as self, use Self as the type
[17:23:06] <Eridius> fn foo(&mut self, other: Self)
[17:23:22] <Eridius> and if it's not a trait function, then you already know the type of self and you can just use that type directly
[17:23:52] <MaikKlein> https://gist.github.com/MaikKlein/5869394
[17:24:35] <MaikKlein> std::option::Option<&Node<>>` but found `std::option::Option<&mut Node<'self>>
[17:24:43] <MaikKlein> because I did Some(self)
[17:24:51] *** Joins: robarnold (rob@BD56354E.DB510C09.6E370BFC.IP)
[17:24:52] <MaikKlein> and self is mutable
[17:25:17] <Eridius> MaikKlein: I think you should declare the struct as parent: Option<&'self const Node<'self>>
[17:25:36] <Eridius> because if you try to convert the mutable pointer to an immutable one that's going to freeze self, which you don't want
[17:25:57] <MaikKlein> Eridius, isn't const going away?
[17:26:05] <Eridius> yeah, and I have no idea what's going to replace it :/
[17:26:11] <Eridius> but while it's here, keep using it
[17:26:39] <Eridius> MaikKlein: I'm not sure who's pushing to remove const, but you should ask them how to write your code in a const-free world
[17:27:36] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:27:50] <MaikKlein> how do I cast a mut object to an immutable one?
[17:28:07] <MaikKlein> like &mut self
[17:28:18] <Eridius> MaikKlein: &*self should work, but again, that's going to freeze your mutable pointer
[17:28:23] <Eridius> which won't work since you're about to mutate it
[17:28:28] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Ping timeout)
[17:28:31] <Eridius> but if you use &'self const in your struct you don't need to do that
[17:28:41] <Eridius> because a &const pointer type accepts both mutable and immutable pointers
[17:28:44] <MaikKlein> hm I did, sec I double check again
[17:29:45] *** Quits: gnittala (gnittala@905F18E1.8E6D85B5.274D17D6.IP) (Quit: Leaving)
[17:30:12] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[17:32:03] <MaikKlein> Eridius, wait are you sure that it freezes? I thought only @ can freez
[17:32:26] *** Quits: robertkn_ (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:32:26] <Eridius> MaikKlein: well it borrows the &mut pointer, and borrowck prevents you from modifying the &mut pointer while it's borrowed
[17:32:32] <Eridius> just like trying to mutate a ~ while it's borowe
[17:32:33] <Eridius> *d
[17:32:36] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[17:32:38] *** Quits: cr (anonymous@moz-9D6CBECC.dip0.t-ipconnect.de) (Quit: cr)
[17:32:56] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[17:32:58] *** Joins: SimonSapin1 (simon@88F51059.F3BBB17D.144F44FA.IP)
[17:33:06] <Eridius> rusti: let a = &mut 3; let b = &*a; a += 1; a
[17:33:07] -rusti- <anon>:9:38: 9:44 error: binary operation + cannot be applied to type `&mut <VI0>`
[17:33:08] -rusti- <anon>:9          let a = &mut 3; let b = &*a; a += 1; a
[17:33:08] -rusti-                                                ^~~~~~
[17:33:08] -rusti- error: aborting due to previous error
[17:33:08] -rusti- application terminated with error code 101
[17:33:13] <Eridius> rusti: let a = &mut 3; let b = &*a; *a += 1; a
[17:33:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aDjE
[17:33:25] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[17:33:30] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:33:35] <Eridius> rusti: let mut x = 3; let a = &mut x; let b = &*a; *a += 1; b
[17:33:37] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jbEF
[17:33:49] <Eridius> rusti: let mut x = 3; let a = &mut x; let b = &*a; *a += 1; *b
[17:33:50] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HNLE
[17:34:02] <Eridius> there we go. error: cannot assign to `*a` because it is borrowed
[17:34:39] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Ping timeout)
[17:35:34] *** Joins: azita (Azita@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:35:47] *** Quits: eholk (eholk@moz-FF3718FD.uconnect.utah.edu) (Quit: eholk)
[17:36:48] *** Joins: snearch (snearch@moz-CF918F37.pool.mediaways.net)
[17:39:18] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[17:39:37] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[17:39:54] *** Joins: nano (nano@moz-972880B.superkabel.de)
[17:39:55] *** Quits: azita (Azita@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: azita)
[17:40:22] <allbets> as a matter of fact the system wasnt included, stupid me, but now i get even more weird linker errors http://pastie.org/private/kz3shrmzukvy2aih3dnctw
[17:40:31] *** Joins: eagen (eagen@8737942B.7A99C13A.B7961A98.IP)
[17:40:35] *** Quits: brendan (brendaneic@moz-B31AD19A.sub-174-240-0.myvzw.com) (Quit: brendan)
[17:40:50] <MaikKlein> Eridius, ah okay thanks
[17:41:43] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[17:42:57] <MaikKlein> I am still confused with lifetimes :x https://gist.github.com/MaikKlein/5869560 I guess I need to tell some how long it can live? 
[17:43:12] <MaikKlein> sth like Some<'self> I have absolutely no idea
[17:43:27] <bstrie> allbets: never seen anything like that before
[17:43:35] *** Quits: jyeo (user@F2D29657.F60B0462.67AC9B1.IP) (Input/output error)
[17:43:42] <bstrie> allbets: can you link anything at all on windows? would be nice to make sure the ffi isn't just broken entirely
[17:43:43] <doener> MaikKlein: the "self" argument needs a lifetime
[17:43:57] *** Quits: snearch (snearch@moz-CF918F37.pool.mediaways.net) (Quit: Verlassend)
[17:44:08] <Eridius> MaikKlein: &'self mut self, perhaps
[17:44:14] <MaikKlein> doener, what is the syntax? &'self mut self ?
[17:44:33] <doener> right
[17:45:24] <SiegeLord> Is mutability a part of the type in Rust?
[17:45:48] <bstrie> SiegeLord: it can be, for types like @mut
[17:45:58] <cmr> SiegeLord: not really, not the type itself, but of pointers to the type.
[17:46:00] <SiegeLord> I note that we do let mut a as opposed to let a : mut
[17:46:01] <bstrie> but not generally
[17:46:05] <allbets> bstrie: well yeah linking works in general though not tested with this specific mingw version which is needed for rust
[17:46:55] <bstrie> SiegeLord: in `let mut a`, we say that the mutability is a property of the *slot*
[17:47:18] <cmr> Also can have `fn foo(mut a: val)`, for example.
[17:47:23] *** Joins: azita (Azita@moz-BE33DA21.fw1.sfo1.mozilla.net)
[17:47:29] <Eridius> SiegeLord: mutability is part of the "slot" (e.g. the variable), and is inherited through types and through ~-pointers. However & and @ don't inherit mutability, but instead define their own mutability
[17:47:32] <cmr> (It can be mutable becaue foo takes owns the value)
[17:48:07] <cmr> I think that's only true for Const types though. Not sure.
[17:48:22] <Eridius> `let mut a = &b` gives you a mutable slot a, which contains an immutable pointer to b. So you could reassign to a (`a = &c`), but you can't modify b through the pointer (e.g. `*a += 3` is invalid)
[17:49:10] <SiegeLord> I'm just thinking this in terms of what D does... I *think* there mutability is part of the type
[17:49:42] <Eridius> rust used to define mutability on individual fields in a struct, but that was discarded in favor of inheriting mutability from the slot
[17:50:06] <cmr> jclements: Some of this code makes me want to cry. Not because it's bad, but because there's just *so much of it*, like all the ToSource impls...
[17:50:07] <MaikKlein> how can I create an option object with the type of "Option<&'self const Node<'self>>" Because if I do Some(self) it consumes the self. :x
[17:50:30] <doomlord> 'self .. lifetimee of self?
[17:50:32] <Eridius> MaikKlein: self is a pointer. how is it "consuming" self?
[17:50:32] <jclements> cmr: yep.
[17:50:47] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[17:50:51] <MaikKlein> Eridius, well i have no idea, I can post the log
[17:50:54] <jclements> cmr: you start on a project and think: well, this won't take me more than an hour....
[17:51:29] <cmr> jclements: I gave up on the interner. It was definitely the wrong place to start. Working on changing *one field* of FileMap, src, from @ to ~, and.. it just keeps going
[17:51:49] <jclements> cmr: yep, I know exactly what you mean.
[17:51:50] <cmr> It should avoid a lot of copies though, there was .to_managed() in lots of places
[17:51:52] <MaikKlein> https://gist.github.com/MaikKlein/5869643 it tells me 15:28 note: `self` moved here because it has type `&'self mut Node<'self>`, which is moved by default (use `copy` to override)
[17:52:11] <MaikKlein> but I don't want to copy
[17:52:44] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[17:52:55] <Eridius> MaikKlein: well the first error is "error: cannot borrow immutable argument as mutable"
[17:53:42] <Eridius> ok that is weird, it is definitely trying to move self, which is of type &'self mut Node<'self>
[17:53:54] *** Parts: allbets (allbets@moz-8121C36A.vie.surfer.at) ()
[17:53:59] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[17:54:09] <Eridius> I wonder if maybe the recent change to get rid of implicit copies went a bit too far.. it doesn't seem to make sense to me to try to move &-pointers at all
[17:54:10] <MaikKlein> ok I fixed it with mut node: Node<'self>)
[17:54:30] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Ping timeout)
[17:54:31] <MaikKlein> but it still tries to move ofc
[17:54:32] <MaikKlein> :(
[17:54:43] <Eridius> MaikKlein: you can say Some(copy self)
[17:54:49] <Eridius> although now there's borrowck errors in main()
[17:54:51] <Eridius> which I think are simply wrong
[17:55:20] <Eridius> it think it's not returning the borrowed &mut pointer
[17:55:33] *** Joins: eholk (eholk@moz-FF3718FD.uconnect.utah.edu)
[17:57:32] <MaikKlein> i think the " &'self mut self " makes problems
[17:58:24] *** Joins: tjc (tjc@moz-44A8681F.public.wayport.net)
[17:58:24] *** ChanServ sets mode: +o tjc
[17:59:13] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Client exited)
[18:01:09] * MaikKlein Emergency shutdown "Brain"
[18:03:21] <MaikKlein> Eridius, also copy doesn't work. " error: copying a value of non-copyable type `&'self mut Node<'self>`"
[18:03:30] <MaikKlein> I think I post this on reddit
[18:03:42] <Eridius> MaikKlein: hmm, worked for me. I'm using compiler from yesterday evening
[18:04:08] <MaikKlein> Eridius, hm me too
[18:04:55] <MaikKlein> I just recompile to the newest master
[18:07:08] <cmr> "error: aborting due to 55 previous errors" that's much less fallout than I was expecting.
[18:09:47] <Sergio965> Can existing types be extended? For example, I can do: "impl string { fn myfunc(&self) { â€¦ } }" and then call "hello".myfunc()?
[18:09:52] <Sergio965> can I*
[18:10:05] <Eridius> Sergio965: you can define a trait and implement the trait on arbitrary types
[18:10:10] <cmr> Sergio965: Yes, but you need to create a "dummy trait"
[18:10:26] <Sergio965> I see. Is there a reason for this?
[18:10:37] <Eridius> rusti: trait Foo { fn foo(&self); } impl Foo for &str { fn foo(&self) { println("foo"); } }; "hello".foo()
[18:10:37] -rusti- <anon>:9:51: 9:55 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[18:10:37] <cmr> To avoid the problem where, when linking multiple crates, they don't link because each defines their own extension method and they clash
[18:10:37] -rusti- <anon>:9          trait Foo { fn foo(&self); } impl Foo for &str { fn foo(&self) { println("foo"); } }; "hello".foo()
[18:10:38] -rusti-                                                             ^~~~
[18:10:38] -rusti- error: aborting due to previous error
[18:10:38] -rusti- application terminated with error code 101
[18:10:49] <Eridius> blah whatever, you get the idea
[18:10:56] <cmr> If each has their own trait with their own name, two crates can always link
[18:11:08] <Eridius> rusti: trait Foo { fn foo(&self); } impl<'self> Foo for &'self str { fn foo(&self) { println("foo"); } }; "hello".foo()
[18:11:09] -rusti- foo
[18:11:09] <cmr> The rule is you can only impl for traits your crate owns, or for types your crate owns.
[18:11:09] -rusti- ()
[18:11:46] <Sergio965> Eridius: Thanks!
[18:11:52] <Sergio965> cmr: That makes sense.
[18:11:53] <Sergio965> Thanks guys.
[18:12:15] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[18:13:03] *** Quits: rubber-duck (rubber-duc@E34C8909.13F85533.76F1346C.IP) (Ping timeout)
[18:13:10] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[18:15:17] *** Joins: tav (tav@moz-5ED3AF3C.range86-152.btcentralplus.com)
[18:15:28] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[18:16:24] *** Quits: tjc (tjc@moz-44A8681F.public.wayport.net) (Quit: zzzzzzzzzz)
[18:17:35] *** Joins: pcwalton (pcwalton@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:17:35] *** ChanServ sets mode: +o pcwalton
[18:18:58] *** Quits: indirect (indirect_m@moz-770AB053.hsd1.ca.comcast.net) (Ping timeout)
[18:22:28] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[18:22:39] *** Joins: indirect (indirect_m@moz-770AB053.hsd1.ca.comcast.net)
[18:24:38] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[18:28:35] *** Joins: rubber-duck (rubber-duc@moz-6E09F57E.dsl.iskon.hr)
[18:29:35] *** Joins: jyeo (user@F2D29657.F60B0462.67AC9B1.IP)
[18:29:54] *** Joins: obk (Mibbit@5832C6FA.C88E081E.27150B55.IP)
[18:32:29] <bblum> UnsafeAtomicRcBox<AtomicOption<PortOne<StreamPortOne<T>>>>
[18:32:32] <obk> Still can't compile rust on SLES11 w/ gcc 4.8.0 - error in https://gist.github.com/anonymous/5870009 (unknown type name â€˜pthread_rwlock_tâ€™) - any ideas welcome.
[18:32:32] <cmr> Eridius: term refactor needs a rebase
[18:32:34] <bblum> sweet type you got there
[18:32:36] <cmr> Eridius: thanks for doing that :)
[18:32:46] <Eridius> cmr: it does? dammit, what happened
[18:33:22] <Eridius> also, if github knows whether the PR is mergable, why is this not exposed in the UI?
[18:33:38] <cmr> It only does it for people who can actually merge the PR
[18:33:40] <cmr> kinda annoying
[18:33:49] <Eridius> bah
[18:34:07] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[18:35:08] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[18:35:40] <Eridius> cmr: argh color got renamed to _color in the windows config >_<
[18:35:55] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[18:38:55] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[18:39:31] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[18:43:15] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[18:43:36] <bstrie> rusti: std::vec::capacity(~[1])
[18:43:37] -rusti- <anon>:9:28: 9:32 error: mismatched types: expected `&const ~[<V4>]` but found `~[<VI0>]` (expected &-ptr but found vector)
[18:43:37] -rusti- <anon>:9          std::vec::capacity(~[1])
[18:43:37] -rusti-                                      ^~~~
[18:43:37] -rusti- error: aborting due to previous error
[18:43:37] -rusti- application terminated with error code 101
[18:43:46] <bstrie> rusti: std::vec::capacity(&~[1])
[18:43:48] -rusti- 4
[18:43:56] <bstrie> rusti: std::vec::capacity(&~[1,2,3,4,5])
[18:43:57] -rusti- 5
[18:44:10] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:44:11] <bstrie> ...
[18:44:27] <cmr> rusti: std::vec::capacity(&~[1,2,3,4,5, 6, 7])
[18:44:28] -rusti- 7
[18:44:33] <cmr> rusti: std::vec::capacity(&~[1,2,3])
[18:44:34] -rusti- 4
[18:44:51] <cmr> bstrie: it probably just won't make a vec with a capacity smaller than 4
[18:44:58] <strcat> right
[18:45:05] <bstrie> but I thought that vectors would grow to the next nearest power of two
[18:45:12] <bstrie> so ~[1,2,3,4,5] would have capacity for 8
[18:45:30] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[18:45:53] *** Quits: qmx (qmx@B42C1175.A82378F3.A2BF9DEB.IP) (Quit: Textual IRC Client: www.textualapp.com)
[18:47:08] <bstrie> rusti: let x = ~[1,2,3,4]; let y = std::vec::capacity(&x); x.push(5); let z = std::vec:capacity(&x); (y, z)
[18:47:08] -rusti- <anon>:9:88: 9:89 error: expected `;` but found `:`
[18:47:08] -rusti- <anon>:9          let x = ~[1,2,3,4]; let y = std::vec::capacity(&x); x.push(5); let z = std::vec:capacity(&x); (y, z)
[18:47:08] -rusti-                                                                                                  ^
[18:47:09] -rusti- application terminated with error code 101
[18:47:37] <MaikKlein> ok i made a post on reddit http://www.reddit.com/r/rust/comments/1h4icq/help_me_to_confirm_a_bug_with_self_mut_self/
[18:47:41] <Eridius> rusti: use std::vec; let mut x = vec::with_capacity(5); x.push_all(~[1,2,3,4,5]); vec::capacity(x)
[18:47:41] -rusti- <anon>:9:98: 9:99 error: mismatched types: expected `&const ~[<V9>]` but found `~[<VI5>]` (expected &-ptr but found vector)
[18:47:41] -rusti- <anon>:9          use std::vec; let mut x = vec::with_capacity(5); x.push_all(~[1,2,3,4,5]); vec::capacity(x)
[18:47:41] -rusti-                                                                                                            ^
[18:47:41] -rusti- error: aborting due to previous error
[18:47:43] -rusti- application terminated with error code 101
[18:47:45] <Eridius> rusti: use std::vec; let mut x = vec::with_capacity(5); x.push_all(~[1,2,3,4,5]); vec::capacity(&x)
[18:47:46] -rusti- <anon>:9:69: 9:81 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[18:47:46] -rusti- <anon>:9          use std::vec; let mut x = vec::with_capacity(5); x.push_all(~[1,2,3,4,5]); vec::capacity(&x)
[18:47:49] -rusti-                                                                               ^~~~~~~~~~~~
[18:47:53] -rusti- 5
[18:48:23] <bstrie> what I want to know is, what's our current growth rate
[18:48:28] <bstrie> is it 2x?
[18:48:30] <strcat> bstrie: 2x
[18:48:35] <bstrie> ok, now how do I prove that
[18:48:42] <Eridius> bstrie: looks like vec::reserve() reserves exactly what was asked for. reserve_at_least() does the power-of-2 behavior
[18:48:44] <bstrie> is vec::capacity the wrong tool?
[18:48:52] <strcat> rusti: let mut xs = ~[1, 2, 3, 4]; println(vec::capacity(&xs).to_str())
[18:48:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/JYNP
[18:49:10] <Eridius> bstrie: anything that uses reserve_at_least (including push) will grow with powers of 2
[18:49:16] <strcat> rusti: let mut xs = ~[1, 2, 3, 4]; println(std::vec::capacity(&xs).to_str()); xs.push(2); std::vec::capacity(&xs)
[18:49:17] -rusti- 4
[18:49:18] -rusti- 8
[18:49:21] <strcat> there
[18:49:29] <bstrie> ok
[18:49:40] <strcat> rusti: let mut xs = ~[1, 2, 3, 4]; println(std::vec::capacity(&xs).to_str()); xs.push(2); xs.push(2); xs.push(2); xs.push(2); std::vec::capacity(&xs)
[18:49:41] -rusti- 4
[18:49:41] -rusti- 8
[18:49:46] <strcat> rusti: let mut xs = ~[1, 2, 3, 4]; println(std::vec::capacity(&xs).to_str()); xs.push(2); xs.push(2); xs.push(2); xs.push(2); xs.push(2); std::vec::capacity(&xs)
[18:49:46] <bstrie> I'm also curious where the default size of 4 comes from
[18:49:47] -rusti- 4
[18:49:47] -rusti- 16
[18:50:18] <Eridius> rusti: std::vec::capacity(~[])
[18:50:18] -rusti- <anon>:9:28: 9:31 error: mismatched types: expected `&const ~[<V4>]` but found `~[<V5>]` (expected &-ptr but found vector)
[18:50:19] -rusti- <anon>:9          std::vec::capacity(~[])
[18:50:19] -rusti-                                      ^~~
[18:50:19] -rusti- error: aborting due to previous error
[18:50:19] -rusti- application terminated with error code 101
[18:50:23] <Eridius> rusti: std::vec::capacity(&~[])
[18:50:24] -rusti- <anon>:9:28: 9:32 error: cannot determine a type for this expression: unconstrained type
[18:50:24] -rusti- <anon>:9          std::vec::capacity(&~[])
[18:50:24] -rusti-                                      ^~~~
[18:50:25] -rusti- error: aborting due to previous error
[18:50:25] *** concrete.mozilla.org sets mode: +M 
[18:50:27] -rusti- application terminated with error code 101
[18:50:34] <Eridius> rusti: let x : ~[u8] = ~[]; std::vec::capacity(&x)
[18:50:35] -rusti- 4
[18:50:43] <Eridius> that's where 4 comes from. it's the size that the runtime gives to an empty vector
[18:50:59] <bstrie> right, I'm curious why it's 4
[18:51:02] <Eridius> or maybe the compiler does that. I don't know exactly where ~[...] gets translated into a vector construction
[18:51:05] <bstrie> as opposed to 300,000 or something
[18:51:17] <Eridius> incidentally build() defaults to 4
[18:51:20] <bstrie> what does C++ do here
[18:51:24] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Quit: Leaving)
[18:51:36] <strcat> bstrie: which C++ stdlib implementation?
[18:51:38] *** Quits: azita (Azita@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: azita)
[18:51:41] <strcat> libstdc++ uses 2x and libc++ uses 1.5x
[18:51:43] <bstrie> strcat: the best one
[18:51:45] <strcat> boost uses 1.5x
[18:51:47] <strcat> libc++ then
[18:51:49] <strcat> 1.5x
[18:51:54] <Eridius> so it's possible that the 4 comes from build() (and build_sized_opt() which has the same 4)
[18:52:11] *** Joins: cr (anonymous@moz-9D6CBECC.dip0.t-ipconnect.de)
[18:52:57] <bstrie> Eridius: I'm talking in the philosophical sense, why 4 rather than any other number :P I wonder if it was chosen carefully or if it was just a quick thing done without thinking
[18:53:01] *** Quits: jclements (jclements@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: jclements)
[18:53:07] * cmr guesses the latter
[18:53:11] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[18:53:19] <Eridius> it was probably chosen because it's a small power of 2
[18:53:27] <Eridius> don't want to make empty vectors too large
[18:53:39] <Eridius> but I can't answer definitively
[18:53:49] <bstrie> strcat: so if our default size is 4, what's libc++'s default size for vectors?
[18:54:30] <strcat> 0
[18:54:44] <bstrie> well in that case a 1.5x growth rate doesn't seem very useful
[18:54:49] <strcat> but C++ stores vectors differently
[18:55:08] *** Quits: brson (brson@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[18:55:23] *** concrete.mozilla.org sets mode: -M 
[18:55:41] <doomlord> what is rusts' binary layout for vectors
[18:55:46] <bstrie> strcat: I ask because I want to try out https://github.com/mozilla/rust/issues/4961 , but I'm wondering what else will need to change to make it a fair test
[18:56:07] <strcat> there's no point in testing it until we're back on jemalloc
[18:56:13] <bstrie> right, I was thinking that
[18:56:14] *** Joins: cp (cp@moz-993078EE.plus.com)
[18:56:28] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[18:56:31] <cmr> *cough* LD_PRELOAD
[18:56:37] *** Joins: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com)
[18:56:44] <strcat> sure but we might not switch back to jemalloc
[18:56:46] <strcat> there's no point
[18:56:54] <strcat> it's different per allocator
[18:56:58] <strcat> we can't test every allocator
[18:57:40] <strcat> bstrie: http://ix.io/6nm libstdc++
[18:58:23] <cmr> doomlord: http://static.rust-lang.org/doc/std/vec.html#struct-unboxedvecrepr
[18:58:30] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[18:58:30] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/FjnNbg
[18:58:30] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[18:59:00] <doomlord> anyone heard of a tool for making a C wrapper for a C++ class - effectively creating a predictable name-mangle (... an idea for exposing existing c++ code to rust..)
[18:59:22] <cmr> does swig do it?
[18:59:32] <MaikKlein> is there a method on vector that acts like push but also returns a reference to the pushed value?
[18:59:35] <strcat> cmr: but they all have the useless 32-byte headers too
[18:59:37] <doomlord> ... and could such a thing be rolled into a trait, rust-side..
[18:59:49] <Eridius> ok the 4 size for ~[] vecs is in middle/trans/tvec.rs
[18:59:53] <Eridius> with no comment, naturally
[19:00:11] <doomlord> http://stackoverflow.com/questions/1067278/generate-c-wrapper-from-c
[19:00:13] <Eridius> MaikKlein: is there a reason to need such a method when you could just use two methods?
[19:00:44] <doomlord> ok swig. sounds like a useful project to make rust bindings like that
[19:01:00] *** Joins: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP)
[19:01:24] <bstrie> Eridius: nice
[19:01:33] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:01:34] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/V_23dQ
[19:01:34] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:01:34] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[19:01:34] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/6Ri9jg
[19:01:34] <ghrust> 13rust/06auto 143dbaa6f 15Alex Crichton: Turn on using LLVM threadsafely
[19:01:34] <ghrust> 13rust/06auto 14782d09b 15bors: auto merge of #7409 : alexcrichton/rust/threadsafe, r=catamorphism...
[19:01:34] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[19:02:30] <MaikKlein> Eridius, ah is it guaranteed that push is always the last element on a vector?
[19:02:43] <cmr> MaikKlein: yeah, kinda the point :p
[19:02:46] <bstrie> sigh, 2-hour test cycles
[19:03:00] <MaikKlein> cmr, okay I wasn't completely sure if it was
[19:03:02] <MaikKlein> thanks
[19:03:34] *** Quits: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: eatkinson)
[19:03:57] <bstrie> strcat: why wouldn't we switch back to jemalloc?
[19:04:15] <strcat> because afaik it's running off the red zone in free
[19:04:46] <bstrie> and you think that can't get fixed before 1.0?
[19:04:46] <strcat> so as usual we're choosing segmented stacks over performance
[19:04:49] <strcat> bstrie: nope
[19:05:17] <strcat> can't allocate more stack to call jemalloc, jemalloc is the allocator
[19:05:27] <strcat> the red zone has to be big enough
[19:05:41] <strcat> freebsd uses jemalloc by default, but I guess we don't care
[19:06:08] <strcat> rust only supports a libc with an allocator implementation happily fitting in the red zone
[19:06:11] *** Joins: tjc (tjc@107A98AF.73F86292.93593ABC.IP)
[19:06:11] *** ChanServ sets mode: +o tjc
[19:06:46] <bstrie> I thought the red zone size was already tunable per platform
[19:06:51] <strcat> it could be that we're already running into the red zone somewhere else
[19:06:52] <bstrie> (and already too big on all of them)
[19:06:58] <strcat> and that jemalloc isn't getting all of the red zone to itself
[19:07:13] <strcat> bstrie: sure, it's 'too big' in that it could be smaller
[19:07:28] <strcat> but it's too small in that rust only works with certain allocators and may sometimes have stack overflows with them
[19:07:36] <strcat> we have no proof that it actually always works with the glibc allocator
[19:07:40] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[19:08:46] <strcat> there's a choice between being in the performance ballpark of C++ by default and lightweight tasks by default
[19:09:10] <strcat> atm our tasks gobble up a huge amount of VM since they all end up with 2MiB+ stacks *anyway* plus the old C stack for compatibility
[19:09:22] <strcat> and they're slow too
[19:09:26] <strcat> worst of both worlds
[19:09:53] <strcat> anyway it's not something where you can have your cake and eat it too
[19:10:03] <strcat> virtual memory vs speed tradeoff
[19:10:46] <bstrie> sad to hear it
[19:10:52] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[19:10:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14782d09b to 143433851: 02http://git.io/N3iJvQ
[19:10:52] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[19:10:54] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[19:10:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/2u2kmg
[19:10:54] <ghrust> 13rust/06auto 14276463f 15Michael Sullivan: Fix another generics bug with default methods. Closes #7295.
[19:10:54] <ghrust> 13rust/06auto 1423fb227 15bors: auto merge of #7356 : msullivan/rust/default-methods, r=bblum...
[19:10:54] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[19:10:59] <strcat> unless it's exposed in the task API (do you want this task to have a segmented stack?)
[19:11:19] <cmr> what is a segmented stack exactly
[19:11:30] <strcat> the stack is a linked list of segments
[19:11:34] <strcat> it grows as-needed
[19:11:42] <Eridius> it's what Go uses
[19:11:44] <strcat> starts off very small, under a kilobyte afaik
[19:11:48] <strcat> + the red zone
[19:11:58] <Eridius> which is why you can have thousands of live goroutines at once
[19:12:06] <strcat> Eridius: can have thousands of threads at once
[19:12:12] <cmr> I've never used go
[19:12:20] <strcat> segmented stacks don't use that much more than a thread
[19:12:23] <strcat> err
[19:12:25] <strcat> that much less
[19:12:30] <Eridius> strcat: depends on your platform I would wager
[19:12:34] <strcat> Eridius: sure
[19:12:38] *** Parts: obk (Mibbit@5832C6FA.C88E081E.27150B55.IP) ()
[19:12:38] <acrichto> strcat: thread => kernel resources though, so not exactly the same
[19:12:43] <strcat> and a server is going to be on linux or freebsd
[19:12:48] <strcat> acrichto: threads aren't really kernel resources
[19:12:53] <strcat> the memory is in userspace
[19:12:56] <Eridius> strcat: threads are tracked in the kernel
[19:13:00] <strcat> the kernel can handle millions of them without caring
[19:13:00] <acrichto> they've got a tcb allocated and have to be scheduled
[19:13:07] <Eridius> also, you can't assume that every rust program is going to be running on linux or freebsd
[19:13:12] *** Joins: snearch (snearch@moz-CF918F37.pool.mediaways.net)
[19:13:12] <strcat> acrichto: they can be scheduled as groups
[19:13:26] <strcat> Eridius: I think we can assume it's not going to scale on windows anyway
[19:13:37] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[19:13:37] <strcat> especially if we're not using jemalloc
[19:13:44] <strcat> which it appears we won't be if we want segmented stacks
[19:14:07] *** Joins: zargony (zargony@moz-81F4F87.versanet.de)
[19:14:23] *** Quits: Yurume_ (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[19:14:30] <strcat> servers (the only case when you actually want 2 million tasks) are going to be on 64-bit, and they're going to be on linux/freebsd
[19:14:52] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[19:15:17] <bstrie> strcat: what did graydon say?
[19:15:23] <strcat> about this? nothing afaik
[19:16:03] <strcat> I think we can just expose it in the task API but I don't know why segmented stacks are the default
[19:16:06] <strcat> you rarely want them
[19:16:21] <doomlord> impl<'self> ......   -what does 'self mean? i thought ' was regions
[19:16:26] <cmr> doomlord: it is
[19:17:27] <zargony> hi everybody. could anybody point me into the right direction with a borrowed pointer lifetime problem?
[19:17:28] <MaikKlein> can I do sth like this "  fn foo<'r>(v: &~[bar]) -> &'r bar{v.last()} "?
[19:17:51] <bstrie> strcat: you should bring this up somewhere more visible, I was under the impression that the reason we got rid of jemalloc was because of our invalid IR
[19:17:54] <zargony> i wonder why this doesn't work: fn create<'a, T> (foo: &'a MyTrait<T>) -> ~MyContainer<'a, T> { ~ MyContainer { foo: foo } }
[19:17:56] <MaikKlein> probably not right?
[19:18:08] <Sergio965> Is everything being moved over to use .iter() instead of things like .each?
[19:18:12] <strcat> bstrie: I don't think it's going to change
[19:18:14] <bstrie> Sergio965: yes
[19:18:21] <bstrie> strcat: why not?
[19:18:27] *** Joins: skippydippy (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[19:18:30] <strcat> Sergio965: https://mail.mozilla.org/pipermail/rust-dev/2013-June/004599.html
[19:18:46] <strcat> bstrie: because again, we can't have both performance and segmented stacks
[19:18:52] <strcat> and segmented stacks seem pretty entrenched
[19:20:02] <MaikKlein> I mean fn foo<'r>(v: &~[bar]) -> &'r bar{v.last()} rust would need to be able to track objects in a vector, and I don't think that is possible... Otherwise last() returns a pointer so I guess it already knows?
[19:20:05] <bstrie> "entrenched" in the sense of tied to the implementation, or entrenched philosophically?
[19:20:32] <strcat> philosophically
[19:20:56] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[19:21:05] *** Joins: roo (jesse.rudo@moz-4D53E5F9.dynamic.ip.windstream.net)
[19:21:09] <Eridius> strcat: I just ran a test where I tried to allocate 10000 pthreads (using C) and it bailed
[19:21:33] <strcat> Eridius: works fine here
[19:22:03] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[19:22:14] <Eridius> strcat: it fails on the 2048th thread
[19:22:24] <Eridius> this is OS X
[19:22:25] <cmr> Eridius: did you up the thread/process limit with ulimit?
[19:22:32] <Eridius> cmr: the error is "Cannot allocate memory"
[19:22:34] <strcat> Eridius: okay so not an OS designed/meant for servers
[19:22:44] <Eridius> actually that's probably just EAGAIN
[19:22:46] <Eridius> so that might be a ulimit
[19:22:55] <strcat> sounds like an arbitrary limit
[19:23:19] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[19:23:54] <Eridius> not sure if it's relevant but sysctl has kern.num_tasks and kern.num_taskthreads set to 2048 (I don't know what those are)
[19:24:43] <Eridius> num_threads is 10240
[19:25:37] *** Quits: eholk (eholk@moz-FF3718FD.uconnect.utah.edu) (Quit: eholk)
[19:25:42] <tedh> kern.num_taskthreads: 2048 
[19:25:43] <bstrie> strcat: I'd still like to see something about this on the public record. if what you say is true, then you're not going to be the last person to bring this up. at least make the devs come out and say "yes, we understand the tradeoffs and accept the consequences"
[19:26:01] <strcat> Eridius: http://ix.io/6no runs fine for me
[19:26:13] <strcat> 100000 8MiB allocations, each with 1 page touched
[19:26:16] <cmr> yay I did something useful.
[19:26:22] *** Quits: roo (jesse.rudo@moz-4D53E5F9.dynamic.ip.windstream.net) (Ping timeout)
[19:26:24] <Eridius> strcat: those aren't threads
[19:26:29] <strcat> Eridius: I can do the same with threads
[19:26:31] <strcat> works fine
[19:27:01] <Eridius> hmm MAP_ANONYMOUS doesn't exist on OS X. what does that do?
[19:27:03] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[19:27:03] <strcat> with untuned, default kernel settings
[19:27:23] <Eridius> oh there's a flag MAP_ANON, is that possibly the same thing?
[19:27:24] <strcat>  The  mapping  is  not  backed  by  any  file; its contents are initialized to zero.
[19:27:26] <strcat> Eridius: yes
[19:27:30] <strcat> MAP_ANON is deprecated on linux
[19:27:55] *** Joins: roo (jesse.rudo@moz-DFCBD248.dynamic.ip.windstream.net)
[19:27:57] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[19:28:32] <Eridius> strcat: with your program on OS X `time -l` reports maximum rss as 410877952 (almost 392MB)
[19:28:52] <Eridius> with MAP_ANON instead of MAP_ANONYMOUS
[19:28:56] <strcat> Eridius: sure, I'm touching 1 page in each, a page is 4k
[19:29:34] <Eridius> strcat: 10000 pages is only 40MB
[19:29:40] <strcat> Eridius: there's 100k
[19:29:47] <Eridius> oh
[19:29:48] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:29:49] <Eridius> ok then
[19:29:55] <hoelzro> so I managed to segfault Rust =/
[19:30:07] <hoelzro> (more accurately, I managed to cause a segfault in a program built by Rust)
[19:30:07] <bstrie> hoelzro: join the club :P
[19:30:12] <hoelzro> \o/
[19:30:18] <cmr> http://i.imgur.com/D1c5oL3.png FileMap using ~str instead of @str
[19:30:31] <Eridius> strcat: here's my thread-creation program: https://gist.github.com/kballard/f378b778df08a1e7cf71
[19:30:55] <strcat> Eridius: could use pause() instead of sleep
[19:31:01] <strcat> and just ctrl-c it when it reaches the top
[19:31:33] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:31:33] <cmr> it does run fine on linux, no tuning at all
[19:31:48] <strcat> it's only 10k though
[19:32:07] <strcat> spawning 100k does work though
[19:32:15] <bstrie> hoelzro: please file a bug with your program if it's small enough
[19:32:26] <hoelzro> I've tried to make it small, but it's hard
[19:32:46] <Sergio965> Sorry, is the plan to have "for" support both internal and external iterators?
[19:32:52] <strcat> Sergio965: no
[19:32:54] <strcat> just external
[19:32:56] <Sergio965> I see.
[19:33:02] <Eridius> anyway the point is you can't assume the program is running on a server OS, it could be running on a consumer OS
[19:33:02] <strcat> there aren't going to be any internal iterators in the stdlib
[19:33:04] <Eridius> or even a mobile OS
[19:33:14] <strcat> Eridius: so for a consumer/mobile OS you don't need 1 million tasks
[19:33:22] <Eridius> strcat: depends on what the tasks are used for
[19:33:34] <Sergio965> But support the syntax sugar for both Iterable implementations and Iterator implementations, ala Python?
[19:33:44] <strcat> Eridius: they can be used for much more than reading/writing from/to a socket/file if you want a million
[19:33:49] <strcat> they can't allocate an array
[19:33:54] <strcat> they can't have a hash table
[19:33:58] <strcat> it'd be bigger than the stack
[19:34:15] <Eridius> well I don't want a million, but a couple thousand would be nice to support
[19:34:18] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[19:34:20] <strcat> there's one use case -> a server that *only* proxies connections or serves files
[19:34:28] <strcat> Eridius: a couple thousand works fine with threads
[19:34:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:34:39] <Eridius> strcat: 2048 doesn't work with threads on OS X
[19:34:39] <strcat> you can spawn 1k threads on android afaik, it's not going to care
[19:34:41] <Eridius> because of the sysctl
[19:35:13] <hoelzro> I'll try to trim it down as much as I can
[19:35:14] <strcat> so we're going to take a 20-30% performance hit because OS X has crappy defaults? ;p
[19:35:41] <strcat> + no jemalloc, so much more of a hit with lots of actual threads doing actual work
[19:35:50] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[19:36:00] <Eridius> strcat: well I'm not actually sure how relevant thread limits are to rust's tasks anyway, because presumably you're not doing a 1-to-1 mapping of tasks to threads
[19:36:11] <strcat> Eridius: if they're doing CPU work you are
[19:36:14] <Eridius> I'm just talking about threads because it's something I can measure
[19:36:22] <Eridius> strcat: 1000 threads doing CPU work? not very useful. I don't have 1000 cores
[19:36:37] <strcat> Eridius: you can't have 1000 tasks doing CPU work without 1000 threads
[19:36:41] <strcat> or they will block each other
[19:37:02] <Eridius> strcat: how is blocking in rust's scheduler any worse than blocking in the kernel's thread scheduler?
[19:37:10] <strcat> Eridius: the kernel scheduler doesn't 'block'
[19:37:15] <strcat> it preempts
[19:37:26] <strcat> we don't use cooperative scheduling OSes anymore
[19:37:37] <Eridius> ok so you're saying rust tasks need to be preemptive
[19:37:40] <strcat> no
[19:37:41] <Eridius> ok so yeah thread limits do matter
[19:37:42] <strcat> they don't need to be
[19:37:47] <strcat> if they were preemptive they would be useless
[19:37:52] <Eridius> well if they're cooperative then you can block in rust's scheduler no problem
[19:37:59] <strcat> kernel threads are *already* preemptive
[19:38:05] <bstrie> strcat: once again, I really wish you would bring up these concerns somewhere more visible than irc. I'd like to see the devs react to it, whether or not you think that segmented stacks are inevitable
[19:38:07] <strcat> if you want preemption, you want kernel threads
[19:38:29] <strcat> you can't beat the kernel's scheduling implementation in userspace
[19:38:37] <Eridius> strcat: I'm confused. if we don't need preemptive tasks, then why have a 1-to-1 mapping of tasks to threads?
[19:38:37] <strcat> you can't come close
[19:38:53] <strcat> Eridius: sometimes you do want preemptive tasks
[19:38:59] <strcat> in that case you do want 1:1 mapping to threads
[19:39:07] <Eridius> ok sometimes, sure, and when you need those you can use a scheduler that maps each one to a thread
[19:39:08] <strcat> there's one use case where lightweight tasks work
[19:39:12] <strcat> tasks that do only I/O
[19:39:14] <strcat> no CPU work
[19:39:34] <strcat> they're an easier way to write async code, that's all
[19:39:48] <strcat> they don't replace threads, they don't compete with the OS scheduler, they aren't not one size fits all
[19:39:54] <strcat> aren't one size fits all*
[19:39:55] <Eridius> or tasks that do CPU work intermittently but are normally blocked on something
[19:40:01] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[19:40:04] <strcat> Eridius: but then your tasks will block each other
[19:40:08] <strcat> and you'll time out requests
[19:40:16] <Eridius> e.g. in Go it's not uncommon to spin up a goroutine that reads from one chan, does work, and writes to another chan. It may very well be dormant for 99% of the time
[19:40:17] <strcat> lightweight tasks only work for hello-world benchmarks
[19:40:37] <strcat> in the real world you usually do work, if you aren't writing a proxy or a web server (we have enough of those)
[19:40:56] <Eridius> strcat: you're missing the point. In Go, goroutines are often used in a datastructure-like way
[19:40:58] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[19:41:13] <strcat> Eridius: you won't use them that way in rust
[19:41:20] <strcat> we'll have generators
[19:41:27] <Eridius> for example, a channel is bounded in the number of items it can hold. If you want an unbounded channel, the easiest way is to spin up a goroutine that reads from the bounded channel and stores items in an unbounded goroutine-local slice, which it then writes back out to a destination channel
[19:41:35] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[19:41:39] <Eridius> it's just an example of a way lightweight goroutines are used
[19:41:43] <strcat> or just use a queue in one task
[19:41:48] <Eridius> I'm not saying the exact same example will be used the exact same way in rust
[19:41:59] <strcat> rust supports writing generic data structures
[19:42:09] <strcat> don't need to use an expensive abstraction to hack around language flaws
[19:42:23] <strcat> tasks are not a replacement for iterators/queues
[19:42:45] <bstrie> strcat: you've said that you want a C#-style "yield", but would we also need a python-style "yield from"?
[19:42:48] <strcat> they're sugar for async I/O
[19:43:07] <strcat> bstrie: 'yield from' is just sugar in python for delegating to a generator and handling exception safety correctly
[19:43:14] <strcat> wouldn't be useful in rust
[19:43:42] <strcat> yield from was only added in 3.3 and it's a pretty minor feature
[19:44:22] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[19:44:53] *** Quits: roo (jesse.rudo@moz-DFCBD248.dynamic.ip.windstream.net) (Ping timeout)
[19:44:58] <strcat> anyway, I just feel that rust is trying too hard to fit every use case atm before getting anything solid - and it's not going to be good at anything
[19:45:04] <Eridius> strcat: ok how about this. Let's say I'm writing a game, and there's a couple of thousand independent actors in my game world. One possible way to structure this is to give each actor its own task
[19:45:06] <strcat> definitely not a viable systems language yet
[19:45:26] <strcat> Eridius: they don't need to be concurrent tasks, they aren't going to be blocking on I/O
[19:45:29] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[19:45:43] <strcat> rust supports writing generic abstractions, there's no need to abuse tasks for stuff like you would in Go
[19:46:12] <strcat> there's really just no need to take a 100x performance hit by using tasks instead of generators/iterators
[19:46:27] *** Joins: roo (jesse.rudo@moz-876184F8.ip.windstream.net)
[19:46:31] <strcat> their use case is I/O - not unrelated abstractions
[19:47:05] <cmr> afaik tasks and their design are heavily driven by servo, so it's probably important to look at how it is using them
[19:47:12] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: Computer has gone to sleep.)
[19:47:23] <cmr> or, maybe not driven, but informed
[19:47:33] <Eridius> strcat: tasks are also used for failure control. What if I'm afraid my actors might fail and I want to catch those failures?
[19:47:54] <Eridius> e.g. what if my actors are running code provided by a dynamically-linked plugin? Or I'm writing a library and the actors are provided by the application using my library
[19:47:57] <strcat> Eridius: there are other ways of handling errors
[19:48:03] <strcat> Eridius: well, I don't see how you'll use failure for that
[19:48:10] <strcat> it provides no way to see what error was thrown and why
[19:48:17] <Eridius> strcat: if the mechanism that creates the failure allows for it, sure. but if it fail!()s then no
[19:48:22] *** Quits: mark_edward (quassel@moz-4A5B1251.wisolt4.epbfi.com) (Ping timeout)
[19:48:23] <bstrie> strcat: funny you should mention the link between iterators and coroutines, I was just reading this http://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/ which talks about ruby's iterators-via-fibers
[19:48:26] <strcat> Eridius: it doesn't though
[19:48:28] <Eridius> strcat: well no, but the idea here is to let the actor die without killing the whole world
[19:48:31] <strcat> there's absolutely no way to see why it failed
[19:48:33] <cmr> doomlord: maybe you can provide perspective on ^?
[19:48:38] <Eridius> I don't care _why_ it failed in this instance
[19:48:42] <Eridius> I just care about not killing the whole world
[19:48:57] <strcat> Eridius: so when you get back the Result, don't fail!()
[19:49:26] <Eridius> strcat: who said I have a Result? I don't control the code of the actor
[19:49:32] <strcat> sure you do
[19:49:33] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[19:49:59] <Eridius> strcat: I do? I already posited 2 scenarios where I don't, one where the actor is provided by a dynamically-linked plugin, and the other where I'm a library and the actor is provided by the application
[19:50:15] <strcat> so it's a broken third party plugin
[19:50:15] <cmr> in both cases you define the api
[19:50:19] <doy> Eridius: why are you so interested in structuring things this specific way?
[19:50:23] *** Quits: Sergio965 (textual@moz-BB21156B.dynamic.csail.mit.edu) (Ping timeout)
[19:50:26] *** Joins: roo_ (jesse.rudo@moz-876184F8.ip.windstream.net)
[19:50:33] <Eridius> strcat: ok here's another similar example. I'm running a genetic algorithm contest, and my students are writing the algorithms. I use whatever code they provide, but I need to not have my entire simulation die if one algorithm fails
[19:50:33] <strcat> any library using fail!() for a runtime error is broken
[19:50:44] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[19:50:51] <strcat> Eridius: you wouldn't run it in the same process
[19:50:57] <strcat> their errors can take down the whole process either way....
[19:51:07] <strcat> they can screw up the environment or write random stuff to the address space
[19:51:10] <strcat> tasks != sandboxes
[19:51:20] <Eridius> as long as they're not using unsafe code, and assuming the soundness holes have been patched, then it should be ok
[19:51:31] <strcat> Eridius: still not a sandbox
[19:51:37] *** Quits: roo (jesse.rudo@moz-876184F8.ip.windstream.net) (Ping timeout)
[19:51:37] <strcat> and they can still take down the whole process
[19:51:46] <strcat> a signal. bam.
[19:52:03] <Eridius> strcat: well I'm not worried about malicious actors here, I'm worried about beginner mistakes like v[5] where v.capacity() < 5
[19:52:05] <strcat> raise(SIGKILL)
[19:52:09] <strcat> safe
[19:52:12] <doy> rusti: 1/0
[19:52:13] -rusti- rust: task failed at 'attempted to divide by zero', <anon>:9
[19:52:14] -rusti- rust: domain main @0x21bd1b0 root task failed
[19:52:14] -rusti- application terminated with error code 101
[19:52:21] <cmr> Eridius: what is the argument you are trying to make, anyway? I don't remember
[19:52:29] <strcat> Eridius: so why aren't you worried about signals
[19:52:32] <Eridius> cmr: my argument is that lightweight tasks have a variety of uses
[19:52:36] *** Joins: roo (jesse.rudo@moz-92884EA7.dynamic.ip.windstream.net)
[19:52:57] <Eridius> strcat: because any student that raises a signal is by definition malicious. Again, I'm not worried about malicious actors, just buggy ones
[19:53:02] <strcat> error handling isn't a use case except in a convoluted scenario where you trust code enough not to use unsafe {}, signals, touch the filesystem or environment
[19:53:11] *** Quits: roo_ (jesse.rudo@moz-876184F8.ip.windstream.net) (Ping timeout)
[19:53:12] <strcat> but you don't trust them enough to be correct
[19:53:23] <strcat> or to do error handling a certain way
[19:53:23] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[19:53:47] <strcat> Eridius: so you don't think they can accidentally screw up the fs or environment?
[19:53:47] <Eridius> strcat: ok what if I'm writing the actor code, and I just don't trust all of the actors I wrote, but I need the simulation to keep going? I know damn well I didn't touch the filesystem, etc.
[19:53:51] <strcat> Eridius: anyway
[19:53:54] <strcat> the tasks are lightweight
[19:53:57] <strcat> they can just block you forever and ever
[19:53:58] <Eridius> strcat: how would they accidentally access the filesystem?
[19:54:24] <strcat> if you don't trust all the actors you wrote.... you can't use tasks/threads
[19:54:27] <strcat> they can block you forever
[19:54:35] <strcat> I don't understand how you expect that to work
[19:54:43] <Eridius> strcat: again, I'm worried about bugginess, not maliciousness
[19:54:46] <strcat> loop {} /* your main task is never going to run again */
[19:54:48] <Eridius> you keep talking about malicious actions
[19:54:49] <strcat> Eridius: okay, there ^
[19:54:54] <strcat> Eridius: they accidentally loop forever
[19:54:56] <strcat> not malicious
[19:55:08] <Eridius> strcat: looping forever shouldn't block other tasks from running
[19:55:12] <strcat> Eridius: it does and will
[19:55:15] *** Joins: fabiand (fabiand@moz-35F2392D.pool.mediaways.net)
[19:55:19] <strcat> Eridius: you want lightweight tasks, that's how they work
[19:55:20] <doy> that's what "lightweight" means
[19:55:38] <Eridius> lightweight means cooperative. Loops are typically points where yielding is introduced, no?
[19:55:42] <cmr> no
[19:55:46] <Eridius> in other lightweight systems
[19:55:47] <strcat> Eridius: not going to have yields
[19:55:50] <strcat> would make it incredibly slow
[19:56:00] <Eridius> then any CPU-intensive loop would also block everything
[19:56:03] <strcat> automatic yields also mean you need to be able to mark critical sections that won't yield
[19:56:10] <cmr> Exactly, that's why you need to use enough threads!
[19:56:20] <strcat> otherwise you can't rely on errno being set by a call and then checking errno, or similar patterns
[19:56:30] <cmr> Anyway only channel/other io read/write and explicit yields yield.
[19:56:45] <strcat> Eridius: yep, CPU code -> use threads, not lightweight tasks
[19:56:58] <strcat> disadvantage of threading over lightweight tasks: context-switching overhead
[19:57:00] <Earnestly> Is there a store where one might be able to purchase personal strcats?
[19:57:02] <strcat> no other disadvantage
[19:57:07] *** Quits: yong (chatzilla@74DA0C97.4E87ADC2.263D9828.IP) (Connection reset by peer)
[19:57:24] <Eridius> strcat: if I have 50 CPU-bound tasks, I definitely don't want 50 threads. I want a handful of threads with the CPU tasks multiplexed onto them
[19:57:30] <Eridius> otherwise they're all fighting for the same CPU
[19:57:35] <strcat> Eridius: uh
[19:57:36] *** Joins: usea (rossm@moz-EE3BB1DC.br.br.cox.net)
[19:57:40] <cmr> That's... what threads are?
[19:57:42] <strcat> multiplexing tasks would be 'fighting for the same CPU'
[19:57:48] <strcat> the kernel has a scheduler
[19:57:58] <strcat> it hands out time slices to tasks (threads, processes)
[19:58:07] <strcat> it's faster than anything userland can offer and well designed
[19:58:13] <strcat> you can't beat it.
[19:58:37] <strcat> if you want context switching you want threads or processes
[19:58:44] <strcat> if you want shared address space you want threads
[19:58:46] <hoelzro> ok, I managed to reduce my program to ~200 (that's about 200, not a unique pointer ;) ) lines and put it in a single file: https://gist.github.com/hoelzro/5871030
[19:58:52] <Eridius> if I have a lot of CPU-bound but _short-lived_ tasks, diving back into the kernel to spin up a thread for every task is a complete waste of time
[19:58:57] <hoelzro> if anyone finds the time to look at it, that'd be cool
[19:58:58] <bstrie> strcat: pcwalton has already acknowledged that rust's concurrency capabilities need to include more than just tasks, I highly doubt that tasks-over-threads-by-default is so philosophically entrenched that a cogent argument can't sway them. and it still couldn't hurt
[19:59:04] <hoelzro> line 188 has the odd behavior
[19:59:06] <strcat> Eridius: starting a task isn't going to be much faster than starting a pthread
[19:59:06] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[19:59:15] <strcat> Eridius: spawning a task is at least one syscall
[19:59:18] <strcat> mmap
[19:59:29] <strcat> there are more syscalls actually
[19:59:32] <strcat> but it's at least that
[19:59:42] <strcat> there are a bunch of futex calls and other things
[19:59:48] <strcat> since they're mapping to pthreads
[20:00:01] <strcat> atm spawning a pthread is likely cheaper than spawning a task in rust
[20:00:02] <Eridius> I don't know what futex is, but in theory the scheduler could hold onto previously-used stacks and reuse them for new threads without mmap
[20:00:19] <Earnestly> strcat: Before I get lost, you're assuming a kernel with a good scheduler is present, does this matter or change when doing embedded programming or where you somehow may not have a nice kernel?
[20:00:31] <strcat> Earnestly: so use a proper kernel
[20:00:36] <Earnestly> heh
[20:01:20] <strcat> Earnestly: an embedded device probably isn't going to want 1 million file descriptors open anyway
[20:02:06] <strcat> or even 10k
[20:03:19] <Earnestly> Hm
[20:04:19] <strcat> ok it's a lot more than 1 syscall
[20:05:57] *** Joins: eholk (eholk@2D7AC318.BBEE78B7.ABD5273E.IP)
[20:06:01] <strcat> [pid 20887] open("/dev/urandom", O_RDONLY) = 3
[20:06:03] <strcat> [pid 20887] read(3, "\240\260\347\16#T\241\\\256\1\27\335+\257\214\275Z\234\350\266\267\v_\333^\273Q\264#\0178\237"..., 1024) = 1024
[20:06:06] <strcat> [pid 20887] close(3)                    = 0
[20:06:07] <strcat> every task also has to do that
[20:06:09] <strcat> to seed the TLS RNG
[20:06:15] <Eridius> hoelzro: your ptrace() call has me concerned. On my system, data is an int, not a void*.
[20:06:29] <Eridius> hrm, looks like Ubuntu has it as a void*
[20:06:39] <Eridius> but still, your `options as *libc::c_void` seems odd
[20:07:00] *** Joins: timot (timot@moz-D18FB99F.cust.telenor.se)
[20:07:02] *** Quits: Sindwiller (quassel@moz-743130B2.dynamic.hispeed.ch) (Connection reset by peer)
[20:07:02] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[20:07:31] *** Quits: roo (jesse.rudo@moz-92884EA7.dynamic.ip.windstream.net) (Ping timeout)
[20:07:54] *** Joins: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu)
[20:08:22] <strcat> the number of syscalls we make is really quite terrible
[20:08:48] <strcat> fn main() {}
[20:08:59] <strcat> http://ix.io/6nu
[20:09:28] <strcat> execve("./a.out", ["./a.out"], [/* 78 vars */]) = 0
[20:09:30] <strcat> exit_group(4080)                        = ?
[20:09:32] <strcat> +++ exited with 240 +++
[20:09:34] <strcat> minimal C program
[20:09:42] <MaikKlein> I think we have a nasty &'self mut self but, it never unborrows
[20:09:48] *** Joins: Sindwiller (sindwiller@moz-743130B2.dynamic.hispeed.ch)
[20:09:49] <MaikKlein> bug*
[20:09:50] <strcat> with dynamic linking it's ~12
[20:09:54] <Luqman> erickt: tjc: was there already an issue for not passing self in the environment slot?
[20:10:06] <tjc> Luqman: Not sure, I'll take a quick look
[20:10:12] <strcat> well ~12 per library I guess.
[20:12:15] <cmr> So if you have an immut struct/&-ptr to struct, and it contains a @mut, can you mutate that @mut member?
[20:12:21] <cmr> I suppose I should just tias
[20:12:25] <tjc> Luqman: I can't find one
[20:12:28] <Eridius> cmr: you can mutate the thing contained within the @mut
[20:12:36] <Luqman> tjc: new one it is
[20:12:39] <Eridius> but you can't, say, reassign the member that holds the @mut to point to a different @-box
[20:12:47] <strcat> cmr: you can't change the @mut, you can modify the contents of the @mut
[20:12:55] <Eridius> cmr: so you could say *mutbox += 2; but you can't say mutbox = @3
[20:12:58] <strcat> because it's not Const
[20:13:43] <zargony> browsing the list, I saw that the compiler ignores bounds on trait type params atm. could it be that it also ignores lifetimes? that could explain my problem
[20:14:04] <strcat> zargony: I didn't think it allowed you to put lifetimes
[20:14:13] <strcat> other than 'static?
[20:14:49] <tjc> strcat zargony: https://github.com/mozilla/rust/issues/5121 is still open, so I think that's true
[20:15:30] <zargony> strcat: ah, I see
[20:15:42] <zargony> strcat: i was trying something like: fn create<'a, T> (foo: &'a MyTrait<T>) -> ~MyContainer<'a, T> { ~ MyContainer { foo: foo } }
[20:16:21] <strcat> zargony: oh I thought you meant on the type bound
[20:16:28] <strcat> trait objects don't really work, I recommend not using them ;p
[20:17:13] <strcat> don't need one for that use case anyway
[20:17:13] <zargony> strcat: which gives me "error: cannot infer an appropriate lifetime due to conflicting requirements", however it compiles if the trait has no type param or using a struct instead of a trait (w or w/o type param)
[20:17:21] <strcat> fn create<'a, T, U: MyTrait<T>>(foo: &U) -> ~MyContainer<'a, T>
[20:17:25] <strcat> fn create<'a, T, U: MyTrait<T>>(foo: &'a U) -> ~MyContainer<'a, T>
[20:17:37] <strcat> probably don't want the ~ on the return value though
[20:17:42] <strcat> let the caller make one if they want
[20:17:57] <zargony> strcat: i stepped into the trait object trap a few times already ;)
[20:18:31] <doy> what is a trait object, exactly?
[20:18:37] <zargony> strcat: ah! I see
[20:19:20] <strcat> doy: a ptr to the object and a ptr to a vtable
[20:19:24] <strcat> trait objects are dynamic dispatch
[20:19:30] <cmr> parse/lexer.rs:185:12: 185:23 error: cannot borrow immutable dereference of @ pointer as mutable
[20:19:31] <strcat> if you think you want one... you probably don't
[20:19:32] <cmr> parse/lexer.rs:185             rdr.filemap.next_line(rdr.last_pos);
[20:19:34] <cmr>                                ^~~~~~~~~~~
[20:19:35] *** Joins: reyre_ (reyre@4EA231A1.8829A0B.47C41102.IP)
[20:19:36] <cmr> What does that mean, exactly?
[20:19:40] <cmr> rdr is a &mut
[20:19:50] <cmr> filemap is a @, next_line takes a &mut...
[20:19:51] <strcat> they are occasionally useful but you usually want a type bound
[20:19:59] <cmr> &mut self that is
[20:20:20] <strcat> cmr: @ isn't mutable
[20:20:28] <strcat> @ is always immutable
[20:20:28] <cmr> strcat: at all?
[20:20:31] <strcat> never
[20:20:33] <cmr> Ugh
[20:20:37] <strcat> you can put non-Const things in it
[20:20:55] <strcat> but... it's immutable in the same way as 'let' without mut
[20:21:18] *** Quits: bjz (brendanzab@moz-E17AB2AB.lnse2.cha.bigpond.net.au) (Quit: Leaving...)
[20:21:44] <zargony> doy: if you cast a variable of some object that has a trait to a pointer to that trait, that's called a trait object. the rust tutorial has a chapter about it somewhere near the bottom
[20:21:45] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[20:21:49] <cmr> @/@mut are like a virus, they spread through everything they touch
[20:22:54] *** Quits: sankha93 (Instantbir@30B304BF.8E165DD6.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[20:23:24] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[20:23:38] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[20:23:40] *** Joins: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net)
[20:24:49] *** Joins: roo (jesse.rudo@moz-A8AE35AA.dynamic.ip.windstream.net)
[20:25:14] *** Joins: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[20:26:05] <zargony> strcat: thanks for the hint to avoid the trait objects at all. it happens to me all the time.. i should try thinking less class-based ;)
[20:26:33] <incDec> do we use stdin to read user input?
[20:27:38] *** Quits: roo (jesse.rudo@moz-A8AE35AA.dynamic.ip.windstream.net) (Ping timeout)
[20:28:28] <bstrie> strcat: filed a bug for that syscall issue
[20:28:37] <Luqman> tjc: updated the pull
[20:28:48] <tjc> Luqman: Great, I'll look
[20:29:07] <strcat> bstrie: we also make 1024 close calls to spawn a process ;p
[20:29:14] <strcat> we should be using CLOEXEC
[20:29:42] <incDec> so which function would I use to read user input?
[20:30:35] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[20:30:37] <bstrie> strcat: now I know why people spend decades writing a single compiler
[20:30:44] *** Joins: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr)
[20:31:19] <cmr> rusti: extern mod syntax; std::sys::size_of::<syntax::codemap::FileMap>()
[20:31:19] -rusti- <anon>:9:9: 9:27 error: "extern mod" declarations are not allowed here
[20:31:20] -rusti- <anon>:9          extern mod syntax; std::sys::size_of::<syntax::codemap::FileMap>()
[20:31:20] -rusti-                   ^~~~~~~~~~~~~~~~~~
[20:31:20] -rusti- error: aborting due to previous error
[20:31:20] -rusti- application terminated with error code 101
[20:31:29] <cmr> feh
[20:31:29] <benh> Doesn't CLOEXEC require all user code to be smart enough to use it?
[20:31:44] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[20:32:06] *** Joins: cp (cp@moz-993078EE.plus.com)
[20:32:23] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[20:32:39] <cmr> strcat: 72 bytes
[20:32:51] <cmr> strcat: I think I reject your argument about large structs
[20:33:04] <Eridius> strcat: rust should use posix_spawn if it's available
[20:34:24] *** Quits: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:34:36] <strcat> cmr: rustc being poorly written doesn't really mean anything
[20:35:04] <cmr> strcat: it's not even that poorly written, a filemap is just a handful of pointers and 2 uints
[20:35:12] <strcat> cmr: a handful?
[20:35:17] <cmr> 6 fields
[20:35:30] <strcat> 7
[20:35:37] <strcat> cmr: that's huge
[20:35:44] <cmr> Not really :\
[20:35:48] <strcat> yeah, it's huge
[20:35:51] <strcat> unless there's just one of them
[20:35:58] <strcat> or a handful
[20:36:06] <strcat> and you pass them by-ref deeper into the call stack
[20:36:18] <strcat> which I doubt rustc does
[20:36:45] <carllerche> is rust going to be getting rid of the GC?
[20:36:47] <cmr> The smallest struct I've ever used is 24 bytes and that's for a color
[20:36:59] <cmr> (in non-example/trivial code, that is)
[20:37:01] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[20:37:02] <strcat> cmr: the *smallest*? I really doubt that
[20:37:20] <strcat> why is a color 24 bytes?
[20:37:26] <cmr> erm, derp
[20:37:27] <strcat> 32-bit is 4 bytes
[20:37:33] <cmr> 24 bits, sorry :p
[20:37:37] <strcat> cmr: that's tiny then
[20:37:40] <cmr> it is tiny
[20:37:45] <cmr> also not a struct
[20:38:08] <engla> hehe great story cmr :)
[20:38:15] *** Joins: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:38:35] <Eridius> cmr: why is it not a struct?
[20:38:35] <cmr> the smallest struct I've written (looking through my code dir) is a grid_t for a minesweeper solver and it's 20 bytes (3 u32s and a pointer)
[20:38:43] <strcat> cmr: you definitely usually want to pass ones 4 words or less by value
[20:39:22] <cmr> strcat: I agree with that, I disagree that code doesn't use large structs unless it's poorly written
[20:39:34] <cmr> Which may not even have been a point you were making
[20:39:35] *** Joins: roo (jesse.rudo@moz-8C8D226E.dynamic.ip.windstream.net)
[20:39:36] <strcat> cmr: it shouldn't use them more than rarely
[20:39:43] <strcat> for almost any use case
[20:39:56] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[20:40:13] <strcat> if it's together in a struct it should *always* all be required together, never just parts of it
[20:40:30] <strcat> no point in passing 8 words to a function only using 3 of them
[20:40:31] <cmr> Eridius: well, it could be using bitfields, but that's hardly a struct except by syntax.
[20:40:48] <Eridius> cmr: what's your definition of struct?
[20:40:49] <strcat> object composition > god objects ;p
[20:41:14] <strcat> struct baz { struct foo; struct bar; } // most functions might just want foo or bar alone
[20:41:17] <cmr> Eridius: multiple values tied together into a unit.
[20:41:18] <MaikKlein> does anyone know a workaround for borrowck?  http://www.reddit.com/r/rust/comments/1h4icq/help_me_to_confirm_a_bug_with_self_mut_self/
[20:41:18] *** Quits: reyre_ (reyre@4EA231A1.8829A0B.47C41102.IP) (Broken pipe)
[20:41:28] <Eridius> cmr: and 3 u8's tied together doesn't count?
[20:41:35] <thiez> carllerche: why would we do that?
[20:41:47] <carllerche> there was a blog post a bit back
[20:41:53] <Eridius> MaikKlein: a workaround? you could always use unsafe cast:: functions to muck with lifetimes and mutability
[20:42:00] <cmr> Eridius: I s'pose it does.
[20:42:06] <carllerche> where it seemed like it was up for discussion
[20:42:11] *** Joins: brson (brson@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:42:11] *** ChanServ sets mode: +o brson
[20:42:12] <carllerche> i guess move the GC into userland
[20:42:20] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[20:42:53] <kimundi> carllerche, GC might get moved to the library instead being build in, but it will remain in one way or another
[20:44:16] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[20:44:19] <bblum> omg bors please take my thing
[20:44:42] <strcat> bblum: http://buildbot.rust-lang.org/bors/bors.html which? trait bounds?
[20:44:56] <strcat> heh, 40 pulls
[20:45:09] <kimundi> "bors says no"
[20:45:10] <bblum> strcat: yes, why does it say unreviewed
[20:45:12] <strcat> 40 pulls is too much ;[
[20:45:25] <cmr> bblum: it only updates every 3 minutes and the github api is flakey
[20:45:28] <strcat> bblum: I think the github API is flaky enough that having 40 pulls open means bors takes ages to see them all
[20:45:35] <bblum> i left a r= thingie a long time ago
[20:45:37] <bblum> like yesterday
[20:46:06] <strcat> bblum: is it on the final child commit?
[20:46:20] <strcat> the PR UI orders them by authored date instead of by parent
[20:46:26] <bblum> oh hmm
[20:46:27] <bblum> argh
[20:46:53] <bblum> holy shit that's really irritating
[20:47:18] *** Joins: dherman (dherman@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:47:18] *** ChanServ sets mode: +o dherman
[20:47:29] <bblum> i also think it's pretty absurd that bors will run for 3 hours on my "make ^~~~ print a different colour" singleton commit
[20:47:41] <bblum> i wish there were a flag like
[20:47:55] <bblum> "I'm sure this will pass all tests. Merge it in with a bunch of other commits and test them all at once."
[20:48:13] <strcat> bblum: we should report the github bug
[20:48:19] <bblum> how
[20:48:22] *** Quits: fabiand (fabiand@moz-35F2392D.pool.mediaways.net) (Quit: Verlassend)
[20:48:25] <cmr> support@github.com
[20:48:57] <bstrie> where are all the devs at today
[20:49:01] <strcat> bblum: there's a UI for reporting bugs
[20:49:10] <strcat> bblum: https://github.com/contact
[20:49:14] *** Joins: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP)
[20:49:52] <bstrie> maybe today is a triage day
[20:49:54] <bstrie> for 0.7
[20:50:13] <cmr> there's only ~20 open issues for 0.7...
[20:50:52] *** Quits: Blub\w (wry@moz-8E0843B9.wireless.dyn.drei.com) (Quit: night)
[20:50:56] <thiez> quickly, file some more
[20:50:59] <strcat> pcwalton's stuff needs to land
[20:51:21] <cmr> pcwalton needs to rebase his stuff
[20:51:25] *** Quits: SimonSapin1 (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[20:51:32] <pcwalton> is it reviewed?
[20:51:36] * pcwalton checks
[20:51:51] *** Quits: pyrac (pyrac@moz-9180E00E.w86-201.abo.wanadoo.fr) (Quit: pyrac)
[20:52:21] *** Joins: reyre_ (reyre@moz-9002CDDA.cpe.net.cable.rogers.com)
[20:52:38] <bblum> strcat: ok i left a thing
[20:53:07] <thiez> it occurs to me that running the testsuite could be much faster if there were more machines and we'd split up the tests and divide those between them
[20:53:42] <cmr> pcwalton: I'd r+ https://github.com/mozilla/rust/pull/7145
[20:54:08] *** Quits: alisdair (textual@E1CEBB1A.D061F0C9.AA6AEE7B.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[20:54:24] <cmr> That commit by graydon already landed
[20:54:46] <pcwalton> niko is here so maybe I'll just do an in person review.
[20:54:57] *** Joins: dylukes (dylukes@BABEDB9D.F727F25D.E8393EEB.IP)
[20:57:17] <cmr> pcwalton: you realize you have two pr's open with the same set of commits?
[20:57:22] <pcwalton> hmm
[20:57:25] <pcwalton> let me look.
[20:57:28] <cmr> https://github.com/mozilla/rust/pull/7145 and https://github.com/mozilla/rust/pull/7396
[20:58:33] *** Quits: dylukes (dylukes@BABEDB9D.F727F25D.E8393EEB.IP) (Quit: Computer has gone to sleep.)
[20:59:03] <benh> is rust gonna edge into erlang's niche
[20:59:14] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[20:59:45] *** Joins: azita (Azita@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:00:12] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[21:00:25] <strcat> meh
[21:00:28] *** Joins: dylukes (dylukes@BABEDB9D.F727F25D.E8393EEB.IP)
[21:00:30] <bstrie> benh: I don't think so
[21:00:31] <strcat> why does everyone only ever want to talk about syntax ;p
[21:01:01] <monk> wadler's law?
[21:01:05] <cmr> yup
[21:01:15] <monk> I guess that's not an explanation of why
[21:01:37] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:01:40] <monk> ask whoever coined the term bikeshedding ;)
[21:01:42] <bstrie> strcat: because if we were smart enough to design a nuclear reactor we wouldn't care what color the shed was painted
[21:02:08] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:02:08] *** Quits: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: eatkinson)
[21:02:11] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:02:31] <Eridius> strcat: because syntax is how we express our ideas in the language, which means you can have an emotional connection to the syntax
[21:02:33] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:02:34] <bstrie> I, for one, prefer orange
[21:02:42] <indutny> so....
[21:02:48] <Eridius> syntax affects how you feel when you write or read code
[21:03:18] <Earnestly> "if we were smart enoughâ€¦ we wouldn't careâ€¦"
[21:03:44] <thiez> I for one am not smart enough.
[21:03:45] <cmr> Eridius: I don't think I have ever had an emotional connection to a for loop
[21:03:46] *** Quits: roo (jesse.rudo@moz-8C8D226E.dynamic.ip.windstream.net) (Ping timeout)
[21:03:57] <thiez> cmr: you're missing out
[21:04:09] <Eridius> cmr: you've never felt frustration at awkward for syntax, or felt relief at being able to replace it with something simpler and more elegant?
[21:04:14] <strcat> well I mean I brought up changing the semantics of the for loop and so far every reply has been about changing the syntax (not related to the proposal) :(
[21:04:25] <Eridius> strcat: maybe nobody disagrees with the proposal? :P
[21:04:40] <thiez> compare java before and after they got the for (x: xs) sugar for iterators
[21:04:45] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[21:04:59] <strcat> thiez: or C++11
[21:05:03] <strcat> compared to C++03
[21:05:21] <Eridius> or obj-c with fast enumeration compared to NSEnumerators
[21:05:22] <bblum> brson: the new try_recv() implementation that uses deschedule_running_task_and_then is really nice
[21:05:24] <thiez> I've managed to avoid most of C++, so I cannot comment on that one
[21:05:27] <strcat> for (std::vector<int>::const_iterator it = foo.begin(); it != foo.end(); ++it) { }
[21:05:30] <benh> I get plenty of emotionally negative reactions to certain syntactic choices in programming languages, it's kinda embarassing :(
[21:05:30] <strcat> ->
[21:05:31] <bstrie> strcat: I think you can take this as an implicit approval of the proposal
[21:05:35] <MaikKlein> so the new for loop will look like for vec |x| {}?
[21:05:37] <strcat> for (const &v : foo) { }
[21:05:44] <thiez> strcat: that does look much nicer
[21:05:49] <bstrie> MaikKlein: I think you're missing the point :P
[21:05:53] <pcwalton> nmatsakis: ping
[21:05:53] <Eridius> MaikKlein: it will look like `for vec.iter() |x| {}` until Iterable becomes implementable
[21:06:05] <strcat> well 'for vec.iter |x| {}'
[21:06:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[21:06:07] <Eridius> well yeah
[21:06:12] <benh> strcat: Did C++11 also come witha concise way to iterate over two iterators rather than over a 'container'?
[21:06:21] <benh> What's stopping Iterable from being implementable?
[21:06:26] <MaikKlein> bstrie, possible :D
[21:06:31] <MaikKlein> hm
[21:06:31] <benh> lack of multi-param typeclasses or something?
[21:06:32] <strcat> benh: the new for loop takes a range, not really a container
[21:06:39] <strcat> it works fine with Boost.Range iterators
[21:06:47] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[21:06:47] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 14e65d0cb to 14eb53d6e: 02http://git.io/k471pw
[21:06:47] <ghrust> 13rust/06try 1404f6358 15Brian Anderson: std::rt: Support os::args
[21:06:47] <ghrust> 13rust/06try 14d3bc310 15Brian Anderson: std: Make console log off/on controls work with newsched
[21:06:47] <ghrust> 13rust/06try 144ad8f05 15Brian Anderson: std: Rewrite vec_reserve_shared_actual in Rust
[21:06:49] <Eridius> benh: I think it's something about type bounds not being implemented in a specific place
[21:06:49] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[21:06:51] <strcat> the silly separate start/end iterators suck
[21:07:00] *** Joins: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:07:03] <strcat> benh: we have multi-param typeclasses but they don't work with bounds
[21:07:07] <MaikKlein> so I guess for x in vec is out?
[21:07:08] <benh> ah
[21:07:08] <strcat> implementation flaw
[21:07:13] <benh> how'd I use the new C++11 syntax to iterate over a C array?
[21:07:17] <bstrie> MaikKlein: once again you're missing the point :)
[21:07:18] <benh> or rather a C pointer+length
[21:07:18] <brson> bblum: thanks and thanks for the review. I haven't read yet, but I'll go through them today
[21:07:25] <strcat> benh: for (const &v : c_array) {}
[21:07:28] <MaikKlein> bstrie, ok I now read the proposal 
[21:07:34] <strcat> benh: it uses begin() and end() (free functions) and they work on C arrays
[21:07:34] <Eridius> benh: you don't, since the new C++11 syntax requires the iterable to implement two methods
[21:07:39] <strcat> Eridius: it doesn't
[21:07:43] <Eridius> oh it does? I thought it used the methods
[21:07:45] <Eridius> don't mind me
[21:07:49] <nmatsakis> pcwalton: pong
[21:07:52] <Eridius> I forgot about the free functions
[21:07:53] <bstrie> MaikKlein: we can discuss syntax at a future date. right now we just want to make sure that removing internal iterators from the language is kosher
[21:07:56] <strcat> benh: you wouldn't use a C array in C++11 though.
[21:07:59] <strcat> benh: it has std::array
[21:08:09] <benh> welp, maybe I'm doing C interop.
[21:08:11] <strcat> std::array<T, size> foo {{1, 2, 3, 4, 5}};
[21:08:15] <strcat> benh: well you can pass that to C
[21:08:18] <pcwalton> nmatsakis: r? https://github.com/mozilla/rust/pull/7396
[21:08:21] <strcat> foo.data() is a C array
[21:08:27] <Eridius> benh: if you're accepting a C array, you don't have a real array, you have a pointer
[21:08:27] <benh> ... the other way around :D
[21:08:29] <MaikKlein> bstrie, ah now I understand why you were talking about color :)
[21:08:30] <Eridius> and a pointer doesn't work with end()
[21:08:34] <nmatsakis> pcwalton: k
[21:08:37] <pcwalton> if it's too much work and you have time I can show you in person what it does
[21:08:37] <benh> I remember being surprised that I couldn't even do for (x: std::pair(ptr, ptr+size)) {}
[21:08:38] <strcat> benh: you can write stuff like...
[21:08:50] <strcat> std::map<int, int> {{5, 2}, {3, 2}, {11, -2}};
[21:08:54] <strcat> std::map<int, int> xs {{5, 2}, {3, 2}, {11, -2}};
[21:08:57] <Eridius> benh: how can you iterate over a non-homogenous container like pair?
[21:08:59] <strcat> they made things a lot saner.
[21:09:12] *** Joins: jclements (jclements@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:09:18] <Eridius> benh: for (x: std::pair(3, "test")) // this can't possibly work
[21:09:23] <strcat> benh: there's std::tie for tuple/pair unpacking at least
[21:09:32] <benh> Eridius: The intention was that the pair would hold begin/end iterators, not elements
[21:09:45] <strcat> benh: you don't need begin/end iterators though ;p
[21:09:46] <nmatsakis> pcwalton: ok, that'd prob be good, maybe ~4pm
[21:09:50] <pcwalton> ok
[21:10:04] <benh> strcat: Pretend I got a C pointer and a length from somewhere! :(
[21:10:17] <benh> I don't even remember where I got it from in my example
[21:10:39] <strcat> benh: make it into a real range
[21:11:34] <Eridius> benh: it's easy to construct your own object that can do something like that if you want to
[21:11:44] <strcat> benh: http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities/iterator_range.html
[21:11:58] <benh> So easy that I was surprised it wasn't built into C++ :)
[21:12:03] <bblum> brson: i don't think it would be too hard to implement select(); you would need to use an AtomicOption<~Coroutine> instead of the ~Coroutine
[21:12:06] <Eridius> I constructed a class once that let me produce a counter using the C++11 for syntax, so I could say `for (auto x : enum_from_to(3,17))`
[21:12:14] <strcat> benh: they are probably going to bring boost range into C++
[21:12:31] <strcat> Eridius: http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/ranges/irange.html ;p
[21:12:49] <Eridius> strcat: screw boost
[21:12:52] *** Quits: txdv (quassel@966F3542.3BA477DA.14C26596.IP) (Ping timeout)
[21:12:54] <strcat> why?
[21:12:57] *** Joins: txdv (quassel@966F3542.3BA477DA.14C26596.IP)
[21:13:00] <bstrie> strcat: btw, iterators are the most exciting user-facing feature of 0.7. in terms of keeping morale high for the rest of us, I hereby crown you King Of This Version
[21:13:01] <Eridius> I don't want to pull in another large library
[21:13:05] <strcat> that's likely going to be in the iteration after C++14
[21:13:12] <Eridius> this was just me dicking around with C++11 for syntax anyway. It's not like I actually _used_ it for anything
[21:13:13] <strcat> C++14 will have boost::optional at least
[21:13:20] <strcat> *possibly* boost variant
[21:13:30] <strcat> C++11 standardized like 10 boost libs
[21:13:35] <brson> bblum: we need our 'select' solution to work I/O as well, so we can wait for either pipesy events or I/O events
[21:13:39] <Eridius> strcat: yeah and I'm happy to use whatever gets standardized
[21:13:41] <brson> bblum: https://github.com/mozilla/rust/issues/6842
[21:14:37] *** Quits: jclements (jclements@moz-BE33DA21.fw1.sfo1.mozilla.net) (Ping timeout)
[21:14:41] <bblum> i ese
[21:14:42] <bblum> see
[21:14:50] <strcat> atomic, chrono, move, unordered, type traits, tuple, regex, random, function, thread, forward, ratio - among others ;p
[21:15:03] <brson> bblum: I'm fairly worried about that issue
[21:15:08] <MaikKlein> cmr, how is your rustdoc project going?
[21:15:19] *** Quits: Aetherspawn_BNC (uid6924@moz-A588D045.irccloud.com) (Ping timeout)
[21:15:21] <benh> the c++ standards committee meetings must be sponsored by stroustrup's printer :D
[21:15:25] <bblum> eholk: ping
[21:15:26] <strcat> and if you count boost libraries that became language features.... lambdas, decltype, result_of, static_assert, etc.
[21:15:32] <eholk> bblum: pong
[21:15:42] <bblum> eholk: do you remember why we needed to use rust_task_{de,}ref in old pipes?
[21:15:49] <strcat> oh and bind + enable_if + ref + mem_fn
[21:16:06] <bblum> it was for select right?
[21:16:10] <eholk> bblum: probably
[21:16:11] <bblum> eholk: the new pipes has a different solution for atomic-deschedule than the reject flag and i'm trying to judge if it's necessary
[21:16:17] <benh> brson: Are there other languages implementing a select() that can wait on IO and channels at the same time?
[21:16:37] <eholk> i think the problem was the task with the other end of the pipe held a pointer to the task, so we needed to make sure it didn't go away during that time
[21:16:38] <strcat> well... does C + Linux APIs count?
[21:16:42] <benh> I remember not seeing it in haskell, but I didn't look very far
[21:16:51] <strcat> epoll lets you poll sockets, files, signals, timers, pipes, etc.
[21:17:00] <bblum> eholk: oh right, if a sender on each selected-on chan raced to wake up the selecting task
[21:17:15] <bblum> yeah, AtomicOption will bypass the need for that i think
[21:17:27] <eholk> ahh, cool
[21:17:30] <bblum> i am growing to think AtomicOption is super sexy
[21:17:30] <eholk> what's AtomicOption?
[21:17:37] <strcat> benh: and events
[21:17:43] <strcat> benh: look at timerfd/signalfd/eventfd ;p
[21:18:00] <bblum> eholk: it's as you might expect -- https://github.com/mozilla/rust/blob/master/src/libstd/unstable/atomics.rs#L236
[21:18:03] <brson> bblum: I don't know. i guess you're thinking maybe it's not a real requirement. we can use a unix pipe if you need to interrupt an i/o operation
[21:18:33] <bblum> brson: i... don't follow?
[21:18:44] <bblum> i believe in the need for timeout- or io-select
[21:18:46] <benh> strcat: that's all basically waiting on stuff to happen in the kernel, right? and our channels don't block on syscalls or anything?
[21:19:02] <bblum> it could be approximated by having another task and a pipe
[21:19:09] <bblum> which would be expensive but correct and easy
[21:19:17] <strcat> benh: I guess they don't
[21:19:25] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[21:19:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/2u2kmg
[21:19:25] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[21:19:31] <strcat> but the rust scheduler replaces the OS scheduler
[21:19:34] *** Quits: dylukes (dylukes@BABEDB9D.F727F25D.E8393EEB.IP) (Quit: Computer has gone to sleep.)
[21:19:35] <strcat> it needs to implement the same stuff
[21:20:08] <strcat> libuv probably uses signalfd and timerfd under the hood on linux
[21:20:17] <strcat> hopefully.
[21:20:18] *** Joins: dylukes (dylukes@BABEDB9D.F727F25D.E8393EEB.IP)
[21:20:31] <brson> bblum: yes, I was suggesting the opposite. instead of a pipe use a unix socket to send a message. using a message abstraction built around unix sockets doesn't require another task though. e.g. instead of select(Port, Socket), select(UnixSocketPort, Socket)
[21:20:44] *** Quits: dylukes (dylukes@BABEDB9D.F727F25D.E8393EEB.IP) (Quit: Computer has gone to sleep.)
[21:20:52] <usea> can you supply more than one path to rustc's -L ?
[21:20:56] <strcat> brson: or a unix pipe?
[21:21:05] <brson> strcat: yes
[21:21:12] <brson> maybe that's better than trying to merge the two different concepts - if you really want to wait on both pipes and I/O you have to pay the cost
[21:21:24] <bblum> brson: hmm, won't that incur kernel overhead for even pipe-only select operations?
[21:21:25] <bblum> oh
[21:21:25] <brson> i simple pipe-alike backed by a unix domain socket would be trivial to implement
[21:21:39] <bblum> but there could be a separate, faster pipes-only select
[21:21:42] <brson> yes
[21:21:43] <Luqman> usea: just pass multiple -L flags
[21:21:45] <bblum> sure
[21:21:49] <usea> ok cool
[21:21:52] *** Joins: xazax (xazax@moz-D7592A2A.csoma.elte.hu)
[21:22:25] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[21:22:25] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/Nf9tgg
[21:22:25] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[21:22:29] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[21:22:29] <ghrust> 01[13rust01] 15bors pushed 9 new commits to 06auto: 02http://git.io/4O_n5g
[21:22:29] <ghrust> 13rust/06auto 14fc83d5a 15Ben Blum: Work-around 'static bound requirement in io::with_bytes_reader (note: does not fix #5723, interface still unsafe)
[21:22:29] <ghrust> 13rust/06auto 145b0918d 15Ben Blum: Infer default static/Owned bounds for unbounded heap fns/traits (#7264)
[21:22:29] <ghrust> 13rust/06auto 1414de2ab 15Ben Blum: Looser restrictions on what can be captured in unbounded traits.
[21:22:30] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[21:22:32] <bblum> brson: i am not familiar with selecting on unix sockets, but assuming there's a primitive for that, that's a better solution than the pipe-and-task one
[21:22:36] <bblum> for sure
[21:22:43] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[21:23:00] <strcat> bblum: well we don't actually want to be using actual 'select' on most platforms anyway
[21:23:06] *** Quits: MaikKlein (maik@moz-897EC845.dip0.t-ipconnect.de) (Ping timeout)
[21:23:13] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[21:23:26] <strcat> epoll on linux, kqueue on bsd/osx (libuv deals with it for us)
[21:23:29] *** Quits: heftig (heftig@moz-D222EE86.dip0.t-ipconnect.de) (Ping timeout)
[21:23:57] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[21:23:57] <strcat> and I'm *hoping* their timer/signal handling uses timerfd/signalfd on linux ;p
[21:24:12] <bblum> strcat: i mean select-in-the-abstract
[21:24:15] *** Quits: kimundi (kimundi@moz-CFAE5EB7.dip0.t-ipconnect.de) (Ping timeout)
[21:24:17] <strcat> oh
[21:24:30] *** Quits: cr (anonymous@moz-9D6CBECC.dip0.t-ipconnect.de) (Ping timeout)
[21:24:31] <bblum> doesn't matter what the name is that implements the operation i'm thinking of
[21:24:37] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[21:25:19] *** Quits: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: eatkinson)
[21:25:22] *** Joins: kimundi (kimundi@moz-CFAE5EB7.dip0.t-ipconnect.de)
[21:25:30] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[21:25:40] <strcat> well you definitely can select on a domain socket
[21:25:58] <strcat> bblum: you can pretty much select on any event on a modern OS, they just provide different APIs
[21:26:01] *** Joins: heftig (heftig@moz-D222EE86.dip0.t-ipconnect.de)
[21:26:09] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[21:26:12] <strcat> an mtime change, a write to a file, a rename within a recursive directory tree
[21:26:19] <toddaaro> would a pipe implemented as unix sockets be a preferable swap than IO going into a normal pipe?
[21:26:32] <toddaaro> so you would get a select on "just pipes"
[21:26:43] <toddaaro> using a unix domain socket seems pretty expensive
[21:27:09] <toddaaro> and also doesn't eliminate scheduler-locality issues with the event loop
[21:27:14] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[21:27:46] *** Joins: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net)
[21:27:56] <toddaaro> "scheduler-locality" maybe not the best term, the task would still need to be on a specific scheduler to make use of this "unix socket select"
[21:28:24] <toddaaro> while piping IO into rust pipes and letting a user select on those eliminates that requirement
[21:29:04] <acrichto> brson: what's the best way to clean all the llvm workspaces of all the bots?
[21:29:08] <brson> toddaaro: that's an interesting point. Adapters going both ways seem pretty trivial so we can probably try both
[21:29:14] *** Quits: jyeo (user@F2D29657.F60B0462.67AC9B1.IP) (Input/output error)
[21:29:17] <thiez> I agree that sounds like the cleanest option, especially since the pipe-overhead will be negligible compared to the average IO operation
[21:29:55] <toddaaro> something easy to test would be exciting to have
[21:30:02] <toddaaro> so I second implementing both adapters
[21:30:15] <bblum> i like the idea of thinking of them as adapters
[21:30:21] <bblum> like little wall plugs for when you go to europe
[21:30:25] <bblum> c.c
[21:30:31] *** Quits: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu) (Client exited)
[21:30:47] <bblum> yeah the pipe-task idea is more elegant, and i guess i give slightly better than even odds that it will be faster
[21:30:50] <bblum> depends on the malocs
[21:30:52] <bblum> mallocs
[21:31:03] <thiez> some of us live in europe you insensitive clod :p
[21:31:04] <toddaaro> could we remove the malloc requirement?
[21:31:10] *** Joins: jclements (jclements@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:31:22] *** Joins: eatkinson (eatkinson@moz-BE33DA21.fw1.sfo1.mozilla.net)
[21:31:32] <bblum> thiez: woops, i gotta check my privilege(?)
[21:31:34] <toddaaro> ideally we will eventually have a "reusable buffer" pipe that doesn't reallocate
[21:31:55] <thiez> bblum: eh, when you phrase it like that, no, it's okay :p
[21:32:06] <bblum> toddaaro: umm
[21:32:29] <eholk> toddaaro: do these pipes still have protocols with them? If so, bounded protocols don't allocate
[21:32:49] <toddaaro> eholk: this is something we haven't thought much about, but that is what I was thinking of
[21:32:51] <bblum> eholk: i believe the plan is to put the protocol compiler in libextra or something
[21:33:21] <bblum> toddaaro: find src/run-pass | grep pingpong to find a test case that demonstrates
[21:33:26] *** Joins: cr (anonymous@moz-9D6CBECC.dip0.t-ipconnect.de)
[21:33:35] <toddaaro> bblum: ?
[21:33:42] <bblum> src/test/run-pass
[21:33:53] <bblum> src/test/run-pass/pipe-pingpong-proto.rs
[21:33:57] <bblum> src/test/run-pass/pipe-pingpong-bounded.rs
[21:34:19] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:34:38] <bblum> it would be nice if the protocol compiler could reuse code from newpipes though
[21:34:51] <bblum> because the blocking mechanism is much better
[21:35:02] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:35:13] <bblum> and so you could e.g. select on a newpipe and a protocol-compiled pipe at once
[21:35:13] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Connection reset by peer)
[21:35:17] <eholk> bblum: it doesn't seem like there should be any reason why it can't
[21:35:19] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:35:28] <toddaaro> select on both pipe types currently?
[21:35:31] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[21:35:46] <eholk> no, have the protocol compiler use newpipes
[21:35:58] <bblum> eholk: well, currently newpipes seems to just be a 1shot, and some streams built on top of 1shot
[21:36:14] <bblum> it doesn't have the innermost RecvPacketBuffered layer or whatever
[21:36:25] <eholk> ahh
[21:37:39] <bblum> i don't remember how general select was on oldsched
[21:38:11] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[21:39:19] *** Joins: mark_edward (quassel@moz-4A9A2F15.dynamic.utc.edu)
[21:39:48] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (Input/output error)
[21:41:15] *** Quits: _1126 (1126@moz-83D60E55.lileth.net) (Ping timeout)
[21:43:51] *** Joins: _1126 (1126@moz-83D60E55.lileth.net)
[21:44:43] *** Quits: tjc (tjc@107A98AF.73F86292.93593ABC.IP) (Quit: zzzzzzzzzz)
[21:45:10] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[21:45:23] <cmr> jclements: ping
[21:45:29] <jclements> cmr: pong
[21:46:05] <cmr> jclements: off the top of your head do you know what FileSubstr is actually used for? (Also, what is qquote? it is mentioned only in comments...)
[21:47:11] <seth> can i pattern match against strings?
[21:47:23] <seth> seems like a haskelly thing that probably won't work in rust
[21:48:09] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[21:48:20] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[21:49:14] <jclements> cmr: git log -S suggests that FssInternal--the "weird" FileSubstr--is not really used any more. generally speaking, it used to be necessary to be able to treat parts of old files as being standalone files.
[21:49:18] <strcat> seth: yes
[21:49:24] <jclements> cmr: quasiquoteâ€¦ well, that's a long one.
[21:49:27] <strcat> and vectors
[21:49:29] <seth> strcat: wow, nice!
[21:49:55] <jclements> cmr: the notion of quasiquote comes from lisp and lisp-like languages.  Generally speaking, it refers to the ability to escape from a templating language back into a parent language.
[21:49:55] <thiez> rusti: match "hello" { "hello" => println("Hai"), _ => () };
[21:49:57] -rusti- Hai
[21:49:57] -rusti- ()
[21:50:03] <strcat> rusti: match ("foo", 2) { ("foo", x) => 1, (x, y) => 2 }
[21:50:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/fFjb
[21:50:19] <strcat> rusti: match ("foo", 2) { ("foo", x) => -x, (x, y) => x.len + y }
[21:50:20] -rusti- <anon>:9:56: 9:61 error: attempted to take value of method `len` on type `&'static str` (try writing an anonymous function)
[21:50:20] -rusti- <anon>:9          match ("foo", 2) { ("foo", x) => -x, (x, y) => x.len + y }
[21:50:20] -rusti-                                                                  ^~~~~
[21:50:20] -rusti- error: aborting due to previous error
[21:50:21] -rusti- application terminated with error code 101
[21:50:24] <strcat> rusti: match ("foo", 2) { ("foo", x) => -x, (x, y) => x.len() + y }
[21:50:24] -rusti- 18446744073709551614
[21:50:43] <jclements> cmr: so, in scheme, for instance, `(a b ,c d) would produce a list containing the symbol a, the symbol b, whatever c is bound to, and the symbol d. That is, the term "c" is evaluated. 
[21:50:43] <strcat> silly integer inference
[21:50:53] <jclements> cmr: that's a really brief and unhelpful overview.
[21:51:01] <jclements> cmr: for our purposes...
[21:51:06] <cmr> jclements: where in the code does it live? or is just threaded through everything?
[21:51:24] <jclements> cmr: can you be more specific? where in the code does *what* live?
[21:51:27] <sully> sigh, there are so many outstanding pull requests
[21:51:30] <cmr> jclements: qquote
[21:51:45] <strcat> sully: yeah and they are piling up ;p
[21:51:54] *** Quits: Sindwiller (sindwiller@moz-743130B2.dynamic.hispeed.ch) (Quit: Konversation terminated!)
[21:52:07] <strcat> slow merges -> more conflicts
[21:52:26] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[21:52:26] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fb0f383 to 1423fb227: 02http://git.io/N3iJvQ
[21:52:26] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[21:52:27] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[21:52:27] <ghrust> 01[13rust01] 15bors pushed 15 new commits to 06auto: 02http://git.io/3ax2lw
[21:52:27] <ghrust> 13rust/06auto 14116897f 15Corey Richardson: Remove `ast::pure_fn` and all concept of `pure` from the compiler
[21:52:27] <ghrust> 13rust/06auto 149b2d9a9 15reus: replaced some 'std::' with 'extra::' in comments
[21:52:27] <ghrust> 13rust/06auto 140f55c9c 15Steven Stewart-Gallus: Cleaned up middle a bit....
[21:52:29] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[21:52:44] <jclements> cmr: libsyntax/ext/quote.rs, mostly.  Rust sort of misuses the term quasiquoteâ€¦ or at least, uses it in an unusual way.
[21:53:05] * strcat should merge a bunch into one PR again
[21:53:09] <sully> I'm surprised that it doesn't seem to be catching up overnight
[21:53:13] <cmr> strcat: I was just about to do that
[21:53:24] <cmr> sully: well there's only ~3-4 cycles in a night...
[21:53:26] *** Joins: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net)
[21:53:39] <strcat> sully: in a week we'll have 100 PRs ;p
[21:53:57] <strcat> and then a single big change makes them all stale
[21:53:59] <strcat> fun
[21:54:26] <vk> Hey, I'm attempting to try out this example from the trunk tutorial but it's coming up with an error, here's a gist of the program and error: https://gist.github.com/vkorapaty/5872067
[21:54:46] <cmr> vk: use std::float;
[21:54:51] <cmr> vk: docs need to be updated
[21:55:04] <sully> is there any plan to deal with this problem, or what?
[21:55:13] <cmr> sully: "make rustc faster"
[21:55:15] <vk> cmr: Cool, thanks.
[21:55:27] *** Quits: Kruppe (user@moz-4DDA8AB8.uwaterloo.ca) (Ping timeout)
[21:55:30] <sully> (I feel like this has probably been asked a million times)
[21:55:31] <sully> cmr: uhoh
[21:55:35] <strcat> cmr: not going to happen in time
[21:55:38] <thiez> I think we need a better plan than that
[21:55:46] <sully> that seems like it isn't going to fly
[21:55:49] <cmr> yeah
[21:55:55] <cmr> graydon's idea, not mine :p
[21:56:11] <strcat> he didn't really propose that as a solution to this
[21:56:30] <incDec> I'm trying to read in user input, but the program which I compiled isn't printing out anything. Here's the gist: https://gist.github.com/anonymous/5872095
[21:57:00] *** Quits: vittorioromeo (quassel@moz-15A9910A.retail.telecomitalia.it) (Input/output error)
[21:57:26] <strcat> cmr: he was against splitting out a bunch of crates
[21:57:30] <strcat> would actually make cycle time *slower*
[21:57:48] <cmr> ah
[21:57:55] <strcat> it would make updating one file and testing faster, depending on the file
[21:58:04] <strcat> in some cases it'd be slower, for example changing hashmap
[21:58:07] <strcat> so it's not really a solution
[21:58:16] <pcwalton> we should probably just turn off Valgrind
[21:58:17] *** Joins: Jesse_ (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[21:58:32] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Connection reset by peer)
[21:58:34] <zargony> incDec: use std::io;
[21:58:36] <strcat> pcwalton: valgrind isn't actually the slowest
[21:58:38] <strcat> no-opt is
[21:58:42] <strcat> scary, I know
[21:58:49] <pcwalton> weird
[21:58:49] <incDec> Do we have to use io::stdin() to read in user input?
[21:58:56] <strcat> pcwalton: our no-opt code is huge :(
[21:59:01] * seth finally figures out that you can compare a ~str and a string literal with this: " ".equiv(&my_string)
[21:59:06] *** Joins: tjc (tjc@47E0F4FB.3DA9EE8.BD3C89DC.IP)
[21:59:06] *** ChanServ sets mode: +o tjc
[21:59:10] <seth> but my_string.equiv(" ") doesn't work
[21:59:12] <pcwalton> seth: " " == my_string works too
[21:59:14] <brson> acrichto: I don't remember if I answered you before but we really need graydon. I can manually delete the workspaces on all the bots except the linux bots that aren't running ec2
[21:59:18] <strcat> pcwalton: it didn't even build at first on 32-bit, graydon had to remove #[inline(always)] globally
[21:59:20] <pcwalton> we need to fix this
[21:59:23] <seth> pcwalton: it didn't work for me, that was the first thing i tried
[21:59:23] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[21:59:28] <pcwalton> seth: oh hmm
[21:59:31] <pcwalton> maybe it works in 0.7
[21:59:31] *** Joins: redline6561 (redline656@moz-714529BD.members.linode.com)
[21:59:35] <pcwalton> master, that is
[21:59:38] <seth> yeah, could be
[21:59:43] <pcwalton> splitting out crates would help with memory usage and solve swapping/can't land the GC problems, but so would dumping the AST before codegen
[21:59:46] <strcat> the 2nd argument to equiv is by-ref
[21:59:51] <pcwalton> we can also just turn off unwinding in rustc
[22:00:07] <acrichto> brson: oh ok, we just need to clean at any point now because when they're rebuilt they'll be rebuilt with the correct flags. If we can't get the ec2 ones then it'll just have to wait
[22:00:11] <incDec> Can anyone give me help with reading in user input?
[22:00:12] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[22:00:36] <strcat> pcwalton: we have really strange codegen problems hurting optimization
[22:00:45] <pcwalton> well, maybe we should turn off no-opt or something
[22:00:51] <pcwalton> I mean, if we can't land stuff we can't land stuff
[22:00:53] <seth> strcat: text.equiv(&" ") does not work either. (though it may on 0.7)
[22:00:54] <strcat> we discussed one affecting iterators yesterday
[22:01:00] <strcat> seth: &(" ") ?
[22:01:18] <seth> you need parens?
[22:01:27] <strcat> rusti: (~"foo").equiv(&("foo"))
[22:01:28] -rusti- true
[22:01:30] <brson> acrichto: well, we need to clean, then merge your commit immediately after, I think. otherwise some other commit might just rebuild llvm without multithreading
[22:01:31] <strcat> rusti: (~"foo").equiv(&"foo")
[22:01:32] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cLjY
[22:01:36] <zargony> incDec: your variable n is just a file reader that read from stdin. you need to call some method like read_line() on it to actually read something
[22:01:39] <strcat> seth: yes
[22:01:44] <strcat> seth: it takes the parameter by-reference
[22:01:49] *** Joins: roo (jesse.rudo@moz-CCE5FF00.dynamic.ip.windstream.net)
[22:01:49] <incDec> ok
[22:01:51] <acrichto> brson: the commit with the configure changes is already in the tree
[22:01:53] <strcat> &"foo" is a &str for some reason
[22:01:56] <zargony> incDec: let n = io::stdin().read_line();  // read one line from stdin
[22:01:57] <brson> acrichto: oh
[22:02:01] <strcat> even though "foo" is already a &str
[22:02:06] <strcat> pcwalton: can we fix that ^?
[22:02:12] <brson> acrichto: ok, I'll log into bots and start rm'ing
[22:02:19] <acrichto> brson: ok, thanks!
[22:02:22] <pcwalton> strcat: yeah, that should be fxied.
[22:02:23] <seth> strcat: i see.. that'd explain why it didn't work for me, heh.
[22:02:24] <pcwalton> fixed.
[22:02:39] <brson> acrichto: thank you. sorry this has been a colossal drag
[22:02:50] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Ping timeout)
[22:02:58] <acrichto> brson: oh no problem! I've been hacking away on other stuff in the meantime
[22:03:06] <bblum> brson: join_latch.release_broken doesn't seem to be used for anything?
[22:03:06] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:04:24] <incDec> I tried io::stdin().read_line(), but it isn't printing anything
[22:04:47] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:04:51] <zargony> incDec: mmh, works fine here
[22:05:25] <strcat> cmr: could do https://github.com/mozilla/rust/pull/7404 and https://github.com/mozilla/rust/pull/7384 too
[22:05:46] <cmr> strcat: ok. I didn't because I hadn't looked at them, I'll take your word for it :p
[22:06:00] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:06:13] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[22:06:22] <strcat> going to be a huge pain if someone makes a rollup branch and it fails a test ofc.
[22:06:28] *** Quits: tjc (tjc@47E0F4FB.3DA9EE8.BD3C89DC.IP) (Ping timeout)
[22:06:32] <cmr> Yeah, I'm testing it locally first
[22:07:11] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[22:07:36] <strcat> cmr: and https://github.com/mozilla/rust/pull/7389
[22:07:42] <zargony> if i need to keep a vec/list with objects of different types (structs with same trait), i need to cast them to trait objects.. or is there a workaround to avoid trait objects?
[22:07:59] <Eridius> zargony: how would you possibly avoid trait objects?
[22:08:01] <strcat> zargony: enums
[22:08:16] <Eridius> ok well I suppose you could do that too if you have a bounded set of possible types
[22:08:29] <strcat> you only need a trait object if you don't know the full set of types
[22:08:30] <Eridius> but you need some way of picking the right implementation of the trait method you're going to call
[22:08:59] *** Quits: vk (chatzilla@3E9D68F2.B1163E0C.2A6693DD.IP) (Quit: ChatZilla 0.9.90 [Firefox 23.0a2/20130624004020])
[22:09:45] <zargony> strcat: wrapping elements in an enum type that has a enum value all known structs?
[22:09:55] <strcat> zargony: yes
[22:09:58] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Ping timeout)
[22:10:14] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[22:10:33] <strcat> will be faster most of the time
[22:11:01] <strcat> unboxed tagged union + branch table to statically dispatched methods (you won't kill branch prediction like virtual methods do)
[22:11:42] <sully> hm, who is thestinger on irc?
[22:11:47] <strcat> sully: me ;p
[22:11:50] <sully> ok
[22:11:53] <Eridius> strcat: you should change your gh name
[22:11:55] <cmr> jedestep: ping
[22:11:59] <sully> how important is a prompt fix to https://github.com/mozilla/rust/issues/7341?
[22:12:04] <jedestep> cmr: pong
[22:12:24] <strcat> sully: it's not that important, it's just a performance issue
[22:12:28] <sully> because I have a fix for it
[22:12:29] <cmr> jedestep: your pull request with 35314c93fa07a21aea18548f59886285a303c696 in it had all sorts of trailing whitespace
[22:12:36] <strcat> sully: well I'd be happy if you landed it! ;p
[22:12:38] <cmr> jedestep: run `make tidy` before you submit a PR, mmkay?
[22:12:46] <jedestep> cmr: will do :)
[22:12:47] <sully> but would probably prefer to wait until I have more stuff to push
[22:12:53] <sully> to avoid clogging the queue unduly
[22:12:53] <Eridius> cmr: what, you mean everybody doesn't `make check` before every PR?
[22:13:06] <zargony> strcat: that'd require the enum type to know of any stored struct - but will do as a workaround. i'd rather prefer the container to not be required to explicitly know all stored types
[22:13:20] <Eridius> zargony: if you don't want to know all possible stored types, then you use a trait object
[22:13:23] <Eridius> that's what trait objects are for
[22:13:27] <cmr> Eridius: I know I don't, but I do run make tidy :p
[22:13:27] <strcat> yeah but ~Trait doesn't work
[22:13:46] <Eridius> strcat: no? damn. What if you struct Foo(Trait) and use a ~Foo?
[22:13:56] <strcat> Eridius: trait objects can't be unboxed
[22:14:01] <jedestep> :%s/\s\+$ :P
[22:14:09] <strcat> they're not sized, they can point to different kinds of objects
[22:14:17] <strcat> the ~/&/@ refers to the object
[22:14:20] <Eridius> strcat: hm I kind of assumed a trait object was already a box
[22:14:27] <zargony> Eridius: i would, but my experience is that they don't work so well
[22:14:30] * Eridius hasn't touched trait objects
[22:14:34] <strcat> Eridius: ~Trait is a ~ pointer to an unknown object type and a ptr to a vtable
[22:14:44] <strcat> so you can cast ~T to ~Trait
[22:14:56] <strcat> but the trait object can't be unboxed
[22:15:02] <Eridius> ok
[22:15:56] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[22:15:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1474f54c0 to 1423fb227: 02http://git.io/N3iJvQ
[22:15:57] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[22:15:58] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[22:15:58] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/c0MdYA
[22:15:58] <ghrust> 13rust/06auto 145e26808 15Michael Sullivan: Get rid of terrible way for iterating over provided methods.
[22:15:58] <ghrust> 13rust/06auto 1413e5f0e 15Michael Sullivan: Remove some essentially dead code in method handling.
[22:15:59] <ghrust> 13rust/06auto 143c86711 15Michael Sullivan: Fix some tests in rustpkg to not pollute the build directory. Closes #7278.
[22:16:01] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[22:19:01] *** Joins: MaikKlein (maik@moz-3909D3B2.dip0.t-ipconnect.de)
[22:19:04] <strcat> meh
[22:19:06] *** Quits: roo (jesse.rudo@moz-CCE5FF00.dynamic.ip.windstream.net) (Ping timeout)
[22:19:09] <strcat> the thing I was worried about happening happened ;p
[22:19:11] <strcat> https://github.com/mozilla/rust/pull/7361
[22:19:13] <MaikKlein> is the borrowck already flow sensitive in the newest master?
[22:19:24] <strcat> this is why it's not a real solution to bors being slow
[22:19:40] <bblum> can someone familiar with windows help me with this
[22:19:41] *** Joins: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu)
[22:19:42] <bblum> http://buildbot.rust-lang.org/builders/auto-win-32-opt/builds/105/steps/test/logs/stdio
[22:19:50] <bblum> what did i do wrong; my test has extern mod extra in it just fine
[22:20:03] <strcat> bblum: // xfail-fast it
[22:20:14] <bblum> -_-
[22:20:15] <strcat> bblum: windows doesn't have extra available in the tests
[22:20:19] <bblum> i see
[22:20:34] <strcat> because it does some crazy merging them all to one file to make up for windows being the slowest thing ever
[22:20:39] * strcat shrugs
[22:20:45] <bblum> yes, i recently learned thi
[22:20:46] <bblum> s
[22:20:53] <strcat> bblum: std::foo also won't resolve
[22:20:54] <bblum> i did not realize that meant you couldn't test extra
[22:20:55] <sully> aw, servo dumps core when I run it
[22:20:56] <strcat> it wants ::std::foo
[22:21:00] *** Joins: roo (jesse.rudo@moz-B25D64BE.dynamic.ip.windstream.net)
[22:21:05] <sully> is there a servo channel?
[22:21:08] <bblum> we should have a lint for extra tests without xfail fast or something
[22:21:12] *** Quits: xazax (xazax@moz-D7592A2A.csoma.elte.hu) (Quit: Ex-Chat)
[22:21:24] <cmr> sully: #servo
[22:21:25] <Eridius> what is xfail-fast?
[22:21:27] <strcat> bblum: or just xfail-fast by default and deal with it later ;p
[22:21:31] <strcat> Eridius: makes it not run on windows
[22:21:35] <bblum> strcat: that seems horrible
[22:21:37] <cmr> Eridius: doesn't test it in `make check-fast`
[22:21:40] <Eridius> strcat: hah. why?
[22:21:50] <cmr> Because it merges all the tests into a single file
[22:21:52] <strcat> bblum: sure, but someone who actually *has* windows can test it without slowing down the whole merging process even more
[22:21:56] <cmr> because windows process spawning is balls slow
[22:21:59] <Eridius> :/
[22:22:13] <cmr> Like, seriously, ridiculously slow. It might be mingw though.
[22:22:14] <bblum> strcat: i don't follow why
[22:22:19] <strcat> bblum: I bet it's at least a number like 10-15% that fail because of check-fast
[22:22:43] <Eridius> boy I wish I could run `make check` on more than 1 of my machines
[22:22:51] <bblum> strcat: and a lint pass would catch it just fine
[22:22:57] <strcat> bblum: I guess
[22:22:58] * Eridius hates this libc++abi issue
[22:23:09] <cmr> 208 / 2224, in src/test
[22:23:17] <strcat> bblum: I've run into more quirks because of it
[22:23:29] <strcat> sometimes needing pub main, ::std, etc.
[22:23:58] <strcat> and failure isn't support on windows
[22:24:01] <strcat> supported*
[22:24:33] <strcat> I guess it doesn't do run-fail
[22:25:38] <bblum> not sure whether or not it's rude to be p=10ing this pull request every time
[22:25:46] <bblum> but i've been sitting on it for like a week now
[22:26:13] <cmr> brson: why did you @bors: retry https://github.com/nickdesaulniers/rust/commit/63e976b451be839fe154d44d38edec7acfda58f9#comments ?
[22:27:27] <brson> cmr: i mistakenly thought he was confused
[22:29:03] *** Quits: Sergio965 (sergiobz@moz-8D70E596.wireless.csail.mit.edu) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[22:29:20] <cmr> There, queue down to 29... that's at least a reasonable number.
[22:30:01] <cmr> bblum: didn't realize how much I'd like the proper squiggly colors
[22:30:11] <bblum> cmr: toldja
[22:30:16] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[22:30:38] <strcat> cmr: assuming it lands ;\
[22:30:47] <cmr> strcat: yeah...
[22:30:54] <cmr> strcat: maybe should push it to try first?
[22:30:54] <bblum> who needs coloured output anyway?? just don't write code that fails to compile
[22:31:03] <strcat> cmr: try doesn't work anymore
[22:31:04] *** Joins: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP)
[22:31:08] <strcat> there are no extra mac bots anyway
[22:31:09] <cmr> well that's unfortunate.
[22:31:18] <strcat> auto fills the mac bots
[22:31:37] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[22:32:29] <steven_is_false> I'm heavily refactoring the extra::arc library, and it's dependencies, and I have no idea what a semaphore is.
[22:32:42] <cmr> steven_is_false: http://en.wikipedia.org/wiki/Semaphore_%28programming%29 ?
[22:32:49] <steven_is_false> cmr: Yes.
[22:33:06] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: leaving)
[22:33:25] <cmr> brson: your `incoming` branch failed because of make tidy... c'mon man :(
[22:34:09] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[22:34:18] <zargony> Is the lifetime 'self in some way special to the compiler? It seems to require it being named 'self in some places where I first tried 'a and it didn't work
[22:34:43] <cmr> zargony: unfortunately yes
[22:34:46] <strcat> zargony: it's only special in that the compiler doesn't allow other names as type parameters yet
[22:34:59] <strcat> when other names become allowed, they will work the same as 'self
[22:35:09] <strcat> as in 'a and 'self are no different except for the arbitrary name
[22:35:44] <brson> cmr: i didn't test it
[22:35:48] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[22:35:55] <brson> obviously :-/
[22:36:15] <strcat> at least make tidy is a quick fail ;p
[22:36:16] *** Quits: azita (Azita@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: azita)
[22:36:35] *** Joins: tjc (tjc@moz-522C532A.west.biz.rr.com)
[22:36:35] *** ChanServ sets mode: +o tjc
[22:37:31] <zargony> so there's no difference in how 'a would be handled from 'self - besides that the syntax requires 'self on type parameters?
[22:37:33] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Ping timeout)
[22:37:45] *** Joins: dylukes (dylukes@61BA7E2E.F727F25D.E8393EEB.IP)
[22:39:29] *** Quits: skippydippy (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:40:48] <thiez> how come you all have colours for the squigglies?
[22:41:11] *** Quits: kini (kini@moz-92AA953A.members.linode.com) (Ping timeout)
[22:41:12] <thiez> I think mine are just white
[22:42:02] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[22:42:29] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[22:43:48] *** Quits: pnkfelix|rcirc (pnkfelix@moz-43495417.fbx.proxad.net) (Ping timeout)
[22:44:50] <engla> cmr: i've got a lazy list working now (to some extent) so I can show you what I mean.
[22:45:25] <brson> I'm going to start deleting workspaces on the bots to force them to rebuild llvm. this will certainly cause chaos
[22:45:50] <strcat> brson: seems like it might be better to wait on that
[22:45:56] <strcat> we have nearly 40 pulls ;\
[22:45:58] <strcat> well
[22:46:00] <cmr> r? https://github.com/mozilla/rust/pull/7417
[22:46:09] <bblum> strcat: only 7 in the queue though it seems
[22:46:17] <strcat> bblum: cmr closed a bunch and turned it into one
[22:46:27] <cmr> bblum: I just merged... 12 :p
[22:46:32] <bblum> into one massive one?
[22:46:34] <bblum> i see
[22:46:37] <strcat> but if it fails we're screwed - who's going to fix it? ;\
[22:46:45] <cmr> me!
[22:46:46] <bblum> well, you can bisect it
[22:46:50] <strcat> cmr: ;p
[22:46:52] <cmr> fwiw all tests pass on linux
[22:46:55] <bblum> and search for the broken one(s)
[22:47:04] <bblum> hopefully this will save time
[22:47:11] <bblum> obviously it will waste extra time if all of them are busted
[22:47:12] <strcat> cmr: they were already all reviewed, so r+
[22:47:19] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:47:22] *** Quits: lmandel (lmandel@556E85CD.E855F8D7.412CF160.IP) (Quit: lmandel)
[22:47:28] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Ping timeout)
[22:47:33] *** Quits: MaikKlein (maik@moz-3909D3B2.dip0.t-ipconnect.de) (Ping timeout)
[22:49:08] *** Joins: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net)
[22:49:42] <strcat> consume/consume_reverse conveniently don't actually implement the actual iterator protocol
[22:49:51] * strcat can put replacing those off ;p
[22:49:57] <bblum> strcat: it's a 'do' function
[22:49:57] <engla> cmr: https://gist.github.com/anonymous/420558f20292694ac823
[22:50:08] <strcat> bblum: it could allow breaking though
[22:50:20] <brson> strcat: ok, I'll hold off
[22:51:11] <cmr> engla: ...how well does this perform?
[22:51:19] <cmr> all I can see is indirection :p
[22:51:35] *** Joins: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP)
[22:51:48] <engla> I don't know enough about Rust to know about performance at all. I'm just trying to solve the problem
[22:51:59] <strcat> well ~fn and @fn are virtual function calls as far as the CPU is concerned, so they break branch prediction
[22:52:15] <strcat> among the worst things you can do without a JIT compiler to save you ;p
[22:52:18] *** Quits: Jesin (Jessin_@moz-157A63DD.cc.lehigh.edu) (Broken pipe)
[22:52:19] <engla> I think it should perform better than eagerly generating lots of possible shrink values when all you need is the simplest one
[22:52:29] <engla> in that case, no single thunk needs to be called
[22:52:38] <engla> and most won't be reached/allocated
[22:52:53] <engla> it's a lazy list for a usecase where you often don't need to traverse it all
[22:54:04] <engla> so at least.. it *is* an Iterator, just a specific convenient implementation of one.. for some values of convenient
[22:55:19] <strcat> engla: it's good that Iterator works for things like that too
[22:55:30] <strcat> and generators
[22:56:14] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[22:56:22] <brson> ok, instead i'm going to build auto with clean-llvm=1 and see what happens
[22:57:00] <cmr> engla: it's a fairly impressive construction.
[22:57:05] <engla> yes strcat it's nice that it's not locked-in to by-ref or by-move etc it works with any
[22:57:35] <engla> cmr: it seems that Callable + Thunk thing is what you need to be able to move in data into closures
[22:57:46] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[22:57:46] *** Quits: incDec (Mibbit@moz-5949C51B.dllstx.fios.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:57:47] <engla> since you can't move it in and then mutate
[22:58:09] <engla> I'm surprised the ~Callable<T> object is working. ^^
[22:58:13] <engla> Callable is a trait
[22:58:32] <strcat> sully: you could probably remove the lint warning for default methods, they work better than many parts of the language ;p
[22:58:43] <cmr> heh
[22:58:55] <strcat> and that way we'll actually have people using them and finding new bugs
[22:59:14] <sully> I feel a little bad about doing it because I have known bugs
[22:59:18] <sully> but, yeah, I think I probably will
[22:59:25] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[23:00:43] <steven_is_false> Hoorah! My refactoring of RWARCs has reading working!
[23:01:33] <bblum> refactoring?
[23:02:03] <steven_is_false> bblum: I couldn't understand the code in extra::arc so I tried to clean it up a bit. I got a little bit carried away.
[23:02:12] <bblum> uh
[23:02:25] <bblum> i see
[23:02:39] <bblum> what needed to be changed?
[23:03:19] <steven_is_false> bblum: A lot of the code is old but the main thing I wanted to change was to convert from a closure passing style to a RAII style.
[23:04:01] <steven_is_false> bblum: I'm experimenting to see if if doing something like let read_lock = shared.read_lock(); is better than do shared.read_lock { etc...
[23:04:33] <bblum> hmm, interesting
[23:05:02] <strcat> something interesting you can do with RAII is failures you can't ignore on something like write(), without using TLS for conditions
[23:05:13] <strcat> foo.write("foo");
[23:05:25] <strcat> and it returns Exception, lets say
[23:05:32] <bblum> presumably the read_lock object has a get() method which returns an &'self -> T? 
[23:05:41] <steven_is_false> bblum: Exactly.
[23:05:41] <strcat> kind of weird C++ anti-pattern
[23:05:45] <strcat> but I like it in C++ ;p
[23:05:54] <bblum> uh i mean -> &'self T
[23:05:58] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[23:06:34] <bblum> much like the RWWriteMode and RWReadMode tokens for downgrade
[23:08:15] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[23:08:20] <steven_is_false> bblum: Yes it's a similar idea.
[23:09:30] *** Quits: pnkfelix (pnkfelix@moz-43495417.fbx.proxad.net) (Quit: Leaving.)
[23:09:33] <bblum> it would be cool to have both ways in the interface (and have the closure way implemented in terms of the raii way)
[23:09:52] <steven_is_false> bblum: That's probable the way to go.
[23:10:04] *** Quits: roo (jesse.rudo@moz-B25D64BE.dynamic.ip.windstream.net) (Ping timeout)
[23:10:43] <bblum> i wonder if the borrow-checker roots unnamed intermediates
[23:10:53] *** Joins: roo (jesse.rudo@moz-35BC136.ip.windstream.net)
[23:11:19] <bblum> so you could be like, "let state = arc.write_lock().get(); ... use state ..." and when you drop 'state' it implicitly also drops the lock token
[23:11:36] <bblum> could be very cute, could also result in nasty surprise deadlocks ;)
[23:12:36] <strcat> bblum: http://en.cppreference.com/w/cpp/thread/unique_lock it's an idiom in C++ btw
[23:12:46] <strcat> but yes, it can surprise you :p
[23:13:28] <strcat> we have a lot of anti-patterns like this
[23:13:30] <strcat> vec::reversed(v).map
[23:13:37] <bblum> strcat: i know of it, yeah
[23:13:40] <strcat> reserved and map both allocate a vector (they don't even use reserve)
[23:13:48] <bblum> reason i like the closure method is that it has no surprise factor
[23:14:07] <strcat> uh, what's recursive locking?
[23:14:15] <bblum> locking the same mutex 2x
[23:14:19] <bblum> and having it smart enough to not deadlock
[23:14:22] <strcat> oh
[23:14:36] <strcat> isn't that a pretty huge abuse of the word recursive ;\
[23:14:44] <bblum> yes
[23:14:47] <bblum> 'nested locking'
[23:14:49] <sp3d> more like "reentrant"
[23:15:00] <bblum> reentrant means something different
[23:15:06] <sp3d> yeah
[23:15:12] <sp3d> but it's better than recursive :x
[23:15:35] <sp3d> hm, actually, https://en.wikipedia.org/wiki/Reentrant_mutex
[23:15:53] <bblum> ugh sigh :P
[23:15:57] <bblum> also an abuse of the word reentrant
[23:16:04] <bblum> anyway, so with the RAII approach i do see a possible advantage over the closure approach is if you have 2 RWARCs you can have finer-grained control of when you drop each lock
[23:16:16] <bblum> if you wanna be like, say:
[23:17:11] * strcat wants foo.finalize() instead of ignore(foo)
[23:17:14] <strcat> well, foo.drop() now
[23:17:27] <bblum> let l1 = arc1.write_lock(); let l2 = arc2.write_lock(); let port = l2.get().get_port_from_somehow(); l2.drop();
[23:17:41] <bblum> let value = l1.get().get_value_somehow();
[23:17:56] <steven_is_false> strcat: Yeah, ignore is pretty bad. Just having a function kill(foo), or release(foo) is good enough though.
[23:17:59] <bblum> port.send(value); l2.drop();
[23:18:04] <bblum> (sorry i meant to drop l1 first)
[23:18:10] <strcat> just having Drop take self by-value would be awesome
[23:18:14] <strcat> and making it callable
[23:18:23] <bblum> (so you have lock l1, lock l2, unlock l1, unlock l2, which pattern you can't do with closures)
[23:18:25] <pcwalton> nmatsakis: ping
[23:18:53] <bblum> steven_is_false: make sure you also have a .cond() method on the tokens so you can also wait/signal/etc
[23:19:15] <steven_is_false> bblum: Yes I'm planning on that.
[23:19:18] <bblum> xlnt
[23:21:51] * strcat should make ",".join(iterator) ;p
[23:23:15] <zargony> I can't seem to add trait objects to a vector. What exactly does "Cannot relate bound region as superregion: br_self." mean?
[23:23:54] <bblum> zargony: you using &Trait, @Trait, or ~Trait?
[23:24:21] <zargony> &'self MyTrait<T>
[23:24:48] <strcat> http://ix.io/6nE this function does so many allocs ;\
[23:24:54] <bblum> zargony: high probability that's a bug, since &Trait isn't really used that often
[23:25:07] <bblum> can you paste your code
[23:25:15] <zargony> bblum: seems works if i remove the type parameter though
[23:25:28] <strcat> reversed makes a new vector via Copy'ing each element, map makes a new vector, to_str_radix allocs strings and then strings are alloc'ed from those strings
[23:25:35] <strcat> concat builds up a whole big string
[23:25:40] <strcat> and then it allocs a new one from that.
[23:25:49] * strcat has found a lot of these patterns
[23:26:01] <bblum> zargony: you writing in a generic function?
[23:26:07] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[23:26:15] <bblum> if so what happens if you put a 'static bound on the type parameter introduction
[23:27:05] <bblum> either way i'm just gonna suggest you try using ~Trait if it's not too painful, since they're less buggy :P
[23:27:09] <bblum> nmatsakis: see above
[23:27:13] <zargony> bblum: preparing a stripped down gist
[23:27:20] <steven_is_false> I need to give RAII style alternatives to unkillable, and such. What's a good name for a struct for unkillable?
[23:27:42] <bblum> steven_is_false: i don't think you should need to do that
[23:28:11] <bblum> no closure passed to RWARCs is executed inside an unkillable block
[23:28:16] <zargony> bblum: https://gist.github.com/zargony/1780399775004b28f0b4
[23:28:23] <steven_is_false> Maybe I don't I'll stare at the problem a little longer.
[23:29:16] <bblum> steven_is_false: i expect you'll need unkillable in the constructor and destructor -- consider that running any code inside unkillable() is unsafe so client code of the library should not run in unkillable context
[23:29:53] <steven_is_false> yes.
[23:30:40] <bblum> hmmmm... you'll probably need to extend the sync::rwlock interface to have raii as well
[23:30:45] <strcat> rusti: let mut xs = [1, 2, 3, 4, 5, 6, 7]; std::vec::reverse_part(xs, 2, 4); xs
[23:30:46] -rusti- [1, 2, 4, 3, 5, 6, 7]
[23:30:54] <steven_is_false> yep
[23:31:02] <strcat> rusti: let mut xs = [1, 2, 3, 4, 5, 6, 7]; std::vec::reverse(xs.mut_slice(2, 4)); xs
[23:31:03] -rusti- [1, 2, 4, 3, 5, 6, 7]
[23:31:08] <strcat> so much cruft
[23:31:08] <bblum> zargony: have nmatsakis take a look at that; it's above my head
[23:32:51] <bblum> pretty sure it's a bug though since your code looks fine
[23:32:52] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[23:33:09] *** Joins: int3_ (int3_@43CB6079.66715431.D25A875A.IP)
[23:33:18] <zargony> bblum: strange thing is that it works when removing the type parameter from the trait. i thought i might be doing something wrong since i'm not very familiar with explicit lifetimes
[23:34:48] <bblum> zargony: oh you didn't mention that it printed "internal compiler error" before the cannot relate region error ;)
[23:34:52] <brendanc> hmm. I should fix up the buildbot auto-interrupter to cancel pending builds too. not enough macs to go around.
[23:35:25] <bblum> zargony: ok, https://github.com/mozilla/rust/issues/5708
[23:35:28] <bblum> same bug
[23:35:51] *** Joins: mschifer (Adium@moz-42254FB1.hfc.comcastbusiness.net)
[23:37:49] <zargony> bblum: oh, I didn't notice the ICE message since it showed me the exact position of the problem which is unusual in case of an ICE ;)
[23:38:24] <bblum> yeah usually people write cx.sess.bug("ice message") but sometimes they write cx.sess.span_bug(...)
[23:38:26] * roo thought that language didn't sound like it was meant for the user
[23:38:48] <zargony> bblum: i'll watch #5708, thanks for the pointer
[23:38:52] <bblum> roo: indeed :P
[23:38:53] <brendanc> or hmm, why was auto-mac-64-nopt forced? it seems to be the same revision that failed on the other autos
[23:40:16] *** Quits: eholk (eholk@2D7AC318.BBEE78B7.ABD5273E.IP) (Quit: eholk)
[23:41:31] <steven_is_false> bblum: So yeah, here's the interface I'm experimenting with http://pastebin.mozilla.org/2566238
[23:41:39] <strcat> cmr: want another small commit? ;p
[23:41:44] <cmr> strcat: sure
[23:42:10] <strcat> cmr: https://github.com/thestinger/rust/tree/vec
[23:42:52] *** Quits: roo (jesse.rudo@moz-35BC136.ip.windstream.net) (Ping timeout)
[23:43:14] <bblum> steven_is_false: suggest "lock_read()" and "lock_write()"
[23:43:23] <bblum> a little bit snappier
[23:43:59] <bblum> the write lock could even have downgrade as a method i think
[23:44:53] *** Joins: roo (jesse.rudo@moz-B8C304F9.dynamic.ip.windstream.net)
[23:45:09] <steven_is_false> bblum: I think your overestimating the progress I've made on the refactoring. I'm still debugging hangs, and mysterious weirdness but I'll consider your suggestions later when I'm farther along.
[23:45:34] <bblum> np, design should usually far outpace implementation :P
[23:45:45] <steven_is_false> yeah
[23:48:44] *** Quits: dylukes (dylukes@61BA7E2E.F727F25D.E8393EEB.IP) (Quit: Computer has gone to sleep.)
[23:49:07] <bblum> oh, release_broken is broken, that's why it's called that
[23:49:35] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[23:51:30] <tikue> let mut vec = ~[1, 2, 3]; vec.last_opt()
[23:51:43] <tikue> rusti: let mut vec = ~[1, 2, 3]; vec.last_opt()
[23:51:44] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bjLQ
[23:52:06] <tikue> hmmm, that seems like a problem with rusti, no?
[23:52:11] <bblum> tikue: trolled
[23:52:25] <bblum> rusti: let mut vec = ~[1, 2, 3]; println(fmt!("%?", vec.last_opt()));
[23:52:27] -rusti- <anon>:9:17: 9:20 warning: variable does not need to be mutable [-W unused-mut (default)]
[23:52:27] -rusti- <anon>:9          let mut vec = ~[1, 2, 3]; println(fmt!("%?", vec.last_opt()));
[23:52:28] -rusti-                           ^~~
[23:52:28] -rusti- Some(&3)
[23:52:28] -rusti- ()
[23:52:40] *** Quits: zargony (zargony@moz-81F4F87.versanet.de) (Input/output error)
[23:52:40] <tikue> haha thanks bblum 
[23:53:27] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[23:53:29] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[23:53:32] <bblum> it is a problem with rusti but it seems to be inherently so
[23:53:53] <tikue> bblum: what do you mean?
[23:54:20] <bblum> well, the goal of rusti is to let you write statements as though in block syntax context
[23:54:24] <strcat> it's just a problem with how I have the file set up
[23:54:38] <bblum> strcat: i can't imagine a better way though, because of let
[23:54:40] <strcat> in theory it could parse it and extract the last expression inside println(fmt!())
[23:54:52] <bblum> oh, that would be stupid but it would work
[23:55:05] <bblum> c.c
[23:55:09] *** Joins: dbaupp (Thunderbir@moz-73E90475.lns20.syd6.internode.on.net)
[23:55:19] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[23:55:20] <strcat> http://ix.io/6nG it's just this
[23:55:49] <strcat> the web interface just pipes the input to rustc directly
[23:56:48] <bblum> "let _ = id; // XXX: `id` is only used in debug statements so appears unused" haha, whoops

[00:00:00] <brson> oh nvm just one. killing
[00:00:13] *** Quits: lmandel (lmandel@3E0B9D77.C1F57925.ADB88A9.IP) (Ping timeout)
[00:00:28] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[00:00:41] <brson> "The buildmaster took more than 10 seconds to start" etc
[00:01:13] <brson> oh it started though
[00:01:23] <strcat> ugh this is a really annoying one
[00:01:25] <strcat> 3 nested for
[00:01:31] <tjc> graydon: r? again on https://github.com/mozilla/rust/pull/8176 -- added one more commit
[00:01:44] <brson> looks like the slaves are coming back
[00:01:50] <strcat> 2 returns and a continue ;[
[00:01:51] <brson> thanks brendanc
[00:02:02] <brendanc> np
[00:02:04] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[00:02:05] <brson> I've got it under control graydon! :-D
[00:02:19] <brson> mostly
[00:03:30] <brendanc> vaguely suspect bors is going to hang around forever waiting for auto-win-32-opt to complete though
[00:03:40] <brendanc> might want to rebuild that one
[00:03:56] <graydon> brson: \o/
[00:04:02] *** Quits: mschifer1 (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:04:07] <brson> olsonjeffery: removing that assertion might be enough to make send work
[00:05:03] <brson> and auto-linux-32-nopt never ran. is it expected to?
[00:05:04] <brendanc> also not sure why nothing's scheduled for auto-linux-32-nopt
[00:05:08] <brendanc> heh
[00:05:53] <brendanc> it ran on the previous push
[00:06:10] <brson> uh, the web console doesn't seem to have any options for scheduling builds atm
[00:06:26] <brson> no forms anywhere
[00:06:31] <brson> did something change intentionally?
[00:07:05] <brson> oh I see. I guess I haven't used it since the upgrade
[00:07:14] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[00:07:19] <kimundi> rusti: Some("foo").to_str()
[00:07:19] -rusti- <anon>:5:9: 6:5 error: type `std::option::Option<&'static str>` does not implement any method in scope named `to_str`
[00:07:20] -rusti- <anon>:5          Some("foo").to_str()
[00:07:20] -rusti- <anon>:6     };
[00:07:20] -rusti- error: aborting due to previous error
[00:07:20] -rusti- application terminated with error code 101
[00:07:50] <brson> hm I still can't force builds
[00:07:57] <brson> i'm authenticated as 'rust'
[00:08:18] <tjc> cmr: ping
[00:08:18] <brendanc> me too, I have the 'rebuild' button but not the force build
[00:08:24] <brendanc> possibly change in webstatus
[00:08:26] <cmr> tjc: pong
[00:08:35] <tjc> cmr: I finally built rustpkg and was able to test rustdoc_ng -
[00:08:43] <tjc> is the issue that rustpkg is building tests/test.rs?
[00:08:47] <graydon> brendanc: yeah, 0.8.8 changed web UI some
[00:08:51] <jeaye> I want a thread that hangs out while a queue of functions/closures is updated for it to run. Suggestions for example code? My first guess would be Servo, but something a bit more trimmed would be good.
[00:08:53] <cmr> tjc: yes
[00:09:09] <cmr> tjc: the tests cause an ICE (I don't know why, haven't investigated it yet, been using libstd to test rustdoc_ng)
[00:09:20] <brendanc> different authz keywords?
[00:09:23] <tjc> cmr: Yeah, the current behavior is that rustpkg will try to build any file in a subdir of the workspace you're building that's called main.rs, test.rs, lib.rs, or bench.rs
[00:09:32] <tjc> but maybe I misunderstood and it should only build files at the top level
[00:09:38] <tjc> graydon: ? ^
[00:10:09] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Ping timeout)
[00:10:16] <graydon> tjc: no, that's correct
[00:10:25] *** Quits: eschweic (Adium@moz-BBE3ABD.mv.mozilla.com) (Quit: Leaving.)
[00:10:34] <tjc> cmr: Yeah, soâ€¦ can you call it something other than test.rs? :-D
[00:10:36] <cmr> Ok, I can work around that
[00:10:51] <graydon> rustpkg essentially reserves those 4 filenames
[00:11:07] <cmr> yeah, sure
[00:11:13] <brendanc> forceBuild=True in authz?
[00:11:20] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:11:57] <brendanc> http://buildbot.rust-lang.org/builders has buttons for stop selected/stop all, but not force selected/force all
[00:11:57] <graydon> ='auth', but otherwise yes
[00:12:07] <graydon> yeah, I noticed
[00:12:10] <graydon> even when logged in
[00:12:32] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[00:13:44] <cmr> tjc: Ok, so rustdoc_ng seems to actually be making a rustdoc_ng executable now, which is good
[00:13:48] <cmr> The problem with rust-zmq remains though
[00:14:27] <graydon> aha!
[00:14:32] <graydon> I found the reference on resumption
[00:14:38] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[00:14:57] *** Quits: ozten (ozten@moz-DD3B00B4.hsd1.wa.comcast.net) (Quit: ozten)
[00:17:26] <dbaupp> doener: were you working on this https://github.com/mozilla/rust/issues/8238?
[00:18:50] <tjc> cmr: the link_name thing is the problem with rust-zmq?
[00:18:59] <cmr> tjc: yeah
[00:19:01] <tjc> cmr: also, sent you a tiny PR with the changes I had to make to get it to compile for me: https://github.com/cmr/rustdoc_ng/pull/22
[00:19:11] <tjc> cmr: is there an issue number yet?
[00:19:16] <tjc> (for the link_name, thing, I mean)
[00:19:26] <cmr> https://github.com/mozilla/rust/issues/8239
[00:20:08] <tjc> cmr: ok, I'll take a look this evening
[00:21:09] <dbaupp> tjc: `and` for #[cfg] is just `,`, btw: #[cfg(not(target_os="win32"), not(target_os="macos"))]
[00:21:28] <cmr> fancy
[00:21:31] * cmr didn't know that existed
[00:22:26] <tjc> dbaupp: Ah, ok, I tried && at first and it didn't work, then the next thing I tried did :-)
[00:22:31] <tjc> cmr, feel free to change that while rebasing if you want
[00:22:48] <cmr> tjc: too late, but I'll fix it later
[00:22:55] <tjc> cmr: nbd
[00:26:22] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:27:45] *** Quits: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP) (Quit: Leaving.)
[00:31:32] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[00:31:57] <bjz> tjc: I kind of wish you could use & and | and ! in the cfgs
[00:32:10] <tjc> bjz: it's what I thought at first would work, at least
[00:32:13] <tjc> FWIW
[00:32:25] <cmr> attribute syntax isn't that flexible, I don't think
[00:32:33] <bjz> yeah
[00:32:42] <bjz> wasn't sure about that
[00:33:08] <cmr> it'd be pretty cool if the #[] syntax was reserved for "arbitrary non-closing-bracket stuff in here" attributes and #foo was the current MetaItem attributes
[00:33:16] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[00:34:38] <strcat> dbaupp: 23 for loops left in librustc
[00:34:49] <dbaupp> strcat: \o/
[00:34:49] * strcat sighs
[00:34:54] <strcat> they are really bad ones
[00:35:04] <dbaupp> strcat: I assume that these ones are "impossible" to remove?
[00:35:07] <strcat> no
[00:35:14] <strcat> I'm just converting to 'do'
[00:35:24] <strcat> but they have nested for loops with returns
[00:35:31] <dbaupp> oh, yuck.
[00:35:58] <strcat> dbaupp: https://github.com/thestinger/rust/compare/for so far
[00:35:59] <brson> figuring out how to download buildbot is kind of hard
[00:36:11] <brson> the home page doesn't contain the word 'download'
[00:37:56] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Client exited)
[00:37:57] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[00:37:57] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14caca31a to 143ddc72f: 02http://git.io/N3iJvQ
[00:37:57] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[00:37:59] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[00:38:00] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ii-YPg
[00:38:00] <ghrust> 13rust/06auto 14076468f 15Huon Wilson: std: use ptr.offset where possible in the vec iterator....
[00:38:00] <ghrust> 13rust/06auto 1429000c0 15Huon Wilson: std: add benchmark for vec.mut_iter.
[00:38:00] <ghrust> 13rust/06auto 149bfd7ae 15bors: auto merge of #8225 : huonw/rust/vec-iter, r=graydon...
[00:38:02] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[00:41:23] <brson> toddaaro: can you rebase https://github.com/mozilla/rust/pull/8241 off master? that commit of mine shouldn't be there
[00:41:52] <toddaaro> brson: sure, I'll do that soon
[00:46:24] *** Joins: wphsieh (wphsieh@moz-12D4D3B4.hinet-ip.hinet.net)
[00:49:18] *** Quits: carllerche (carllerche@moz-BF6CB667.hsd1.ca.comcast.net) (Quit: carllerche)
[00:49:20] * kimundi tries to finish his PR - looks into bors queue - decides that he would have to rebase anyway at the time the queue reached his - goes to bed
[00:50:15] <tjc> kimundi: good decision
[00:50:38] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:52:52] *** Quits: hjr3 (hradtke@1A0AE795.28A5F6C3.A2D40ED2.IP) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[00:54:19] <strcat> dbaupp: 15 ;p
[00:57:05] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1-rdmsoft [XULRunner 22.0/20130619132145])
[00:59:44] *** Quits: huseby (huseby@moz-4E8C421A.husebyhome.com) (Quit: Leaving)
[00:59:45] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[01:00:12] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[01:02:37] *** Joins: syatchmenoff (syatchmeno@moz-AB5B740D.hsd1.or.comcast.net)
[01:08:46] *** Quits: bnicholson (bnicholson@moz-835D504A.rcmdva.fios.verizon.net) (Connection reset by peer)
[01:08:47] *** Quits: bytewise (bytewise@moz-4A801D04.unitymediagroup.de) (Quit: Leaving)
[01:10:25] *** Quits: echristo (echristo@DCF57675.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[01:15:43] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[01:15:43] *** ChanServ sets mode: +o pcwalton
[01:20:14] *** Quits: syatchmenoff (syatchmeno@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[01:20:33] *** Joins: syatchmenoff (syatchmeno@moz-AB5B740D.hsd1.or.comcast.net)
[01:25:30] *** Quits: tikue (tkuehn@moz-BBE3ABD.mv.mozilla.com) (Quit: tikue)
[01:25:59] <strcat> very close to removing 'for' ;p
[01:26:08] <goffrie> strcat: nice!
[01:26:35] <strcat> set the lint to deny, and there are 17 left in rustc and none elsewhere (through run-pass, etc.)
[01:27:57] *** Quits: azakai (alon@moz-BBE3ABD.mv.mozilla.com) (Quit: Ex-Chat)
[01:28:04] *** Joins: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com)
[01:29:49] *** Quits: azakai_ (alon@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[01:31:12] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[01:32:59] <brson> pcwalton: can you delete your r+ from toddaaro's pull?
[01:33:01] <brson> it's not ready
[01:33:04] <pcwalton> oops
[01:33:10] <pcwalton> I wondered if I was in the wrong there
[01:33:13] <pcwalton> sorry! will do
[01:33:16] <brson> it has an extra commit for some reason
[01:33:36] <pcwalton> done
[01:33:40] <brson> thanks
[01:34:03] <pcwalton> strcat: \o/
[01:34:25] <strcat> all but those 17 in rustc now...
[01:37:52] *** Joins: lmandel (lmandel@moz-4D911C2E.dsl.bell.ca)
[01:39:45] <brson> seems like libuv has a non-deterministic memory leak on os x that we're going to have to fix before landing
[01:40:46] <pcwalton> ugh
[01:41:26] <brson> it's shown up on the bots a few times in the two test run-pass cases that are testing newrt, but it shows up a lot when i turn it on everywhere
[01:42:04] <sully> ok, figured out the match bug I have been banging my head against!
[01:42:05] <sully> https://github.com/mozilla/rust/issues/6909
[01:42:10] <sully> now I just need to figure out how to fix it....
[01:43:33] <brson> i guess this could be a bug in `start`. i'll try valgrinding on linux too
[01:44:22] <brson> bbl
[01:44:41] <strcat> dbaupp: I think the vec iterator PR is actually broken
[01:44:45] <strcat> because it failed a 2nd time
[01:45:06] <strcat> it's odd
[01:45:10] <strcat> it times out compiling libstd
[01:46:29] *** Quits: lerc (quassel@moz-598ED764.telstraclear.net) (Connection reset by peer)
[01:47:00] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[01:47:00] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ug6kFQ
[01:47:00] <ghrust> 13rust/06auto 14f51795c 15Patrick Walton: librustc: Introduce a new visitor type based on traits and port syntax to it....
[01:47:00] <ghrust> 13rust/06auto 1457ba09e 15Patrick Walton: librustc: Disallow "unsafe" for external functions
[01:47:01] <ghrust> 13rust/06auto 148365992 15bors: auto merge of #8235 : pcwalton/rust/unsafe-extern-fns, r=pcwalton...
[01:47:03] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[01:48:16] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[01:49:56] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[01:51:27] *** Quits: syatchmenoff (syatchmeno@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[01:52:51] *** Joins: MiguelD (MiguelD@2ACDA535.A137FB69.46937063.IP)
[01:53:32] <cmr> Does anyone know what typedefs are represented as in the AST?
[01:56:20] *** Joins: syatchmenoff (syatchmeno@moz-AB5B740D.hsd1.or.comcast.net)
[01:58:50] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[01:59:12] *** Quits: syatchmenoff (syatchmeno@moz-AB5B740D.hsd1.or.comcast.net) (Quit: syatchmenoff)
[02:00:43] <tjc> cmr: definitions of them are item_types, uses are ty_path in ast::Ty
[02:00:53] <tjc> or item_ty
[02:00:54] <tjc> something like that
[02:01:03] <tjc> you'd think I would know since I was looking at that code in the past 5 minutes
[02:01:03] <cmr> rusti: fn foo(x: unsafe &fn()) {}
[02:01:05] -rusti- <anon>:5:26: 5:27 error: expected `fn`, found `&`
[02:01:06] -rusti- <anon>:5          fn foo(x: unsafe &fn()) {}
[02:01:06] -rusti-                                    ^
[02:01:06] -rusti- application terminated with error code 101
[02:01:10] <cmr> rusti: fn foo(x: unsafe fn()) {}
[02:01:11] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bFPN
[02:01:18] <cmr> rusti: fn foo(x: &unsafe fn()) {}
[02:01:20] -rusti- <anon>:5:16: 5:17 warning: unused variable: `x` [-W unused-variable (default)]
[02:01:20] -rusti- <anon>:5          fn foo(x: &unsafe fn()) {}
[02:01:21] -rusti-                          ^
[02:01:21] -rusti- ()
[02:01:24] <cmr> ..huh
[02:01:53] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[02:02:41] *** Quits: lmandel (lmandel@moz-4D911C2E.dsl.bell.ca) (Ping timeout)
[02:02:59] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Quit: pcwalton)
[02:03:07] *** Joins: lmandel (lmandel@moz-4D911C2E.dsl.bell.ca)
[02:03:19] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[02:03:34] <strcat> 13 for loops left >.<
[02:03:43] <cmr> rusti: fn foo(x: &once unsafe fn()) {}
[02:03:43] -rusti- <anon>:5:25: 5:31 error: expected `fn`, found `unsafe`
[02:03:43] -rusti- <anon>:5          fn foo(x: &once unsafe fn()) {}
[02:03:43] -rusti-                                   ^~~~~~
[02:03:43] -rusti- application terminated with error code 101
[02:03:52] <cmr> rusti: fn foo(x: &unsafe once fn()) {}
[02:03:53] -rusti- <anon>:5:16: 5:17 warning: unused variable: `x` [-W unused-variable (default)]
[02:03:53] -rusti- <anon>:5          fn foo(x: &unsafe once fn()) {}
[02:03:53] -rusti-                          ^
[02:03:54] -rusti- ()
[02:03:54] <strcat> last few require ugly spaghetti state
[02:03:59] *** kimundi is now known as zz_kimundi
[02:04:01] <strcat> oh well
[02:04:04] <cmr> This is craziness
[02:04:11] <strcat> or I could write a bunch of iterator implementations
[02:04:13] <strcat> ;p
[02:05:00] <cmr> rusti: fn foo(x: &unsafe once fn:Send+Freeze()) {}
[02:05:01] -rusti- <anon>:5:16: 5:17 warning: unused variable: `x` [-W unused-variable (default)]
[02:05:01] -rusti- <anon>:5          fn foo(x: &unsafe once fn:Send+Freeze()) {}
[02:05:01] -rusti-                          ^
[02:05:01] -rusti- ()
[02:05:16] <cmr> How much features do we squeeze into the poor closure ;(
[02:06:13] *** Joins: aatch (aatch@moz-2BB0AC01.cable.telstraclear.net)
[02:06:17] <engla> hehe
[02:06:38] <aatch> Afternoon comrades
[02:06:52] <engla> cmr: you can still fit two lifetimes in there
[02:07:10] *** Quits: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP) (Quit: Textual IRC Client: www.textualapp.com)
[02:07:22] <cmr> Where???
[02:07:43] <engla> rusti: fn foo<'r>(x: &'r unsafe once fn:Send+Freeze+'static()) {}
[02:07:44] -rusti- <anon>:5:20: 5:21 warning: unused variable: `x` [-W unused-variable (default)]
[02:07:45] -rusti- <anon>:5          fn foo<'r>(x: &'r unsafe once fn:Send+Freeze+'static()) {}
[02:07:45] -rusti-                              ^
[02:07:45] -rusti- ()
[02:08:45] <aatch> Hmm, I wonder if we should alter the terminology here a little.
[02:08:49] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[02:09:39] <aatch> So in `&'foo`, the `'foo` is a region name, and in `Foo<'bar>`, the `'bar` is a lifetime parameter
[02:10:05] <strcat> they're both lifetimes though
[02:10:20] <aatch> strcat, yeah, I just thought of that...
[02:10:28] <shachaf> Are lifetimes and regions not the same thing?
[02:10:33] <cmr> they are the same thing
[02:10:34] <aatch> shachaf, they are.
[02:10:51] <shachaf> Ah. OK, then the documentation isn't *that* outdated. :-)
[02:11:20] * shachaf was reading region_inference/doc.rs earlier
[02:14:43] <cmr> tjc: I see no item_types?
[02:14:53] <tjc> cmr: item_ty (my mistake)
[02:14:57] <cmr> oh ok
[02:15:12] *** Joins: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net)
[02:15:13] *** ChanServ sets mode: +o dherman
[02:19:19] <strcat> these last 7 are really dreadful
[02:20:40] * strcat hopes he hasn't broken anything
[02:25:38] <engla> strcat: backtrace from hanging with dbaupp's vec iterator branch + no opt build. https://gist.github.com/anonymous/fa385a5c90b34d049d28/raw/6c3722c2a25390dbe8d99c2e698f8b7683c7e1fb/gistfile1.txt
[02:26:26] * strcat will look at it in a bit
[02:26:34] *** Joins: vk (chatzilla@F92596F.2DEF7520.EF7679FA.IP)
[02:26:34] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[02:28:41] <strcat> last for loop
[02:29:02] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:29:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148365992 to 143ddc72f: 02http://git.io/N3iJvQ
[02:29:02] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:29:04] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[02:29:04] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/kWKOWg
[02:29:04] <ghrust> 13rust/06auto 14a1bbd18 15Palmer Cox: Sha2: Remove unecessary integer type specifications.
[02:29:04] <ghrust> 13rust/06auto 145b01555 15Palmer Cox: Sha2: Rearrage traits / impls / structs....
[02:29:05] <ghrust> 13rust/06auto 143cac628 15Palmer Cox: Sha2: Remove the result_X() methods; move logic into the Digest impls....
[02:29:07] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[02:29:40] *** Quits: mihneadb (mihneadb@moz-BE33DA21.fw1.sfo1.mozilla.net) (Input/output error)
[02:30:07] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[02:30:50] <engla> wow
[02:30:57] <engla> nice going
[02:31:40] <strcat> lots of ugly workarounds for lacking iterators though
[02:31:42] <strcat> all fixable later
[02:31:55] <strcat> nooo that sha2 one adds more
[02:34:07] *** Joins: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com)
[02:34:27] <strcat> tjc: still around? can you replace the iter().advance in https://github.com/mozilla/rust/pull/8176 with foreach?
[02:34:39] <strcat> there are a few more than what I left comments on
[02:34:54] * strcat thinks it will conflict anyway though
[02:35:06] <tjc> strcat: Sure, 1 sec
[02:36:17] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[02:37:54] <strcat> aatch: https://github.com/mozilla/rust/pull/8244 r?
[02:38:07] <vk> Hey, what's happened to split_char_nonempty()?
[02:38:10] <cmr> dbaupp: The auto-deref stuff with deriving(Clone) is really inconvenient, and I know you can't do anything about it, but I'd just like to register my complaint again ;)
[02:38:36] <tjc> strcat: done
[02:38:37] <dbaupp> vk: split_options_iter
[02:38:46] <dbaupp> cmr: thanks :P
[02:38:47] <vk> dbaupp: thanks
[02:39:00] *** Quits: dherman (dherman@moz-6CA476B1.hsd1.ca.comcast.net) (Quit: dherman)
[02:39:20] <strcat> tjc: there are actually a few more
[02:39:27] <strcat> although I think it's going to conflict regardless
[02:39:38] <strcat> because I replaced every `for` in the codebase with either foreach or do
[02:39:41] <tjc> strcat: did I miss some comments?
[02:39:47] <strcat> tjc: I didn't comment on some :)
[02:40:00] * strcat is serially lazy sometimes
[02:40:17] <aatch> strcat, le done
[02:40:25] <dbaupp> engla, strcat: I think I found the problem
[02:40:28] * dbaupp is embarrassed
[02:40:40] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[02:40:42] <strcat> tjc: anyway I think the for loop removal will land next so you could just rebase on top of that
[02:40:44] <strcat> probably easier
[02:40:56] <dbaupp> https://github.com/mozilla/rust/pull/8225/files#L0R2182 should be self.end
[02:40:57] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[02:40:57] *** ChanServ sets mode: +o pcwalton
[02:40:59] <Mindless`> is there already a method like this (replaces part of a vector) in the standard library? -- http://codepad.org/r6oSE5Ib
[02:40:59] <strcat> s/think/hope/
[02:41:21] <tjc> strcat: sounds good
[02:42:06] <strcat> there were only something like 2300
[02:42:29] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[02:43:18] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[02:43:44] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[02:44:10] <strcat> Mindless`: I don't think we have it atm
[02:44:29] *** Quits: zz_kimundi (kimundi@moz-467E131.dip0.t-ipconnect.de) (Ping timeout)
[02:44:31] * pcwalton envies whoever gets to remove the old for code
[02:44:32] <strcat> it's not safe for T though
[02:44:42] <strcat> pcwalton: I could remove it now ;p
[02:44:50] <pcwalton> go for it!
[02:45:28] <strcat> I could just make `for` parse as `foreach` does
[02:45:40] <pcwalton> that would be great
[02:45:45] <pcwalton> makes sprocketnes able to use the new syntax anyway
[02:45:51] <pcwalton> and that's what really matters
[02:46:11] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[02:46:11] *** ChanServ sets mode: +o brson
[02:46:27] <strcat> rusti: foreach (x, y) in range(0, 10).zip(range(20, 30)) { printfln!("%? %?", x, y) }
[02:46:29] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CPIa
[02:46:36] * strcat is very happy with it :)
[02:46:47] <Mindless`> strcat: oh? I don't know much abut writing unsafe code, so... what did I do wrong?
[02:47:17] <Mindless`> *about
[02:47:33] <pcwalton> strcat: I wonder how well LLVM optimizes that
[02:47:41] *** Joins: zz_kimundi (kimundi@moz-3109E9F9.dip0.t-ipconnect.de)
[02:47:55] <pcwalton> does it optimize into for (i = 0; i < 10; i++) { println(i + " " + (i + 20)) } I wonder
[02:47:59] *** zz_kimundi is now known as kimundi
[02:49:12] <strcat> pcwalton: it unrolls the loop
[02:49:22] <strcat> pcwalton: http://ix.io/71D
[02:49:25] <strcat> at -O
[02:49:40] <pcwalton> haha, ok
[02:49:47] <pcwalton> try to 100 :P
[02:49:49] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[02:50:19] <strcat> pcwalton: http://ix.io/71E
[02:50:22] <pcwalton> I really hate that env pointer
[02:50:30] <pcwalton> if only I had free cycles to fix up nmatsakis' stuff
[02:50:37] <strcat> it's very good at optimizing them
[02:50:49] <strcat> the only issue is the ptrtoint/inttoptr stuff in the current vec iterator, about to be fixed
[02:50:56] <strcat> then it's able to turn them into memcpy/memset and vectorize
[02:50:58] <strcat> (atm it can't)
[02:52:32] <pcwalton> ok, it turned it into for (i = 0, j = 20; i < 100; i++, j++)
[02:52:34] <pcwalton> that's reasonable
[02:52:46] <vk> I'm getting this error, "error: `self` is not allowed in this context", in the following context:
[02:52:48] <vk> impl Context {
[02:52:49] <vk>   fn compile_reader(rdr: Reader) -> Template {
[02:52:51] <vk>     ...
[02:52:52] <vk>     template_path: self.template_path,
[02:52:54] <vk>     template_extension: self.template_extension
[02:52:55] <vk>  };
[02:52:57] <vk>   Template {
[02:52:58] <vk>     ctx: self,
[02:53:00] <vk>     ...
[02:53:01] <vk>   }
[02:53:03] <vk> }
[02:53:04] <vk> What's that about?
[02:53:07] <pcwalton> vk: fn compile_reader(&self, rdr: Reader) -> ...
[02:53:09] <cmr> vk: self isn't implicit
[02:53:27] <vk> ah, thanks
[02:53:53] <dbaupp> strcat: I think https://github.com/mozilla/rust/pull/8225 is fixed now (just running tests here.)
[02:54:10] <strcat> dbaupp: what was wrong?
[02:54:30] <dbaupp> strcat: using self.ptr rather than self.end in the d-e implementation
[02:54:43] <strcat> isn't it still wrong?
[02:54:45] * dbaupp clearly forgot to run tests after change that
[02:54:48] <strcat> oh nvm
[02:54:55] <dbaupp> *changing
[02:54:58] * strcat read the condition backwards
[02:55:29] <strcat> I'm surprised something actually uses the double-ended iterator beyond the tests, I didn't add it that long ago
[02:55:45] <strcat> oh, because the reverse iterators are really the double-ended one
[02:55:47] <strcat> that's why
[02:56:13] <engla> yup it failed in the first str::rfind in the program
[02:56:24] <engla> "failed"
[02:56:59] <rbancroft> did anything change in 0.7 with #[link_name]? my library isn't showing up on the 'cc arguments' list
[02:57:03] <ChrisMorgan> Is there an operation for +=, as distinct from +?
[02:57:09] <dbaupp> ChrisMorgan: not yet
[02:57:23] <strcat> ChrisMorgan: atm it only works on built-ins
[02:57:39] <dbaupp> ChrisMorgan: https://github.com/mozilla/rust/issues/5992
[02:58:00] <strcat> pcwalton: it's kind of odd, but as soon as you convert pointers to/from integers it's 100% opaque to LLVM
[02:58:14] <strcat> as opaque as an external function call to something non-readonly/readnone
[02:58:37] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[02:58:38] <strcat> apparently they just haven't extended any analysis to it because it's supposed to be incredibly rare
[02:58:52] <strcat> (there *are* aliasing rules for it, just unused ones)
[02:58:53] <ChrisMorgan> strcat: you mean +=, I presume? So x += y doesn't even desugar to x = x + y?
[02:59:03] <rbancroft> hmm, looks like #[link_args] is now required? not link_name? but the docs still seem to say that #[link_name] is correct
[02:59:10] <strcat> ChrisMorgan: += will only work on built-in types, yeah
[02:59:20] <strcat> there will be another trait for it
[02:59:28] <strcat> it can't efficiently be implemented in terms of Add for complex types
[02:59:31] <cmr> rbancroft: the docs frequently lie
[02:59:44] <strcat> #[link_name] changes the symbol name
[02:59:52] <strcat> it's not used for linking to libraries anymore
[03:00:02] <strcat> I think the FFI tutorial needs an update
[03:00:40] <rbancroft> I see...
[03:00:47] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[03:00:51] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[03:00:56] <rbancroft> ok, well thanks :) yes that fixes my issue
[03:01:37] <strcat> pcwalton: well, checking to see if this little change works... then I can actually remove the for code
[03:01:52] <strcat> pcwalton: http://ix.io/71H/diff afaict it's that simple.
[03:01:55] <strcat> replacing it
[03:02:04] <pcwalton> cool :)
[03:04:24] <vk> I'm getting "error: unresolved name ..." with functions from std::str. I've got a "use std::str::*;" statement in the file, so why would this error be coming up?
[03:04:29] <dbaupp> ChrisMorgan: it used to desugar to that, but it was doing it wrong (e.g. it evaluated x twice-ish) so it was removed.
[03:04:37] <dbaupp> vk: which functions?
[03:04:49] <cmr> vk: you usually shouldn't need the functions, most things have been moved to methods
[03:04:53] <vk> find_from, push_char, each_char, split_options_iter
[03:04:59] <vk> and a few others
[03:05:15] <vk> Ah, that's probably it then.
[03:05:33] <strcat> and almost all the 'each' functions are gone
[03:05:39] <dbaupp> yeah, all methods (although find_from will now be .slice_from(x).find())
[03:06:24] <strcat> aatch: sadly going to break from 4 loops in the sha2 PR
[03:06:31] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[03:06:33] <strcat> I'll just fix it in the 3 min gap ;p
[03:06:45] <aatch> strcat, heh
[03:07:02] <dbaupp> strcat: are you going to turn the lint to warn/error too?
[03:07:19] <strcat> dbaupp: I did, I'm actually about to flip on parsing for as 'for pattern in iterator {}'
[03:07:26] <dbaupp> strcat: oh, that works too
[03:07:27] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:07:32] <strcat> removing the dead code can be another PR
[03:07:44] * dbaupp thinks dealing with all the complains about syntax changes will be fun
[03:07:58] <dbaupp> (well, confusion, not complaints.)
[03:08:20] <cmr> Yeah... everything previously written is going to be out of date :(
[03:08:21] *** Quits: tjc (tjc@moz-BBE3ABD.mv.mozilla.com) (Quit: Places to go, people to annoy)
[03:08:25] <strcat> might be less than you think, because there aren't really any internal iterators left in libstd/libextra
[03:08:26] <dbaupp> strcat: maybe you could add a "migration guide" to https://github.com/mozilla/rust/wiki/Doc-under-construction-FAQ for for -> do/foreach?
[03:08:31] *** Quits: wphsieh (wphsieh@moz-12D4D3B4.hinet-ip.hinet.net) (Client exited)
[03:08:31] <pcwalton> ugh, 3rd bounce for unsafe
[03:08:41] <strcat> dbaupp: yeah, I will
[03:08:48] <strcat> it's mostly from advance -> foreach though
[03:08:55] <strcat> well, for soon
[03:09:36] <strcat> the cmp.rs tests don't actually run
[03:09:41] <strcat> I broke parsing them
[03:10:45] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[03:12:12] <strcat> http://static.rust-lang.org/doc/tutorial-container.html#iterators s3 finally updated
[03:12:54] <cmr> rustdoc_ng should be in fairly good shape by sunday
[03:13:50] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[03:13:55] <strcat> anyway `for` will be gone by the end of tommorow :]
[03:14:03] <strcat> or rather, foreach will be gone
[03:15:06] <dbaupp> \o/
[03:15:11] * dbaupp hugs strcat
[03:16:30] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[03:19:40] *** Joins: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu)
[03:19:46] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Client exited)
[03:20:01] <strcat> fn main() {
[03:20:03] <strcat>     for x in range(0, 10) {
[03:20:05] <strcat>         printfln!("%d", x)
[03:20:07] <strcat>     }
[03:20:09] <strcat> }
[03:20:11] <strcat> that now compiles.
[03:20:20] <cmr> We're basically python :p
[03:20:53] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[03:20:54] <strcat> dbaupp: https://github.com/mozilla/rust/pull/8244 r? just the 2nd commit
[03:21:14] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[03:21:32] <dbaupp> strcat: nope, r-, you're deleting all my hard work with than lint :P
[03:21:36] <strcat> ;p
[03:21:53] <strcat> the lint was what allowed me to remove them all if that makes you feel better :)
[03:22:10] <strcat> "for" is way too hard to grep for
[03:22:29] <dbaupp> yeah, I assumed that would be its use.
[03:23:00] <dbaupp> (coo, my vec iterator patch passes properly now.)
[03:23:02] <dbaupp> *cool
[03:23:25] <strcat> that and sed ;p
[03:23:44] <strcat> I think I still did like 300 by hand...
[03:24:01] <cmr> https://gist.github.com/cmr/e59e9b65d0281ac95076
[03:24:07] <cmr> clean.rs:568:16: 568:17 error: expected `;` or `}` after expression but found `{`
[03:24:09] <cmr> clean.rs:568         Typedef {
[03:24:11] <cmr>                              ^
[03:24:13] <cmr> What am I missing here
[03:24:15] <cmr> It's something obvious
[03:24:17] <cmr> oops field names
[03:24:19] <cmr> I need sleep :(
[03:24:34] <cmr> Weird spot for the parse to fail though
[03:25:12] *** Quits: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[03:25:36] <dbaupp> strcat: we should just have `strcat x in foo.iter() { ... }`, as a tribute
[03:25:39] <pcwalton> acrichto: why is the format string verified at compile time but parsed at runtime?
[03:25:43] <pcwalton> I'm confused
[03:25:48] <pcwalton> i18n or something?
[03:28:01] <acrichto> pcwalton: not really any particular reason right now, it was the easiest thing to do first
[03:28:05] <pcwalton> ok
[03:28:09] <aatch> rusti: std::u8::from_str("123")
[03:28:12] <acrichto> I wanted to reduce the amount of code generated at the callsite
[03:28:13] -rusti- Some(123)
[03:28:20] <acrichto> test fmt ... bench: 384 ns/iter (+/- 14)
[03:28:21] <acrichto> test ifmt ... bench: 1093 ns/iter (+/- 3)
[03:28:22] <pcwalton> I think we will want it to be parsed at compile time
[03:28:25] <acrichto> pcwalton: ^ not looking good though
[03:28:31] <pcwalton> yeah
[03:28:37] <pcwalton> for performance reasons
[03:28:42] <cmr> is ifmt the new one?
[03:28:46] <acrichto> cmr: yeah
[03:28:58] <strcat> the old one is already very slow :(
[03:29:07] <acrichto> yeah I'm actually kinda surprised it's so slow
[03:29:09] <pcwalton> if you're always formatting into a string *and* parsing at runtime that's a pure regression
[03:29:14] <pcwalton> I'm not surprised
[03:29:37] <pcwalton> I'm more concerned about the lack of io::Writer support
[03:29:48] <pcwalton> that to me is the most important thing
[03:29:49] <acrichto> yeah I'll try to drill down exactly on why that wasn't working
[03:29:54] <pcwalton> being able to format directly into an io::Writer
[03:29:57] <acrichto> it's built such that it should be really easy to implement
[03:29:57] <sp3d> acrichto: I haven't looked into it so sorry to waste time, but does new formatting do a separate count-size pass, allocate, and then fill in the string, or does it just increase buffer size exponentially or whatnot as it writes?
[03:30:00] <pcwalton> always allocating is a killer
[03:30:04] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:30:04] *** ChanServ sets mode: +o brson
[03:30:07] *** Quits: eatkinson (eatkinson@moz-BBE3ABD.mv.mozilla.com) (Quit: eatkinson)
[03:30:18] <pcwalton> acrichto: was it segfaulting?
[03:30:22] <acrichto> sp3d: right now it just calls push_str which I think doubles the size hitting the limit
[03:30:35] <sp3d> is the former approach planned/feasible in the long term?
[03:30:37] <acrichto> pcwalton: no I think it was compile errors, but I haven't tried in awhile
[03:30:39] <pcwalton> ok
[03:30:50] <strcat> it should use a Writer and we can add a way to pass a hint to the Writer
[03:31:06] <strcat> I was thinking about how to do that
[03:31:19] <acrichto> sp3d: that could work yeah, it could at least pre-allocate all space for each string literal portion
[03:31:24] <pcwalton> so I'm ok with this for now
[03:31:28] <pcwalton> with comments addressed
[03:31:35] <acrichto> pcwalton: thanks for looking at it!
[03:31:41] <pcwalton> but we need to get the allocation and parsing issues fixed
[03:31:52] <pcwalton> people use fmt! all the time in benchmarks
[03:31:54] <strcat> tests passed with `for` replaced :)
[03:31:59] <pcwalton> e.g. chris leary's benchmark where we were 1000x slower than python
[03:32:01] * cmr *cough*
[03:32:03] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[03:32:07] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[03:32:07] *** ChanServ sets mode: +o brson
[03:32:13] <acrichto> pcwalton: yeah that's one of the things I really wanted to take care of
[03:32:15] <sp3d> acrichto: yeah, I don't know if it would be bad for perf to have to e.g. figure out how many decimal digits some float will take and then later format it again from the start, vs. allocating as you go
[03:32:19] <pcwalton> and we *should* be the fastest language around for this
[03:32:22] <pcwalton> much faster than Go
[03:32:30] <sp3d> but it seems like at least the two approaches should be compared
[03:32:44] <strcat> pcwalton: D can compete with us there too
[03:32:48] <strcat> static regexp, etc.
[03:32:58] <pcwalton> sure
[03:33:01] <acrichto> sp3d: yeah I agree
[03:33:20] <strcat> C++ doesn't allow variadic templates for user-defined string literals so it can't ;p
[03:33:24] <engla> people shouldn't use IO in benchmarks..
[03:33:43] <strcat> but in theory.... "%s %s"_fmt("foo", "bar") can almost work in C++
[03:33:48] <pcwalton> engla: they also shouldn't make benchmarks gated on rand() ;)
[03:33:55] * cmr *cough*
[03:33:59] <pcwalton> but there was one just the other day that made the front page of hacker news
[03:34:00] <engla> haha
[03:34:01] <dbaupp> acrichto: can we have it so that runtime parsing only happens in cases where it's required? (i.e. only for internationalised strings)
[03:34:03] * cmr shuffles awkwardly
[03:34:07] <dbaupp> pcwalton: it was fixed
[03:34:14] <dbaupp> (to the credit of the author)
[03:34:15] <pcwalton> dbaupp: the damage was done though
[03:34:22] <acrichto> dbaupp: yeah that's what I wanna try to do
[03:34:25] <pcwalton> the first rule of benchmarks is that everyone makes stupid ones, so your defaults should be fast so you don't get embarrassed
[03:35:05] <sp3d> "a lesson is learned but the damage is irreversible"
[03:35:10] <pcwalton> Go to its credit is pretty fast at most stupid benchmarks across the board, we are not because of fmt! and stack growth
[03:35:15] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[03:35:26] <cmr> At the smart benchmarks we do pretty good though
[03:35:28] <pcwalton> the exception being re2, Go's dependency on re2 is a killer for stupid benchmarks
[03:35:51] <pcwalton> also the io::Reader/Writer interfaces are not good
[03:35:54] <pcwalton> in Rust
[03:35:57] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[03:35:59] <strcat> pcwalton: well they have a rewrite of re2 in Go
[03:36:03] <cmr> The stuff in std::rt::io is nice
[03:36:04] <acrichto> pcwalton: oh btw 'ct' == 'compiletime', but you're definitely right that parsing at runtime is going to make this a lot better because right now a profile is showing almost all parsing
[03:36:06] <strcat> and it's slower than actual re2
[03:36:29] <pcwalton> strcat: that's even worse ;P
[03:36:36] <pcwalton> re2 is the kind of thing you really need an optimizing compiler for
[03:36:48] <pcwalton> but I think re2's algorithm is just plain flawed
[03:37:07] <pcwalton> it's better in theory sure but in practice it's only pathological regexes where recursive backtracking hurts
[03:37:24] <pcwalton> in practice the simplicity of recursive backtracking beats everything else
[03:37:34] <dbaupp> acrichto: (also... is there a way to avoid the unsafe pointer stuff?)
[03:38:05] <acrichto> dbaupp: not that I know of right now
[03:38:15] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[03:38:23] <cmr> I'm not really familiar with regexps but surely there is a way to analyze a regexp to see which algorithm is going to be more suited?
[03:38:25] <dbaupp> pcwalton: I guess it depends what you're doing with the regexes: if you're taking external ones, then avoiding exponential behaviour is very nice.
[03:38:35] <pcwalton> cmr: yup, you could do that, I think there are some engines that do
[03:38:42] <pcwalton> problem is, re2 isn't one of those engines ;)
[03:38:50] <strcat> http://codesearch.debian.net/ like that
[03:38:52] <pcwalton> dbaupp: yeah, but I think that's a very specialized use case
[03:39:03] <pcwalton> in that case I agree re2 is appropriate
[03:39:06] <pcwalton> but for e.g. routes
[03:39:09] <pcwalton> re2 is totally wrong IMO
[03:39:11] <dbaupp> pcwalton: true
[03:39:15] <pcwalton> for routes you really want *compile time* regexes
[03:39:21] <pcwalton> using recursive backtracking
[03:39:34] <dbaupp> (was it ssbr who was working on regexes for Rust, ages ago?)
[03:39:39] <strcat> pcwalton: you could probably spend the time analyzing them to figure out if they're possibly pathological ones that way
[03:39:43] <ssbr> dbaupp: yes
[03:39:53] <pcwalton> strcat: yeah, I would like re2 much better if it did that
[03:40:06] <pcwalton> also the state of the art with runtime regexes is JITting them
[03:40:07] <ssbr> pcwalton: re2 does some analysis, but not much
[03:40:10] <pcwalton> which re2 does not do
[03:40:15] <strcat> yeah and pcre does
[03:40:16] <pcwalton> even PCRE does now
[03:40:27] <strcat> + it has a way to ask it to optimize more than usual
[03:40:28] <cmr> ssbr: do you still plan on working on it?
[03:40:36] <ssbr> it checks if it can do "backtracking search" without actually keeping a stack of places to go back to
[03:41:03] <strcat> dbaupp: I bet it'll break on a windows specific code path
[03:41:14] <ssbr> cmr: it still interests me! but not intensely enough to break out of inertia of not working on it, apparently
[03:41:15] <cmr> strcat: run it in wine!
[03:41:18] <ssbr> maybe tomorrow. :/
[03:41:28] <cmr> ssbr: we can beat you with sticks if that will help ;p
[03:41:31] <ssbr> (I took a break to find a job. bad move, apparently.)
[03:41:38] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[03:41:39] <ghrust> 01[13rust01] 15thestinger pushed 2 new commits to 06try: 02http://git.io/PwO__Q
[03:41:39] <ghrust> 13rust/06try 140afc570 15Daniel Micay: replace all remaining `for` with `foreach` or `do`
[03:41:39] <ghrust> 13rust/06try 14551d35d 15Daniel Micay: make `for` parse as `foreach` does
[03:41:39] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[03:42:11] <pcwalton> at the limit I think Go is going to be pretty fast though, since they generally just write problematic routines in asm instead of making their compiler actually optimize :D
[03:42:24] <cmr> heh
[03:42:40] <cmr> Why did they chose to not use LLVM?
[03:42:41] <ssbr> cmr: Well, it's good to know people still care
[03:42:54] <pcwalton> cmr: compile time performance
[03:42:58] <pcwalton> probably some measure of NIH
[03:43:01] <cmr> Oh right
[03:43:06] <strcat> Go can do well on benchmarks because they don't require abstractions or much memory allocation
[03:43:06] <cmr> Go was designed to be compiled fast
[03:43:17] <strcat> benchmark their stdlib sort though
[03:43:31] <pcwalton> strcat: they don't devirtualize the Sort interface at all, do they
[03:43:36] <strcat> pcwalton: nope
[03:43:43] <strcat> gccgo can't either
[03:43:43] <pcwalton> yeah, I always thought that was questionable
[03:44:05] <strcat> they use a lot of reflection too, not just vtables
[03:44:09] <pcwalton> yeah, I know
[03:44:21] <pcwalton> I was aghast at how much typecasting is in their stdlib with interfaces
[03:44:28] <pcwalton> just checking whether interfaces implement random methods
[03:45:01] <strcat> meh auto finished anyway
[03:45:16] <pcwalton> strcat: how good is their JSON deserialization performance?
[03:45:23] <pcwalton> I figured it must be miserable
[03:45:28] <strcat> pcwalton: they don't build trees though
[03:45:28] <pcwalton> because it's all reflection based
[03:45:38] <strcat> they write stuff out into a struct
[03:45:40] <pcwalton> deserialization I mean
[03:45:48] <pcwalton> JSON -> native objects
[03:46:00] <strcat> pcwalton: yeah they don't actually build a tree
[03:46:11] <strcat> you have to specify a struct with some metadata and it writes it out to your struct
[03:46:13] <strcat> well
[03:46:15] <strcat> it's pretty weird imo
[03:46:17] <pcwalton> right
[03:46:26] <pcwalton> it uses reflect to parse all those type tags at runtime, right?
[03:46:31] <strcat> pcwalton: I think so
[03:46:35] <pcwalton> that's gotta be slow
[03:46:46] <strcat> I used it a *looooong* time ago, it might have a different API now
[03:46:53] <strcat> probably not
[03:46:57] <goffrie> is there a nice way of getting an uninitialized ~str of a given length?
[03:47:01] <goffrie> (unsafe of course)
[03:47:20] <strcat> I tried Go when it was at r59/r60 pre-1.0 and then never touched it again ;p
[03:47:44] <pcwalton> I shouldn't bash Go too much, it does what it does well relative to what's out there
[03:47:45] <strcat> goffrie: with_capacity will get you in safe code
[03:47:50] <strcat> goffrie: the unsafe part is set_len
[03:47:56] <strcat> pcwalton: well it's much simpler than rust
[03:47:59] <strcat> simpler than java
[03:48:01] <strcat> that's their niche
[03:48:05] <pcwalton> yeah
[03:48:11] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[03:48:14] <acrichto> there's no way to go from char -> [u8] without allocating :(
[03:48:15] <goffrie> strcat: oh I see, cool, thanks
[03:48:49] <cmr> acrichto: [u8, ..4] or &[u8]?
[03:48:51] <pcwalton> acrichto: you mean UTF-8 encoding a char?
[03:48:59] <acrichto> pcwalton: cmr: yeah, or with something like a callback
[03:49:08] <pcwalton> you could have the caller pass in a [u8, ..4]
[03:49:12] <pcwalton> or return something like
[03:49:20] <strcat> I think our whole encoder is push_char
[03:49:32] <pcwalton> enum EncodedChar { One([u8 * 1]), Two([u8 * 2]), ... }
[03:49:38] <pcwalton> which is awful of course
[03:49:40] <pcwalton> but it does the trick :)
[03:49:43] <acrichto> oh well I'm looking to push it onto a io::Writer now
[03:49:56] <strcat> alright bors what are you up to
[03:50:18] <strcat> oh I was looking at the wrong buildbot page.
[03:51:04] <Mindless`> strcat: could you elaborate on why my code isn't safe for T? -- http://codepad.org/r6oSE5Ib
[03:51:22] <acrichto> pcwalton: https://gist.github.com/alexcrichton/6145107
[03:51:29] <strcat> Mindless`: sec looking again, I may have been wrong
[03:51:58] <acrichto> I'll open a bug
[03:52:10] <pcwalton> wat
[03:52:13] <pcwalton> acrichto: cc sully 
[03:52:17] <acrichto> will do
[03:52:19] <pcwalton> he's looking into all sorts of trait things
[03:52:42] <strcat> &Trait doesn't work at all
[03:52:42] <pcwalton> yay, self-hosted a Rust that doesn't parse &const or *const
[03:52:49] <strcat> it only seems to work for 'static lifetime ptrs
[03:52:57] <pcwalton> yeah, that's what we're hitting
[03:52:59] <acrichto> but hopefully soon it can work!
[03:53:05] <strcat> I was trying to benchmark our virtual function calls and ran into it ;p
[03:53:07] <pcwalton> that's gotta be easy to fix
[03:53:35] <acrichto> pcwalton: it looks like though that it wasn't as bad as I thought having a field of `&mut io::Writer`
[03:53:45] <pcwalton> you could just transmute for now
[03:53:48] <acrichto> that may be the only blocker (unless there are runtime things)
[03:53:53] <acrichto> oh true...
[03:54:02] <pcwalton> transmute to 'static
[03:54:23] <acrichto> looks like transmuting '&a as &Trait' worked
[03:55:05] <acrichto> I think that sys::log_str needs an overhaul to take &mut io::Writer as well
[03:55:27] <acrichto> pcwalton: yeah with the transmute everything builds just fine, now to see if it passes the tests...
[03:55:33] <pcwalton> cool :)
[03:55:39] <acrichto> good idea lol
[03:55:42] <pcwalton> I've been using &Trait in sprocketnes for months, btw
[03:55:48] <pcwalton> I do remember having to transmute it in though
[03:55:55] <pcwalton> but once that was done it worked
[03:56:03] <pcwalton> I use it for memory mappers
[03:56:16] <acrichto> awesome, I had no idea that they were working so well
[03:56:30] <acrichto> oh yay no I can make fprintf
[03:56:33] <cmr> I think it's mostly ~Trait that was crashy
[03:56:34] <acrichto> instead of only having sprintf
[03:56:40] <pcwalton> cmr: yes
[03:56:42] <strcat> ~Trait is fixed afaik
[03:56:50] <strcat> I couldn't figure out a way to break it at least
[03:56:56] <pcwalton> I figured out a way to break @Trait :P
[03:56:58] <dbaupp> acrichto: fwiw, sprintf should ideally just use fprintf
[03:57:00] <pcwalton> but it involves lots of generics
[03:57:05] <acrichto> maybe there should be a PSA that (&|~|@)Trait should no longer be considered broken
[03:57:08] <acrichto> dbaupp: of course :)
[03:57:08] *** Joins: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au)
[03:57:15] <pcwalton> I have a patch to rustc that exposes it
[03:57:22] <strcat> acrichto: well we never linted about them like we did for default methods ;p
[03:57:23] <dbaupp> acrichto: (cool, just checking.)
[03:57:33] <pcwalton> @Trait evolved out of "obj"
[03:57:37] <strcat> I think trait objects are still pretty broken when combined with other features
[03:57:38] <pcwalton> which was part of Rust for years
[03:57:46] <strcat> with default methods or trait inheritance they'll probably break fast
[03:57:47] <pcwalton> I think there is probably still a way to make cast out of trait
[03:57:53] <strcat> *especially* trait inheritance
[03:57:55] <pcwalton> because of @/@mut problems
[03:58:07] <pcwalton> I plan to bring this up on Tuesday
[03:58:22] <pcwalton> strcat: you sure? I was under the impression sully solved most of the problems
[03:58:38] <strcat> pcwalton: well I think he solved most, but if you actually try using it you're sure to find more
[03:58:46] <pcwalton> probably :P
[03:58:49] <strcat> because it's uncharted territory
[03:59:04] <strcat> he fixed 95% of default methods without trait objects and I still found a few more bugs
[03:59:12] <sully> default methods should mostly work with trait objects, I think
[03:59:19] <sully> inheritance I think does not work
[03:59:21] <cmr> What's the difference between a "regular" function (item_fn) and TyBareFn?
[03:59:28] <cmr> Is TyBareFn the type of functions?
[03:59:36] <strcat> need more people to use default methods + inheritance to find the bugs
[03:59:38] <strcat> ;p
[03:59:47] <acrichto> pcwalton: if I could figure out how to do it, would you be comfortable basically shoving all of the `Piece` structs into some unique static per callsite of ifmt!? that's for only compile-time parsing
[03:59:53] <strcat> cmr: BareFn is fn(), I think it just yells at you when you use it...
[04:00:06] *** Joins: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:00:07] <pcwalton> acrichto: I think so
[04:00:07] <cmr> strcat: I'm not sure, rustdoc_ng is getting one from libstd
[04:00:08] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[04:00:12] <pcwalton> assuming I understand what you mean :)
[04:00:15] <strcat> cmr: maybe it wraps the sigil around it
[04:00:25] *** Joins: lerc (quassel@D9C8F2D2.85A70C12.788638A4.IP)
[04:00:35] <pcwalton> I plan to make the &fn -> fn transition soonish
[04:00:37] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Connection reset by peer)
[04:00:51] <strcat> pcwalton: wouldn't "fn" be dynamically sized?
[04:00:53] <acrichto> ok cool
[04:00:57] <pcwalton> no, fn just means &fn
[04:01:04] <pcwalton> and ~fn/@fn go away
[04:01:09] <cmr> pcwalton: please leave the AST in a better state than what you found it in! It feels... sprawling
[04:01:14] <acrichto> wasn't it a few months ago that the transition was made from fn -> &fn ?
[04:01:16] *** Joins: wphsieh (wphsieh@moz-12D4D3B4.hinet-ip.hinet.net)
[04:01:18] <pcwalton> yeah
[04:01:23] <pcwalton> in favor of ~Trait and GC<Trait>
[04:02:16] *** Quits: rfw (rfw@moz-C65A114.rfw.name) (Ping timeout)
[04:02:31] <pcwalton> acrichto: we've flip flopped on this. eventually we've settled on super-simplified in the name of, well, simplicity
[04:02:47] <pcwalton> punt the complex ownership stuff over to boxed Trait objects
[04:02:47] <acrichto> oh I certainly don't mind one way or another
[04:02:57] <acrichto> what does this mean for the lifetime of functions though?
[04:02:58] *** Quits: HERTZ (Xplod@moz-6BDFDFBE.dynamic.amis.net) (Ping timeout)
[04:03:07] <acrichto> or is &'a fn not really that significant?
[04:03:08] <pcwalton> acrichto: same as always. &'whatever fn becomes 'whatever fn
[04:03:12] <acrichto> oh ok
[04:03:41] *** Joins: rfw (rfw@moz-C65A114.rfw.name)
[04:04:17] <acrichto> also no fprintf yet :( https://github.com/mozilla/rust/issues/8249
[04:04:29] <cmr> We're really blazing through the issue numbers
[04:04:46] <pcwalton> blah
[04:04:50] <acrichto> cmr: oh wow! what are the numbers?
[04:04:51] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[04:04:51] *** ChanServ sets mode: +o brson
[04:05:02] <cmr> acrichto: well you just opened 8249
[04:05:09] <acrichto> as in churn
[04:05:16] <cmr> oh
[04:05:18] <acrichto> oh wait you mean that
[04:05:18] <cmr> dunno yet
[04:05:19] <strcat> we've totally broken github's issue search
[04:05:19] <acrichto> nevermind
[04:05:20] <cmr> twir is tomorrow
[04:05:27] <cmr> but 8000 was opened 11 days ago
[04:05:37] <strcat> it doesn't realize lots of bugs were closed
[04:05:40] <acrichto> 22 issues/day, not bad if we close that many too :)
[04:05:57] <cmr> github's search has always been flaky
[04:06:09] *** Joins: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP)
[04:08:01] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:08:01] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/kWKOWg
[04:08:01] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:10:34] <acrichto> was there a concious decision that block comments don't nest?
[04:10:46] <cmr> rusti: /* /* foo */ */
[04:10:46] -rusti- <anon>:5:23: 5:24 error: unexpected token: `/`
[04:10:46] -rusti- <anon>:5          /* /* foo */ */
[04:10:47] -rusti-                                 ^
[04:10:47] -rusti- application terminated with error code 101
[04:10:49] <cmr> yikes
[04:10:52] <strcat> yes
[04:10:55] <strcat> they used to nest
[04:10:57] <cmr> I would have expected/hoped they did
[04:10:58] <pcwalton> acrichto: yeah, I don't agree with it personally but graydon wanted to simplify the lexer
[04:11:07] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[04:11:07] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/WzQksA
[04:11:07] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[04:11:16] <acrichto> oh ok, if it were a bug I'd be interested in fixing it :)
[04:11:36] * strcat has to fix those 4 new ones
[04:11:44] <strcat> also.... somehow one run-pass test wasn't caught on linux :|
[04:11:50] <cmr> non-nesting comments in the name of simplicity is a bit much imo, but it's not really the end of the world
[04:11:56] <strcat> oh
[04:12:01] <strcat> it's because run-pass doesn't care about lint.
[04:14:25] <brson> the new runtime completes make check in about 56% the userspace time of the old scheduler, and and about half the sys time. real time is only improved by about 10% though
[04:14:30] <strcat> cmr: he wanted lexing to be possible with regexp-based stuff like vim's highlighting
[04:14:50] <strcat> brson: so it's more I/O bound?
[04:14:52] *** Joins: sawrubh (uid6719@moz-5F4AA75A.irccloud.com)
[04:14:55] <brson> the there's a big difference in implementations because of the lack of split stacks
[04:15:47] * strcat doesn't really understand how real time stayed so similar
[04:15:53] <strcat> I thought I/O counted as sys time
[04:16:08] <brson> strcat: idk. at a guess i'd imagine there's a hell of a lot less locking
[04:16:58] <strcat> oh nvm sys is just CPU
[04:17:02] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:17:02] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1413e48a5 to 14efd6eaf: 02http://git.io/N3iJvQ
[04:17:02] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:17:03] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[04:17:03] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/VwOFdw
[04:17:03] <ghrust> 13rust/06auto 14c0f95b7 15Daniel Micay: replace all remaining `for` with `foreach` or `do`
[04:17:03] <ghrust> 13rust/06auto 146a1d553 15Daniel Micay: make `for` parse as `foreach` does
[04:17:04] <ghrust> 13rust/06auto 1459581b4 15Daniel Micay: port remaining `for` loops
[04:17:05] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[04:17:13] <strcat> so it means it's more I/O bound
[04:17:29] <strcat> or... sleeping ;]
[04:18:21] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Ping timeout)
[04:18:26] <cmr> You know, someone made a joke a while ago about a sleep() in rustc...
[04:18:36] <cmr> it would be very unamusing if that was found to be true
[04:21:11] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[04:21:11] *** ChanServ sets mode: +o pcwalton
[04:21:11] <cmr> dbaupp: btw status of the bencher is "it's still running builds, but I got frustrated with rust's documentation and started working on rustdoc_ng again"
[04:21:50] <dbaupp> cmr: np, I assume that it'll then run a few 100 benchmarked builds at some point in the fuure?
[04:21:54] <dbaupp> future
[04:21:55] <cmr> dbaupp: yup
[04:22:13] <cmr> only 4 minutes per bench, so it's not that bad
[04:22:50] <strcat> anyway... once this lands I'll make a snapshot and remove foreach
[04:22:52] <Eridius> brson: r? I had to rebase https://github.com/mozilla/rust/pull/8213
[04:23:05] <cmr> 241 cached builds
[04:23:19] <cmr> strcat: how many do you have? does my collection trump yours yet? :p
[04:23:27] * strcat has daily builds going back to the release of 0.6
[04:23:30] <strcat> cmr: you have more
[04:23:42] <strcat> I deleted a lot
[04:23:46] <cmr> /dev/sdb4       382G   26G  337G   7% /var/rust
[04:23:47] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Ping timeout)
[04:23:52] <strcat> mine are small though
[04:24:00] <strcat> since they're xz pkgs
[04:24:11] <jeaye> bjz: ping
[04:24:20] <strcat> Download Size  : 16492.71 KiB
[04:24:22] <strcat> Installed Size : 48783.00 KiB
[04:24:29] <strcat> and I started symlinking the compiler libs to the target libs
[04:24:41] <cmr> My netbook appreciates it very much
[04:25:02] <strcat> cmr: http://pkgbuild.com/~thestinger/repo/x86_64/ "tiny" deltas now ;p
[04:25:27] <strcat> (xdelta sucks)
[04:25:45] <Eridius> strcat: We need some documentation somewhere for the Iterator protocol that explains that, once None is returned, nothing is guaranteed about subsequent calls to next()
[04:25:48] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[04:25:48] *** ChanServ sets mode: +o pcwalton
[04:25:53] <Eridius> (i.e. you can't assume future calls will continue to return None)
[04:25:55] <strcat> Eridius: it should keep returning None
[04:26:14] <Eridius> strcat: last time we discussed this you said that the iterator protocol doesn't require that to be true
[04:26:31] <Eridius> in response to me saying that iterator adaptors don't necessarily force that to happen
[04:26:33] <strcat> Eridius: well, it's not assumed it's true anywhere but I think semantically it should be
[04:26:45] <Eridius> strcat: it would be nice if it were true, but nothing guarantees it at the moment
[04:26:45] <strcat> Eridius: yes, iterator adaptors assume iterator implementations are correct
[04:26:55] <strcat> it's guaranteed with every iterator afaik
[04:27:08] <strcat> adaptors are *not* going to add checks second-guessing the iterator they wrap though
[04:27:24] <Eridius> strcat: from what I recall there were iterator adaptors that took user-supplied functions, and the user-supplied function could cause the adaptor to return Some after it returns None. Your position at the time was that the user-supplied function needs to conform to the iterator protocol
[04:27:34] <strcat> yes
[04:27:35] <Eridius> whereas my position was that it's not the job of a user-supplied function to enforce the iterator contract
[04:27:50] <Eridius> it was during this conversation that you said that the iterator protocol doesn't necessarily hold after None is returned
[04:27:55] <strcat> well afaik the only one is Unfoldr
[04:28:00] <strcat> and it can just be put in the docstring
[04:28:09] <strcat> as a requirement on the user function
[04:28:23] <Eridius> if you want the protocol to state that once None is returned once the iterator should keep returning None forever, then that too should be documented
[04:28:25] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Ping timeout)
[04:29:28] <Luqman> acrichto: any idea why the div test was failing?
[04:29:53] <Eridius> curious, IteratorUtil.zip explicitly states that once None is returned it will continue to return None.
[04:30:07] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[04:30:28] *** Joins: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net)
[04:30:28] *** ChanServ sets mode: +o pcwalton
[04:30:46] <strcat> ugh I think i broke the test runner ;p
[04:30:53] * strcat sighs
[04:31:48] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[04:32:27] <ChrisMorgan> https://github.com/mozilla/rust/issues/5992 (assignment operator overloads) speaks of QuotAssign (quot for quotient); what is in ops at present uses Div (div for division); is that a change, or is there some strange reason it would be Quot rather than Div?
[04:33:25] <cmr> There was a huge bikeshed whether Div should be Quot or Div
[04:33:33] <cmr> Div won
[04:33:41] <ChrisMorgan> Good.
[04:33:49] *** Quits: pcwalton (pcwalton@moz-481A040C.hsd1.ca.comcast.net) (Ping timeout)
[04:33:54] <acrichto> Luqman: no :(, I looked into it as best as I could, and it looked like LLVM wasn't saving the result of an idiv before calling a function, causing the value in the register to be lost
[04:34:11] <acrichto> Luqman: that was also because I was specifically trying to find an LLVM bug, but this could be our bug as well
[04:34:14] <Eridius> aren't classic quot and div subtlely different for negative numbers?
[04:34:28] <Eridius> e.g. in Haskell, `quot` truncates toward 0 but `div` truncates toward negative infinity
[04:34:44] * ChrisMorgan is wondering whether to take a crack at implementing general augmented assignment
[04:34:47] <dbaupp> Eridius: we have div_floor and to manage that.
[04:34:51] <dbaupp> *and so on
[04:35:46] <strcat> don't understand how I broke this.
[04:35:58] <cmr> rusti: struct Static;
[04:36:00] -rusti- ()
[04:36:47] <strcat> oh
[04:36:51] <strcat> hm
[04:37:27] <strcat> iter_header was buggy
[04:37:29] * strcat sighs
[04:37:45] <strcat> I just revealed the bug by depending on internal iterators not being broken :(
[04:38:31] <ChrisMorgan> Ah, such a silly assumption.
[04:38:46] <ChrisMorgan> You know yet another something that would be nifty to have in Rust? Named Unicode literals. Python: '\N{EM DASH}' == '\u2014'.
[04:38:57] <strcat> rusti: "\u2014"
[04:38:58] -rusti- "\u2014"
[04:39:06] <ChrisMorgan> (Unfortunately almost no one knows about them in Python.)
[04:39:11] <strcat> ChrisMorgan: I didn't know
[04:39:14] <strcat> ;p
[04:39:15] <cmr> I didn't know either
[04:39:16] <dbaupp> rusti: print("\u2014")
[04:39:17] -rusti- â€”()
[04:39:25] <strcat> rusti: "\N{COMMA}"
[04:39:25] <cmr> And I get paid to use and teach python!
[04:39:25] -rusti- <anon>:4:12: 4:13 error: unknown string escape: 78
[04:39:25] -rusti- <anon>:4     let r = {
[04:39:27] -rusti-                      ^
[04:39:29] -rusti- application terminated with error code 101
[04:39:54] <dbaupp> ChrisMorgan: we'd need more unicode tables :P
[04:39:58] <cmr> Wouldn't we need to embed all of the unicode tables though?
[04:40:00] <cmr> Yeah
[04:40:05] <cmr> Does libICU have them?
[04:40:19] <strcat> python has them internally
[04:40:22] <ChrisMorgan> Oh, sure. The compiler would then need full Unicode tables.
[04:40:29] <strcat> cmr: we can't use icyu
[04:40:31] <strcat> icu*
[04:40:37] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[04:40:48] <dbaupp> strcat: licensing?
[04:40:57] <strcat> yes and also it's a pile of insecure crap
[04:40:58] <ChrisMorgan> Another handy thing Python people often don't know: unicodedata.name('\u2014') == 'EM DASH'
[04:40:59] <strcat> ;p
[04:41:00] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[04:41:00] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[04:41:00] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14940b287 to 14efd6eaf: 02http://git.io/N3iJvQ
[04:41:00] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[04:41:03] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[04:41:03] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/xvRUNA
[04:41:03] <ghrust> 13rust/06auto 143e23ce5 15Daniel Micay: replace all remaining `for` with `foreach` or `do`
[04:41:03] <ghrust> 13rust/06auto 1427a8c9a 15Daniel Micay: make `for` parse as `foreach` does
[04:41:03] <ghrust> 13rust/06auto 1446745af 15bors: auto merge of #8244 : thestinger/rust/for, r=huonw...
[04:41:05] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[04:41:22] <cmr> ICU is MIT I thought
[04:41:26] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[04:41:29] <ChrisMorgan> "for" is a pretty cool branch name.
[04:41:47] <strcat> ChrisMorgan: the one for removing all the advance loops was retreat ;p
[04:42:08] <cmr> yeah, ICU is MIT
[04:42:36] <ChrisMorgan> Still, in all of these things, I prefer the Mercurial way of anonymous heads...
[04:42:37] *** Quits: tautologico (shung@9F01D096.92EA1F6.C27E1635.IP) (Quit: tautologico)
[04:42:39] <dbaupp> we'll probably need want the tables in pure Rust for speed/safety, anyway.
[04:42:48] <ChrisMorgan> Yeppp.
[04:43:00] * dbaupp likes being able to say that we need to move away from C to get faster
[04:43:20] *** Quits: vk (chatzilla@F92596F.2DEF7520.EF7679FA.IP) (Ping timeout)
[04:43:26] <cmr> Well that's because our FFI is awful :\
[04:43:37] * dbaupp ignored that
[04:43:51] <dbaupp> just details :P
[04:43:52] <cmr> I mean there are valid reasons to have the data structures in pure rust
[04:44:09] <strcat> probably a lot of tests I will have to fix now ;[
[04:44:17] <strcat> stupid iter_header function was a dirty liar
[04:44:36] <strcat> https://github.com/thestinger/rust/commit/3e23ce53396bed45dac3ad8f120fb1ea12fcffc8#L0R107
[04:44:41] <strcat> returned false when you didn't break from it
[04:45:43] <strcat> could have just ported to to Iterator ;p
[04:46:16] *** Quits: jgilbert (jgilbert@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[04:49:47] <jeaye> rusti: let (foo, bar) = (1, 2); bar
[04:49:48] -rusti- <anon>:5:14: 5:17 warning: unused variable: `foo` [-W unused-variable (default)]
[04:49:49] -rusti- <anon>:5          let (foo, bar) = (1, 2); bar
[04:49:49] -rusti-                        ^~~
[04:49:49] -rusti- 2
[04:50:19] <jeaye> That's so cool. :D
[04:53:29] *** Quits: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com) (Connection reset by peer)
[04:53:42] <cmr> The cost of non-global inference is lots of typing :(
[04:54:06] * cmr is growing weary of typing pub fn clean(&self) -> Foo and pub fn to_json(&self) -> Json
[04:54:08] * dbaupp dislikes how annoying it is to pass iterators to and from functions
[04:54:22] *** Joins: dew (Instantbir@moz-8A63B53.dhcp.stls.mo.charter.com)
[04:55:04] <strcat> dbaupp: as in <A, T: Iterator<A>>(x: &mut T)?
[04:55:18] <dbaupp> strcat: yeah
[04:55:44] <dbaupp> strcat: (but especially returning, because you end up with Map<Filter<...>>)
[05:00:08] *** Quits: MiguelD (MiguelD@2ACDA535.A137FB69.46937063.IP) (Quit: KVIrc 4.1.3 Equilibrium http://www.kvirc.net/)
[05:01:37] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[05:02:20] <olsonjeffery> anyone around who's pretty familiar w/ conditions?
[05:02:34] * ChrisMorgan has touched them a very little
[05:03:05] <dbaupp> acrichto: ^
[05:03:44] <strcat> sorry bors ;p
[05:03:52] * strcat has to fix a few tests now ;[
[05:04:06] <strcat> that evil iter_header function
[05:05:06] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[05:05:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1446745af to 14efd6eaf: 02http://git.io/N3iJvQ
[05:05:06] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[05:05:07] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[05:05:07] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/UQsLlA
[05:05:07] <ghrust> 13rust/06auto 14887c656 15Patrick Walton: librustc: Introduce a new visitor type based on traits and port syntax to it....
[05:05:07] <ghrust> 13rust/06auto 149457ebe 15Patrick Walton: librustc: Disallow "unsafe" for external functions
[05:05:08] <ghrust> 13rust/06auto 142a7be1c 15bors: auto merge of #8235 : pcwalton/rust/unsafe-extern-fns, r=pcwalton...
[05:05:10] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[05:05:12] <ChrisMorgan> I'm pondering the workings of augmented assignment. Does this sound reasonable: `x += y` is effectively translated to `x.add_assign(y)`, or if that is not implemented, to `x = x.add(y)`, or if that is not implemented, produces an error. That's basically how Python does it with its __iadd__ and __add__ (though it also tries y.__radd__ before failing).
[05:05:47] <cmr> ChrisMorgan: the second evaluates x twice
[05:05:54] <cmr> or, would, if implemented naively
[05:05:54] <strcat> ChrisMorgan: it will become AddAssign
[05:05:59] <strcat> it won't have special magic
[05:06:19] <strcat> the trait system can get to the point where you can provide a default impl for types impl'ing a trait
[05:06:26] <strcat> not a good thing to special case
[05:07:30] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:08:33] <ChrisMorgan> That'd be a default implementation of `fn add_assign(&mut self, rhs: &RHS) { *self = self + rhs }`, I think?
[05:08:53] <strcat> yes, we can probably do it already
[05:08:59] <strcat> since AddAssign would inherit from Add
[05:09:26] <ChrisMorgan> Hmm... that works for `mut x: X` and `mut x: ~X`, but you'd then be requiring `mut x: &mut X` rather than `x: &mut X`?
[05:09:33] <ChrisMorgan> True, true.
[05:09:40] *** Joins: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net)
[05:10:15] <ChrisMorgan> cmr: you mean for things like an lvalue of `foo.bar().baz += 2`?
[05:10:16] *** Quits: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[05:10:22] <cmr> ChrisMorgan: yes
[05:10:41] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[05:11:09] <ChrisMorgan> That will clearly require some thought and very careful coding and is probably beyond me with my current grasp of the code base.
[05:12:18] *** Joins: mark_edward (quassel@moz-9631ECE3.public.wayport.net)
[05:16:37] *** Quits: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP) (Client exited)
[05:18:50] *** Joins: dwhyte (dwhyte@1922756A.EDC594B0.7BF4A4B0.IP)
[05:19:55] *** Quits: lmandel (lmandel@moz-4D911C2E.dsl.bell.ca) (Quit: lmandel)
[05:20:17] *** Quits: thesnowdog (doug@629A8C2F.CDB23781.6F17036B.IP) (Quit: WeeChat 0.4.1)
[05:20:19] <cmr> rusti: macro_rules! foo ( ($x:expr) => {use $x;} ); foo!(std::foo);
[05:20:21] -rusti- <anon>:5:47: 5:48 error: expected ident, found `std::foo`
[05:20:21] -rusti- <anon>:5          macro_rules! foo ( ($x:expr) => {use $x;} ); foo!(std::foo);
[05:20:21] -rusti-                                                         ^
[05:20:21] -rusti- application terminated with error code 101
[05:20:33] *** Joins: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr)
[05:20:34] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[05:20:35] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[05:21:04] <aatch> cmr, I think you want path
[05:21:10] <cmr> rusti: macro_rules! foo ( ($x:path) => {use $x;} ); foo!(std::foo);
[05:21:10] -rusti- <anon>:5:47: 5:48 error: expected ident, found `an interpolated path`
[05:21:10] -rusti- <anon>:5          macro_rules! foo ( ($x:path) => {use $x;} ); foo!(std::foo);
[05:21:10] -rusti-                                                         ^
[05:21:10] -rusti- application terminated with error code 101
[05:21:11] <cmr> Yeah
[05:21:16] <cmr> I was just making sure that's what it was first
[05:21:49] <cmr> rusti: macro_rules! foo ( ($x:ident) => {use $x;} ); foo!(adfd);
[05:21:49] -rusti- <anon>:5:43: 5:50 error: view items must be declared at the top of the block
[05:21:50] -rusti- <anon>:5          macro_rules! foo ( ($x:ident) => {use $x;} ); foo!(adfd);
[05:21:50] -rusti-                                                     ^~~~~~~
[05:21:50] -rusti- application terminated with error code 101
[05:21:56] <cmr> that's weird
[05:22:00] <cmr> macros have lots of weirdness
[05:22:30] <cmr> anyway the bug I'm getting is span_to_snippet is failing, rust: task failed at 'assertion failed: `(left == right) && (right == left)` (left: `{__field__: 9860}`, right: `{__field__: 57921}`)', /home/cmr/hacking/rust-benching/src/libsyntax/codemap.rs:376, on a span I get from rustc, one of the max_values
[05:22:44] <cmr> The only place span_to_snippet is used in the rust codebase is resolve error reporting
[05:22:46] <cmr> (I put it there!)
[05:24:15] <cmr> I have no idea if span_to_snippet actually works, it seems it doesn't
[05:26:55] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:27:01] * cmr bed
[05:27:24] * strcat table
[05:27:26] <strcat> wait what?
[05:28:43] <erickt1> ChrisMorgan: hey there. In case you're interested, I updated https://github.com/erickt/ragel to 0.8.x
[05:28:55] <ChrisMorgan> Thanks!
[05:29:19] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Ping timeout)
[05:29:28] <erickt1> ChrisMorgan: There are a bunch of examples in https://github.com/erickt/ragel/tree/rust/examples/rust
[05:30:06] <erickt1> ChrisMorgan: the url parser is about the same speed as extra::url at the moment. Some urls it's faster, others it's twice as slow. Not sure why
[05:30:14] <dbaupp> erickt1: "ragel examples for OCaml codegen" ;P
[05:30:31] <erickt1> oops
[05:31:10] <strcat> reminds me that I need to get labelled breaks parsing with `for`
[05:31:20] <strcat> now that the old one is going to be gone...
[05:31:42] <erickt1> dbaupp: fixed :)
[05:32:25] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[05:33:02] * erickt1 wishes we could have a labeled match branches that could compile down to gotos. Then we wouldn't need to use a state table and it should be a bit faster
[05:33:30] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[05:33:54] <dbaupp> erickt1: i.e. similar  to fallthrough of switch?
[05:34:05] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Input/output error)
[05:35:04] <ChrisMorgan> `a + b` is effectively equivalent to `a.add(&b)`, right?
[05:35:48] <dbaupp> (&a).add(&b) yes
[05:36:53] <strcat> unless a and b are already refs
[05:37:02] <dbaupp> really?
[05:37:07] <strcat> hm
[05:37:10] <strcat> maybe not
[05:37:16] <strcat> rusti: let x = &5; let y = &5; x + y
[05:37:18] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eXJJ
[05:37:20] <strcat> oh nvm
[05:37:20] <dbaupp> rusti: let a = 1; &a + &a
[05:37:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/WQTR
[05:37:25] <strcat> rusti: let x = 5; let y = &5; x + y
[05:37:25] -rusti- <anon>:5:36: 5:37 error: mismatched types: expected `<VI0>` but found `&<VI1>` (expected integral variable but found &-ptr)
[05:37:25] -rusti- <anon>:5          let x = 5; let y = &5; x + y
[05:37:25] -rusti-                                              ^
[05:37:25] -rusti- error: aborting due to previous error
[05:37:25] -rusti- application terminated with error code 101
[05:37:35] <erickt1> dbaupp: kinda. I thought java allowed you to label case arms so you can use them to simulate a goto-driven state machine
[05:37:39] <ChrisMorgan> dbaupp: but not (&a) as a will be auto-borrowed, right?
[05:37:49] <erickt1> although now I can't find an example on how to do it
[05:37:53] *** Quits: wphsieh (wphsieh@moz-12D4D3B4.hinet-ip.hinet.net) (Client exited)
[05:38:06] <dbaupp> ChrisMorgan: yes, but it has to be &a, otherwise auto deref explodes thing.
[05:38:48] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[05:39:25] <strcat> erickt1: or inline LLVM IR ;p
[05:40:17] <erickt1> strcat: that's cheating :)
[05:40:19] <ChrisMorgan> rusti: let (a, b) = (1i, 2i); (a).add(&b)  // dbaupp: but what about this?
[05:40:20] -rusti- 3
[05:41:05] <dbaupp> rusti: struct Foo; impl<'self> Add for &'self Foo { fn add(&self, _: & &'self Foo) -> &'self Foo { *self } } (&Foo).add(& (&Foo))
[05:41:05] -rusti- <anon>:5:33: 5:37 error: wrong number of type arguments: expected 2 but found 0
[05:41:05] -rusti- <anon>:5          struct Foo; impl<'self> Add for &'self Foo { fn add(&self, _: & &'self Foo) -> &'self Foo { *self } } (&Foo).add(& (&Foo))
[05:41:05] -rusti-                                           ^~~~
[05:41:06] -rusti- application terminated with error code 101
[05:41:23] <dbaupp> rusti: struct Foo; impl<'self> Add<&'self Foo, &'self Foo> for &'self Foo { fn add(&self, _: & &'self Foo) -> &'self Foo { *self } } (&Foo).add(& (&Foo))
[05:41:24] -rusti- &{}
[05:41:38] <dbaupp> ChrisMorgan: hm, maybe it doesn't destroy everything.
[05:41:56] <strcat> rusti: 2
[05:41:57] -rusti- 2
[05:42:01] <dbaupp> ChrisMorgan: (in any case... I don't see the point in asymmetrically borrowing the two sides.)
[05:42:01] <strcat> rusti: 2+2+2+2+2+2+2
[05:42:01] -rusti- 14
[05:42:05] <strcat> rusti: 2+2+2+2+2+2+2+2+2+2
[05:42:05] -rusti- 20
[05:42:08] <strcat> rusti: 2+2+2+2+2+2+2+2+2+2+2
[05:42:09] -rusti- 22
[05:42:25] <strcat> dbaupp: can speed up the vector iteration further with inbounds GEP btw
[05:42:32] <strcat> I'll do that stuff later
[05:42:40] <dbaupp> rusti: struct Foo; impl<'self> Add<&'self Foo, &'self Foo> for &'self Foo { fn add(&self, _: & &'self Foo) -> &'self Foo { *self } } impl Add<Foo,Foo> for Foo { fn add(&self, _: &Foo) -> Foo { Foo } } (&Foo).add(& (&Foo))
[05:42:40] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/RjFP
[05:42:48] <dbaupp> ChrisMorgan: there ^
[05:42:57] <dbaupp> rusti: struct Foo; impl<'self> Add<&'self Foo, &'self Foo> for &'self Foo { fn add(&self, _: & &'self Foo) -> &'self Foo { *self } } impl Add<Foo,Foo> for Foo { fn add(&self, _: &Foo) -> Foo { Foo } } (& (&Foo)).add(& (&Foo))
[05:42:57] -rusti- &{}
[05:43:27] <dbaupp> strcat: yeah, isn't that just making ptr.offset() a inbounds gep call?
[05:43:39] <strcat> dbaupp: maybe.
[05:43:40] <dbaupp> strcat: (assuming that it's reasonable to have such a requirement.)
[05:43:41] <strcat> maybe not
[05:43:45] <strcat> it would make offset unsafe
[05:43:54] <strcat> and we would have to remove Add/Sub for *T
[05:44:03] <strcat> but... it makes little sense to have *slow* pointer arithmetic
[05:45:01] <dbaupp> is inbounds GEP slow??
[05:45:08] <strcat> no I mean non-inbounds
[05:45:17] <strcat> C/C++ uses inbounds pointer arithmetic.
[05:45:32] <strcat> rust is penalizing all pointer arithmetic by making offset safe
[05:45:48] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[05:45:50] <strcat> there's essentially no reason for it to be safe because deref is no more or less unsafe with inbounds
[05:46:09] <dbaupp> isn't inbounds GEP still "safe" for a non-inbounds offset, it's just derefing
[05:46:12] <dbaupp> ?
[05:46:14] <strcat> no
[05:46:38] <strcat> it's undefined behaviour for it to a) overflow or b) point outside of the object it's based on (it's allowed to point one byte past the end)
[05:47:03] <strcat> I carefully did vector iterators as they're done in C++ so it can use inbounds GEP
[05:47:05] *** Quits: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net) (Ping timeout)
[05:47:17] <dbaupp> (byte or word?)
[05:47:21] <strcat> dbaupp: byte
[05:47:22] <ChrisMorgan> :-( This default trait implementation doesn't seem to be working: `pub trait AddAssign<RHS>:Add<RHS,Self>{fn add_assign(&mut self, rhs:&RHS){*self=*self+*rhs;}}`
[05:47:29] <strcat> dbaupp: meaning it can point to the next element
[05:47:43] <dbaupp> ChrisMorgan: borrowing as mutable and immutable?
[05:47:45] <strcat> padding counts as part of an element when it comes to this
[05:47:54] <dbaupp> strcat: ah, right; makes sense
[05:48:06] <ChrisMorgan> Well, it compiles fine, but things aren't recognised as having an add_assign satisfying it.
[05:48:25] <dbaupp> you need to impl AddAssign for int {} etc
[05:48:28] <strcat> yeah
[05:48:29] <dbaupp> it's not automatic
[05:48:31] <erickt1> hm. crazy idea. how dumb would it be to allow us to write `match { 'step1 => { continue 'step2; }, 'step2 => { continue 'out; }, 'out => {} }`?
[05:48:41] * dbaupp likes erickt1's idea
[05:48:53] <ChrisMorgan> OK, I see. I did note that when I added an impl for int it did work.
[05:48:55] <erickt1> constrained goto
[05:50:05] <erickt1> maybe `match 'step1 { 'step1+> â€¦`
[05:50:29] <strcat> erickt1: seems non-trivial to make it safe if you're still going to allow patterns
[05:50:35] <strcat> you can move into them
[05:50:43] <bjz> jeaye: hoy
[05:50:55] <bjz> jeaye: sorrys, was out
[05:50:59] <doener> dbaupp: that's for letting me know about the ret alloca issue!
[05:51:09] <dbaupp> erickt1: especially if there was "computed goto" for the match expression
[05:51:13] <doener> dbaupp: s/that's/thanks/
[05:51:19] * doener just got up and needs coffee
[05:51:23] <dbaupp> erickt1: (although that seems impossible)
[05:51:56] <erickt1> strcat: at first I wasn't thinking it'd make sense to do pattern matching, but i suppose a computed goto would make sense
[05:52:46] <erickt1> would we have to make it possible to have a region as a first class value then?
[05:52:55] <strcat> sooooo close to killing off for
[05:53:15] <erickt1> does a first class region even make sense?
[05:53:55] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[05:53:56] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 14551d35d to 140aece61: 02http://git.io/k471pw
[05:53:56] <ghrust> 13rust/06try 146dcdc3a 15Daniel Micay: replace all remaining `for` with `foreach` or `do`
[05:53:56] <ghrust> 13rust/06try 141e9dcce 15Daniel Micay: make `for` parse as `foreach` does...
[05:53:56] <ghrust> 13rust/06try 140aece61 15Daniel Micay: rm obsolete documentation on `for`...
[05:53:58] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[05:54:00] <erickt1> maybe hiding this all in a macro would be the best way of doing this
[05:54:07] <dbaupp> erickt1: I could imagine that `match 'jumptable { 'jumptable => { match some_value { x => continue 'a, y => continue 'b } }, 'a => { }, 'b => { } }` would be a common/useful pattern (for resumably state machines.)
[05:54:23] <dbaupp> ... also, nested goto-matches.
[05:54:42] <dbaupp> `continue 'match_name:'target_name` ?
[05:54:50] <strcat> erickt1: you're going to need borrowck/liveness support
[05:54:56] <strcat> either way
[05:55:25] <strcat> labelled breaks are very simple since loops already work that way
[05:55:54] <doener> aatch: what clang does is to check whether there is only one store to the ret slot alloca that would dominate the load that is to be inserted. If so, it just returns the operand used by that store for the "ret" instruction and drops the store and the alloca
[05:56:20] <aatch> doener, ok thne.
[05:56:23] <aatch> then*
[05:56:31] <erickt1> strcat: yeah. I'm going to look around to see if anyone else has done this
[05:57:19] <dbaupp> doener: does that optimisation have any effect on https://github.com/mozilla/rust/issues/7298 ?
[05:58:07] *** Joins: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com)
[05:58:23] <strcat> that's not really related to ret
[05:58:36] <doener> dbaupp: no, there's no ret slot alloca to begin with
[05:58:49] <doener> dbaupp: in that case, the ret slot is the first argument
[05:58:54] <dbaupp> ah
[05:59:16] * dbaupp has essentially no idea about the details of this stuff.
[06:00:51] <ChrisMorgan> I don't believe that default method implementation for AddAssign is working: see http://sprunge.us/gQLR 
[06:01:43] <erickt1> strcat / dbaupp: D's switch statement supports "goto case" to jump between switch arms: http://dlang.org/statement.html#GotoStatement
[06:02:21] <aatch> Sweet, made a platform triple parser that should be able to handle anything you throw at it (as long as it knows about the various parts)
[06:02:37] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[06:03:08] <dbaupp> ChrisMorgan: do you need the (&mut l)?
[06:03:41] <dbaupp> ChrisMorgan: wait, doesn't matter.
[06:04:11] <ChrisMorgan> True, but I was doing it that way 'cos of what you sed.
[06:05:06] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[06:05:16] <ChrisMorgan> Will Rust have goto?
[06:05:57] <dbaupp> rusti: pub trait AA<RHS>:Add<RHS,Self>{fn aa(&mut self,rhs:&RHS){*self=*self+*rhs;}}struct A;impl Add<A,A> for A{fn add(&self,_:&A)->A{A} impl AA<A> for A{} let mut a = A; a.aa(&A);
[06:05:57] -rusti- <anon>:8:0: 8:1 error: file ended with unbalanced delimiters
[06:05:57] -rusti- <anon>:8 }
[06:05:57] -rusti-          ^
[06:05:57] -rusti- application terminated with error code 101
[06:06:06] <dbaupp> rusti: pub trait AA<RHS>:Add<RHS,Self>{fn aa(&mut self,rhs:&RHS){*self=*self+*rhs;}}struct A;impl Add<A,A> for A{fn add(&self,_:&A)->A{A}}impl AA<A> for A{} let mut a = A; a.aa(&A);
[06:06:07] -rusti- ()
[06:06:14] <dbaupp> rusti: pub trait AA<RHS>:Add<RHS,Self>{fn aa(&mut self,rhs:&RHS){*self=*self+*rhs;}}struct A;impl Add<A,A> for A{fn add(&self,_:&A)->A{A}}impl AA<A> for A{} let mut a = A; (&mut a).aa(&A);
[06:06:14] -rusti- ()
[06:06:20] <dbaupp> ChrisMorgan: not full goto
[06:06:44] <dbaupp> erickt1: cool!
[06:06:47] <ChrisMorgan> Of course not a full goto. It'd obviously need to be restricted to things that made sense and were safe.
[06:07:23] <ChrisMorgan> Oh yeah, I forgot you've still got to have an empty impl block :-/
[06:07:34] <erickt1> dbaupp: ooh, and llvm supports computed gotos tooâ€¦ http://blog.llvm.org/2010/01/address-of-label-and-indirect-branches.html
[06:07:40] <dbaupp> rusti: pub trait AA<RHS>:Add<RHS,Self>{fn aa(&mut self,rhs:&RHS){*self=*self+*rhs;}}struct A;impl Add<A,A> for A{fn add(&self,_:&A)->A{A}}impl AA<A> for A; let mut a = A; (&mut a).aa(&A);
[06:07:41] -rusti- ()
[06:08:04] <dbaupp> ChrisMorgan: that's not true, it can be a `;`, not just a block. :P
[06:08:25] <dbaupp> erickt1: neat
[06:09:51] <ChrisMorgan> And I then can't do `impl<LHS: Add<RHS, LHS>, RHS> AddAssign<RHS> for LHS;` because then nothing else can do it :-(
[06:10:16] <aatch> Huh, apparently `float` is always 64-bit in rust
[06:11:13] <ChrisMorgan> Is there any way I can make this work?
[06:11:32] <erickt1> anyway bedtime for me. gnight everyone!
[06:11:36] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[06:12:21] <ChrisMorgan> Just as there is the discussion of adding #[deriving(Clone)] and a few others if reasonable, would it be possible to automatically derive AddAssign if Add is implemented and AddAssign is not?
[06:12:57] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[06:13:15] <dbaupp> drat, erickt left.
[06:13:42] <ChrisMorgan> Or would it be possible to have a low-priority `impl<LHS: Add<RHS, LHS>, RHS> AddAssign<RHS> for LHS;` which can be silently overridden?
[06:14:01] <dbaupp> fwiw, https://gist.github.com/huonw/6145412
[06:14:05] <dbaupp> ChrisMorgan: maybe
[06:14:24] <dbaupp> ChrisMorgan: there is proposal for trait specialisation support
[06:15:21] <dbaupp> ChrisMorgan: https://github.com/mozilla/rust/issues/7059 (among other things)
[06:16:12] <dbaupp> ChrisMorgan: and https://gist.github.com/bjz/5855557
[06:17:19] *** Quits: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com) (Quit: WeeChat 0.3.8)
[06:17:44] <ChrisMorgan> Sounds like it is likely to happen somewhere along the line?
[06:18:14] *** Quits: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP) (Ping timeout)
[06:19:10] <strcat> not before 1.0
[06:21:27] *** Quits: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr) (Ping timeout)
[06:23:14] <ChrisMorgan> Which means that augmented assignment operators won't be able to be used conveniently :-(
[06:23:27] <strcat> they will
[06:23:36] <strcat> if you implement Add, implement AddAssign too
[06:23:51] <strcat> not much different than how you should implement Clone/DeepClone for almost every type
[06:31:50] <dbaupp> strcat: (we need to go and add DeepClone to all the deriving(Clone)'s, btw.)
[06:32:16] <strcat> yeah I know
[06:32:21] <strcat> almost all
[06:32:30] <strcat> & can Clone but not DeepClone
[06:33:01] <dbaupp> right
[06:33:25] <dbaupp> (but you can't derive on &, so my point stands :P )
[06:36:23] <strcat> rusti: 5
[06:36:23] -rusti- 5
[06:36:28] <strcat> dbaupp: why can't you derive on &?
[06:36:37] <strcat> it has a Clone impl
[06:36:39] <strcat> auto-deref?
[06:37:17] <dbaupp> strcat: as in, you can't derive directly on the type &T
[06:37:35] <dbaupp> strcat: but yes, deriving doesn't work with fields with & because of auto-deref
[06:37:55] <dbaupp> (at least, in some instances, auto-deref kills it.)
[06:38:25] <strcat> will need to rm more for loops from the most current PR ;[
[06:38:34] <strcat> luckily they are all advance ones afaict
[06:39:48] <strcat> just passed all 4 try bots though
[06:39:49] <strcat> good news
[06:41:10] <strcat> hurry bors :p
[06:41:24] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[06:41:48] <dbaupp> you can rebase on top of auto, right?
[06:42:16] <strcat> yeah I could
[06:42:18] <strcat> good point
[06:42:55] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[06:44:08] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[06:44:08] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/UQsLlA
[06:44:08] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[06:44:27] <dbaupp> strcat: quick!
[06:44:30] <strcat> it's okay
[06:44:35] *** Joins: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr)
[06:44:42] <strcat> it will cancel when I force push over my own
[06:44:50] <strcat> it just didn't work last time because pcwalton's had a higher priority
[06:45:09] <strcat> and it's good it did, because it would have failed to land
[06:46:06] <strcat> meh I don't think I did it in time
[06:46:21] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[06:46:44] * strcat just used sed
[06:46:50] *** Joins: jfbk (textual@moz-EEA9CFB3.nyc.res.rr.com)
[06:47:12] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[06:47:18] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[06:47:18] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/1qU0ZQ
[06:47:18] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[06:47:20] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[06:47:20] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/83np7Q
[06:47:20] <ghrust> 13rust/06auto 14b913547 15toddaaro: modified logging function to truncate output and adjusted error output formatting tests to be compatible with both the new and old runtimes
[06:47:20] <ghrust> 13rust/06auto 1484698a7 15toddaaro: fixed the buffer to make it a more reasonable size
[06:47:22] <ghrust> 13rust/06auto 144750490 15bors: auto merge of #8250 : brson/rust/logging-fixes, r=brson...
[06:47:24] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[06:48:13] <strcat> meh I'll just land those with mine
[06:54:58] * dbaupp has a feeling that bors won't be happy about this
[06:55:14] <strcat> ;p
[06:57:09] *** Quits: eholk (eholk@moz-B0798A8B.uconnect.utah.edu) (Quit: eholk)
[06:57:34] <strcat> wake up bors
[06:58:06] <strcat> I think you're right ;[
[06:58:07] * dbaupp whacks strcat for breaking bors *again*
[06:58:09] <dbaupp> :P
[06:58:11] <joelteon> how do you make an IoFactory object? (from rt::rtio)
[06:58:20] <strcat> I already tested it in try too >.<
[06:59:00] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[06:59:00] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06auto from 144750490 to 14efd6eaf: 02http://git.io/N3iJvQ
[06:59:00] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[06:59:24] <strcat> there now he's been totally confused >.<
[06:59:53] <dbaupp> strcat: if you're gonna kill him, do it properly?
[07:00:13] <strcat> well maybe he'll detect it and start again
[07:00:20] <strcat> but I think I managed to actually crash it
[07:01:33] <strcat> meh
[07:02:12] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:02:12] <ghrust> 01[13rust01] 15bors merged 06master into 06auto: 02http://git.io/UQsLlA
[07:02:12] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:02:16] <strcat> err
[07:02:22] <strcat> just as I re-opened that
[07:03:52] <joelteon> hmm
[07:03:54] <joelteon> where did unwrap go?
[07:04:01] <joelteon> it doesn't seem to be in std::option anymore
[07:04:01] <dbaupp> joelteon: it looks like you're not mean to get one directly; but just rt::uvio::UvIoFactory(foo) (where foo : rt::uv::Loop)
[07:04:06] * dbaupp doesn't really know
[07:04:06] <joelteon> I see it now, dbaupp 
[07:04:09] <dbaupp> joelteon: a method
[07:04:28] <joelteon> yeah, huh. that's usually the story now
[07:04:31] <dbaupp> rusti: Some(1).unwrap()
[07:04:32] -rusti- 1
[07:05:06] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[07:05:06] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ee60cb0 to 142a7be1c: 02http://git.io/N3iJvQ
[07:05:06] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[07:05:16] <strcat> wtf bors
[07:05:57] * dbaupp thinks graydon will frown at strcat for these shenanigans.
[07:06:04] <strcat> alright just going to trust that try was enough and do a rollup
[07:06:07] <strcat> dbaupp: doubt it ;p
[07:06:18] <strcat> bors should be able to handle that ;)
[07:06:23] * dbaupp just wanted to say "shenanigans"
[07:07:23] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:07:24] <ghrust> 01[13rust01] 15thestinger pushed 4 new commits to 06master: 02http://git.io/Exyluw
[07:07:24] <ghrust> 13rust/06master 14b3ad685 15Daniel Micay: replace all remaining `for` with `foreach` or `do`
[07:07:24] <ghrust> 13rust/06master 14b41d047 15Daniel Micay: make `for` parse as `foreach` does...
[07:07:24] <ghrust> 13rust/06master 1487cf286 15Daniel Micay: rm obsolete documentation on `for`...
[07:07:26] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:08:10] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[07:08:10] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147b1b6a4 to 14deddb00: 02http://git.io/N3iJvQ
[07:08:10] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[07:08:11] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[07:08:11] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/zPZvjg
[07:08:11] <ghrust> 13rust/06auto 14f637c85 15OGINO Masanori: Remove unused variables....
[07:08:11] <ghrust> 13rust/06auto 148dc8247 15OGINO Masanori: Rename sum -> _sum....
[07:08:11] <ghrust> 13rust/06auto 1466529af 15OGINO Masanori: Move `use` statements....
[07:08:12] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[07:08:12] <dbaupp> strcat: fun fact, non-bors merges make the benchmakers less useful.
[07:08:21] * strcat shrugs
[07:08:58] <dbaupp> strcat: you gotta care, this stuff's important! :P
[07:09:11] <strcat> bors pissed me off ;[
[07:09:19] * strcat has been working on this for hours and ran it through try twice
[07:09:40] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[07:09:40] <ghrust> 01[13rust01] 15thestinger created 06rollup (+2 new commits): 02http://git.io/LRtRUA
[07:09:40] <ghrust> 13rust/06rollup 14eab749a 15toddaaro: modified logging function to truncate output and adjusted error output formatting tests to be compatible with both the new and old runtimes
[07:09:40] <ghrust> 13rust/06rollup 141f9c392 15toddaaro: fixed the buffer to make it a more reasonable size
[07:09:41] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[07:11:22] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[07:11:22] *** Joins: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net)
[07:11:22] <ghrust> 01[13rust01] 15thestinger pushed 1 new commit to 06rollup: 02http://git.io/Py9XPQ
[07:11:22] <ghrust> 13rust/06rollup 1454e685d 15Kevin Ballard: option: mutate() and mutate_default() should return bool...
[07:11:22] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[07:11:40] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[07:11:49] <strcat> dbaupp: bors gets really messed up by the long queue btw
[07:12:03] <dbaupp> strcat: yeah, his stuff is O(n), right?
[07:12:12] <strcat> yeah but github API requests fail all the time
[07:12:16] <dbaupp> O(n) unreliable github request
[07:12:17] <dbaupp> s
[07:12:19] <dbaupp> yup
[07:12:24] <strcat> so it will get a partial view of the updates
[07:12:29] <strcat> and also they have eventual consistency
[07:13:22] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[07:13:22] <ghrust> 01[13rust01] 15thestinger pushed 2 new commits to 06rollup: 02http://git.io/mGksWw
[07:13:22] <ghrust> 13rust/06rollup 14fbb7cd3 15Huon Wilson: std: use ptr.offset where possible in the vec iterator....
[07:13:22] <ghrust> 13rust/06rollup 141992765 15Huon Wilson: std: add benchmark for vec.mut_iter.
[07:13:22] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[07:13:26] *** Joins: jaen (jaen@moz-C6EFC57A.play-internet.pl)
[07:13:33] *** Quits: eatkinson (eatkinson@moz-AD233F1B.dia.static.qwest.net) (Quit: eatkinson)
[07:13:53] <joelteon> is there some function I have to call when I'm using the rt subsystem?
[07:14:02] <joelteon> I keep getting assertion failures and whatnot
[07:14:06] <strcat> dbaupp: bors totally broke anyway
[07:14:09] <strcat> the 2 PR thing
[07:14:13] <dbaupp> joelteon: do you have RUST_NEWRT=1?
[07:14:22] <strcat> needs an off switch
[07:14:25] <joelteon> no
[07:14:34] <joelteon> ahh, there we go
[07:14:46] <joelteon> different failure this time
[07:15:08] <joelteon> one sec
[07:16:03] <doener> aatch: is there a reason why you chose to make Type a regular struct instead of a newtype one?
[07:16:18] <aatch> doener, not really, no
[07:17:14] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[07:17:14] <ghrust> 01[13rust01] 15thestinger pushed 1 new commit to 06rollup: 02http://git.io/vOdizQ
[07:17:14] <ghrust> 13rust/06rollup 1475155cd 15Kevin Ballard: Explicitly impl Clone for RWArc...
[07:17:14] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[07:17:20] <doener> aatch: ok, good
[07:17:22] *** Joins: jviereck (Adium@moz-36D78475.ethz.ch)
[07:17:44] <strcat> dbaupp: rollups will screw up benchmarking too ;p
[07:17:54] <dbaupp> strcat: yup
[07:18:09] <strcat> although in this one there's only 1 thing relevant to it so far (ptr.offset)
[07:18:24] <dbaupp> strcat: e.g. http://huonw.github.io/isrustfastyet/mem/#f132401,5102853
[07:18:37] <dbaupp> we have no idea what caused that drop.
[07:18:56] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Ping timeout)
[07:19:12] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[07:19:33] <strcat> nothing
[07:19:34] <strcat> ;p
[07:19:41] <strcat> benchmarker errata imo
[07:19:54] <dbaupp> seems fairly unlikely
[07:20:09] <dbaupp> (given it was is consistent before and after.)
[07:20:10] <strcat> https://github.com/thestinger/rust/commit/8d3bb7eb306993430e5f5acf3e3fbf22d7a9d97f unless that did it ;\
[07:20:18] <strcat> dbaupp: yeah but maybe cmr altered something
[07:20:50] <dbaupp> strcat: maybe.
[07:21:08] <joelteon> what's the best way to create an 8192-element vector of 0s?
[07:21:09] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[07:21:09] <ghrust> 01[13rust01] 15thestinger pushed 3 new commits to 06rollup: 02http://git.io/5ChTQQ
[07:21:09] <ghrust> 13rust/06rollup 14afaca4c 15OGINO Masanori: Remove unused variables....
[07:21:09] <ghrust> 13rust/06rollup 146829397 15OGINO Masanori: Rename sum -> _sum....
[07:21:09] <ghrust> 13rust/06rollup 14def8891 15OGINO Masanori: Move `use` statements....
[07:21:11] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[07:22:18] <dbaupp> joelteon: what sort of vector?
[07:22:23] <joelteon> a mutable owned one
[07:22:26] <dbaupp> joelteon: ~[0, .. 8192]
[07:22:36] <dbaupp> (or vec::from_elem(8192, 0))
[07:23:04] <joelteon> i like the first one better
[07:23:36] <joelteon> neat, thanks dbaupp 
[07:24:55] <joelteon> and it looks like SSL support is still in progress
[07:24:56] <strcat> dbaupp: https://github.com/mozilla/rust/pull/8257 anyway just doing these
[07:24:59] <doener> dbaupp: I'd guess the drop in that rollup was due to https://github.com/mozilla/rust/commit/a87c2d1
[07:25:22] <strcat> doener: I thought printfln! just did that internally
[07:25:58] <joelteon> aw man, I thought the newest commit message was about a different TLS :(
[07:25:59] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[07:25:59] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14cbe9ca4 to 14deddb00: 02http://git.io/N3iJvQ
[07:25:59] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[07:25:59] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[07:25:59] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/zer4fw
[07:25:59] <ghrust> 13rust/06auto 1420fad0f 15bors: auto merge of #8257 : mozilla/rust/rollup, r=thestinger...
[07:25:59] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[07:26:06] <strcat> anyway going to do a snapshot soon
[07:26:18] *** Quits: jviereck (Adium@moz-36D78475.ethz.ch) (Quit: Leaving.)
[07:26:34] <strcat> that's why I didn't feel like waiting another 3 hours ;p
[07:27:11] <doener> strcat: the divergence starts in the expansion phase, and that's the only thing that matters for that, AFAICT
[07:27:14] *** Joins: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de)
[07:27:54] <doener> strcat: smaller initial ast + different fragmentation behaviour, maybe?
[07:28:06] <doener> anyway, doesn't matter
[07:33:46] *** Joins: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr)
[07:34:52] *** Joins: webber46 (webber46@moz-717E9C5B.cust.bredband2.com)
[07:34:58] <strcat> doener: something like that ;]
[07:35:45] <strcat> 3 days to get rid of for, not bad
[07:35:48] <strcat> really 2 days
[07:38:52] <joelteon> ok, so I don't get this
[07:39:09] <joelteon> rt has a Reader trait that provides a read() method for reading from a socket into a mut vector
[07:39:36] <joelteon> but it uses the actual current length of the vector
[07:39:50] <joelteon> so if it's full of nulls, you get a big-ass string back that's full of nulls
[07:40:29] <joelteon> oh, or I could do from_bytes_with_null...
[07:41:31] <joelteon> oh, well, but that doesn't really work either
[07:42:12] <dbaupp> joelteon: doesn't it return the number of bytes read?
[07:42:19] <joelteon> let me check
[07:42:37] <dbaupp> joelteon: so something like `let len = foo.read(buf); str::from_bytes(buf.slice_to(len))`
[07:42:43] <joelteon> oh, it totally does
[07:42:47] <joelteon> haha, look at me
[07:43:03] <strcat> dbaupp: rusti will be updated soon ;p
[07:43:43] <doener> cmr: hm, actually a good bit of time is (indirectly) spent by using the RNG, because it's pulled out of TLS for every use
[07:44:13] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[07:45:22] <sam113101> where are the benchmarks?
[07:46:02] <dbaupp> sam113101: which benchmarks?
[07:46:20] <sam113101> that showed how fast was rust, or something like that
[07:46:23] <sam113101> can't remember
[07:46:27] <sam113101> it was a graph
[07:46:36] <dbaupp> sam113101: http://huonw.github.io/isrustfastyet/mem/
[07:46:44] <dbaupp> sam113101: (it's in the status line :P )
[07:46:54] <sam113101> thanks
[07:47:00] <dbaupp> doener: acrichto said that we could/should convert TLS to use a hashmap
[07:47:11] <dbaupp> doener: which could help with that
[07:47:25] <sam113101> I don't know how to scroll my status line rofl
[07:47:30] <acrichto> if you're worried about performance hitting TLS a lot isn't the best idea in general probably
[07:47:33] <acrichto> if it can be avoided
[07:48:02] <dbaupp> acrichto: https://github.com/mozilla/rust/pull/8258 r?
[07:48:18] <doener> dbaupp: maybe, the point is that the benchmark was supposed to be about fmt!(), but maybe 20% of the time are spent in the rng-related code
[07:48:28] <dbaupp> doener: yup
[07:48:38] <acrichto> dbaupp: oh that's big, I've got a long train ride tomorrow so is it ok if I postpone it till then?
[07:48:44] <dbaupp> acrichto: not at all
[07:48:51] * dbaupp is in no rush
[07:49:06] <doener> and with a trivial change in int_to_str_bytes_common, the rng dominates my reduced test case :-)
[07:49:15] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[07:49:21] *** Quits: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Connection reset by peer)
[07:49:24] <dbaupp> doener: what trivial change?
[07:50:01] <doener> dbaupp: avoiding bounds checks at the end, using an iterator...
[07:50:04] *** Joins: doomlord (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[07:50:19] <dbaupp> doener: oh? the mut_iter is fast now?
[07:50:23] <acrichto> dbaupp: fancy!
[07:50:26] *** Quits: jaen (jaen@moz-C6EFC57A.play-internet.pl) (Ping timeout)
[07:50:28] <strcat> dbaupp: http://www.reddit.com/r/rust/comments/1jm8b2/the_for_loop_is_dead_long_live_the_for_loop/
[07:50:42] <strcat> it will get faster ;p
[07:50:45] * dbaupp upvotes
[07:50:49] <acrichto> strcat: nice job!
[07:50:57] <doener> dbaupp: no, there's a second loop
[07:51:02] <strcat> acrichto: thanks ;]
[07:51:05] <strcat> going to snapshot
[07:51:08] * dbaupp brings up the code
[07:52:02] <dbaupp> doener: oh, the while loop calling f?
[07:52:16] <doener> dbaupp: yeah, but my bench was bogus, I accidently used a constant
[07:53:07] <doener> yeah, actually no change in runtime
[07:53:24] * dbaupp got all excited
[07:53:37] <doener> it was just too good to be true
[07:54:51] * ChrisMorgan is enjoying implementing augmented assignment everywhere
[07:55:34] <doener> dbaupp: mut_iter doesn't cause a slowdown anymore though
[07:55:50] <doener> even slightly faster
[07:55:59] <dbaupp> ChrisMorgan: do you have the langitem working?
[07:56:05] <doener> 850ms => 810ms
[07:56:06] <ChrisMorgan> dbaupp: no, that comes next
[07:56:39] <strcat> doener: it's about to get faster ;[
[07:56:41] <strcat> ;p *
[07:56:44] <dbaupp> ChrisMorgan: awesome! (you should comment on the issue saying you're working on it, if you are, btw; there's been several instances of work-scooping recently)
[07:56:49] <dbaupp> strcat: why so sad :P
[07:56:56] <strcat> typos make me sad, apparently
[07:57:00] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzz)
[07:57:07] <dbaupp> doener: nice
[07:57:29] <ChrisMorgan> For some reason or other I decided to implement (Add|Sub|Mul|Div|Rem|BitOr|BitAnd|BitXor|Shl|Shr)Assign wherever \1 was implemented before actually making it useful.
[07:57:35] <ChrisMorgan> True, I should indicate that.
[07:58:14] <strcat> hm, I can't complain about for loops or headers anymore
[07:58:16] <strcat> what now? ;p
[07:58:35] <dbaupp> strcat: unicode still sucks
[07:58:49] <strcat> yeah but I don't care about to complain and then fix it :)
[07:59:34] <dbaupp> I guess you're finished with Rust then.
[07:59:34] <dbaupp> bye. o/
[07:59:57] <strcat> ;)
[08:00:47] <ChrisMorgan> strcat: your next task is simply to make everything (yes, *everything*) twice as fast.
[08:00:49] <dbaupp> strcat: you could start with E-Easy issues, to get your feet wet :P
[08:01:18] <ChrisMorgan> Oh, by the way, the task after that is the same thing, so don't bother getting speed-ups of more than a factor of two this time.
[08:01:33] <strcat> maybe I'll fix bools
[08:03:00] <dbaupp> ChrisMorgan: have you got ragel to work?
[08:03:04] <dbaupp> (out of interest)
[08:03:07] <ChrisMorgan> Haven't tried yet.
[08:03:26] <ChrisMorgan> Went attacking this augmented assignment matter first.
[08:03:27] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[08:04:00] <dbaupp> strcat: (don't forget to add the for migration guide to the wiki :) )
[08:04:06] <dbaupp> ChrisMorgan: yup, sounds good
[08:04:11] * dbaupp wants real +=
[08:04:20] <strcat> dbaupp: yeah, I will
[08:04:29] <strcat> I want to improve the tutorial more first though
[08:05:10] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[08:05:26] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:05:34] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:05:47] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:06:09] <strcat> rusti: 2
[08:06:13] -rusti- 2
[08:06:59] <strcat> rusti: ()
[08:07:02] -rusti- ()
[08:07:10] <dbaupp> rusti: botsnack
[08:07:11] -rusti- <anon>:5:9: 5:17 error: unresolved name `botsnack`.
[08:07:12] -rusti- <anon>:5          botsnack
[08:07:12] -rusti-                   ^~~~~~~~
[08:07:12] -rusti- error: aborting due to previous error
[08:07:12] -rusti- application terminated with error code 101
[08:07:15] <dbaupp> :'(
[08:07:24] <strcat> my internet is being terrible
[08:07:31] <strcat> rusti: unsafe { std::cast::transmute(()) }
[08:07:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HaOW
[08:07:53] <strcat> rusti: enum Foo {} unsafe { let x: Foo = std::cast::transmute(()) }
[08:07:54] -rusti- <anon>:5:68: 5:69 error: expected `;` but found `}`
[08:07:54] -rusti- <anon>:5          enum Foo {} unsafe { let x: Foo = std::cast::transmute(()) }
[08:07:54] -rusti-                                                                              ^
[08:07:54] -rusti- application terminated with error code 101
[08:08:00] <strcat> rusti: enum Foo {} unsafe { let x: Foo = std::cast::transmute(()); x }
[08:08:01] -rusti- rust: task failed at 'enum value matched no variant', /build/rust-git/src/rust/src/libstd/repr.rs:521
[08:08:01] -rusti- rust: domain main @0x1876100 root task failed
[08:08:01] -rusti- application terminated with error code 101
[08:08:03] <dbaupp> rusti: unsafe { std::cast::transmute::<(), std::util::Void>(()) }
[08:08:04] -rusti- rust: task failed at 'enum value matched no variant', /build/rust-git/src/rust/src/libstd/repr.rs:521
[08:08:04] -rusti- rust: domain main @0x1233100 root task failed
[08:08:05] -rusti- application terminated with error code 101
[08:08:28] <strcat> rusti: let x: @int = std::cast::transmute(~5); x
[08:08:28] -rusti- <anon>:5:23: 5:48 error: call to unsafe function requires unsafe function or block
[08:08:28] -rusti- <anon>:5          let x: @int = std::cast::transmute(~5); x
[08:08:29] -rusti-                                 ^~~~~~~~~~~~~~~~~~~~~~~~~
[08:08:29] -rusti- error: aborting due to previous error
[08:08:29] -rusti- application terminated with error code 101
[08:08:37] <strcat> rusti: unsafe { let x: @int = std::cast::transmute(~5); x }
[08:08:43] <dbaupp> strcat: you should suggest small-caps in the current up/down-case bikeshed :P
[08:08:49] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[08:09:15] <ChrisMorgan> Hey, I have an idea for rusti: instead of just saying "more than 5 lines of output", also indicate how many lines there were. It will occasionally be helpful meaning you don't need to actually look at it.
[08:11:15] <strcat> rusti: 2 + 5
[08:11:15] -rusti- 7
[08:11:22] <strcat> ChrisMorgan: I could do that
[08:11:42] <ChrisMorgan> OK, lang item time. Are the existing numbers in rustc::middle::lang_items::LangItem sacred?
[08:11:52] <strcat> yes
[08:12:00] <strcat> if you change them you have to change the 2 other places the numbers matter
[08:12:13] <strcat> they're in the same file
[08:12:24] <strcat> well, there are 2 arrays with the # of lang items
[08:12:34] <strcat> 41 or something
[08:12:46] <strcat> and then the enum with the comments, and then a match expression with indexes
[08:12:57] <strcat> and then it needs to push them into the array in the right order, for the match expression indices to match
[08:13:04] <strcat> yay horrible anti-pattern
[08:13:33] <strcat> it's worse in token.rs, because not *only* does it do all of that, but it also hardcodes numbers in 3 more match expressions so say which things are keywords/reserved
[08:13:39] <strcat> + hardcodes numbers in structs
[08:13:41] <strcat> >.<
[08:14:21] * ChrisMorgan is wondering whether to put *AssignTraitLangItem in the middle, modifying most of the indices of the langitems, or at the end, where they will be out of place
[08:14:45] <dbaupp> ChrisMorgan: middle
[08:15:09] <dbaupp> strcat: that something to fix too ;)
[08:15:12] <strcat> ChrisMorgan: pastebinned N lines of output?
[08:15:14] <strcat> hm
[08:15:31] <ChrisMorgan> Anything.
[08:15:34] <acrichto> I wonder if an iterator macro would work well for those
[08:15:56] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[08:16:01] <acrichto> can macros take macros as arguments?
[08:16:09] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:16:09] <dbaupp> acrichto: depends what you mean
[08:16:15] <strcat> rusti: 2
[08:16:16] -rusti- 2
[08:16:19] <strcat> rusti: aaaaaa aaaaaaaaaa 
[08:16:19] -rusti- <anon>:5:16: 5:26 error: expected `;` or `}` after expression but found `aaaaaaaaaa`
[08:16:19] -rusti- <anon>:5          aaaaaa aaaaaaaaaa 
[08:16:19] -rusti-                          ^~~~~~~~~~
[08:16:19] -rusti- application terminated with error code 101
[08:16:22] <strcat> rusti: [
[08:16:22] -rusti- <anon>:6:4: 6:5 error: incorrect close delimiter: `}`
[08:16:23] -rusti- <anon>:6     };
[08:16:23] -rusti-              ^
[08:16:23] *** concrete.mozilla.org sets mode: +M 
[08:16:24] -rusti- application terminated with error code 101
[08:16:25] <strcat> dammit
[08:16:30] <strcat> rusti: dagdsg::dgsad
[08:16:31] -rusti- pastebinned 11 lines of output: http://sprunge.us/EZGV
[08:17:06] * ChrisMorgan adds 12 more langitems and so gets to use 12<C-A> all down the line... yay vim!
[08:17:34] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[08:17:34] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[08:18:11] <strcat> rusti: 2
[08:18:12] -rusti- 2
[08:20:06] <strcat> http://buildbot.rust-lang.org/grid?branch=snap-stage3&refresh=15 :)
[08:21:22] *** concrete.mozilla.org sets mode: -M 
[08:30:00] <aatch> ChrisMorgan, vim's visual modes are awesome.
[08:38:49] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[08:41:33] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[08:41:59] *** Quits: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP) (Connection reset by peer)
[08:43:43] *** Joins: Ms2ger (Ms2ger@EDC982F3.6890FC55.187A1082.IP)
[08:43:49] *** Joins: yong (chatzilla@89F941DF.4E87ADC2.263D9828.IP)
[08:48:03] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[08:48:23] <acrichto> cmr: for the fmt! benchmark on reddit, I just got ifmt! to take half the time :)
[08:48:44] <doener> acrichto: awesome :-)
[08:49:03] <acrichto> 22% of the time is now in random generation
[08:49:26] <acrichto> I think we should speed up local data
[08:49:31] <acrichto> it's kinda super slow...
[08:50:37] <dbaupp> acrichto: how?
[08:50:45] <dbaupp> (how is ifmt! faster, that is.)
[08:51:06] <acrichto> dbaupp: there's only one allocation performed for an entire call to ifmt!, and it's preallocated to 128bytes (which was a larger opt than I thought)
[08:51:18] <dbaupp> acrichto: ah, neat.
[08:51:40] <acrichto> now it just looks like int_to_str_bytes_common is the super slow one
[08:52:21] <dbaupp> acrichto: "Other structures are not sufficient right now: * HashMap uses ~[T] internally (push reallocates/moves)" (in task_local_priv.rs)
[08:53:03] <acrichto> dbaupp: it's tricky
[08:53:09] <acrichto> look on line 294
[08:53:19] <acrichto> I think that the way that's done supercedes that comment
[08:53:26] <acrichto> such that HashMap should be able to be used
[08:53:33] <acrichto> although I haven't given it a huge amount of thought yet
[08:53:51] *** Joins: Aetherspawn_BNC (uid6924@moz-31ABA2C0.irccloud.com)
[08:54:31] <dbaupp> it looks like we should just re-find the appropriate position to return the loan
[08:54:40] <dbaupp> (since it could get invalidated in the closure.)
[08:54:41] <acrichto> yeah that's what it has to do anyway
[08:54:47] <acrichto> I thought it could get around it using a vector
[08:54:53] <acrichto> but I think I just forgot to update that comment
[08:55:20] <acrichto> I'm also not sure if this would actually be faster for generating random numbers
[08:55:31] <acrichto> hash lookups are actually pretty expensive
[08:55:32] <dbaupp> yeah, it says Hence we do another lookup here to            // fixup the loans. ... but there doesn't appear to be another look up.
[08:55:44] <acrichto> especially when the lookup is compared to like a 3 element vector
[08:55:51] <acrichto> but who knows :)
[08:55:57] <acrichto> I do believe that a hash map would work
[08:56:00] <acrichto> so long as you re-look it up
[08:56:09] <dbaupp> (lesson of the day: use `let r = task_rng();` ... r.gen() in tight loops.)
[08:56:39] <acrichto> yeah that's hard to explain to someone new though :(
[08:56:45] <dbaupp> yup
[08:56:51] <acrichto> in theory TLS lookups should be pretty cheap
[08:57:04] <dbaupp> yeah, we need a faster hash
[08:57:34] <acrichto> this may not need a faster hash, but rather just a different map thing
[08:57:46] <acrichto> I kinda like how hashmap by default has a nice and good hash
[08:57:51] <dbaupp> acrichto: oh. I think I understand the re-lookup comment, the reindex into map[i].
[08:58:22] <dbaupp> yeah, but we could have it designed so that you can chose the hash and it defaults what we currently have.
[08:58:35] <acrichto> or even better, parameterize over it!
[08:58:43] <dbaupp> yeah, that's what I was meaning ;)
[08:59:10] <acrichto> TreeMap may also be pretty good here
[08:59:16] <acrichto> then you also wouldn't have to do the re-lookup
[08:59:30] <acrichto> b/c the nodes aren't moving around in memory
[08:59:37] <acrichto> but sadly TreeMap is in extra :(
[09:00:09] *** Joins: jaen (jaen@moz-C6EFC57A.play-internet.pl)
[09:00:15] <dbaupp> that sounds like a reasonable argument for moving it to std
[09:00:38] <dbaupp> (or, at least, having some stable non-O(n) map in std.)
[09:00:45] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[09:00:59] <strcat> trie, if you have uints ;p
[09:01:38] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[09:01:42] <dbaupp> strcat: does trie use u8 or each bit as the "characters" for each branch?
[09:01:50] <strcat> it chunks it
[09:01:56] <dbaupp> how big?
[09:02:06] <acrichto> strcat: what a point a pointer casted to a uint?
[09:02:09] <strcat> configurable, if we could pass integer type params ;p
[09:02:17] <strcat> forget what it's set to atm
[09:02:25] <strcat> static SHIFT: uint = 4;
[09:02:27] <strcat> static SIZE: uint = 1 << SHIFT;
[09:02:29] <strcat> static MASK: uint = SIZE - 1;
[09:02:39] <strcat> it splits 16 ways each time
[09:02:43] *** Quits: kkris (kkris@moz-CB70009.yourvserver.net) (Quit: Coyote finally caught me)
[09:02:47] *** Joins: kkris (kkris@moz-CB70009.yourvserver.net)
[09:02:50] <strcat> acrichto: yes that will work
[09:03:10] <ChrisMorgan> I'm concerned about this and presume I don't understand it. Why on line at https://github.com/mozilla/rust/blob/master/src/librustc/middle/cfg/construct.rs#L389 are l and r swapped, while on line 395 they are not?
[09:03:10] <acrichto> well the keys are just addresses, so that may actually work pretty well
[09:03:18] <strcat> acrichto: look at src/test/bench/core-map.rs for an idea of how it performs
[09:03:22] <strcat> it eats a fair bit of memory atm though
[09:03:34] <strcat> not *that* much
[09:03:38] <strcat> but it should be a lot better
[09:03:42] <strcat> need to teach it to use buckets
[09:03:50] <dbaupp> ChrisMorgan: ask nmatsakis 
[09:04:02] <acrichto> strcat: I'm not sure if TLS lookup is really that big of a problem anyway
[09:04:16] <ChrisMorgan> nmatsakis: are you able to explain that thing?
[09:04:51] <dbaupp> ChrisMorgan: wait, it's presumably because information flows from l -> r for `l = r`, but `l + r` goes l -> r
[09:04:58] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[09:04:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/qpQ1bQ
[09:04:58] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[09:05:00] <dbaupp> *r = l
[09:05:04] * dbaupp made no sense at all
[09:05:23] * dbaupp doesn't think what he said was at all correct
[09:05:32] <aatch> ChrisMorgan, the list is the evaluation order of the parameters
[09:05:42] <strcat> dbaupp: I guess the snapshots are going to ruin the bench anyway? not sure where those build now
[09:05:55] <dbaupp> strcat: hm?
[09:06:05] <dbaupp> strcat: oh, the buildbot bench?
[09:06:06] <aatch> ChrisMorgan, so with `a = b`, the evaluation order is `b`, then `a`.
[09:06:08] <strcat> dbaupp: yeah
[09:06:25] <dbaupp> strcat: the benches cmr runs are more useful, fwiw.
[09:06:31] <ChrisMorgan> Good, that makes sense. Thanks.
[09:06:40] <strcat> dbaupp: fast vector iterator landed ;]
[09:06:52] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[09:07:14] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[09:07:57] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[09:07:57] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/03YO_Q
[09:07:57] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[09:08:07] <dbaupp> strcat: awesome
[09:08:22] *** Quits: KindOne (KindOne@187DC4EC.E114B4AE.EC6A1518.IP) (Ping timeout)
[09:08:26] <ChrisMorgan> So if, for example, we had `a().b = a().b`, RHS is evaluated before LHS, but for `a().b + a().b`, LHS before RHS.
[09:08:41] <kimundi> dbaupp: "<dbaupp> strcat: (but especially returning, because you end up with Map<Filter<...>>)" - Can't you introduce a typedef for that?
[09:08:50] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:09:01] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[09:09:06] <strcat> kimundi: or better, a type with a priv field to hide that impl detail
[09:09:19] <strcat> but it's boilerplate either way
[09:09:33] <dbaupp> kimundi: you can, but you still have to think about/write out the iterator chain twice
[09:09:37] <aatch> ChrisMorgan, yep. Because of things like moving and borrowing, it needs to be in that order, otherwise you end up with some weird cases.
[09:09:41] <strcat> having yield would fix it since you'd have an easy way to clear custom types
[09:09:42] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Connection reset by peer)
[09:09:44] <kimundi> true
[09:09:45] <dbaupp> strcat: that loses you all the nice iterator impls
[09:09:58] <ChrisMorgan> Yes, that's the order that makes sense, if you think long enough.
[09:10:00] <strcat> dbaupp: well you have to impl Iterator for it
[09:10:14] <dbaupp> strcat: yeah, which is much worse that the original situation ;)
[09:10:56] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[09:10:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/03YO_Q
[09:10:56] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[09:10:58] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[09:10:58] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/DV-Z0Q
[09:10:58] <ghrust> 13rust/06auto 14aa94dfa 15Kevin Ballard: str: Add method .into_owned(self) -> ~str to Str...
[09:10:58] <ghrust> 13rust/06auto 1439fafd6 15bors: auto merge of #8204 : kballard/rust/str-into-owned, r=graydon...
[09:10:58] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[09:12:59] *** Joins: KindOne (KindOne@5C8D8F5A.B11A32F.EC6A1518.IP)
[09:14:15] <doener> *sigh* memory peak usage is back at ~1.8G
[09:14:56] * ChrisMorgan decides to try building his changes now and see what immediately breaks
[09:15:11] <strcat> dbaupp: another nice drop from no more for ;p
[09:15:17] <dbaupp> doener: oh? :(
[09:15:20] <strcat> measured locally
[09:15:21] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[09:15:27] <dbaupp> strcat: how much?
[09:15:56] <strcat> 20s maybe
[09:15:58] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[09:16:04] <dbaupp> for librustc?
[09:16:04] *** Joins: onix (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP)
[09:16:10] <dbaupp> or the whole bootstrap?
[09:16:17] <strcat> whole thing ;p
[09:16:18] <doener> dbaupp: librustc
[09:16:21] *** Quits: onix (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[09:16:22] <ChrisMorgan> I must confess that once I'm getting to expr_binary and expr_assign_op I'm out of my depth, so I may not be able to actually complete augmented assignment, even apart from making sure LHS is only evaluated once.
[09:16:29] *** Joins: mib_r3mqqx (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP)
[09:16:36] <doener> dbaupp: oh, talking to strcat, nvm
[09:16:42] <dbaupp> doener: well, both
[09:16:46] * dbaupp is very efficient
[09:16:58] <strcat> anyway lot of dead code to rip out now
[09:17:07] <dbaupp> doener: I assume you've got no idea what caused it?
[09:17:17] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[09:17:42] <mib_r3mqqx> Is there a need for COM (Component Object Model) support for Rust?
[09:18:13] <doener> dbaupp: not yet, and I'm not yet sure if I want to look... It would just regress again tomorrow :-p
[09:18:49] <dbaupp> doener: cmr's currently redoing the benchmarker btw.
[09:19:00] <dbaupp> doener: (which is why we don't have that data yet.)
[09:19:14] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[09:21:03] <jensnockert> mib_r3mqqx: I think it would be cool?
[09:21:37] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[09:22:00] <Ms2ger> jensnockert, really? Having used COM, it's horrible :)
[09:24:17] <mib_r3mqqx> jensnockert: do you have any use cases in mind for rust users? apart from DirectX and activeX 
[09:24:26] <kimundi> strcat: Hm, how about a iterator_composer!(type Myname = Map<Filter<...>>) macro that expands to a struct with a private field and the necessary Iterator implemnetations?
[09:24:38] <strcat> maybe
[09:25:00] <kimundi> less boiler plate and implemnetation detail hiding
[09:25:01] <ChrisMorgan> Hmm... just come across a problem with AddAssign. Take this, from vec.rs: `impl<'self,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'self [T]`. Problem is, that doesn't let me `impl<'self, T: Clone, V: Vector<T>> AddAssign<V> for &'self mut [T]`, because there is no impl of `Add<V, &'self [T]>`â€”and what's more, that clearly wouldn't make sense.
[09:25:04] <mib_r3mqqx> Ms2ger: I use it everyday at work :O
[09:25:23] <strcat> rusti: 2
[09:25:24] -rusti- 2
[09:25:29] <dbaupp> ChrisMorgan: that's not a valid += impl anyway
[09:25:30] <Ms2ger> mib_r3mqqx, I use it every day in Gecko :)
[09:25:42] <ChrisMorgan> This has the result that one needs a ~[T] to use `vec += other`, and &'self mut [T] isn't enough.
[09:25:55] <mib_r3mqqx> Ms2ger: Isn't that XPCOM ?
[09:25:56] <ChrisMorgan> dbaupp: hmm? Why not?
[09:25:58] <dbaupp> ChrisMorgan: yes: ~[T] is the only thing that can be extended
[09:25:59] <strcat> rusti: for (x, y) in range(0, 3).zip(range(11, 14)) { printfln!("%d %d", x, y) }
[09:26:00] -rusti- 0 11
[09:26:00] -rusti- 1 12
[09:26:00] -rusti- 2 13
[09:26:00] -rusti- ()
[09:26:06] <dbaupp> ChrisMorgan: *only vector
[09:26:22] <Ms2ger> mib_r3mqqx, yeah, but that's essentially the same
[09:26:23] <strcat> now to rm all traces of foreach ;p
[09:26:40] <ChrisMorgan> Oh, yeah... sorry, forgot the difference there between ~ and &mut for vectors.
[09:26:51] <dbaupp> strcat: you'll have to doctor the irc logs, commit history and reddit's database :P
[09:27:09] <dbaupp> strcat: (and people's memory & browser histories & local repositories, I guess.)
[09:27:40] <aatch> What's this foreach?
[09:27:56] <ChrisMorgan> Sounds long. I'm glad Rust doesn't have it.
[09:28:22] <aatch> ChrisMorgan, yeah, I'd get confused with PHP
[09:29:12] <strcat> aatch: :)
[09:29:21] <mib_r3mqqx> Ms2ger: Curious...Does XPCOM has extensive tooling support (Development Environments) and libraries?
[09:29:57] <aatch> In all seriousness though, I'm glad it's `for <pat> in <expr>` instead of PHP'
[09:29:59] * ChrisMorgan wonders whether he could successfully slip in a PR which made $ valid for ident to make PHP types feel more at home
[09:30:22] <aatch> PHP's `foreach (<$expr> as <$var>)`
[09:30:23] <Ms2ger> mib_r3mqqx, not really
[09:30:45] <Seldaek> ChrisMorgan: believe me this is a welcome change :p
[09:32:07] <ChrisMorgan> Weird: &str has an Add impl, but ~str doesn't.
[09:32:38] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[09:32:44] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[09:33:59] <aatch> ChrisMorgan, ~str auto-slices to &str
[09:34:15] <aatch> rusti: ~"abc" + ~"de"
[09:34:15] -rusti- <anon>:5:18: 5:23 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[09:34:15] -rusti- <anon>:5          ~"abc" + ~"de"
[09:34:16] -rusti-                            ^~~~~
[09:34:16] -rusti- ~"abcde"
[09:34:22] <aatch> rusti: "abc" + ~"de"
[09:34:23] -rusti- <anon>:5:17: 5:22 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[09:34:23] -rusti- <anon>:5          "abc" + ~"de"
[09:34:23] -rusti-                           ^~~~~
[09:34:23] -rusti- ~"abcde"
[09:34:26] <aatch> rusti: "abc" + "de"
[09:34:26] -rusti- ~"abcde"
[09:34:27] <ChrisMorgan> Ah. But for AddAssign to work, it needs an Add impl for ~str... anything wrong with me adding one?
[09:34:36] <aatch> ChrisMorgan, not sure.
[09:35:07] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[09:35:07] <ghrust> 01[13rust01] 15thestinger 04deleted 06rollup at 14def8891: 02http://git.io/TSvmEA
[09:35:07] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[09:35:11] <aatch> ChrisMorgan, I'm not sure how method resolution interacts with auto-slicing/borrowing
[09:35:15] <aatch> (probably badly)
[09:35:50] <aatch> ChrisMorgan, from an aesthetic pov, there's nothing wrong as long as you document it.
[09:36:11] <ChrisMorgan> Otherwise I don't know if AddAssign would work for an LHS of ~str.
[09:36:48] <aatch> ChrisMorgan, can you not implement AddAssign without having an Add implementation?
[09:36:55] <aatch> That doesn't seem... ideal.
[09:37:30] <ChrisMorgan> Hmm. I'll need to think more about it and how it fits in with default impl and so on. Just now, g2g.
[09:37:31] *** Quits: webber46 (webber46@moz-717E9C5B.cust.bredband2.com) (Quit: webber46)
[09:39:10] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[09:43:11] <kimundi> HAHA
[09:43:45] <kimundi> I was just watching that recent air mozilla presentation about servo
[09:44:08] <kimundi> I was looking at the screen
[09:45:26] <kimundi> I noticed the rust sticker on the presenters notebook
[09:46:17] <kimundi> And then I thought "Wait a minute... wasn't I supposed to get one of those together with the shirt?"
[09:47:23] <kimundi> Long story short: It's good that I haven't cleaned up the packaging in the last two weeks it was laying around on the floor.
[09:49:52] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[09:49:57] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[09:50:42] <aatch> Oh, that reminds me. I finally got my shirt!
[09:51:44] *** Joins: robert (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net)
[09:51:57] <aatch> Also, I'm pretty sure I'm the only person in the country with a tshirt like this.
[09:52:15] *** Quits: jaen (jaen@moz-C6EFC57A.play-internet.pl) (Ping timeout)
[09:52:54] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:54:00] <cde> it is available for sale online?
[09:55:07] <robert> Hi, I'm pretty interested in contribute with the Rust project, but I do not have the enough knowledge to improve the language or the compiler. Is there any other way to contribute? PD: I am spanish (in case it is useful).
[09:55:37] <aatch> robert, well you could do spanish translations?
[09:55:43] <robert> Of course.
[09:56:00] <aatch> cde, not as far as I am aware. It was a gift for rust contributors.
[09:56:01] *** Joins: Earnestly (earnest@CAE8D902.48DC5685.39C00A7A.IP)
[09:56:49] <aatch> robert, well there are translation files for the documentation all set up. I don't know much about translation though, so I don't where you'd start.
[09:58:00] <robert> And what about the web?
[09:58:29] <aatch> robert, what do you mean?
[09:58:34] <cde> aatch: ok. I found a mug nonetheless :)
[09:58:48] <strcat> ughhh why do snapshots take so long
[09:59:03] <aatch> strcat, because the linux snapshot bot is old.
[09:59:03] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[09:59:26] <robert> I can translate it too. And I am web programmer so I could improve it if is required.
[10:02:13] <aatch> robert, well there's not much for the website, other than documentation and that's all generated by a rust tool.
[10:02:51] <aatch> You could jump into #rustdoc_wg if you want to help with the web side of the new rustdoc.
[10:03:31] <aatch> thats #rustdoc-wg sorry
[10:03:51] <robert> Right, I will. But How can I translate the docs? Are they in github?
[10:04:24] <kimundi> I'm not sure if translating the docs is a good idea right now...
[10:04:42] <kimundi> Seeing how they'rs just not... good
[10:06:04] <aatch> robert, kimundi does have a point, but yes, the docs are github. Specifically, there are .pot files. As I said though, I don't know how .pot files are supposed to work.
[10:06:24] <kimundi> robert: But anyway, even if the compiler itself scares you, work on the std library is also needed :) And things like modernizing the format of the doc comments, cheecking if they are still right in regard to the function they document, etc
[10:06:55] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[10:07:26] <kimundi> A big problem is that examples in doccomments are just not atomatic tested... so they age quickly
[10:07:58] <kimundi> I've seen a few thet still talk about a syntax like 'foo.chan { |bar| ... }'
[10:08:17] <robert> I see. In this case I will take a look at the std library.
[10:09:08] *** Quits: KindOne (KindOne@5C8D8F5A.B11A32F.EC6A1518.IP) (Ping timeout)
[10:12:20] <kimundi> robert: And don't feel scared to ask even trivial questions here in the channel. Rust has changed enough in the recent past that we can't expect anyone to learn how it works just by looking at the source or the crappy docs :)
[10:13:15] <ldunn> Ho hum. Should I be able to use ~-ptrs with zero.rs?
[10:13:21] *** Joins: KindOne (KindOne@moz-23830D44.dynamic.ip.windstream.net)
[10:13:24] *** Quits: goffrie (goffrie@moz-E416245D.dsl.ncf.ca) (Ping timeout)
[10:13:29] *** Joins: goffrie (goffrie@moz-3AD452E4.dsl.ncf.ca)
[10:13:48] <robert> Sure, all I hope not to be scared in the channel too xD.
[10:13:51] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[10:14:21] <aatch> ldunn, as long as you have a malloc impl.
[10:14:40] <jj2baile> Oh man, llvm
[10:14:43] <kimundi> ldunn: I think yes. ~ ptrs are just malloc and free, those should work
[10:14:47] <Luqman> acrichto: the bug with the updated llvm sorta found
[10:15:05] <ldunn> alright, hm. Thanks o/
[10:15:46] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[10:16:15] *** Joins: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com)
[10:18:22] *** Quits: robert (Mibbit@moz-11F9F15.red-83-37-58.dynamicip.rima-tde.net) (Quit: http://www.mibbit.com ajax IRC Client)
[10:21:20] <ldunn> It's curious, though. I don't have malloc/free since I'm messing with bare-metal stuff, but llvm core-dumps on me when I try to compile a function that returns a ~-ptr.
[10:21:36] <ldunn> I would have expected it to just compile with the stubs I provide and hang (the stubs are just jmp $)
[10:21:55] <aatch> ldunn, hmm, that's odd.
[10:22:07] <aatch> it should compile fine.
[10:22:32] <aatch> What target are you compiling for?
[10:23:06] <ldunn> i386-intel-linux
[10:23:42] <aatch> Hmm, that should work fine.
[10:23:51] *** Joins: lhatsk (Adium@moz-4D97378F.pool.mediaways.net)
[10:24:01] <ldunn> mmm. https://gist.github.com/ldunn/81400c2c58a361fd853c is the error
[10:24:58] <aatch> ldunn, hmm, and it's only when using zero.rs?
[10:26:33] <jj2baile> llvm code gen fails. Fix binary by editing it with vim
[10:26:52] <jj2baile> Props to Luqman 
[10:28:21] <ldunn> aatch: compiling with the same flags (apart from --target) and without zero.rs works fine
[10:28:42] <aatch> ldunn, what about with zero.rs and no --target?
[10:29:00] <aatch> I think it might be throwing a hissy fit about the target.
[10:29:21] <ldunn> core dumps with zero.rs and no --target
[10:29:40] * ldunn checks he didn't modify zero.rs in some stupid way and forget about it
[10:29:59] <aatch> ldunn, Oh, that might be it actually.
[10:30:25] <aatch> I don't think the lang-item functions are type-checked.
[10:30:44] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[10:31:44] <ldunn> nurp, core-dumps with zero.rs from pcwalton's repo too. 
[10:31:51] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[10:31:56] * ldunn git reset's his rust repo and rebuilds
[10:32:58] *** Quits: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net) (Ping timeout)
[10:39:25] *** Quits: mib_r3mqqx (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:40:59] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[10:41:24] *** Joins: mcclurmc (mcclurmc@moz-8D61EFD1.cable.virginmedia.com)
[10:41:49] <dbaupp> aatch: you got your shirt! :D (/me is confused that he got his a month ago, before many of the americans, even.)
[10:42:14] <aatch> dbaupp, apparently my one didn't get sent...
[10:42:29] <dbaupp> aatch: NZ, the forgotten country
[10:42:36] <aatch> dbaupp, :(
[10:42:38] * dbaupp is ok with that
[10:42:40] <dbaupp> :P
[10:43:46] *** Joins: codatory (textual@7A88C043.CC4A4609.503B7E4F.IP)
[10:44:34] <aatch> Grr, so much of rust treats android as an operating system.
[10:44:50] <dbaupp> ldunn: pcwalton's zero.rs is very old, so there's possibly a confounding factor there.
[10:45:24] <dbaupp> ldunn: https://github.com/huonw/rust-malloc/blob/master/zero.rs might work (?)
[10:46:14] <dbaupp> aatch: it's not?
[10:46:26] <aatch> dbaupp, nope. Technically it's an environment.
[10:46:26] <ldunn> hah, yes, that worked
[10:46:42] *** Quits: igl (igl@moz-5248A071.adsl.alicedsl.de) (Ping timeout)
[10:46:51] <aatch> In the triple, it's `arm-unknown-linux-androideabi`
[10:46:52] <dbaupp> aatch: oh, right; linux kernel + random cruft
[10:47:05] <aatch> That last bit is the "environment"
[10:47:27] *** Quits: mark_edward (quassel@moz-9631ECE3.public.wayport.net) (Ping timeout)
[10:47:50] * aatch is making target handling more sane
[10:47:57] *** Joins: igl (igl@moz-B96098E6.adsl.alicedsl.de)
[10:48:00] <dbaupp> aha, makes sense.
[10:48:23] <Luqman> aatch: the target triple isn't arm-unknown-linux-androideabi though
[10:48:32] <ldunn> cool, that gives much saner error messages in the bare-metal stuff too. Thanks all
[10:48:58] <aatch> Luqman, maybe not what's in the configure, but the one we pass to LLVM is.
[10:49:22] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[10:49:23] <dbaupp> ldunn: what are you working on? (out of interest)
[10:49:56] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[10:49:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/DV-Z0Q
[10:49:57] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[10:49:58] <ldunn> dbaupp: a toy kernel in as much Rust as possible
[10:50:02] <aatch> I tell a lie, it's arm-linux-androideabi
[10:50:10] <dbaupp> ldunn: ooh, awesome!
[10:50:21] <aatch> (Though LLVM will fill in the missing vendor)
[10:50:39] <aatch> I use a similar algorithm for parsing triples.
[10:50:59] <ldunn> I'm currently wrestling with passing unsafe pointers around, something's getting mangled somewhere
[10:52:29] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[10:52:52] <ldunn> oh! That was my other question. Including zero.rs in multiple files which include each other makes rustc complain about multiple definitions of the lang items it introduces. 
[10:52:54] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[10:52:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/T-fYLA
[10:52:54] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[10:53:07] <ldunn> I "fixed" this by removing that error from rustc and recompiling, but I suspect there is a better way to do it
[10:53:19] <ldunn> (it didn't seem to break anything :o)
[10:53:20] <dbaupp> ldunn: you don't want to use `mod` more than once.
[10:53:57] <dbaupp> ldunn: `mod` loads a file into the crate and sets up the module heirachy, `use` is how you should import items in other files.
[10:54:04] <ldunn> hrm.
[10:54:07] <ldunn> oh!
[10:54:39] <ldunn> I'm pretty  hazy on the crate/module/etc. business
[10:55:56] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[10:55:56] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/T-fYLA
[10:55:56] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[10:56:57] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:56:58] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[10:57:03] <codatory> Is there a searchable API doc for Rust by version? Ala ruby-doc.org?
[10:57:51] <dbaupp> codatory: not really.
[10:58:27] <dbaupp> codatory: although `site:http://static.rust-lang.org/doc/0.6/ foo bar` probably works in google
[10:59:56] <codatory> Bummer, google doesn't really have the syntactical intelligence to figure out I'm looking for a method called range vs the dozen or so other reasons to use the word "range" in documentation
[11:00:17] <dbaupp> we could probably help ;) what are you looking for?
[11:00:30] *** Quits: KindOne (KindOne@moz-23830D44.dynamic.ip.windstream.net) (Ping timeout)
[11:01:01] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[11:01:18] <aatch> codatory, as a general rule, searching for `fn <name>` works
[11:01:48] <aatch> (The joys of low parsing complexity)
[11:02:16] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[11:02:37] <codatory> I'm trying to go through Rust for Rubyists, which is all rust 0.6 using Rust 0.7 (because that's what homebrew installed), so I need to "upgrade" a bunch of syntax
[11:02:45] <dbaupp> aatch: https://github.com/mozilla/rust/pull/8186 r?
[11:03:26] <dbaupp> codatory: could you point us to the snippet you're looking at now? :)
[11:03:36] <dbaupp> aatch: (fwiw, pcwalton reviewed it previously... just merge conflicts.)
[11:03:57] *** Joins: nano (nano@moz-972880B.superkabel.de)
[11:04:00] <aatch> dbaupp, yep, done
[11:04:06] *** Joins: KindOne (KindOne@moz-23830D44.dynamic.ip.windstream.net)
[11:04:07] <dbaupp> aatch: thanks
[11:04:13] <codatory> fn main() {
[11:04:13] <codatory>     for int::range(1, 101) |num| {
[11:04:13] <codatory>         println(int::to_str(num));
[11:04:13] <codatory>     }
[11:04:13] <codatory> }
[11:04:41] <codatory> i've got the whole thing with iter().advance figured out, just need to generate the range
[11:04:50] <kimundi> codatory: In 0.7 your problem is that int is not imported by default in the prelude anymore
[11:04:56] <dbaupp> codatory: what does `rustc --version` say?
[11:05:17] <dbaupp> codatory: but as kimundi says, you need `use std::int` at the top of the file.
[11:05:35] <kimundi> for ::std::int::range(1, 101) |num| OR use std::int; for int::range(1, 101) |num|
[11:06:10] <kimundi> In current git however basically everthing of this loop is different :P
[11:06:43] <codatory> Yeah; completely different between 0.6, 0.7 and master
[11:07:11] <kimundi> today in git it would be 'for num in range(1, 101) { ... }', with the big difference that range() is now a funnction that returns an external iterator
[11:07:37] <rntz> is range also a trait method in master, or are you omitting the "int::"?
[11:08:21] <kimundi> todays range is something completly different than the old range
[11:08:36] <dbaupp> (fun fact: rust has had 2307 pull requests that have been closed.)
[11:09:01] <dbaupp> rntz: it's a function in std::iterator that is reexported by std::prelude, so it doesn't need a use.
[11:09:21] <dbaupp> rntz: (it's generic over Add+Ord+Clone, I think.)
[11:09:50] <kimundi> old: std::int::range() == function in the int module that taken an closure; new: std::iterator::range() == function in the iterator module that basically acts as an constructor for an RangeIterator object
[11:10:17] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:11:51] <codatory> Fun language, looking forward to 1.0 ;-)
[11:11:55] <rntz> dbaupp: aha, genericbdit is generic, good.
[11:12:08] <rntz> s/genericbdit/it/
[11:12:30] <aatch> 24 resolve errors to go.
[11:12:43] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[11:13:03] <rntz> although Add+Ord+Clone seems an odd combination.
[11:13:13] <dbaupp> rntz: currently the only range supported in that way is step-up-by-one, range_rev and range_step come later
[11:13:23] <dbaupp> rntz: in what way?
[11:13:27] <rntz> how do I "add one" with Add+Ord+Clone?
[11:13:40] <rntz> unless Add includes a "successor" method
[11:13:51] <rntz> or, ugh, a coercion from int.
[11:14:03] <dbaupp> nah, I forgot One. :)
[11:14:11] <rntz> blech blech blech :(
[11:14:18] <kimundi> Add+Ord+Clone+One
[11:14:29] <rntz> unless One is a misnamed descendant of Add
[11:14:32] <rntz> is it?
[11:14:34] <dbaupp> rntz: https://github.com/mozilla/rust/blob/master/src/libstd/iterator.rs#L1517-L1542
[11:14:42] <aatch> the range_step is Add+Ord+Clone though.
[11:14:43] <dbaupp> misnamed?
[11:14:51] <kimundi> rusti: One::one::<float>()
[11:14:52] -rusti- pastebinned 11 lines of output: http://sprunge.us/CBZP
[11:15:03] <kimundi> rusti: ::std::num::One::one::<float>()
[11:15:04] -rusti- 1
[11:15:04] <dbaupp> rusti: std::num::One::one::<float>()
[11:15:05] -rusti- 1
[11:15:20] <kimundi> rusti: ::std::num::One::one::<uint>()
[11:15:21] -rusti- 1
[11:15:26] <kimundi> rusti: ::std::num::One::one::<~str>()
[11:15:26] -rusti- <anon>:5:9: 5:37 error: failed to find an implementation of trait std::num::One for ~str
[11:15:26] -rusti- <anon>:5          ::std::num::One::one::<~str>()
[11:15:26] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[11:15:27] -rusti- application terminated with error code 101
[11:15:41] <kimundi> rusti: ::std::num::Zero::zero::<~str>()
[11:15:42] -rusti- ~""
[11:15:44] <rntz> basically I am suspicious about the way rust is going about organizing its traits
[11:15:55] <aatch> rusti: ::std::num::Zero::zero::<Option<~str>>()
[11:15:56] -rusti- None
[11:16:08] <rntz> because it seems ad hoc rather than motivated by well-known mathematical abstractions
[11:16:14] <dbaupp> rusti: std::num::Zero::zero::<&'static str>()
[11:16:15] -rusti- ""
[11:16:24] <kimundi> rntz: feel free reading throug the 100+ comments numeric bikeshadding issue on github ;)
[11:16:34] <dbaupp> rntz: it's *reasonably* close
[11:16:43] <dbaupp> rntz: https://github.com/mozilla/rust/issues/4819
[11:16:43] <rntz> just steal the way haskell does it :P
[11:16:48] <dbaupp> that's worse
[11:16:52] <kimundi> https://github.com/mozilla/rust/issues/4819
[11:16:55] <dbaupp> (unless you mean the numeric prelude)
[11:16:59] <rntz> what is worse?
[11:17:04] <aatch> rntz, what, you mean do pretty much exactly what we did?
[11:17:13] <dbaupp> rntz: Haskell, Num is wrong
[11:17:25] <rntz> I wasn't thinking of Num.
[11:17:38] <dbaupp> ("wrong" in the sense of encompassing too many things)
[11:17:40] <rntz> I was thinking of Enum, for the case of Range.
[11:17:47] <rntz> s/Range/range/
[11:17:56] <dbaupp> right; it's in the works.
[11:18:29] <dbaupp> as in, someone needs to implement it. ;P
[11:19:25] *** Quits: Uther (Instantbir@moz-1B244B05.hfc.dyn.abo.bbox.fr) (Ping timeout)
[11:30:24] *** Quits: cdidd (cdidd@moz-D1CFF15B.broadband.corbina.ru) (Ping timeout)
[11:45:50] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[11:49:03] *** Joins: cdidd (cdidd@moz-C645E30B.broadband.corbina.ru)
[11:49:46] *** Quits: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com) (Ping timeout)
[11:49:51] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[11:57:23] <aatch> Yay, my changes compile! Now lets see if they bootstrap.
[12:03:02] <doener> aatch: what are you working on?
[12:03:15] <aatch> doener, target handling.
[12:03:31] <aatch> Trying to make it a little more generic, extensible and unified.
[12:03:35] <doener> ah
[12:05:19] <aatch> doener, the long view on this is being able to at least generate code for pretty much any target LLVM supports.
[12:07:51] <aatch> Also, this is groundwork for improving the inline asm.
[12:10:13] <Luqman> aatch: speaking of which, found a rather amusing use for asm! today
[12:10:22] <aatch> Luqman, oh?
[12:10:30] *** Joins: feduser (feduser@25932DF4.AAE9A62C.650F25DA.IP)
[12:10:49] <Luqman> aatch: using it to insert nop's so we could hexedit the binary without messing up any offsets :P
[12:11:01] <aatch> Luqman, oh wow.
[12:11:05] <aatch> That is mad
[12:11:31] <Luqman> aatch: see the comments @ https://github.com/mozilla/rust/pull/7115
[12:12:57] <doener> yay, reached stage2 with a crash
[12:12:59] <aatch> Luqman, heh.
[12:13:09] <dbaupp> Luqman: do you know a fix?
[12:13:21] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[12:14:03] <aatch> I'm also going to try to get le32 support up
[12:14:19] <aatch> Which is useful for emscripten support.
[12:14:30] <Luqman> dbaupp: nope. no idea where to look in llvm
[12:14:46] <dbaupp> Luqman: doesn't LLVM do all the register allocation itself?
[12:14:56] <dbaupp> (so, in theory, this is an LLVM bug?)
[12:15:18] <Luqman> dbaupp: yes, i'm fairly sure this is an llvm bug and not rustc
[12:15:34] <dbaupp> cool; I guess.
[12:15:39] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[12:16:08] *** Quits: cde (cde@moz-593D124F.rev.dedibox.fr) (Client exited)
[12:21:49] <aatch> Cool, my changes didn't break anything, on linux anyway.
[12:22:26] <ldunn> always a plus
[12:22:28] <aatch> next step: make it actually decent.
[12:23:04] <aatch> Right now it's practically the same code as before, just via a ~Target trait object instead of a different struct.
[12:23:40] <dbaupp> aatch: not a @mut Trait object? :P
[12:24:50] <aatch> dbaupp, I do have some self respect, thankyouverymuch
[12:26:48] *** Quits: feduser (feduser@25932DF4.AAE9A62C.650F25DA.IP) (Quit: Leaving)
[12:27:54] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[12:32:07] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[12:33:31] <dbaupp> ChrisMorgan: btw, adding an Add for ~str should be fine
[12:33:41] * dbaupp actually thought he added one a while ago, but clearly not.
[12:33:42] <ChrisMorgan> Good. Thanks.
[12:34:56] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[12:34:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/z-YO8Q
[12:34:56] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[12:35:58] *** Joins: mib4pg (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP)
[12:36:53] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[12:37:53] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[12:37:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/MXRBbg
[12:37:53] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[12:41:06] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[12:44:42] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[12:45:51] <ChrisMorgan> r? https://github.com/mozilla/rust/pull/8251 (already approved, just a slight change madeâ€”removing highlighting of foreachâ€”and I think bors then wants approval again)
[12:46:39] *** Joins: mark_edward (quassel@moz-9631ECE3.public.wayport.net)
[12:57:35] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[12:59:06] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[12:59:33] *** Joins: mathrick (mathrick@B9391410.C760DD8D.1352A07E.IP)
[13:00:22] <mathrick> hiya, what's the point of having rust? Ie. given how much it's inspired by OCaml, why not cut out the middleman and just use OCaml?
[13:01:10] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[13:01:18] <mathrick> especially that, AFAIK, OCaml can interface with C just fine, and with the native compiler, it can generate code that's just as fast
[13:02:21] <dbaupp> yay, super-fast benchmarks https://github.com/mozilla/rust/issues/8261 \o/
[13:02:58] <mathrick> (not trying to troll, btw, I'm genuinely curious as to why you'd decide to go to the effort of designing and implementing a completely new language that isn't particularly compatible with either OCaml or C)
[13:02:59] <dbaupp> mathrick: different target spaces, e.g. OCaml doesn't allow precise, "manual" memory management.
[13:03:01] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[13:03:13] <mathrick> dbaupp: ah, even with the compiler hooks?
[13:03:26] <dbaupp> mathrick: OCaml compiler hooks?
[13:03:30] <mathrick> yeah
[13:03:40] <mathrick> from what little I know of its internals, it allows some rather extensive hooks to happen
[13:03:55] * dbaupp doesn't know anything about OCaml compiler internals
[13:05:07] <mathrick> dbaupp: and what use-cases are for manual memory management other than interfacing with C? Do you see it used in, say, Spidermonkey++ and its JIT or something along these lines?
[13:05:20] <mathrick> *are there
[13:05:48] <dbaupp> avoiding GC and its associated problems where necessary
[13:05:51] <doener> r? https://github.com/mozilla/rust/pull/8262
[13:05:58] *** Joins: sigma (sigma@moz-8A1E1A62.zone13.bethere.co.uk)
[13:07:03] <mathrick> dbaupp: sure, but when exactly is that a serious enough consideration to make designing a whole language worthwhile, rather than just using whatever optimisation hints you can for stack allocation and such?
[13:07:17] <dbaupp> mathrick: (also, Rust isn't *that* inspired by OCaml: it looks very different, and is semantically different.)
[13:07:23] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: brb)
[13:07:34] <dbaupp> mathrick: too much reliance on compiler magic
[13:07:38] *** Quits: sigma (sigma@moz-8A1E1A62.zone13.bethere.co.uk) (Ping timeout)
[13:07:55] <mathrick> the explicit borrowed pointers and friends are a very neat way of packaging up the semantics of C in a sane package, but they're really heavy-handed and invasive compared to optimisation hints
[13:07:58] <dbaupp> mathrick: a small change can mean that suddenly you get a huge slowdown because the optimiser can't cope with the new change.
[13:08:23] *** Joins: schnozzle (Mibbit@3624352C.AD379810.85518BE6.IP)
[13:08:50] <ChrisMorgan> dbaupp: I suppose your point with the "super-fast benchmarks" is that eliminating that code is undesirable?
[13:08:51] <mathrick> I guess, but then in Rust you have to deal with the opposite problem: you cannot just hint after you're done writing it, you have to write the code for the specific memory management style
[13:09:15] <dbaupp> ChrisMorgan: definitely; they're benchmarking the overhead of the benchmarking system
[13:09:43] <dbaupp> mathrick: right; have you used Rust much?
[13:10:24] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[13:10:25] <schnozzle> which version focus on rust on windows x64? is there any developer on windows x64?
[13:10:42] <mathrick> dbaupp: nope, reading about it because I've seen it described as "C invented by someone who only knew Haskell" (later corrected in comments to OCaml :), and I was curious as to why exactly you'd want to do all that work
[13:10:56] <dbaupp> mathrick: Just asking, because I've found that in practice, "writing for a specific memory management style" to be no bother: just use & everywhere.
[13:11:06] <dbaupp> (except when you can't, but the compiler tells you that.)
[13:11:18] <mathrick> I don't know OCaml as such, but it's on my hitlist and I've heard some very good things about ease of writing vs. speed compared to C vs. ease of interfacing with the C world
[13:11:55] <mathrick> dbaupp: oh, it does cause problems for real people, lemme find you the article that prompted it
[13:12:20] <mathrick> ah yes, here we go: http://me.veekun.com/blog/2012/11/17/a-little-bit-rusty/
[13:13:08] <mathrick> half of the issues there are "uh, that doesn't actually work even though it seems like a good idea" or "those two pointer styles live in disjoint worlds" or "that seems like it should work, but actually Rust just explodes"
[13:13:33] <dbaupp> mathrick: that article is actually too old to be relevant any more
[13:13:55] <dbaupp> there have been some big changes that mean that essentially everything that should work, does.
[13:13:59] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[13:14:14] <mathrick> has it changed fundamentally, ie. things like "I planned those to be unique pointers but then I found out I couldn't use it for anything" are now possible?
[13:15:16] <dbaupp> yes, the error complained about ("mutable, aliasable") no longer exists (or at least, I've not seen it for many months)
[13:16:06] <mathrick> dbaupp: btw, this is certainly just drive-by armchair design, but I find the idea of ; changing semantics of things to be really, really, really terrible. I'm willing to bet that it will be the #1 cause of confusion for newcomers and annoying bugs for veterans for years to come
[13:16:15] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[13:16:25] <mathrick> it's as bad an idea as switch() and break
[13:16:44] <dbaupp> mathrick: yeah, let's not bikeshed semicolons please. (it's been done to death.)
[13:17:24] <mathrick> I'm a lisper by choice, so for me the answer is obvious: just return the last value always :)
[13:18:01] <dbaupp> in any case, omitting a `;` is either a type error, or it works. very unlikely to accidentally cause a runtime bug.
[13:18:26] <engla> yes, Rust is much more strict about well-formedness of a program (compared to for rexample C)
[13:18:42] <mathrick> I guess with a real type system it's less of a problem
[13:18:42] <dbaupp> ("works" == type checks and compiles, which normally implies that's what you mean to do.)
[13:19:03] * mathrick glares in the general direction of JS and its idiotic implicit ; rules
[13:19:11] <engla> mathrick: and the type checker makes sure every branch of an `if` or `match` have the same type
[13:19:30] <mathrick> yeah, it just makes it hard to read for people
[13:19:46] <dbaupp> mathrick: fwiw, that article was pretty good; but Rust moves so fast that anything older than a few months is probably out of date.
[13:19:48] <mathrick> (different things should look different and all that)
[13:19:49] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:20:05] <dbaupp> they do look different, there's a whole character missing :P
[13:20:16] *** Quits: schnozzle (Mibbit@3624352C.AD379810.85518BE6.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:20:33] <mathrick> dbaupp: I definitely found it interesting in that it's a real-world, yet tractable problem being solved, which usually gives a good feel for what the practice of the language is
[13:21:41] <engla> this week  the for loop switched syntax and paradigms from internal to external iterators
[13:21:49] <engla> so things are moving fast ^^
[13:22:42] <mathrick> another question, how accurate and future-proof is the tutorial section on closures? It tells me that closures can either be closed over bindings and be forbidden from escaping, or be allowed to escape and then copy the environment, which is a good deal less expressive than the closures I'm used to. Is this still/going to stay true?
[13:23:20] <dbaupp> any/all parts of the documentation are either currently wrong or will at some point be wrong.
[13:23:37] <bjz> :P
[13:23:50] <mathrick> right, but what are the plans for closures? Do you want to have escaping, shared environment closures eventually?
[13:23:59] <dbaupp> there is that already
[13:24:07] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (Quit: brb)
[13:24:40] <dbaupp> rusti: fn foo() -> @fn() { let a = @1i; return || { println(a.to_str()) }; } foo()()
[13:24:41] -rusti- 1
[13:24:41] -rusti- ()
[13:25:02] <mathrick> dbaupp: so http://dl.rust-lang.org/doc/0.4/tutorial.html#closures <-- "A managed closure does not directly access its environment, but merely copies out the values that it closes over into a private data structure. This means that it can not assign to these variables, and cannot observe updates to them." <-- so this is no longer accurate?
[13:25:14] <bjz> rntz: https://github.com/mozilla/rust/pull/8049
[13:25:23] <dbaupp> mathrick: yeah, sounds wrong
[13:25:39] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[13:25:43] <dbaupp> mathrick: wait. that is the 0.4 documentation
[13:25:51] <bjz> haha
[13:26:07] <mathrick> oh, have I been reading a terribly outdated tutorial?
[13:26:10] <dbaupp> yup
[13:26:14] <bjz> mathrick: http://static.rust-lang.org/doc/tutorial.html
[13:26:18] <mathrick> damn
[13:26:34] <dbaupp> modern rust is much better :)
[13:26:40] <bjz> we are at the 0.7-.8 cycle, and rust moves fast
[13:26:47] <dbaupp> (e.g. things actually work :P )
[13:26:51] <bjz> hehe
[13:27:53] <dbaupp> that sentence is still there
[13:28:24] <dbaupp> rusti: fn mk_appender(suffix: ~str) -> @fn(~str) -> ~str {return |s| s + suffix;} mk_appender(~"foo")(~"bar")
[13:28:25] -rusti- ~"barfoo"
[13:28:54] <engla> there is a closure reform still in the pipeline
[13:28:57] <engla> so things will change
[13:29:12] <dbaupp> yeah, that seems like it does a bad implicit copy.
[13:29:19] <mathrick> FWIW, the current tutorial says the exact same thing about managed closures
[13:29:27] <dbaupp> yup
[13:29:53] * mathrick wades through the sea of punctuation in that snippet
[13:30:20] <dbaupp> it appears to be correct (in that that is the behaviour), but I have a feeling that that the behaviour is wrong. (which I assume the closure reform will fix.)
[13:30:31] <mathrick> isn't ~ a unique pointer? Why'd you ever put that in your function signature like that?
[13:30:51] <dbaupp> rusti: fn mk_appender(suffix: ~str) -> @fn(&str) -> ~str {return |s| s + suffix;} mk_appender(~"foo")("bar")
[13:30:52] -rusti- ~"barfoo"
[13:30:53] <mathrick> dbaupp: it's definitely wrong if you want your closures to be useful, yeah
[13:30:59] <dbaupp> rusti: fn mk_appender(suffix: &str) -> @fn(&str) -> ~str {return |s| s + suffix;} mk_appender(~"foo")("bar")
[13:31:00] -rusti- pastebinned 8 lines of output: http://sprunge.us/SjNC
[13:31:15] <dbaupp> mathrick: not quite: because you can use a @mut variable which works.
[13:31:21] <dbaupp> (works as you expect)
[13:31:24] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[13:32:03] <mathrick> I guess, I keep forgetting it has explicit pointers
[13:32:31] <dbaupp> rusti: fn mk_appender(suffix: @mut ~str) -> @fn(&str) -> ~str {return |s| s + *suffix;} let mut suffix = @mut ~"foo"; let f = mk_appender(suffix); println(f("bar")); *suffix = ~"baz"; println(f("bar"))
[13:32:32] -rusti- pastebinned 6 lines of output: http://sprunge.us/DiVX
[13:32:36] <mathrick> also, that thing where vectors are mutable or not depending on where they live is... odd
[13:32:44] <engla> Passing ~T or ~str is useful and avoids copying
[13:32:52] <dbaupp> mathrick: not as odd as it sounds
[13:33:06] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[13:33:08] <dbaupp> rusti: fn mk_appender(suffix: @mut ~str) -> @fn(&str) -> ~str {return |s| s + *suffix;} let suffix = @mut ~"foo"; let f = mk_appender(suffix); println(f("bar")); *suffix = ~"baz"; println(f("bar"))
[13:33:09] -rusti- barfoo
[13:33:09] -rusti- barbaz
[13:33:09] -rusti- ()
[13:33:27] <mathrick> engla: but why wouldn't it be fn(&str) instead?
[13:33:36] <dbaupp> there^, one closure (`f`) and one variable(`suffix`), and the change is observed
[13:33:38] <dbaupp> mathrick: it should be
[13:33:53] <engla> mathrick: for this particular case I guess it's better
[13:33:55] <dbaupp> (the tutorial is bad, unfortunately :( )
[13:34:44] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[13:34:52] <engla> mathrick: you can store a ~str indefinitely, &str is a borrowed string so it has a lifetime; if you need to do the former, take a ~str  (or be forced to copy &str -> ~str)
[13:35:35] <engla> mathrick: say for example a hashmap. You would probably use ~str keys to let the hashmap own the keys
[13:35:40] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[13:36:51] <bjz> mathrick: for engla's hash map example, it could take a &str, but then it'd have to copy it inside the function. That's a little sneaky.
[13:37:02] <mathrick> engla: probably, but then I cannot use these keys anymore, which can be annoying in its own right (very often you get a piece of processed data, note it in a hashmap, then carry on doing whatever else you need to do with it)
[13:37:17] <dbaupp> mathrick: yes, you just copy it yourself
[13:37:26] <bjz> mathrick: you'd just do a .clone() on them
[13:37:41] <dbaupp> or, use shared strings (@str), so you don't have to copy them.
[13:38:06] <mathrick> wouldn't passing a @str to a ~str function cause a type error?
[13:38:13] <dbaupp> yes
[13:38:43] <mathrick> so you need to have a separate hashmap implementation that can take shared strings
[13:38:48] <dbaupp> it's generic.
[13:39:12] <bjz> rusti: fn insert(_key: ~str, _val: int) {} let k = ~"hi"; insert(k.clone(), 1); k
[13:39:13] -rusti- ~"hi"
[13:39:22] <bjz> rusti: fn insert(_key: ~str, _val: int) {} let k = ~"hi"; insert(k, 1); k
[13:39:23] -rusti- pastebinned 8 lines of output: http://sprunge.us/OIae
[13:39:37] <dbaupp> rusti: use std::hashmap::HashMap; let h1 = HashMap::new(); h1.insert(~"foo", 1); let h2 = HashMap::new(); h2.insert(@"foo", 1);
[13:39:38] -rusti- pastebinned 8 lines of output: http://sprunge.us/GCTW
[13:39:41] <mathrick> haven't really seen the generics (other than "they're sane" opinion), so I can't really know how that works yet
[13:39:57] <dbaupp> rusti: use std::hashmap::HashMap; let mut h1 = HashMap::new(); h1.insert(~"foo", 1); let mut h2 = HashMap::new(); h2.insert(@"foo", 1);
[13:39:58] -rusti- ()
[13:40:08] <dbaupp> (no output means that compiled fine)
[13:40:10] <bjz> mathrick: pretty much standard parametric polymorphism
[13:40:33] <bjz> mathrick: you end up with some pretty insane type signatures
[13:40:50] <mathrick> yeah
[13:41:23] <bjz> mathrick: the way it works with traits is good
[13:41:26] <mathrick> hopefully not as bad as haskell, where you can do a PhD and never once venture outside the type signatures :)
[13:41:55] <bjz> mathrick: erm, what? haskell is really readable, one of the best
[13:41:59] <mathrick> (haskell is a useful breeding ground for ideas, but not a language I'd actually want to work in)
[13:42:09] <bjz> for type sigs
[13:42:12] <dbaupp> well, these are insane in the vein that C++ template error messages are insane. (Although nowhere near as bad.)
[13:42:49] <mathrick> bjz: yes, unless you want to do an unheard of thing such as "a collection of different things". There's a guy who does nothing but hacks like that and he's really know for it in the haskell world
[13:42:55] <kimundi> mathrick: (btw, a meta reason for "why does rust do this manual memory management" could be that no one else in this space besides C/C++ does it, wich for diversity reasons alone is seems worthwhile)
[13:43:27] <dbaupp> mathrick: oleg?
[13:43:39] <mathrick> yes, I was googling to see if his name was oleg as I remembered
[13:43:51] <kimundi> mathrick: Collection of different things is perfectly possible if those things share a common trait and you use trait objects :)
[13:43:56] <mathrick> kimundi: that's a good point, though I'd sure not spend my time implementing a whole new language just for that :)
[13:44:03] <dbaupp> mathrick: having collections of different things isn't typesafe, without some other features.
[13:44:08] <kimundi> yeah, it's not the reason of course
[13:44:15] <mathrick> oh, that was only re: haskell and impossibly complex types
[13:44:22] <kimundi> but it's reason enough to not change to much, I think
[13:44:54] <mathrick> I meant that you can not touch any parts of haskell other than the type system and still do a PhD or ten out of the material there
[13:45:22] <dbaupp> there's isn't exactly much to Haskell other than the type system
[13:45:37] <bjz> :P
[13:45:40] <mathrick> I know! Which is exactly what makes it not a very appealing language to use in practice
[13:45:47] * dbaupp likes using Haskell
[13:45:53] <mathrick> it's nifty as hell for theoretic and groundbreaking work
[13:46:05] <dbaupp> (john carmack likes using Haskell :P )
[13:46:13] <mathrick> but I wouldn't want to write my daily code in haskell
[13:46:26] <dbaupp> what do you normally code in?
[13:46:46] <mathrick> depends on whether I'm allowed to ignore real world :). If yes, then Common Lisp
[13:47:03] <dbaupp> and if no?
[13:47:22] <kimundi> mathrick: Don't underestimate the power of the human mind to learn new things :)
[13:47:32] <mathrick> whatever happens to be acceptable. I can put up with python, have done plenty of C, recently JS has been finding me more often than I'd like
[13:47:49] * bjz thinks the "haskell is only for theoretical stuffs" meme is sad
[13:47:50] <mathrick> kimundi: oh I don't; I use CL after all and am perfectly happy doing so :)
[13:48:04] * ChrisMorgan wonders yet again why syntax::ast::binop has `subtract` rather than `sub` as it is everywhere else
[13:48:16] <kimundi> I wouldn't want to write code in lisp - because I don't know it and only know that I'll type '(' and ')' a lot.
[13:48:17] <dbaupp> ChrisMorgan: because consistency is for losers :P
[13:48:18] <mathrick> bjz: it's not a meme, it's my independent conclusion I've come to after learning haskell and liking the process
[13:49:06] <kimundi> I wouldn't want to write C++ - because I don't know it, ant just hear about it's memory safety issues all the time here
[13:49:16] <mathrick> kimundi: nah, you only do (, and the rest is handled by your editor. It's actually very convenient to work in, because the editor can glean so much from it and can offer tools that know exactly what can happen where
[13:49:21] <bjz> kimundi: foo(bar(x, y)) vs (foo (bar x y))?
[13:49:39] <dbaupp> mathrick: in any case, the "design goal" for Rust is a language in the same niche as C++, but without (most of) the problems that C++ has.
[13:49:50] <kimundi> (I'm not being completly serious here :P)
[13:49:50] <mathrick> kimundi: the only people who want to write C++ are ones who don't know it well enough
[13:50:13] <mathrick> and mental patients :)
[13:50:54] <mathrick> dbaupp: *nod*, I just thought that OCaml was already fairly good as a systems language
[13:51:19] <dbaupp> mathrick: maybe; but it's very different to C++
[13:51:27] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[13:51:27] <kimundi> mathrick: He, it was good enough that rusts first compiler was written in it
[13:51:43] <mathrick> I know! That's why I mentioned OCaml specifically
[13:51:43] <bjz> mathrick: concurrency is an issue, also control over memory layout.
[13:51:52] <bjz> (so I hear)
[13:52:13] <kimundi> mathrick: After that, rust changed often enough that it really doesn't make sense to talk about any kind of 'planning' going on
[13:52:21] <mathrick> I heard good things about OCaml's concurrency, but it's pure hearsay, so doesn't really have much weight
[13:52:32] <kimundi> rust used to have classes, and be only garbage collected
[13:52:50] <bjz> mathrick: jane street has made some strides in it, but the language wasn't built with it in mind
[13:53:14] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[13:56:22] <mathrick> bjz: ah
[13:57:14] <mathrick> dbaupp: to be perfectly fair, so is Rust
[13:57:30] <mathrick> (which is a good thing, mind)
[13:58:23] <dbaupp> mathrick: right, but Rust is much closer to C++ than it is to OCaml (in certain key areas, like memory control).
[13:58:25] <mathrick> "not C++" should be the #1 bullet point on any language wanting to be systems language. "not C" is a reasonable #2
[13:59:30] <zxcdw> Would that imply that C++ is not a better C?
[13:59:33] <kimundi> mathrick: What really exites me about rust is, that even if it ends up more verbose than other languages, we're converging against a feature set where a lot of important properties of your code thet you usually have to keep in check yourself can be encoded in the typesystem directly. ANd the way you have just the right building blocks for most kinds of constructs without needing to work with some kind of language abstraction that could cau
[13:59:33] <kimundi> se overhead or so.
[13:59:40] <mathrick> zxcdw: it's not a better anything
[13:59:51] <dbaupp> mathrick: it's a better footgun
[14:00:07] <mathrick> yes, but "better" here would be very debatable
[14:00:31] <zxcdw> mathrick: Thats quite an extreme case formulation
[14:00:54] <engla> traits are exciting. It's so easy to split up or merge interfaces, or create just the small interfaces needed to solve a particular problem
[14:01:04] <mathrick> zxcdw: I submit that anyone actually familiar with C++ ought to conclude that
[14:01:06] <engla> no use in trying to say C++ is a better C. It's clearly not C.
[14:01:17] <mib4pg> Is there any interest in providing support for COM or XPCOM in Rust?
[14:01:19] <bjz> mathrick: don't let yourself be blind to C++'s good points
[14:01:28] <kimundi> For example: Haskel has typeclasses, C++ has objects. In rust, you can use both the same way by using generics or trait objects
[14:01:31] <mathrick> and yes, only fools and Stroustrup claim C++ to have anything to do with C
[14:01:45] <mathrick> all C++ has in common with C is its problems
[14:01:46] <dbaupp> mib4pg: not necessarily directly in the standard-libs, but I'm sure it'd get used someplaces.
[14:01:53] <mathrick> which C++ then expands and takes in new, exciting directions
[14:02:09] <dbaupp> kimundi: (fwiw, Haskell has "typeclass objects" too)
[14:02:18] <kimundi> IT has?
[14:02:21] <dbaupp> yup
[14:02:23] <bjz> yup
[14:02:25] <mathrick> bjz: C++ has no good points. C++ and PHP are two languages which are absolutely, utterly irredeemable
[14:02:34] <kimundi> Well, never claimed to know about haskell :P
[14:02:39] <dbaupp> kimundi: [forall a. Show a => a] -- list of showable things
[14:02:48] <dbaupp> kimundi: (requires an extension)
[14:02:53] <zxcdw> mathrick: Hmm, quite frankly that sounds more subjective than objective when you put it that way.
[14:02:53] <mathrick> (it's arguable whether PHP is really a language, but let's be generous. It's certainly used as one)
[14:03:11] <bjz> mathrick: I'm not saying it's not a train wreck, but there are *reasons* why it is valued in industry
[14:03:24] <zxcdw> But then again I am an pedantic ass and I think we're both better off not discussing this on a serious tone :)
[14:03:26] <mathrick> zxcdw: nah. Anything you can point to and say "this is a good use for C++ if you stick to it" can just as well or better be done in pure C
[14:03:41] <dbaupp> kimundi: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
[14:03:58] <mathrick> even "C with strings", which is closest to a reasonable use for C++, is only good as long as you don't remember there are about 100000 different string classes for C++
[14:04:39] <mathrick> bjz: historical accident. C happened, and it was sad, then C++ happened and made C look good
[14:04:51] <mathrick> worse is often the winner, sadly
[14:05:14] <dbaupp> mathrick: it would be nice to avoid turning this into a bash-other-languages session, please.
[14:05:17] <mathrick> C set us back some 20 years in compiler development. C++ is another 20 years at least
[14:05:30] <mathrick> dbaupp: aight
[14:06:26] <bjz> dbaupp: agreed
[14:06:53] <ChrisMorgan> Well, I'm willing to admit that I'm quite thoroughly outside my depth for actually tying x += y to x.add_assign(y), but I've got at least a fair bit of it done: https://github.com/chris-morgan/rust/compare/augmented-assignment
[14:07:04] <mathrick> it's just good to know that just because we're finally having some not utterly disastrous compilers for C (and C++) only looks good if you don't look where Fortran (yes, Fortran) compiler research has been in the '70s
[14:07:31] <dbaupp> ChrisMorgan: awesome!
[14:07:52] <zxcdw> mathrick: A fellow Haskeller, I suppose?
[14:07:58] * dbaupp was very confused by the github email he got from the @ mention.
[14:08:03] <mathrick> zxcdw: Lisper, but close :)
[14:08:10] <ChrisMorgan> dbaupp: rustc even still compiles!
[14:08:17] <mathrick> bjz, zxcdw: related, have you read Coders at Work? If not, run, don't walk to buy it
[14:08:28] <bjz> mathrick: Rust is heavily reliant on LLVM, which is mainly a back end for clang. We are indebted to the C++ compiler community's efforts
[14:08:40] <dbaupp> ChrisMorgan: \o/
[14:08:58] <dbaupp> ChrisMorgan: (fwiw, it's nice to avoid the "make it compile" commits in the main source tree :) )
[14:09:13] <mathrick> bjz: sure, but again, that only makes sense if you don't take into account where we *could've* been if C and C++ didn't happen
[14:09:20] <ChrisMorgan> dbaupp: it's true, though :D
[14:09:29] <ChrisMorgan> Not sure if the tests would pass or not, haven't tried it. Don't think I've changed anything yet which would break it.
[14:09:33] <mathrick> C pretty much ended automatic parallelism and intrinsic generation research for 20 years
[14:09:49] * bjz likes to look forward, rather than lamenting the past
[14:09:51] <ChrisMorgan> dbaupp: I'm following the principle with it of commit earrly, commit offten.
[14:09:56] <mathrick> that's what the PTRAN group was working on before they got effectively disbanded because C compilers were needed
[14:10:06] <kimundi> mathrick: Mek, we are where we are today, and all we can try is to improve it from here.
[14:10:15] <dbaupp> ChrisMorgan: right (it's not a big problem, just nice.)
[14:10:33] <dbaupp> ChrisMorgan: do you know where the + -> .add rewrite happens in the compiler?
[14:10:43] <bjz> ChrisMorgan: oooh, sweet stuffs
[14:11:07] *** Joins: LU324 (weechat@9AF4F288.83671C58.1B5D53D7.IP)
[14:11:11] <ChrisMorgan> I haven't found something that I would say: "lo! here the compiler turns + into .add!" about.
[14:11:12] <mathrick> kimundi: obviously. The only thing I'm objecting to is saying "but C++ has good point". It doesn't. (C I will allow much more leeway, since while bad, it was not quite as disastrously awful in every regard. It's a decent PDP-11 assembler)
[14:11:49] <kimundi> well it does. If it didn't it wouldn't be used today
[14:11:54] <ChrisMorgan> Some of it in build/builder seems to be dealing with integers, not quite sure if it's general or not. But I've only been looking at it in the last twenty minutes.
[14:11:55] <bjz> mathrick: zero cost abstractions?
[14:12:06] <ChrisMorgan> s/integers/numbers/ (and constants)
[14:12:09] <kimundi> IT might not be the good points you want, though :P
[14:12:19] <mathrick> bjz: hah, no. They're certainly not zero cost, and piss poor abstractions too
[14:12:38] <dbaupp> ChrisMorgan: it looks like resolve.rs:5075 is approximately a good place to start
[14:12:56] <mathrick> even if you care about bare metal speed, C++ is often really costly, because it ends up copying a lot
[14:13:11] <ChrisMorgan> Yay! Let's all write assembly code!
[14:13:18] <ChrisMorgan> dbaupp: observe that I have done some stuff there
[14:13:23] * dbaupp checks
[14:13:27] <bjz> ChrisMorgan: ^_^
[14:13:44] <dbaupp> ChrisMorgan: oh
[14:13:52] <dbaupp> ChrisMorgan: you win :)
[14:14:10] <dbaupp> ChrisMorgan: ... can you actually use them?
[14:14:12] <ChrisMorgan> ... but I presume that isn't sufficient to get it to magically do the rest.
[14:14:22] <dbaupp> it might be.
[14:14:22] <cmr> BareFn is extern fn,for those who were curious
[14:14:24] <ChrisMorgan> I dunno, I haven't tried to see what happens. It probably blows up.
[14:14:34] <ChrisMorgan> dbaupp: what, without actually telling it the method name to call?
[14:15:25] * ChrisMorgan runs `make install`... and then wonders whether it was a good idea to hose a known-good build like that with one that's almost certainly partially broken
[14:16:05] <cmr> rusti: let x: Option<extern fn<T>(y: T) -> T> = None
[14:16:05] -rusti- <anon>:5:33: 5:34 error: expected `>`, found `T`
[14:16:05] -rusti- <anon>:5          let x: Option<extern fn<T>(y: T) -> T> = None
[14:16:06] -rusti-                                           ^
[14:16:06] -rusti- application terminated with error code 101
[14:16:09] <kimundi> mathrick: The point is, c++ is used because the coder there has more control over such things. Used correctly you can do a lot of good, fast stuff with it, so I'd content the "no good points" argument. Doesn't change the fact that it's a unwieldy footgun though :P
[14:16:30] <dbaupp> ChrisMorgan: I'm not 100% sure how it works, but I have a feeling that it just takes the first method.
[14:16:50] <ChrisMorgan> "the first method"?
[14:16:57] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[14:16:57] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nrHZBg
[14:16:57] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[14:17:14] <cmr> rusti: let x: Option<extern fn<'a>(y: &'a int) -> int> = None
[14:17:15] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[14:17:15] -rusti- <anon>:6     };
[14:17:15] -rusti-              ^
[14:17:15] -rusti- application terminated with error code 101
[14:17:20] <cmr> rusti: let x: Option<extern fn<'a>(y: &'a int) -> int> = None;
[14:17:21] -rusti- <anon>:5:13: 5:14 warning: unused variable: `x` [-W unused-variable (default)]
[14:17:21] -rusti- <anon>:5          let x: Option<extern fn<'a>(y: &'a int) -> int> = None;
[14:17:21] -rusti-                       ^
[14:17:21] -rusti- ()
[14:17:22] <dbaupp> ChrisMorgan: well, I'm fairly sure e.g. the name `add` has no special significance
[14:17:22] *** concrete.mozilla.org sets mode: +M 
[14:19:37] *** Joins: CLogic (choeseung_@FBE88F35.7C615A3D.90024CDB.IP)
[14:19:54] *** Joins: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP)
[14:19:54] *** Parts: ghrust (ghrust@C8693FCB.6A2AE50.F3114085.IP) ()
[14:19:57] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[14:20:00] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[14:20:28] <ChrisMorgan> What, so the trait just has to be a trait with a single method?
[14:20:50] <cmr> It's a language item
[14:20:59] <cmr> But that's what I'd guess yeah
[14:21:19] *** Quits: sebcrozet (sebcrozet@moz-F96421F3.w80-13.abo.wanadoo.fr) (Client exited)
[14:21:40] <ChrisMorgan> "binary operation + cannot be applied to type `A`" followed by "internal compiler error: no type for node 135: expr r (id=135) in fcx 7fb63ccbd620".
[14:22:21] <ChrisMorgan> But it didn't say "run with RUST_LOG=::rt::traceback, etc."
[14:22:22] *** concrete.mozilla.org sets mode: -M 
[14:22:42] <ChrisMorgan> Hah hah, ghrust isn't logged in...
[14:22:43] <dbaupp> yeah, different kinds of failures show different error messages :(
[14:24:36] * ChrisMorgan wishes Rust could give useful backtraces
[14:24:57] <ChrisMorgan> What do I care that the task failed at /home/chris/vc/rust/src/libsyntax/diagnostic.rs:95? It's a couple of levels before that that I care about...
[14:25:05] <cmr> mw is doing fantastic work on debuginfo
[14:25:16] <cmr> extra-debug-info, when it doesn't ICE, is awesome
[14:25:16] <ChrisMorgan> Yeah, you know, at /home/chris/opt/rust/bin/../lib/librustc-d3cb8c2ccd84a7a7-0.8-pre.so(_ZN6middle6typeck5check14__extensions__10meth_523537node_ty17_b84599fc5432d6fb14_0$x2e8$x2dpreE+0x4d5)[0x7f86f12fef45]
[14:25:53] <cmr> ChrisMorgan: gdb!
[14:25:56] <dbaupp> ChrisMorgan: line 827 for me
[14:26:17] <dbaupp> (of middle/typeck/check/mod.rs)
[14:26:17] <ChrisMorgan> cmr: last time I had a build of Rust with -Z debug-info it made gdb fall apart when I did bt :D
[14:26:47] <ChrisMorgan> dbaupp: yep, I found it there. Not sure precisely what to do next other than go to bed :P
[14:27:08] *** Joins: boredomist (user@moz-63CF9F31.res-cmts.sesp.ptd.net)
[14:27:09] <dbaupp> ChrisMorgan: you can see the node ids with --pretty expanded,identified (I think)
[14:27:27] * dbaupp might be making things up
[14:27:43] <ChrisMorgan> dbaupp: how am I meant to do that when I can't compile it?
[14:27:43] <mib4pg> is there a tutorial on error handling (conditions ?) in rust?
[14:28:03] <dbaupp> ChrisMorgan: it quits earlier than typecheck
[14:28:05] <ChrisMorgan> mib4pg: the comments at the top of the code (libstd/condition.rs) are pretty good
[14:28:21] <mib4pg> ChrisMorgan: thanks
[14:28:22] <dbaupp> ChrisMorgan: (what are you compiling, btw? the full bootstrap, or a external test?)
[14:28:53] <ChrisMorgan> dbaupp: a simple script. I've got rustc compiled, but if I try using += on type A which implements AddAssign, it falls over.
[14:29:11] <dbaupp> ChrisMorgan: maybe you should fix it :P
[14:29:43] <ChrisMorgan> dbaupp: I quote from The Pirates of Penzance: "I would if I could, but I am not able." Bonus points if you know the tune associated with the line.
[14:29:48] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[14:29:59] <mib4pg> ChrisMorgan: couldn't find any comment in condition.rs :(
[14:30:29] <ChrisMorgan> Well, I wouldn't say I'm not able, but not yet anyway.
[14:30:40] <dbaupp> ChrisMorgan: I guess you need to adjust check_binop too
[14:31:06] <ChrisMorgan> mib4pg: sorry, that's not what I was thinking of... look at libstd/rt/io/mod.rs.
[14:31:56] <cmr> mib4pg: There are no tutorials on conditions
[14:32:15] <cmr> the newrt is a good example of how to use them though
[14:33:06] <dbaupp> (they've been recently fixed cross-crate (so they are actually useful)... documentation will hopefully be appearing soon.)
[14:33:32] <ChrisMorgan> dbaupp: really? check_binop looks OK to me from my iggerant layman's aspect.
[14:34:14] <dbaupp> ChrisMorgan: I was just following the trait of node_types -> write_ty -> things that sound like they might be relevant.
[14:34:59] <ChrisMorgan> Though, looking at it, I think the AllowOverloadedOperatorsFlag can be removed, as augmented assignment is now going to be permitted.
[14:35:51] <mib4pg> is the method of error handling in rust finalized? based on the comments in the io module, it seems otherwise.
[14:36:00] *** Quits: mathrick (mathrick@B9391410.C760DD8D.1352A07E.IP) (Ping timeout)
[14:36:15] <ChrisMorgan> Because I guess it's the source of the "binary operation + cannot be applied to type `A`" error.
[14:36:18] <dbaupp> ChrisMorgan: yes, at least change DontAllow* to Allow*
[14:36:30] <ChrisMorgan> dbaupp: it serves no other purpose, so I'll kill it.
[14:36:37] <dbaupp> ChrisMorgan: yup
[14:36:47] <kimundi> mib4pg: Nothing in rust is finalized in any way
[14:36:47] <dbaupp> mib4pg: no
[14:37:15] <kimundi> still, ther are quite a few things that are very unlikelyd to change :)
[14:37:38] <ChrisMorgan> mib4pg: conditions seem to have a sound _foundation_, but the implementation is distinctly clumsy to use.
[14:37:59] <kimundi> In the case of errors, we seem to converge into three different schemes
[14:38:07] <mib4pg> what would be the most likely method of error handling that 1.0 will support?
[14:38:11] <kimundi> 1. Task failure
[14:38:16] <kimundi> 2. Conditions
[14:38:27] <kimundi> 3. Result types
[14:38:57] <kimundi> mib4pg: Depending on the kind of error, and where/how often you expect it, one of the above
[14:39:22] <dbaupp> mib4pg: there'll always be Result types (since they aren't "special")
[14:39:33] <dbaupp> mib4pg: and it seems unlikely that conditions will disappear
[14:39:48] <dbaupp> (and task failure is certainly around to stay without some *major* upheavals.)
[14:40:07] <ChrisMorgan> Whoa... he starts `make` and memory usage leaps up by well over a gigabyte.
[14:40:11] <mib4pg> kimundi: i'm wrapping existing c/c++ libraries that return error codes. what is the suggested method of error handling in this case?
[14:40:25] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[14:40:37] <kimundi> mib4pg: Again it depends
[14:40:58] <dbaupp> ChrisMorgan: well, you're compiling librustc, right?
[14:41:07] <ChrisMorgan> Yip.
[14:41:08] <kimundi> mib4pg: If the error is regular expected a Result type would probably be appropiate
[14:41:09] <dbaupp> ChrisMorgan: (apparently we're currently at 1.8G max.)
[14:41:16] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[14:41:34] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[14:41:41] <kimundi> mib4pg: If it is a osne-off error that normally shouldn't happen, but can be caught, use conditions
[14:41:59] <cmr> mib4pg: Low-level wrappers should almost exclusively use Result
[14:42:15] <kimundi> mib4pg: If it is a error that is not recoverable, fail!()
[14:42:20] <ChrisMorgan> When I got this laptop, it had 2GB of RAM in it. I was very pleased with the difference an extra 2GB made three years later. I didn't expect to ever be filling the entire 4GB thenâ€”but lo, here I am building Rust...
[14:42:43] <cmr> And there's nothing worse than a library that causes task failure :\
[14:43:02] <mib4pg> kimundi: but isn't it nice to some consistency and also since this is library shouldn't the client decide the course of action (fail/continue)?
[14:43:16] <mib4pg> *nice to have some
[14:43:40] <dbaupp> ChrisMorgan: you should try building Rust twice at once, it's fun.
[14:43:43] <cmr> https://github.com/mozilla/rust/blob/master/src/libstd/os.rs#L1376 for example
[14:45:06] <kimundi> mib4pg: Hence you should only explicitly fail if you truely got a irrecoverable mess :P
[14:46:19] <ChrisMorgan> What, running out of memory will cause task failure?
[14:46:23] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[14:46:35] <dbaupp> cmr: woah, we have nice mmap bindings??
[14:46:38] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[14:46:47] <kimundi> ChrisMorgan: It probably should, but right now it just aborts
[14:46:54] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[14:46:54] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 141571a76 to 146be014d: 02http://git.io/N3iJvQ
[14:46:54] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[14:46:56] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[14:46:56] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/t44Axg
[14:46:56] <ghrust> 13rust/06auto 1470d2be0 15Kevin Ballard: Revert "std::rt: Use a constant 4 threads for multithreaded sched tests"...
[14:46:56] <ghrust> 13rust/06auto 142001cc0 15Kevin Ballard: Bump fd limit on macos when running rt tests...
[14:46:56] <ghrust> 13rust/06auto 1434101d2 15bors: auto merge of #8213 : kballard/rust/fd-limit, r=brson...
[14:46:58] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[14:46:59] <mib4pg> kimundi, cmr : agreed, but how to decide between Result and condition?
[14:47:10] <kimundi> because the problem on OOM is that you need memory for failure too
[14:47:15] * ChrisMorgan doesn't see why running out of memory would cause any form of failure
[14:47:43] <dbaupp> mib4pg: at the moment, Result, since condition isn't very documented.
[14:47:48] <dbaupp> ChrisMorgan: what would it cause?
[14:48:31] <cmr> mib4pg: Condition is for errors that the user can handle at the site of failure to either cause success or do something useful
[14:48:32] <ChrisMorgan> In such a case it's allocating of a large block which doesn't work, so you've still probably got memory spare. Conditions sound ideal for that.
[14:48:44] <cmr> For example, see http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html
[14:49:14] <dbaupp> mib4pg: (and so errors internal to a C library don't satisfy this)
[14:49:21] <cmr> dbaupp: Yes we do, thanks to indutny
[14:49:51] <dbaupp> ChrisMorgan: yeah; in most cases, fail!() calls in the standard lib could/should be conditions.
[14:49:59] <kimundi> mib4pg: As I said: If the error is regulary expected use result (eg: FileNotFound). If it is unexpected but catchable use conditions ( eg, HardDriveFull)
[14:50:21] <kimundi> Also, what cmr said
[14:50:32] <mib4pg> cmr: thanks. i will definitely read it.
[14:50:57] <mib4pg> one other question, does rust support custom/ user-defined attributes?
[14:51:14] <cmr> mib4pg: not yet but it is planned
[14:51:27] <dbaupp> mib4pg: you mean, attributes == #[foo], right?
[14:52:09] <mib4pg> kimundi: in that case, is it ok to have both. i.e a function that returns Result but can also throw?
[14:52:09] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Connection reset by peer)
[14:52:18] <mib4pg> dbaupp: yes
[14:52:32] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[14:52:46] <cmr> rustc doesn't error on unrecognized attribute, but there's no way to modify behavior based on it without modifying the compiler
[14:53:00] <ChrisMorgan> But you could have an external tool which reads it.
[14:53:09] <kimundi> cmr: ...yet
[14:54:07] <mib4pg> cmr: so in the future will the user defined attributes be able to perform actions during compile time...like an attribute on a 'extern mod' statement that causes a crate to be generated?
[14:54:07] <kimundi> If we get user loadable syntax extensions, we might as well also get user definable attribute handlers
[14:54:33] <cmr> mib4pg: hopefully
[14:54:37] <cmr> Attributes are a bit tricky
[14:54:44] <cmr> because they can literally modify any behavior in the compiler
[14:54:56] *** Joins: Danish (Danish@moz-284EC002.retail.telecomitalia.it)
[14:55:33] <mib4pg> i love the c# custom attributes model. any chance rust will support something like it?
[14:55:43] <dbaupp> kimundi: (attributes like #[deriving] are literally the same code as syntax extensions like fmt!, so that's entirely reasonable.)
[14:56:10] <cmr> mib4pg: Unlikely, reflection like C# has in Rust is difficult
[14:56:21] <cmr> Not impossible, the information is in the compiled crate, but it's tricky
[15:01:29] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[15:02:11] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[15:02:21] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[15:04:15] *** Quits: Danish (Danish@moz-284EC002.retail.telecomitalia.it) (Quit: )
[15:04:18] *** Joins: Danish (Danish@moz-284EC002.retail.telecomitalia.it)
[15:07:07] <cmr> Rust's "task failure as exceptions" really falls apart when your stuff isn't sendable :\
[15:11:12] <ChrisMorgan> dbaupp: well, with AllowOverloadedOperatorsFlag removed, it gives the same error and fails in the same way :-(
[15:12:29] <ChrisMorgan> I'll need to look at it further some other time. Bed time now. Or an hour and a half ago.
[15:13:27] <dbaupp> ChrisMorgan: syntax::ast_util::binop_to_method_name
[15:13:41] <ChrisMorgan> dbaupp: I was actually just duplicating that, but that still won't be enough.
[15:14:06] <dbaupp> ChrisMorgan: I assume that check_user_binop needs to be modified to account for the differences.
[15:15:14] <dbaupp> ChrisMorgan: I imagine it might require more invasive changes.
[15:15:18] * dbaupp doesn't know.
[15:15:22] <ChrisMorgan> Looks like it
[15:15:52] * ChrisMorgan wonders whether &&= and ||= should be allowed, for booleans... that'd be much harder, by the looks of it.
[15:15:55] *** Joins: goffrie_ (goffrie@moz-E9EC021C.dsl.ncf.ca)
[15:15:59] <dbaupp> ChrisMorgan: I guess nmatsakis or pcwalton would be the people to ask.
[15:16:01] *** Quits: goffrie (goffrie@moz-3AD452E4.dsl.ncf.ca) (Ping timeout)
[15:16:10] <ChrisMorgan> Anyway, g'night. You should go to bed too :P
[15:16:11] *** Joins: mummy (Mibbit@604BE3E8.7058C25E.C0DF6D2F.IP)
[15:16:13] <dbaupp> yup
[15:16:40] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[15:16:42] *** Quits: mummy (Mibbit@604BE3E8.7058C25E.C0DF6D2F.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[15:17:02] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[15:17:18] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:18:40] *** Quits: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au) (Ping timeout)
[15:21:53] *** Joins: pupoque1 (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[15:22:32] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Ping timeout)
[15:23:01] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[15:25:06] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[15:25:23] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:26:03] *** Quits: pupoque1 (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Ping timeout)
[15:27:25] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[15:30:39] <cmr> Is there any (unsafe) way to convince the type system to let me send a value which isn't sendable?
[15:31:55] *** Quits: Danish (Danish@moz-284EC002.retail.telecomitalia.it) (Quit: )
[15:32:54] *** Joins: Nisstyre (wes@moz-FD86289.netflash.net)
[15:34:02] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[15:35:47] *** Parts: CLogic (choeseung_@FBE88F35.7C615A3D.90024CDB.IP) ()
[15:37:04] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[15:39:01] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:39:01] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[15:39:10] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:39:16] <steven_is_false> Hi! Where is the new alternative for uint::range?
[15:39:26] <cmr> steven_is_false: std::iterator::range
[15:39:28] <cmr> it's in the prelude
[15:39:45] <cmr> rusti: foreach x in range(0, 10) { print(x.to_str()); }
[15:39:46] -rusti- 0123456789()
[15:39:55] <steven_is_false> Thanks.
[15:40:10] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[15:42:41] <engla> isn't uint::iterate  exactly the same as uint::range was?
[15:43:17] <cmr> dunno
[15:43:21] <engla> it looks like it
[15:43:34] <engla> I'm just confused why there would be a duplicate
[15:45:54] *** Joins: pupoque1 (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[15:46:46] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Ping timeout)
[15:48:41] *** Quits: KindOne (KindOne@moz-23830D44.dynamic.ip.windstream.net) (Ping timeout)
[15:50:10] <engla> I'll kill it
[15:52:39] *** Joins: KindOne (KindOne@moz-23830D44.dynamic.ip.windstream.net)
[15:52:53] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[15:57:34] *** Quits: pupoque1 (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Connection reset by peer)
[15:57:58] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[16:00:47] *** Quits: mark_edward (quassel@moz-9631ECE3.public.wayport.net) (Ping timeout)
[16:02:50] *** Joins: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP)
[16:05:31] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[16:09:17] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[16:10:33] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[16:13:00] *** Quits: mark_edward (quassel@981AA104.E81F12CD.76F66111.IP) (Ping timeout)
[16:14:40] *** Joins: bytbox_ (s@moz-DC83764A.washdc.fios.verizon.net)
[16:14:41] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[16:22:58] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:22:58] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/t44Axg
[16:22:58] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:23:27] <joelteon> forgive me if I'm wrong, but the docs suggest vec.iter().transform(f) instead of vec.map(f), but those two expressions don't have the same tpe
[16:23:29] <joelteon> type
[16:24:19] <cmr> joelteon: vec.map is an old thing, don't use it
[16:24:27] <cmr> transform returns an iterator
[16:24:34] <cmr> to to_owned_vec() to get a vector from it
[16:25:53] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:25:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/nd9wtA
[16:25:53] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:25:54] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[16:25:54] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LvuzPA
[16:25:54] <ghrust> 13rust/06auto 14ff7adb5 15Brian Anderson: rt: Fix a corner-case in unwinding that leads to stack overflow...
[16:25:54] <ghrust> 13rust/06auto 140bccd0e 15bors: auto merge of #8217 : brson/rust/reset_stack_limit, r=pcwalton...
[16:25:54] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[16:25:55] <joelteon> oh, cool.
[16:26:24] <joelteon> there's not any clever shorthand for |x| x.f(), is there?
[16:26:37] <engla> there isn't
[16:26:38] <joelteon> ruby would have a.map(&:to_i) for example, which is the same as map{|x|x.to_i}
[16:26:41] <joelteon> ok
[16:26:55] <engla> there is a plan to do something about free methods
[16:28:24] <joelteon> also, this isn't strictly language related, but if I make an identifier with a trailing underscore, rust.vim conceals the underscore to the prime character
[16:28:26] <joelteon> why is that?
[16:28:35] <joelteon> is that just a language philosophy thing?
[16:28:41] <cmr> no
[16:28:47] <cmr> you're using the old vim file it seems
[16:28:51] <cmr> turn conceal off
[16:29:18] <joelteon> i'm using wting/rust.vim
[16:29:47] <cmr> there's a vimfile in src/etc/vim
[16:30:00] <joelteon> ok that's probably a better idea
[16:30:22] <acrichto> Luqman: jj2baile: mad props on identifying the bug in llvm! 
[16:33:06] *** Joins: fabiand (fabiand@moz-79114A69.adsl.alicedsl.de)
[16:33:31] *** Joins: nano (nano@moz-972880B.superkabel.de)
[16:33:38] *** Joins: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net)
[16:33:39] <joelteon> ok, maybe I fucked up, but I just cloned mozilla/rust and moved the vim stuff into ~/.vim/bundle and it's still concealing _ to prime
[16:33:52] <cmr> turn conceal off
[16:34:03] <engla> conceal should be off in the current vim files
[16:34:12] <joelteon> okay :(
[16:34:26] <joelteon> i like rust's conceal, it doesn't mess up horizontal alignment
[16:38:41] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[16:38:54] <cmr> oh that's not the question you were asking
[16:39:14] <cmr> foo_ turns into foo-prime because conceptually you only trail with a underscore if it's the second foo... I think
[16:39:20] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[16:40:46] * engla shudders
[16:40:52] <engla> not touching that kind of conceal
[16:43:04] <joelteon> ok
[16:43:08] <joelteon> yeah, that makes sense
[16:43:19] <joelteon> oh, yeah, haha, no I know how to turn off conceal
[16:43:25] <joelteon> I just wondered *why* it was being concealed to that
[16:44:15] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[16:45:22] *** Joins: nano (nano@moz-972880B.superkabel.de)
[16:47:34] <Seldaek> is it correct that there is no performance difference between a 'let' and 'let mut' if all you do is assign once to it? does it only affect the compiler checks of is it allocated differently somehow?
[16:48:52] <cmr> Seldaek: only compiler checks
[16:49:08] <Seldaek> ok thanks
[16:49:23] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[16:51:59] <strcat> aatch: around?
[16:52:10] <strcat> or anyone who can review something fairly simple
[16:52:13] <strcat> https://github.com/mozilla/rust/pull/8264
[16:52:59] <acrichto> strcat: r+ p=10
[16:53:17] <acrichto> cmr: haha beat me to it
[16:53:24] <strcat> checking if I missed one atm ;p
[16:53:39] <strcat> just did sed -i s/foreach/for/ in doc/ and src/ ;p
[16:53:47] <strcat> + removed the token and parse bits...
[16:53:54] <acrichto> probably sufficient
[16:53:58] <acrichto> anyay gtg, sry
[16:54:00] <strcat> \o
[16:54:11] *** Joins: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr)
[16:54:37] *** Quits: lhatsk (Adium@moz-4D97378F.pool.mediaways.net) (Quit: Leaving.)
[16:54:56] <strcat> and... here it goes
[16:54:59] <strcat> I really hope I didn't miss one
[16:55:46] <strcat> the only 'foreach' left are in mk/ configure, Makefile.in and src/rt/jemalloc
[16:55:53] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[16:55:53] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140bccd0e to 1434101d2: 02http://git.io/N3iJvQ
[16:55:53] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[16:55:54] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[16:55:54] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/28TBLg
[16:55:54] <ghrust> 13rust/06auto 14fc24c86 15Daniel Micay: register snapshots
[16:55:54] <ghrust> 13rust/06auto 14ff9f614 15Daniel Micay: remove obsolete `foreach` keyword...
[16:55:54] <ghrust> 13rust/06auto 14ebeb4d6 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=cmr,alexcrichton
[16:55:55] * strcat omitted rt/llvm/libuv
[16:55:56] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[16:56:52] <cmr> feel free to r=me
[16:56:57] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[16:57:16] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[16:57:42] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[16:58:44] <strcat> silly foreach loop
[16:59:15] *** Joins: webber46 (webber46@moz-717E9C5B.cust.bredband2.com)
[16:59:38] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Connection reset by peer)
[16:59:46] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[17:00:00] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[17:00:22] *** Quits: StarLight (StarLight@moz-24285283.dynamic.avangarddsl.ru) (Ping timeout)
[17:02:07] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[17:02:20] <strcat> nooo
[17:02:22] <strcat> windows
[17:02:26] <strcat> er, mac
[17:02:58] <strcat> hm, wat
[17:02:59] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Connection reset by peer)
[17:03:11] *** Joins: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP)
[17:04:42] *** Joins: StarLight (StarLight@moz-24311389.dynamic.avangarddsl.ru)
[17:05:00] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[17:05:00] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14ebeb4d6 to 1434101d2: 02http://git.io/N3iJvQ
[17:05:00] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[17:05:00] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[17:05:01] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/FrWIqw
[17:05:01] <ghrust> 13rust/06auto 142047026 15Steven Stewart-Gallus: Fix calling destructor on uninitialized dynamic library crash....
[17:05:01] <ghrust> 13rust/06auto 14800dbff 15bors: auto merge of #8219 : sstewartgallus/rust/fix_dynamic_lib, r=graydon...
[17:05:01] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[17:06:15] <strcat> don't understand why it's failing ;[
[17:07:22] *** Joins: mark_edward (quassel@moz-9631ECE3.public.wayport.net)
[17:10:09] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[17:10:09] <ghrust> 01[13rust01] 15thestinger 04force-pushed 06try from 140aece61 to 1455fcf79: 02http://git.io/k471pw
[17:10:09] <ghrust> 13rust/06try 14fc24c86 15Daniel Micay: register snapshots
[17:10:09] <ghrust> 13rust/06try 1455fcf79 15Daniel Micay: remove obsolete `foreach` keyword...
[17:10:09] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[17:11:37] <cmr> Is there any way, unsafe or safe, to isolate task failure, without actually creating a task? Or (unsafely) capturing something that isn't sendable? CodeMap::span_to_snippet is buggy but I need to use it anyway :\
[17:12:10] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[17:13:14] <Seldaek> how do you check if var == SomeEnumVariant ?
[17:13:39] <cmr> rusti: enum Foo { A, B }; let x = A; if x == A { print("success"); }
[17:13:44] -rusti- <anon>:5:42: 5:48 error: binary operation == cannot be applied to type `main::Foo`
[17:13:44] -rusti- <anon>:5          enum Foo { A, B }; let x = A; if x == A { print("success"); }
[17:13:44] -rusti-                                                    ^~~~~~
[17:13:44] -rusti- error: aborting due to previous error
[17:13:45] -rusti- application terminated with error code 101
[17:13:50] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[17:13:50] <strcat> needs deriving(Eq) to do that
[17:13:52] <cmr> rusti: #[deriving(Eq)] enum Foo { A, B }; let x = A; if x == A { print("success"); }
[17:13:53] -rusti- <anon>:5:58: 5:64 error: binary operation == cannot be applied to type `main::Foo`
[17:13:53] -rusti- <anon>:5          #[deriving(Eq)] enum Foo { A, B }; let x = A; if x == A { print("success"); }
[17:13:53] -rusti-                                                                    ^~~~~~
[17:13:54] -rusti- error: aborting due to previous error
[17:13:56] -rusti- application terminated with error code 101
[17:13:57] <Seldaek> oh ok
[17:13:59] <Seldaek> thanks
[17:14:05] <strcat> deriving doesn't work in function scope
[17:14:07] <sp3d> or match on it?
[17:14:10] <strcat> so it won't work on rusti
[17:14:13] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[17:14:13] <strcat> yeah, or match
[17:14:14] <cmr> ah
[17:14:22] <strcat> you need to match anyway if it's not a simple unit variant
[17:14:31] <Seldaek> yup but I am in a bigger if statement with other bool checks, so an Eq is nicer
[17:14:44] <Seldaek> but thanks that worked
[17:16:32] <Seldaek> oh noes, you can't open a file with a path without picking one of WindowsPath or PosixPath? 
[17:16:46] <cmr> Path
[17:17:07] <Seldaek> that's not in std::path (on 0.7 at least) 
[17:17:12] <strcat> it is
[17:17:13] <cmr> it's in the prelude
[17:17:36] <Seldaek> ok *shakes hand at docs*
[17:17:53] <Seldaek> well, fist, whatever. thanks 
[17:18:03] <strcat> #[cfg(windows)]
[17:18:05] <strcat> pub use Path = self::WindowsPath;
[17:18:07] <strcat> #[cfg(unix)]
[17:18:09] <strcat> pub use Path = self::PosixPath;
[17:18:11] <strcat> is in path.rs
[17:18:20] <strcat> the doc tool doesn't have a way to figure out those cfgs
[17:18:23] *** Quits: z0w0 (zack@moz-E12708D5.lns6.woo.bigpond.net.au) (Client exited)
[17:18:33] <strcat> and maybe it doesn't show type aliases anyway
[17:18:42] <strcat> or pub use
[17:18:42] <cmr> it doesn't show reexports yeah
[17:19:02] <strcat> rusti: use foo = int; let x: foo = 5; x
[17:19:05] -rusti- pastebinned 8 lines of output: http://sprunge.us/FjMJ
[17:19:34] * strcat hates how we don't have relative imports now
[17:19:55] <Seldaek> it's nasty because the compiler asks for a WindowsPath 
[17:20:30] <Seldaek> I guess it's one case where fugly #ifdef inside a Path struct would be nicer from a user point of view
[17:21:00] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[17:21:04] <strcat> it should be a type alias
[17:21:06] <strcat> that's all
[17:23:04] *** Joins: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP)
[17:27:27] <engla> we need a plan for a new posix path that allows arbitrary bytes
[17:29:58] <strcat> http://buildbot.rust-lang.org/builders/try-mac/builds/574 wat
[17:30:06] <strcat> I don't understand why it segfaulted on an auto bot
[17:36:26] *** Joins: mrhandle (Mibbit@3448BE39.6A13B4BB.6692E697.IP)
[17:38:05] *** Quits: fabiand (fabiand@moz-79114A69.adsl.alicedsl.de) (Quit: Verlassend)
[17:38:13] <mrhandle> hi
[17:38:38] <mrhandle> what are my options if i want to use opengl on windows?
[17:40:33] <cmr> mrhandle: the only usable bindings right now are gles2
[17:42:47] <mrhandle> does that binding include a way to create opengl windows?
[17:42:58] <cmr> of course not
[17:43:05] <cmr> we have sdl and glfw3 bindings though
[17:43:34] <Seldaek> well, wut. rust: task failed at 'assertion failed: buf_len >= len - how do I initialize a buffer big enough that Reader.read() won't fail? 
[17:44:07] <mrhandle> ok thx, i'll check it out
[17:46:15] <cmr> Seldaek: an io::Reader?
[17:47:42] <Seldaek> cmr: yes
[17:47:57] <Seldaek> I can't seem to read from it into a [u8] 
[17:48:08] <Seldaek> probably I'm an idiot
[17:48:24] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[17:49:36] <engla> strcat: Mr. Iterator, yes? small improvements pull r if you have time https://github.com/mozilla/rust/pull/8265
[17:49:47] <strcat> sec
[17:54:52] <Seldaek> cmr: oh nvm I think I got it
[17:58:33] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[18:04:08] *** Joins: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com)
[18:08:23] *** Quits: bytbox_ (s@moz-DC83764A.washdc.fios.verizon.net) (Ping timeout)
[18:11:16] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[18:12:48] *** Quits: mib4pg (Mibbit@18F3C6F3.8762FF1A.520CDC98.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:14:26] *** Quits: eagen (eagen@moz-92A457CB.hsd1.mn.comcast.net) (Ping timeout)
[18:18:00] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Quit: Leaving)
[18:18:49] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[18:19:23] *** Parts: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP) (ERC Version 5.3 (IRC client for Emacs))
[18:20:08] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:24:28] <engla> strcat: do you think I should add any docs for the random access + invert  change? inline docs?
[18:26:38] <strcat> engla: yeah but not sure where
[18:26:40] <strcat> ;p
[18:26:57] <strcat> too many places it can be put
[18:27:21] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[18:29:18] <engla> I'll add the repeat iterator too 
[18:29:23] <engla> since it came up
[18:29:50] <strcat> probably should return &T
[18:30:04] <strcat> instead of clone
[18:30:46] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:31:38] <engla> cloning is more generic
[18:31:53] <engla> except if you want the repeat iterator to own the element
[18:32:03] <strcat> yeah I mean it should own it
[18:32:22] <strcat> maybe not
[18:32:41] <engla> Repeat::new(1) -> 1, 1, 1, ;  Repeat::new(&1) -> &1, &1, &1,
[18:32:58] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:34:34] <strcat> I think that's fine
[18:34:42] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:35:10] <engla> it has two sides
[18:35:52] <engla> not using clone makes it easier to return
[18:36:26] <engla> in fact, it generalizes the pattern of passing explicit environment to an iterator you return ^^
[18:36:42] *** Joins: tiffany (kawaii@moz-EB8B0C08.dhcp.embarqhsd.net)
[18:36:58] <engla> hm
[18:36:59] <engla> nah
[18:37:05] <engla> it doesn't matter if it owns it for that
[18:38:39] <engla> Repeat::new(&set_a).zip(set_b.iter()).filter(&|a, ref elt| a.contains(*elt))
[18:38:50] <engla> something like that is an intersection iterator you can return
[18:39:01] <engla> oh, you have to untuple it too 
[18:39:47] <engla> anyway, this repeat thing is clearly useful
[18:39:57] <engla> at least the clone thing, because it can be used in hashmap
[18:40:59] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[18:40:59] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/FrWIqw
[18:40:59] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[18:43:52] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[18:43:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/YOeKIg
[18:43:53] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[18:43:54] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[18:43:54] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/icyBNA
[18:43:54] <ghrust> 13rust/06auto 142f6777b 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=cmr
[18:43:54] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[18:45:13] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[18:45:21] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[18:45:51] *** Joins: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de)
[18:46:26] <maikklein> do we still have "for"?
[18:46:47] <maikklein> for xxx.iter().zip
[18:47:01] <goffrie_> maikklein: for x in iter { }, now
[18:47:16] <engla> strcat: it's moderately pretty.  Repeat (using .clone()) can carry the "explicit closure capture" instead of the current EnvFilterIterator in hashmap.  https://gist.github.com/anonymous/a65b5531a0342b52a672
[18:47:16] <maikklein> i thought it is foreach now?
[18:47:25] <FrozenCow> cool
[18:47:34] <goffrie_> maikklein: as I understand it it got renamed for `for` already
[18:47:41] <engla> the snapshot must go in
[18:47:41] <FrozenCow> no it *just* changed: http://git.io/icyBNA
[18:47:49] <doy> maikklein: it was just temporarily named foreach in order to allow converting things over little by little
[18:47:56] <maikklein> ah okay
[18:48:07] <engla> you can use new `for` with rust now, but the snapshot must land before it's used in the compiler itself
[18:48:07] *** goffrie_ is now known as goffrie
[18:48:12] <FrozenCow> so, will .iter still be removed, or is that on purpose?
[18:48:29] <strcat> it won't be removed
[18:48:46] <strcat> there will be an Iterable trait
[18:48:48] <goffrie> FrozenCow: it will eventually become unnecessary to type .iter() in a bunch of common cases, but not right now
[18:48:51] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[18:48:51] <strcat> iter can be part of that trait
[18:48:56] *** Quits: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90.1 [Firefox 23.0/20130729175331])
[18:49:01] <FrozenCow> aah like that
[18:49:22] <mark_edward> is there anyone who could help me with something?
[18:49:45] <mark_edward> trying to write a keccak implementation in pure Rust based on the C reference code
[18:50:21] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[18:51:01] <cmr> mark_edward: sure
[18:51:03] <strcat> engla: ah that's neat
[18:51:54] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Leaving...)
[18:52:05] <strcat> I don't understand why the snapshot won't land
[18:52:08] <strcat> it passed on try bots
[18:52:48] *** Joins: vk (chatzilla@moz-389FEE13.hsd1.ca.comcast.net)
[18:52:51] <mark_edward> cmr: the problem im having is weird. i know the block permutation part is working right. it's just that im not ending with the same output
[18:52:52] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[18:52:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142f6777b to 14800dbff: 02http://git.io/N3iJvQ
[18:52:52] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[18:52:54] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:52:54] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/gnCuiQ
[18:52:54] <ghrust> 13rust/06auto 1477adec9 15David Halperin: Add trait name to conflicting implementation error message
[18:52:54] <ghrust> 13rust/06auto 14fe8ad14 15David Halperin: Add backticks around trait name in conflicting implementations error message
[18:52:54] <ghrust> 13rust/06auto 14b5d77d2 15bors: auto merge of #8223 : davidhalperin/rust/master, r=Aatch...
[18:52:56] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:53:03] <cmr> mark_edward: code?
[18:55:18] <mark_edward> hold on a bit pushing latest changes
[18:55:53] <strcat> don't have a mac so I can't fix it
[18:57:23] <mark_edward> cmr: https://github.com/MarkJr94/rust-keccak/tree/bughunt
[18:58:28] <cmr> mark_edward: I see you're using uint. Maybe you want u32 or u64?
[18:59:10] <mark_edward> cmr: key stuff is here https://github.com/MarkJr94/rust-keccak/blob/bughunt/reference.rs#L132-L153 and i compare the output to reference info here
[18:59:26] <mark_edward> cmr: what are the differences between uint and u64?
[18:59:39] <mark_edward> cmr: reference info here: https://github.com/MarkJr94/rust-keccak/blob/bughunt/KeccakPermutationIntermediateValues.txt#L854-L860 
[19:00:01] <goffrie> mark_edward: u64 has guaranteed 64-bit size, uint is pointer-sized
[19:00:14] <goffrie> mark_edward: for crypto you almost certainly want fixed-size integers
[19:00:46] <mark_edward> cmr: i get the same state after iota, but the state after permutation is different, and i don't know why. the reference code doesn't alter the state after the last iota, so i don't know what' happening
[19:01:16] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Connection reset by peer)
[19:01:27] <mark_edward> goffrie: you're right. i'll change that throughout the code. for now i think i'm alright because all my work is on my 64bit laptop, but it shouldn't be related to my problems now
[19:02:30] *** Joins: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net)
[19:03:46] <Seldaek> how do I declare a struct field as mutable (it's a u64, and I've been battling with the compiler for 10min..)
[19:04:20] <doener> Seldaek: mutability is inherited, you can't mark individual fields as mutable anymore
[19:04:34] <Seldaek> ah, that sort of makes sense
[19:04:37] *** Quits: pupoque (Adium@297D6F99.EF706C30.C0C64AB3.IP) (Quit: Leaving.)
[19:05:36] <Seldaek> doener: except inherit from where? setting the whole struct instance as mut doesn't help
[19:05:45] <mark_edward> cmr: let me know if i need to explain stuff
[19:05:53] *** Joins: gcarter (Greg_Carte@D87A4EB0.E54E9B70.CED80046.IP)
[19:06:01] <Seldaek> doener: ah right, &mut self instead of &self, nvm, thanks
[19:06:51] <Seldaek> but now it trips up because io::Writer's write method defines &self and not &mut self
[19:10:09] <kimundi> Seldaek: thaty.s a problemw with writer
[19:10:25] <Seldaek> so I'm screwed? :p
[19:10:32] <kimundi> That is, the Writer trait ignores such things as mutability right now :(
[19:10:54] <engla> there is a new writer trait in rt::io
[19:11:10] <Seldaek> I'm on 0.7, don't feel like compiling myself on windows :/
[19:11:38] <Seldaek> can I wrap the mutable thing in another struct and give that to the writer so it can remain immutable?
[19:12:15] <maikklein> rusti: for j in uint::range(0, 4) {}
[19:12:18] -rusti- pastebinned 11 lines of output: http://sprunge.us/ICVh
[19:12:32] <maikklein> rusti: for j in std::uint::range(0, 4) {}
[19:12:33] -rusti- <anon>:5:18: 5:34 error: unresolved name `std::uint::range`.
[19:12:33] -rusti- <anon>:5          for j in std::uint::range(0, 4) {}
[19:12:33] -rusti-                            ^~~~~~~~~~~~~~~~
[19:12:33] -rusti- error: aborting due to previous error
[19:12:33] -rusti- application terminated with error code 101
[19:12:52] <maikklein> hm
[19:13:46] <engla> acrichto: I'll fix the .consume_iter thing with Option
[19:13:59] <maikklein> any idea why this doesn't work?
[19:14:19] <engla> acrichto: but I don't know which way is more consistent. I don't think we got to that point where that is considered
[19:14:24] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[19:14:27] <maikklein> oh
[19:15:05] *** Joins: miloshadzic (miloshadzi@5E9C7FE4.FA4D0618.449B8A48.IP)
[19:17:31] <maikklein> rusti: for j in std::uint::iterate(0, 4, |x| false) {}
[19:17:32] -rusti- <anon>:5:9: 6:5 error: type `&mut bool` does not implement any method in scope named `next`
[19:17:32] -rusti- <anon>:5          for j in std::uint::iterate(0, 4, |x| false) {}
[19:17:32] -rusti- <anon>:6     };
[19:17:32] -rusti- error: aborting due to previous error
[19:17:32] -rusti- application terminated with error code 101
[19:17:45] <maikklein> rusti: for j in std::uint::iterate(0, 4, |x| false).iter() {}
[19:17:45] -rusti- <anon>:5:18: 5:62 error: type `bool` does not implement any method in scope named `iter`
[19:17:46] -rusti- <anon>:5          for j in std::uint::iterate(0, 4, |x| false).iter() {}
[19:17:46] -rusti-                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[19:17:46] -rusti- error: aborting due to previous error
[19:17:46] -rusti- application terminated with error code 101
[19:17:53] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:17:57] <engla> uint::iterate is not an iterator
[19:18:14] <engla> it's an old style iterator (and I'm killing it with my PR)
[19:18:23] <engla> replaced by range
[19:19:16] <engla> rusti: for j in range(0, 4) { printf!("%?, ", j); }
[19:19:18] -rusti- 0, 1, 2, 3, ()
[19:19:27] <jeaye> So extra::arc is helpful for getting references across thread boundries, but it isn't a tool for preventing race conditions. Where are the mutexes?
[19:20:44] <strcat> jeaye: it doesn't allow races
[19:20:51] <jeaye> Oh yeah?
[19:21:00] <strcat> mutable arcs have locks
[19:21:15] <strcat> you should prefer message passing though
[19:21:20] <eevee> oh is range() now dwim?
[19:21:54] <strcat> rusti: for (x, y) in range(0, 3).zip(range(10, 15)) { printfln!("%? %?", x, y) }
[19:21:55] -rusti- 0 10
[19:21:56] -rusti- 1 11
[19:21:56] -rusti- 2 12
[19:21:56] -rusti- ()
[19:22:14] <orshem> the unused-import is incorrect...
[19:22:28] <jeaye> strcat: I'm looking at the example ( http://static.rust-lang.org/doc/extra/arc.html ); I don't see how that would lock. Unless it's like std::lock_guard and locks within the scope?
[19:22:48] <strcat> jeaye: there's *no way* to use it without a lock
[19:23:05] <strcat> there are no data races in safe code
[19:23:14] <strcat> arc doesn't break that guarantee
[19:23:55] <jeaye> So I can just write [safe] multithreaded code and be 100% certain that, if it compiles, there are no races or dead locks?
[19:24:07] <strcat> dead locks?
[19:24:13] <strcat> you can be certain there are no data races
[19:24:31] <orshem> scratch that, i'm an idiot
[19:24:39] <jeaye> orshem: :)
[19:24:55] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[19:25:05] <mark_edward> cmr: any advice?
[19:25:25] <tikue> rusti: return 1;
[19:25:27] -rusti- pastebinned 12 lines of output: http://sprunge.us/YbJI
[19:25:57] <tikue> rusti: let x = True; if x { return 1; }
[19:25:57] -rusti- <anon>:5:17: 5:21 error: unresolved name `True`.
[19:25:57] -rusti- <anon>:5          let x = True; if x { return 1; }
[19:25:57] -rusti-                           ^~~~
[19:25:57] -rusti- error: aborting due to previous error
[19:25:58] -rusti- application terminated with error code 101
[19:26:06] <tikue> rusti: let x = true; if x { return 1; }
[19:26:06] -rusti- <anon>:5:37: 5:38 error: mismatched types: expected `()` but found `<VI0>` (expected () but found integral variable)
[19:26:07] -rusti- <anon>:5          let x = true; if x { return 1; }
[19:26:07] -rusti-                                               ^
[19:26:07] -rusti- error: aborting due to previous error
[19:26:07] -rusti- application terminated with error code 101
[19:28:34] <strcat> jeaye: you can still deadlock by implementing a buggy communication protocol and so on
[19:28:42] <strcat> prefer message passing over arcs though
[19:28:58] <strcat> you only want arcs when you have something huge
[19:29:08] <strcat> and you can't figure out a way to avoid copying it
[19:31:22] <miloshadzic> extra::fileinput has nice docs
[19:31:39] <tikue> saw something on rust -- is `for` completely changed now?
[19:31:50] <tikue> saw something on *reddit
[19:31:51] <engla> eevee: range() is a generic function
[19:31:56] <strcat> tikue: yes it's been a long time coming
[19:32:04] <engla> eevee: hopefully that is what you want :)
[19:32:19] <tikue> strcat: \o/
[19:32:52] <tikue> rusti: let xs = [1, 2, 3]; for &x in xs.iter() { printfln!("%d potato", x); }
[19:32:53] -rusti- 1 potato
[19:32:53] -rusti- 2 potato
[19:32:54] -rusti- 3 potato
[19:32:54] -rusti- ()
[19:33:01] <tikue> weeeee 
[19:33:19] <jeaye> strcat: What about something like https://gist.github.com/Jeaye/74ceef1a3b90583e22be
[19:33:34] <jeaye> Does it just not allow such things, which is why it prevents race conditions? :P
[19:33:47] *** Joins: yedpodtrzitko (Mibbit@47AC10C.D03BD19.4813241C.IP)
[19:33:53] <doomlord> so the extra complexity of specifying 'xs.iter' is to allow forward, backward, range... whatever
[19:34:17] <strcat> jeaye: it doesn't prevent *race conditions*
[19:34:20] <strcat> it prevents *data races*
[19:34:27] <strcat> you cannot ever have an inconsistent view of an object
[19:34:32] *** Quits: yedpodtrzitko (Mibbit@47AC10C.D03BD19.4813241C.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:34:33] <tikue> doomlord: making it unnecessary is slated for some point
[19:34:35] *** Joins: yed (yed@329A667E.EA418F3D.536C81E0.IP)
[19:34:46] *** Joins: yed_ (yed@329A667E.EA418F3D.536C81E0.IP)
[19:34:48] <strcat> you really don't want to be using arcs much though, they're not for common use cases
[19:34:50] *** Quits: yed_ (yed@329A667E.EA418F3D.536C81E0.IP) (Quit: Leaving)
[19:35:01] *** yed is now known as yed_
[19:35:07] <doomlord> ok i was about to suggest "can it be structured such that you get forward iteration over the whole thing by default, and ask for anyything different.."
[19:35:18] <doomlord> i gather its partly compiler bug workarounds :)
[19:35:24] <strcat> doomlord: .iter isn't extra complexity, at a minimum you need to be able to get an iterator
[19:35:31] <jensnockert> Do we have any workaround for the new silly rule that `use' must come before `mod' ?
[19:35:51] <doomlord> perhaps complexity is the wrong word
[19:35:54] <strcat> doomlord: it iterates over iterators, like range, counter, cycle, chain, filter, map, take, skip_while
[19:35:58] <strcat> none of those is a container
[19:36:36] <doomlord> fair enough, i guess my suggestion translates to "could you make a container expose an forward iterator interface over its whole by default"
[19:36:51] <orshem> jensnockert: i was bitten by that. why was it made?
[19:37:02] <jensnockert> orshem: No idea, but I assume there is a good reason?
[19:37:03] <orshem> it's more logical to first import and then use
[19:37:09] <orshem> imo
[19:37:11] <tikue> rusti: let mut x = [0, ..100]; x = x.iter().transform(|_| std::rand::random::<int>()).collect();
[19:37:12] -rusti- line longer than 150 columns, pastebinned 4 lines of output: http://sprunge.us/bdIi
[19:37:27] <tikue> hm
[19:37:39] <tikue> no chance in getting collect working for fixed size vecs?
[19:37:44] <strcat> nope
[19:37:52] <strcat> you can't implement methods on fixed-size vectors
[19:37:55] <strcat> they can't implement any trait
[19:37:57] <tikue> ah
[19:38:01] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[19:38:09] <strcat> but you couldn't make it work anyway
[19:38:18] <strcat> fixed-size vectors are fixed-size, collect builds something up
[19:38:20] <doomlord> for is nice, i'm sort of dissapointed "do " wasn't sufficient, thats a criticism of reality not rust's for :)
[19:38:44] <strcat> 'do' doesn't have an iteration protocol
[19:38:51] <tikue> strcat: well assuming the trait issue didn't exist you don't think you could just special case collect?
[19:38:52] <strcat> it's sugar for passing a sugar, not really necessary at all
[19:38:59] <strcat> tikue: no, I don't think it could
[19:39:08] <strcat> what would it do if the iterator didn't yield enough elements?
[19:39:14] <tikue> cry? :)
[19:39:39] <tikue> a method that can fail isn't a problem really is it?
[19:39:40] <doomlord> i liked the idea that you could do a lot of iterator style things with do.. like    do collection.each |x| { .... }  but i read issues with 'return'
[19:40:10] <strcat> doomlord: that doesn't support composing iterators or generics
[19:40:11] <yed_> Hi, I tried to use zmq bindings (found on github), and it used a lot of constants from `libc`, but it doesn't work for me (eg libc::EACCES). Is problem on my side or in that library?
[19:40:13] <yed_> http://pastebin.com/4q6JzGQZ
[19:40:20] <strcat> doomlord: there's a whole lot written about it now
[19:40:33] <strcat> closure-based iteration protocol *does not* work in rust
[19:40:46] <strcat> or a strict evaluation language in general
[19:40:56] <jensnockert> orshem: Oh, wait, I can just wrap everything in a moduleâ€¦
[19:41:00] <strcat> but more so in rust because of the restrictions on closures
[19:41:05] <strcat> and because it doesn't have variadic generics
[19:41:30] <doomlord> is it just the likes of control flow (people expecting to 'return' /'break'/ etc  that breaks it
[19:41:37] <strcat> doomlord: no
[19:41:51] <strcat> 1) it does not support generics, you cannot use traits with internal iterators
[19:42:05] <strcat> 2) rust is a strict evaluation language, it cannot support generic composition or algorithms like zip
[19:42:28] <strcat> 3) it cannot support method chaining or even generic functions like map/filter because we have no variadic functions
[19:42:48] <strcat> 4) closures are very restricted when it comes to captures, the environment gives them a lifetime and they can't move out of captures
[19:42:50] <strcat> and so on
[19:43:10] <strcat> there's a lot written about it at this point though on the bug tracker and mailing list
[19:43:31] <strcat> that break/return won't necessarily work is a minor issue in comparison to those
[19:43:42] <maikklein> is it possible to define trait bounds in the trait definition like this? "pub trait Vec<T,Slice>: Dimensioned<T,Slice>+ SwapComponents {}" 
[19:43:47] <strcat> + another minor issue is that overusing closures like that led to slow compilation time
[19:43:52] <maikklein> i thought it has to be defined in the impl
[19:44:03] <strcat> maikklein: yes you can have bounds on trait type parameters
[19:44:12] <strcat> you can't have bounds on types
[19:44:15] <strcat> like a struct
[19:44:27] <maikklein> strcat, ah okay thanks
[19:45:24] <tikue> strcat: I just updated my rust repo, still getting `for` must be followed by a block call
[19:45:37] <tikue> which stage is the new for protocol in
[19:45:44] <strcat> tikue: implemented
[19:45:51] <strcat> for uses external iterators now
[19:46:12] <strcat> rusti: for (x, y) in range(0, 3).zip(range(10, 15)) { printfln!("%? %?", x, y) }
[19:46:12] -rusti- 0 10
[19:46:12] -rusti- 1 11
[19:46:13] -rusti- 2 12
[19:46:13] -rusti- ()
[19:46:13] <engla> tikue: in not-stage0
[19:46:23] <engla> if that was intended
[19:46:28] <tikue> ah weird
[19:46:31] <tikue> it doesn't work with my path
[19:46:33] <tikue> or rather
[19:46:39] <strcat> the snapshot hasn't landed
[19:46:48] <tikue> i have to do bin/rustc example.rs
[19:46:54] <strcat> there's a segfault on 64-bit OS X under valgrind
[19:47:03] <tikue> i can't just be in an arbitrary directory and type rustc example.rs
[19:47:04] <tikue> for some reason
[19:47:44] <sp3d> relative paths in some env variable?
[19:47:55] <tikue> probably. not sure how to fix it though
[19:48:04] <sp3d> "env | fgrep ./"?
[19:48:17] <sp3d> I guess you could be missing a leading / as well though
[19:49:26] <tikue> sp3d: what is it supposed to look like?
[19:50:20] <mark_edward> strcat: counld'nt we have a x.iter().collect_into(xs) function for all types implementing the COntaainer trait if we made inserting a part of the container trait?
[19:50:32] <strcat> there's .extend
[19:51:02] <mark_edward> strcat: what does that do?
[19:51:03] <sp3d> tikue: ideally, empty... "env" lists foo=bar for your variables, and grep looks for strings in there; if you have a path set to include ./foo/bar or ../../whatever it wouldn't work outside of some dirs
[19:51:03] <strcat> rusti: let mut xs = ~[]; xs.extend(range(0, 10); xs
[19:51:03] -rusti- <anon>:6:4: 6:5 error: incorrect close delimiter: `}`
[19:51:04] -rusti- <anon>:6     };
[19:51:04] -rusti-              ^
[19:51:04] -rusti- application terminated with error code 101
[19:51:07] <strcat> rusti: let mut xs = ~[]; xs.extend(range(0, 10)); xs
[19:51:08] -rusti- pastebinned 8 lines of output: http://sprunge.us/aDHC
[19:51:22] <strcat> rusti: use std::iterator::Extendable; let mut xs = ~[]; xs.extend(range(0, 10)); xs
[19:51:23] -rusti- pastebinned 7 lines of output: http://sprunge.us/hCcE
[19:51:32] <strcat> rusti: use std::iterator::Extendable; let mut xs = ~[]; xs.extend(&mut range(0, 10)); xs
[19:51:33] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[19:51:42] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[19:51:52] <strcat> rusti: use std::iterator::Extendable; let mut xs = ~[]; for _ in range(0, 2) { xs.extend(&mut range(0, 10)) }; xs
[19:51:53] <tikue> sp3d: yeah it is empty. no ./ found
[19:51:53] -rusti- ~[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[19:51:56] <sp3d> mm
[19:52:17] <sp3d> you could manually look at env to see if any RUST or LD things might be missing a leading / but I'm just guessing, sorry
[19:52:18] <mark_edward> strcat: could collect_into be implemented using that?
[19:52:29] <strcat> mark_edward: I don't know what you'd want collect_into to do
[19:52:43] <strcat> collect is only a method because static methods are painful to use atm
[19:52:51] <strcat> it can be removed when they're not
[19:52:51] <tikue> sp3d: there is no rust stuff in my env
[19:52:53] <engla> strcat: I updated the PR
[19:52:54] <tikue> my path has this
[19:52:56] <mark_edward> strcat: call clear from the container trait and then call extend
[19:52:56] <tikue> PATH=/Users/tkuehn/rust/x86_64-apple-darwin/stage2/bin:$PATH
[19:53:15] <strcat> mark_edward: yeah that could exist
[19:53:29] <strcat> but it could also be done with the Assign trait
[19:53:40] <strcat> maybe
[19:53:43] <jared> tikue: did you run `sudo make install` to install the rust binary on your system?
[19:53:51] <tikue> jared: no, was I supposed to?
[19:53:52] <mark_edward> strcat: the point of collect_into in my midn is to not contruct a new container
[19:53:55] <tikue> i didn't see that in the instructions
[19:54:08] <strcat> you should prefer not using make install
[19:54:09] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[19:54:17] <tikue> I simply did ./configure && make
[19:54:17] <jared> oh sorry, just realized you are working on OS b, that might not be part of your setup
[19:54:25] <doomlord> 'extend' is what strings seem to have as 'append' ? (i've usually used the name 'append' for adding elements to a collection)
[19:54:27] <jared> OS x*
[19:54:30] <strcat> either use it from a local dir or use a package manager
[19:54:47] <strcat> doomlord: extend takes an iterator
[19:55:15] <tikue> strcat: is there a package manager that builds rust nightly?
[19:55:24] <strcat> depends on your OS
[19:55:33] <strcat> there are nightly builds for arch linux and ubuntu, maybe others
[19:55:40] <tikue> mmm
[19:55:48] <doomlord> is all the do/old for stuff going to get removed (like    .iter().advance |x| {... } 
[19:55:58] <tikue> doomlord: do isn't going anywhere
[19:55:59] <strcat> although I think my arch linux packages will work on most linux distros
[19:56:06] <tikue> strcat: i use os x
[19:56:12] <mark_edward> strcat: i used make install regularly from a script i wrote to update rust daily on Ubuntu before there was the ubuntu repo
[19:56:15] <doomlord> ok good i like do alot :)
[19:56:50] <tikue> doomlord: for in no way replaces using do with higher order functions
[19:56:55] <tikue> :)
[19:57:07] <doomlord> ok its just better at certain things
[19:57:09] <strcat> advance will likely be removed though
[19:57:35] <strcat> rust no longer has a sanctioned internal iterator protocol
[19:57:57] *** Joins: chii (Mibbit@moz-BCB94A24.nycm.ny.dynamic.megapath.net)
[19:58:00] <tikue> strcat: that seems perfectly reasonable. TOOWTDI ? ;)
[19:58:08] <strcat> yes
[19:58:20] <strcat> it's just pretty pointless now - I only made it as a shim for the old for loop
[19:58:29] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Client exited)
[19:58:32] <doomlord> you'll still have all the xs.map(||{ ... }).collect() stuff i presume
[19:58:37] <tikue> ya
[19:58:49] <tikue> and usually if you'd want to do `do xs.each` you really just want map
[19:58:53] <tikue> amirite?
[19:58:54] <strcat> doomlord: yes that's the external iterators
[19:59:11] <doomlord> ok i'm never sure which is which (internal/external) :)
[19:59:21] <tikue> doomlord: everything nowadays is external 
[19:59:22] <strcat> tikue: the map method on vectors is deprecated though
[19:59:29] <strcat> it will be replaced 
[19:59:31] <tikue> strcat: but it'll be brought back
[19:59:34] <strcat> yeah
[19:59:39] <strcat> it will return an iterator
[19:59:43] <tikue> as it should
[19:59:45] <tikue> imo
[19:59:50] *** Joins: vilonis (jared@moz-B2CBB8FC.static.snlo.ca.charter.com)
[19:59:56] <doomlord> somevec.map().collect()?
[20:00:00] * tikue is very much in favor of having the defaults be iterators
[20:00:02] <strcat> if you really want a copy
[20:00:11] <tikue> doomlord: usually the collect won't be necessary tho
[20:00:14] *** Quits: jared (jared@moz-B2CBB8FC.static.snlo.ca.charter.com) (Quit: WeeChat 0.3.8)
[20:00:20] <tikue> doomlord: unless you need .is_empty() maybe
[20:00:40] <strcat> you can check if an iterator is empty by iterating over it ;p
[20:00:49] <doomlord> i was convinced by the idea that the short names should be the things you can chain efficiently without intermediate allocs..... xs.map(..).filter(..).collect()
[20:00:53] <tikue> strcat: but that's a lot of extra juggling heh
[20:01:01] *** Quits: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de) (Ping timeout)
[20:01:21] <strcat> doomlord: yeah but collect() won't be needed at the end most of the time
[20:01:29] <strcat> you'd have a loop over it, or a fold, etc.
[20:02:00] <strcat> or extend
[20:02:10] <doomlord> ok
[20:02:14] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[20:02:21] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[20:02:55] *** Quits: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca) (Connection reset by peer)
[20:03:00] <strcat> not sure what to do about the snapshot
[20:03:27] <chii> what are the rustic conventions for when to use ~str, &str, and/or &~str?
[20:03:45] *** Joins: brson (brson@136F0C88.6E5482D7.8DDCAE07.IP)
[20:03:45] *** ChanServ sets mode: +o brson
[20:04:05] <kimundi> chii: depends
[20:04:06] <strcat> chii: use &str until it's not enough
[20:04:25] <chii> kimundi strcat thanks
[20:04:34] *** Quits: heftig (heftig@8D5076D2.6FC4DE2F.FEC4A986.IP) (Ping timeout)
[20:04:34] <brson> strcat: did toddaaro's logging fixes get in?
[20:04:39] <strcat> and use stack allocation and borrows until that's not enough
[20:04:41] <chii> strcat so if I want to store a string in a struct, that'll have to be a ~str, right?
[20:04:41] <strcat> brson: yes
[20:04:50] <engla> chii: &str if you want to examine (read-only) a string. &~str never, &mut ~str for removing/adding to the string, ~str if you want to own the string
[20:04:53] <strcat> brson: bors went a bit mad
[20:04:53] <chii> so until then, try to keep things &str?
[20:05:01] *** Joins: heftig (heftig@8DB4145A.5C7D981D.FEC4A986.IP)
[20:05:04] <strcat> brson: ended up landing a rollup of ~5 though, including that
[20:05:17] *** Quits: jensnockert (jensnocker@moz-61E1062F.tbcn.telia.com) (Input/output error)
[20:05:18] <chii> engla thanks
[20:05:27] <doomlord> based on lifetimes, &str in a struct should work sometimes ..
[20:05:41] <chii> doomlord right, that's less flexible though
[20:05:51] <doomlord> but most uses you'd think of ~str would be more likele in a struct i think
[20:05:52] <kimundi> chii: a ~str is only needed if you want to heap allocate a string. Just for referencing and passing a read only argument to a function use &str
[20:06:08] <chii> engla I guess I'm wondering about sometimes you might want to flexibility to examine and then possibly own the string?
[20:06:15] <strcat> brson: I made a snapshot and it's segfaulting on the valgrind mac bot :(
[20:06:22] <strcat> it passed on all 4 try bots
[20:06:25] <chii> kimundi I see
[20:06:43] <strcat> brson: sadly I don't have OS X anywhere.
[20:06:52] <chii> so something like making things easier for a user (not needing to type ~ all the time) doesn't factor in? :P
[20:06:59] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[20:07:21] <kimundi> chii: nope.
[20:07:44] <chii> kimundi thanks
[20:07:46] <chii> thanks everyone!
[20:07:47] <engla> chii: you can always copy it from &str to something else
[20:07:57] <doomlord> rusts reason for existing ... distinguishing ~ & @ is important
[20:08:09] <chii> engla right
[20:08:15] <kimundi> chii: Rust is about explicitness. Wich means somewhat more verbose code compared to other languages, but at the gain of much more control about what happens
[20:08:20] <doomlord> if that wasn't important, you could just use a gc based language
[20:08:27] <chii> doomlord kimundi yes, that's what I want to try to get things clear :P
[20:08:31] <chii> *why
[20:08:43] <doomlord> its what makes rust a viable C++ alternative
[20:08:50] <doener> strcat: is it allowed to call next() on an iterator that has already reached its end? i.e. after next() already returned None?
[20:09:58] <brson> strcat: i can't investigate right now, but i can at least get a backtrace or something in a while
[20:11:42] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[20:13:00] *** Quits: yed_ (yed@329A667E.EA418F3D.536C81E0.IP) (Quit: Leaving)
[20:14:31] *** Quits: sebcrozet (sebcrozet@moz-87D51607.w80-13.abo.wanadoo.fr) (Ping timeout)
[20:14:44] *** Joins: sigma (sigma@moz-B02A5A92.dab.02.net)
[20:16:25] *** Quits: sigma (sigma@moz-B02A5A92.dab.02.net) (Ping timeout)
[20:22:28] <strcat> doener: yes, it should work fine
[20:22:33] <strcat> should just keep returning None
[20:23:59] *** Quits: gcarter (Greg_Carte@D87A4EB0.E54E9B70.CED80046.IP) (Quit: Leaving.)
[20:24:15] <doener> strcat: ok, thanks
[20:24:23] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[20:24:39] <strcat> doener: I should document that.
[20:25:48] <doener> strcat: yeah, should be known whether an iterator must or just may behave like that
[20:26:20] <strcat> doener: basically, an iterator should behave that way - but an adaptor may assume an iterator respects that rule
[20:26:36] <strcat> (the adaptor itself can't break the rule if the iterators it takes respect it)
[20:27:31] *** Joins: ross (ross@moz-8A84103E.br.br.cox.net)
[20:28:50] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[20:28:50] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/gnCuiQ
[20:28:50] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[20:28:52] *** Quits: chii (Mibbit@moz-BCB94A24.nycm.ny.dynamic.megapath.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:29:59] *** Quits: Ms2ger (Ms2ger@EDC982F3.6890FC55.187A1082.IP) (Quit: nn)
[20:30:28] *** Joins: lmandel (lmandel@48A1D3AB.D6C5F29.ADB88A9.IP)
[20:30:38] <engla> it would be very confusing if there was a difference between empty iterators and invalid iterators.  [].iter() is an empty iterator
[20:31:50] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[20:31:50] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fqdmHQ
[20:31:50] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[20:31:52] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[20:31:52] <ghrust> 01[13rust01] 15bors pushed 1 new commit to 06auto: 02http://git.io/L0PkwA
[20:31:52] <ghrust> 13rust/06auto 147510849 15bors: auto merge of #8264 : thestinger/rust/snapshot, r=cmr
[20:31:52] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[20:32:05] *** Quits: BizarreCake (BizarreCak@moz-361FE9B2.dynamic.barak-online.net) (Ping timeout)
[20:32:52] <doener> engla: I'm asking because LLVM has "GetNext..." functions that return a NULL pointer as the end marker. And you can't call next on it. So my wrappers have to take care of that.
[20:33:03] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[20:33:27] <engla> aha
[20:34:57] *** Joins: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com)
[20:36:45] <strcat> doener: can you see if you can get a trackback from that snapshot PR?
[20:36:50] <strcat> assuming you're on OS X
[20:37:00] *** Quits: alex_abreu (alex@moz-7421D6C9.mc.videotron.ca) (Ping timeout)
[20:37:00] <strcat> under valgrind
[20:37:06] <strcat> it works without vg ;[
[20:39:14] <brson> bblum: when I build master under the new runtime I hit assertions about self.kill_handle_is_some(). do your patches fix that?
[20:39:34] <brson> this is when turning on the new runtime in `start` and then building std
[20:39:45] <brson> the assert is in inhibit_kill
[20:40:33] <bblum> that is odd, probably different than what my most recent PR addressed
[20:40:36] <Eridius> strcat: after considering the problem of the Scan iterator, where you suggest that we simply document that the closure needs to obey the iterator protocol, it occurs to me that there's another problem
[20:40:48] <bblum> do you mean you are running rustc with NEWRT=1, or what?
[20:40:52] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[20:40:52] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 147510849 to 14b5d77d2: 02http://git.io/N3iJvQ
[20:40:52] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[20:40:55] <strcat> Eridius: hm?
[20:40:56] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[20:40:56] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/CyDvNA
[20:40:56] <ghrust> 13rust/06auto 14cf9e9b2 15Stepan Koltsov: Add default implementation of Map::contains_key function...
[20:40:56] <ghrust> 13rust/06auto 1418e3db7 15bors: auto merge of #8246 : stepancheg/rust/contains-key, r=thestinger...
[20:40:56] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[20:40:56] <doener> strcat: I'm on linux
[20:41:00] <strcat> doener: ah nvm :)
[20:41:06] <Eridius> strcat: even if the function behaves correctly and returns None forever if it returns it once, future calls to next() will still iterate the underlying wrapped iterator
[20:41:09] <bblum> i.e., what is the program that makes the assert trip
[20:41:13] *** Quits: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP) (Ping timeout)
[20:41:19] <Eridius> strcat: which means that any side-effects further back in the iterator chain will run, which is unexpected
[20:41:44] *** Joins: km (quassel@FDBAF0A0.DBF71E41.29C67456.IP)
[20:41:48] <strcat> Eridius: yeah but iterators are responsible for dealing with that
[20:41:59] <strcat> you'd be proposing having every adaptor second-guess every iterator it took as a parameter
[20:42:18] <strcat> instead, iterator implementations just need to be correct and stop doing anything when they reach the end
[20:42:22] <brson> bblum: oh, you don't have any outstanding patches, then?
[20:42:30] <Eridius> strcat: no I'm saying Scan is broken no matter what function you give it
[20:42:33] <Eridius> not all iterators, just Scan
[20:42:38] <strcat> Eridius: I don't understand why
[20:42:40] <bblum> brson: nope
[20:42:43] <Eridius> strcat: gimme a sec
[20:42:56] *** Quits: hjr3 (hradtke@moz-842BF853.hsd1.ca.comcast.net) (Quit: My MacBook has gone to sleep. ZZZzzzâ€¦)
[20:43:19] <brson> bblum: it's just running rustc on std with rustc using the new runtime. probably equivalent to `RUST_NEWRT=1 rustc std.rc`. I'll investigate a little more
[20:43:19] <strcat> Eridius: I don't mind adding a check to just scan
[20:43:22] <engla> Eridius: I can see there be a problem, since the state is &mut St, you can modify the state even if you return None
[20:43:29] <bblum> ok, me too
[20:43:45] <Eridius> engla: well that too, but that would be a problem with the closure, not the iterator protocol
[20:43:45] <engla> Eridius: if you'd instead return the new state like a pure function, that would be impossible.. right?
[20:43:49] <strcat> engla: yeah but that's not much different than the others
[20:43:56] <Eridius> give me a sec to construct an example for why a correct closure can still create a bad iterator chain
[20:43:57] <strcat> you can do impure stuff in any function
[20:44:00] <engla> ok yeah, closures can do whatever with state
[20:44:21] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[20:44:48] <strcat> brson: are you on OS X?
[20:45:21] <brson> strcat: no, but i have access to some os x's
[20:45:33] <strcat> brson: can you try running https://github.com/mozilla/rust/pull/8264 on one with VALGRIND_COMPILE?
[20:45:41] <strcat> it segfaults compiling the stage0 libstd
[20:45:41] <brson> ok
[20:45:50] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[20:45:52] <strcat> it works *without* valgrind though - very strange
[20:46:30] <strcat> just need a traceback of some sort
[20:46:39] <Eridius> rusti: let x = [1,2,3]; let it = x.iter().peek_(|x| printfln!(x)).scan(true, |st, &x| { if *st { *st = false; Some(x) } else { None } }); (it.next(), it.next(), it.next())
[20:46:40] -rusti- pastebinned 19 lines of output: http://sprunge.us/WAiB
[20:47:21] *** Quits: brson (brson@136F0C88.6E5482D7.8DDCAE07.IP) (Ping timeout)
[20:47:27] <Eridius> hrm, why does borrowed value not live long enough?
[20:47:33] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[20:47:33] *** ChanServ sets mode: +o brson
[20:47:43] <brson> strcat: that command won't be running under valgrind
[20:47:55] <brson> it's the same command that runs everywhere
[20:48:20] <strcat> brson: hm, the stage0 compiler isn't? ugh
[20:48:28] <engla> Eridius: because you return borrowed references to the outer scope (last expression)
[20:48:29] <strcat> I don't understand why it works on try-mac but not the auto one
[20:48:47] <Eridius> engla: no the last expression should evaluate to (Option<int>, Option<int>, Option<int>)
[20:48:54] <brson> that machine doesn't even have valgrind!
[20:48:55] <Eridius> the scan removes the &
[20:48:58] <brson> wtf
[20:49:36] <brson> i know i've seen valgrind errors on the mac valgrind builders
[20:49:43] <brson> i wonder if some of the slaves have it and some don't
[20:49:57] <brson> the build system seems to not care if valgrind is not installed, even if it's requested
[20:50:05] <strcat> that's pretty bad ;s
[20:50:11] <strcat> it should fail hard if it's not there
[20:50:14] <strcat> and you ask for it
[20:50:19] <acrichto> engla: re consume_iter -- if we're not being consistent yet it's not really useful trying to be consistent anyway, at some point a decision should be made and then everything should change at once would probably be the best course of action
[20:50:45] <strcat> brson: it's pretty odd that it's failing on one machine and not the other though
[20:50:53] <bblum> brson: is it deterministic? does the compile have to fail? what stage?
[20:50:59] <engla> acrichto: I think it's fine either way
[20:51:18] <engla> acrichto: I'm just used to the _iter suffixes, but I realize it must be standardized at some point
[20:51:50] <acrichto> engla: I'm fine with it for now, but I also thought that all the _iter suffixes were for name collisions at the start and now they can start going away, that could be wrong though
[20:52:15] <Eridius> borrowed pointer must be valid for the static lifetime" ... why?
[20:52:17] <strcat> they will probably go away
[20:52:20] <engla> The main method is .iter(), the others just follow that name
[20:52:21] <strcat> the suffixes
[20:52:36] <strcat> .map(), .filter(), etc. instead of _iter
[20:52:41] <strcat> but... rev_iter will probably keep it
[20:52:49] <strcat> .rev() sounds like in-place reverse
[20:52:55] <engla> .iter() and .mut_iter() have no suffix to remove
[20:53:01] <acrichto> that sounds right to me
[20:53:04] <strcat> engla: right
[20:53:10] <Eridius> oh huh, apparently it's the print in the peek. Why that requires it to be static I have no clue
[20:53:10] <acrichto> consume_iter sounds like it could lose _iter though
[20:53:18] <Eridius> since the closure should be tied to the iterator
[20:53:23] <brson> strcat: i'll do a build on that machine
[20:53:52] *** Joins: froystig (froystig@5A39C99E.352137A1.BCED17D.IP)
[20:53:58] <Eridius> ok, double-hmm.. the peek actually gets &&int. Maybe that's doing something weird. Although printing *x vs x really shouldn't have any effect on lifetimes
[20:54:07] *** Quits: froystig (froystig@5A39C99E.352137A1.BCED17D.IP) (Quit: leaving)
[20:54:25] <brson> bblum: this command always fails for me: x86_64-unknown-linux-gnu/stage1/bin/rustc --cfg stage1  -O -Z no-debug-borrows --target=x86_64-unknown-linux-gnu  -D warnings -o x86_64-unknown-linux-gnu/stage1/lib/rustc/x86_64-unknown-linux-gnu/lib/libstd.so /home/brian/dev/rust/src/libstd/std.rs
[20:54:35] *** Joins: froystig (froystig@5A39C99E.352137A1.BCED17D.IP)
[20:54:36] <brson> with std modified to use newrt
[20:54:37] <Eridius> rusti: let x = [1,2,3]; let mut it = x.iter().peek_(|x| printfln!(*x)).scan(true, |st, &x| { if *st { *st = false; Some(x) } else { None } }); (it.next(), it.next(), it.next())
[20:54:38] -rusti- &1
[20:54:38] -rusti- &2
[20:54:38] -rusti- &3
[20:54:38] -rusti- (Some(1), None, None)
[20:54:42] <Eridius> strcat: that is the problem ^
[20:54:46] <bblum> brson: ok yep, i just got it too
[20:54:51] <bblum> looking into it
[20:54:53] <Eridius> the iterator pipeline was called 3 times, even though scan only ever returned one value
[20:54:59] <Eridius> so side-effects (e.g. the peek) in the pipeline are being called
[20:55:11] <strcat> Eridius: yeah but that's normal
[20:55:15] <strcat> it happens everywhere else too
[20:55:18] <Eridius> it's quite unexpected
[20:55:26] *** Quits: froystig (froystig@5A39C99E.352137A1.BCED17D.IP) (Quit: leaving)
[20:55:26] <Eridius> strcat: I think Scan is the only one that behaves this way
[20:55:36] *** Quits: mrhandle (Mibbit@3448BE39.6A13B4BB.6692E697.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[20:55:51] <strcat> Eridius: I know others do too
[20:55:54] <Eridius> what others?
[20:55:55] <strcat> next_back on chain
[20:55:59] <strcat> and more
[20:56:03] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[20:56:13] <Eridius> oh hmm, I haven't looked at the double-ended stuff yet
[20:56:27] <engla> Eridius: zip
[20:56:33] *** Joins: ecr (Thunderbir@moz-F724119C.uoregon.edu)
[20:56:56] <strcat> Eridius: that's just how they're implemented, we aren't going to have a bool in each adaptor
[20:57:00] <Eridius> engla: ahh, you're probably right there
[20:57:14] <Eridius> hmm
[20:57:23] <strcat> not supposed to have side effects if they're done
[20:57:29] *** Joins: azita (Azita@C828EC68.8E67A50A.508D426F.IP)
[20:57:36] <Eridius> strcat: exactly my point
[20:57:46] <strcat> yes, so it's wrong to write an iterator with a side effect after it's done
[20:57:48] <Eridius> if they're done, subsequent calls to next() should be idempotent. But the rest of the iterator chain doesn't know its done
[20:58:01] <Eridius> strcat: I can write an iterator with a side-effect and have it be correct, and then someone else can wrap it and now things break
[20:58:11] <strcat> Eridius: I don't get it
[20:58:23] <Eridius> strcat: my iterator can be perfectly correct and obey the iterator protocol, and have side effects
[20:58:25] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Quit: victorporof)
[20:58:27] <Eridius> someone else can wrap it
[20:58:34] <Eridius> the total pipeline can end early, but my iterator _doesn't know it's done_
[20:58:36] <strcat> if it has side effects on .next() calls when it's done, it's not correct
[20:58:39] <Eridius> so my iterator continues to execute side-effects
[20:58:50] <bblum> brson: ok, this is just the "UnsafeArc destructor uses unkillable" problem, which we should find a more principled solution to
[20:58:54] <Eridius> strcat: see the example I gave rusti. The peek doesn't know it's done, so it continues to have side-effects (e.g. printing)
[20:59:16] <engla> Eridius: not clear that it's a problem that side effect execute. You just filter the result value out in the end
[20:59:28] <strcat> Eridius: peek is meant to be that way
[20:59:38] <strcat> it's a debugging tool
[20:59:40] <Eridius> engla: the assumption is that once an iterator returns None, future calls to .next() will be idempotent, e.g. won't have side-effects
[20:59:48] <Eridius> strcat: peek is just an example, I could write another iterator that has side effects
[21:00:04] <strcat> Eridius: okay, and by having a side effect when it's done *you* are breaking the protocol
[21:00:12] <Eridius> strcat: no I'm not
[21:00:15] <strcat> you are
[21:00:19] <Eridius> strcat: no, please think about this.
[21:00:22] <Eridius> MY iterator is not done
[21:00:25] <strcat> it is done
[21:00:26] <Eridius> the WRAPPED iterator is done
[21:00:31] <strcat> your adaptor is done if you call .next()
[21:00:33] <strcat> that's how adaptors work
[21:00:38] <Eridius> MY iterator has no possible way of knowing that the wrapped iterator finished
[21:00:40] <strcat> if you call .next() and it's done
[21:00:45] <strcat> Eridius: yes it does, it calls .next()
[21:01:04] <Eridius> strcat: please, think about what I'm saying instead of just assuming I'm wrong, because you've got something horribly confused
[21:01:09] <Eridius> I have iterator A, which I wrote, which has a side effect
[21:01:17] <Eridius> someone else wraps it in adaptor B
[21:01:18] <n0v> Will there be an equivalent of .isatty() for @Reader? I'm not sure how to query @Reader to ask if it's stdin. 
[21:01:19] <strcat> when does it have a side effect?
[21:01:20] <Eridius> adaptor B ends early
[21:01:32] <Eridius> but calling .next() on adaptor B calls .next() on my iterator A, which _is not yet done_
[21:01:40] <Eridius> so my iterator A continues to have side effects, even after the adaptor is done
[21:01:40] <bblum> brson: the unkillable is for unwrap(), and KillHandles are only unwrapped when it's safe to call unkillable, but some other UnsafeArcs (like, for example, this SharedChan<monitor_msg> in rustc.rs, do get dropped where it's not safe to call unkillable, but never get unwrapped, so don't need to call unkillable
[21:01:44] <Eridius> because A _cannot_ know that B was done
[21:01:52] <Eridius> hell, A doesn't even know it was wrapped at all
[21:02:24] <strcat> okay I see what you're saying
[21:02:29] <strcat> the ones that stop early need a bool
[21:02:34] <Eridius> yes, that's what I'm saying
[21:02:53] <strcat> so zip
[21:02:55] <strcat> among others
[21:02:58] <Eridius> or at least, some way of determining that they're done (e.g. maybe wrap the fn in an Option, since that won't expand the size of the struct)
[21:03:19] <strcat> the size of the struct doesn't really matter much
[21:03:26] <Eridius> yes it's unfortunate, but it's the only way to preserve idempotency in the face of side-effectful iterators
[21:04:07] <Eridius> this is actually why I kind of liked your original stated position that the iterator protocol no longer holds once None is returned, although I recognize the practical difficulties with that
[21:04:25] <strcat> well... we *could* say that
[21:04:35] <strcat> it's not defined in the docs yet
[21:04:35] <bblum> brson: in particular, it's getting put inside of a @fn() ("diagnostic::Emitter"), which is destructed in the box annihilator
[21:04:53] <Eridius> strcat: stating that has another benefit, which is that certain iterators could actually explicitly define behavior after None is returned
[21:05:15] <brson> bblum: why is it not safe to call unkillable in the box annihilator?
[21:05:27] <Eridius> so you could have an iterator that does a non-blocking read, and returns None when there is no data
[21:05:29] <strcat> could just say that the iterator protocol does not specify behaviour after None is returned
[21:05:38] <Eridius> strcat: yes, that's what the iterator protocol would say in this case
[21:05:39] <strcat> but individuals iterators may specify what they want
[21:05:42] <Eridius> exactly
[21:05:43] <brson> is the box annihilator run at the wrong time?
[21:06:11] <bblum> brson: 'wrong' is subjective, but 'perhaps yes'
[21:06:22] <brson> yeah, it's running user code outside of the try/catch block
[21:06:23] <brson> seems wrong
[21:06:32] <Eridius> the downside to this is people who don't read carefully may assume that .next() is idempotent once None is returned. But I'm not sure if that's a significant concern
[21:06:36] <bblum> brson: hmm, agreed
[21:06:51] <strcat> Eridius: an adaptor could be used if you actually need that guarantee
[21:06:56] <Eridius> strcat: true
[21:07:06] <bblum> brson: you could fix this particular problem by moving the cleanup::annihilate call in Task::destroy to putting it in Task::run before the call to collect_failure()
[21:07:19] <bblum> but it probably wants to be inside the self.unwinder.try() function itself
[21:07:31] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[21:07:45] <bblum> brendanc: do self.unwinder.try { do f.finally { cleanup::annihilate() } }
[21:07:51] <strcat> Eridius: well, we could say it's not specified that adaptors will stop calling the ones they wrap after they return None
[21:07:52] <bblum> uh. come back brson
[21:07:53] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:07:53] *** ChanServ sets mode: +o brson
[21:07:54] <strcat> hm
[21:07:56] <brson> omg wifi
[21:08:05] <Eridius> strcat: I think that's more confusing
[21:08:11] <bblum> brson: probably do self.unwinder.try { do f.finally { cleanup::annihilate() } }
[21:08:18] <Eridius> harder to explain, more complicated rule for people to have to remember
[21:08:22] <brson> bblum: is running outside of the try/catch the reason it's incorrect to call unkillable here?
[21:08:51] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[21:09:01] <Eridius> strcat: and actually the practical effect will be similar to just saying it's not defined, since anyone who doesn't know the full iterator chain their using _and_ needs to rely on behavior after next() returns None would have to use the new adaptor that enforces this
[21:09:11] <Eridius> because they wouldn't be able to know if the iterator chain is side-effectful
[21:09:14] <bblum> brson: running after collect_failure() is the reason; collect_failure() sets the kill_handle to None (because it needs to unwrap it).
[21:09:21] <strcat> Eridius: true
[21:09:37] <strcat> it would make it a *lot* more complicated to enforce the guarantee
[21:09:59] <Eridius> ack s/their/they're/
[21:10:00] *** Quits: azita (Azita@C828EC68.8E67A50A.508D426F.IP) (Quit: azita)
[21:10:11] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[21:10:32] *** Quits: lmandel (lmandel@48A1D3AB.D6C5F29.ADB88A9.IP) (Quit: lmandel)
[21:10:48] <Eridius> strcat: ok, so I think the only 2 reasonable approaches are 1) iterator protocol does not define behavior after None is returned, or 2) every single adaptor needs to remember that it returned None and short-circuit
[21:10:52] <Eridius> #1 is a lot simpler
[21:10:58] <Eridius> well, implementation-wise. #2 is simpler for users
[21:11:01] <bblum> though i'm not sure calling cleanup::annihilate() inside unwinder.try() will help anything either; that's just the "what happens if the GC fails during failure" problem
[21:11:12] <bblum> also, just moving the collect_failure call to inside destroy() after the annihilate() call would work too
[21:11:24] <Eridius> but #1 allows individual iterators to define behavior after None if they want (e.g. you could, say, reset the iterator and repeat everything)
[21:11:37] <strcat> Eridius: right and that's useful
[21:12:13] *** Quits: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net) (Ping timeout)
[21:12:17] <Eridius> strcat: at this point, I'd be comfortable with either approach, but I think #1 is better
[21:12:24] <strcat> adding bools everywhere is going to kill the simplicity of writing an adaptor
[21:12:38] <strcat>         match (self.a.next(), self.b.next()) {
[21:12:40] <strcat>             (Some(x), Some(y)) => Some((x, y)),
[21:12:42] <strcat>             _ => None
[21:12:44] <strcat>         }
[21:12:49] <strcat> like that (zip) would need to mark a bool as false in the None path
[21:12:53] <strcat> and then check it at the start
[21:13:03] <Eridius> strcat: yeah, well, you could always wrap your core iterator in our new adaptor, but then a long chain of iterators would get a bunch of copies of this same adaptor, which is terrible
[21:13:25] <Eridius> e.g. fn zip() { Zip{left: Foo{left}, right: Foo{right}, ... })
[21:13:26] <brson> bblum: i do think the box annihilator does need to go in the try block since the bounds of the try/catch are essentially the extent of the task. users shouldn't be able to affect anything outside it. the recursive failure problem is something we've already got anyway
[21:13:50] <Eridius> (I'm not seriously advocating for this)
[21:14:10] <brson> brson: does collect_failure run any user-specified closures?
[21:14:21] <bblum> it does not
[21:14:41] <brson> ugh, local storage needs to move in there too
[21:14:44] <strcat> side effects make this much more annoying than it should be
[21:14:45] <bblum> brson: if the destruction of the LocalStorage needs to happen before the annihilator (it currently is that way, not sure if it needs to be), then it would have to
[21:14:53] <bblum> yeah, what you just said :P
[21:14:56] <brson> fn destroy is just bogus
[21:15:42] <bblum> feel free to reorder it as you like; i don't think collect_failure needs to happen before anything else
[21:16:37] <brson> ok, i'll move things around and give it a try
[21:16:47] <bblum> it already has a try
[21:17:09] <bblum> ;)
[21:17:11] <doy> n0v: @Writer has get_type, which may be close enough
[21:17:19] <doy> depending on what you're doing
[21:17:27] <Eridius> strcat: any ideas for the name of this adaptor that makes next()->None idempotent?
[21:17:32] <brson> lol
[21:18:34] <doy> not sure why @Reader doesn't have get_type
[21:19:02] *** Quits: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) (Ping timeout)
[21:20:55] *** Joins: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP)
[21:21:25] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[21:21:32] *** Joins: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP)
[21:21:39] <strcat> Eridius: still thinking about it, sec
[21:21:58] <Eridius> strcat: I'm working on updating documentation and implementing this adaptor, I just don't have a name
[21:21:59] <brson> strcat: the mac is rebuilding llvm atm
[21:22:56] <bblum> ok, confirmed that moving collect_failure to after annihilate makes it work
[21:23:13] *** Quits: robertknight (robertknig@moz-AB0E96D7.range86-162.btcentralplus.com) (Ping timeout)
[21:23:51] *** Joins: lkuper (lkuper@E0D3ECD7.A402E718.C082B7DC.IP)
[21:24:22] <n0v> doy: Ah, thanks!
[21:26:12] *** Joins: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[21:26:23] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[21:26:36] *** Quits: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Leaving)
[21:26:46] *** Quits: alisdair (textual@1697D94C.7742FB18.FBC8476D.IP) (Ping timeout)
[21:28:55] <engla> Eridius: (Zip only needs one flag, not one per iterator)
[21:29:18] <Eridius> engla: yes, like I said my suggestion wasn't serious, it was just an example of how you could make writing the adaptor simpler
[21:29:35] <Eridius> rather, avoid making it more complicated, by always adding this proposed new adaptor
[21:29:47] <Eridius> still need a name for it :/
[21:29:49] <engla> right
[21:30:07] <engla> Eridius: backflow valve? :)
[21:30:10] <Eridius> hah
[21:31:27] <engla> don't forget to implement double-ended and random access for the adaptor
[21:32:06] <miloshadzic> any way to recover from a fail?
[21:32:23] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[21:32:26] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[21:32:26] *** ChanServ sets mode: +o brson
[21:32:31] <engla> or maybe it doesn't matter, it should be mostly stream iterators (non-bidi, non-random access) that have this problem
[21:32:33] *** Quits: cade (cade@moz-DB3BF95F.members.linode.com) (Quit: Bye!)
[21:32:45] <miloshadzic> i know that a piece of code may fail!() at some point but i'd rather it failed silently
[21:32:50] *** Joins: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr)
[21:32:50] *** Quits: sebcrozet (sebcrozet@moz-2517AE39.w80-13.abo.wanadoo.fr) (Quit: sebcrozet)
[21:33:10] <Eridius> engla: double-ended sure, not sure if it makes sense for random access
[21:33:53] <engla> well if the underlying iterator is random access you want to preserve that
[21:34:12] <Eridius> engla: sure, but it won't affect behavior of the random-access methods
[21:34:14] *** Joins: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[21:34:22] *** Quits: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Leaving)
[21:34:45] <Eridius> should only need one flag for next() and next_back() though, because it doesn't make sense to have an iterator that returns None for one but not the other (although it's certainly possible to write)
[21:36:46] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[21:37:16] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[21:37:54] <brson> strcat: (gdb) r
[21:37:54] <brson> Starting program: /Users/administrator/scratch/rust/build/x86_64-apple-darwin/stage0/bin/rustc --cfg stage0 -O --target=x86_64-apple-darwin -A warnings -o x86_64-apple-darwin/stage0/lib/rustc/x86_64-apple-darwin/lib/libstd.dylib /Users/administrator/scratch/rust/src/libstd/std.rs
[21:37:58] <brson> warning: The target crashed on startup, maybe the shell is crashing.
[21:38:02] <brson> fun
[21:38:03] <strcat> huh
[21:38:23] <brson> i'll find a machine with valgrind and try actually valgrinding it
[21:38:32] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[21:38:42] <brson> x86_64-apple-darwin/stage0/bin/rustc                                                                                                                                    Illegal instruction: 4
[21:39:35] <strcat> a shot in the dark is that the snapshot machine is newer, and generates code invalid on the old OS X
[21:40:55] * kimundi wonders why he is always drawn towards big changes...
[21:40:59] <kimundi> r? https://github.com/mozilla/rust/pull/8268
[21:42:02] *** Joins: chii (Mibbit@moz-474FFD66.nycmny.east.verizon.net)
[21:44:58] <tikue> what is this adaptor you guys are talking about?
[21:45:02] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[21:45:45] <Eridius> tikue: one that keeps a boolean flag and returns None without calling the underlying it.next() if the underlying iterator returned None in the past
[21:45:48] <brson> strcat: segfaults on my macbook too
[21:46:27] <tikue> Eridius: the only motivation being to save the function call?
[21:46:48] <Eridius> tikue: no, the motivation being to avoid unexpected side-effects further back in the iterator pipeline
[21:47:04] <Eridius> and to define behavior after None is returned
[21:47:08] <kimundi> Eridius: still looking for a name?
[21:47:18] <Eridius> since the current proposal is to have the iterator protocol only define up until None is returned once, and abdicate all further responsibility
[21:47:21] <Eridius> kimundi: yep
[21:47:29] <Eridius> my best thought so far is .cap(), which really isn't very descriptive
[21:47:36] <kimundi> hm... terminate() TerminatorIterator ?
[21:47:39] <Eridius> or .enforceNoneIdempotency(), which is a mouthful
[21:48:01] <brson> strcat: valgrind says 'bad executable (no stack)'!
[21:48:06] <Eridius> kimundi: hmm, not sure
[21:48:07] <tikue> Eridius: wait really? I thought part of the protocol is that it'd keep returning None
[21:48:13] <Eridius> tikue: that's not actually defined at the moment
[21:48:14] <kimundi> fuse() : Gets triggered on first None
[21:48:17] <tikue> oh wow
[21:48:18] <Eridius> tikue: strcat's gone back and forth on that
[21:48:34] <tikue> I've definitely committed Servo code that relies on that :\
[21:48:40] <Eridius> heh, oops
[21:48:46] <brson> strcat: rustc is only 9k
[21:48:53] <strcat> brson: hrm
[21:48:56] <kimundi> FuseIterator ... I like that name :P
[21:48:59] <sp3d> ".make_strict()" has potential for misunderstanding but it's short
[21:48:59] <tikue> oh wait jk
[21:49:01] <tikue> I haven't haha
[21:49:03] *** Joins: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com)
[21:49:03] <strcat> brson: I can't see how it succeeds on the try bot
[21:49:03] <tikue> whew
[21:49:10] <Eridius> kimundi: hmmmmm, that has potential
[21:49:12] <strcat> brson: could it be an s3 issue?
[21:49:13] *** Quits: doomlord__ (doomlod@moz-13E69BC8.range86-180.btcentralplus.com) (Quit: Leaving)
[21:49:21] * strcat shrugs
[21:49:23] <tikue> Eridius: what kind of side effects though?
[21:49:44] <Eridius> tikue: whatever you want. I could use an iterator adaptor like .peek() or .transform(), or I could write my own adaptor, that does things
[21:49:51] <Eridius> any existing adaptor that takes a &fn can have side effects
[21:49:51] <kimundi> Eridius: It implies that nothing really changes, but an special kind of protection is added
[21:50:01] <strcat> lets say you have [1, 2, 3, 4, 5]
[21:50:10] <strcat> and you use peek, printing out the value when it yields
[21:50:13] <Eridius> kimundi: I think I'm going to use fuse() unless someone comes up with a better idea. Thanks
[21:50:14] <strcat> and now zip that with [1, 2, 3]
[21:50:17] <strcat> so it will yield
[21:50:23] <strcat> (1, 1), (2, 2), (3, 3)
[21:50:26] <strcat> and print 1, 2, 3
[21:50:28] <Eridius> rusti: let x = [1,2,3]; let mut it = x.iter().peek_(|x| printfln!(*x)).scan(true, |st, &x| { if *st { *st = false; Some(x) } else { None } }); (it.next(), it.next(), it.next())
[21:50:29] -rusti- &1
[21:50:29] -rusti- &2
[21:50:29] -rusti- &3
[21:50:29] -rusti- (Some(1), None, None)
[21:50:32] <Eridius> tikue: ^
[21:50:32] <brson> oh rustc is just a tiny stub. 9k is probably ok
[21:50:34] <strcat> hm
[21:50:42] <strcat> Eridius: well you know, it already has side effects
[21:50:52] <strcat> it will print "4"
[21:50:57] <strcat> because it has to check that it's done
[21:51:09] <Eridius> strcat: yes, I know. And that I'm willing to accept
[21:51:23] <tikue> i see
[21:51:38] <Eridius> strcat: not only is that perfectly legit when the iterator protocol doesn't define behavior after None
[21:51:40] <strcat> even ones with hasNext in scala have side effects in hasNext - it has to read from a socket to know there's more
[21:51:59] <Eridius> strcat: but it's also ok when we try to add idempotency, since subsequent calls to .next() won't trigger side-effects and thus will not change the world
[21:52:01] *** Quits: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Ping timeout)
[21:52:23] <Eridius> strcat: the goal here is that if `it.next()` returns None, then `it.next(); it.next(); it.next()` should behave identically to just `it.next()`
[21:52:43] <Eridius> strcat: so a side-effect on the very first `it.next()` is fine, since the subsequent ones won't trigger side-effects and thus you can add as many future calls to `it.next()` as you want
[21:52:53] *** Joins: jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[21:53:05] <tikue> rusti: printfln!(2);
[21:53:05] -rusti- 2
[21:53:05] -rusti- ()
[21:53:09] <tikue> since when could you do that
[21:53:20] <Eridius> idempotency doesn't mean "every call behaves the same", it means that behavior is unchanged when you call it multiple times
[21:53:20] <tikue> rusti: print(2);
[21:53:20] -rusti- <anon>:5:15: 5:16 error: mismatched types: expected `&str` but found `<VI0>` (expected &str but found integral variable)
[21:53:21] -rusti- <anon>:5          print(2);
[21:53:21] -rusti-                         ^
[21:53:21] -rusti- error: aborting due to previous error
[21:53:21] -rusti- application terminated with error code 101
[21:53:29] <Eridius> tikue: a couple weeks ago IIRC
[21:53:36] <tikue> nice
[21:53:42] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[21:53:45] <tikue> rusti: printfln!(2, 3, 4);
[21:53:45] -rusti- <anon>:5:19: 5:20 error: first argument to fmt! must be a string literal.
[21:53:45] -rusti- <anon>:5          printfln!(2, 3, 4);
[21:53:45] -rusti-                             ^
[21:53:46] -rusti- application terminated with error code 101
[21:53:51] <Eridius> tikue: printfln!(...) is equivalent to println(fmt!(...)), with the addition that printfln!(x) is the same as println(fmt!("%?", x))
[21:54:02] <tikue> ok
[21:54:03] <Eridius> if you have multiple args you need a fmt string
[21:54:03] <strcat> hm, how the hell does python do this
[21:54:06] <tikue> thanks
[21:54:12] <tikue> strcat: do what?
[21:54:21] <strcat> oh because it throws
[21:54:23] <strcat> nvm
[21:54:38] <brson> strcat: it does seem likely that the toolchain on the new bots just produces binaries that are incompatible with older machines
[21:54:40] <Eridius> tikue: I believe there's also printf!() which is print() instead of println()
[21:54:56] <tikue> rusti: printf!(2);
[21:54:56] -rusti- 2()
[21:55:01] <tikue> ah ok
[21:55:21] <strcat> Eridius: http://ix.io/72J in python the order passed to zip matters
[21:55:25] <strcat> we run both next() 
[21:56:03] <Eridius> strcat: ok so python short-circuits, and we don't. Not sure if that really matters
[21:56:08] <Eridius> we could certainly add short-circuit behavior to our zip
[21:56:12] <Eridius> heck, maybe we should
[21:56:16] <strcat> Eridius: fyi python works like what I wrote
[21:56:25] <strcat> it doesn't make the guarantee
[21:56:32] <strcat> so I don't think we should
[21:56:40] <Eridius> which guarantee?
[21:56:44] <strcat> here
[21:56:46] <strcat> I'll give an example
[21:57:03] <strcat> Eridius: http://ix.io/72K
[21:57:07] <strcat> it calls down the pipeline when it's done
[21:57:12] <strcat> it doesn't record the intermediate end
[21:57:29] <strcat> the only difference is that their zip short-circuits
[21:57:38] <Eridius> strcat: that's compatible with the approach I'm going for now of no defined behavior once None is returned
[21:57:44] <strcat> yeah
[21:57:46] <strcat> I know
[21:57:49] *** Joins: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de)
[21:58:37] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[21:58:52] *** Joins: tcr (tcr@moz-1C4F4144.hsd1.ma.comcast.net)
[21:59:41] <maikklein> bjz, ping
[21:59:45] *** Parts: sigma (sigma@51C589B3.EF2694B5.DFAC6AA7.IP) ()
[21:59:58] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[22:00:04] <brson> strcat: when I run ld on the bot that did the snapshot it says 'ld: warning: -macosx_version_min not specified, assuming 10.7'. my macbook at least is running 10.6. the other bots are on 10.7 though
[22:00:13] <strcat> ah
[22:00:21] <Earnestly> strcat: Doesn't haskell's zip just truncate the longer list?
[22:00:27] <strcat> I wonder why this only became a problem recently
[22:00:43] <strcat> Earnestly: we're not talking about that behaviour atm, but rather side effects in the iterator pipeline
[22:00:52] <strcat> brson: so I guess we need to be setting that...
[22:00:57] <brson> oh, but maybe gcc sets the macosx_version_min to something conservative, since we don't run ld directly
[22:01:10] <brson> we did just add two new bots, and one of them did the snap
[22:01:26] <brson> the old bots' ld says the same thing though
[22:01:30] <strcat> oh
[22:01:43] <strcat> can you try running the binary on a bot with 10.7?
[22:01:53] <strcat> just to verify try isn't doing something weird
[22:02:11] <tikue> what's preventing transform from being renamed to map now?
[22:02:20] <strcat> method resolve issue
[22:03:06] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Ping timeout)
[22:04:03] <Eridius> strcat: if pcwalton's deref() proposal becomes reality, I'm thinking the iterator adaptors (that wrap a single one, so not Zip) should implement it, so that iterators can define extra methods and have them be usable through adaptors
[22:04:24] <strcat> doesn't necessarily make much sense to do that
[22:04:37] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[22:04:51] <strcat> you can't just have iterators that aren't double-ended exposing next_back transparently from the parent
[22:04:52] <Eridius> well at the moment iterators don't tend to define extra methods. But if one did, it would be nice if an adaptor didn't break that
[22:04:53] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[22:04:58] <strcat> I don't think so
[22:04:59] <Eridius> since the adaptors are only intended to modify the behavior of the iterator methods
[22:05:03] <strcat> the adaptor breaks those assumptions
[22:05:10] <Eridius> oh hmm, that's a good point about .next_back()
[22:05:17] <strcat> there are other cases though
[22:05:21] <strcat> the adaptor changes the meaning
[22:05:25] *** Joins: int3_ (int3_@moz-1BCA8397.static.monkeybrains.net)
[22:05:28] <Eridius> ok fine
[22:05:30] <maikklein> https://github.com/bjz/lmath-rs/blob/master/src/math/mat.rs#L99 "error: failed to find an implementation of trait math::SwapComponents for math::mat::Mat2<T>" does this error make sense? afaik it shouldn't even need an impl for Mat2 only for T
[22:05:52] <strcat> Eridius: I think we should copy python here as you suggest though
[22:06:05] <Eridius> second thought: I think I'm going to add a .resetFuse() method to this Fuse adaptor. Not sure if it's actually useful, but maybe
[22:06:10] <Eridius> strcat: you mean short-circuiting?
[22:06:14] <strcat> both ;p
[22:06:27] <miloshadzic> i know that a piece of code may fail!() at some point but i'd rather it failed silently
[22:06:45] <Eridius> both what? the other behavior, where python does call through the pipeline after it was done, is the current behavior (and won't change)
[22:06:51] <strcat> Eridius: yeah, that
[22:07:05] <Eridius> since I'm going with protocol doesn't define post-None, I'm not changing that behavior
[22:07:55] *** Joins: azita (Azita@C828EC68.8E67A50A.508D426F.IP)
[22:07:57] *** Quits: thpickert (thpickert@moz-34341F25.dynamic.dsl.tng.de) (Quit: thpickert)
[22:08:27] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[22:08:27] *** ChanServ sets mode: +o brson
[22:08:31] *** Quits: mark_edward (quassel@moz-9631ECE3.public.wayport.net) (Ping timeout)
[22:10:19] *** Quits: int3_ (int3_@moz-1BCA8397.static.monkeybrains.net) (Client exited)
[22:10:41] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[22:11:57] *** Quits: bytbox (s@moz-DC83764A.washdc.fios.verizon.net) (Input/output error)
[22:12:04] <Eridius> strcat: do you agree with me that Fuse can use one bool for .next() and .next_back() together, because if one returns None, the other should also return None?
[22:12:14] <strcat> yes
[22:13:10] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[22:14:57] *** Quits: chii (Mibbit@moz-474FFD66.nycmny.east.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:15:11] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:15:11] *** Quits: azita (Azita@C828EC68.8E67A50A.508D426F.IP) (Quit: azita)
[22:15:57] <brson> strcat: I reconfigured buildbot to not allow the new mac bots to do the snap. can you make another?
[22:16:04] <strcat> brson: yeah
[22:16:19] <strcat> brson: I'm not sure how to force builds anymore though, I might have to redo them all
[22:16:29] <strcat> let me see..
[22:17:41] *** Joins: bytbox (s@moz-DC83764A.washdc.fios.verizon.net)
[22:17:50] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[22:21:04] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[22:22:56] *** Joins: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP)
[22:22:56] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/CyDvNA
[22:22:56] *** Parts: ghrust (ghrust@E7A4CCE2.6A2AE50.F3114085.IP) ()
[22:23:08] <tikue> any idea when we'll be able to do 
[22:23:10] <tikue> rusti: for &x in [1, 2, 3].iter() { printfln!(x); }
[22:23:11] -rusti- pastebinned 11 lines of output: http://sprunge.us/MjdI
[22:23:43] <strcat> that's the rvalue issue
[22:23:52] <strcat> I don't think it's decided what should be done there yet
[22:24:07] <strcat> brson: yeah I don't think we can force builds anymore.
[22:24:35] *** Joins: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP)
[22:24:35] <ghrust> 01[13rust01] 15thestinger merged 06auto into 06snap-stage3: 02http://git.io/7S4JuA
[22:24:35] *** Parts: ghrust (ghrust@614D05BD.6A2AE50.F3114085.IP) ()
[22:25:00] <tikue> strcat: what do you mean "decided"? i.e. what are the options?
[22:25:10] <Eridius> grr, I can't say `x@Some(_)`. "error: cannot bind by-move with sub-bindings". But _ isn't a real binding!
[22:25:19] <strcat> tikue: it could live to the end of the expr or to the end of the block
[22:25:34] <maikklein> trait foo : bar  . is this trait inheritance?
[22:25:45] <strcat> yes
[22:25:53] <strcat> anything implementing foo also implements bar
[22:25:54] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[22:25:54] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/E_9Fng
[22:25:54] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[22:25:55] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:25:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/uuFLEw
[22:25:55] <ghrust> 13rust/06auto 147fc8807 15Marvin LÃ¶bel: Updated std::Either and std::Result...
[22:25:55] <ghrust> 13rust/06auto 14618c7e2 15bors: auto merge of #8268 : Kimundi/rust/master, r=pcwalton...
[22:25:55] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:26:12] <tikue> strcat: oh ok. either way it'll work, though, right? also, why would it ever need to live to the end of the block?
[22:26:51] <strcat> tikue: wouldn't necessarily need to but how long does the compiler extend the lifetime?
[22:26:58] <strcat> does it extend it as long as the borrows are kept around?
[22:26:59] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Client exited)
[22:27:06] <strcat> what about raw pointers? it won't be able to track that.
[22:27:18] <strcat> so
[22:27:22] <strcat> let x = &5;
[22:27:24] <strcat> will be well defined
[22:27:34] <strcat> let x: *int = &5; <- I don't think this is well defined
[22:27:47] <tikue> hm
[22:28:05] <strcat> or...
[22:28:11] <strcat> x.takes_borrow().takes_raw()
[22:28:15] <strcat> where x is an rvalue
[22:28:27] <strcat> if it lives until the end of a trackable expr, it's gone after takes_borrow()
[22:28:49] <tikue> true
[22:29:32] <tikue> could the life time be appropriately inferred by the context or something
[22:29:43] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:31:02] <strcat> C++ extends to the end of an expr or as long as there's a *const* reference to it
[22:31:07] <kimundi> strcat: Hm, but isn't it kinda the failt of the programmer to get a raw pointer from a temporary?
[22:31:08] <strcat> it doesn't care about non-const refs or ptrs ;p
[22:31:09] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[22:31:09] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[22:31:26] <strcat> kimundi: but if we're extending the life of temporaries as long as needed otherwise.... it is an easy trap to fall into
[22:31:41] *** Quits: ecr (Thunderbir@moz-F724119C.uoregon.edu) (Quit: ecr)
[22:31:44] <kimundi> Add a lint then
[22:31:47] <strcat> anyway snapshot attempt 2
[22:31:54] <brson> bblum: i guess you are a vernor vinge fan, based on your suggestions for runtime failure messages?
[22:32:08] <bblum> brson: your assessment is dead-on
[22:32:15] <brson> fyi, one of the reasons for picking lovecraft is that he is public domain
[22:32:19] *** Joins: steven_is_false (user@C5B76363.1FF1EBF8.1ECA502.IP)
[22:32:23] <brson> fwiw, vinge is my favorite
[22:32:23] <bblum> oh is that so
[22:32:39] <bblum> sure, public domain is actually a pretty good reason
[22:32:52] *** Quits: lkuper (lkuper@E0D3ECD7.A402E718.C082B7DC.IP) (Quit: lkuper)
[22:32:59] *** Joins: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net)
[22:33:24] *** Quits: webber46 (webber46@moz-717E9C5B.cust.bredband2.com) (Quit: webber46)
[22:33:58] <maikklein> why doesn't this work? https://gist.github.com/MaikKlein/6148239
[22:34:05] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[22:34:23] <maikklein> ups
[22:34:42] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[22:34:57] <kimundi> maikklein: Yeah that's a bit confusing
[22:35:18] <kimundi> maikklein: you still impl bar2 and bar1 seperately
[22:35:35] <maikklein> kimundi, oh okay
[22:35:49] <kimundi> which I'm finding unintuitive too
[22:35:52] <maikklein> kimundi, but whats the point then for a supertrait?
[22:35:58] <kimundi> Not suroe if that's inteded
[22:36:28] <kimundi> maikklein: well, if you have a bar1, you automatically can access bar2
[22:36:44] <bblum> brson: what license? should we be crediting lovecraft in comments above the quotes?
[22:37:28] <bblum> oh it's because they're old
[22:42:51] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[22:43:27] <Eridius> can anyone r=graydon this PR for me? He said r=me if I rebased, and I did: https://github.com/mozilla/rust/pull/8203
[22:43:41] <orshem> dbaupp: ping
[22:43:58] <Eridius> although I guess I'm assuming it still merges, since I rebased 14 hours ago ;)
[22:44:03] <jeaye> rusti: let a; let b; (a, b) = (1, 2); b
[22:44:04] -rusti- pastebinned 8 lines of output: http://sprunge.us/WNZa
[22:44:10] <Eridius> does bors move a PR to STALE if it was in DISCUSSING, or only if it was ACCEPTED?
[22:44:14] <Eridius> err APPROVED
[22:44:17] <Eridius> (since it's still in DISCUSSING)
[22:44:39] <jeaye> Why isn't that allowed? ^^
[22:44:59] <Eridius> jeaye: good question. file an issue?
[22:45:05] <jeaye> Sure./
[22:45:19] *** Quits: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de) (No route to host)
[22:46:24] <Eridius> hmm, Option.unwrap() is being renamed to Option.get()? I dunno why but that makes me slightly sad
[22:46:29] <Eridius> I liked the idea of unwrapping an option
[22:47:05] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[22:47:19] *** Joins: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP)
[22:47:31] *** Quits: geomyidae (cole@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[22:47:31] <engla> Eridius: I'm not sure how to productively discuss it. It's hard to know what you really think and what you are just used to. I think  .get/.get_mut/.unwrap is a nice and short-named trio
[22:47:32] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[22:47:32] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[22:47:39] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[22:47:51] <Eridius> engla: yeah I'm not opposed to the name, I just lament the loss of the mental idea of unwrapping an option
[22:47:51] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[22:47:58] * Eridius isn't trying to raise an objection here
[22:48:00] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: night)
[22:48:26] <engla> aha, so only the habit thing
[22:48:28] *** Quits: codatory (textual@7A88C043.CC4A4609.503B7E4F.IP) (Quit: Textual IRC Client: www.textualapp.com)
[22:48:41] <Eridius> also, #7887 (the RFC for naming) states that `get()` returns a ref and doesn't mention a `get_ref()`.
[22:48:44] <Eridius> so I'm kind of confused here
[22:49:58] <brson> what's the replacement for get? get_ref?
[22:50:07] <brson> what did get even do before?
[22:50:10] <Eridius> brson: I think it's get_ref()
[22:50:12] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[22:50:28] <brson> so get,  get_ref, get_mut_ref?
[22:50:32] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Quit: Konversation terminated!)
[22:50:34] <engla> .get used to copy the value out. After the removal of Copy, .get and .unwrap were the same
[22:50:37] <engla> I think
[22:50:44] <jeaye> Eridius: https://github.com/mozilla/rust/issues/8273
[22:50:48] <jeaye> Answered. :P
[22:51:10] *** Joins: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de)
[22:51:21] <Eridius> jeaye: ahh, that makes sense actually
[22:51:44] <brson> unwrap is evocative, but as a linear type system i'm also sympathetic to the idea that moving should be the default
[22:51:55] <brson> it does seem like maybe this should have gotten some mailing list discussion
[22:52:00] <brson> it's pretty central to the 'feel' of the language
[22:52:18] <brson> i guess it could still be brought up, it's not like it can't continue to change
[22:52:19] <strcat> it doesn't necessarily move, Options can be implicitly copyable if T is
[22:52:27] <strcat> hm
[22:52:44] <Eridius> My biggest objection at the moment is, despite referencing #7887, it seems to directly contradict the naming proposed in #7887
[22:52:47] <strcat> rusti: let x = Some(5); (x.unwrap(), x.unwrap())
[22:52:47] -rusti- (5, 5)
[22:53:45] <brson> i think i'll kill this build for more discussion
[22:54:07] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[22:54:38] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[22:55:00] <kimundi> Eridius: yeah... basically I decided that both ways have pros and cons, but pcwalton was pushing for get for quite some time, so I just went with that
[22:55:16] <kimundi> (honestly wasn't expecting to directly get a r+)
[22:56:03] <engla> pcwalton didn't comment on the RFC issue
[22:56:21] <Eridius> I'm guessing he didn't even notice that it contradicted the RFC
[22:56:31] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[22:56:43] <maikklein> bjz, lmath needs some love again :(
[22:57:36] <maikklein> bjz, I am already fixing various things but I hit some strange compiler errors that I can't fix
[22:58:38] <kimundi> (Maybe it was an error to make that PR yet...)
[22:58:44] *** Joins: dim-an (ermolovd@moz-FE167E47.nationalcablenetworks.ru)
[22:58:56] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[22:58:56] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14618c7e2 to 1418e3db7: 02http://git.io/N3iJvQ
[22:58:57] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[22:58:58] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[22:58:58] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/gAzh0A
[22:58:58] <ghrust> 13rust/06auto 1444cb1c3 15Chris Morgan: Highlight sigils and operators in Vim....
[22:58:58] <ghrust> 13rust/06auto 14ceb6516 15Chris Morgan: Vim highlighting: remove `foreach` keyword
[22:58:59] <ghrust> 13rust/06auto 14799f02b 15bors: auto merge of #8251 : chris-morgan/rust/vim-sigil-highlighting, r=huonw...
[22:59:01] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[22:59:03] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[23:00:45] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[23:01:11] <tikue> rusti: let x = Some(5); (x.get(), x.unwrap())
[23:01:12] -rusti- (5, 5)
[23:02:00] <Eridius> are .get() and .unwrap() identical at the moment?
[23:02:09] <brson> kimundi: there's no harm in it. pr's are certainly the best way to bring attention to an issue
[23:02:45] <maikklein> rusti: let x = None; x.get()
[23:02:46] -rusti- pastebinned 6 lines of output: http://sprunge.us/RSGK
[23:02:52] <maikklein> rusti: let x = None; x.unwrap()
[23:02:54] -rusti- pastebinned 6 lines of output: http://sprunge.us/INPW
[23:03:02] <Eridius> maikklein: the methods are identical
[23:03:05] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[23:03:07] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[23:03:09] <Eridius> rusti: let x: Option<int> = None; x.get()
[23:03:09] -rusti- rust: task failed at 'option::get `None`', /build/rust-git/src/rust/src/libstd/option.rs:370
[23:03:09] -rusti- rust: domain main @0x185c100 root task failed
[23:03:09] -rusti- application terminated with error code 101
[23:03:24] *** Joins: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP)
[23:04:01] <kimundi> Eridius: yeah they are
[23:04:24] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[23:04:25] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[23:04:32] <maikklein> hm
[23:04:54] <maikklein> but calling get on None... isn't this the same as a nullpointer exception?
[23:05:21] <maikklein> I thought we have to match None/Some in order to access the value
[23:05:25] *** Quits: victorporof (victorporo@B4B1C8EE.73B1E539.9B1E38F4.IP) (Ping timeout)
[23:05:30] <tikue> maikklein: get fails if it's none
[23:05:43] <tikue> maikklein: there's no null exception
[23:05:50] <Eridius> maikklein: it doesn't crash. It triggers task failure
[23:06:12] *** Quits: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP) (Quit: buildmaster reconfigured: bot disconnecting)
[23:06:12] *** Joins: rust-buildbot (rust-build@505BFA3.C3CCCE8C.D25A875A.IP)
[23:06:15] <maikklein> what is the difference between failure and a crash?
[23:06:27] <engla> maikklein: the methods on Option are just different shortcuts for things you can do with match 
[23:06:27] <kimundi> maikklein: failure is manageable
[23:06:27] <maikklein> we can't catch failures right?
[23:06:34] <tikue> maikklein: in many cases using expect() is better because you can write why you expect it to be some
[23:06:44] <engla> maikklein: all destructors run
[23:06:45] <Eridius> maikklein: you can catch task failure and prevent it from propagating to your other tasks
[23:06:46] *** Quits: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net) (Connection timed out)
[23:06:49] <kimundi> maikklein: we can't catch them, but we can contain them
[23:06:52] <Eridius> you just can't keep the task that failed alive
[23:07:02] <brson> buildbot should be allowing force builds again
[23:07:30] <tikue> i feel like get_ref should be renamed get and unwrap should stay
[23:07:38] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[23:07:53] <strcat> or just call unwrap 'val'
[23:08:02] * strcat shrugs
[23:08:05] *** Joins: thomaslee (thomaslee@moz-306D3DF4.hsd1.or.comcast.net)
[23:08:20] <tikue> strcat: idk i feel like unwrap gets across the fact that in many cases the option is no longer accessible afterward
[23:08:22] <tikue> right?
[23:08:34] <strcat> yeah but that's true any time something is by-value
[23:08:44] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[23:08:53] <engla> I agree tikue
[23:09:19] <engla> get/get_mut/unwrap  is nice because you don't have to try to remember if its get_mut_ref or get_ref_mut
[23:09:22] <maikklein> rusti: let x: Option<int> = None; x.expect(~"test")
[23:09:23] -rusti- pastebinned 6 lines of output: http://sprunge.us/HXOR
[23:09:27] <kimundi> Ideally we could have `get()` and `ref()` ... but sadly latter as a keyword
[23:11:14] <maikklein> so in c++ if I would have 100 threads and I would get an unchaught nullpointer exception somewhere, my whole program would crash?
[23:11:18] *** Joins: pupoque (Adium@3CBC96CB.41993F96.4329AE1A.IP)
[23:11:26] <tikue> rusti: let x: Option<int> = None; x.expect("I should've known it was None!")
[23:11:27] -rusti- rust: task failed at 'I should've known it was None!', /build/rust-git/src/rust/src/libstd/option.rs:348
[23:11:27] -rusti- rust: domain main @0x143c100 root task failed
[23:11:27] -rusti- application terminated with error code 101
[23:11:56] <tikue> maikklein: uhhh probably
[23:11:58] <strcat> maikklein: it's not an exception
[23:12:03] <Eridius> tikue: I believe #7887 currently documents what you suggested
[23:12:07] <Eridius> and I think it makes sense
[23:12:14] <strcat> it's undefined behaviour, in the userland of most OSes it will segfault
[23:12:19] <Eridius> .get() returns ref, .unwrap() consumes, .take() swaps with empty
[23:12:23] <strcat> but it won't necessarily segfault
[23:12:30] <maikklein> oh ok
[23:12:35] <strcat> the compiler can assume it will never happen and allow memory unsafety in a case it did
[23:12:37] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[23:12:43] <Eridius> maikklein: yes, in C++, you'll crash unless you install a signal handler that catches that particular signal
[23:12:50] <strcat> won't necessarily crash though
[23:12:57] <Eridius> but such a signal handler is incredibly dangerous. You typically can't do anything at all in that except record the particulars of the crash somewhere and exit
[23:13:03] <strcat> compiler can optimize out a null ptr deref, and so on
[23:13:29] <tikue> Eridius: so it does
[23:13:42] <joelteon> can you define a function from inside a macro
[23:13:47] <steven_is_false> There's already a zip method for iterators, what does everyone think about a zip_list method that does the same but for a list?
[23:13:50] <jeaye> How do I move out of a &?
[23:13:54] <Eridius> jeaye: you can't
[23:13:57] <jeaye> gar
[23:14:05] <strcat> steven_is_false: do you mean vector?
[23:14:10] <joelteon> & explicitly doesn't know the lifetime of the object
[23:14:16] <steven_is_false> strcat: Right a vector.
[23:14:17] <strcat> steven_is_false: then definitely no
[23:14:19] <joelteon> except that "it exists while I can access it"
[23:14:19] <engla> steven_is_false: it already exists, in the tuple module
[23:14:20] *** Joins: Florob (florian@moz-EC59AB41.netcologne.de)
[23:14:23] <Eridius> steven_is_false: why would you use that instead of the iterator .zip?
[23:14:25] <strcat> engla: deprecated though
[23:14:36] <engla> why didn't you remove it then? :)
[23:14:50] <steven_is_false> Eridius: zip only works for 2 iterators. I need zip_list for N iterators.
[23:14:55] <Eridius> ahh
[23:14:58] <strcat> because removing deprecated things isn't very fun
[23:15:07] <Eridius> steven_is_false: you can always nest it, a.zip(b).zip(c)
[23:15:18] <engla> of course it is, removing stuff is great
[23:15:32] <Eridius> steven_is_false: since these iterators get inlined, it should be ok even though the resulting pattern is ugly, as (((a, b), c), d)
[23:15:43] <strcat> engla: well, I'm going to have fun ripping the old for loop out of the compiler
[23:15:44] <strcat> ;p
[23:15:50] <steven_is_false> Right but the size of the list varies at runtime.
[23:16:02] <Eridius> oh. So what, it yields a &[]?
[23:16:04] <Eridius> or a ~[]
[23:16:07] *** Joins: Guest__ (textual@moz-A3295542.nycmny.fios.verizon.net)
[23:16:29] <steven_is_false> Eridius: Let me post the code in a bit.
[23:16:58] <engla> steven_is_false: it's not really like zip since all iterators must have the same element type right?
[23:16:59] <tikue> i kind of like the idea; can you pattern match on an &[]
[23:17:07] <steven_is_false> engla: Yes.
[23:17:15] <tikue> ah
[23:17:25] <tikue> that'sâ€¦limited usefulness imo
[23:17:34] <sfackler> this seems strange:
[23:17:36] <strcat> steven_is_false: ah I though you meant like the deprecated vec::zip
[23:17:37] <sfackler> rusti:  extern "C" fn foo() {} fn bar(f: extern "C" fn()) {} bar(foo);
[23:17:38] -rusti- <anon>:5:67: 5:70 error: mismatched types: expected `extern "C" fn()` but found `*u8` (expected extern fn but found *-ptr)
[23:17:38] -rusti- <anon>:5           extern "C" fn foo() {} fn bar(f: extern "C" fn()) {} bar(foo);
[23:17:38] -rusti-                                                                             ^~~
[23:17:38] -rusti- error: aborting due to previous error
[23:17:40] -rusti- application terminated with error code 101
[23:17:47] <Eridius> strcat: https://github.com/mozilla/rust/pull/8276
[23:18:17] *** Quits: maikklein (maik@moz-835049A2.dip0.t-ipconnect.de) (Ping timeout)
[23:18:27] <strcat> Eridius: can you say "leaves the behaviour after returning None up to the iterator implementation"
[23:18:59] <strcat> Eridius: and I think you should talk about side effects
[23:19:03] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[23:19:03] <strcat> rather than None
[23:19:13] <Eridius> hmm
[23:19:32] <strcat> the None part isn't the part we can't guarantee
[23:19:43] <strcat> we don't necessarily guarantee it
[23:19:53] *** Quits: Guest__ (textual@moz-A3295542.nycmny.fios.verizon.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzzâ€¦)
[23:19:54] <strcat> python does seem to with the built-in adaptors/iterators
[23:20:18] <Eridius> what do you mean, the None part isn't the part we can't guarantee?
[23:20:29] <strcat> If you need to rely on iterators returning
[23:20:31] <strcat> +`None` forever, you can use the `Fuse` adaptor: 
[23:20:46] <strcat> that is guaranteed right now, if the underlying iterators guarantee it
[23:21:00] <Eridius> ah you're talking about the tutorial. ok
[23:21:01] <strcat> what isn't guaranteed is that it will not touch the underlying pipeline
[23:21:10] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[23:22:37] <bjz> madmoose: buggery
[23:22:40] <strcat> Eridius: the tutorial should explain that it's specified by the iterator, and also explain what that means for the existing iterators
[23:22:44] <brson> sfackler: that extern fns are represented as *u8 is a legacy wart. ffi is still undergoing some changes
[23:22:56] <engla> Eridius: btw, the method name should be .reset_fuse() to match the style in libstd
[23:22:56] <miloshadzic> what does to_owned()? I get that it gets me an owned pointer when i have a borrowed one but I'm clueless what really happens
[23:23:05] <bjz> madmoose: woops, I meant maik
[23:23:06] <Eridius> engla: ok
[23:23:12] <Eridius> miloshadzic: that copies the data
[23:23:24] <doener> brson: I guess you want a comment in build_return_block, right?
[23:23:42] <miloshadzic> Eridius: thanks
[23:23:47] <strcat> miloshadzic: allocates on the heap and copies to it, but it doesn't exist for unique/borrowed pointers afaik
[23:23:51] <sfackler> brson: cool. so the snippet above should be the way to do it when ffi gets fixed up?
[23:23:52] <strcat> only for slices
[23:23:54] <doener> brson: nvm, just realized that it was an inline comment
[23:24:11] <strcat> &[T] and ~[T] aren't unique/borrowed pointers, the syntactic sugar is just similar
[23:24:51] <miloshadzic> hmm okay
[23:24:53] <steven_is_false> Here's the implementation of zip_list http://pastebin.mozilla.org/2775341
[23:25:19] <mihneadb> how would I get a vector out of range(0,5)?
[23:25:30] <Eridius> mihneadb: .collect()
[23:25:39] <mihneadb> Eridius: <anon>:15:0: 15:22 error: cannot determine a type for this bounded type parameter: unconstrained type
[23:25:41] <Eridius> you may need to restrict the type, since this can produce any FromIterator container
[23:25:43] <mihneadb> (taht's with collect)
[23:25:52] <engla> rusti: range(0,5).to_owned_vec()
[23:25:53] -rusti- ~[0, 1, 2, 3, 4]
[23:25:53] <Eridius> rusti: let x: ~[int] = range(0,5).collect(); x
[23:25:54] -rusti- ~[0, 1, 2, 3, 4]
[23:26:00] <mihneadb> aha, I see
[23:26:04] <Eridius> when did we get .to_owned_vec()?
[23:26:08] <engla> recently
[23:26:14] <mihneadb> why?
[23:26:15] <engla> a ninja snuck it in
[23:26:19] <Eridius> is this just because getting ~[T] is so common?
[23:26:28] <Eridius> rusti: range(0,5).collect::<~[int]>()
[23:26:29] -rusti- ~[0, 1, 2, 3, 4]
[23:26:45] <mihneadb> ah didn't know about ::
[23:26:45] <mihneadb> nice!
[23:26:52] <miloshadzic> woah
[23:27:01] <Eridius> mihneadb: that's how you provide type parameters to a function when they can't be deduced
[23:27:06] <brson> sfackler: yes, i think so
[23:27:37] <mihneadb> Eridius: and if I wanted to get an @vector?
[23:27:46] <mihneadb> (it does not have an impementation for it)
[23:27:53] <geomyidae> rusti: let x: ~[int] = range(0,5).collect()
[23:27:53] -rusti- <anon>:6:4: 6:5 error: expected `;` but found `}`
[23:27:54] -rusti- <anon>:6     };
[23:27:54] -rusti-              ^
[23:27:54] -rusti- application terminated with error code 101
[23:28:06] <joelteon> is there a printf-ish function in the standard library
[23:28:11] <Eridius> mihneadb: @[] doesn't implement FromIterator? That may be an oversight
[23:28:11] <mihneadb> joelteon: printfln!
[23:28:18] <mihneadb> joelteon: and printf!
[23:28:20] <joelteon> ahh, printflan
[23:28:23] <mihneadb> with "!"
[23:28:26] <strcat> Eridius: it can't really
[23:28:34] <Eridius> joelteon: you can also just use fmt!() for sprintf-like behavior
[23:28:35] <Eridius> strcat: no?
[23:28:38] <mihneadb> https://gist.github.com/anonymous/c5aa32eb93f2b7665383
[23:28:38] <brson> lol at printflan
[23:28:42] <geomyidae> is there not a way to do this? let x: ~[int] = range(0,5).collect()
[23:28:44] <joelteon> Eridius: yeah but that's annoying
[23:28:46] <strcat> @[] and @mut [] are fixed-size after you make them
[23:28:52] <strcat> they are not incredibly useful.
[23:28:54] <Eridius> geomyidae: yes there is. What you just typed is fine
[23:28:57] <mihneadb> geomyidae: you forgot to add the " ;"
[23:29:00] <Eridius> strcat: oh they are? bleh. I've never used them
[23:29:08] <strcat> Eridius: well think about it - they avoid indirection
[23:29:11] <strcat> realloc can change the pointer
[23:29:15] <geomyidae> Eridius: didn't write one and rusti didn't mind?
[23:29:16] <strcat> and they have multiple refs
[23:29:24] <mihneadb> geomyidae: put ";"
[23:29:26] <Eridius> strcat: ah, I was assuming they'd indirect
[23:29:26] <mihneadb> rusti is not that smart
[23:29:27] *** Joins: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net)
[23:29:28] <strcat> you need @mut ~[] for a shared resizable one
[23:29:44] <Eridius> geomyidae: when I typed that code, I added `; x` on the end
[23:29:48] <engla> so collecting to ~[] and the converting to @[] is already as little work as you need to do, approximately
[23:29:51] <Eridius> rusti: let x: ~[int] = range(0,5).collect(); x
[23:29:52] -rusti- ~[0, 1, 2, 3, 4]
[23:29:54] <geomyidae> oi vey, I understand.
[23:30:04] <strcat> engla: ~[T] and @[T] have a different runtime representation
[23:30:17] <engla> strcat: I know, you can still convert
[23:30:24] *** Quits: mihneadb (mihneadb@moz-329F29A3.lightspeed.sntcca.sbcglobal.net) (Input/output error)
[23:30:25] <engla> pub fn to_managed_consume<T>(v: ~[T]) -> @[T]
[23:30:29] <geomyidae> (I meant, now I do, :))
[23:30:38] <strcat> engla: but that's an allocation so it's somewhat misleading
[23:30:51] <engla> I'm not misleading anyone
[23:31:04] <strcat> not saying you are
[23:31:10] <strcat> saying that the function signature is misleading
[23:31:31] * geomyidae doesn't see why
[23:31:43] <strcat> because it does a large allocation
[23:31:53] <engla> and it does it because it has to :)
[23:32:14] <engla> collecting to ~[] and then converting to @[] is the best thing you can do for .collect() into @[]
[23:32:18] <geomyidae> how would a function signature be able to indicate that though, other than the name? or is that what you take slight with?
[23:32:31] <strcat> engla: the conversion is unsafe so you could just collect to @[] with unsafe code
[23:32:52] <engla> strcat: you need to know the size right?
[23:32:54] <Eridius> whoa, github just started providing links to comments on older diffs in PRs!
[23:33:03] <strcat> engla: not necessarily
[23:33:11] <engla> ah, so *you* did mislead :)
[23:33:23] <strcat> you can't use realloc
[23:33:32] <strcat> you have local_malloc and local_free
[23:33:49] <strcat> and then convert it to @[]
[23:33:52] <strcat> entirely in unsafe code
[23:33:57] *** Quits: orshem (orshem@C5E06B1E.A5B6B765.E3D28531.IP) (Quit: Leaving)
[23:33:57] <doener> Eridius: hm? The an one got lost in #8270 only minutes ago
[23:33:59] <Eridius> strcat, engla: I updated my iterator PR: https://github.com/mozilla/rust/pull/8276
[23:34:07] <doener> s/The an/An/
[23:34:09] <tikue> Eridius: github was doing that for me a week ago haha, must be a slow rollout
[23:34:24] <Eridius> doener: check out #8276, there's a link to see the discussion on the "outdated diff"
[23:34:31] <Eridius> tikue: hmm, maybe so
[23:34:38] <Eridius> doener: ok maybe you just don't have access to it yet ;)
[23:34:52] <Eridius> or maybe it's on a per-PR basis? I actually don't see any outdated diffs on #8270
[23:34:53] <doener> Eridius: hm, works for that one. Weird
[23:34:58] <Eridius> ok yeah, must be per-PR
[23:35:10] *** Quits: Florob (florian@moz-EC59AB41.netcologne.de) (Quit: leaving)
[23:35:14] <Eridius> maybe it's a slow rollout that depends on who did the push?
[23:35:59] <strcat> Eridius: I don't think it's really going to be clear what's meant by the pipeline
[23:36:14] <strcat> keeping in mind that this is the first thing people are going to read about iterators, before adaptors are introduced
[23:36:20] <Eridius> strcat: ok
[23:36:51] <strcat> I'm not entirely sure we're defining it the right way
[23:37:44] <Eridius> ok I removed the word "pipeline", using "underlying iterator" now.
[23:38:01] <strcat> it's still too early to introduce a lot of that
[23:38:06] <strcat> for loops are covered later, etc.
[23:38:12] <Eridius> :/
[23:38:25] <strcat> you definitely can't introduce Fuse there
[23:39:05] <Eridius> hmm
[23:39:30] <Eridius> I can move Fuse into the Iterator adaptors section
[23:39:45] <strcat> I think in the protocol section you should just say something like
[23:39:56] <Eridius> I'm just going to leave the first 2 sentences in the protocol section
[23:40:00] <Eridius> (the first 2 added sentences)
[23:40:03] *** Quits: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net) (Ping timeout)
[23:40:12] <Eridius> everything else will be moved, and slightly reworded, to the end of the iterator adaptor section
[23:40:15] <Eridius> and I'll change the example to not use for
[23:40:49] <strcat> the 2nd sentence should probably clarify that 'not guaranteed' means it's not guaranteed by the protocol
[23:40:52] <strcat> an iterator can guarantee it
[23:40:53] <Eridius> yeah
[23:43:02] <strcat> "The iterator protocol does not require iterators to handle being called again after they return None. Instead, it is possible to wrap them if the guarantee is required."
[23:43:07] <miloshadzic> what would be a good way to create an iterator that repeats itself forever? Akin to clojure's "repeatedly".
[23:43:15] <strcat> miloshadzic: cycle
[23:43:22] <miloshadzic> strcat, thanks!
[23:43:24] <strcat> if it's a clonable iterator
[23:43:56] <Eridius> strcat: I'm not sure I like that wording
[23:43:58] <strcat> building a buffer to hold the results would be a separate iterator
[23:44:12] <Eridius> I prefer your earlier suggestion of "leaves the behavior after returning `None` up to the iterator implementation"
[23:44:21] <engla> a buffering iterator adaptor could in fact be called buffer
[23:44:52] * strcat isn't quite sure it would make sense
[23:44:57] <strcat> (buffering that way)
[23:45:05] <strcat> it wouldn't  be cloneable either
[23:45:23] <sam113101> if IÂ do let borrowed = &30; is 30 on the stack?
[23:45:30] <engla> it could be
[23:45:41] <strcat> engla: but it'd have a reference to the underlying iterator
[23:45:48] <strcat> sam113101: yes
[23:45:57] <strcat> as is the pointer to it
[23:46:18] <sam113101> and if IÂ did @30 or ~30, it would be on the heap?
[23:46:22] <engla> strcat: I implemented this some time ago, a buffering thing called .tee() and you said it's better if we just .clone() iterators
[23:46:40] <strcat> sam113101: yes but it's not necessarily defined that way, anything could happen after optimizations
[23:46:47] <engla> and of course that's right
[23:47:06] *** Joins: dw (dmw@5D5650A6.59C24325.3C3EAB72.IP)
[23:47:15] <strcat> engla: well, what I'd like is for a way to lazily buffer for cycle
[23:47:22] <strcat> but I'm not sure that makes sense
[23:47:57] *** Quits: eholk (eholk@moz-9AB4D52F.hsd1.ut.comcast.net) (Quit: eholk)
[23:50:03] <engla> don't you think that would make sense as using  it.buffer().cycle() ?
[23:50:06] <sam113101> how are #[things_like_that] called?
[23:50:10] <engla> so to split it in two orthogonal parts
[23:50:10] <sam113101> such as #[test]
[23:50:33] <strcat> engla: yes, the issue is just that buffer then has an internal field containing 'it'
[23:50:51] <strcat> and you don't want to clone all of buffer
[23:51:05] <strcat> (but you can't anyway)
[23:51:09] <engla> you could have a .shared_buffer() that uses indirection
[23:51:15] <engla> .rc_buffer()
[23:52:51] <Eridius> strcat: hmm, providing an example in the Iterator adaptors section that actually demonstrates why fuse() is useful is hard without using things we haven't shown yet (e.g. peek())
[23:53:10] <Eridius> or .scan() would be a better example of something to use
[23:55:12] <strcat> ok I think it's really too unclear/complex
[23:55:25] <strcat> "The Iterator protocol does not define behavior" is going to be interpreted wrong
[23:56:32] <sam113101> guys ;_;
[23:56:37] <strcat> "In general, the `next` method should not be called after it returns `None`. A specific implementation of the Iterator protocol may choose to allow this."
[23:56:43] <strcat> simple
[23:57:00] <Eridius> strcat: if I read that, I think "but what happens if I call it on an iterator that doesn't choose to allow it?"
[23:57:12] <Eridius> "does not define behavior" seems clearer to me
[23:57:33] <engla> sam113101: I think they are attributes
[23:57:33] <strcat> it's not going to be interpreted that way
[23:57:37] <strcat> the behaviour is well defined
[23:57:41] <strcat> just not by the protocol
[23:57:45] <Eridius> the iterator defines it. the protocol does not
[23:57:51] <Eridius> hence "the iterator protocol does not define..."
[23:57:56] <sam113101> engla: and they are only useful at compile time, right?
[23:58:02] <strcat> Eridius: it's not clear you're saying that
[23:58:22] <strcat> someone learning this isn't going to see a clear separation between the "Iterator protocol" and an implementation of it
[23:58:41] <Eridius> strcat: I take it you're talking about the Iterator docstring now, not the tutorial?
[23:58:42] <engla> sam113101: yes, not entirely sure what you mean
[23:58:46] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[23:58:47] <strcat> Eridius: well, both
[23:59:02] <Eridius> the tutorial uses the wording you suggested "leaves the behavior after returning `None` up to the iterator implementation"
[23:59:04] <sam113101> IÂ think C# has them too
[23:59:05] <sfackler> isn't "the behavior is implementation defined" the usual terminology for that kind of thing? apologies if that's come up already, I haven't been following the conversation closely
[23:59:12] <jeaye> I need to send three ~[] to a task and then get them back after the task finishes (DuplexStream). Is there a preferred way of sending them (i.e. struct, tuple, etc)? If not, tuple should do.
[23:59:19] <strcat> Eridius: but I don't really like that wording
[23:59:22] <Eridius> sfackler: it is for people who are familiar with C specifications
[23:59:43] <strcat> sfackler: it's not 'implementation defined' according to the meaning of that word in C
[23:59:55] <strcat> an alternate implementation of rust or these adaptors would need to provide the same definitions

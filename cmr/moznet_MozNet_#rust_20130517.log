[00:00:11] <thiez> strcat: in that case, could you update https://github.com/mozilla/rust/issues/6239 so that people don't start performing useless work? :p
[00:00:12] <nmatsakis> graydon: why does += 1 make you feel guilty?
[00:00:22] <graydon> nmatsakis: ^
[00:00:30] <thiez> the 'alternatively' should go away
[00:00:32] <graydon> "maybe I was just being lazy, and didn't have any reason"
[00:00:41] <strcat> graydon: Go has them but they aren't expressions (so there's only one form) - so it's a pretty pointless special case ;p
[00:00:50] <graydon> hah!
[00:00:50] <nmatsakis> graydon: oh, I see. you know... we could implement ++ with an impl now
[00:00:55] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[00:01:01] <graydon> ??
[00:01:03] <EXetoC> bjz: not that I got much of that, but ok :p anyway, it's not really an obstacle
[00:01:16] <nmatsakis> graydon: impl uint { fn get_and_self(&mut self) -> uint { let x = *self; *self += 1; x } }
[00:01:27] <nmatsakis> er, make that "get_then_inc"
[00:01:28] <bjz> EXetoC: which?
[00:01:40] <cmr> cscottnet: I also have the intrinsic-atomics failure, are you compiling with clang?
[00:01:43] <bjz> EXetoC: "it's not really an obstacle"
[00:01:45] <nmatsakis> graydon: ok the syntax leaves sometihng to be desired :)
[00:01:55] <thiez> cmr: can you pastebin the error messages?
[00:02:08] <cmr> thiez: sure, hang on
[00:02:38] <graydon> *shrug* we can leave it until the indefinite future. assuming there's not a huge backwards compatibility risk with people writing --x to mean unary-minus(unary-minus(x))
[00:02:41] <EXetoC> bjz: nevermind
[00:02:56] <graydon> or just ban ++ and -- as lexemes for the time being
[00:02:58] <bjz> EXetoC: I'm open to being convinced
[00:05:15] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[00:05:47] *** Joins: int3_ (int3_@moz-37BAD98B.omega81.maxonline.com.sg)
[00:06:12] *** Joins: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net)
[00:06:17] <strcat> graydon: https://github.com/mozilla/rust/pull/6544 r?
[00:07:44] <graydon> strcat: this is better than fold?
[00:07:53] <graydon> (I mean, fold generalizes them, no?)
[00:08:03] *** Quits: bbrittain (ben@moz-632384CB.dr02.roch.ny.frontiernet.net) (Client exited)
[00:08:17] <strcat> graydon: well we don't have fold yet ;p
[00:08:25] <strcat> I could add that too and define them in terms of it
[00:09:09] <thiez> that would be nicer, also as an example of how to use fold
[00:09:34] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[00:09:55] <thiez> I hear there were plans for iterators that could go backwards as well? Would they have foldl? :D
[00:10:45] <graydon> I think you mean foldr
[00:10:54] <strcat> graydon: sec
[00:11:08] <strcat> should I call it foldl or reduce?
[00:11:17] <strcat> we can't have foldr for internal iterators
[00:11:36] <graydon> foldl is the one based on left-identity, no? f(f(f(f(f(f(init, x[0]), x[1]), x[2], ...) 
[00:11:37] <aatch> strcat, I would lean towards reduce.
[00:11:46] <graydon> yeah, I think you can't have foldr
[00:11:50] <graydon> might be infinite
[00:12:24] <strcat> graydon: well foldl will never finish on an infinite sequence either
[00:12:37] <strcat> but foldr would just be really inefficient on an iterator
[00:12:37] <graydon> fair point. why can't you, then?
[00:12:45] <strcat> graydon: well it's usually defined on lists or lazy lists
[00:12:55] <graydon> lists, yeah.
[00:13:13] <strcat> you'd have to build up a stack of the whole iterator to start at the end afaik
[00:13:47] <mcpherrin> strcat: Isn't that what the usual foldr recursive definition always does?
[00:14:02] <strcat> mcpherrin: I guess. but I think in haskell it can cheat
[00:14:17] <strcat> haskell's foldr works on infinite lists.... foldl doesn't
[00:14:20] <strcat> don't ask me how
[00:14:24] <graydon> I never remember how haskell's thing works
[00:14:26] <graydon> yeah
[00:14:42] <graydon> I remember thinking "oh, of course!" every time I read it. then forgetting.
[00:14:44] <graydon> anyway
[00:14:46] <aatch> Haskell stores "thunks" if I remember correctly
[00:14:49] <graydon> yes
[00:14:52] <graydon> I know how it evaluates
[00:15:06] <tjc> well, that's why foldr (+) 0 xs and foldl (+) 0 xs can have wildly different complexity in Haskell
[00:15:12] * aatch has reached the end of his Haskell knowledge now
[00:15:17] <graydon> :)
[00:15:18] <graydon> anyway
[00:15:20] <tjc> gotta love laziness resulting in non-commutativity manifesting itself in space usage :-)
[00:15:23] <graydon> "reduce" is probably fine
[00:15:24] *** Quits: int3_ (int3_@moz-37BAD98B.omega81.maxonline.com.sg) (Ping timeout)
[00:15:38] <nmatsakis> I thnk you wind up wanting both fold and reduce
[00:15:44] <nmatsakis> that is, they have different signatures
[00:15:54] <nmatsakis> certainly I want fold more often than I want reduce
[00:15:55] <graydon> tjc: mathematicians ... blah blah .. value of everything ... cost of ... left as exercise for reader
[00:15:59] <tjc> heh
[00:16:01] <graydon> different signatures?
[00:16:14] <nmatsakis> usually fold takes a starting element
[00:16:21] <nmatsakis> and reduce doesn't (it uses the 0th element of the list)
[00:16:29] <graydon> as does reduce! no?
[00:16:30] <graydon> oh
[00:16:43] <graydon> then reduce is built atop fold
[00:16:44] <nmatsakis> so fold is like (A, [B], (A,B) -> A)
[00:16:48] <graydon> both! into the bucket!
[00:17:01] <nmatsakis> and reduce is ([A], (A,A)->A)
[00:17:01] <aatch> I generally find I need reduce more often.
[00:17:31] <nmatsakis> I think it just depends on what you're doing. Reduce is good for math, but I find I'm usually ... building up a structure, or summarizing things, then I want fold.
[00:17:40] <strcat> nmatsakis: ah so reduce is usually like haskells foldl1/foldr1
[00:17:42] <nmatsakis> in the end I usually use a for loop anyhow though, more readable :)
[00:17:50] <thiez> cmr: could you give me the link to the pastebin as well? ;)
[00:17:51] <graydon> I can just _see_ catamorphism's eyes twitching all through this conversation
[00:18:36] <aatch> ANYWAY. We should have both.
[00:18:57] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[00:18:59] <cmr> thiez: it's building+running tests
[00:19:47] <engla> for fun, I implemented fn collect<B:Builder<A>>(self) -> B;  in IteratorUtil. (Making a container like LinearSet and so on from an iterator). Just another idea
[00:20:22] <strcat> graydon: haskell has foldl, foldl', foldl1, foldl1', foldr, foldr1 ;p
[00:20:27] <thiez> cmr: sorry, I assumed you'd forgotten
[00:20:37] <strcat> the ' ones aren't lazy strict
[00:20:45] <strcat> but... foldl doesn't work on infinite lists anyway
[00:20:55] <strcat> I really don't understand why foldr works and foldl doesn't
[00:20:56] <thiez> I'm rather curious what the problem is, yet at the same time it's been 2AM and I should really go sleep :)
[00:21:18] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[00:21:21] *** Joins: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP)
[00:21:53] <graydon> strcat: it also has http://hackage.haskell.org/packages/archive/pointless-haskell/0.0.3/doc/html/Generics-Pointless-RecursionPatterns.html
[00:21:59] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[00:22:07] <graydon> strcat: cata :: (Mu a, Functor (PF a)) => a -> (F a b -> b) -> a -> b
[00:22:08] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[00:22:15] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[00:22:19] <graydon> \o/ \o/ haskell \o/ \o/
[00:22:29] <tjc> this is a good time to link to http://www.willamette.edu/~fruehr/haskell/evolution.html
[00:22:31] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[00:22:33] <tjc> (it's always a good time to link to http://www.willamette.edu/~fruehr/haskell/evolution.html )
[00:22:34] <graydon> quite
[00:22:55] <graydon> "This recursion pattern subsumes histomorphisms, futumorphisms and dynamorphisms  and can be seen as the natural hylomorphism generalization from composing an histomorphism after a futumorphism"
[00:23:12] <bjz> graydon: O_O
[00:23:48] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Client exited)
[00:23:54] <tjc> category theory would be much more popular if someone came up names for each of the morphisms that sound like "factory pattern"
[00:23:54] <EXetoC> my brain exploded twice
[00:24:12] <tjc> fortunately, brain explosion is an idempotent operation
[00:24:14] <bjz> tjc: hooray for nouns!
[00:24:22] <graydon> this is about as fun as initWithBitmapDataPlanes
[00:24:29] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[00:24:39] <graydon> they should fight
[00:25:06] <bjz> EXetoC: oh dear, I just realised that the window close callback is not triggered when window.set_should_close(true) is called
[00:25:15] <strcat> and C++ calls fold accumulate ;p
[00:25:17] <graydon> xtranormal cartoon: design-patterns OO verbosity-monster yelling at category-theory FP verbosity-monster
[00:25:22] <bjz> EXetoC: only when it is initiated by the user
[00:25:26] <steven_is_false> tjc: AbstractFactorySingletonProxyEndomorphism?
[00:25:35] <tjc> steven_is_false: heh
[00:25:47] <bjz> EXetoC: hence we probably need to utalise the window userpointer
[00:25:53] <tjc> an AbstractFactorySingletonProxyEndomorphism is just an endofunctor in the category of AbstractFactorySingletonProxies
[00:25:55] <steven_is_false> tjc: So you mean Scala?
[00:25:55] <jclements> tjc: i take issue with your idempotency claim.
[00:25:56] <tjc> (obviously*
[00:26:03] <tjc> jclements: has your brain exploded more than once?
[00:26:06] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[00:26:11] <tjc> steven_is_false: maybe I should learn more about Scala
[00:26:51] <cscottnet> cmr: no, gcc
[00:26:56] <graydon> ok. swim time. this heap map is almost tolerably maybe taking shape. gosh I hope it's dense enough.
[00:26:58] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[00:27:00] <steven_is_false> tjc: Oh, I honestly don't know enough about it. All I really know is that it's on the JVM,  has a complicated type system, and supports some functional idioms.
[00:27:03] <cscottnet> (presumably; i don't have clang installed)
[00:27:05] <mcpherrin> tjc: loving evolution.thml
[00:27:06] <cmr> cscottnet: alright there goes that hypothesis!  :p
[00:27:17] <bjz> EXetoC: I was going to let you know btw, that the WindowData struct might make pipes easier
[00:27:22] <tjc> mcpherrin: it's a classic
[00:27:27] <jclements> tjc: more prosaic: I just don't think that function's codomain is a subset of its domain.
[00:27:27] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[00:27:30] <tjc> steven_is_false: Yeah, that's about what I know about it
[00:27:36] <tjc> jclements: heh
[00:27:41] <cmr> cscottnet: I'm on x86_64 linux though. Did you get an LLVM assertion error?
[00:28:41] <benh> Is codomain the fancy way to say return type?
[00:28:45] <thiez> I'm on x86_64 linux too, and no problems with that test :(
[00:28:55] <jclements> benh: SSSSHHHHH! 
[00:29:00] <EXetoC> bjz: it's already easy. do you mean getting rid of them? because you can if you make the window managed IIRC
[00:29:08] <aatch> the atomics test? I get it too btw.
[00:29:08] <jclements> benh: (it's a secret)
[00:29:10] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:29:28] <aatch> x86_64 Linux, clang built
[00:29:28] *** cscottnet is now known as cscottnet_away
[00:29:36] <bjz> EXetoC: how so?
[00:30:06] <jclements> benh: strictly speaking, you can differentiate between the codomain and the range, but "return type" is pretty much an exact synonym for codomain, IIUC.
[00:30:16] <EXetoC> bjz: I wonder how that q3 guy could do it without pipes, and I think it was because the window was managed
[00:30:27] <EXetoC> unlike mine, which is stack-allocated
[00:30:32] <benh> I never got all the jokes in #haskell that revolved around putting co- in front of things and reversing arrows
[00:31:21] <benh> (and only got a year or so worth of college-level math education ;)
[00:31:28] <tjc> a co-mathematician is a machine for turning ffee into co-theorems
[00:31:31] <tjc> or something like that
[00:31:36] <strcat> ugh there are way too many variations of fold that you can make because of by-value vs reference
[00:31:36] <benh> :D
[00:31:47] <jclements> tjc: :)
[00:32:02] <strcat> sum/product should eventually be using in-place add/mul so fn(T, U) -> T is no good...
[00:32:10] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[00:33:23] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[00:34:09] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Ping timeout)
[00:34:51] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[00:34:51] *** ChanServ sets mode: +o tjc
[00:35:57] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[00:36:01] <strcat> this is ugly from a functional POV ;p
[00:36:20] <strcat> pub fn fold<T, U>(start: T, iter: &fn(f: &fn(U) -> bool) -> bool, f: &fn(&mut T, U)) -> T {
[00:36:22] <strcat> oh well
[00:37:18] <nmatsakis> strcat: I believe they should take the "accumulator" by value, as vec does. Problem is, this can't be type-checked (yet)
[00:37:24] <thiez> I have a failing test dupe-first-attr.rc
[00:37:26] *** Joins: mermi (Mibbit@moz-B2B382E7.hsd1.fl.comcast.net)
[00:37:36] <strcat> nmatsakis: well if you take it by-value it makes it very inefficient for some things
[00:37:42] <nmatsakis> thiez: btw I looked at that test of yours a little, I think i kinda kno prblem is
[00:37:45] <strcat> like building up a vector or a bigint
[00:37:52] <thiez> nmatsakis: do elaborate
[00:38:11] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[00:38:13] <nmatsakis> thiez: i'm not precisely sure yet, I just suspect there's a bug around the treatment of `'self` and static fns
[00:38:38] <nmatsakis> strcat: why is it inefficient?
[00:38:47] <nmatsakis> strcat: certainly not for a vector.
[00:38:51] <strcat> nmatsakis: because it creates a new vector/bigint for each iterator
[00:38:56] <strcat> I mean accumulating a vector/bigint
[00:39:00] <nmatsakis> strcat: why? 
[00:39:09] <nmatsakis> I mean, you give it one, you push onto it, return the one it gave you
[00:39:19] <nmatsakis> that said, &mut may be even better :)
[00:39:23] *** Joins: hay_guise (Mibbit@moz-258BC5F7.eastlink.ca)
[00:39:28] <nmatsakis> plus you can type it today
[00:39:47] <strcat> nmatsakis: ah you mean in the future you'll be able to move it
[00:40:21] <thiez> nmatsakis: whatever it is, it only seems to happen when the struct/impl is in another crate
[00:40:31] <strcat> nmatsakis: x = foo(x) will work? (moving x into foo)
[00:40:32] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[00:41:11] <hay_guise> is anyone here using rust on windows? i tried it several months ago with no luck. wondering if the windows stuff had any love in recent times.
[00:41:12] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[00:41:21] <benh> This is a bit of a silly question, but could you give an example of a particularly well/idiomatically-documented rust module?
[00:41:31] <joshua_> hay_guise: it should be supported, lest we all suffer the wrath of graydon :-)
[00:41:32] <strcat> benh: core::iter
[00:41:43] <strcat> in trunk
[00:41:47] <benh> I've been scared away by documentation pages that are just a list of prototypes and probably not read as much of it as I should have :)
[00:41:50] <cmr> hay_guise: Thad Guidry has been working a bit on windows, updated the docs and working out problems.
[00:41:50] <benh> thanks
[00:41:56] <strcat> benh: each fn has an example
[00:42:17] <strcat> I plan on documenting core::iterator as well today too
[00:42:19] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[00:42:35] <strcat> I was waiting for the &mut rvalue thing to land first ;p
[00:42:46] <benh> What's that again?
[00:42:53] <strcat> can borrow temporaries as &mut
[00:43:01] <benh> It's hard to keep up with the bits that nikomatsakis isn't blogging about :)
[00:43:03] <nmatsakis> strcat: yes, I think if we make it so that closures do not recurse, you could write x = foo(x) even within a closure (you can write it today, but not if `x` is an upvar)
[00:43:26] <strcat> nmatsakis: hmm, I didn't realize you could write it today
[00:43:37] <strcat> nmatsakis: I guess it's 'foo.bar = op(foo.bar)' that you can't write today?
[00:43:55] <nmatsakis> strcat: that's probalby true.
[00:44:06] <nmatsakis> strcat: right now you can't move from paths, on my list to fix (like so many things)
[00:44:15] <strcat> rusti: fn foo(x: ~int) -> ~int { x }; let x = ~5; x = foo(x); x
[00:44:15] *** Joins: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net)
[00:44:17] <nmatsakis> strcat: or at leastnvenienly :)
[00:44:20] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OPcR
[00:44:29] <strcat> rusti: fn foo(x: ~int) -> ~int { x }; let mut x = ~5; x = foo(x); x
[00:44:31] -rusti- ~5
[00:44:36] <strcat> huh, I had no idea that worked.
[00:44:42] <strcat> I assumed it didn't after figuring out it didn't with fields
[00:44:45] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[00:44:47] <aatch> strcat, why wouldn't it?
[00:44:58] <strcat> because 'x.foo = x.foo' doesn't
[00:45:15] <aatch> strcat, isn't that because of partial moves though?
[00:45:25] <benh> strcat: is rusti open source/published?
[00:45:27] <strcat> aatch: I guess, but I assumed it was a more general thing
[00:45:36] <strcat> benh: it's not much code, I can pastebin it
[00:45:41] <strcat> it's a quickly thrown together hack
[00:45:43] <strcat> ;p
[00:46:29] <aatch> brson, btw, I refactored one of my tests and unconvered a race condition in the work queue. I'll fix it up and update the pull.
[00:46:36] <cmr> thiez: cscottnet_away: aatch: Well, the test passes for me now... :\
[00:47:17] <cmr> on latest incoming
[00:47:25] <strcat> benh: so... it has a linux root made with 'pacstrap -d sandbox -S base rust-incoming-git'
[00:47:26] <aatch> cmr, I also encountered it on a branch that isn't from mozilla/rust
[00:47:45] <strcat> benh: http://ix.io/5G8 this container cfg
[00:47:53] <benh> I was hoping to be able to play with the bit that calls rustc(/rust do?) without setting up the whole thing
[00:48:07] <strcat> benh: http://ix.io/5F0 this terrible wrapper
[00:48:17] <benh> thanks!
[00:48:34] <strcat> benh: http://ix.io/5F1 and this terrible irc bot copypasted from the twisted docs
[00:48:38] <strcat> I don't even *want* async
[00:48:45] <strcat> because it uses too much memory for a req
[00:48:47] <thiez> aatch: you said the atomics test failed for you? Do you happen to have a log?
[00:48:47] <strcat> so it's blocking anyway ;p
[00:49:00] <aatch> thiez, sorry no.
[00:49:02] <strcat> benh: well you have to set it up for sandboxing ;p
[00:49:14] <thiez> everybody is telling me it's broken and nobody can tell me why :p
[00:49:18] <aatch> It was an LLVM assertion though
[00:49:21] <strcat> benh: http://ix.io/5G9 that's the rust.sh in the container
[00:49:28] <aatch> hang on, I'll run a make-check
[00:49:28] <cmr> It's not broken anymore, for me, but yeah, it was an LLVM assertion
[00:49:33] <benh> thanks!
[00:49:41] <mermi> Hi all, sorry to interrupt. Looking to dive into rust, any ideas for a small self-contained project I could start to get familiar with it? Thinking of something like a rest server maybe?
[00:49:56] <aatch> mermi, I would stay away from IO atm
[00:50:06] <aatch> It's all being re-written
[00:50:13] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[00:50:19] <pcwalton> well, you need *some* I/O :)
[00:50:22] <strcat> benh: I should clean it up and put it on github eventually
[00:50:30] <pcwalton> but I wouldn't do anything heavy like a web server or anything
[00:50:45] <mermi> hmm, any idea what I should focus on?
[00:50:51] <cmr> mermi: http://www.matasano.com/articles/crypto-challenges/ is fun.
[00:51:04] <cmr> not too hard, but not trivial either
[00:51:12] <pcwalton> tptacek says the matasano challenges have gotten a few Rust submissions :)
[00:51:17] <strcat> ugh fold doesn't work at all
[00:51:24] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:51:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/XLKO8Q
[00:51:24] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:51:25] <mcpherrin> pcwalton: I think that was me :)
[00:51:31] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[00:51:36] <pcwalton> mcpherrin: was wondering if the responsible party would speak up :)
[00:51:37] <mcpherrin> (dunno if anybody else did it in rust)
[00:51:38] <strcat> iter.rs:250:26: 250:30 error: mismatched types: expected `&fn(&fn(<V2>) -> bool) -> bool` but found `&fn(&fn(&'a) -> bool) -> bool` (expected bound lifetime parameter &, but found concrete lifetime)
[00:51:40] <strcat> iter.rs:250     fold(Zero::zero::<T>, iter, |a, x| *a = a.add(x))
[00:51:41] <cmr> I started working on the matasano challenges but I've since got caught up in working on rustc :p
[00:51:42] <strcat> ;\
[00:51:50] <strcat> well
[00:51:50] <mermi> that does look fun, I'll take a look :)
[00:51:53] <strcat> I screwed up the fn call...
[00:51:57] <strcat> but that's not the error ;p
[00:52:32] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Ping timeout)
[00:53:05] <strcat> nmatsakis: you still around? I really don't understand this lifetime error
[00:53:17] <strcat> I think it's a bug
[00:53:27] <strcat> http://ix.io/5Ga code -> http://ix.io/5Gb error
[00:54:11] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[00:54:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:54:23] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/VBUSMg
[00:54:23] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:54:24] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[00:54:24] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/ljj_WA
[00:54:24] <ghrust> 13rust/06auto 14226f4df 15Tim Chevalier: rustc: One less bad copy
[00:54:24] <ghrust> 13rust/06auto 141bf4f90 15Tim Chevalier: rustc: Remove import that is, indeed, not necessary
[00:54:24] <ghrust> 13rust/06auto 1417970a9 15bors: auto merge of #6545 : catamorphism/rust/unused-import, r=catamorphism
[00:54:25] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[00:54:39] <strcat> whenever I touch higher-order functions in rust I end up with weird problems ;p
[00:55:41] <aatch> pcwalton, there was one guy that did some course work with Rust.
[00:55:57] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[00:56:02] <nmatsakis> strcat: let me look
[00:56:05] <pcwalton> strcat: that code is very scary
[00:56:12] <pcwalton> grep for "ReSkolemized" sometime ;)
[00:56:17] <aatch> It was pretty competitive with the C++ versions that were submitted
[00:56:19] <pcwalton> the HoFs + regions
[00:56:41] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Quit: lkuper)
[00:57:00] <strcat> I end up hitting variations of this with all of the core::iter stuff in generic code
[00:57:09] <strcat> but... it doesn't happen in the tests because they aren't generic code themselves
[00:57:36] <strcat> so it seems like something to do with HoFs + regions + generics >.<
[00:58:49] <nmatsakis> strcat: I think that error is legit.
[00:58:58] <nmatsakis> strcat: but I have to think it over some more.
[00:59:29] <strcat> nmatsakis: well it seems like it should be fine if iter was moved
[00:59:43] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[00:59:45] <strcat> I don't really know the details of &fn
[01:00:00] <nmatsakis> strcat: the problem is that iter expects a function that takes a pointer to a T in any reigon
[01:00:18] <nmatsakis> or rather, iter is a function that takes as parameter another function that takes a pointer to a T in *any* reigon
[01:00:39] <nmatsakis> but in fold, you have iter being a function that takes a function that takes a U
[01:00:49] <nmatsakis> which is strictly less polymorphic basically
[01:01:05] <nmatsakis> ok, nobody should ever say "basically" and "less polymorphic" in the same sentence
[01:01:08] <nmatsakis> nothing basic about it
[01:01:18] <nmatsakis> anyway, I might be confused though, there is a lot of functions that take functions that take functions here
[01:01:47] <strcat> nmatsakis: iter: &fn(f: &fn(T) -> bool) -> bool just represents a function implementing the iteration protocol
[01:01:47] <nmatsakis> but I think the problem lies in the fact that you have fold defined over any U, but sum takes a fn<'a>(&'a T)
[01:01:50] <strcat> I should probably typedef it
[01:01:52] <nmatsakis> (writing out the binding explicitly)
[01:02:24] <nmatsakis> strcat: I know what it represents, but it's not always helpful to decide if the subtyping works out...
[01:03:21] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:03:41] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:03:51] <nmatsakis> strcat: I think the think is that the function which sum() takes has type &fn(&fn(&T)), meaning that it expects a parameter &fn(&T) which is a function that takes arguments in any region
[01:04:06] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[01:04:06] <nmatsakis> strcat: in other words, it expects a function that it can supply data to, and be sure that this function won't hold on to it
[01:04:17] <nmatsakis> strcat: but there is no value you can supply to U which has that property
[01:04:20] <strcat> ah
[01:04:25] <strcat> nmatsakis: yeah if I use &U it works
[01:04:27] <nmatsakis> strcat: because U is bound at an outer scope
[01:04:29] <nmatsakis> strcat: right.
[01:05:23] <nmatsakis> strcat: very subtle stuff, not sure how clear that explanation is, but I'm pretty sure that if the type checker allowed it, there'd be a way for borrowed pointers to leak out :)
[01:05:24] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:06:03] <strcat> nmatsakis: well, basically I have a lot of situations where I want to make a function taking T where it *can* be a borrowed ptr
[01:06:16] <strcat> and it works for borrowed pointers
[01:06:29] <strcat> but then when another function has &T and tries to call that generic function, it hits this
[01:06:39] <nmatsakis> right. and I think it's correct to complain, is the problem
[01:06:44] <nmatsakis> you could fix it another way
[01:06:53] <nmatsakis> something like this might work
[01:06:54] <strcat> so there's no way for the &T region to be passed along to U?
[01:07:29] <strcat> because it works if I use &int instead of &T
[01:07:30] <nmatsakis> well, it doesn't make sense, there *is no &T region* until the fn is called and *each time it's called the region could be different*
[01:07:38] <nmatsakis> however, you could write this:
[01:07:45] <strcat> nmatsakis: ah right
[01:07:51] <nmatsakis> pub fn sum<'a, T: Zero + Add<T, T>>(iter: &fn(f: &fn(&'a T) -> bool) -> bool) -> T {}
[01:08:01] <nmatsakis> now U could be bound to &'a T
[01:08:12] <nmatsakis> but of course that may not be what you want necessarily
[01:08:21] <strcat> ah, I guess I expected that to happen for me
[01:08:42] <strcat> but it makes sense that it doesn't
[01:08:46] <strcat> less polymorphic
[01:09:07] <nmatsakis> right.
[01:09:08] <strcat> since it forces the passed things to be in the same region... lets see if that even works
[01:09:50] <nmatsakis> strcat: also, I think the code is in a weird intermediate state
[01:09:59] <nmatsakis> strcat: where that declaration may not do what it should do
[01:10:11] <nmatsakis> strcat: because we used to determine the bindings of regions based on where they appeared, not where they were declared
[01:10:16] <strcat> nmatsakis: yeah it doesn't work this way
[01:10:18] <nmatsakis> strcat: and I fear we may still be doing that, even though you now declare them
[01:10:22] <strcat> iter.rs:250:28: 250:32 error: mismatched types: expected `&fn(&fn(<V2>) -> bool) -> bool` but found `&fn(&fn(&'a 'a) -> bool) -> bool` (expected bound lifetime parameter &'a , but found concrete lifetime)
[01:10:39] <nmatsakis> strcat: 
[01:10:42] <nmatsakis> oops
[01:11:09] <nmatsakis> things would definitely be smoother if you were consistently using borrowed pointers everywhere, but I know why you're trying to avoid that
[01:11:19] <strcat> yeah
[01:11:37] <nmatsakis> I'm not sure what's the best way to structure that, I suspect though that you can workaround it another way
[01:11:41] <nmatsakis> give me a sec
[01:12:47] <strcat> nmatsakis: it's probably fine to use a borrowed ptr for fold, but it's somewhat less useful
[01:12:53] <nmatsakis> yeah, I think what I had in mind won't work.
[01:13:17] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:13:22] <strcat> since you can have something like Iterator<T> where T is ~[u8]
[01:13:30] <strcat> and you'd want to actually be passed them by-move, not by-ref
[01:13:41] <strcat> I could make two versions
[01:13:58] <strcat> one for when you know you have a ref, one for when you have either
[01:13:59] <nmatsakis> you might need to do that
[01:14:43] <strcat> the problem is at some point you're forced to use &T instead of T and then you can no longer use &T as an arbitrary U
[01:14:56] <strcat> kind of weird but I understand now :)
[01:15:04] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: Places to go, people to annoy)
[01:15:30] <strcat> it's not too painful
[01:15:41] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[01:16:02] <cmr> I saw in the logs talks about compiling the tests earlier on. This would be fantastic :)
[01:16:26] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:16:56] <mcpherrin> What's a replacement for iter::repeat? Seems to be gone...
[01:17:11] <strcat> mcpherrin: iter::Times, repeat is old_iter::repeat
[01:17:13] <mcpherrin> (this is when I wish there was a rustfix)
[01:17:18] <strcat> it may or may not stay around
[01:17:23] <aatch> thiez, ping
[01:17:27] <thiez> aatch: pong
[01:17:41] <aatch> rustc: /home/james/projects/rust/compiler/src/llvm/include/llvm/IR/Instruction.h:437: void llvm::Instruction::setInstructionSubclassData(unsigned short): Assertion `(D & HasMetadataBit) == 0 && "Out of range value put into field"' failed.
[01:17:42] <strcat> rusti: for 5.times { println("foo") }
[01:17:44] -rusti- foo
[01:17:44] -rusti- foo
[01:17:44] -rusti- foo
[01:17:44] -rusti- foo
[01:17:44] -rusti- foo
[01:17:49] <cmr> yup that's the one
[01:17:52] <aatch> thiez, that's the LLVM assertion
[01:18:07] <thiez> that's interesting
[01:18:12] <mcpherrin> strcat: thanks :)
[01:18:17] *** Joins: gunther (Mibbit@C79F8129.C20800D2.D6ECB108.IP)
[01:18:23] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[01:18:51] <aatch> thiez, for further reference, it is literally the only test that fails.
[01:19:03] <thiez> I think I made it compile a store/load with sizeof(intptr_t), which should be the same as int
[01:19:34] <thiez> (in rust, not C)
[01:19:51] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Client exited)
[01:20:12] *** Joins: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP)
[01:21:57] *** Quits: infynyxx (infynyxx@DB780A29.749BA1D.DCC373F0.IP) (Ping timeout)
[01:22:49] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[01:24:27] <fread2281> rusti: "h"
[01:24:28] -rusti- "h"
[01:25:06] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[01:25:22] <a_m0d> Could someone please try running some code for me - https://gist.github.com/am0d/5596328
[01:25:31] <cmr> Could someone lend me a hand? For https://github.com/cmr/rust/tree/faster_each_permutation I'm getting https://gist.github.com/cmr/fec4c1bd9542f24fbda6 and I do not know how to handle this.
[01:25:34] <a_m0d> This is my bubble sort code, and it fails randomly for some reason
[01:25:50] <cmr> a_m0d: fails how?
[01:26:06] <cmr> oh
[01:26:10] <cmr> I see the second file
[01:26:14] <a_m0d> Yeah
[01:26:28] <a_m0d> Thing is, sometimes the first run fails, sometimes the last, sometimes they all pass
[01:27:02] <a_m0d> the only random thing I can see is the generation of the array
[01:27:02] <jclements> pauls: ping
[01:27:21] <a_m0d> I'd love to know if it happens for anyone else, or if it only fails on my machine
[01:27:43] <cmr> a_m0d: can replicate
[01:28:41] *** Quits: gunther (Mibbit@C79F8129.C20800D2.D6ECB108.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:28:42] <cmr> a_m0d: also, vec::swap :)
[01:28:45] *** Joins: burntsushi (burntsushi@moz-27A1B1D8.dhcp.oxfr.ma.charter.com)
[01:28:49] <aatch> thiez, if it helps, it's failing when it tries to set the load as atomic
[01:29:32] <thiez> I think that might help :)
[01:29:50] <cmr> a_m0d: in ensure_sorted you can use vec::each, rather than the loop
[01:29:55] <a_m0d> cmr: good to know it's not just me
[01:29:58] <thiez> aatch: what kind of system are you running?
[01:30:07] <aatch> 64-bit Linux
[01:30:17] <aatch> Built Rust with clang
[01:30:23] <thiez> how to build rust with clang?
[01:30:32] <aatch> thiez, ./configure --enable-clang
[01:30:32] <cmr> configure --enable-clang
[01:30:37] <thiez> ok, thanks
[01:30:50] <cmr> cscottnet_away reproduced with gcc though
[01:30:54] <cmr> (and on 32bit)
[01:31:08] <thiez> given that it's 3:30 AM over here I think I'll solve this tomorrow :p
[01:31:13] <a_m0d> cmr: I had problems getting vec::swap to work originally, but the types are a bit different so I'll try again
[01:31:19] <thiez> thanks for all the feedback
[01:31:31] <cmr> a_m0d: should be able to do arr.swap(left, right)
[01:32:13] <cmr> altohugh it might be vec::Swap(arr, left, right)
[01:32:15] <cmr> can't remember
[01:33:38] <a_m0d> thanks, got the vec::swap working, but that didn't fix the problem
[01:33:47] <cmr> right, didn't expect it to
[01:33:48] <a_m0d> I'll also try replace the loop with vec::each
[01:33:58] <cmr> just suggesting cleanups to make it more rustic :)
[01:33:58] *** Quits: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com) (Quit: bleibig)
[01:34:02] <a_m0d> I'm not sure if the validation code is wrong - I don't think so
[01:34:09] <a_m0d> cmr: I appreciate that
[01:34:22] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[01:34:30] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Input/output error)
[01:34:37] *** Joins: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com)
[01:34:52] <a_m0d> Rustic is starting to look cleaner to me, the more I work with it; higher level functions and operations (e.g. vec::swap, etc.) are really good for that
[01:35:43] *** Quits: bnicholson (bnicholson@moz-C03D0C61.vlan426.asr1.sfo1.gblx.net) (Ping timeout)
[01:38:54] *** kimundi is now known as zz_kimundi
[01:39:02] <cmr> a_m0d: btw, if timer code like what you have isn't already somewhere in libstd, it'd probably be a nice contribution :)
[01:39:22] <a_m0d> cmr: Yeah, I'm trying to write this as a re-usable library.
[01:39:40] <a_m0d> My next task is to split it into a module and use it to time a few more sort functions
[01:39:48] <a_m0d> And then I might contribute it
[01:41:02] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[01:42:19] <a_m0d> Figured out the bug - it was in my sort code - the early exit part of it was incorrect.  I removed that and the bug seems to be gone
[01:42:37] <Jeaye> *seems*
[01:42:40] <Jeaye> ^_^
[01:42:44] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[01:44:53] <a_m0d> Jeaye: after running the same code about 500 times, I haven't seen the bug again - I think it's safe to say it's gone :)
[01:47:19] *** Quits: mermi (Mibbit@moz-B2B382E7.hsd1.fl.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:48:57] <EXetoC> yep. time to ship
[01:49:12] <a_m0d> :D
[01:50:49] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[01:54:15] *** Quits: luigy (luigy@moz-57FF0274.nwrknj.fios.verizon.net) (Quit: Computer has gone to sleep.)
[01:54:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[01:54:23] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/ljj_WA
[01:54:23] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[01:54:46] <strcat> nmatsakis: https://github.com/mozilla/rust/pull/6544 r?
[01:54:50] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Client exited)
[01:56:18] <cmr> r? https://github.com/mozilla/rust/pull/6546
[01:57:07] <strcat> cmr: r+
[01:57:10] <cmr> thx
[02:00:22] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:00:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/geaoAw
[02:00:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:00:24] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[02:00:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8kQ6qg
[02:00:25] <ghrust> 13rust/06auto 1408ef229 15Daniel Micay: iter: add fold, sum and product
[02:00:25] <ghrust> 13rust/06auto 1409bf401 15bors: auto merge of #6544 : thestinger/rust/new_iter, r=nikomatsakis
[02:00:25] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[02:03:50] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[02:03:50] <aatch> so this is what the ordering being passed to atomic load is: 0x3eca67a0
[02:05:06] <aatch> This is what it should be: 0x7
[02:08:05] <cmr> aatch: what commit are you on, with this error?
[02:08:21] <aatch> cmr, I'm more-or-less incoming
[02:08:29] <cmr> ok
[02:08:41] <aatch> I'm actually on a branch of brson's atm
[02:08:48] <benh> iter::to_vec is a weird function. Calling it seems to be more verbose than the function itself is.
[02:09:07] <benh> internal iterators compose weirdly ;)
[02:11:07] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Quit: WeeChat 0.4.0)
[02:11:48] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[02:13:52] <bjz> Jeaye: ping
[02:14:52] <strcat> benh: iter::to_vec(internal_iterator)
[02:14:56] <strcat> not that bad
[02:15:04] <strcat> but it assumes the internal takes 1 argument
[02:15:12] <strcat> and partial application is verbose in rust
[02:15:56] <strcat> the protocol has a very loose definition that's not actually usable in a function signature
[02:16:04] <strcat> without making you use partial application
[02:16:47] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[02:16:56] <aatch> I found the Atomic load issue
[02:17:46] <benh> I guess the example would be less verbose if it didn't want to deref pointers
[02:18:16] <strcat> benh: yeah in that example it could use .consume
[02:18:20] <strcat> if .consume worked
[02:18:25] <strcat> anyway it's just an example
[02:18:30] <aatch> The wrapper function in C takes 4 args, the rust decl takes 3
[02:18:31] <strcat> not meant to be idiomatic since it doesn't actually do anything
[02:18:34] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[02:18:52] <cmr> aatch: ouch. 
[02:23:25] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[02:24:29] *** Quits: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP) (Quit: pcwalton)
[02:25:27] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[02:34:02] <bjz> strcat: r? https://github.com/mozilla/rust/pull/6549
[02:34:18] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[02:34:23] <bjz> Jeaye: ping
[02:34:58] <cmr> bjz:  can you add a default impl of sin_cos?
[02:35:08] <bjz> cmr: we will
[02:35:21] <bjz> cmr: once default impls work :)
[02:35:25] <cmr> ah
[02:35:43] <cmr> (it was a genuine question, I didn't know if it were possible)
[02:36:00] <bjz> no, it's a good question
[02:36:24] <bjz> there are many places in core::num where we could use default impls
[02:37:11] <bjz> the thing is, default impls are a backwards-compatible change, so they haven't been a high priority at the moment for the compiler devs
[02:38:48] <cmr> makes sense
[02:39:48] <strcat> bjz: is the reason for implementing this to make use of some hardware support eventually?
[02:40:01] <bjz> strcat: yes
[02:40:22] <bjz> strcat: also because its useful in some circumstances
[02:41:34] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[02:42:20] <bjz> strcat: added some more info on the PR
[02:43:01] <strcat> rusti: 5
[02:43:04] -rusti- 5
[02:43:19] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[02:43:37] <bjz> strcat: folks were complaining that the rusti notices were pining them
[02:43:48] <bjz> *pinging
[02:44:05] <strcat> bjz: well afaict it's the proper way to do it and clients shouldn't be pinging on NOTICE ;\
[02:44:12] <bjz> :(
[02:44:17] <bjz> silly clients
[02:44:24] <bjz> (my one doesn't)
[02:44:25] <cmr> strcat: rfc? what rfc.
[02:44:49] <strcat> bjz: notice is just support to be like privmsg but you aren't allowed to automatically respond to it
[02:45:01] <strcat> so it stops bot loops and marks the output as automatically generated
[02:45:21] <strcat> or at least, output a bot shouldn't respond to ;p
[02:46:03] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3]; let mut it = xs.iter(); for it.advance |&x| { println(x.to_str()) }
[02:46:04] -rusti- 1
[02:46:04] -rusti- 2
[02:46:04] -rusti- 3
[02:46:20] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3]; for xs.iter().advance |&x| { println(x.to_str()) }
[02:46:21] -rusti- 1
[02:46:21] -rusti- 2
[02:46:21] -rusti- 3
[02:46:23] <strcat> yay!
[02:46:28] <benh> Why is advance not called each?
[02:46:42] <cmr> not repeatable, I imagine
[02:46:45] <benh> Because the iterator doesn't logically contain the iteratees?
[02:46:46] <strcat> benh: because it takes &mut self and modifies the iterator
[02:46:49] <benh> ah
[02:47:13] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3]; for xs.iter().advance |&x| { if x == 2 { break } }; x.next()
[02:47:15] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/jKdO
[02:47:16] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3]; for xs.iter().advance |&x| { if x == 2 { break } }; xs.next()
[02:47:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MMgI
[02:47:19] <strcat> ugh
[02:47:20] * strcat is silly
[02:47:28] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Client exited)
[02:47:30] *** Quits: jgilbert (jgilbert@2557E599.66715431.D25A875A.IP) (Ping timeout)
[02:47:34] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3]; let mut it = xs.iter(); for it.advance |&x| { if x == 2 { break } }; it.next()
[02:47:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eJEi
[02:48:02] <benh> heh :(
[02:48:04] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3]; let mut it = xs.iter(); for it.advance |&x| { if x == 2 { break } }; fmt!("%?", it.next())
[02:48:05] -rusti- ~"Some(&3)"
[02:48:26] <strcat> if you break the state is still saved
[02:48:38] <strcat> it was advanced to that state
[02:48:42] <strcat> I just think it makes more sense than 'each'
[02:48:56] <benh> probably
[02:49:52] <benh> my toy iterator mockup passed them by value and advanced something like it = it.next()
[02:49:58] <benh> so i keep getting confused ;
[02:49:59] <benh> ;)
[02:50:21] <strcat> benh: well the protocol uses 'fn next(&mut self) -> Option<T>'
[02:50:28] <strcat> advance is one of the default impl'ed adaptors you get
[02:51:00] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[02:51:23] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3, 4, 5]; for xs.iter().take_while(|&x| *x < 3).advance |&x| { println(x.to_str()) }
[02:51:24] -rusti- 1
[02:51:24] -rusti- 2
[02:51:38] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3, 4, 5]; for xs.iter().take_while(|&x| *x < 3).transform(|x| x * 2).advance |&x| { println(x.to_str()) }
[02:51:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MfgC
[02:51:48] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3, 4, 5]; for xs.iter().take_while(|&x| *x < 3).transform(|x| x * 2).advance |x| { println(x.to_str()) }
[02:51:49] -rusti- 2
[02:51:49] -rusti- 4
[02:52:12] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[02:53:17] *** Quits: zz_kimundi (kimundi@moz-B735306B.dip0.t-ipconnect.de) (Ping timeout)
[02:54:41] <aatch> strcat (or anybody else): https://github.com/mozilla/rust/pull/6550 r?
[02:55:29] <strcat> aatch: ugh that's a horrible bug :(
[02:55:40] <aatch> strcat, yep
[02:55:48] <aatch> And theres very little you can do about it.
[02:56:14] <aatch> And it seems like luck of the draw as to whether it actually fails or not.
[02:56:42] *** Joins: zz_kimundi (kimundi@moz-609262F2.dip0.t-ipconnect.de)
[02:57:02] <Luqman> aatch: ouch :(
[02:57:05] <SiegeLord> Maybe it's possible to examine the library code's assembly to infer the number of arguments the function takes?
[02:57:07] *** zz_kimundi is now known as kimundi
[02:57:08] <Luqman> were tests not fialing in auto?
[02:57:17] <SiegeLord> *-code
[02:57:19] <cmr> Luqman: nope.
[02:57:41] <strcat> SiegeLord: no, but you don't need to
[02:57:43] <aatch> Luqman, well if the Ordering parameter was 0, it was fine.
[02:58:00] <strcat> just need to make bindgen better and integrated into rustc
[02:58:20] <strcat> rustc should be able to just import C libraries *by looking at the headers to find defs*
[02:58:36] <SiegeLord> It's not possible to make a full binding automatically
[02:58:36] <cmr> before or after preprocessing...
[02:58:40] <strcat> because headers vary per-platform, for example gmp's headers have different types/defines based on compile-time options
[02:58:45] <strcat> SiegeLord: not about making a binding
[02:58:55] <strcat> just about declaring the C functions automatically
[02:59:03] <SiegeLord> It's not clear to me that that would work
[02:59:05] <strcat> you still have to wrap it and make it safe
[02:59:07] <strcat> SiegeLord: why?
[02:59:13] <strcat> D does it
[02:59:14] <SiegeLord> I had to heavily modify the bindgen output to suit my needs
[02:59:21] <strcat> SiegeLord: what has to be modified?
[02:59:21] <SiegeLord> No it doesn't
[02:59:25] <SiegeLord> I manually generate my D bindings
[02:59:36] <SiegeLord> Because D's version of bindgen sucks
[02:59:37] <benh> rusti: trait Tr<'self> { fn f(&self) -> &'self int; } fn g<T: Tr<'self>>() { }
[02:59:37] -rusti- error: internal compiler error: unexpected failure
[02:59:38] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[02:59:38] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[02:59:49] *** Quits: catpig (catpig@moz-88EA3F26.dip0.t-ipconnect.de) (Quit: Verlassend)
[03:00:00] <SiegeLord> strcat, Well, mutability for one... names of some types
[03:00:15] <strcat> SiegeLord: they declare mutability
[03:00:22] <strcat> it should default to *mut if it's not const
[03:00:26] <strcat> and I think it does now
[03:01:17] <cmr> r? https://github.com/mozilla/rust/pull/6523
[03:01:19] <strcat> it can't handle enums and unions
[03:01:30] <benh> strcat: is rusti on an uptodate incoming?
[03:01:31] <strcat> but there's no way to portably deal with them from rust
[03:01:38] <strcat> benh: yes, it just updated itself actually
[03:01:45] <benh> swell
[03:01:46] <strcat> I have a repo with daily builds and rusti pulls from there
[03:02:28] <strcat> rusti: core::run::run_program("rustc", [~"--version"]);
[03:02:29] -rusti- rustc 0.6 (00eef96 2013-05-16 13:37:39 -0700)
[03:02:29] -rusti- host: x86_64-unknown-linux-gnu
[03:02:30] <Luqman> cmr: r+
[03:02:36] <cmr> Luqman: thanks
[03:02:52] <strcat> benh: pretty close to the tip of incoming now ;p
[03:02:55] <strcat> it's 1 merge behind
[03:03:17] <benh> trying to figure out whether that ICE is already known...
[03:03:25] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:03:25] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/8kQ6qg
[03:03:25] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:03:29] <strcat> now 2 ;p
[03:04:09] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[03:04:59] * strcat can kill off most of old_iter soon :)
[03:06:24] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:06:24] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8ldz6w
[03:06:24] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:06:27] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[03:06:27] <ghrust> 01[13rust01] 15bors pushed 6 new commits to 06auto: 02http://git.io/sEJNyQ
[03:06:27] <ghrust> 13rust/06auto 142264c79 15Tommy M. McGuire: Add reverse_part, replace each_permutation, add tests
[03:06:27] <ghrust> 13rust/06auto 145948d8a 15Tommy M. McGuire: Ensure reverse_part does not access outside given vector
[03:06:27] <ghrust> 13rust/06auto 14c99d1de 15Corey Richardson: Update to modern rust
[03:06:28] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[03:06:49] <SiegeLord> I guess I'll have to see it to believe it
[03:06:57] <cmr> how did that get to the top of the queue :\
[03:07:15] <strcat> cmr: is it old?
[03:07:21] <strcat> the oldest things go first
[03:07:25] <strcat> based on when the pull was opened
[03:07:28] <cmr> ah
[03:07:40] <cmr> I assumed the order would depend on when it was r+'d
[03:07:52] <strcat> it sorts by (priority, age_of_pr)
[03:08:59] <strcat> looks like the age sorting is just implicit from the order it iterates
[03:09:14] <strcat> I guess python's sort is a stable sort? I don't remember.
[03:09:52] <Luqman> i believe it was
[03:11:27] *** Joins: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[03:12:13] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[03:13:43] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: Leaving)
[03:16:26] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[03:17:23] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[03:17:26] <Jeaye> bjz: pong
[03:23:58] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[03:26:06] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[03:27:58] *** Joins: jclements_ (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[03:28:10] <cmr> How do I open a file?
[03:28:25] <cmr> I don't see anything in core::io for it
[03:29:49] <mcpherrin> cmr: http://mcpherrin.ca/tmp/bIZ
[03:29:56] <a_m0d> cmr: https://github.com/mozilla/rust/wiki/Doc-reading-and-writing-files
[03:30:12] <cmr> a_m0d: oh hey, look at that!
[03:30:26] <a_m0d> although I'm not sure how accurate it still is
[03:30:38] <a_m0d> And it really should be put somewhere much more visible
[03:30:47] *** Joins: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com)
[03:30:53] <a_m0d> *References: rust-0.3 docs :-/
[03:31:20] <engla_> cmr: file_reader/file_writer still exist
[03:31:41] <bjz> Jeaye: hoy
[03:32:08] <bjz> Jeaye: I have an issue with glfw that would be nice if you could help me with
[03:32:49] *** Quits: jclements_ (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements_)
[03:33:05] <bjz> Jeaye: I think it would be better to store the WindowData struct in the window userpointer
[03:33:20] <bjz> Jeaye: ie. as opposed to TLS
[03:34:10] <Jeaye> hmm
[03:35:37] <Jeaye> I don't know much about the glfw-rs internals.
[03:35:50] *** Quits: engla_ (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[03:36:58] <bjz> Jeaye: mmk
[03:37:17] <bjz> Jeaye: I'm attempting to start documenting it better
[03:38:12] <Jeaye> Yeah. I've just never really needed to know about it, since I'm simply just using the code provided in the examples to create my window and context.
[03:38:35] <bjz> that's exactly what I like to hear
[03:38:39] <Jeaye> :P
[03:38:48] <bjz> you shouldn't have to know about the internals :)
[03:39:11] <bjz> (still, in order to do that, I need to worry about it)
[03:39:18] <bjz> :)
[03:39:22] <Jeaye> Yeah. ^_^
[03:39:26] <Jeaye> Someone has to.
[03:39:42] <Jeaye> I've q3 to worry about. >.<
[03:40:01] <bjz> heh
[03:40:25] <bjz> yeah, I'll never get to my game :P
[03:40:39] <bjz> *chortle*
[03:40:39] *** Quits: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net) (Quit: Leaving.)
[03:40:46] <Jeaye> Maybe you will!
[03:41:51] <bjz> Jeaye: not when I'm messing around with numerics and wrapper libs :)
[03:41:57] <Jeaye> Aye.
[03:42:04] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[03:42:23] <Jeaye> But those'll come to an end eventually. Or at least they'll require less attention.
[03:42:39] <Jeaye> I reckon' Rust will be around for a while. :P
[03:42:44] <bjz> yeah, once Rust has settled down
[03:42:58] <bjz> it's also nice to help other people
[03:43:06] <Jeaye> Aye.
[03:43:07] <bjz> :)
[03:43:13] <bjz> (make cool stuff)
[03:43:29] * bjz can't wait until lmath is awesome
[03:43:36] <bjz> :P
[03:43:41] <Jeaye> heh
[03:43:49] <bjz> still have to wait for some more feature
[03:43:51] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[03:43:53] <Jeaye> It'll be useful.
[03:43:54] <bjz> *features
[03:44:04] <Jeaye> And save people quite a bit of time.
[03:44:06] <bjz> I feel bad that it's broken all the time
[03:44:24] * Jeaye remembers writing his math lib for q3. Wasn't fun.
[03:44:34] <bjz> when people have been using it, and their stuff is broken too
[03:44:48] <bjz> oh wells
[03:44:52] <bjz> onwards!
[03:44:55] <Jeaye> All in good time.
[03:44:58] * strcat is very happy about the rvalue thing
[03:44:59] <bjz> aye
[03:45:08] <bjz> okies
[03:45:11] <bjz> gotta go
[03:45:17] <bjz> coffee awaits
[03:45:19] <bjz> :)
[03:45:21] <strcat> ;p
[03:45:36] <Jeaye> o/
[03:45:42] <Jeaye> Howdy strcat 
[03:45:47] <strcat> hi
[03:46:06] <strcat> rusti: bytes!("foo")
[03:46:08] -rusti- &[102, 111, 111]
[03:46:17] <Jeaye> ohh
[03:46:21] <strcat> rusti: bytes!(~"foo")
[03:46:21] -rusti- foo.rs:5:9: 6:5 error: bytes! takes 1 argument.
[03:46:21] -rusti- foo.rs:5          bytes!(~"foo")
[03:46:21] -rusti- foo.rs:6     });
[03:46:27] <Jeaye> Fancy
[03:46:30] <cmr> wut
[03:46:36] <strcat> need to teach it to handle ~"foo" and @"foo"
[03:46:46] <cmr> that error message doesn't make any sense?
[03:46:50] <strcat> cmr: it does ;p
[03:46:57] <cmr> what's the second argument?
[03:47:01] <strcat> it's a syntax ext so it sees tokens
[03:47:03] <strcat> "foo" is a token
[03:47:05] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[03:47:09] <cmr> ahhh
[03:47:40] <Jeaye> rusti: bytes!(42)
[03:47:41] -rusti- foo.rs:5:9: 6:5 error: bytes! requires a string.
[03:47:41] -rusti- foo.rs:5          bytes!(42)
[03:47:41] -rusti- foo.rs:6     });
[03:48:00] *** Joins: fournm (Aria@moz-DA4B3E49.austin.res.rr.com)
[03:48:05] <cmr> rusti: let x = ~"foo"; bytes!(x)
[03:48:05] -rusti- foo.rs:5:25: 6:5 error: bytes! requires a string.
[03:48:05] -rusti- foo.rs:5          let x = ~"foo"; bytes!(x)
[03:48:06] -rusti- foo.rs:6     });
[03:48:40] <strcat> it's for byte constants
[03:49:06] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[03:49:09] <strcat> hm
[03:49:21] <strcat> I guess it doesn't matter if it only handles &'static str
[03:50:43] <strcat> can always convert to ~[u8] or @[u8] via a move at runtime
[03:52:16] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke. It's all a joke.)
[04:05:21] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[04:06:12] <cmr> Whoa
[04:06:21] <cmr> auto-mac is exploding
[04:06:23] <cmr> http://buildbot.rust-lang.org/builders/auto-mac/builds/1308/steps/test/logs/stdio
[04:06:48] <cmr> wait nevermind, those all seem to be expected
[04:10:08] *** Quits: hay_guise (Mibbit@moz-258BC5F7.eastlink.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[04:10:46] *** Joins: thpickert (thpickert@moz-99F22CD3.dynamic.dsl.tng.de)
[04:11:03] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Quit: Jesse)
[04:11:05] <cmr> jesse99: Are you going to maintain rparse?
[04:11:30] <jesse99> I dunno, I have a lot less time to play around with rust
[04:11:41] <fournm> Is rustpkg picky or.. am I terribly misunderstanding how to use it?
[04:11:54] <jesse99> and when I tried to update a project from 0.5 to 0.7 I got kind of discouraged by the zillion errors
[04:12:13] <cmr> mind giving me contributorship, then?
[04:12:24] <jesse99> ok
[04:13:09] <jesse99> I think there was a branch with some neato operator overloading for function composition but back in the day it ICEd all over
[04:17:12] <cmr> I'm cmr on github btw
[04:17:21] <jesse99> oh
[04:17:44] *** Parts: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP) ()
[04:17:49] <aatch> fournm, rustpkg is, as far as I am aware, incomplete
[04:18:14] <jesse99> OK I added you cmr
[04:18:18] <cmr> jesse99: thanks
[04:18:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:18:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/sEJNyQ
[04:18:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:18:23] <jesse99> (won't be on much longer tonight)
[04:20:00] <fournm> aatch: ah. fair enough.
[04:21:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:21:21] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/hAiU4w
[04:21:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:21:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[04:21:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/_L2YFQ
[04:21:23] <ghrust> 13rust/06auto 14c2baaa8 15Corey Richardson: fix warnings
[04:21:23] <ghrust> 13rust/06auto 14918bfa7 15bors: auto merge of #6546 : cmr/rust/warning, r=thestinger
[04:21:23] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[04:24:23] *** Joins: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net)
[04:24:34] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[04:26:40] *** Quits: heftig (heftig@moz-B697A2F0.dip0.t-ipconnect.de) (Ping timeout)
[04:26:49] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Quit: lmandel)
[04:26:52] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[04:27:20] *** Joins: heftig (heftig@moz-97B64F16.dip0.t-ipconnect.de)
[04:29:26] *** Joins: eholk (eholk@moz-C345A84D.hsd1.ut.comcast.net)
[04:29:46] *** Quits: thpickert (thpickert@moz-99F22CD3.dynamic.dsl.tng.de) (Quit: thpickert)
[04:31:14] *** Joins: z0w0 (zack@moz-B13FD5D7.lns2.cha.bigpond.net.au)
[04:32:27] <dbaupp> strcat: I see that rvalue mutability has landed! \o/
[04:32:39] <strcat> dbaupp: yep :)
[04:32:55] <dbaupp> have you converted the iterators over to it yet? ;P
[04:32:58] <strcat> rusti: use core::iterator::*; let xs = ~[1, 2, 3, 4, 5]; for xs.iter().take_while(|&x| *x < 3).transform(|x| x * 2).advance |x| { println(x.to_str()) }
[04:32:59] -rusti- 2
[04:32:59] -rusti- 4
[04:33:17] <dbaupp> :D
[04:33:22] <strcat> dbaupp: I think it's only the tests that need to be converted
[04:33:27] <strcat> it Just Works with the way it was
[04:34:52] <dbaupp> yup... that line looks much nicer, though
[04:38:58] *** Joins: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP)
[04:42:35] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[04:44:24] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[04:45:55] *** Joins: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net)
[04:47:35] *** Joins: jclements_ (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[04:48:58] *** Joins: brson (brson@moz-6A295265.hsd1.ca.comcast.net)
[04:48:58] *** ChanServ sets mode: +o brson
[04:50:00] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[04:50:38] *** Quits: brson (brson@moz-6A295265.hsd1.ca.comcast.net) (Ping timeout)
[04:53:23] <cmr> heh, managed to hang vim..
[04:54:11] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[04:54:11] *** ChanServ sets mode: +o brson
[04:54:29] <strcat> cmr: vim or the terminal?
[04:54:32] <cmr> vim
[04:54:36] <strcat> heh
[04:54:41] <strcat> terminals are easy to hang, but I haven't done it to vim beforew
[04:54:52] <cmr> I haven't hung urxvt yet
[04:55:03] <strcat> cmr: there are known escape sequences you can hang terminals with though
[04:56:34] <acrichto> strcat: r? https://github.com/mozilla/rust/pull/6093 I had some test failures this afternoon sadly, but they should be fixed now
[04:57:03] <strcat> acrichto: r+
[04:57:06] <acrichto> strcat: thanks!
[04:57:27] <strcat> cmr: I mean, `tput smacs` is already pretty messed up :)
[04:57:46] <strcat> but you can give them stuff like a 10000000000 parameter to clear screen
[04:58:09] <strcat> anything you run in a terminal without sanitizing escapes is essentially fairly trusted
[04:58:14] <strcat> at least trusted enough to not freeze it.
[04:58:40] <strcat> smacs is how you draw a bunch of weird pre-unicode alternate chars
[04:58:55] <strcat> just hope the application switches it back before exiting...
[04:58:57] <strcat> :D
[04:59:03] <strcat> there are a lot of weird modes like that
[04:59:18] <strcat> want to set the title? there's an escape to move the cursor *into the statusline* and then another to go out
[04:59:23] <strcat> so an application can get you stuck in the titlebar...
[04:59:27] <cmr> wut
[04:59:43] <mcpherrin> strcat: OS X terminal.app has some GREAT ones
[04:59:56] <cmr> I'd always assumed taht escape just set the title TO that text
[05:00:23] <mcpherrin> If you have a mac, run curl http://csclub.uwaterloo.ca/~mmmulani/lol.cgi
[05:00:25] <strcat> cmr: if you look in man terminfo, you can search for to_status_line and from_status_line
[05:00:29] <strcat> it's 2 escapes :)
[05:00:31] <strcat> not an atomic thing
[05:00:46] <cmr> blech
[05:00:55] <strcat> cmr: how vim sets the title is *amazingly* horrific
[05:01:10] <strcat> cmr: unset the WINDOWID env var and vim won't set the title by default anymore
[05:01:18] <strcat> why? because it uses WINDOWID *to query X* for the title
[05:01:25] <strcat> and when you exit it can restore to the old title
[05:01:27] <strcat> :D
[05:01:57] <strcat> ofc it needs X support to do that
[05:02:10] <strcat> but console vim does it... pretty messed up
[05:02:17] <strcat> then again console vim also supports the X clipboard
[05:02:40] <strcat> it has 'xterm clipboard' support to which urxvt/xterm implement
[05:02:49] <strcat> sets the X clipboard *through* the terminal
[05:02:52] <strcat> totally redundant now
[05:03:12] <strcat> terminals are scaryt
[05:04:55] <strcat> luckily terminfo also supports phones with pulse dialing and printer toner
[05:05:30] <strcat> but ctrl-arrows? nooooooope. have to hardcode
[05:05:48] *** Joins: thpickert (thpickert@moz-24816453.tng.de)
[05:05:54] *** Quits: thpickert (thpickert@moz-24816453.tng.de) (Quit: thpickert)
[05:09:00] <cmr> src/parsers.rs:68:21: 68:25 error: Illegal anonymous lifetime: anonymous lifetimes are not permitted here
[05:09:02] <cmr> src/parsers.rs:68 impl CharParsers for &str {
[05:09:30] <cmr> If you impl for just "str" will it auto-deref?
[05:10:41] <strcat> cmr: can't, str isn't a type
[05:10:53] <strcat> impl<'self> CharParsers for &'self str
[05:11:08] <cmr> funky
[05:11:32] <strcat> and then 'self refers to the lifetime of the slice in all of the methods
[05:11:57] <strcat> not very useful for a slice... useful for other types ;p
[05:12:14] <cmr> What about:
[05:12:16] <cmr> src/types.rs:7:0: 7:60 error: trait bounds are not allowed in type definitions
[05:12:18] <cmr> src/types.rs:7 pub type Parser<T: Copy+Durable> = @fn (State) -> Status<T>;
[05:12:33] <cmr> (context: porting over rparse to 0.6, as an intermediate step before incoming)
[05:12:38] <strcat> cmr: need to actually define a new type
[05:12:45] <strcat> 'type' is just an alias
[05:13:04] <strcat> cmr: well
[05:13:12] <strcat> cmr: you also can't have bounds in a type definition ;p
[05:13:29] <strcat> need to just have them on the impl
[05:13:45] <strcat> and make the fields private if you don't want to allow constructing them without going through the constructor(s)
[05:15:08] <cmr> I don't understand. It's just a name for a specific signature of closure. What impl would I have what in?
[05:15:19] <cmr> (brbfood)
[05:16:45] <strcat> cmr: well then just leave off the Copy/Durable bounds
[05:20:43] *** Quits: bent (chatzilla@moz-932324BF.hsd1.ca.comcast.net) (Quit: ChatZilla 0.9.90-rdmsoft [XULRunner 18.0.2/20130201065344])
[05:21:21] <cmr> oh
[05:21:28] <cmr> yeah
[05:21:30] <cmr> strcat: thanks!
[05:22:33] *** Quits: blitter (blitter@moz-7C98731E.dyn.centurytel.net) (Ping timeout)
[05:24:10] <dbaupp> llvm errors </3
[05:24:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:24:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/_L2YFQ
[05:24:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:25:07] <strcat> dbaupp: rust should have a nice wrapper around llvm preventing LLVM asserts
[05:25:12] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[05:25:16] <strcat> it's rustc's fault ;p
[05:25:20] <aatch> strcat, theres an issue about that.
[05:25:37] <dbaupp> yup, and to give more info about where the assert happened
[05:25:47] <dbaupp> strcat, also, https://github.com/mozilla/rust/issues/6390 can be closed
[05:25:50] <strcat> and then we can disable LLVM assert support in optimized builds and get a nice 30% drop in LLVM's size...
[05:26:12] <strcat> dbaupp: which commit/pull fixed it?
[05:26:21] <strcat> oh
[05:26:22] <dbaupp> strcat: duplicated
[05:26:22] <strcat> duplicate
[05:26:27] <Ralith> disabling asserts drops the size by 30%?
[05:26:27] <Ralith> daaamn
[05:26:50] <Ralith> I thought the space consumption was all just the debug info
[05:27:23] <dbaupp> strcat: https://github.com/mozilla/rust/issues/4760 looks closeable too
[05:27:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:27:23] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/HWTU2w
[05:27:23] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:27:23] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[05:27:24] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/iSr84A
[05:27:24] <ghrust> 13rust/06auto 14030c666 15Alex Crichton: Re-implement lint with less emphasis on item ids...
[05:27:24] <ghrust> 13rust/06auto 141daaf78 15Alex Crichton: Optimize lint passes to perform far fewer allocations...
[05:27:25] <ghrust> 13rust/06auto 144d44abd 15Alex Crichton: Change lints to indicate exactly where the level was set
[05:27:26] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[05:27:28] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[05:27:37] <dbaupp> (due to duplication)
[05:27:41] <strcat> dbaupp: are you sure it's the same bug though?
[05:27:47] <strcat> could be multiple ways of hitting the same assert
[05:27:48] <dbaupp> strcat: which one?
[05:27:51] <strcat> these 3
[05:28:01] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[05:28:14] <strcat> Ralith: yep the asserts are pretty awful
[05:28:22] <dbaupp> two of them are both `let &(ref x, ) == ...;`
[05:28:23] <strcat> they don't really slow it down *much* though
[05:28:26] <strcat> dbaupp: ah
[05:28:34] <dbaupp> and the last is `let ref x = ...`
[05:30:14] *** Quits: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP) (Ping timeout)
[05:31:35] *** Quits: cdidd (cdidd@moz-7EFA154C.broadband.corbina.ru) (Input/output error)
[05:32:41] *** Quits: eholk (eholk@moz-C345A84D.hsd1.ut.comcast.net) (Quit: eholk)
[05:32:46] *** Quits: wuwei`lab (wuwei@1A513F49.818D7924.FAA9ED67.IP) (Quit: Leaving)
[05:32:47] *** Joins: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP)
[05:33:35] *** Joins: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP)
[05:33:35] *** ChanServ sets mode: +qo graydon graydon
[05:33:50] *** Quits: graydon (graydon@3853DDD.39EEDBB3.D758B1AA.IP) (Quit: Leaving.)
[05:33:59] <cmr> acrichto: 3x speedup? nice!
[05:34:17] <acrichto> cmr: just of the lint passes though, so nothing too major
[05:34:26] <cmr> right
[05:34:30] <acrichto> the vast majority of time is not spent linting :)
[05:39:07] *** Joins: cdidd (cdidd@moz-EC11ECD5.broadband.corbina.ru)
[05:43:07] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[05:44:51] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[05:45:08] *** Quits: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net) (Quit: zzzZZZzzz)
[05:45:56] <dbaupp> strcat: does Rc stand for reference counted?
[05:46:08] <strcat> dbaupp: yes
[05:46:18] <aatch> Ahh! This code won't compile without a snapshot...
[05:46:25] <strcat> and arc is atomatically reference counted
[05:46:32] <aatch> It doesn't know what order things are in.
[05:48:23] <dbaupp> strcat: eh, I broke the table on the rust for C++ programmers page :(
[05:48:28] <strcat> dbaupp: sec
[05:48:30] <strcat> fixing
[05:48:44] <dbaupp> (sorry :( )
[05:48:47] <strcat> it's fine :)
[05:48:59] <strcat> dbaupp: they have to be kept at the same length
[05:49:12] <strcat> there are other ways to define tables that would probably be saner for this
[05:49:21] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[05:49:26] <dbaupp> oh, eurgh... yeah, handformatting tables is not fun
[05:49:32] <strcat> dbaupp: well I have a plugin for it ;p
[05:49:41] <strcat> resize the top line and ,,f and it reformats
[05:49:50] <dbaupp> ooh, browser plugin? (or vim?)
[05:49:54] <strcat> https://github.com/nvie/vim-rst-tables it's buggy though
[05:49:55] <strcat> dbaupp: yeah vim
[05:50:09] <strcat> I've always wanted to write a better one supporting the various kinds of tables that exist
[05:50:15] <strcat> there are pandoc markdown ones, the rst ones, etc.
[05:50:37] <strcat> it doesn't work on that first table anyway :(
[05:50:43] <strcat> it wraps lines very very poorly
[05:51:20] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[05:53:54] <strcat> the docs for that plugin are wrong too ;p
[05:53:59] <strcat> ,,c makes a table, ,,f reformats
[05:54:30] <strcat> dbaupp: http://docutils.sourceforge.net/docs/user/rst/quickref.html#tables there's a lazy way of defining them but it's usually more confusing
[05:54:46] <dbaupp> you should send a pull request fixing it ;)
[05:54:56] <dbaupp> (the docs... not the whole plugin)
[05:55:21] <strcat> there are a lot of things I should report/fix ;p
[05:55:34] <dbaupp> that looks mildly complicated
[05:55:44] <strcat> I actually have a text file with bugs I have to report, it's 133 lines
[05:55:54] <strcat> I hate dealing with mailing lists.
[05:55:55] *** Quits: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com) (Quit: bleibig)
[05:55:58] <dbaupp> across multiple projects?
[05:56:00] <strcat> dbaupp: yep
[05:56:23] <dbaupp> none from rust, I guess
[05:56:29] <strcat> yeah rust ones I just report
[05:56:32] <strcat> and any github ones really.
[05:56:46] <strcat> finding a mailing list, subscribing so the email doesn't bounce, etc. is a pain
[05:56:53] <strcat> and then no one responds and it's not actually in some bug db...
[05:57:44] * strcat is a bug magnet
[05:57:54] <dbaupp> and, writing up the bug in a useful way
[05:57:59] <strcat> yeah
[05:58:10] <strcat> it's not very useful for me to say 'X has a segfault'
[05:58:18] <strcat> they're going to one a core dump or at least a stack trace
[05:58:23] <strcat> going to want*
[05:58:32] <dbaupp> yup, of course
[05:58:38] *** Quits: cdidd (cdidd@moz-EC11ECD5.broadband.corbina.ru) (Ping timeout)
[05:59:07] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[05:59:22] <dbaupp> http://stackoverflow.com/questions/16601160/multidimensional-vectors-in-rust-segfaulting
[05:59:26] <strcat> I don't bother reporting gnome project bugs anymore. I've never had a report not ignored
[05:59:41] <dbaupp> do big data structures actually make rust segfault? :(
[05:59:51] <dbaupp> strcat: yeah, gnome doesn't have a good reputation
[06:00:08] <strcat> I have bug reports with *patches* on gnome project bug trackers
[06:00:19] <strcat> UNCONFIRMED and no responses for months or over a year ;p
[06:00:24] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:00:29] *** Joins: cdidd (cdidd@moz-60E9E712.broadband.corbina.ru)
[06:00:30] * strcat sighs
[06:00:45] <strcat> they really need to sort out bug triage...
[06:01:05] <dbaupp> and community interaction in general
[06:01:08] <strcat> dbaupp: yeah well it sucks that they maintain gtk, libxml2, etc. ;p
[06:01:23] <strcat> for some value of maintain :)
[06:02:55] <strcat> dbaupp: my best experience was with intel-gpu-tools
[06:03:13] <strcat> the developer *emailed me* to tell me that there was a bug on Arch in the upcoming release
[06:03:16] <strcat> because I maintain the package
[06:03:23] <strcat> and they do CI on various distros I guess
[06:03:30] <strcat> anyway was some autotools issue
[06:03:32] <aatch> strcat, that's awesome
[06:03:35] <dbaupp> wow
[06:04:02] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:04:04] <aatch> And I am incredibly annoyed atm. The snapshot doesn't have flow-sensitivity.
[06:04:28] <cmr> There's a few places that could be cleaned up with a new snapshot too.
[06:04:34] <aatch> So it's getting pissy because I'm assigning to a variable that has a loan.
[06:04:44] <aatch> This loan comes /after/ being assigned
[06:04:47] <aatch> for the first time.
[06:05:07] <dbaupp> aatch: can you #[cfg(not(stage0))] the function/type/module?
[06:05:12] <strcat> dbaupp: yep
[06:05:15] <aatch> dbaupp, not really.
[06:05:23] <strcat> dbaupp: only if it's not used though
[06:05:29] <strcat> otherwise it's more of a pain ;p
[06:05:43] <dbaupp> strcat: yup, I know it's possible, wondering if it was actually doable in this instance ;)
[06:05:45] <strcat> and I think it still has to parse...
[06:05:54] <dbaupp> strcat: parse and expand
[06:06:01] <aatch> It parses fine
[06:06:20] <dbaupp> the stripping is the first non-libsyntax step
[06:06:35] <aatch> line 139: assigning to immutable local variable prohibited due to outstanding loan
[06:06:49] <aatch> line 141: note: loan of immutable local variable granted here
[06:06:58] <dbaupp> aatch: can you put the code in a block?
[06:07:05] <strcat> aatch: is it code that's actually used in stage0?
[06:07:13] <dbaupp> (does that work without the flow sensitivity?)
[06:07:23] <strcat> dbaupp: for a small subset
[06:07:39] <strcat> { immutable borrow }; { mutable borrow } // won't help
[06:07:44] *** Quits: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP) (Quit: Tschuss!)
[06:07:55] <aatch> I have it the way I do /because/ of blocking
[06:08:09] <strcat> dbaupp: well
[06:08:14] *** Joins: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP)
[06:08:16] <strcat> if the mutable borrow ends at the end of the block and doesn't return
[06:08:19] <strcat> yes it will work ;p
[06:08:26] <strcat> (and same for the immutable one)
[06:08:30] <dbaupp> aatch: put the snippet online? :)
[06:08:33] <aatch> I need a value to be alive for the duration of the function, but getting it is an unsafe operation
[06:08:35] <strcat> flow insensitivity was a huge pain...
[06:09:22] <aatch> https://gist.github.com/Aatch/d6c82db1a6813385b48c
[06:09:53] <dbaupp> new_buf?
[06:09:58] <aatch> dbaupp, yep
[06:10:30] <strcat>  store_buffer(&mut self.active_buffer, &new_buf);
[06:10:32] <strcat> buf = unpack_buffer(new_buf);
[06:10:34] <strcat> those conflict?
[06:10:40] <aatch> strcat, yep
[06:10:47] <strcat> does buf = unpack_buffer return & or an unrelated new value?
[06:10:56] <aatch> strcat, a &
[06:10:59] <strcat> ah
[06:11:04] <aatch> I know
[06:11:08] <strcat> so this is the really painful situation where blocks won't help :(
[06:11:10] <strcat> such a PITA
[06:11:48] <strcat> aatch: cast::transmute_region ;p
[06:12:01] <strcat> I'd add a stage0 version with that
[06:12:09] *** Quits: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org) (Quit: ZNC - http://znc.sourceforge.net)
[06:12:15] * strcat thinks that will work
[06:12:17] <aatch> strcat, yeah, I'll try and figure something out...
[06:13:12] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[06:13:50] <cmr> Why does rustc --pretty reorder /// comments :\
[06:14:05] <cmr> It moves all whitespace-only /// to top of block of ///
[06:14:13] *** Quits: infynyxx (infynyxx@moz-E95B370B.nyc.res.rr.com) (Client exited)
[06:14:30] <strcat> cmr: because it's evil :(
[06:14:41] <strcat> why does it put 20 blank lines at the top of my gmp bindings 
[06:14:54] * strcat wonders if it's still that bad
[06:15:13] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[06:15:22] <strcat> oh it doesn't do that anymore :)
[06:15:30] <cmr> maybe it doesn't do the /// stuff now
[06:15:47] <cmr> I'm using 0.6 because incoming ICE's on this old 0.5 syntax
[06:15:52] <cmr> which is reasonable behavior
[06:16:48] <dbaupp> not really
[06:17:10] <dbaupp> in theory there should be no ICEs
[06:17:15] <dbaupp> (just helpful error messages)
[06:17:17] <cmr> I wouldn't expect rustc to maintain backwards compatability back farther than a single version at this point
[06:17:18] *** Quits: cdidd (cdidd@moz-60E9E712.broadband.corbina.ru) (Connection reset by peer)
[06:17:38] <steven_is_false> Tough math question. Given 3 3D tangents corresponding to the sides of a triangle find a normal.
[06:18:15] <dbaupp> steven_is_false: cross product two of them
[06:18:18] <steven_is_false> In 2D given the two tangents (one's just a mirror of  the other) this is trivial.
[06:18:24] <steven_is_false> dbaupp: Doh!
[06:19:53] <steven_is_false> dbaupp: So, if the cross product finds the normal, and the normal in 2d only needs one value does that mean the cross product in 2D only takes one vector? How does one get the normal in 4d?
[06:20:07] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:20:11] <dbaupp> steven_is_false: eh, what do you mean by normal?
[06:20:24] <steven_is_false> dbaupp: For a triangle, I want the surface normal
[06:20:24] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Connection reset by peer)
[06:20:31] <dbaupp> (because normal in 2d doesn't make much sense ?)
[06:20:43] <steven_is_false> dbaupp: normal in 2d makes sense!
[06:20:57] <strcat> cmr: ICEs are unimplemented error messages though
[06:21:02] <strcat> it shouldn't ICE on *any* input
[06:21:12] <Jesse> i think of normal as "a vector perpendular to all the input vectors"
[06:21:23] <aatch> ICEs are "We shouldn't have got here"
[06:21:25] <dbaupp> steven_is_false: isn't it just any vector perpendicular to the 2d plane in 2d?
[06:21:47] <steven_is_false> dbaupp: Well yeah but they can be orthogonal to each other.
[06:22:12] <dbaupp> the triangle edge-vectors?
[06:22:33] <steven_is_false> dbaupp: For 2d it's not a triangle but a line
[06:22:44] <steven_is_false> dbaupp: For 4d it'd be a some wierd thing.
[06:22:50] <dbaupp> oooh, I understand
[06:23:19] <dbaupp> steven_is_false: the 4d thing is a 3d hyperplane
[06:23:49] *** Quits: Nisstyre (wes@moz-FD86289.netflash.net) (Client exited)
[06:23:58] <steven_is_false> dbaupp: Is it possible to get a normal from just two tangents in 4d, or does one need 3?
[06:23:59] <cmr> What category of math is this? Linear alg?
[06:24:08] <dbaupp> cmr: yeah, linalg
[06:24:15] <dbaupp> steven_is_false: 3
[06:24:44] <dbaupp> steven_is_false: you need to span 3 of the 4 dimensions to get a 1d thing left
[06:24:55] <steven_is_false> dbaupp: Is it N dimensions -> N - 1 tangents required?
[06:25:03] <dbaupp> steven_is_false: exactly :)
[06:25:08] *** Joins: cdidd (cdidd@moz-BFE6072C.broadband.corbina.ru)
[06:25:38] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:25:42] <steven_is_false> dbaupp: So 1 dimensions means no tangents required, as there is only one possible answer for the equation x * y = 0 forall y, and some x.
[06:25:50] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[06:27:12] <dbaupp> steven_is_false: yes
[06:27:28] <steven_is_false> dbaupp: Cool.
[06:27:58] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[06:29:25] <cmr> src/parsers.rs:870:27: 872:21 error: mismatched types: expected `core::result::Result<types::Succeeded<&'a>,<V58>>` but found `core::result::Result<types::Succeeded<'a>,<V61>>` (expected &-ptr but found type parameter)
[06:29:27] <cmr> src/parsers.rs:870                     } else {
[06:29:29] <cmr> src/parsers.rs:871                         result::Ok(Succeeded{new_state: pass2.new_state, value: pass.value,})
[06:29:31] <cmr> src/parsers.rs:872                     }
[06:29:33] <cmr> what is this error trying to tell me?
[06:29:44] <cmr> Specifically where would the &'a be where it is expecting a 'a
[06:29:59] <dbaupp> strcat: does rust grow the stack "in-place"?
[06:30:06] <strcat> dbaupp: it uses segments
[06:30:12] <strcat> the stack is essentially a linked list
[06:30:30] <strcat> if you call a function that needs 200MiB of stack space it should be allocating that space before the call if it doesn't have it
[06:30:32] <dbaupp> doesn't that break the data structure across multiple segments?
[06:30:33] <strcat> or there's a bug ;p
[06:30:35] <dbaupp> (and not work?)
[06:30:38] <steven_is_false> dbaupp: Thank you very much for your help.
[06:30:44] <strcat> dbaupp: well that never happens
[06:30:47] <dbaupp> steven_is_false: no problem
[06:30:49] <strcat> dbaupp: it knows how much stack a function needs
[06:30:54] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[06:30:57] <strcat> so it can allocate before calling
[06:30:57] <dbaupp> strcat: ooh, of course
[06:31:00] <bjz> brson: is bors tied up?
[06:31:03] *** Joins: fabiand (fabiand@moz-A08343BC.adsl.alicedsl.de)
[06:31:09] <dbaupp> strcat: that's pretty fancy
[06:31:16] <aatch> dbaupp, segmented stacks is handled by LLVM mostly
[06:31:29] <strcat> rust implements the function that actually expands the stacks
[06:31:34] <strcat> LLVM handles actually calling it
[06:31:42] *** Quits: jclements_ (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements_)
[06:31:46] <aatch> __morestack
[06:31:55] <dbaupp> well named
[06:32:06] <bjz> ahh I see http://buildbot.rust-lang.org/waterfall?branch=auto&refresh=15
[06:32:19] <strcat> dbaupp: it's essentially the same cost as -fstack-protector=all with C/C++
[06:32:27] <strcat> 2-5% for most code
[06:32:33] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:32:34] <strcat> assuming you start with a big segment.
[06:32:45] <aatch> dbaupp, even better, it's built into libgcc and is specially recognized by gdb
[06:32:54] <aatch> (but not valgrind...)
[06:32:59] <dbaupp> yeah, just reading the llvm page about it
[06:33:08] <strcat> it was added to libgcc for gccgo
[06:33:08] <cmr> I wouldn't call that "better"... ideally that information would be in an elf segment
[06:33:24] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[06:33:28] <aatch> cmr, "better" is what I meant.
[06:33:33] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:33:41] <steven_is_false> dbaupp: Hoorah! My 3D collision detection works perfectly!
[06:33:44] <aatch> I forget that sarcasm isn't well transmitted over text
[06:33:56] <cmr> mm
[06:33:57] <dbaupp> steven_is_false: sweet! :D
[06:33:59] <strcat> dbaupp: one of the big perf problems that's almost 100% fixed is that rust was switching to a separate stack for C calls
[06:34:04] <strcat> that's what #[fast_ffi] gets rid of
[06:34:09] <strcat> soon to be the default
[06:34:12] <dbaupp> strcat: yeah, met it a few times
[06:34:17] <steven_is_false> Anyways goodnight.
[06:34:21] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[06:34:34] <strcat> dbaupp: and also that rust starts with a small segment. which it probably shouldn't do by default on 64-bit
[06:34:46] <dbaupp> what size?
[06:34:53] <strcat> I forgot ;p
[06:35:03] <strcat> way under a MiB though
[06:35:14] <aatch> Well my fix was to just make stub impls of the functions affected and use #[cfg(stage0)]
[06:35:16] <strcat> atm it assumes all C calls need 2MiB though
[06:35:18] <dbaupp> woah, that's tiny
[06:35:20] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:35:36] <strcat> dbaupp: yeah it should eventually be possible for it to be tinier than it is now
[06:35:50] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:36:09] <strcat> but not *by default* because the OS (at least on linux) already lazily allocates stacks page-by-page on page faults
[06:36:15] <strcat> so all you waste is VM
[06:36:22] <strcat> which matters on 32-bit only
[06:36:59] <dbaupp> start with a gig of stack on 64 bit
[06:37:03] <dbaupp> should be fine
[06:37:32] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:37:50] <strcat> dbaupp: well linux does 8 or 10MiB for a process
[06:37:54] <strcat> and 2MiB for a thread
[06:37:57] <strcat> by default
[06:38:11] <strcat> so that would be fine
[06:38:18] <aatch> Start with a gig, touch every byte before executing
[06:38:46] <aatch>  // Zero out stack, I like to be clean
[06:39:25] <strcat> ;p
[06:40:46] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:40:51] <dbaupp> strcat: yep... it's fun overwriting other threads' stacks
[06:41:00] <dbaupp> (in C)
[06:42:16] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:42:16] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/iSr84A
[06:42:16] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:42:35] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[06:43:23] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[06:43:37] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[06:44:14] <cmr> acrichto: seems to have yielded a nice drop in compile and test times
[06:44:47] <cmr> 'course, one beforce could have been skewed... who knows
[06:45:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:45:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/aONBLA
[06:45:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:45:16] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[06:45:16] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/DoeFWg
[06:45:16] <ghrust> 13rust/06auto 145696081 15Brendan Zabarauskas: Implement sin_cos method for float, f64 and f32
[06:45:16] <ghrust> 13rust/06auto 148badea4 15bors: auto merge of #6549 : bjz/rust/numeric-traits, r=thestinger...
[06:45:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[06:45:23] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[06:45:52] <dbaupp> cmr: if you're looking at isrustfastyet, it hasn't updated for the most recent pull request
[06:46:23] <cmr> whoops
[06:46:39] <cmr> I'm convinced that that data is uselessly noisy, then
[06:47:26] <dbaupp> cmr: done now
[06:47:34] <dbaupp> made mac spike a lot
[06:47:45] <dbaupp> and yeah, it is ridiculously noisy
[06:48:59] <dbaupp> it also made windows-tests spike
[06:55:38] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Ping timeout)
[06:56:28] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[06:59:56] <aatch> strcat, how far is the new iterator stuff from finishing landing?
[07:00:17] <aatch> Importing iter, and old_iter is annoying
[07:00:30] <strcat> aatch: well core::iter and core::iterator are getting pretty complete
[07:00:50] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:00:51] <strcat> I haven't started on the *iterable* stuff
[07:00:54] <aatch> Especially since .each is in old_iter
[07:00:56] *** Joins: jclements_ (jclements@moz-20AD2EFB.dsl.static.sonic.net)
[07:01:30] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Connection reset by peer)
[07:01:32] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[07:01:51] <bjz> h3r3tic: ping
[07:02:32] <strcat> aatch: yeah but size_hint needs to be detached from it :(
[07:02:46] <strcat> it's a pain
[07:02:56] *** Quits: jclements_ (jclements@moz-20AD2EFB.dsl.static.sonic.net) (Quit: jclements_)
[07:03:00] <strcat> a size hint is a good idea, but it needs to be there for all kinds of iterables
[07:03:01] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Connection reset by peer)
[07:03:07] <strcat> and anyway you can probably just Container
[07:03:10] *** Joins: berak (chatzilla@AFDA5932.4742BCFA.1A5CC7E5.IP)
[07:03:13] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[07:03:15] <strcat> all Container requires is len and is_empty
[07:05:16] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:06:47] *** Quits: fournm (Aria@moz-DA4B3E49.austin.res.rr.com) (Quit: Leaving)
[07:08:25] *** Quits: matt (Mibbit@moz-8DB2A37.range109-154.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[07:08:35] *** Joins: doener (bs@moz-AA189A5A.unitymedia.biz)
[07:08:35] *** Quits: twm (twm@moz-13417AD3.dsl.static.sonic.net) (Ping timeout)
[07:13:01] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (Quit: Leaving)
[07:15:06] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:15:12] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:16:51] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:20:06] *** Joins: seckcoder (Mibbit@2D5D3043.56214CB4.75B241AF.IP)
[07:23:14] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:25:05] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:26:06] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:26:24] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[07:26:52] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Quit: leaving)
[07:28:38] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:28:39] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[07:31:06] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:32:23] *** Joins: twm (twm@moz-13417AD3.dsl.static.sonic.net)
[07:33:04] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:33:32] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[07:36:34] *** Quits: seckcoder (Mibbit@2D5D3043.56214CB4.75B241AF.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[07:38:49] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[07:40:35] *** Quits: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP) (Ping timeout)
[07:41:18] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[07:42:26] *** Quits: devbug (quassel@moz-E1DE087C.bchsia.telus.net) (Connection reset by peer)
[07:42:41] *** Quits: fabiand (fabiand@moz-A08343BC.adsl.alicedsl.de) (Quit: Verlassend)
[07:44:07] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[07:45:50] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[07:47:09] *** Quits: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net) (Ping timeout)
[07:47:10] *** Joins: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP)
[07:48:04] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eaten by a grue)
[07:48:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:48:14] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/DoeFWg
[07:48:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:51:59] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[07:53:36] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[07:54:03] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[07:57:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:57:12] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/isBOsA
[07:57:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:57:14] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[07:57:14] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/UC24Ig
[07:57:14] <ghrust> 13rust/06auto 14a289dcd 15James Miller: Fix AtomicLoad builder code
[07:57:14] <ghrust> 13rust/06auto 14a3d31f4 15bors: auto merge of #6550 : Aatch/rust/atomic-load, r=thestinger...
[07:57:14] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[07:59:03] *** Joins: eternaleye (eternaleye@moz-76321711.hsd1.wa.comcast.net)
[08:10:50] *** Joins: mitsuhiko (mitsuhiko-@moz-BC29B73E.srv.pocoo.org)
[08:11:58] *** Joins: jaen1 (jaen@moz-E0979827.copit.pl)
[08:12:01] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Connection reset by peer)
[08:12:10] <jaen1> /nick jaen
[08:12:12] *** jaen1 is now known as jaen
[08:13:10] *** Joins: EXetoC (ex@moz-C741B177.customer.t3.se)
[08:21:16] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[08:21:42] <thiez> wow that atomic intrinsics bug
[08:22:02] <thiez> can't believe I overlooked that :D
[08:24:36] <dbaupp> it's alright, aatch has got your back :D
[08:24:47] <thiez> yes, I see
[08:25:27] <thiez> nice that my mistakes get fixed while I'm sleeping :p
[08:25:32] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Ping timeout)
[08:26:26] *** Quits: pascal (pascal@moz-3A678551.pascalj.de) (Quit: .)
[08:28:07] *** Joins: pascal (pascal@moz-3A678551.pascalj.de)
[08:33:52] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[08:35:00] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[08:37:28] *** Joins: fabiand (fabiand@moz-A08343BC.adsl.alicedsl.de)
[08:40:30] *** Quits: otters (joel@moz-82AAB099.rs) (Ping timeout)
[08:41:26] *** Joins: otters (joel@moz-82AAB099.rs)
[08:42:29] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Ping timeout)
[08:44:39] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[08:46:28] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[08:49:55] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[08:53:30] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[08:54:59] *** Quits: fabiand (fabiand@moz-A08343BC.adsl.alicedsl.de) (Quit: Verlassend)
[08:56:35] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:56:58] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:59:20] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[09:02:15] *** Joins: Blub\w (wry@moz-3B49E725.wireless.dyn.drei.com)
[09:02:23] *** Joins: dobkeratops (walter@moz-B4683AA6.range31-52.btcentralplus.com)
[09:03:08] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[09:07:26] *** Quits: robn (robn@moz-76B0302C.static.internode.on.net) (Client exited)
[09:08:29] *** Joins: novabyte (Instantbir@moz-135D0E61.mullvad.net)
[09:09:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[09:09:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/UC24Ig
[09:09:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[09:12:23] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[09:12:58] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[09:14:26] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[09:15:18] *** Quits: Blub\w (wry@moz-3B49E725.wireless.dyn.drei.com) (Ping timeout)
[09:16:49] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[09:17:53] *** Joins: Blub\w (wry@moz-3B49E725.wireless.dyn.drei.com)
[09:18:53] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[09:19:52] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[09:27:33] *** Joins: robn (robn@moz-76B0302C.static.internode.on.net)
[09:41:05] *** Quits: z0w0 (zack@moz-B13FD5D7.lns2.cha.bigpond.net.au) (Quit: Leaving.)
[09:43:58] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[09:52:47] *** kimundi is now known as zz_kimundi
[09:53:10] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[09:53:42] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[09:54:43] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Ping timeout)
[09:55:01] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[09:55:31] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[09:55:45] *** zz_kimundi is now known as kimundi
[09:58:09] *** Quits: doomlord (doomlod@moz-B4683AA6.range31-52.btcentralplus.com) (Quit: Leaving)
[10:09:14] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[10:10:09] *** Quits: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP) (Input/output error)
[10:11:04] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[10:16:34] *** Joins: geomyidae (geomyidae@9FDA6BE2.37A86C23.448B98CC.IP)
[10:19:43] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Ping timeout)
[10:20:13] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[10:22:01] *** Joins: vmx (vmx@moz-86342C05.pools.arcor-ip.net)
[10:23:04] *** Joins: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP)
[10:23:11] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[10:24:23] <strcat> rusti: 2
[10:24:24] -rusti- 2
[10:32:51] *** Joins: doomsplayer (Mibbit@C8AEDC2E.F5F53E8A.2D6DB75E.IP)
[10:34:08] *** Quits: doomsplayer (Mibbit@C8AEDC2E.F5F53E8A.2D6DB75E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:35:56] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Client exited)
[10:42:45] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Quit: Leaving)
[10:44:13] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[10:45:58] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[10:46:07] <busylizzy> guys, i don't understand. syntax extensions in rust must be built into the compiler, but in limited form may be defined with macros, right?
[10:46:17] *** Quits: berak (chatzilla@AFDA5932.4742BCFA.1A5CC7E5.IP) (Quit: .. too much fighting on the dancefloor ..)
[10:46:53] *** Joins: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp)
[10:48:13] <kimundi> busylizzy, right
[10:48:34] <busylizzy> okay
[10:48:55] <kimundi> busylizzy: though you will be able to write syntax extensions that work like buildins sometime in the future
[10:49:35] <busylizzy> they will make macros like in nemerle? :)
[10:50:20] <Boreeas> How do I compare enums if not with ==? If I try, I get "error: binary operation == cannot be applied to type `lexer::Token`"
[10:51:13] <dbaupp> Boreeas: you can't use == unless the type has an Eq impl
[10:51:29] <kimundi> Boreeas: Per default you can only compare enum variants with pattern matching. You need a #[dervivnng(Eq)] on the enum to use ==
[10:51:33] <dbaupp> is that the built-in Token?
[10:51:53] <kimundi> rusti: enum Foo { A, B}; A == B
[10:51:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LLDb
[10:52:02] <dbaupp> (if it's one you defined, you can add #[deriving(Eq)] to get an automatic instance)
[10:52:20] <kimundi> rusti: #[deriving(Eq)]enum Foo { A, B}; A == B
[10:52:21] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/hKHP
[10:52:44] <kimundi> hum...
[10:53:03] <dbaupp> kimundi: possibly something about being inside a function
[10:53:09] <kimundi> rusti: #[deriving(Clone)] enum Foo { A, B}; A.clone()
[10:53:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/iCXf
[10:54:15] <dbaupp> rusti: mod Mod { #[deriving(Eq)] pub enum Foo {A, B} }; (Mod::A == Mod::A, Mod::A == Mod::B)
[10:54:16] -rusti- (true, false)
[10:54:36] *** Joins: victorporof_ (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[10:54:50] <busylizzy> but how can i implement Eq for third party enum?
[10:55:05] <kimundi> busylizzy: YOu can't
[10:55:08] <dbaupp> busylizzy: you can't
[10:55:14] <kimundi> only way would be to newtype it
[10:55:14] <busylizzy> o_O
[10:55:26] <EXetoC> busylizzy: yoU CAN't
[10:55:37] <kimundi> xD
[10:55:46] <busylizzy> it's strangely
[10:55:47] <dbaupp> you can only make an implementation for a trait when either (or both) the type or the trait is defined in the current trait
[10:55:56] <dbaupp> err, current crate
[10:56:04] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[10:57:08] <busylizzy> and so in haskell too?
[10:57:36] <kimundi> Haskell doesn't have that restriction, wich regulary leads to problem there
[10:57:42] <dbaupp> no, you can implement traits whereever
[10:57:50] <dbaupp> kimundi: which problems?
[10:58:15] <dbaupp> (it ends up requiring the open world assumption, but that's not exactly a problem (?))
[10:58:23] <kimundi> because A can define a type, B can define a typeclass, and a unrelated C can implement the typclasee from B on A
[10:58:43] <dbaupp> that's not a problem, is it?
[10:58:50] <busylizzy> if write realisation of msgpack and want to implement trait MsgPackable for some common types, i can't to do this?
[10:59:02] <busylizzy> if i write*
[10:59:05] <kimundi> Well, you never now if mixing two libaries will lead to failure becuase of duplicted implementations
[10:59:24] <dbaupp> busylizzy: no it's fine, if you define the MsgPackable trait
[11:00:16] <dbaupp> kimundi: oh, I guess that's possible.
[11:00:45] <strcat> busylizzy: you can implement a trait for a type if either the type or trait is in the current crate
[11:00:50] <busylizzy> but user of my library can't to implement MsgPackable for some datastructure from third part library?
[11:01:02] <busylizzy> it's bad :(
[11:01:07] <kimundi> busylizzy: If you define the trait, you can implement it on any type, even those from other crates. If you define the type, you can implement any trait for it, even those from other crates.
[11:01:08] <dbaupp> that is correct
[11:01:30] <strcat> busylizzy: they can, by making a new type containing the one from the third party library
[11:01:34] <kimundi> busylizzy: YOu can always work around it with newtypes
[11:02:20] <strcat> busylizzy: as long as all the data you need to serialize is exposed in public methods/fields
[11:02:25] <lucian> is newtype struct Foo {Bar}; now?
[11:02:52] <dbaupp> lucian: no, `struct Foo(Bar)`
[11:03:13] <busylizzy> hm. not sure if it's comfortably.
[11:03:50] <Boreeas> dbaupp, kimundi, thanks! So Rust enums are similar to Java enums, in so far as I can define arbitrary methods for them?
[11:03:56] <kimundi> Well, it's the only way to preven random failure at linktime
[11:04:01] <dbaupp> Boreeas: yes
[11:04:22] <kimundi> Boreeas: Just the enum type as a whole though, not each variant
[11:06:46] <Boreeas> Ah, alright. And no, dbaupp, not the built-in token (I didn't even know that existed).
[11:07:29] <lucian> dbaupp: ah, right
[11:09:03] <busylizzy> rust needs some mechanism to switch between implementations of same trait for same type :D for example, implementations can be module-local and invisible outside of module if author of module doesn't export it (somehow).
[11:10:07] <cmr> impl's cannot be private anymore.
[11:11:17] <lucian> busylizzy: that could remove much of the need for newtype, maybe
[11:11:24] <lucian> i don't know if it would be a good idea
[11:12:21] *** Joins: catpig (catpig@moz-7ECD724E.dip0.t-ipconnect.de)
[11:14:19] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[11:14:29] *** kimundi is now known as zz_kimundi
[11:14:34] *** Quits: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net) (Connection reset by peer)
[11:14:55] *** Joins: tedh (tedh@moz-F0B37C08.hsd1.il.comcast.net)
[11:15:58] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[11:17:27] <busylizzy> http://pastebin.com/wVQRCKcS !!
[11:19:42] <busylizzy> i don't know, but if nemerle has compile-time "if's" with conditions on types ("same type", "dirived" and so on) then these macros are as powerful as c++ templates but without awful brainfuckable syntax.
[11:20:35] *** Quits: catpig (catpig@moz-7ECD724E.dip0.t-ipconnect.de) (Quit: Verlassend)
[11:20:44] <busylizzy> i'm dreaming of such macros since 5 years
[11:21:36] *** Joins: mindginative (mindginati@moz-618C7234.dsl.dyn.ihug.co.nz)
[11:21:42] *** Quits: mindginative (mindginati@moz-618C7234.dsl.dyn.ihug.co.nz) (Quit: brb)
[11:22:18] <bjz> h3r3tic: pingy ping ding dong
[11:23:42] *** Joins: HOLYCOWBATMAN (Mibbit@moz-AB722A1C.mc.videotron.ca)
[11:26:53] *** zz_kimundi is now known as kimundi
[11:28:59] <bjz> HOLYCOWBATMAN
[11:29:07] *** Quits: sdh_ (sdh@C957F273.8BDB8EF1.A76F6622.IP) (Quit: Konversation terminated!)
[11:29:16] <kimundi> busylizzy: The problem is, even if it where module private it could still cause conflicts in that module.
[11:29:49] <busylizzy> kimundi: it's problem of author of module
[11:30:05] <busylizzy> like duplicated definitions of function MyFunc
[11:30:30] <busylizzy> or not?
[11:30:34] <bjz> EXetoC: ping
[11:32:27] <strcat> busylizzy: no, trait impls don't have scopes
[11:32:31] <strcat> traits have scopes
[11:32:50] <strcat> if you impl a trait, anyone who can see the trait or the type can see the impl
[11:32:55] <busylizzy> strcat: but could!
[11:33:09] <strcat> busylizzy: how?
[11:33:18] <strcat> busylizzy: module A implements the trait, module B implements the trait
[11:33:20] <strcat> for the same type
[11:33:20] <dbaupp> strcat: *or* the type? (aren't both required?)
[11:33:22] <strcat> which do you use?
[11:33:28] <strcat> dbaupp: no, only either
[11:33:35] <strcat> dbaupp: you can impl Clone on your own type or impl YourTrait on int
[11:33:50] <strcat> dbaupp: oh I see what you mean - yes
[11:33:53] <strcat> ;p
[11:33:56] <dbaupp> strcat: but then why do we have to import *Util
[11:34:01] <dbaupp> oh, cool :)
[11:34:08] <strcat> dbaupp: you can use a type without having it in scope though
[11:34:16] <strcat> trait has to actually be in the current scope to see the methods
[11:34:20] <busylizzy> strcat: i don't know :D
[11:35:07] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:35:13] <busylizzy> strcat: if i don't exports these impl's then i don't use any of them
[11:36:06] *** Joins: bheylin (bheylin@moz-3D24C757.static.chello.nl)
[11:36:26] <busylizzy> if i export impl's from both A and B then i do wrong
[11:36:39] <bjz> how does this look? https://gist.github.com/bjz/eab047c4494a1e029aab
[11:36:45] <bjz> bheylin: ^
[11:37:01] <bjz> bheylin: I'm preparing for nmatsakis's function pointer fix
[11:37:09] <EXetoC> bjz: bong
[11:37:22] <bjz> EXetoC: thoughts? ^
[11:37:33] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[11:37:38] <bjz> trying to do documentation
[11:37:46] <bheylin> bjz: nice, dynamic loading!
[11:37:54] <bjz> well soon
[11:37:59] <bheylin> bjz: looking damn fine if i may say so
[11:38:08] <bjz> apparently there is a branch out there
[11:38:14] <bjz> in the digital ether
[11:38:17] <dbaupp> bjz: how did you get .is_loaded to work on functions? (or is that just illustrative?)
[11:38:38] <busylizzy> and by default implementation exports only from module in which type or trait is defined. from third part module user must export implementation manualy.
[11:39:49] <busylizzy> user must import*
[11:39:50] <EXetoC> neat
[11:39:53] <bjz> dbaupp: there is a struct for each feild in the function loader, first field is `f`, which holds the function pointer, second is `is_loaded`, a boolean flag
[11:40:42] <bjz> dbaupp: the actual functions you call are actually inlined wrapper methods
[11:40:53] <busylizzy> explicit imports and local impl's overrides automaticaly imported impl's in module
[11:41:14] <bjz> dbaupp: eg: #[inline(always)] unsafe fn CullFace(&self, mode: GLenum)  { (self.CullFace.f)(mode) }
[11:41:20] <busylizzy> something like that :)
[11:41:49] <bjz> dbaupp: I think I should probably document that stuff
[11:42:49] <bjz> dbaupp: hopefully it doesn't cause overhead. it might though.
[11:43:24] <bheylin> bjz: would be great to make an article or such
[11:43:46] <dbaupp> bjz: ah, so gl has methods and properties with the same name... neat :)
[11:44:07] <bjz> dbaupp: no, this is just the loader
[11:45:07] *** Quits: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com) (Ping timeout)
[11:45:21] <dbaupp> bjz: um... I meant the "gl" object that you do `gl.Viewport.is_loaded` and `gl.Viewport(0, 0, 600, 480);` with?
[11:45:34] <bjz> dbaupp: correct
[11:45:48] <dbaupp> so that has a Viewport property and a Viewport method?
[11:46:14] <bjz> dbaupp: a Viewport field and a Viewport method
[11:46:47] <EXetoC> a little overhead shouldn't be a big deal if the data is batched properly
[11:46:48] <dbaupp> ah, yes, using the right word makes me make more sense ;P
[11:46:57] *** Joins: Excureo (c@moz-DE8C33F1.static.yakm.wa.charter.com)
[11:47:37] <bjz> dbaupp: GL { Viewport: Viewport { f: <fn pointer>, is_loaded: <bool> } }
[11:48:38] <bjz> obviously the are a thousand more fields in the GL struct
[11:49:14] <bjz> I dunno if it should be initialised as an owned pointer
[11:49:20] <bjz> let gl = ~gl::load_with(glfw::get_proc_address);
[11:49:27] <bjz> as opposed to: let gl = gl::load_with(glfw::get_proc_address);
[11:49:36] <bjz> (on the stack)
[11:49:54] <dbaupp> entirely auto-generated, right?
[11:50:02] <bjz> dbaupp: yep
[11:50:22] <EXetoC> so most loaders take a single argument? I guess
[11:50:27] <bjz> dbaupp: it's lua at the moment, but I'd like to move to rust in the future
[11:51:21] <bjz> EXetoC: if not, its a closure, so you can do: let gl = do gl::load_with |&s| { ...}
[11:51:31] <EXetoC> yeah
[11:51:55] <EXetoC> making it owned is only going to add a little initialization overhead, so that seems like a good approach
[11:52:03] *** Joins: vosen (vosen@moz-266BA656.icpnet.pl)
[11:52:21] <bjz> EXetoC: rust-sdl doesn't have a get_proc_address function wrapped yet, so I can't speak for it
[11:53:28] <EXetoC> bjz: I was referring to the GL struct
[11:53:43] <bjz> yep, got that
[11:54:44] <bjz> so yeah basically I just want to get the generated API done nicely, then it can possibly make a rust generator
[11:55:03] <bjz> *I can
[11:55:24] <bjz> ie: a generator written in Rust, for Rust
[12:12:09] *** Quits: HOLYCOWBATMAN (Mibbit@moz-AB722A1C.mc.videotron.ca) (Quit: http://www.mibbit.com ajax IRC Client)
[12:14:50] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[12:17:31] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[12:19:27] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[12:19:41] *** Joins: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP)
[12:24:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:24:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/fC49Gw
[12:24:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:24:22] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[12:24:22] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/s9z0Ew
[12:24:22] <ghrust> 13rust/06auto 14305331c 15Brian Anderson: core: Document some intrinsics
[12:24:22] <ghrust> 13rust/06auto 14dbbc244 15bors: auto merge of #6534 : brson/rust/intrinsic-docs, r=bstrie
[12:24:22] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[12:32:11] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[12:35:40] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Ping timeout)
[12:35:41] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[12:35:50] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.0)
[12:51:42] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[12:54:19] *** Joins: FrozenCow_ (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[12:54:20] *** Quits: FrozenCow_ (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[12:55:42] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[12:58:20] *** Quits: Blub\w (wry@moz-3B49E725.wireless.dyn.drei.com) (Quit: bbl)
[12:58:35] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[12:59:05] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[13:02:55] *** Joins: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP)
[13:04:27] *** Joins: thatfreakingguy (Mibbit@moz-3075E850.pool.mediaways.net)
[13:04:29] *** Quits: thatfreakingguy (Mibbit@moz-3075E850.pool.mediaways.net) (Quit: thatfreakingguy)
[13:04:38] *** Joins: thatfreakingguy (Mibbit@moz-3075E850.pool.mediaways.net)
[13:05:27] *** Quits: cdidd (cdidd@moz-BFE6072C.broadband.corbina.ru) (Ping timeout)
[13:12:26] *** Quits: EXetoC (ex@moz-C741B177.customer.t3.se) (Ping timeout)
[13:15:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:15:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/s9z0Ew
[13:15:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:16:50] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[13:18:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:18:13] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/8gRLVg
[13:18:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:18:17] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:18:17] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/qVSJiw
[13:18:17] <ghrust> 13rust/06auto 14c8b1ece 15Graydon Hoare: rustc: change 'use' to 'add' in error message, fix #2994
[13:18:17] <ghrust> 13rust/06auto 14283510a 15bors: auto merge of #6340 : graydon/rust/issue-2994, r=thestinger
[13:18:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:18:38] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[13:20:19] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:20:27] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Connection reset by peer)
[13:20:30] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[13:22:25] *** Joins: EXetoC (ex@moz-2DBEB1E4.customer.t3.se)
[13:22:39] *** Joins: GeneralMaximus (ankur@B9E85031.8ABA9E53.6E73A72E.IP)
[13:32:09] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[13:32:59] *** victorporof_ is now known as victorporof
[13:43:16] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[13:43:39] *** Joins: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com)
[13:48:17] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:48:17] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14283510a to 14dbbc244: 02http://git.io/N3iJvQ
[13:48:17] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:48:18] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[13:48:18] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/8F4OwA
[13:48:18] <ghrust> 13rust/06auto 148c5de02 15Steven Stewart-Gallus: Fixed type signature of uninhabited method....
[13:48:18] <ghrust> 13rust/06auto 14290a2eb 15bors: auto merge of #6442 : sstewartgallus/rust/incoming, r=pcwalton...
[13:48:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[13:54:21] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: Leaving)
[13:55:45] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:56:26] *** Joins: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP)
[13:56:33] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Input/output error)
[13:59:02] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[14:00:14] *** Joins: berak (chatzilla@5327474A.8B38C502.16E13E53.IP)
[14:00:16] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[14:02:45] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[14:03:05] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[14:03:30] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[14:03:44] *** Quits: GeneralMaximus (ankur@B9E85031.8ABA9E53.6E73A72E.IP) (Quit: Textual IRC Client: www.textualapp.com)
[14:17:20] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[14:18:35] *** Joins: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP)
[14:19:13] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[14:23:34] *** Quits: thatfreakingguy (Mibbit@moz-3075E850.pool.mediaways.net) (Quit: http://www.mibbit.com ajax IRC Client)
[14:25:53] *** Joins: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com)
[14:31:40] <cmr> Terminals are insane
[14:32:21] <cmr> I've always wanted to write a sane terminal, but I never realized they were this bad
[14:32:46] *** Joins: synapsos (Mibbit@640C6C8D.C434660A.DAB1EB3B.IP)
[14:33:01] <cmr> ssbr_: eevee: you probably have more experience with this than me. as an application author, what would your ideal terminal be?
[14:33:27] *** Joins: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP)
[14:33:44] <cmr> first thing I want to do is abolish escape codes for the majority of things and use dynamic libraries to control the terminal
[14:39:21] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:39:21] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/8F4OwA
[14:39:21] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:40:19] *** Quits: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP) (Ping timeout)
[14:41:58] *** Joins: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP)
[14:41:58] *** Quits: rgrinberg (rgrinberg@AE999E95.52DE4C60.258AD6F5.IP) (Quit: rgrinberg)
[14:42:08] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:42:08] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/KY1Izg
[14:42:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:42:10] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[14:42:10] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/KzyRKw
[14:42:10] <ghrust> 13rust/06auto 148327900 15Tim Chevalier: testsuite: Add passing test for #4107
[14:42:10] <ghrust> 13rust/06auto 143f2bdb8 15bors: auto merge of #6483 : catamorphism/rust/issue-4107, r=catamorphism
[14:42:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[14:42:51] *** Joins: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com)
[14:44:00] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[14:44:30] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[14:47:47] *** Quits: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP) (Connection reset by peer)
[14:47:58] *** Joins: ssbr (scorchsabe@A9D9D38C.B6F034AC.72A31D6.IP)
[14:48:49] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Client exited)
[14:49:19] *** Joins: int3_ (int3_@moz-DC8217D4.singnet.com.sg)
[14:49:34] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[14:49:36] <Sodel_the_V> YIKES. Building rustc with `RUST_LOG=rustc::middle:typeck` seems like it has a memory leak or something. The compiler's memory usage will happily fill up ALL of my RAM.
[14:49:39] <Sodel_the_V> ALL 8GB.
[14:50:08] *** Quits: sp3d (a@moz-17CB39F1.fidnet.com) (Ping timeout)
[14:50:43] <dbaupp> Sodel_the_V: I found that too :(
[14:52:46] <Sodel_the_V> I'm going to check if a bug's been filed
[14:53:46] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[14:54:16] <Sodel_the_V> dbaupp: Are you on x86, or x86_64?
[14:54:25] <dbaupp> x64
[14:54:31] <Sodel_the_V> Same.
[14:55:37] <Sodel_the_V> I know nmatsakis built rustc with that RUST_LOG setting. I don't know what platform he's on, so it's possible that this bug is x64-exclusive.
[14:56:16] <dbaupp> I'll just try it on x86 now
[14:57:18] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Quit: Leaving)
[14:58:22] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[15:02:18] <Sodel_the_V> Bug filed. https://github.com/mozilla/rust/issues/6558
[15:02:27] <dbaupp> Sodel_the_V: it quite happily ate 1.8GB of RAM building core on x86 with that RUST_LOG
[15:02:29] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:03:06] *** Quits: novabyte (Instantbir@moz-135D0E61.mullvad.net) (Quit: bye bye)
[15:03:29] <Sodel_the_V> dbaupp: Thanks for checking.
[15:04:02] <dbaupp> put a note on the bug :)
[15:04:09] <dbaupp> *I put ...
[15:04:41] <Sodel_the_V> I see that, thank you! :)
[15:05:23] *** Joins: fabiand (fabiand@moz-A08343BC.adsl.alicedsl.de)
[15:06:44] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[15:08:25] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[15:09:34] *** Quits: fabiand (fabiand@moz-A08343BC.adsl.alicedsl.de) (Quit: Verlassend)
[15:09:40] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[15:10:23] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[15:15:08] *** Joins: snowmantw (snowmantw@moz-22F9C99D.dynamic.hinet.net)
[15:15:08] *** Quits: snowmantw (snowmantw@moz-22F9C99D.dynamic.hinet.net) (Quit: snowmantw)
[15:15:20] *** Joins: snowmantw (snowmantw@moz-22F9C99D.dynamic.hinet.net)
[15:15:25] *** Quits: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP) (Ping timeout)
[15:15:31] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[15:16:10] *** Quits: ysuzuki (ysuzuki@moz-A563888C.ics.keio.ac.jp) (Client exited)
[15:16:43] *** Quits: pyrac (pyrac@F9CC429.73C89388.AD05C589.IP) (Ping timeout)
[15:16:56] *** Joins: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP)
[15:18:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:18:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 143f2bdb8 to 14290a2eb: 02http://git.io/N3iJvQ
[15:18:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:18:15] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[15:18:15] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/Z5KJ1w
[15:18:15] <ghrust> 13rust/06auto 14589d2c7 15Olivier Saut: Correct the example given for a future, add punctuation where necessary
[15:18:15] <ghrust> 13rust/06auto 140895f72 15Olivier Saut: Add a small section on futures to the tutorial, remove use task::spawn as it is now included by default in prelude.rs
[15:18:17] <ghrust> 13rust/06auto 1493b4a57 15Olivier Saut: Fix typo
[15:18:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[15:22:59] *** Quits: sk_ (sk@253351EF.84AD35F3.1FCE22BB.IP) (Ping timeout)
[15:29:15] *** Joins: novabyte (Instantbir@moz-135D0E61.mullvad.net)
[15:29:33] *** Parts: berak (chatzilla@5327474A.8B38C502.16E13E53.IP) ()
[15:34:11] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[15:36:10] *** Quits: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se) (Ping timeout)
[15:36:29] *** Joins: BitPuffin (quassel@moz-8370D1B9.bredband.comhem.se)
[15:37:23] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[15:38:20] *** Joins: sk_ (sk@5936D79C.C8AF14A1.33B96495.IP)
[15:42:08] *** Quits: jdm (jdm@DB05BBF2.BB1F48F2.971E19F6.IP) (Ping timeout)
[15:43:50] *** Joins: eholk (eholk@moz-A365E2F9.uconnect.utah.edu)
[15:43:55] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Ping timeout)
[15:44:08] <nmatsakis> Sodel_the_V: I've...never seen that.
[15:44:37] <nmatsakis> Sodel_the_V: however, running with that setting does dump an *enormous* amount of output
[15:45:00] <nmatsakis> Sodel_the_V: I usually redirect it to a file *and* either filter with grep for the messages I care about, or try for a small file 
[15:45:23] <nmatsakis> Sodel_the_V: (or else restrict to a more narrow module, if possible)
[15:45:47] <nmatsakis> Sodel_the_V: I'd like to revamp the compiler logging so that you can specify the *source module* you care about and only get logs pertaining to that source module, but ...
[15:46:06] <ssbr_> cmr: TBH, it's actually not something that ever bothers me, because the ugliness is so well wrapped up.
[15:46:18] <ssbr_> cmr: all I would ask is that it works 100% on Windows, without any caveats.
[15:46:27] <ssbr_> (and also can run cmd.exe inside it)
[15:46:32] <ssbr_> (for bonus points, at least.)
[15:46:55] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Quit: victorporof)
[15:48:55] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[15:49:53] <Sodel_the_V> nmatsakis: Weird. I did try dumping to a file, to the terminal, and even to /dev/null (not that I expected any real difference), and the result was the same.
[15:51:31] <nmatsakis> Sodel_the_V: weird indeed!
[15:51:58] <nmatsakis> Sodel_the_V: any progress looking into your code? I could look some more now if you like, not sure if you've made any updates
[15:52:58] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[15:53:21] <dbaupp> nmatsakis: https://github.com/mozilla/rust/pull/6561 r?
[15:53:47] <Sodel_the_V> nmatsakis: All I've done so far is remove a superfluous match expression from meth::trans_trait_callee(); I'm now deciding what is and isn't still needed in meth::trans_trait_callee_from_llval()
[15:54:20] <nmatsakis> dbaupp: r+, thanks
[15:54:26] <nmatsakis> dbaupp: that's been driving me bonkers :)
[15:54:28] *** Parts: bheylin (bheylin@moz-3D24C757.static.chello.nl) ()
[15:57:43] <Sodel_the_V> nmatsakis: Well the two problems so far, as you said, are 1) the adjustment code not being called, and 2) updating meth.rs. I of course appreciate any help, but if you have other stuff to do we might as well wait until I've made a bit more progress on my end.
[15:58:29] <nmatsakis> Sodel_the_V: I'm going to dig a little bit into problem (1)
[15:58:56] <Sodel_the_V> nmatsakis: Alright, and I'm already looking into (2)
[15:59:56] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[16:00:25] *** Quits: eholk (eholk@moz-A365E2F9.uconnect.utah.edu) (Quit: eholk)
[16:01:20] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[16:02:15] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[16:02:23] <bstrie> meth.rs. not even once.
[16:02:58] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[16:02:58] <bstrie> or is that heroin.rs...
[16:03:37] <Sodel_the_V> Or perhaps lovecraft.rs
[16:03:44] <otters> otte.rs
[16:03:50] <otters> is my website :o)
[16:05:01] *** Joins: eholk (eholk@moz-A365E2F9.uconnect.utah.edu)
[16:06:33] * Sodel_the_V must be tired, and only got bstrie's joke just now
[16:06:47] <Sodel_the_V> otters: That's excellent on multiple levels.
[16:08:17] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[16:08:21] <nmatsakis> Sodel_the_V: so, I see the problem in typeck---I'm going to cobble together a kind of hokey fix now, I think the right fix is going to be better done as a separate patch
[16:09:01] <Sodel_the_V> nmatsakis: Great!
[16:10:27] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[16:11:25] <steven_is_false> Can someone confirm some vector math with me? In 2D for colliding a point with a line I have one tangent A ---> B, and I use that to calculate friction. In 3D I have a triangle with 3 tangents A --> B, B --> C, and C --> A. I understand that if I had two orthogonal tangents I could easily find the friction but the same procedure would work for any tangents as long as they weren't exactly equal.
[16:11:53] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[16:12:12] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:12:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 148f28394 to 14290a2eb: 02http://git.io/N3iJvQ
[16:12:12] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:12:17] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[16:12:17] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/v1Np-g
[16:12:17] <ghrust> 13rust/06auto 14aa179cb 15Huon Wilson: rustc: relax limits on (u)int type limit lint. Fixes #6130.
[16:12:17] <ghrust> 13rust/06auto 14ff08198 15bors: auto merge of #6561 : huonw/rust/rustc-u-int-limit-lint, r=nikomatsakis
[16:12:18] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[16:13:23] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[16:13:43] *** Quits: Ralith (ralith@moz-50F3C77.vc.shawcable.net) (Ping timeout)
[16:13:46] <kimundi> someone interested in giving me an introduction in how the syntax extensions in libsyntax work? Want to improve bytes!() a bit but I don't understand how the system works in general. :)
[16:15:28] <bjz> nmatsakis: if you get a chance, would you be able to test this code on your function pointer branch? https://gist.github.com/bjz/69d47eb02d42698b2ea3
[16:16:29] <dbaupp> kimundi: do you have a more focused question? but, basically, they create an ast which gets spliced back into the ast that is created by the parser
[16:16:46] *** Joins: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr)
[16:17:39] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[16:17:47] <bjz> nmatsakis: if you're wondering, here's my draft README: https://gist.github.com/bjz/eab047c4494a1e029aab
[16:17:53] <dbaupp> kimundi: so the bytes gets feed the argument(s) given by bytes!(...) as a token tree, and then it can do whatever it wants to this tree
[16:18:40] <dbaupp> kimundi: currently, bytes! just requires & enforces that the first and only argument is a literal string
[16:19:05] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[16:19:43] <kimundi> dbaupp: Right, I want to extend it to take an arbitrary number of &str, char or u8 arguments and concattenate them all
[16:19:56] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:21:17] *** Joins: Jeaye (Jeaye@moz-FD505E54.hsd1.ca.comcast.net)
[16:22:11] <dbaupp> kimundi: the `get_exprs_from_tts` function might be helpful
[16:22:17] <nmatsakis> bjz: ok, I can also push it somewhere for you to try if you want
[16:24:03] *** Joins: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP)
[16:24:45] <dbaupp> kimundi: I imagine it'll be a little tricky though, since you'll have to manage extracting literals and so on from the ast::expr
[16:25:12] <kimundi> dbaupp: yeah, that's what I just wanted to ask :)
[16:25:34] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Ping timeout)
[16:25:57] <kimundi> basically, I don't know what's possible, what not, what's possible but hard, and where to find it... ;)
[16:27:49] <Luqman> kimundi: i usually look at the other syntax extensions and try to find something similar enough to what I want and go from there
[16:28:14] <dbaupp> kimundi: well, of the top of my head `match expr.node { ast::expr_lit(lit) => { ... }, _ => cx.span_err(sp, "Non-literal in bytes!") }`
[16:28:21] <kimundi> hm, good idea. Onward to fmt! :P
[16:28:25] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[16:28:28] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[16:29:00] <dbaupp> kimundi: and then `lit` is a @ast::lit, and `lit.node` is ast::lit_
[16:29:49] <dbaupp> kimundi: so matching on that gives you lit_str(str), lit_uint(val, ast::ty_u8), and lit_int(val, ast::ty_char)
[16:31:16] <Luqman> kimundi: dbaupp: let p = parse::new_parser_from_tts(cx.parse_sess(), cx.cfg(), vec::to_owned(tts)); let foo = p.parse_str(); OR let foo = expr_to_str(cx, p.parse_expr(), "argument must be str literal");
[16:31:53] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Quit: Computer has gone to sleep.)
[16:32:53] <dbaupp> Luqman: I think get_exprs_from_tts in ext/base.rs is more appropriate for this
[16:33:40] <pyrac> hi all. Is there a make target to only test the tutorials ?
[16:34:05] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[16:34:09] <Luqman> dbaupp: i guess, though it essentially just wraps the above + a loop
[16:34:12] <kimundi> pyrac: I think yes. Look in the wiki on github
[16:34:40] <dbaupp> Luqman: yup
[16:35:11] <pyrac> kimundi: Thanks. I just learnt the hard way that the codes in tutorial are tested (which is a very good thing !)
[16:35:18] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[16:35:23] <kimundi> yes, indeed :)
[16:37:26] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[16:40:59] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[16:44:20] *** Quits: acrichto (acrichto@moz-FE112B96.res.cmu.edu) (Quit: leaving)
[16:44:33] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Quit: Leaving)
[16:46:31] *** Joins: graydon (Adium@A5087023.2354C43D.D8E68FF6.IP)
[16:46:31] *** ChanServ sets mode: +qo graydon graydon
[16:47:03] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[16:47:40] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[16:49:45] <pyrac> I think I have made a mistake while correcting my PR https://github.com/mozilla/rust/pull/6537 . Should I resubmit a new one?
[16:50:51] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[16:51:44] <kimundi> dbaupp: so a '5u8' is 'lit_uint(5, ast::ty_u8)', and a '5' 'lit_int_unsuffixed(5)' ?
[16:51:55] <dbaupp> kimundi: yes
[16:52:44] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[16:53:38] <Sodel_the_V> nmatsakis: I pushed a few commits to github. I recently rebased onto incoming again. I hope that doesn't screw you up. :/
[16:53:43] <kimundi> dbaupp: okay. So if I want to support unsuffixid uint literals I have to handle both? I guess yes, they're just tokens at that point...
[16:53:56] <dbaupp> kimundi: correct
[16:54:30] <nmatsakis> Sodel_the_V: I'll cope.
[16:55:02] <dbaupp> kimundi: (and if you want to handle i8's too, that'll be lit_int(5, ast::ty_i8).)
[16:55:49] <kimundi> dbaupp: Them being ty-i8 doesn't mean they are of the correct size, right?
[16:56:22] <dbaupp> kimundi: umm, I guess so
[16:56:32] <dbaupp> not sure
[16:57:01] *** Joins: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com)
[16:58:30] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Client exited)
[16:58:51] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[17:00:29] *** Quits: inolen (Adium@moz-FA2406D8.socal.res.rr.com) (Quit: Leaving.)
[17:00:34] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Ping timeout)
[17:00:36] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[17:02:09] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[17:03:48] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:06:28] *** Quits: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net) (Ping timeout)
[17:07:42] <cmr> ssbr_: alright, thanks
[17:09:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[17:09:09] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/v1Np-g
[17:09:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[17:09:28] *** Joins: tad_ (Tom@moz-2036EE54.kimsufi.com)
[17:09:29] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[17:09:30] *** Joins: iopluy (iopluy@moz-F90237FA.adsl.highway.telekom.at)
[17:09:49] *** Quits: tad_ (Tom@moz-2036EE54.kimsufi.com) (Input/output error)
[17:10:11] *** Quits: iopluy (iopluy@moz-F90237FA.adsl.highway.telekom.at) (Quit: iopluy)
[17:10:19] *** Joins: iopluy (iopluy@moz-F90237FA.adsl.highway.telekom.at)
[17:11:59] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[17:14:36] *** Joins: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net)
[17:15:43] *** Joins: steven_is_false (quassel@1E3F14AE.29819A33.115CE8E4.IP)
[17:16:09] <steven_is_false> Hi I'm having trouble with a mutable vector. How can I iterate over it and mutate it's contents?
[17:16:25] <cmr> steven_is_false: mutate the items, or mutate the vector itself?
[17:16:35] <steven_is_false> cmr: Only mutate the items.
[17:17:41] <steven_is_false> As a side note, there doesn't seem to be documentation for the methods on vectors. core::vec for example doesn't have each in it.
[17:18:04] *** Joins: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP)
[17:18:18] <cmr> steven_is_false: you want each_mut
[17:18:47] <steven_is_false> cmr: Thanks. Why does there need to be an each_mut, and  an each method?
[17:19:07] <cmr> steven_is_false: each_mut passes the closure a &mut, each doesn't.
[17:19:13] <cmr> it's a safety thing, as usual
[17:19:24] <graydon> to what extent do default methods work presently?
[17:19:37] <steven_is_false> cmr: Maybe there should be some kind of polymorphism over pointer types, or mutablility?
[17:19:49] <cmr> graydon: supposedly they don't work at all, at least according to bjz last night
[17:19:56] <graydon> grr
[17:20:02] <steven_is_false> eg) fn <Mutability> foo (x : &Mutability);
[17:20:18] <graydon> bjz: can you elaborate any?
[17:20:19] <bjz> cmr: I'm not sure to the extent
[17:20:35] <bjz> graydon: no :(
[17:20:54] <bjz> graydon: tbh I haven't bothered trying recently
[17:20:57] *** Joins: thatfreakingguy (Mibbit@moz-E09ED084.pool.mediaways.net)
[17:20:58] <graydon> bjz: like .. what was the failure mode? failure-to-compile, failure-to-run?
[17:20:59] <graydon> ok
[17:21:27] <bjz> graydon: I wonder if anyone has actually tried recently
[17:21:33] <graydon> I am trying presently
[17:21:40] <bjz> graydon: awesome!
[17:21:40] <graydon> because .. visitor has to go
[17:21:49] <bjz> visitor?
[17:21:51] <graydon> (fold also, though visitor is easier to check with)
[17:21:58] <graydon> visitor and fold are our two AST-walkers
[17:22:07] <graydon> fold rebuilds the AST. visitor just visits each node.
[17:22:15] *** Quits: zxcdw (r-a@moz-C7C5467B.cust.bredband2.com) (Ping timeout)
[17:22:16] <graydon> both are giant collections of @fns
[17:22:29] * bjz imagine an AT-AT striding across Hoth
[17:22:30] <graydon> from way before we had objects or traits or anything
[17:22:31] <nmatsakis> graydon: oh man I'd love to rewrite those with default fns
[17:22:45] <nmatsakis> graydon: I asked pnkfelix to give it a try, don't think he got too far though.
[17:22:52] <graydon> I would love it more than you presently, I think: the @fns generated are hammering the gc heap
[17:23:11] <nmatsakis> I can imagine.
[17:23:22] <nmatsakis> graydon: I... partially rewrote fold to use a boxed trait, at least
[17:23:32] <nmatsakis> graydon: not sure how much effort it'd be to rip out the @fn's altogether, maybe not much.
[17:23:35] <graydon> well, hm. maybe I can just recycle this visitor.
[17:23:35] <nmatsakis> still not ideal.
[17:23:42] <bjz> graydon: yeah the core::num folks are super excited about default methods
[17:23:46] <nmatsakis> but that wouldn't get you all that far, I think. we use visitor a lot more.
[17:25:54] *** Joins: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net)
[17:29:49] <steven_is_false> Does anyone here know of a quick way to test if a port is blocked? I'm using internet at a coffee shop, and I think they blocked port 22 so I can't push commits to GitHub.
[17:30:10] <cmr> steven_is_false: nc host 22
[17:30:14] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:30:21] <steven_is_false> cmr: Thank you.
[17:30:40] *** Quits: infynyxx (infynyxx@moz-8BE8F2CD.hsd1.md.comcast.net) (Client exited)
[17:31:19] *** Joins: sp3d (a@moz-17CB39F1.fidnet.com)
[17:31:19] <steven_is_false> cmr: Is that a netcat traditional syntax only? I'm using netcat-openbsd, and your command doesn't seem to work
[17:31:30] <graydon> hm. no. they really don't work.
[17:31:35] <graydon> self-calls in them don't, anyway.
[17:31:43] <graydon> which kinda .. yeah
[17:31:57] <cmr> steven_is_false: works here with netcat-openbsd
[17:32:09] *** Joins: calamity (calamity@moz-B84210E2.static.dsl.dodo.com.au)
[17:32:12] <graydon> nmatsakis: do you remember what the general suggestion is for "working around" absence of default methods?
[17:32:13] <steven_is_false> cmr: Did you mean localhost?
[17:32:13] <calamity> Hullo all
[17:32:24] <cmr> steven_is_false: any host, one with port 22 open
[17:32:40] <cmr> sorry for ambiguity
[17:32:54] <bjz> calamity: hullo again
[17:33:03] *** Quits: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP) (Quit: Bye!)
[17:33:08] <steven_is_false> Right so In my case I'd do nc git@github.com:sstewartgallus/rust-opengles.git 22
[17:33:09] *** Joins: bjz (brendanzab@B398BE78.F804C29E.D35A31DF.IP)
[17:33:12] <cmr> No
[17:33:19] <cmr> That is a URI, you just want hostname
[17:33:22] <cmr> github.com is fine
[17:33:24] <nmatsakis> graydon: well, the usual thing is to make a fn like this:
[17:33:35] <cmr> "nc github.com 22" here gives "
[17:33:37] <steven_is_false> cmr: Oh right.
[17:33:38] <cmr> SSH-2.0-OpenSSH_5.5p1 Debian-6+squeeze1+github12"
[17:33:43] <nmatsakis> graydon: fn super_method<This:MyTrait>(this: &This, ...)
[17:34:02] <nmatsakis> graydon: and then have the impl call: fn method(&self, ...) { super_method(self, ...) }
[17:34:07] <nmatsakis> graydon: see for example type
[17:34:09] <nmatsakis> oops
[17:34:22] <nmatsakis> graydon: see for example typeck/infer/combine.rs
[17:34:23] <graydon> hmm
[17:34:26] <steven_is_false> cmr: Right, I'm not getting any info from github. I think the coffee shop blocked port 22.
[17:34:29] <nmatsakis> graydon: which uses this pattern all over the place. 
[17:34:35] <nmatsakis> graydon: it's kind of a pain.
[17:34:36] <cmr> steven_is_false: very well might be
[17:34:44] <graydon> this is pretty .. terrible. I guess we've just been prioritizing other things :(
[17:35:02] <nmatsakis> graydon: yes, it's terrible, I was hoping to have pnkfelix take care of it
[17:35:06] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (Quit: Computer has gone to sleep.)
[17:35:07] <nmatsakis> graydon: I've been talking to him about it as his first big project
[17:35:15] <nmatsakis> graydon: but maybe we'll want it done sooner
[17:35:16] <graydon> sorry, I don't mean to be critical. I know how unpleasant hearing "this tool is terrible" is, as I wince every time someone says the same to me :(
[17:35:21] <steven_is_false> cmr: Thank you. These aren't very important commits anyways. I'm just .gitignoreing some files
[17:35:25] <graydon> it's a good tool. just missing an extra-useful corner :)
[17:35:29] <nmatsakis> graydon: I have some definitive thoughts about how it should be done (not how it's being done now)
[17:35:31] <nmatsakis> graydon: that I lan to write down
[17:35:34] <nmatsakis> *plan to write down
[17:35:38] <graydon> (and will go .. much faster when we can do that!)
[17:35:40] <nmatsakis> graydon: but I have a long queue of things I'm working on writing down :)
[17:35:51] <graydon> yeah, I know. I appreciate all the effort you put into it.
[17:35:54] <nmatsakis> graydon: well, it's #3 on the queue, and #1 and #2 are almost done
[17:36:04] <cmr> what are 1 and 2?
[17:36:26] <bstrie> default methods would be soooooo cool for 0.7
[17:36:33] <bstrie> been waiting years for them :)
[17:36:42] <nmatsakis> cmr: #1 is documenting borrow checker code
[17:36:49] <graydon> I'm terrible at it. your writing is extremely lucid and very much appreciated, a lot of what's happened so far would be a complete mystery / hodge-podge without the clarity of your writeups and docs.
[17:37:00] <nmatsakis> cmr: #2 is trying to specing out the trait system and matching algorithm
[17:37:02] <thiez> I agree with graydon 
[17:37:04] <thiez> he's terrible at it.
[17:37:08] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[17:37:16] <thiez> eh, I mean, your writing is enlightning, nmatsakis :p
[17:37:22] <nmatsakis> ;)
[17:37:33] <steven_is_false> Does anyone find it ironic that while Rust doesn't have pure anymore some people are working on making extern fn "GPU" work?
[17:37:40] <graydon> thiez: eep! I should make "write actually useful docs from time to time" on my 2013 goals
[17:37:57] <nmatsakis> graydon: well, thanks. I would like to get started on writing more "official complete" things in the manual. I figure I've been waiting until we know precisely what the system is, but I think that's becoming relatively clear
[17:38:00] <graydon> steven_is_false: no, one's an ABI and one's an effect. they're totally different.
[17:38:13] <graydon> nmatsakis: agreed
[17:39:13] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[17:39:22] <steven_is_false> graydon: I was mainly thinking about this Reddit thread http://www.reddit.com/r/rust/comments/1dfuik/a_great_explanation_from_graydon_on_why_rust_no/ .
[17:40:55] <steven_is_false> graydon: Any given ABI might have restrictions on it comparable to an effect system. 
[17:41:10] <steven_is_false> graydon: All though most ABIs wouldn't.
[17:41:41] <graydon> could, yeah. and if it did, it'd be (or require) an effect system.
[17:41:44] <nmatsakis> steven_is_false: it is an interesting phenomena that basically every body who wants to use the word "pure" means a slightly different thing by it
[17:41:52] <graydon> I guess I don't know what you're asking / pointing out the irony of
[17:41:58] <steven_is_false> nmatsakis: True enough.
[17:43:44] <steven_is_false> I guess it's not ironic but just a reasonable decision.
[17:43:58] <erickt> nmatsakis: I finally uploaded my notes (https://gist.github.com/anonymous/5600681) and my branches (https://github.com/erickt/rust/tree/trans-self15) and (https://github.com/erickt/rust/tree/trans-self16). It's all pretty rough
[17:44:12] <nmatsakis> graydon: interesting fact. As I am pushing through some of the method matching code, trying to help out Sodel_the_V with this Don-Quijote-esque refactoring I sent him on, I realize how much nicer dynamically sized types would make a lot of this code :)
[17:44:20] <nmatsakis> erickt: ok. Do you still plan to start over?
[17:44:21] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[17:44:24] <thatfreakingguy> Pattern matching can be used to copy non-Copyable types. Is that a known bug? I'm not good at searching the issue tracker.
[17:44:28] <graydon> "GPU" is much better defined as a problem. and it probably even needs to be tightened to "opencl" or something to be implementable (I imagine the subsets differ by GPU-interface)
[17:44:30] <steven_is_false> Hmm, so if instead of having pure fn one has extern fn "GPU" does that mean instead of having pure fn one might have extern fn "CONSTEXPR"
[17:44:31] *** Joins: inolen (Adium@moz-9F4F17DF.tourcaster.com)
[17:44:38] <nmatsakis> thatfreakingguy: there are some open bugs, do you mean as part of a `let` or a `match`?
[17:44:56] *** Quits: doener (bs@moz-AA189A5A.unitymedia.biz) (Quit: leaving)
[17:45:06] <steven_is_false> It would actually be useful to have something along the lines of extern fn "C MACRO".
[17:45:45] <steven_is_false> Though silly.
[17:45:53] *** Joins: pcwalton (pcwalton@43CB6079.66715431.D25A875A.IP)
[17:45:53] *** ChanServ sets mode: +o pcwalton
[17:46:38] <thatfreakingguy> nmatsakis: In a "let" statement and in function parameters
[17:46:48] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[17:46:59] <nmatsakis> thatfreakingguy: yeah, that's a known bug. 
[17:47:06] <thatfreakingguy> "fn p<T>(&x: &T)" works for non-copyable types for example
[17:47:08] <nmatsakis> thatfreakingguy: basically those patterns are kind of unchecked. have to fix that.
[17:47:14] <thatfreakingguy> Ok
[17:47:28] * Sodel_the_V belatedly chuckles at "Don-Quijote-esque" 
[17:48:33] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[17:49:30] <erickt> graydon: and then there's the issue of which version of opencl to use.
[17:49:51] <kimundi> uhm, english grammar question: 'too large' or 'to large'? :P
[17:49:56] <steven_is_false> I'm going to drop out for a bit while I walk home from the coffee shop.
[17:50:04] <cmr> kimundi: too large
[17:50:05] <erickt> kimundi: too large
[17:50:18] <erickt> kimundi: unless you are embiggening something :)
[17:50:29] <kimundi> thank good, don't have to renmae all those test cases...
[17:50:34] <kimundi> ;)
[17:51:56] *** Quits: steven_is_false (quassel@1E3F14AE.29819A33.115CE8E4.IP) (Ping timeout)
[17:52:07] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:52:08] <erickt> nmatsakis: Yeah, I was thinking about rewriting it again. I had trouble figuring out how to massage the method code to work correctly. Maybe it'll be easier to just convert methods into functions as early as possible in typeck
[17:52:54] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[17:54:13] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Ping timeout)
[17:54:31] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[17:54:43] <cmr> Is it too much to ask for people to clean up the warnings they introduce in their patches? (legitimate question)
[17:55:02] <pcwalton> no, maybe we should -Werror as part of make tidy
[17:55:19] <erickt> pcwalton: I'm all in favor of that
[17:55:31] <cmr> I've never heard of make tidy until now..
[17:55:37] <pcwalton> it does style police
[17:55:41] <pcwalton> policing
[17:55:52] <cmr> is it run by make check?
[17:55:55] <pcwalton> yes
[17:55:55] <erickt> I keep catching myself checking warnings to see if they are my fault or not
[17:55:59] <cmr> oh, ok then
[17:56:18] <nmatsakis> I am generally in favor of -Werror.
[17:56:32] <pcwalton> just as part of tidy though, when hacking it's a nuisance
[17:56:36] <pcwalton> also might cause staging problems
[17:56:38] * nmatsakis shrugs
[17:56:39] <thatfreakingguy> Is there a way to get a C function pointer from a Rust function?
[17:56:43] <nmatsakis> yes, true
[17:56:51] <pcwalton> thatfreakingguy: after nmatsakis' patch lands yes ;)
[17:56:56] <pcwalton> well
[17:56:59] <thatfreakingguy> Nice
[17:57:02] <nmatsakis> thatfreakingguy: if you use the type `extern "Rust" fn`, you get a simple function pointer
[17:57:03] <pcwalton> you can declare your rust function as "extern fn"
[17:57:10] <nmatsakis> thatfreakingguy: not sure if that's what you want exactly
[17:57:25] <pcwalton> if you want to pass a Rust function to a C callback, declare your Rust function as "extern fn"
[17:57:33] <nmatsakis> erickt: regarding method resolution and so forth, I'm not 100% sure what you mean, but I do have some thoughts on how we can simplify and improve method resolution
[17:57:33] *** Quits: synapsos (Mibbit@640C6C8D.C434660A.DAB1EB3B.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[17:57:40] <pcwalton> it then has the type *u8 in incoming, although I have an open PR to change that type to extern "C" fn
[17:58:58] <nmatsakis> erickt: maybe we could arrange a time to discuss on the phone
[17:59:13] <nmatsakis> erickt: some planning is warranted.
[17:59:42] <bjz> pcwalton: ooh
[17:59:47] <bstrie> pcwalton: why did you close https://github.com/mozilla/rust/issues/4176 if https://github.com/mozilla/rust/pull/6412 hasn't landed yet?
[17:59:53] *** Joins: blitter (blitter@moz-7C98731E.dyn.centurytel.net)
[17:59:55] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[17:59:56] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[18:00:26] <erickt> nmatsakis: If you are in town next week, we could grab lunch / coffee / beer sometime
[18:00:35] *** Parts: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) ()
[18:00:37] <pcwalton> bstrie: that's a stale PR. it has landed as part of a later PR
[18:00:47] * pcwalton closes the PR
[18:00:52] *** Joins: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP)
[18:00:53] <bjz> pcwalton: I have been getting the opengl loader back up to scratch, but I did have the u8* issue
[18:00:54] <bstrie> ok
[18:00:57] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Ping timeout)
[18:01:01] <bjz> pcwalton: https://gist.github.com/bjz/69d47eb02d42698b2ea3
[18:01:27] <nmatsakis> erickt: I'm working out of Boston now :)
[18:01:35] <erickt> ack!
[18:01:45] <erickt> I was just there last week
[18:01:47] <bjz> pcwalton: https://gist.github.com/bjz/eab047c4494a1e029aab
[18:01:56] <cmr> bjz: I hope that was automatically generated...
[18:01:58] <erickt> nmatsakis: permanently?
[18:02:10] <bjz> cmr: I hand typed it all
[18:02:15] <cmr> You're kidding right
[18:02:19] <bjz> cmr: took a while
[18:02:24] <pcwalton> bjz: I think nmatsakis' WIP patch may fix that?
[18:02:26] <cmr> you can't be serious
[18:02:28] <pcwalton> allowing function pointers that is
[18:02:50] <bjz> yeah. but yours was just cosmetic?
[18:03:03] <pcwalton> my patch?
[18:03:07] <bjz> yah
[18:03:08] <pcwalton> it adjusted the types
[18:03:12] <pcwalton> I wouldn't say that's "cosmetic" :)
[18:03:13] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[18:03:15] <pcwalton> but it didn't change trans, noi
[18:03:33] <bjz> yeah, didn't know how to describe it
[18:03:36] <bjz> :)
[18:03:39] <nmatsakis> erickt: yes.
[18:03:44] <bjz> cmr: hopefully I havent made any mistakes
[18:04:00] <nmatsakis> pcwalton: I'm still...kind of stuck on this bizarro LLVM assertion.
[18:04:05] <bjz> cmr: :)
[18:04:05] <nmatsakis> pcwalton: I may just workaround and push patch
[18:04:09] <pcwalton> yes, please
[18:04:10] <pcwalton> :)
[18:04:49] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Quit: Eluding grues)
[18:04:51] <nmatsakis> pcwalton: problem is, it occurs when compile librustc with --test too :) but I guess I can figure out where and fix the incompatible C declarations
[18:05:21] <erickt> nmatsakis: shucks! well Boston sure is pretty this time of the year
[18:05:40] <nmatsakis> erickt: yes, it's beautiful out.
[18:06:05] <erickt> nmatsakis: sure we could do a phone call some time. I can't today/this weekend though
[18:06:05] *** Joins: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net)
[18:06:23] <nmatsakis> erickt: (or skype or whatever) next week would be best for me.
[18:06:54] <erickt> Ok, I'll ping you next week. I've been wondering why I've been seeing you online at 6-7am...
[18:09:43] <erickt> Although this does make me think it'd be nice to have a small rust hackathon in the bay area some time
[18:09:55] *** Quits: BizarreCake (BizarreCak@32C9829A.151E84E7.561471F8.IP) (Ping timeout)
[18:10:12] <cmr> Is a std::bitv a bitmap?
[18:10:42] <cmr> ie, bit-addressable data structure
[18:11:24] <erickt> Are there any other bay area folks online that would be interested in meeting up to hack on rust some Saturday/Sunday?
[18:11:53] <nmatsakis> cmr: yes, it's a vec of integers, using one bit per element
[18:12:25] <cmr> nmatsakis: thanks
[18:14:57] *** Joins: Ralith (ralith@moz-50F3C77.vc.shawcable.net)
[18:14:59] <cantsin> erickt: i'd be interested.
[18:15:43] <erickt> woot
[18:15:59] <cantsin> erickt: ask on the ML too?
[18:16:52] <erickt> Sure!
[18:18:22] *** Quits: eholk (eholk@moz-A365E2F9.uconnect.utah.edu) (Quit: eholk)
[18:19:25] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[18:20:16] <steven_is_false> Which repo is most active for rust-sdl, and should be the one I make a  pull request too?
[18:22:00] <jdm> steven_is_false: probably brson/rust-sdl
[18:22:46] <steven_is_false> jdm: Okay, that's the one I was pulling from.
[18:23:01] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[18:24:07] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[18:24:07] *** ChanServ sets mode: +o brson
[18:25:16] *** Joins: igl (igl@moz-19BA7592.adsl.alicedsl.de)
[18:25:20] <brson> I reimplemented `oneshot` and `stream` on top of the new scheduler and I think the code is pretty nice
[18:25:23] <brson> https://github.com/brson/rust/blob/io-wip/src/libcore/rt/comm.rs
[18:25:50] <brson> also, 95% of the run-pass tests succeed with the new scheduler
[18:27:09] <erickt> ++ brson
[18:27:57] <steven_is_false> brson: I accidentally made a pull request against rust-sdl but screwed the stuff up, GitHubs interface was kind of confusing to me. I'm sorry.
[18:28:16] <pcwalton> brson: \o/
[18:28:35] <kimundi> aarg :(
[18:29:40] <graydon> brson: \o/ amazing
[18:30:22] <kimundi> I modified the bytes! syntax extension and ended up with an ice in stage1 librustc :/
[18:31:24] <erickt> we have a bytes! syntax extension?! I've wanted that forever!
[18:33:18] <nmatsakis> brson: very cool.
[18:34:00] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[18:34:58] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[18:35:03] <bjz> brson: will rust-sdl have a get_proc_address function in the future?
[18:35:07] <kimundi> Has anyone an idea why this might lead to an ice? https://github.com/Kimundi/rust/commit/20e4ffeb2160ef8b1732cb2efab14410f8dfdd54
[18:35:16] <bjz> brson: I couldn't find it in the bindings
[18:35:57] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[18:39:01] *** Quits: dylukes (dylukes@moz-B5418F79.hsd1.pa.comcast.net) (Quit: ["Textual IRC Client: www.textualapp.com"])
[18:39:14] *** Quits: victorporof (victorporo@CA0EF1E0.A58E0E41.6A4F8DA2.IP) (Quit: victorporof)
[18:40:24] *** Joins: cdidd (cdidd@moz-B9125CFF.broadband.corbina.ru)
[18:42:21] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[18:42:47] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[18:45:08] *** Joins: acrichto (acrichto@moz-B63D64BD.res.cmu.edu)
[18:46:11] *** Joins: Blei (philipp@moz-96D25F7A.cust.bluewin.ch)
[18:47:18] *** Joins: jclements_ (jclements@2557E599.66715431.D25A875A.IP)
[18:47:56] *** Quits: vmx (vmx@moz-86342C05.pools.arcor-ip.net) (Quit: Leaving)
[18:48:13] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[18:49:23] <brson> bjz: it will as soon as you add it!
[18:49:34] <bjz> brson: haha
[18:49:42] <brson> bjz: I haven't done any work on it in a long time. It's maintained by AngryLawyer
[18:50:00] <bjz> brson: oh ok
[18:50:04] * brson lunch
[18:50:22] <bjz> brson: I use glfw, I was just wondering because of interop with my gl loader
[18:51:42] *** Quits: calamity (calamity@moz-B84210E2.static.dsl.dodo.com.au) (Quit: Leaving)
[18:52:16] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[18:52:57] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[18:53:35] *** Joins: catpig (catpig@moz-7ECD724E.dip0.t-ipconnect.de)
[18:59:07] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[18:59:27] <thiez> kimundi: I have no idea, but why do you limit the strings to ascii?
[19:01:28] <thiez> oh never mind, you don't
[19:05:26] <thiez> kimundi: you may wish to change those copyright notices to 2013 :)
[19:05:37] <kimundi> err, yeah... xD
[19:06:02] <kimundi> I'm testing atm if the ice was oom caused...
[19:06:16] <kimundi> the vm just had 2GB
[19:06:27] <thiez> any swap?
[19:06:42] <thiez> because I haven't been able to compile with only 2GB and no swap for a while now... :(
[19:07:11] <kimundi> huh, and in this moment it actully finished with the librustc build without ice... so that seems to be the cause :)
[19:07:50] <thiez> it's that very last moment of compilation that usually kills it, memory usage seems to explode in the last few seconds
[19:08:12] *** Quits: busylizzy (lisa@85228838.12D0DC84.211374C4.IP) (Quit: No Ping reply in 180 seconds.)
[19:08:41] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[19:12:47] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Client exited)
[19:13:21] *** Parts: judder (maradukewa@CF01B517.FDE2B133.950D3BB5.IP) ()
[19:13:28] *** Joins: steven_is_false (quassel@moz-144077DE.bchsia.telus.net)
[19:13:43] *** Quits: steven_is_false (quassel@moz-144077DE.bchsia.telus.net) (Client exited)
[19:15:58] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:18:36] *** Quits: Blei (philipp@moz-96D25F7A.cust.bluewin.ch) (Quit: WeeChat 0.4.0)
[19:19:11] *** Quits: novabyte (Instantbir@moz-135D0E61.mullvad.net) (Quit: bye bye)
[19:21:45] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[19:24:35] *** Joins: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net)
[19:27:44] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[19:27:46] *** Joins: khodzha_sh (Mibbit@AD6C6882.A859D9FD.CA6E2165.IP)
[19:28:08] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[19:29:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[19:30:52] *** Joins: eholk (eholk@moz-A365E2F9.uconnect.utah.edu)
[19:31:05] *** Quits: eholk (eholk@moz-A365E2F9.uconnect.utah.edu) (Quit: eholk)
[19:31:13] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[19:37:12] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[19:37:19] <cmr> linking?
[19:38:13] <nmatsakis> graydon: ping
[19:42:40] *** Quits: santiago (santiago@moz-8ADE82B4.socal.res.rr.com) (Quit: Computer has gone to sleep.)
[19:45:14] *** Joins: eholk (eholk@moz-A365E2F9.uconnect.utah.edu)
[19:49:27] <cmr> so what is this schedular brson has been working on? N:M OS:task thread scheduler?
[19:50:30] <kimundi> Hm, apparently a -1024 is not a ast::expr_lit(..) ... Interesting
[19:50:54] *** Parts: khodzha_sh (Mibbit@AD6C6882.A859D9FD.CA6E2165.IP) ()
[19:52:16] *** Joins: santiago (santiago@moz-8ADE82B4.socal.res.rr.com)
[19:53:35] *** Quits: thatfreakingguy (Mibbit@moz-E09ED084.pool.mediaways.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:54:23] *** Joins: jensnockert (jensnocker@moz-8BE55278.customer.t3.se)
[19:54:28] <kimundi> Hm, I wonder if I should go to the length of explicitly parsing the negation operator so that I can print a pretty error message, or not.
[19:58:04] <cmr> rusti: 0432
[19:58:05] -rusti- 432
[19:58:10] <cmr> rusti: 0o432
[19:58:11] -rusti- foo.rs:5:10: 5:14 error: expected `;` or `}` after expression but found `o432`
[19:58:11] -rusti- foo.rs:5          0o432
[19:58:11] -rusti-                    ^~~~
[19:58:17] <cmr> rusti: 432o
[19:58:17] -rusti- foo.rs:5:12: 5:13 error: expected `;` or `}` after expression but found `o`
[19:58:17] -rusti- foo.rs:5          432o
[19:58:17] -rusti-                      ^
[19:58:27] <cmr> Is there literal syntax for octal?
[19:59:21] <jensnockert> rusti: 032
[19:59:22] -rusti- 32
[19:59:28] <jensnockert> Hm... apparently not.
[19:59:52] <pauls> rusti: 4*8*8 + 3*8 + 2
[19:59:53] -rusti- 282
[20:00:06] <pauls> A little cumbersome, though.
[20:00:25] <jensnockert> You could make a macro.
[20:00:27] <cmr> Seems weird to have binary and hex, but not octal.
[20:02:14] *** Joins: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net)
[20:02:29] <cmr> opened #6563
[20:02:29] <jensnockert> Octal is by far the most uncommon, and the 'default' way to parse them is to start with a zero, which can be surprising to newcomers to C-like languages. 
[20:02:44] <cmr> Well I'd use 0o
[20:03:17] <cmr> I was never a fan of leading 0 being octal
[20:03:28] <Ralith> yeah that's a landmine
[20:03:34] <Ralith> 0o is consistent and intuitive though
[20:07:03] <engla> if nobody has a use for octal, maybe rust can be without it
[20:07:20] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[20:07:34] <cmr> reason I hit this is the ncurses binary format is specified with octal.
[20:07:36] <jensnockert> Couldn't there just be a macro octal!()
[20:07:41] <jensnockert> ?
[20:07:52] <cmr> jensnockert: yeah
[20:09:55] *** Joins: mib_4r00fe (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP)
[20:10:33] <mib_4r00fe> hello! is there any way of multiplying a numerical vector with a number, say, 0.25 * [0.0, 1.0]?
[20:11:00] <nmatsakis> random thought: x#2 to project an element of a tuple?
[20:11:13] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[20:11:13] *** ChanServ sets mode: +o tjc
[20:12:20] <SiegeLord> I thought somebody was implementing octal already
[20:12:44] <SiegeLord> I remember discussion about a specific implementation a little while ago (it was 0o incidentally)
[20:12:53] <SiegeLord> (for consistency with Python, e.g.)
[20:13:34] <engla> mib_4r00fe: you need a wrapper type around the vec to define multiplication on it. And the vec type is pretty impractical for math operations since you'll create a lot of new ~[] objects
[20:13:39] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Ping timeout)
[20:14:19] <kimundi> nmatsakis: As operator?
[20:14:57] *** Quits: lmandel (lmandel@F2D29657.F60B0462.67AC9B1.IP) (Quit: lmandel)
[20:15:20] <kimundi> rusti: ~[0.0f, 1.0f].map(|&e| e * 0.25f)
[20:15:21] -rusti- ~~[0, 0.25]
[20:15:33] <kimundi> rusti: [0.0f, 1.0f].map(|&e| e * 0.25f)
[20:15:34] -rusti- ~[0, 0.25]
[20:15:35] <nmatsakis> kimundi: similar to `.`
[20:16:09] <nmatsakis> kimundi: so where x.f selects the field f from a struct, x#2 would select the 2nd element of a tuple (or probably 3rd, since I guess we'd be zero-based)
[20:16:39] <kimundi> Looks a bit heavy
[20:17:12] <kimundi> But if it works...
[20:17:40] <nmatsakis> kimundi: sure, but it's not something one should use often. And no comparable operator exists today, you have to write "let (_, _, v) = x" 
[20:17:53] <nmatsakis> of course we could just permit "x.2"
[20:17:55] <kimundi> tuples are certainly impracticable to handle sometimes, and it's hard to implement accessor methods on them without compiler magic or cheating
[20:18:06] <nmatsakis> so long as the `2` is an integer literal
[20:18:12] <nmatsakis> that's not legal today
[20:18:31] <cmr> I think x#2 is less surprising than x.2
[20:18:36] <cmr> x.2 just... feels wrong
[20:19:55] <kimundi> is there some way to use x[...] without it conflicting with reglur Indax ?
[20:20:10] <kimundi> regular Index*
[20:21:10] <kimundi> x[#2] ? Nah that's silly xD
[20:21:33] <nmatsakis> kimundi: graydon and I tossed around the idea of saying that indexing a tuple is legal as long as the index expr is a compile-time constant
[20:21:57] <cmr> I'd prefer that over tuple-only syntax
[20:22:51] <bstrie> I actually like x#2 :P
[20:23:03] <kimundi> That sounds reasonable. Tuple won't ever have regular Index implemented anyway I just realized. :)
[20:23:08] <bstrie> still not sure if it's useful, though
[20:24:57] <pauls> Tuples are like structs, so `.` seems familiar.
[20:24:58] <kimundi> well... 'return f() # 0' or 'return f()[0]' vs 'let (r, _, _, _) = f(); r'
[20:25:06] *** Joins: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com)
[20:25:20] <kimundi> 'return f().0' ?
[20:25:37] *** Joins: hatman (Mibbit@moz-D5A1D0F5.members.linode.com)
[20:25:38] <kimundi> but yeah pauls makes a good point
[20:25:40] *** Quits: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[20:26:52] <kimundi> It could be generalized to say "unsigned integer literals can be used to acces annonymous fields of a struct, tuple, newtype etc"
[20:26:54] <cmr> I still think . is unpleasant to look at. # is less so. more of a symmetry thing...
[20:27:07] *** Quits: hatman (Mibbit@moz-D5A1D0F5.members.linode.com) (Quit: http://www.mibbit.com ajax IRC Client)
[20:27:43] <bstrie> x.#2
[20:27:45] <bstrie> there you go :)
[20:28:00] <cmr> heh
[20:28:05] <kimundi> struct Foo { field: uint }; f.field = 5; struct Bar(uint); b.0 = 5;
[20:28:08] *** Joins: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com)
[20:28:25] <bstrie> it's basically just indexing, isn't it? why not use [] ?
[20:28:43] <bstrie> in fact
[20:28:48] <bstrie> it's literally just indexing
[20:28:51] <kimundi> Well it's not really indexing because each slot can have a different type
[20:28:53] <bstrie> okay, okay
[20:28:54] <bstrie> right
[20:28:57] <bstrie> different sizes
[20:29:05] <bstrie> still, it's indexing in the python sense :P
[20:29:14] <kimundi> so I think it's more similar to struct fields
[20:29:15] <bstrie> if not in the pointer-arithmetic sense
[20:29:24] <mib_4r00fe> can I use extension impls for arrays to get the ability to multiply them with numbers? say, impl Mul<~[f32], f32> for ~[f32]
[20:29:45] <bstrie> kimundi: I feel sort of like if you want to access elements like that, you should have just made a struct to begin with
[20:29:49] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[20:30:02] *** Quits: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[20:30:15] *** Quits: themgt (themgt@moz-248BBB96.dhcp.gnvl.sc.charter.com) (Quit: themgt)
[20:30:27] <bstrie> mib_4r00fe: I... think so. haven't tried. bjz might know
[20:30:37] <mib_4r00fe> i'm building a mathematics library for my project and vector/number ops is something I won't be able to get around.
[20:30:37] <cmr> mib_4r00fe: check out lmath
[20:30:41] <kimundi> mib_4r00fe: Two problems. 1. You couldn't have multible impls for different number types and the same type. 2. You can't define imple on ~[T]
[20:30:46] *** Joins: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com)
[20:30:53] <engla> either dot or hash notation looks fine.  dot is easier to write
[20:31:29] <mib_4r00fe> oh. that I didn't know, and it renders the prospect of getting a minimalistic version of numpy on rust quite a bit harder, I think.
[20:31:41] *** Quits: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[20:31:41] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[20:31:59] <engla> mib_4r00fe: you will want a custom ndarray just like numpy anyway
[20:32:02] <engla> instead of vec
[20:32:28] <mib_4r00fe> yeah, i guess that's true.
[20:32:36] *** Joins: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com)
[20:32:43] *** Quits: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP) (Quit: zzzzzzzzzz)
[20:33:09] *** Quits: vcl (vcl@moz-E7EA111C.clients.kiwiirc.com) (Quit: http://www.kiwiirc.com/ - A hand crafted IRC client)
[20:33:29] *** Quits: otters (joel@moz-82AAB099.rs) (Ping timeout)
[20:34:51] <kimundi> bstrie: The way I see it both # and . would be fine in principle, but # is a new seperate operator people need to know about, while . would map well to named fields.
[20:35:55] <bstrie> kimundi: if I have `bar = ((1, 2), "foo")`, is `bar.0.1` unambiguous? does that require unbounded lookahead?
[20:36:08] *** Quits: SiegeLord (siege@moz-CAF07B4C.hsd1.ma.comcast.net) (Connection reset by peer)
[20:36:58] <kimundi> It just seems more... consistent to me? type has named fields : acces per name. type has unnamed fields: acces per positional number.
[20:37:42] <kimundi> bstrie: I don't see what would be ambiguous there.
[20:37:54] *** Quits: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net) (Connection reset by peer)
[20:37:57] *** Joins: otters (joel@moz-82AAB099.rs)
[20:38:35] <cmr> rusti: let 1and1 = 2; 1and1
[20:38:35] <bstrie> I have no objections, if someone really finds it useful
[20:38:36] -rusti- foo.rs:5:14: 5:18 error: expected `;` but found `and1`
[20:38:36] -rusti- foo.rs:5          let 1and1 = 2; 1and1
[20:38:36] -rusti-                        ^~~~
[20:38:52] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[20:38:52] <cmr> mm
[20:39:07] <kimundi> cmr: identifiers need to start with a-zA-Z or _
[20:39:15] <cmr> kimundi: that is what I assumed, was testing it
[20:39:21] *** Joins: tjc (tjc@A5087023.2354C43D.D8E68FF6.IP)
[20:39:21] *** ChanServ sets mode: +o tjc
[20:40:31] <engla> does it affect types like  struct X(int,int) ?
[20:40:39] <engla> the tuple indexing
[20:41:00] <bstrie> jclements_: would notation like `bar.2` to access the second element of a tuple require unbounded lookahead to account for the case of nested tuples?
[20:41:15] <bstrie> to disambiguate from numeric literals, I mean
[20:41:41] <cmr> (third element)
[20:41:46] <bstrie> right, right :)
[20:41:46] <nmatsakis> pcwalton: llvm types are interned, I assume?
[20:41:50] <pcwalton> yes
[20:41:56] <jclements> bstrie: if it were up to me, I would never allow new syntactic forms  but that wasn't your question. :)
[20:42:40] <cmr> Coming from other languages, bar[2] is the most unsurprising.
[20:42:44] <nmatsakis> bstrie: parsing bar.2.2 would be problematic, yes, because lexer would probably want to interpret 2.2 ...
[20:42:46] <bstrie> jclements: in fact, let's just keep removing forms... I wonder what a language that did that would look like... :P
[20:43:05] <jclements> bstrie: Are you just asking about something like bar.2.5.7? I think I must be misunderstanding you, because that sounds like the same problem as bar.x.y.z. 
[20:43:30] <jclements> bstrie: however, it could make the *lexer* more confused....
[20:43:34] <engla> cmr: but c++ uses  std::get<2>(bar)
[20:43:40] <nmatsakis> jclements: I don't think there's a problem with lookahead in the parser per se, but rather that it'd require lexer/parser interaction
[20:44:12] <jclements> nmatsakis: right. bleah.
[20:44:25] <cmr> engla: I don't think anyone wants that :)
[20:44:56] <engla> well, bar[2] would be easy if it was dynamic lookup
[20:45:11] <cmr> it's easy now; tuples are known statically
[20:45:34] <kimundi> he, how about foo.[0] ? Distingueshes it from the regular Index
[20:45:50] <jclements> kimundi: ugh, blecch! :)
[20:45:52] <cmr> kimundi: why does it need to be distinguished?
[20:46:38] <kimundi> Well, Its not really "item at offset x" but "annonymous field x"
[20:47:26] <kimundi> that way you could use the notation for named tuples and newtypes without interfering with an existing Index impl on them
[20:48:54] <cmr> rusti: file_reader("foo").unwrap().read_bytes(100000)
[20:48:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eJMV
[20:49:08] <cmr> rusti: use core::io::file_reader; file_reader("foo").unwrap().read_bytes(100000)
[20:49:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LNFi
[20:49:11] <kimundi> I mean, the problem "get n-th item of a tuple" is just a specific form of "get n-th annonymous field of a type"
[20:49:34] <cmr> rusti: use core::io::file_reader; use p = core::path::PosixPath; file_reader(p("foo")).unwrap().read_bytes(100000)
[20:49:35] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SKVP
[20:49:47] <cmr> rusti: use core::io::file_reader; use p = core::path::PosixPath; file_reader(&p("foo")).unwrap().read_bytes(100000)
[20:49:48] -rusti- line longer than 10000 characters, bailing out
[20:49:59] <cmr> heh
[20:50:11] <cmr> rusti: use core::io::file_reader; use p = core::path::PosixPath; file_reader(&p("foo")).unwrap().read_bytes(1000000000)
[20:50:12] -rusti- line longer than 10000 characters, bailing out
[20:50:24] <cmr> rusti: use core::io::file_reader; use p = core::path::PosixPath; file_reader(&p("foo.rs")).unwrap().read_bytes(1000000000)
[20:50:27] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/TLfU
[20:55:18] *** Joins: Jesin (Jessin_@moz-5654D37.washdc.fios.verizon.net)
[20:55:32] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[20:55:32] *** jclements_ is now known as jclements
[20:56:33] *** Parts: vivekg (uid10501@moz-C944F5EC.irccloud.com) ()
[20:57:10] <cmr> rusti: ~[1u8, 2u8, 3u8] as ~[u16]
[20:57:12] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/TieS
[20:57:28] *** Parts: jaws (uid2871@moz-D8B63698.irccloud.com) ()
[20:58:40] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[20:59:09] *** Quits: iopluy (iopluy@moz-F90237FA.adsl.highway.telekom.at) (Ping timeout)
[20:59:27] <kimundi> cmr: as only works on numbers, some unsafe ptr stuff, and for trait objects
[21:00:24] *** Joins: iopluy (iopluy@moz-A9D18B6B.adsl.highway.telekom.at)
[21:00:30] <nmatsakis> rusti: "test"
[21:00:31] -rusti- "test"
[21:00:39] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[21:00:48] * nmatsakis finally got fed up enough to lookup how to make irssi stop telling him about NOTICEs
[21:01:41] <steven_is_false> Hi! Does anyone know a nice way to get the number of constants in an enum? So far I'm doing LastElement as uint but that's kind of hacky.
[21:05:29] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[21:06:49] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:06:54] <nmatsakis> steven_is_false: no, there is no nice way right now.
[21:07:06] <nmatsakis> steven_is_false: hopefully the enum-deriving patch will land soon?
[21:07:10] *** Joins: vcl (chatzilla@741D4FEA.76F9E272.DA40C4B3.IP)
[21:07:11] <nmatsakis> not sure what it's status is
[21:07:51] <steven_is_false> nmatsakis: Oh! #[deriving(EnumCount)] or something like that would be a good way to solve the problem.
[21:07:57] <vcl> Hi!  Is there a cheatsheet with a list of useful rustc make targets?
[21:08:15] <vcl> For example, how do Rust devs test their compiler changes in day-to-day development?  Surely,you don't build all 3 stages all the time?
[21:08:16] <nmatsakis> steven_is_false: yeah there was a patch to derive some utility traits with things like to-int, from-int, max-value etc
[21:08:35] <cmr> vcl: yes, actually...
[21:08:39] <nmatsakis> vcl: I don't know if there is a list, but rustc-stage1, check-stage1, rustc-stage2, check-stage2 are among the most useful
[21:08:46] <nmatsakis> and of course TAGS.emacs and TAGS.vi
[21:08:47] <nmatsakis> ;)
[21:09:01] <Jeaye> nmatsakis: But are the tags actually useful?
[21:09:11] <nmatsakis> Jeaye: if you like to know where things are, yes.
[21:09:12] <Jeaye> I haven't seen anyone with Vi or Emacs working with the tags.
[21:09:18] <nmatsakis> it may only be me
[21:09:24] <nmatsakis> the only thing they don't get is variant names
[21:09:26] <Jeaye> In Vi[m] or Emacs?
[21:09:27] <nmatsakis> you'd need to write a C plugin for those
[21:09:29] <nmatsakis> in emacs.
[21:09:30] *** Joins: themgt (themgt@moz-F5F3FFDF.dhcp.gnvl.sc.charter.com)
[21:09:32] <Jeaye> >.<
[21:09:39] <vcl> Would rustc-stage1 also build runtime and libraries?
[21:09:40] <cantsin> there's an open ticket on proper etag support somewhere
[21:09:44] <tjc> vcl: https://github.com/mozilla/rust/wiki/Note-testsuite
[21:09:45] <Jeaye> Will your configuration work for Vim, nmatsakis?
[21:09:46] <cantsin> i plan to look at that ... eventually :)
[21:09:51] <nmatsakis> Jeaye: I've never tested it, but it should
[21:10:01] <nmatsakis> vcl: it builds a function rustc, which includse core+std
[21:10:05] <nmatsakis> *includes
[21:10:18] <nmatsakis> vcl: rustc-stage1 and check-stage1 are my goto target unless i'm changing something in the codegenerator etc
[21:10:39] <vcl> cool! thanks!
[21:10:51] *** Joins: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP)
[21:12:03] <graydon> nmatsakis: we had ._1 and ._2 and such for a long time
[21:12:10] <graydon> we removed them on the "nobody uses them" basis
[21:12:18] <graydon> (and perhaps "they're ugly")
[21:12:36] <nmatsakis> graydon: I kind of preferred #1 because it was not a "magic field name"
[21:12:46] <nmatsakis> graydon: but the only reason I care about this is because in borrow checker I have to serialzie paths :)
[21:12:50] <nmatsakis> graydon: and sometimes they go through tuple elements
[21:12:53] <nmatsakis> graydon: and there is no syntax for this :)
[21:13:01] <nmatsakis> graydon: I don't *really* care anyhow, I'll just invent something for now.
[21:13:05] <graydon> k
[21:13:20] <nmatsakis> well, actually, I already did: x#3 :)
[21:13:42] *** Quits: maxli (maxli@F2D29657.F60B0462.67AC9B1.IP) (Quit: Leaving.)
[21:15:08] *** Quits: jensnockert (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[21:16:18] *** Quits: pyrac (pyrac@moz-C70D038B.w109-214.abo.wanadoo.fr) (Quit: pyrac)
[21:17:00] <cmr> With https://github.com/cmr/terminfo-rs/tree/wip, what would I have to do to get parser::compiled loaded? Do I need a `#[path = "parser/compiled.rs"] pub mod parser::compiled;` ?
[21:17:36] *** Quits: eholk (eholk@moz-A365E2F9.uconnect.utah.edu) (Quit: eholk)
[21:22:48] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[21:26:57] <brson> somebody accidentally downgraded libuv :(
[21:27:12] * brson *grumble* submodules
[21:27:45] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[21:28:13] <brson> I wonder if I could add a check to tests.mk that verifies the submodule hash
[21:28:21] <brson> this happens a lot
[21:31:41] *** Quits: mib_4r00fe (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[21:32:30] *** Joins: eholk (eholk@moz-A365E2F9.uconnect.utah.edu)
[21:32:59] *** Quits: twm (twm@moz-13417AD3.dsl.static.sonic.net) (Ping timeout)
[21:33:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[21:33:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/xDT5ng
[21:33:10] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[21:33:42] *** Quits: eholk (eholk@moz-A365E2F9.uconnect.utah.edu) (Quit: eholk)
[21:34:16] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[21:35:49] *** Quits: bytbox (s@moz-D83E9B31.wireless.umd.edu) (Ping timeout)
[21:42:11] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[21:42:16] <graydon> if someone wants a cute task
[21:42:37] <graydon> I would be fond of an attribute called #[static_assert]
[21:42:52] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[21:42:53] <graydon> that, when applied to a static bool, halts compilation if the bool evaluates to false.
[21:43:07] <graydon> and is an error (or ignored) anywhere else
[21:43:25] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[21:43:45] <graydon> maybe optionally #[static_assert("why this is important")]
[21:44:26] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[21:46:02] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[21:47:32] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[21:47:56] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[21:53:28] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[21:55:17] <cmr> graydon: #6568
[21:55:20] *** Joins: mcomella_ (mcomella@moz-B10FF54F.ri.ri.cox.net)
[21:56:00] *** Quits: mcomella (mcomella@moz-B10FF54F.ri.ri.cox.net) (Ping timeout)
[21:56:07] <graydon> cmr: thanks!
[21:56:23] <cmr> graydon: if you point me to where attributes are at, I can take a shot at it
[21:57:30] *** Quits: devinus (devinus@moz-B4AF84BC.ptr.us.xo.net) (Ping timeout)
[21:57:40] <graydon> ast::attribute is the type. they're randomly looked-at by various phases of the compiler, there's not a ton of organization to the process
[21:58:11] *** Quits: spider-mario (spidermari@moz-2BC095A6.rev.sfr.net) (Input/output error)
[21:59:46] <cmr> alright, thanks
[22:00:01] *** Quits: iopluy (iopluy@moz-A9D18B6B.adsl.highway.telekom.at) (Ping timeout)
[22:00:10] <graydon> probably you'd want to hook in either at an early stage and run const-eval on them
[22:00:21] *** Joins: iopluy (iopluy@moz-FAF1BF29.adsl.highway.telekom.at)
[22:00:49] <graydon> if you look in src/librustc/driver/driver.rs
[22:00:50] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[22:00:57] <graydon> in the function compile_rest
[22:01:18] <graydon> there are a bunch of pretty random passes thrown in there
[22:01:34] <graydon> const marking, const checking, privacy checking, loop checking, etc. etc.
[22:02:11] <graydon> you could either stick it in the middle of one of those (const marking and checking are probably worth merging someday) or add another pass that just checks the attribute
[22:03:20] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:04:14] <graydon> the constant evaluator in const_eval is pretty weak. it's only used for ... I think simplifying constants in patterns (which we may have reduced to pretty much just "literals and idents") and evaluating the RHS of a C-like enum, the custom discriminant
[22:04:55] <graydon> it's otherwise mostly incorrect. the "real" constant evaluator that produces LLVM constant expressions is in trans, src/librustc/middle/trans/consts.rs
[22:04:58] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[22:05:00] *** Quits: int3_ (int3_@moz-DC8217D4.singnet.com.sg) (Client exited)
[22:05:17] <cmr> I love how rust has tons of documentation, but it's all squirrled away in comments in the source :(
[22:05:23] *** Joins: int3_ (int3_@moz-511FFB9.subnet-207.amherst.edu)
[22:06:02] <graydon> you might be able to hook in there as well (and perhaps that's best, since const_eval is so weak). the only difficulty is that sometimes LLVM doesn't want to let you read values back _out_ from a const you're computing. i.e. I'm not sure you'd be able to find the true/falseness of the static.
[22:06:20] *** Quits: bleibig (bleibig@moz-58EF3B3A.rochester.res.rr.com) (Quit: bleibig)
[22:06:33] <graydon> but you might. jdm might know?
[22:06:56] *** Joins: int3__ (int3_@moz-DC8217D4.singnet.com.sg)
[22:07:04] *** Quits: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Ping timeout)
[22:07:30] *** Joins: bytbox (s@moz-D83E9B31.wireless.umd.edu)
[22:07:37] <steven_is_false> Is there a built in sum method somewhere as in do sum (list) |x| { x.value } ? Or is my best choice just to use foldr
[22:07:40] <graydon> or perhaps jld. having jdm and jld both poking at const eval gets confusing.
[22:07:56] *** Quits: int3_ (int3_@moz-511FFB9.subnet-207.amherst.edu) (Ping timeout)
[22:08:29] <cmr> graydon: why is this useful (#[static_assert])? statics seem too limited to be useful for static assertions, but I am not certain
[22:08:34] <graydon> steven_is_false: I believe strcat either landed or is about-to-land one
[22:10:51] <steven_is_false> graydon: Oh thanks!
[22:10:53] <graydon> cmr: statics cover all integer, char, bool, floating point, 'static&, raw*, fixed-size-{vec,str}, struct and tuple expressions.
[22:11:09] <graydon> cmr: including all arithmetic on them
[22:11:59] <graydon> cmr: static_assert is pretty much always "I computed this bunch of related static values that have to do with sizes of things, please confirm that my calculations are internally consistent"
[22:12:18] <graydon> cmr: and/or "if someone changes X, make sure they also change Y because they have to remain related"
[22:12:40] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: nn)
[22:13:25] <steven_is_false> graydon: Aren't statics just anything which fits the constraint 'static?
[22:13:40] <graydon> I believe that's the idea. or .. hopefully!
[22:14:07] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Input/output error)
[22:14:28] <graydon> the concepts are calculated during different paths / phases, so I wouldn't be surprised if there's some skew between them. but that's why the name was chosen, IIRC
[22:14:36] *** Quits: int3__ (int3_@moz-DC8217D4.singnet.com.sg) (Client exited)
[22:15:55] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (Quit: Leaving)
[22:16:43] <steven_is_false> graydon: Fair enough.
[22:19:17] *** Joins: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP)
[22:19:28] *** Quits: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP) (Quit: WeeChat 0.4.1-dev)
[22:20:25] *** Joins: twm (twm@moz-13417AD3.dsl.static.sonic.net)
[22:22:12] *** Joins: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl)
[22:24:13] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:24:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/O2RZ7A
[22:24:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:24:33] *** Joins: solancile (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[22:25:06] *** Joins: Earnestly (earnest@6A917A59.5E1FD793.39C00A7A.IP)
[22:25:56] <jdm> graydon: what's the question?
[22:26:11] *** Joins: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com)
[22:29:57] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[22:30:07] <jld> graydon: So, constants can be destructured, but there are things that "should" be constants and aren't --- like, famously, GEP in the presence of target data.
[22:30:07] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[22:30:17] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[22:30:31] <jld> graydon: Or, put another way, there are LLVM-IR-time constants and there are selection-DAG-time constants.
[22:30:57] *** Quits: FrozenCow (FrozenCow@moz-9DF5D010.dynamic.upc.nl) (Client exited)
[22:31:00] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Quit: Leaving.)
[22:31:36] <Earnestly> Hello, I'm getting this error: http://ix.io/5GZ on this very basic (from the tutorial) source: http://ix.io/5H0 and struggling to find out why. rustc 0.6
[22:31:47] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[22:32:05] <cmr> Earnestly: you need to throw that in a fn main() { }
[22:32:08] <tjc> Earnestly: you have to put the code inside fn main() {          }
[22:32:14] <tjc> the code that extracts tests from the tutorial does that automatically
[22:32:15] <cmr> (as the tutorial disclaims)
[22:32:25] *** Quits: iopluy (iopluy@moz-FAF1BF29.adsl.highway.telekom.at) (Ping timeout)
[22:32:37] *** Joins: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP)
[22:32:48] *** Joins: iopluy (iopluy@moz-3420F2D5.adsl.highway.telekom.at)
[22:33:13] <Earnestly> I get the same error: http://ix.io/5H1
[22:33:24] <cmr> ALL of it
[22:33:45] <cmr> lets are not allowed in a static context.
[22:33:56] <Earnestly> Ah, yes. I remember now. derp
[22:34:56] <Earnestly> (too much c, sorry)
[22:34:56] <kimundi> Someone here who wants to review my changes to bytes!()? https://github.com/mozilla/rust/pull/6569 :)
[22:35:17] <erickt> kimundi: sure
[22:35:30] * erickt loves the longer line limit...
[22:36:33] <cmr> kimundi: -1024 isn't a literal?
[22:36:47] <kimundi> apparentl not
[22:36:49] <cmr> that's a really bad error message, worth fixing imo
[22:37:04] <erickt> kimundi: does str.each go a byte at a time?
[22:37:11] *** Quits: vosen (vosen@moz-266BA656.icpnet.pl) (Quit: Leaving)
[22:37:18] <kimundi> erickt: yes
[22:38:06] <kimundi> cmr: well, I wasn't sure if its worth fixing, especially because negative lirerals would be illigal there anyway
[22:38:23] <cmr> I agree that it's invalid, just needs a better error message :)
[22:40:03] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[22:40:04] <erickt> kimundi: so this doesn't add a trailing null, which may or may not be an issue
[22:40:26] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[22:41:13] <kimundi> erickt: Howso? I made the change to what was there befor because I needed the option to tack an 0 at the end
[22:41:32] <kimundi> and its an vector, nto a string it evaluets to
[22:42:05] <erickt> kimundi: I'm looking at https://github.com/Kimundi/rust/commit/7a2afb72884774f8e7865c625efc806fd09e693b#L0R30
[22:42:23] <erickt> if I'm reading libcore/str.rs correctly, str.each does not include the trailing null
[22:42:43] <kimundi> yes.
[22:42:45] <cmr> I didn't know str's even had a trailing null
[22:43:10] <erickt> cmr: yep, to make it efficient when we have to pass a string to a C function
[22:43:14] <kimundi> erickt: All bytes of the string excluding the trailing null end up in the vector.
[22:43:51] <kimundi> which is also what bytes! does at the moment
[22:44:02] <kimundi> rusti: bytes!("foo")
[22:44:04] -rusti- &[102, 111, 111]
[22:44:35] <erickt> Understood. I'm just torn if that's the right behavior or not
[22:44:50] <kimundi> Which is perfectly safe, once it is a vector the string invariants no longer apply
[22:44:58] <cmr> I think it's the right behavior. I wouldn't ever want my bytes literal to include the trailing null of a string
[22:45:09] <cmr> it's easy to add if you want it, but difficult to remove if you don't
[22:45:15] <kimundi> jup
[22:45:35] <erickt> the situation I'm thinking of is when interacting with C functions, you might need that trailing null
[22:45:44] <kimundi> with my patch, just have to do bytes!("foo", 0) if needed
[22:46:07] <erickt> ooh, I missed that bit
[22:46:15] <erickt> I didn't get to your last example
[22:46:25] *** Joins: devbug (quassel@moz-E1DE087C.bchsia.telus.net)
[22:46:33] <kimundi> erickt: well in that situation you'd have to be careful anyway if you just work with a [u8]
[22:47:39] <erickt> rusti: str::to_bytes("foo")
[22:47:40] -rusti- ~[102, 111, 111]
[22:48:00] <erickt> oh, I thought you included the trailing null too
[22:48:23] <kimundi> nope
[22:48:26] <erickt> kimundi: ok I'm sold. I thought bytes! had a different behavior than to_bytes
[22:48:45] <kimundi> :)
[22:50:19] <erickt> kimundi: r+ed
[22:50:27] <kimundi> thx :)
[22:51:18] <engla> bytes! is just for inserting byte literals right?
[22:51:45] <kimundi> it evaluates to a &[u8]
[22:51:45] <erickt> engla: right
[22:52:12] <kimundi> rusti: bytes!("abc")
[22:52:13] -rusti- &[97, 98, 99]
[22:53:02] *** Quits: Scriptor (historium@moz-E06F46F0.corp.bitshelter.com) (Quit: Scriptor)
[22:54:09] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:54:09] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/RyJbJw
[22:54:09] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:54:11] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[22:54:11] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/gnreJA
[22:54:11] <ghrust> 13rust/06auto 14916942d 15Marvin Lbel: Some cosmetic changes to num.rs
[22:54:11] <ghrust> 13rust/06auto 147a2afb7 15Marvin Lbel: Made bytes!() accept a list of string, integer or char literals
[22:54:11] <ghrust> 13rust/06auto 142d28d64 15bors: auto merge of #6569 : Kimundi/rust/ext-bytes, r=erickt...
[22:54:13] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[22:54:15] *** Quits: erickt (erickt@8C9ECD8F.3A598286.F12515B4.IP) (Ping timeout)
[22:54:21] *** Joins: dbaupp (Thunderbir@moz-856B3C14.lns20.syd6.internode.on.net)
[22:54:26] <kimundi> There it goes :D
[22:55:07] <dbaupp> kimundi: that pr looks nice :)
[22:56:36] <kimundi> Writing a syntax extension turned out to be surprisisgly simple
[22:56:57] <kimundi> (once you got someone to tell you how to do it)
[22:57:21] <jld> rusti: bytes!("")
[22:57:23] -rusti- &[226, 138, 162, 195, 176, 226, 137, 164, 195, 190]
[22:58:05] <dbaupp> kimundi: yup, it's not too bad
[22:58:40] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[22:59:13] *** Joins: a_m0d (a_m0d@moz-9F925EFA.hm.shawcable.net)
[22:59:58] <jld> rusti: str::connect(bytes!("").map(|&b|fmt!("%03o",b))," ")
[22:59:59] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cebj
[23:00:18] <jld> rusti: str::connect(bytes!("").map(|&b|fmt!("%03o",(b as uint)))," ")
[23:00:19] -rusti- ~"342 212 242 303 260 342 211 244 303 276"
[23:00:48] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[23:01:06] <graydon> jld: hm. I guess the issue I'm getting at is "how likely is it that arithmetic-and-boolean constants can be evaluated-in-llvm and have their truthiness read back out in trans?"
[23:02:22] <graydon> gep I can understand being a bit of a .. challenge. but I wouldn't mind static_assert being slightly nonideal. it's mostly for checking "did I divide thing by other thing properly?"
[23:02:26] *** cscottnet_away is now known as cscottnet
[23:05:06] <cscottnet> cmr: the x86 'make check' error in intrinsic-atomics.rs is:
[23:05:07] <cscottnet> rustc: /home/cananian/Projects/Rust/rust/src/llvm/include/llvm/IR/Instruction.h:437: void llvm::Instruction::setInstructionSubclassData(short unsigned int): Assertion `(D & HasMetadataBit) == 0 && "Out of range value put into field"' failed.
[23:05:29] *** Quits: lmandel (lmandel@FE1F74.86ED00A7.971E19F6.IP) (Ping timeout)
[23:05:29] *** Quits: jdm (jdm@F2D29657.F60B0462.67AC9B1.IP) (Ping timeout)
[23:05:30] <jld> graydon: Arithmetic ought to Just Work, I think?
[23:06:32] <cmr> cscottnet: aatch already found and fixed it, but thanks a lot :)
[23:07:03] <cscottnet> thiez: ^^
[23:08:08] <cmr> cscottnet: it was a problem with signatures. C wrapper functino took 4 params, rust declaration only took 3. uninit stack
[23:10:20] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[23:10:34] <jld> graydon: Although... what about assertions involving size_of?  Have things changed since I last saw them, or is that still an always-inline function?
[23:11:06] <graydon> it is, but it's not a const-expr
[23:11:18] <cmr> What is GER?
[23:11:26] <graydon> we might need to add it to the const-expr vocabulary for just this reason. 
[23:11:33] <graydon> cmr: ?
[23:11:48] <cmr> GEP, sorry
[23:11:54] <jld> GetElementPointer
[23:11:58] <tjc> cmr: http://llvm.org/docs/GetElementPtr.html explains
[23:12:00] <graydon> sizeof, alignof and offsetof are the big tricky ones
[23:12:09] <tjc> "The Often Misunderstood GEP Instruction"
[23:12:16] <cscottnet> cmr: so if I git-pull and rebuild, it should magically work?
[23:12:27] <cmr> cscottnet: yup. make sure you're using the incoming branch
[23:12:31] <graydon> in that they come from the compiler, they're not really function calls at all
[23:12:37] <graydon> they just "look like them"
[23:13:20] <cscottnet> graydon: are there any docs on rust's runtime scheduler?
[23:13:21] <kimundi> graydon: Does anything speak against them being syntaxextensions?
[23:13:26] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:13:30] <graydon> we can either make them look different, or wire them in as special cases to the const-expr grammar (these N intrinsic functions that are compiler-feedback), or ..
[23:13:41] <graydon> kimundi: they're not known at syntax-expansion time
[23:14:09] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Client exited)
[23:14:28] <kimundi> i see
[23:14:49] <kimundi> well, good night everyone
[23:14:59] <graydon> cscottnet: it's being rewritten. brson wrote up some docs on his plan http://brson.github.io/2013/02/02/redesigning-the-rust-runtime/
[23:15:40] <cscottnet> hm, i'm wondering why you aren't using work-stealing
[23:15:52] <jld> graydon: Something about this that's... something is that if it was just about static asserts, then it might be possible to check for truth after running the always-inline pass (and the magical constant folding that I think happens).
[23:15:58] <graydon> cscottnet: that's the plan
[23:16:09] <cmr> cscottnet: aatch wrote a work-stealing queue specifically for this, afaik
[23:16:12] <jld> ...also I should mention that I seem to be coming down with a cold, so I may not be maximally coherent.
[23:16:21] <graydon> jld: sizeof and alignof will wind up used elsewhere though
[23:16:30] <graydon> jld: but I get what you're saying
[23:16:42] <jld> graydon: But, of course, there are other uses for "constant expressions" with stronger requirements.  Like array sizes, which typeck has to know about.
[23:16:46] <cscottnet> graydon: i spent a decent amount of time with cilk, and i'm thinking that rust could use some influencing in this regard. ;)
[23:18:06] *** Quits: cdidd (cdidd@moz-B9125CFF.broadband.corbina.ru) (Input/output error)
[23:19:02] <graydon> cscottnet: what else springs to mind?
[23:19:24] <cscottnet> inlets/outlets and task spawn/join behavior
[23:21:02] *** Quits: iopluy (iopluy@moz-3420F2D5.adsl.highway.telekom.at) (Ping timeout)
[23:21:29] <cscottnet> i'll hack around on this a bit, but in my first readthrough of the rust docs, it seems that doing a simple "spawn; spawn; sync" is a little awkward.
[23:21:34] *** Joins: iopluy (iopluy@moz-58C21ABB.adsl.highway.telekom.at)
[23:21:38] <graydon> ok. I think nmatsakis has spent some time with fork/join style parallelism and might have plans for rust in that regard. presently our parallelism is mostly task-oriented but we have other experiments ongoing (including some GPU-kernel integration)
[23:22:13] <cscottnet> cilk's semantics are that 'sync' joins only those tasks spawned at the same function-level, which I believe is part of cilk's performance guarantee
[23:22:51] <cscottnet> duplicating this on rust seems to involve some complicated pipe plumbing, although maybe there's a syntax extension which could ease the pain.
[23:24:16] <graydon> cscottnet: there are a few ways you could try to emulate it in rust. I don't know what you mean by "function level" though.
[23:24:28] *** Joins: lucian (lucian@moz-22A14C6A.cable.virginmedia.com)
[23:24:56] <cscottnet> also, cilk has a clean way of coding search.  ie: we're going to spawn a task to recurse down each branch of a tree in parallel, but once we find the thing we're looking for, we can abort the other tasks and clean up (which doesn't involve fail-ing the task which successfully found the result)
[23:25:53] <cscottnet> graydon: function level means that, for: function foo() { spawn a(); spawn b(); sync; } function a() { spawn c(); sync; }
[23:25:58] <graydon> why is aborting different from failing?
[23:26:10] *** Quits: lucian (lucian@moz-22A14C6A.cable.virginmedia.com) (Ping timeout)
[23:26:32] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[23:26:50] <cmr> aren't tasks a concurrency primitive, or are they also meant to be used for parallelism?
[23:27:29] <cscottnet> the sync in foo() waits for a and b (not c); and the sync in a() waits for c (but not b)
[23:27:38] <graydon> they can and do run in parallel, but they're oriented more-towards concurrency than parallelism, yes
[23:27:48] <graydon> (and oriented towards failure-isolation, actually)
[23:27:51] *** Joins: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net)
[23:28:32] *** Quits: seth (seth@moz-D840E602.dsl.static.sonic.net) (Ping timeout)
[23:29:06] <kesserich> howdy. I'm trying to upgrade a program which does a lot of c-interop to rust 0.6 but i'm getting a strange error when i attempt to check if ptr::is_null()
[23:29:42] <cscottnet> graydon: my first reading of the rust sync code seems to indicate that it is difficult to return a value from one spawned task while simultaneously killing all the other spawned tasks (but not the parent)
[23:29:42] <cscottnet> if the parent kills the children, it seems that all the children would die, including the successful child.  maybe i misread.
[23:29:42] <cscottnet> cmr: can you explain the difference between concurrency and parallelism?
[23:30:04] <graydon> kesserich: file a bug?
[23:30:07] <kesserich> the pointer in question is to an opaque type so i defined it as a *c_void.  This worked fine in 0.5 but in 0.6 i'm getting a nasty compilation error: 
[23:30:08] <kesserich> Assertion failed: (isa<X>(Val) && "cast<Ty>() argument of incompatible type!"), function cast, file /Users/psantaclara/Desktop/rust-0.6/src/llvm/include/llvm/Support/Casting.h, line 197.
[23:30:18] <graydon> kesserich: or paste code perhaps
[23:30:45] <cmr> cscottnet: http://www.yosefk.com/blog/parallelism-and-concurrency-need-different-tools.html is a better summary of it than I could give
[23:31:11] *** Quits: iopluy (iopluy@moz-58C21ABB.adsl.highway.telekom.at) (Ping timeout)
[23:32:11] <graydon> cmr: in CS-lingo at least, parallelism means doing multiple tasks at the same time. concurrency means interleaving sequential logic against some lesser number of resources (cores, say)
[23:32:19] <cscottnet> cmr: that's a distinction i hadn't heard made before.
[23:32:31] <cscottnet> and my initial thought is that "concurrency" is stupid. ;)
[23:32:40] *** Joins: iopluy (iopluy@moz-F2AC77C8.adsl.highway.telekom.at)
[23:32:48] <cmr> graydon: I don't think that those definitions fully capture all of the implications, though
[23:32:55] <cscottnet> if you're interleaving against the same number of cores, that's parallelism.
[23:33:09] <graydon> cmr: not if you're interleaving a lot more threads than you have cores
[23:33:29] <cscottnet> according to the article you cited, concurrency is more like a gui, where i want to render images while waiting for other stuff to happen (disk i/o, say).  "one coke machine"
[23:33:33] <graydon> I do not think it's an either/or, I think they're dual aspects of work-scheduling problems
[23:33:40] <cmr> cscottnet: exactly
[23:34:10] <cmr> cscottnet: eg python's twisted solves concurrency rather well, but it doesn't do parallelism that great
[23:34:13] <graydon> you can have a concurrency problem on a parallel processor
[23:34:29] <graydon> and you can have a parallelism problem in a system that does concurrency well
[23:34:41] <graydon> or you can live in the promised land of having neither problem
[23:34:49] <cscottnet> concurrency is a good idea if you only have a single processor.  with multiple cores even on single processors now, concurrency is a terrible hack.
[23:35:10] <graydon> cscottnet: can I ask you to tone down the critical voice?
[23:35:22] <cscottnet> graydon: sorry about that.  ;)
[23:35:28] <graydon> cscottnet: you do not typically have 1 core per network connection
[23:35:37] <cscottnet> i should say that it's a terrible hack, having published papers on the terrible hack myself. ;)
[23:35:38] <graydon> that would be cool, but we're not in that future
[23:36:21] <graydon> a modern superscalar out-of-order core is, itself, a concurrency problem among a fixed number of execution units
[23:36:27] <graydon> the problems interleave all the way down
[23:37:20] <cscottnet> have you guys ever seen http://www.gnu.org/software/pth/ ?
[23:37:26] <cmr> yes
[23:37:33] <cscottnet> we used to call this "cooperative multitasking"
[23:37:43] <cmr> we don't call it that anymore?
[23:37:54] <cscottnet> apparently we now call it "concurrency"
[23:37:57] *** Quits: maxli (maxli@C03F2759.C70D537E.2FA4EA88.IP) (Quit: Leaving.)
[23:38:05] <graydon> I don't think you can get away from viewing computational throughput in both terms. it's like asking whether operators or operands make up an algebra.
[23:38:44] <graydon> how-many-work-units-you-want-fairly-executed and how-many-execution-resources-you-have are very rarely 1:1
[23:39:10] <graydon> preemptive multitasking is concurrency as well
[23:39:16] <cscottnet> this is why i brought up work-stealing
[23:39:19] <graydon> you think your sleeping thread has a core assigned to it? :)
[23:39:41] <cscottnet> if you have more work-units than execution-resources, work-stealing allows scheduling which is within a constant factor of optimal.  provably.
[23:40:10] <graydon> yes. work stealing is a way of moving work between execution units. we know about it and are intending to implement it for moving coroutines between our io/scheduler queues.
[23:40:52] *** Quits: kesserich (Mibbit@moz-7ABC9BDB.hsd1.pa.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:41:13] <dbaupp> cscottnet: fwiw, there is a work-stealing queue implementation in progress https://github.com/brson/rust/pull/1
[23:41:27] <cmr> oh he opened a PR, nice
[23:42:15] <cscottnet> i don't want to go off on a flamewar here.  tasks seem a reasonable parallelism mechanism.  if you've got even better ones in the wings, I'm eager to hear about them as well.
[23:42:19] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[23:43:38] *** Joins: seth (seth@moz-D840E602.dsl.static.sonic.net)
[23:44:04] <graydon> I don't know which better ones we should be aiming for. the language doesn't have fork/join statements build in for spawning them or collecting them but I'm not sure that is beyond what one could do in a library.
[23:44:07] *** Quits: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com) (Quit: Computer has gone to sleep.)
[23:44:20] <steven_is_false> About coopereative multitasking, it's fairly easy to implement something similar to that using run once functions, and a run, and return successor pattern. How good is the support for run once functions right now?
[23:44:29] <graydon> otherwise I expect in many cases task will == thread, since threads can be quite cheap
[23:45:06] <graydon> steven_is_false: I'm not aware of any difference between rust tasks and "cooperative multitask"
[23:45:13] <bstrie> vcl: ah, I see you finally made it
[23:45:31] <cscottnet> graydon: it's possible you could define a function-scope variable or object to tie the spawns and syncs together.  in my copious free time i'd like to try to translate some of my cilk code into rust and see what breaks.
[23:45:35] <steven_is_false> graydon: For Rust tasks one can't share data easily.
[23:45:48] <graydon> that is intentional
[23:46:03] <steven_is_false> graydon: That's useful if one intends to split them up on separate cores but for many cases it is overkill.
[23:46:16] *** Quits: iopluy (iopluy@moz-F2AC77C8.adsl.highway.telekom.at) (Quit: iopluy)
[23:46:39] <graydon> steven_is_false: I am not sure what you're getting at
[23:46:57] <cscottnet> steven_is_false: i'm not entirely sure about "can't share data easily" either.  in a tree structured data structure, it seems like you could make each task the temporary Owner of a subtree.
[23:46:57] <graydon> if you want to pass data around, you can. it's not like it gets copied, it's moved. usually just a single owning pointer.
[23:47:11] <vcl> bstrie: yeah, was having tech difficulties :)
[23:47:27] <cscottnet> i'm not sure how easy it is to collect the results and re-own the tree at the end -- that might be a place that could be improved.
[23:48:35] <graydon> cscottnet: yes, one of the patterns we've discussed is a sort of unsafe library that does a synchronous destructure, fork, join, and reassemble on a value.
[23:48:48] <steven_is_false> It's not THAT difficult to pass data around but it is slighty annoying. I was only asking on the current status of run once functions.
[23:49:43] <graydon> I do not know what their state is. sorry, I guess I'm being a little rude myself.
[23:49:43] <steven_is_false> graydon: What I mean is that one can use a trampoline pattern.
[23:50:12] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Broken pipe)
[23:50:15] <steven_is_false> graydon: It's fair enough if you don't know the status.
[23:50:15] <cscottnet> fwiw, transactions are the other hobby-horse I have.  fork-join seems to fit better with rust, though.
[23:50:18] <graydon> steven_is_false: sure. I just .. think you might be surprised to look inside the scheduler brson's writing, it's pretty much that
[23:50:29] <steven_is_false> graydon: Oh.
[23:50:57] <graydon> or, rather, it doesn't keep re-manufacturing new run-once closures
[23:51:07] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:51:07] <ghrust> 01[13rust01] 15bors merged 06auto into 06incoming: 02http://git.io/gnreJA
[23:51:07] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:51:44] <graydon> it grabs a closure, stack-switches into it, and when the closure calls a yielding function, it comes out the other side of the stack-switch call and it goes on to the next closure.
[23:51:56] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[23:51:57] <steven_is_false> graydon: That is somewhat problematic. When I do a similar thing in Java I reuse old objects so that is not a problem.
[23:51:58] <cmr> graydon: btw, do you know any reasonable source of the noise / spikes in http://huonw.github.io/isrustfastyet/ ?
[23:52:07] <engla> is there a way to implement a parallel map easily (with futures for example). I can't make it work since you need to write out the closure to make it unique (you can't copy a ~fn)
[23:52:21] *** Quits: samnardoni (samnardoni@moz-ECB14881.cable.virginmedia.com) (Client exited)
[23:53:19] <engla> hmm.. maybe if I use a closure that returns a ~fn
[23:53:23] <dbaupp> engla: there's std::par which has some stuff like that
[23:53:35] <dbaupp> engla: (it does exactly the closure thing)
[23:53:43] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[23:54:03] <engla> wow
[23:54:04] <engla> cool
[23:54:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:54:05] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/kA-yZA
[23:54:05] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:54:05] *** Joins: ghrust (ghrust@moz-4EF5B6E5.rs.github.com)
[23:54:05] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/lCMv4g
[23:54:05] <ghrust> 13rust/06auto 147dc466f 15Olivier Saut: Correct the example given for a future, add punctuation where necessary
[23:54:05] <ghrust> 13rust/06auto 143e41639 15Olivier Saut: Add a small section on futures to the tutorial
[23:54:06] <ghrust> 13rust/06auto 1435b654c 15bors: auto merge of #6565 : osaut/rust/futures, r=bstrie...
[23:54:07] *** Joins: tgt (tgt@moz-D59EE478.aztw.cable.virginmedia.com)
[23:54:08] *** Parts: ghrust (ghrust@moz-4EF5B6E5.rs.github.com) ()
[23:54:12] <engla> happy I figured that out :)
[23:54:14] <graydon> cmr: nope. machine noise perhaps, network traffic noise, start time noise, etc.
[23:54:22] <graydon> cmr: guessing
[23:54:30] <cmr> graydon: ok, thanks
[23:54:38] <dbaupp> graydon: are they dedicated rust machines?
[23:54:46] <graydon> dbaupp: yeah
[23:54:55] <graydon> +/- amazon machines that power up on demand
[23:55:05] <cmr> ohhh they're running on EC2?
[23:55:08] <graydon> no
[23:55:21] *** Joins: mib_atb1yl (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP)
[23:55:36] <graydon> the main bots are in offices or VMs in racks we own
[23:55:39] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[23:55:41] <cmr> what is meant by amazon machine?
[23:55:50] <graydon> EC2 is backfill. plus future scaling as we increase load.
[23:55:55] <graydon> we haven't increased load yet.
[23:56:13] <graydon> also freebsd is on EC2. sometimes we run more EC2 machines, sometimes less.
[23:56:35] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[23:56:38] <mib_atb1yl> i'm trying to multiply a 2d matrix by a scalar, like so: vec::map(~[~[1, 2], ~[3, 4]], |e| vec::map(e, |i| i * 2)) and the compiler complains about "mismatched types: expected `& <V7>` but found `&~[<VI3>]` (expected vector but found &-ptr)"
[23:56:42] <mib_atb1yl> what am I doing wrong?
[23:57:39] <tjc> mib: a function that you pass to map takes an &T if the vector is a ~[T]...
[23:57:48] <tjc> so in the body of each of the functions that you're passing to map, you need to dereference the argument
[23:57:53] <tjc> in the second case: |i| *i * 2
[23:58:04] <joshua_> rusti, vec::map(~[~[1, 2], ~[3, 4]], |e| vec::map(*e, |i| *i * 2))
[23:58:20] <joshua_> rusti: vec::map(~[~[1, 2], ~[3, 4]], |e| vec::map(*e, |i| *i * 2))
[23:58:25] -rusti- ~[~[2, 4], ~[6, 8]]
[23:58:34] <mib_atb1yl> oh, I see, thanks. :)
[23:58:46] <tjc> np
[23:59:02] <dbaupp> rusti: (~[~[1,2], ~[3,4]]).map(|e| e.map(|&i| i*2))
[23:59:04] -rusti- ~[~[2, 4], ~[6, 8]]
[23:59:56] *** Quits: mib_atb1yl (Mibbit@C83F40FA.C3C4EFEF.4BC5EF08.IP) (Quit: http://www.mibbit.com ajax IRC Client)

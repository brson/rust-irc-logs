[00:00:07] <dbaupp> (otherwise, e.g. `let map = 1; hash_map!(map: 2);` won't work, and that possibly happens)
[00:00:09] <aatch> Oh, and you can't conflict with external names.
[00:00:20] * dbaupp wants hygiene to work
[00:00:23] <engla> dbaupp: good point! That's the thing that has actually happened to me..
[00:00:29] <aatch> dbaupp, I thought it did.
[00:00:58] <dbaupp> engla, aatch: is there a "gensym!()" macro yet? (or whatever makes it work...)
[00:01:02] <bjz> fixed
[00:01:06] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[00:01:16] <shachaf> Is there  way to have a bunch of fields of the same type in a struct without specifying it for each one?
[00:01:19] <bjz> https://gist.github.com/bjz/821a6d00b2ef6d5450e7
[00:01:31] <engla> dbaupp: I don't know
[00:01:41] <aatch> dbaupp, no, but I thought that it namespaced the declarations inside macros.
[00:01:53] <sp3d> shachaf: use a vector?
[00:02:06] <shachaf> As in "{ int x, y, z; }" or "{ x, y, z :: Int }".
[00:02:20] <bjz> I wish we had a way of doing methodised macros: map.insert!("foo": 1, "bar": 2);
[00:02:25] <aatch> shachaf, nope.
[00:02:33] <shachaf> sp3d: I think a vector is a bit excessive to save myself from a few type annotations. :-)
[00:02:56] <dbaupp> rusti: macro_rules! foo(($x:expr) => {{ let bar = 1; bar += ($x).len(); bar }}) let bar = ~[]; foo!(bar)
[00:02:57] <shachaf> OK.
[00:02:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DYhH
[00:03:16] <dbaupp> rusti: macro_rules! foo(($x:expr) => {{ let bar = 1; bar += ($x).len(); bar }}) let bar = ~[1i]; foo!(bar)
[00:03:17] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RYTL
[00:03:23] <sp3d> in my experience code working with such structures often ends up doing [&foo.x, &foo.y, &foo.z].map(bar) or such very often
[00:03:28] <dbaupp> aatch: ^
[00:03:37] <aatch> dbaupp, ooooo.
[00:03:41] <aatch> I didn't think of that.
[00:03:44] <sp3d> or needs to refer to "which" of x, y, or z
[00:03:48] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[00:03:53] *** Joins: MaikKlein1 (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[00:03:59] <bjz> what other macro things might be useful? tree_map?
[00:04:05] <sp3d> i.e. the index into the vector
[00:04:25] <shachaf> sp3d: In this case the structure is user_regs_struct from sys/user.h.
[00:04:34] <sp3d> mm
[00:04:42] <engla> bjz: one thing I've tried to do in macros for this purpose is to count the number of elements passed in (for capacity) but I can't do it
[00:05:00] <engla> bjz: maybe it doesn't matter much for these "literals"
[00:05:06] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:05:13] <sp3d> yeah, in that case it might end up being mostly opaque or named access only
[00:05:35] <sp3d> you can save typing with a newtype
[00:05:37] <aatch> dbaupp, I think what I was thinking of was that a `let bar = ...` in a macro that doesn't have an enclosing scope won't clobber a previous `bar` variable.
[00:05:43] <dbaupp> engla: `[$($key),*].len()` probably works
[00:05:48] <dbaupp> aatch: yeah
[00:06:23] <aatch> shachaf, is every field the same type?
[00:06:35] <dbaupp> bjz: you could have a `map!(HashMap, a: b, c: d, ...)` general macro
[00:06:58] <sp3d> aatch: yes
[00:07:00] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[00:07:01] <shachaf> aatch: Yep. 27 general-purpose 64-bit registers.
[00:07:16] <MaikKlein1> engla, didn't i move the port into the closure? I thought this would do it
[00:07:16] <MaikKlein1> let port = self.port;
[00:07:16] <MaikKlein1>         do spawn {
[00:07:16] <MaikKlein1>            let value = port.recv();
[00:07:16] <MaikKlein1>            println(fmt!("%?",value));
[00:07:17] <MaikKlein1>         }
[00:07:18] <aatch> shachaf, then you could use a macro for it.
[00:07:19] <shachaf> It's not such a big deal. In fact the C code in the .h file defines one per line.
[00:07:21] <shachaf> I was just wondering.
[00:07:28] <shachaf> Hmm, I suppose that's a possibility.
[00:07:42] * shachaf will have to look into how those work.
[00:07:50] <engla> MaikKlein1: yes you did, but the implication is that all of self must move, like it does, too, but you didn't want it to be consumed
[00:07:51] <aatch> basically just feed it the field names.
[00:08:04] <aatch> shachaf, they do have to expand to items (in this case)
[00:08:38] <aatch> so the macro itself needs to expand to the struct.
[00:08:40] <engla> dbaupp: borrow checker doesn't like it. no real idea what is happening
[00:09:36] <dbaupp> shachaf: `macro_rules! struct_def { ($(field:ident),*) => { struct MyStruct { $(field: uint),* } } struct_def!(rax, rbx, rcx)`
[00:09:46] <dbaupp> engla: oh :(
[00:09:53] <aatch> dbaupp, dammit, beat me to it. :D
[00:11:42] *** Quits: kini (kini@8CE7D24D:6948BCE:9B80811F:IP) (Ping timeout)
[00:12:39] *** Joins: kini (kini@8CE7D24D:6948BCE:9B80811F:IP)
[00:13:13] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[00:13:36] <shachaf> Sounds like syntax-rules.
[00:13:39] <aatch> Hmm, where would the best place to put syscall code be.
[00:13:45] <engla> dbaupp: you don't need the type in the macro in rust.. just the appropriate trait impls
[00:13:49] <aatch> shachaf, it's supposed to.
[00:13:57] <engla> dbaupp: for the generic collection macro
[00:14:28] <MaikKlein1> engla, can I clone a Port?
[00:15:15] <dbaupp> aatch: os or libc
[00:15:34] <aatch> dbaupp, what about sys?
[00:15:45] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[00:15:53] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:16:07] <engla> I don't know MaikKlein1, not much experience there
[00:16:29] <MaikKlein1> engla, ok no problem, thanks anyway :)
[00:17:01] <steven_is_false> Anyone here working on the concurrency stuff? Is it safe to fail! inside a with block for an std::unstable::Exclusive value? I know scheduling operations like yielding are prohibited in the documentation.
[00:17:19] <dbaupp> aatch: oh yeah
[00:17:48] <dbaupp> aatch: it might even be worth having an entirely separate std::linux; module?
[00:18:02] <dbaupp> (or, wait, syscalls happen on all os's)
[00:18:07] * dbaupp is silly
[00:18:12] <aatch> dbaupp, well syscalls in and of themselves are platform independent.
[00:18:16] <bjz> I wonder if a HashMap::from_vals fn might be easier: https://gist.github.com/bjz/821a6d00b2ef6d5450e7
[00:18:20] <dbaupp> aatch: right
[00:18:49] <aatch> it's just the implementation that differs.
[00:18:57] <bjz> (and more flexible)
[00:19:01] <dbaupp> bjz: you could use Iterator<(K,V)> ;)
[00:19:19] <aatch> Also, not all syscalls would run through a general syscall interface.
[00:19:19] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[00:19:39] <strcat> dbaupp: HashMap should have a FromIterator implementation
[00:19:42] <strcat> err
[00:19:43] <strcat> bjz: *
[00:19:48] <strcat> atm only vectors have it
[00:19:48] <engla> yeah
[00:19:52] * aatch needs to figure out how windows and bsd/macos do syscalls
[00:20:11] <cmr> aatch: I saw the logs, very promising work :)
[00:20:16] <bjz> dbaupp: fn from_vals<K:Hash + Eq,V, I: Iterator<(K,V)>(vals: I) -> HashMap<K,V> ?
[00:20:38] <dbaupp> bjz: right; but using FromIterator would be even cooler :)
[00:20:51] <bjz> dbaupp: but it looks ugly
[00:20:56] <dbaupp> (where using = "implementing then using")
[00:21:06] <engla> .collect() is the thing you can use to make a generic collection macro
[00:21:23] <bjz> you have to specify it's a hashmap
[00:21:32] <engla> return type inference
[00:21:35] <dbaupp> bjz: well, it's less ugly than having to allocate a whole new vector every time you want to make a hashmap
[00:21:43] <dbaupp> engla: it's not very reliable with .collect()
[00:22:00] <bjz> dbaupp: well we could implement a wrapper on HashMap
[00:22:01] <aatch> cmr, yeah, since syscalls don't run on the stack, we can use them without incurring a stack switch that we get from normal FFI
[00:22:08] <engla> hmm... maybe not
[00:22:10] <dbaupp> bjz: yes
[00:22:12] <cmr> aatch: I know
[00:22:14] <engla> that can be fixed hopefully
[00:22:28] <dbaupp> (in any case, is FromIterator would be good to have)
[00:22:34] <dbaupp> s/is //
[00:22:49] <bjz> dbaupp: HashMap::new - then HashMap::empty would be what new is currently?
[00:22:52] <engla> and a consuming vec iterator :-)
[00:23:00] <aatch> cmr, I plan to implement the easy, naive way first, then move x86_64 linux to using vdso
[00:23:23] <cmr> aatch: freebsd uses the standard 0x80 interrupt
[00:23:26] <dbaupp> engla: I'm on that one :)
[00:23:32] <aatch> cmr, ah, cool.
[00:23:41] <dbaupp> bjz: dunno
[00:23:51] <engla> dbaupp: I had a go strcat told me it was unsafe :-<
[00:24:02] <cmr> I don't know what NT does, but you don't want to be using them anyway, you want to be using win32
[00:24:05] <dbaupp> engla: right... :S
[00:24:31] <aatch> cmr, would assuming that macos uses the same as bsd be ok?
[00:24:32] <strcat> you mean consume?
[00:24:42] <engla> yes
[00:24:42] <dbaupp> strcat: yeah
[00:24:43] <strcat> you can write a perfectly safe VecRevConsumeIterator
[00:24:55] <strcat> it's forward consume that has to rely on the drop flag (which may be rm'ed)
[00:24:57] <cmr> aatch: I don't know what xnu does
[00:25:05] <aatch> xnu?
[00:25:10] <cmr> osx's kernel
[00:25:13] <dbaupp> strcat: why's it have to rely on it?
[00:25:16] <aatch> cmr, ahh.
[00:25:24] <strcat> dbaupp: because it sticks init() to replace elements
[00:25:25] <cmr> it's open source, with the rest of darwin
[00:25:28] <strcat> and if there was no drop flag that would crash
[00:25:45] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[00:25:47] <dbaupp> strcat: right
[00:26:06] <strcat> dbaupp: vectors only have a ptr to the start and len, so you can only safely do that from the end (assuming a world with no drop flag like niko/patrick want to do)
[00:26:07] <cmr> strcat: I wonder if we could stand up a darwin VM and it would be equivalent to testing on OS X...
[00:26:16] <strcat> cmr: it's okay anyway it's landing
[00:26:25] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[00:26:26] <cmr> strcat: even so, it's a pita
[00:26:26] <strcat> 277s
[00:26:29] <strcat> ;p
[00:26:32] <dbaupp> strcat: it is possible to do it safely from the front
[00:26:36] <strcat> dbaupp: how?
[00:26:44] <strcat> the destructor will iterate over all the elements
[00:26:46] <strcat> if fail happens
[00:26:50] <strcat> and destroy them
[00:26:58] <aatch> All I know about it is that it's a BSD variant, but I guess that's not enough to make assumptions on.
[00:26:59] <dbaupp> strcat: it's slightly complicated, sec
[00:27:00] <strcat> you can't swap init() in safely, that assumes a drop flag
[00:27:19] <strcat> dbaupp: I guess you swap the end to the start?
[00:27:26] <strcat> and when you get to the new end you go back to the start
[00:27:36] <dbaupp> strcat: yeah, for half the elements, and then iterate backwards for the rest
[00:27:36] <cmr> aatch: You can fall back to syscall(2) for unix-alike
[00:27:43] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[00:27:51] <strcat> dbaupp: well that'd work
[00:27:53] <strcat> :p
[00:27:54] <cmr> aatch: hm, found http://thexploit.com/secdev/mac-os-x-64-bit-assembly-system-calls/
[00:27:55] <aatch> cmr, yeah... but that kinda defeats the point.
[00:27:58] <engla> dbaupp: funky
[00:27:59] <strcat> cmr: syscall is glibc-specific
[00:28:16] <strcat> and it's not how you actually ever want to make a linux syscall
[00:28:22] <cmr> strcat: no, definitely isn't
[00:28:26] <strcat> you want to use the vdso directly
[00:28:31] <strcat> cmr: it's definitely linux specific
[00:28:35] <engla> dbaupp: so that's slightly more expensive than the unsafe current consume implementation?
[00:28:40] <cmr> strcat: nope, freebsd *and* os x have them
[00:28:44] <dbaupp> engla: right
[00:28:46] <strcat> cmr: but they take different args
[00:28:50] <MaikKlein1> when have you started coding in rust?
[00:28:59] <dbaupp> engla: (especially so for large structures)
[00:29:03] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Input/output error)
[00:29:53] * strcat shrugs
[00:29:55] <cmr> strcat: so? it's still syscall(num, ...), and all the syscalls are enumerated in <sys/syscall.h>
[00:29:59] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[00:30:14] <strcat> cmr: on linux
[00:30:17] <strcat> and it's useless
[00:30:18] <strcat> it's an FFI call
[00:30:18] <cmr> strcat: and freebsd, and os x
[00:30:19] <aatch> strcat, I found a use for an unreachable intrinsic, btw.
[00:30:42] <strcat> cmr: so why not just use the POSIX functions like read/write?
[00:30:54] * strcat shrugs
[00:31:14] <strcat> the point of making syscalls directly is not needing an FFI call, requiring a 2MiB stack alloc
[00:31:17] <cmr> strcat: good point, there's no point falling back to a syscall function :p
[00:31:18] <aatch> allowing for functions with a return type of -> ! without having to use fail.
[00:31:27] <cmr> what a huge fail on my part :\
[00:31:37] * aatch said that right at the start...
[00:31:56] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[00:31:56] <strcat> cmr: and we need to use the vdso before it's faster than going through glibc for many
[00:31:59] <strcat> like gettimeofday
[00:32:11] <cmr> because, you mean?
[00:32:13] <cmr> also I know
[00:33:01] <aatch> strcat, sure, though that only works on x86_64 anyway.
[00:33:11] <strcat> aatch: isn't vsyscall still faster?
[00:33:14] <strcat> on x86
[00:33:25] <aatch> strcat, I'm not sure. maybe.
[00:33:37] <strcat> Go seems to use vsyscall + vdso almost exclusively
[00:33:54] <cmr> interrupts are slow, should be avoided
[00:34:08] <aatch> but the `syscall` instruction is only on x86_64 as well, anyway.
[00:34:24] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[00:34:24] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/zO8OJA
[00:34:24] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[00:34:25] <cmr> aatch: that's why the vDSO exists, to stup them out for platforms without that insn
[00:34:42] <aatch> cmr, I am aware.
[00:34:55] <cmr> everyone is saying things everyone knows!
[00:35:01] <strcat> cmr: it's faster than the syscall instruction for some
[00:35:26] <strcat> calls not requiring priv checks can be implemented with read-only pages
[00:35:28] <cmr> woo it landed
[00:35:45] <strcat> I'll try removing the headers now
[00:35:55] <mib_0som4e> wondering why mut tuples can't be assigned to now? e.g. "obsolete syntax: `mut` with multiple bindings"
[00:36:13] <cmr> mib_0som4e: those aren't tuples
[00:36:15] <cmr> those are patterns
[00:36:17] <bjz> dbaupp: why does it need a &mut I?
[00:36:29] <mib_0som4e> let mut (x, y) = (1, 2) ?
[00:36:31] <cmr> mib_0som4e: and they were removed because they're buggy and noone aggrees on what it should do
[00:36:33] <aatch> My point is that it's easier to implement in pieces, as long as I give myself space to upgrade to faster calls.
[00:36:34] <bjz> dbaupp: what if I want to give it a static vector?
[00:36:35] <strcat> mib_0som4e: not a tuple
[00:36:35] <cmr> not a tuple.
[00:36:46] <strcat> mib_0som4e: that's destructuring
[00:36:49] <strcat> it's a pattern
[00:36:56] <mib_0som4e> hmm ok, so what should I do?
[00:36:58] <cmr> mib_0som4e: the feature will be readded back in as `let (mut x, mut y) = ...` eventually
[00:37:01] <dbaupp> bjz: iterators store their internal state, and it needs to be modified for each .next()/.advance/whatever call
[00:37:04] <mib_0som4e> sorry for n00b question!
[00:37:08] <cmr> mib_0som4e: separate bindings, `let mut x = 1; let mut y = 2`
[00:37:09] <mib_0som4e> cmr but for now...?
[00:37:13] <dbaupp> bjz: an vector isn't an iterator
[00:37:20] *** Joins: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP)
[00:37:20] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/_u5csg
[00:37:20] *** Parts: ghrust (ghrust@F6EE6DE3.6A2AE50.F3114085.IP) ()
[00:37:22] <mib_0som4e> what if I have a function foo that returns (int, int)?
[00:37:23] <bjz> dbaupp: from_iterator([...])
[00:37:23] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[00:37:23] <ghrust> 01[13rust01] 15bors pushed 3 new commits to 06auto: 02http://git.io/nFBeeg
[00:37:23] <ghrust> 13rust/06auto 149b8c435 15Brian Anderson: More 0.7 release notes
[00:37:23] <ghrust> 13rust/06auto 14a766a95 15Brian Anderson: Bump version from 0.7-pre to 0.7
[00:37:23] <ghrust> 13rust/06auto 141c48aac 15bors: auto merge of #7517 : brson/rust/0.7, r=brson
[00:37:25] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[00:37:28] <cmr> mib_0som4e: can also rebind, `let (x, y) = ...; let mut x = x; let mut y = y`
[00:37:29] <mib_0som4e> and I want to assign the result to (x, y)?
[00:37:32] <dbaupp> bjz: from_iterator([...].iter())
[00:37:34] <aatch> mib_0som4e, it's fine. that's why we're here :D
[00:37:36] <bjz> oh
[00:37:39] <bjz> :(
[00:37:42] <mib_0som4e> ooh cmr I think I get it
[00:37:46] <mib_0som4e> and aatch thanks :)
[00:37:54] <bjz> fff default methods!!!!!
[00:37:57] <strcat> bjz: we can have an Iterable trait, it's a huge pain though
[00:38:08] <bjz> whyyyy are you not there
[00:38:08] <dbaupp> bjz: the iterator needs to be immutable, but not necessarily the thing it's iterating over
[00:38:08] <strcat> first default methods need to work with #[inline] cross-crate
[00:38:17] <mib_0som4e> why was the destructuring buggy?
[00:38:28] <bjz> strcat: :(
[00:38:34] <aatch> mib_0som4e, let bindings and match bindings use different code paths.
[00:38:39] <aatch> they shouldn't
[00:38:44] *** Joins: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net)
[00:39:00] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[00:39:04] <dbaupp> strcat: how do we implement Iterable for Iterator? just copy self?
[00:39:09] <aatch> but it meant that the code for let bindings didn't keep up very well.
[00:39:26] <mib_0som4e> aatch ah, I see
[00:39:28] <strcat> dbaupp: can't
[00:39:29] <mib_0som4e> thanks for the explanation!
[00:39:36] <dbaupp> strcat: ?
[00:39:37] <aatch> mib_0som4e, Rust has two types of patterns, by the way.
[00:39:48] <strcat> dbaupp: you can't implement it for iterators
[00:39:50] <strcat> think about &mut
[00:39:52] <strcat> it's non-copyable
[00:39:52] <aatch> mib_0som4e, refutable patterns, and irrefutable patterns.
[00:39:55] <dbaupp> strcat: right
[00:39:56] <strcat> Iterable will take &self
[00:40:06] <dbaupp> strcat: that's pretty annoying
[00:40:23] <strcat> dbaupp: I don't want to worry about Iterable yet
[00:40:24] <mib_0som4e> aatch and the difference is?
[00:40:27] <strcat> needs to be thought out well ;p
[00:40:40] <aatch> mib_0som4e, irrefutable patterns are known at compile time, so stuff like (x, a) is irrefutable, since only a two-element tuple can match it.
[00:40:49] <cmr> mib_0som4e: irrefutable patterns are allowed in `let` and in function arguments, refutable patterns aren't
[00:40:58] <dbaupp> mib_0som4e: (an irrefutable pattern can never fail to match)
[00:41:06] <cmr> bam, tag teamed
[00:41:09] <strcat> meh
[00:41:09] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[00:41:10] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[00:41:16] <mib_0som4e> makes sense aatch cmr
[00:41:17] <strcat> I need to get rid of the C++ exchange allocator and vector code
[00:41:20] <strcat> I guess that's next
[00:41:49] <aatch> mib_0som4e, refutable patterns are things like enum variants. So with Option<T>, you have None and Some(T), only one can match, but we don't know which one until runtime.
[00:42:16] <mib_0som4e> right
[00:42:35] <aatch> irrefutable patterns can be used anywhere a value is assigned to a variable (in theory)
[00:42:57] <strcat> rusti: let (a, (b, c), d) = (1, ('c', 2), "foo"); (a, b, c, d)
[00:42:58] -rusti- (1, 'c', 2, "foo")
[00:43:03] <mib_0som4e> right, because the compiler can tell how it should be resolved?
[00:43:08] <strcat> rusti: let (a, (b, c), d) = (~1, ('c', 2), "foo"); (a, b, c, d)
[00:43:09] -rusti- (~1, 'c', 2, "foo")
[00:43:09] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[00:43:11] <aatch> mib_0som4e, correct.
[00:43:12] <strcat> rusti: let (~a, (b, c), d) = (~1, ('c', 2), "foo"); (a, b, c, d)
[00:43:13] -rusti- (1, 'c', 2, "foo")
[00:43:19] <mib_0som4e> cool!
[00:43:41] <strcat> rusti: let (~a, (b, &c), d) = (~1, ('c', &2), "foo"); (a, b, c, d)
[00:43:41] -rusti- (1, 'c', 2, "foo")
[00:43:59] <aatch> oh, right, you can move/copy out of pointers using pattern-matching against the sigils.
[00:44:04] <aatch> which is pretty cool.
[00:44:14] <roo> rusti: fn foo(():()) { }; foo(());
[00:44:15] -rusti- error: internal compiler error: node_id_to_type: no type for node `expr () (id=11)`
[00:44:15] -rusti- application terminated with error code 101
[00:44:16] <strcat> aatch: it's sad that *x can't move out of ~T though
[00:44:20] <roo> lol
[00:44:31] <strcat> rusti: let x = ~5; let ~y = x; y
[00:44:32] -rusti- 5
[00:44:44] <strcat> rusti: let x = ~5; let y = *x /* this should let you move out of x too */; y
[00:44:45] -rusti- 5
[00:44:46] <aatch> (I think it might just be move for patterns actually)
[00:44:46] <mib_0som4e> !!!
[00:44:49] <strcat> oh it's fixed!
[00:44:51] <strcat> heh.
[00:44:54] <mib_0som4e> pretty awesome
[00:44:57] <strcat> aatch: ah right
[00:45:03] <strcat> aatch: I meant when *x is movable only
[00:45:05] <strcat> here, sec
[00:45:10] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[00:45:11] <strcat> rusti: let x = ~~5; let ~y = x; y
[00:45:11] <cmr> And in irrefutable patterns you can have variable binding
[00:45:11] -rusti- ~5
[00:45:14] *** Joins: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net)
[00:45:15] <cmr> Like when you're doing a range
[00:45:25] <strcat> rusti: let x = ~~5; let ~y = x /* works */ y
[00:45:25] -rusti- <anon>:9:45: 9:46 error: expected `;` but found `y`
[00:45:25] -rusti- <anon>:9          let x = ~~5; let ~y = x /* works */ y
[00:45:25] -rusti-                                                       ^
[00:45:25] -rusti- application terminated with error code 101
[00:45:26] <cmr> c@1..15
[00:45:27] <strcat> err
[00:45:30] <strcat> rusti: let x = ~~5; let ~y = x /* works */; y
[00:45:30] -rusti- ~5
[00:45:30] <cmr> binds the the result to `c`
[00:45:38] <strcat> rusti: let x = ~~5; let y = *x /* should work */; y
[00:45:38] <aatch> cmr, that's refutable.
[00:45:39] -rusti- ~5
[00:45:39] *** Joins: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP)
[00:45:40] <strcat> heh
[00:45:44] <cmr> oops, that's what I meant
[00:45:45] <strcat> aatch: that works now too
[00:45:50] <strcat> aatch: dunno when it got fixed :)
[00:45:53] <bjz> dbaupp: https://gist.github.com/bjz/ecc68313b6f88c36ab02
[00:46:01] <aatch> strcat, who cares!
[00:46:08] <cmr> dbaupp: some data starting to land in http://hnn.mrsd.org/~cmr/ btw
[00:46:09] <strcat> aatch: well I've been working around it for ages
[00:46:12] <strcat> never noticed it got fixed
[00:46:15] <strcat> cause I stopped doing it ;p
[00:46:32] <aatch> strcat, heh, the problem with workarounds.
[00:46:42] <cmr> dbaupp: mem.json is standard json like from mem-bench, time.txt is /usr/bin/time in a separate run (to avoid memory profiling overhead)
[00:46:44] <mib_0som4e> wait, sorry, "in [refutable] patterns  you can have variable binding"?
[00:46:45] <aatch> It's pretty rare that the workaround stops working.
[00:46:52] <cmr> mib_0som4e: yes
[00:46:57] <bjz> dbaupp: it wouldn't allow me to do from_vals([...].iter())
[00:46:58] <aatch> mib_0som4e, inside a match, yes
[00:47:07] <mib_0som4e> ah, right, got it
[00:47:28] <strcat> bjz: you can't chain rvalues
[00:47:28] <aatch> so match a { x @ 1..5 => ... }
[00:47:33] <strcat> bjz: with refs
[00:47:36] <bjz> ?
[00:47:37] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[00:47:38] <cmr> dbaupp: (because the memory profiling is slow python code and in a busy loop, it skews the timing results, though I do have cpuacct stuff recorded)
[00:47:46] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().fold(0, |a, &b| a + b)
[00:47:47] -rusti- 6
[00:47:53] <strcat> rusti: [1, 2, 3].iter().fold(0, |a, &b| a + b)
[00:47:55] <mib_0som4e> aatch I think I see
[00:47:56] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UKAR
[00:47:59] <strcat> it doesn't work yet
[00:48:00] <mib_0som4e> thanks so much!
[00:48:03] <bjz> lame, why?
[00:48:12] <strcat> bjz: rustc is dumb
[00:48:21] <strcat> bjz: special cases rvalues for a single borrow
[00:48:26] <strcat> doesn't do it for a borrow after a move
[00:48:28] <bjz> >:(
[00:48:30] * strcat shrugs
[00:48:33] <strcat> well
[00:48:36] <strcat> I guess it doesn't do it with chained borrows
[00:48:46] <strcat> rusti: let x = &5; /* why does this work? */ x
[00:48:47] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/MiIV
[00:48:48] <strcat> rusti: let x = &5; /* why does this work? */ *x
[00:48:49] -rusti- 5
[00:48:52] <strcat> anyway
[00:48:58] <strcat> it's a fragile thing, the rvalue handling
[00:49:06] <bjz> mmk
[00:49:08] <aatch> bjz, hey, for a while you couldn't borrow rvalues at all.
[00:49:18] <bjz> :P
[00:49:48] <cmr> http://rustlog.octayn.net/post/54300983987/status-update, good night all
[00:49:50] * bjz apologises for his morning attitude
[00:50:07] <aatch> bjz, eh, it's a monday.
[00:50:16] <bjz> aatch: yup
[00:50:16] <aatch> nobody like mondays/
[00:50:19] <strcat> meh
[00:50:21] <MaikKlein1> :D
[00:50:21] <strcat> http://buildbot.rust-lang.org/console?branch=auto&refresh=15
[00:50:24] *** Quits: MaikKlein1 (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Quit: Leaving)
[00:50:26] <strcat> missing bot
[00:50:28] <bjz> aatch: I'm supposed to be on holidays
[00:50:29] *** Joins: MaikKlein1 (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[00:50:33] <strcat> because of that stupid stalled build
[00:50:33] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[00:50:35] <bjz> aatch: in brissy
[00:50:35] <strcat> that it can't kill
[00:50:38] * strcat sighs
[00:50:51] <bjz> aatch: but I just can't stop rusting
[00:50:53] <strcat> aatch: https://github.com/mozilla/rust/blob/master/src/libstd/rt/global_heap.rs#L65 so close!
[00:50:59] <bjz> MaikKlein1: hoya!
[00:51:08] <MaikKlein1> bjz, hey
[00:51:18] <bjz> MaikKlein1: does lmath build, or still bugged?
[00:51:25] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[00:51:28] * strcat starts on vectors
[00:51:46] <strcat> aatch: hrmm did your snapshot not land?
[00:52:00] <MaikKlein1> bjz, no I made a very small PR to fix the +=, but there were some lifetime errors that I couldn't fix :(
[00:52:05] <aatch> bjz, heh. I went on holiday over new years, wrote a Mongrel library in C while staying at my girlfriends parents.
[00:52:14] <aatch> strcat, I'm not sure.
[00:52:16] <aatch> I don't think so
[00:52:29] <aatch> acrichto wanted some change to build, but I had already gone to bed.
[00:52:46] <MaikKlein1> bjz, I am not sure why I can't fix them, I believe there is some macro trouble.
[00:53:21] *** Quits: geomyidae (geomyidae@DD6F7E3A.21468E9A.30200F38.IP) (Ping timeout)
[00:54:06] <aatch> strcat, looks like it bitrotted.
[00:54:10] <MaikKlein1> bjz,  for example this macro https://github.com/bjz/lmath-rs/blob/master/src/dim_macros.rs#L218
[00:55:08] <roo> rusti: fn foo((x,y): (int,int)) -> int { x+y }; foo((1,2));
[00:55:09] -rusti- ()
[00:55:52] <roo> rusti: fn foo((x,y): (int,int)) -> int { x+y }; foo((1,2))
[00:55:53] -rusti- 3
[00:58:16] <aatch> strcat, one of the conflicts I got is "deleted by us" on exchange_alloc
[00:58:17] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[00:58:26] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[00:58:26] *** ChanServ sets mode: +o brson
[00:58:48] <strcat> aatch: I'm not really sure why we had that file in addition to the rt/global_heap.rs one
[00:59:04] <aatch> strcat, so it _should_ be gone?
[00:59:08] <strcat> aatch: yes
[00:59:20] * aatch can never interpret merge conflicts properly
[00:59:40] <strcat> aatch: I prefer the stuff you get from pull --rebase
[00:59:51] <strcat> the merge conflict makes you deal with it all at once ;p
[01:00:55] <doener> https://gist.github.com/dotdash/5897733 -- am I doing something wrong here?
[01:01:19] <strcat> doener: for loops don't have labelled breaks
[01:01:21] <strcat> they aren't loops
[01:01:23] <strcat> they're closures
[01:01:38] <strcat> it will get fixed by making a new for loop
[01:01:44] <strcat> where return/break actually do what they claim
[01:01:48] <doener> ok
[01:02:05] <aatch> strcat, then the borrow checker will be able to reason about them properly.
[01:02:45] <aatch> strcat, by the way whats your take on changing the syntax? I'm not bothered either way, but I see the point of the "it's not a closure" argument.
[01:02:56] <bjz> MaikKlein1: yeah that's the one I was having issues with
[01:03:21] <strcat> aatch: don't care
[01:03:22] <strcat> ;p
[01:03:30] <aatch> strcat, fair enough.
[01:03:31] <bjz> MaikKlein1: tbh I think we should just do a demacroification
[01:03:38] <strcat> really fine with it being 'for iterator |pattern| {}' or 'for pattern in iterator {}'
[01:03:42] <MaikKlein1> bjz, yeah
[01:03:52] <bjz> MaikKlein1: bloody annoying though, I tangled it all up
[01:03:54] <strcat> aatch: it's hard to fix that
[01:03:57] <strcat> don't see how you would
[01:04:06] <strcat> make an entire separate tree for the stage1/stage2 codebase?
[01:04:08] <bjz> MaikKlein1: I feel bad showing it
[01:04:14] <MaikKlein1> bjz, :D
[01:04:18] <strcat> maybe add a for_each keyword and then snapshot
[01:04:20] <strcat> and remove for
[01:04:21] <strcat> and add for
[01:04:24] <strcat> change them all
[01:04:26] <strcat> remove for_each
[01:04:29] <strcat> not going to be fun.
[01:04:49] <aatch> I guess you're like me, as long as it's not terrible syntax, you care more about semantics and what's actually going on under the hood.
[01:05:01] <bjz> MaikKlein1: ohhhh
[01:05:06] * aatch doesn't understand python advocates for this reason
[01:05:09] <dbaupp> strcat, bjz: it doesn't look like the rvalue lifetime problem
[01:05:19] <bjz> MaikKlein1: it might be that rvalue thing strcat was talking about
[01:05:29] <bjz> dbaupp: ?
[01:05:36] <dbaupp> bjz: if you implement from iterator for `&'self (K, V)` it should work
[01:05:50] <dbaupp> (well, ignoring the rvalues problem, which might crop up again)
[01:06:08] <dbaupp> bjz: .iter() for vectors yields references
[01:06:10] <bjz> dbaupp: so you'd have to do [&("foo", 1), ...]? :(
[01:06:16] <dbaupp> bjz: nope
[01:06:54] <bjz> ?
[01:07:00] <dbaupp> bjz: vec.iter() -> Iterator<&T> so [(K,V)].iter() -> Iterator<&(K,V)>, not Iterator<(K,V)> which is what your current impl of fromiterator requires
[01:07:03] <bjz> dun gettit
[01:07:42] <dbaupp> rusti: let v = [1,2,3]; for v.iter().advance |i| { println(fmt!("%?", i)); }
[01:07:43] -rusti- &1
[01:07:44] -rusti- &2
[01:07:44] -rusti- &3
[01:07:44] -rusti- ()
[01:07:47] <yichoi> build bot has some problem ?
[01:07:58] <dbaupp> cmr: cool!
[01:07:59] <bjz> which impl?
[01:08:04] <strcat> yichoi: yes a mac build is stuck
[01:08:11] <strcat> so there are no free mac bots
[01:08:13] <dbaupp> cmr: http://hnn.mrsd.org/~cmr/6fcd8bf5677652f31008cde5f9f9f00fe67d90b8/time.txt ?
[01:08:20] <dbaupp> cmr: (that has no newlines for me)
[01:08:21] <strcat> so pulls are going to take 2x as long to land ;p
[01:08:52] <yichoi> strcat: sad new!
[01:08:56] <yichoi> news!
[01:09:02] <dbaupp> bjz: what do you mean?
[01:09:07] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Quit: )
[01:10:00] *** Quits: bjz (brendanzab@moz-E17AB2AB.lnse2.cha.bigpond.net.au) (Ping timeout)
[01:10:02] <MaikKlein1> what is .all doing again?
[01:10:29] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[01:10:40] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[01:10:49] <strcat> MaikKlein1: checking if a predicate is true for all the items
[01:11:18] <strcat> rusti: let xs = [1, 2, 3]; xs.iter().all(|x| *x < 4)
[01:11:18] -rusti- true
[01:11:27] <strcat> rusti: let xs = [1, 2, 3, -5, 1, 2, -111, 2]; xs.iter().all(|x| *x < 4)
[01:11:28] -rusti- true
[01:11:32] <strcat> rusti: let xs = [1, 2, 3, -5, 1, 2, 5, -111, 2]; xs.iter().all(|x| *x < 4)
[01:11:32] -rusti- false
[01:11:35] <MaikKlein1> ah ok thanks
[01:11:50] <aatch> strcat, does all short-circuit?
[01:11:55] <strcat> aatch: yes
[01:11:58] <dbaupp> aatch: yes
[01:12:00] <strcat> aatch: and any
[01:12:07] <strcat> they are all as lazy as can be for generic iterators
[01:12:12] <MaikKlein1> rusti: let xs = [1, 1,1,1,1,1,1]; xs.iter().all(|x| *)
[01:12:12] -rusti- <anon>:9:55: 9:56 error: unexpected token: `)`
[01:12:12] -rusti- <anon>:9          let xs = [1, 1,1,1,1,1,1]; xs.iter().all(|x| *)
[01:12:12] -rusti-                                                                 ^
[01:12:12] -rusti- application terminated with error code 101
[01:12:18] <MaikKlein1> rusti: let xs = [1, 1,1,1,1,1,1]; xs.iter().all(|x| *x)
[01:12:18] -rusti- <anon>:9:54: 9:56 error: mismatched types: expected `bool` but found `int` (expected bool but found int)
[01:12:18] -rusti- <anon>:9          let xs = [1, 1,1,1,1,1,1]; xs.iter().all(|x| *x)
[01:12:19] -rusti-                                                                ^~
[01:12:19] -rusti- error: aborting due to previous error
[01:12:19] -rusti- application terminated with error code 101
[01:12:19] *** concrete.mozilla.org sets mode: +M 
[01:12:31] * strcat hates flood protection
[01:12:52] *** Quits: MaikKlein1 (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Quit: Leaving)
[01:12:58] *** Joins: MaikKlein1 (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[01:13:03] *** Quits: MaikKlein1 (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Client exited)
[01:13:09] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[01:13:10] <strcat> you need to be identified
[01:13:28] <strcat> it sets +M when it goes over the flood protection level
[01:13:30] <MaikKlein> rusti: let xs = [1, 1,1,1,1]; xs.iter().all(|x| *x as bool)
[01:13:30] -rusti- true
[01:13:37] <MaikKlein> rusti: let xs = [1, 1,0,1,1]; xs.iter().all(|x| *x as bool)
[01:13:38] -rusti- false
[01:14:38] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[01:14:38] *** ChanServ sets mode: +o brson
[01:14:40] <MaikKlein> has anyone here read "The Last of the Masters"?
[01:15:19] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (Ping timeout)
[01:16:03] <SiegeLord> Bors lived it
[01:16:11] <MaikKlein> oh look I think we have finally found a Higgs Brson
[01:16:26] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Quit: Leaving)
[01:17:17] *** concrete.mozilla.org sets mode: -M 
[01:17:40] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[01:19:45] *** Joins: brson (brson@6A848D32.C1B840DD.76F66111.IP)
[01:19:45] *** ChanServ sets mode: +o brson
[01:21:44] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo];
[01:21:46] -rusti- <anon>:9:25: 9:27 warning: unused variable: `xs` [-W unused-variable (default)]
[01:21:46] -rusti- <anon>:9          struct Foo; let xs = ~[Foo, Foo];
[01:21:46] -rusti-                                   ^~
[01:21:46] -rusti- ()
[01:21:47] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo]; xs
[01:21:52] -rusti- timeout triggered!
[01:21:55] <strcat> ha
[01:21:59] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo]; xs[0]
[01:21:59] -rusti- {}
[01:22:03] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo]; xs
[01:22:08] -rusti- timeout triggered!
[01:22:09] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo]; xs.len()
[01:22:10] -rusti- 2
[01:22:18] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo]; xs.capacity()
[01:22:19] -rusti- 4
[01:22:33] <strcat> rusti: struct Foo; let xs = ~[Foo, Foo, Foo, Foo, Foo]; xs.capacity()
[01:22:33] -rusti- 5
[01:23:21] <aatch> hmm, I wonder if that's a good thing or not.
[01:23:39] <strcat> well I'm just trying to figure out how to port the C++ part to rust atm
[01:23:39] <MaikKlein> is capacity the expanded length?
[01:23:46] <strcat> MaikKlein: it's the allocation size
[01:23:53] <aatch> MaikKlein, it's the amount of allocated space.
[01:24:03] <MaikKlein> oh
[01:24:05] <strcat> rusti: let mut xs = ~[]; xs.push(5); xs.capacity()
[01:24:05] <MaikKlein> ok
[01:24:05] <etw> what's the best way to prevent borrowing a pointer as immutable? if I use &*mut I get an error "cannot borrow `*engine` as mutable more than once at a time"
[01:24:05] -rusti- 4
[01:24:21] <strcat> rusti: let mut xs = ~[]; xs.push(5); xs.push(5); xs.push(5); xs.push(5); xs.push(5); xs.capacity()
[01:24:21] -rusti- 8
[01:24:31] *** Joins: mib_793nti (Mibbit@moz-D7F31788.hsd1.mi.comcast.net)
[01:24:32] <strcat> etw: you can only have one mutable borrow at a time anyway
[01:24:42] <strcat> well
[01:24:44] <strcat> what do you mean?
[01:24:47] <MaikKlein> :D
[01:25:06] <MaikKlein> strcat, is the size in byte?
[01:25:07] <strcat> you can have any number of & borrows
[01:25:15] <strcat> MaikKlein: capacity returns size in elements
[01:25:21] <etw> just trying to get this to work: http://pastebin.com/LN7vnAcP
[01:25:52] <strcat> etw: you definitely don't want that &mut
[01:26:03] <strcat> can you just do 'engine.instructions.iter()'
[01:26:16] *** Joins: bjz (brendanzab@moz-D2E3CABC.lns6.cha.bigpond.net.au)
[01:26:20] <etw> nope, I get error: cannot borrow `*engine` as mutable because it is also borrowed as immutable
[01:26:29] <strcat> and where are the borrows
[01:26:36] <strcat> what are the notes it prints
[01:26:37] <bjz> MaikKlein: currently working on the macros
[01:26:49] <etw> src/engine.rs:34:8: 34:27 note: second borrow of `*engine` occurs here
[01:26:50] <etw> src/engine.rs:34     for engine.instructions.iter().advance |instruction| {
[01:27:05] <strcat> etw: which part do they both point to?
[01:27:14] <strcat> ok well I see where it goes wrong
[01:27:17] <etw> I'm really impressed by the rust notes/errors in general, just some of them are still a little esoteric
[01:27:20] <strcat> step is borrowing engine as &mut
[01:27:22] <MaikKlein> bjz, to replace them with traits?
[01:27:30] <strcat> etw: if step is borrowing as &mut, this won't work
[01:27:41] <strcat> etw: you can't have an overlapping &mut borrow and another borrow
[01:27:50] <strcat> anyway I guess it is because you take engine as &mut
[01:27:52] <etw> strcat: I just want to preserve the mutability
[01:28:02] <strcat> etw: well you can't copy &mut borrows
[01:28:09] <strcat> etw: you can't use 'engine' inside that loop
[01:28:17] <strcat> it overlaps with the borrow of engine.instructions
[01:28:31] <strcat> you can pass *part* of engine as &mut and have part as &
[01:28:39] <strcat> but the &mut can't overlap with the & or another &mut
[01:29:35] <etw> there's no way to preserve that pointer ?
[01:29:41] <strcat> etw: I don't know what you mean
[01:29:52] <strcat> you definitely can't have an &foo.bar and an &mut foo at the same time
[01:29:57] <etw> I really just want to pass around a reference to the same object
[01:30:10] <aatch> etw, it's probably better to have methods on Engine
[01:30:18] <strcat> aatch: it won't fix this
[01:30:19] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[01:30:27] <strcat> ok so look
[01:30:31] <strcat> &mut can't alias with other borrows
[01:30:32] <etw> aatch: that's where I'm going, but I'm still learning in baby steps ;)
[01:30:43] <strcat> you have &engine.instructions borrowed
[01:30:49] <strcat> so you can't refer to &mut engine
[01:30:51] <aatch> strcat, I know, but you can then use a normal loop to prevent the overlapping borrows.
[01:31:08] <aatch> I guess the method thing doesn't make a difference...
[01:31:08] <MaikKlein> bjz, I think we can convert everything to traits fairly easy
[01:31:09] <strcat> etw: which fields does 'step' actually need?
[01:31:21] <strcat> etw: you can't pass it all of engine because part is borrowed by your loop
[01:31:36] <strcat> step() could modify engine.instructions as the loop was going
[01:31:40] <engla> strcat: so your ~ header changes did land on master eventually?
[01:31:40] <strcat> bam, memory corruption
[01:31:44] <strcat> engla: yes they landed
[01:31:46] <strcat> it still has headers
[01:31:59] <strcat> they are now *never* initialized/read/written to
[01:32:07] <engla> strcat: no judgement but it's a pretty hilarious thing to push in just before the release
[01:32:12] <strcat> engla: why?
[01:32:14] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[01:32:15] <strcat> it passes tests
[01:32:18] <etw> strcat: ah I see, let's just say, that I'm happy that that could happen, is there a workaround?
[01:32:19] <MaikKlein> has anyone experimented with default methods?
[01:32:25] <aatch> engla, the releases are time-based
[01:32:30] <engla> sure strcat if tests are good enough
[01:32:35] <MaikKlein> are they relatively stable now?
[01:32:36] <strcat> etw: you can take specific references to fields
[01:32:39] *** Quits: mib_0som4e (Mibbit@moz-43C591CF.nycmny.east.verizon.net) (Quit: http://www.mibbit.com ajax IRC Client)
[01:32:41] <aatch> MaikKlein, yes, they work reasonably well not, still some bugs around generics though.
[01:32:47] <etw> strcat: I'd have to go unsafe?
[01:32:49] <aatch> s/not/now
[01:32:51] <strcat> etw: no
[01:32:57] <strcat> etw: like, let Engine{x: ref x, y: ref mut y} = engine;
[01:33:16] <strcat> etw: you can't pass an &mut that includes engine.instructions as you have engine.instructions borrowed as &
[01:33:20] <engla> aatch: ok, then, it has lined up pretty well for a release anyway so I thought not
[01:33:37] <strcat> etw: you can pass &mut pointers to any field in engine except for the 'instructions' field to step
[01:33:39] <dbaupp> strcat: (do let bindings with ref work now?)
[01:33:43] <strcat> dbaupp: enough to do that
[01:33:56] <aatch> they have issues with anything more complicated though.
[01:34:00] <dbaupp> rusti: let a = 1; let ref b = a;
[01:34:01] -rusti- <anon>:9:24: 9:29 warning: unused variable: `b` [-W unused-variable (default)]
[01:34:01] -rusti- <anon>:9          let a = 1; let ref b = a;
[01:34:01] -rusti-                                  ^~~~~
[01:34:02] -rusti- ()
[01:34:09] <strcat> rusti: struct Foo { x: int, y: int } Foo { x: 5, y: 10 }
[01:34:10] -rusti- {x: 5, y: 10}
[01:34:16] <MaikKlein> hm
[01:34:20] <aatch> like `~ref a`
[01:34:25] <strcat> rusti: struct Foo { x: int, y: int } let mut a = Foo { x: 5, y: 10 }; a
[01:34:25] -rusti- <anon>:9:47: 9:48 warning: variable does not need to be mutable [-W unused-mut (default)]
[01:34:26] -rusti- <anon>:9          struct Foo { x: int, y: int } let mut a = Foo { x: 5, y: 10 }; a
[01:34:26] -rusti-                                                         ^
[01:34:26] -rusti- {x: 5, y: 10}
[01:34:33] <MaikKlein> rusti: let a = 1; let ref b = a; b
[01:34:34] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/ibcK
[01:34:39] <strcat> anyway
[01:34:46] <strcat> if you borrow 'foo' as &mut
[01:34:51] <MaikKlein> rusti: let a = 1; let ref b = a; println(fmt!("%?",b));
[01:34:51] -rusti- application terminated abnormally with signal 11 (Segmentation fault)
[01:34:54] <MaikKlein> :X
[01:34:55] <strcat> you can't have refs to any of the fields as &mut or &
[01:35:01] <strcat> you can borrow foo.a as &mut and foo.b as &mut
[01:35:05] <strcat> or foo.a as &mut and foo.b as &
[01:35:08] <strcat> they don't overlap
[01:35:12] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Connection reset by peer)
[01:35:16] *** Joins: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net)
[01:35:21] <MaikKlein> rusti: let a = 1; let ref b = a; println(fmt!("%?",a));
[01:35:22] -rusti- <anon>:9:24: 9:29 warning: unused variable: `b` [-W unused-variable (default)]
[01:35:22] -rusti- <anon>:9          let a = 1; let ref b = a; println(fmt!("%?",a));
[01:35:22] -rusti-                                  ^~~~~
[01:35:22] -rusti- 1
[01:35:22] -rusti- ()
[01:35:26] <dbaupp> rusti: let a = 1; match a { ref b => println(fmt!("%?",b)) }
[01:35:27] -rusti- &1
[01:35:27] -rusti- ()
[01:35:41] <strcat> rusti: struct Foo { x: int, y: int } let mut a = Foo { x: 5, y: 10 }; let Foo { x: ref mut x, y: ref y }; *x = 10; (a, y)
[01:35:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LKFb
[01:35:46] <etw> strcat: that makes sense, I'm being protected from invalidating the iterator, but there's absolutely no way around that? 
[01:35:47] <strcat> rusti: struct Foo { x: int, y: int } let mut a = Foo { x: 5, y: 10 }; let Foo { x: ref mut x, y: ref y }; *x = 10; (a, *y)
[01:35:48] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LcEB
[01:35:54] <strcat> etw: no way around it, rust is memory safe
[01:35:59] <strcat> etw: what fields does step need?
[01:36:05] <MaikKlein> what is let ref doing?
[01:36:07] <strcat> etw: if it doesn't need engine.instructions there's no problem
[01:36:11] <etw> strcat: none yet, I'm just curious at this point
[01:36:15] <MaikKlein> Isn't it just a & ?
[01:36:22] <aatch> MaikKlein, it's doing a by-ref binding
[01:36:25] <strcat> etw: you can pass it a ref to every field in engine *except* the one you need to borrow for the loop
[01:36:33] <aatch> MaikKlein, yep.
[01:36:33] <MaikKlein> let a = 1; let b = &a:
[01:36:34] <strcat> etw: and it can receive references to inside that field from the loop itself
[01:36:41] <MaikKlein> would this be the same?
[01:36:45] <dbaupp> MaikKlein: it *should* be equivalent to the match { ref ... }, but it's clearly still broken
[01:36:48] <etw> strcat: thanks for your explanation though
[01:36:49] <dbaupp> MaikKlein: (yes)
[01:37:04] <strcat> etw: the rules are simple but the errors can be complex until you get used to it :)
[01:37:09] <MaikKlein> ok
[01:37:16] <mib_793nti> could someone explain to me what &@~ means? like let x = &@~9;
[01:37:24] <bjz> MaikKlein: I used to have them as traits
[01:37:26] <MaikKlein> haha
[01:37:35] <strcat> etw: since it just explains what the conflicts are and not why they are conflicting
[01:37:37] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:37:37] <bjz> MaikKlein: I just wish we had default methods :(
[01:37:40] <strcat> it could give better errors, for sure
[01:37:43] <dbaupp> mib_793nti: it's a reference to a managed pointer to a owned pointer to an int (with value 9)
[01:37:48] <strcat> it should say
[01:37:53] <MaikKlein> bjz, #[allow(default_methods)]
[01:37:54] <etw> strcat: yep, but I'm very impressed so far, most errors have been very clear
[01:38:06] <dbaupp> mib_793nti: (reference = &, managed pointer = @, owned pointer = ~)
[01:38:06] <strcat> 'cannot borrow engine as &mut because engine.instructions is borrowed as &, [explain why they can't overlap]'
[01:38:11] <strcat> would be ideal
[01:38:15] <bjz> MaikKlein: what about with generics and inlining?
[01:38:16] <MaikKlein> bjz, aatch said they work reasonably well ^.^
[01:38:22] <bjz> aatch: ^?
[01:38:23] <mib_793nti> dbaupp: ok so it's like a double pointer
[01:38:28] <dbaupp> mib_793nti: triple
[01:38:31] <engla> mib_793nti: since ~ and @ are called boxes, it's just nested boxes.
[01:38:44] <dbaupp> mib_793nti: & is a pointer too
[01:39:07] <strcat> rusti: struct Foo { x: int, y: int } let mut a = Foo { x: 5, y: 10 }; let Foo { x: ref mut x, y: ref y }; *x = 10; (a, *y)
[01:39:08] <MaikKlein> bjz, I think cross crate inlining doesn'T work
[01:39:08] <aatch> MaikKlein, yep, it's just from the fact that, syntactically, in `let a = b`, 'a' is a pattern.
[01:39:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/LBeN
[01:39:12] <mib_793nti> dbaupp: & is a borrowed pointer right? i thought those were just used as a parameter type so a function can take any type of pointer
[01:39:17] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[01:39:17] <aatch> it just so happens to be a very simple pattern.
[01:39:39] <aatch> mib_793nti, depends, it's also the address-of operator.
[01:39:42] <dbaupp> mib_793nti: yes, it's a borrowed pointer, it's also the "address of operator"
[01:39:52] <strcat> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo { x: ref mut x, y: ref y }; *x = 10;
[01:39:53] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/BiDR
[01:39:53] <dbaupp> aatch: we're clearly the same person :S
[01:39:56] <strcat> wtf
[01:40:05] <engla> mib_793nti: you can say that ~ and @ boxes are autoborrowed to & when passed to such a function.
[01:40:09] <strcat> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i };
[01:40:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/Ljgh
[01:40:22] <dbaupp> strcat: you aren't assigning anything there
[01:40:25] <strcat> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo {_, _} = a;
[01:40:25] -rusti- <anon>:9:85: 9:86 error: expected `}`, found `,`
[01:40:25] -rusti- <anon>:9          struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo {_, _} = a;
[01:40:25] -rusti-                                                                                               ^
[01:40:25] -rusti- application terminated with error code 101
[01:40:31] <aatch> strcat, strange error...
[01:40:34] <strcat> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo {x: _, y: _} = a;
[01:40:35] -rusti- <anon>:9:48: 9:49 warning: variable does not need to be mutable [-W unused-mut (default)]
[01:40:35] -rusti- <anon>:9          struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo {x: _, y: _} = a;
[01:40:35] -rusti-                                                          ^
[01:40:35] -rusti- ()
[01:40:40] <engla> mib_793nti: so & is a true pointer and ~ and @ are just boxes that need to be borrowed to & to be accessed.
[01:40:40] <dbaupp> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo { x: ref mut x, y: ref y } = a; *x = 10;
[01:40:41] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RZNb
[01:40:46] <strcat> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo {ref x: x, ref y: y} = a;
[01:40:46] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/aKFU
[01:40:59] <strcat> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo {x: ref x, y: y} = a;
[01:41:01] <dbaupp> strcat: it seems that let + ref is still broken
[01:41:01] <aatch> engla, they don't need to be borrowed.
[01:41:01] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cCDc
[01:41:13] <strcat> rusti: struct Foo { x: int, y: int }; let mut a = Foo { x: 5i, y: 10i }; let Foo {x: ref x, y: ref y} = a; (*x, *y)
[01:41:14] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bHWR
[01:41:22] <strcat> dbaupp: meh
[01:41:23] <strcat> ;p
[01:41:25] <aatch> Or more accurately, it depends on what, exactly, is going on.
[01:41:29] <mib_793nti> dbaupp: oh i didnt know there was a difference between a pointer and a box
[01:41:38] <MaikKlein> bjz, there might be some hiccups with generics too :/
[01:41:39] <dbaupp> mib_793nti: there isn't really
[01:41:41] <aatch> all three are pointers, with a runtime representation to match.
[01:41:53] <dbaupp> mib_793nti: the difference is the exact semantics of what @/~/& means
[01:42:06] <MaikKlein> bjz, I make some tests
[01:42:08] <doener> why does this work? https://gist.github.com/dotdash/5897846
[01:42:08] <aatch> engla, it's just that, currently, ~ and @ have a 32-byte header before the actual data.
[01:42:21] <aatch> They will be disappearing.
[01:42:25] <engla> yeah
[01:42:30] <strcat> doener: let bindings are currently totally unsound
[01:42:31] <bjz> MaikKlein: you woun't believe how many ICEs I've had over the past year with lmath
[01:42:37] <strcat> doener: just don't use patterns in let atm if you don
[01:42:40] <bjz> MaikKlein: related to generics
[01:42:43] <strcat> don't want to check correctness yourself*
[01:42:46] <dbaupp> mib_793nti: (the actual names of @/~ hasn't really be standardised on, some people call them boxes, some pointers, others (e.g. me) switch between them)
[01:42:56] <strcat> doener: use 'match x { pattern => result }' instead of let and it will error
[01:43:01] <aatch> strcat is trying to get rid of the ones on ~ now, and the ones on `@` will be gone when the new GC lands.
[01:43:12] <doener> strcat: ok, thanks
[01:43:13] <engla> aatch: what's incorrect about saying you need to borrow it to access it
[01:43:14] <strcat> aatch: they won't
[01:43:23] <aatch> strcat, they won't?
[01:43:25] <strcat> aatch: they're going to be around for ages
[01:43:27] <strcat> on @
[01:43:28] <dbaupp> strcat: https://github.com/mozilla/rust/pull/7262
[01:43:34] <aatch> awww :-(
[01:43:37] <strcat> aatch: and I don't care about @ so I'm not going to be wasting my time on it ;p
[01:43:44] <strcat> dbaupp: yep I know
[01:43:47] <strcat> dbaupp: he has a PR open fixing it
[01:43:50] <strcat> but it didn't land
[01:43:54] * strcat thought it did
[01:44:04] <strcat> dbaupp: oh
[01:44:05] <strcat> sorry
[01:44:09] <strcat> thought you linked to the issue :)
[01:44:11] <dbaupp> strcat: heh
[01:44:19] <roo> rusti: fn foo(():()) { }; foo(()) //is this related to an open issue?
[01:44:19] -rusti- error: internal compiler error: node_id_to_type: no type for node `expr () (id=11)`
[01:44:19] -rusti- application terminated with error code 101
[01:44:27] <strcat> roo: dunno
[01:44:28] <bjz> src/mat.rs:753:12: 753:13 error: only refutable patterns allowed here
[01:44:29] <aatch> roo, not sure. I don't think so.
[01:44:29] <bjz> src/mat.rs:753         let a = Mat4 { x: Vec4 { x: 1.0, y: 5.0, z:  9.0, w: 13.0 },
[01:44:36] <bjz> 8.
[01:44:46] <roo> i know its related to something closed a few months ago
[01:44:54] <bjz> (caret points to `a`)
[01:45:11] <bjz> why?
[01:45:11] <aatch> bjz, wtf?
[01:45:13] <mib_793nti> dbaupp: so "&" is acting as the address of operator (not a conversion from managed to borrowed) in this case: let x = &@~;
[01:45:24] <dbaupp> bjz: is `a` a static constant somewhere?
[01:45:31] <dbaupp> mib_793nti: correct
[01:45:44] <mib_793nti> dbaupp: oooook i think i get it
[01:45:50] <mib_793nti> dbaupp: thanks
[01:46:29] <bjz> dbaupp: noo
[01:46:37] <dbaupp> bjz: oh
[01:46:48] <bjz> src/mat.rs:849:12: 849:14 error: only refutable patterns allowed here
[01:46:49] <bjz> src/mat.rs:849         let f1 = 0.5;
[01:46:55] <bjz> (pointing to f1)
[01:46:58] <dbaupp> wtf
[01:47:14] <bjz> oh wait
[01:47:17] <dbaupp> (same error if you change it to foo_bar_baz_some_unique_name?)
[01:47:19] <bjz> it is a constant
[01:47:23] <bjz> :P
[01:47:27] <dbaupp> oh
[01:47:40] * dbaupp thinks constants should be linted to uppercase by default
[01:47:50] <bjz> yah
[01:47:51] <aatch> dbaupp, could be a lint check.
[01:47:52] <bjz> indeed
[01:47:56] <MaikKlein> bjz, https://gist.github.com/MaikKlein/5897863 this seems to work
[01:48:41] <strcat> aatch: if case was part of the grammar like haskell, it would remove ambiguity
[01:48:45] <bjz> MaikKlein: I'm dividing up the matrix tests btw
[01:48:46] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[01:48:46] <strcat> Foo(1, 2) // tuple struct constructor
[01:48:50] <strcat> foo(1, 2) // function call
[01:49:00] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[01:49:01] <strcat> there's value in enforcing those rules
[01:49:10] <dbaupp> strcat: (Foo could also be an enum variant)
[01:49:13] <bjz> MaikKlein: so if you were writing tests for mat, it's going to change abit
[01:49:18] <strcat> dbaupp: well that's essentially a tuple struct
[01:49:19] <bjz> MaikKlein: just a heads up
[01:49:23] <dbaupp> strcat: right
[01:49:28] <strcat> dbaupp: Foo{x: 5} can also be an enum variant
[01:49:32] *** Joins: yichoi (yichoi@B9B92496.8529BA9E.1C44CDAC.IP)
[01:49:34] <MaikKlein> bjz, ok
[01:49:35] <dbaupp> strcat: right
[01:50:13] <bjz> strcat: might be issues with C bindings though
[01:50:29] <strcat> bjz: #[link_name] ;p
[01:50:33] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[01:50:36] <MaikKlein> bzw does mozilla "own" Rust?
[01:50:51] <strcat> MaikKlein: no there isn't copyright assignment
[01:50:51] <MaikKlein> like Sun owns Java?
[01:50:58] <strcat> mozilla only "owns" the parts of rust written by mozilla employees
[01:51:27] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[01:51:46] <strcat> but it's licensed under permissive licenses so....
[01:52:07] <aatch> Dual MIT/Apache
[01:52:20] <bjz> <3 mozilla
[01:57:07] *** Quits: erickt1 (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[01:59:40] <mib_793nti> ive got another question. say you have let s = someType(args); (~s).someMethod(); // is "s" copied on the 2nd line?
[01:59:59] <dbaupp> mib_793nti: moved
[02:00:31] <aatch> mib_793nti, which means it depends on the type as to exactly what it does.
[02:00:32] <dbaupp> mib_793nti: (which means a memcpy, but you cannot use the `s` variable after (~s))
[02:01:00] <dbaupp> mib_793nti: (except if it is implicitly copyable, like int and float, in which case it is copied.)
[02:01:19] <bjz> MaikKlein: btw, I fixed the build
[02:01:21] <mib_793nti> dbaupp: say someType is a tuple struct
[02:01:29] <dbaupp> mib_793nti: yes, that's a move
[02:01:33] *** Joins: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net)
[02:02:12] <mib_793nti> dbaupp: ok so then I basically couldn't use s again? ever?
[02:02:24] <aatch> mib_793nti, in that particular example, yes.
[02:02:31] *** Quits: tikue (tkuehn@moz-A7CDB794.dia.static.qwest.net) (Quit: tikue)
[02:02:32] <MaikKlein> bjz, nice!
[02:02:35] <dbaupp> rusti: struct Foo(int, int); let s = Foo(1,2); let _ = ~s; s
[02:02:36] -rusti- {__field__: 1, __field__: 2}
[02:02:43] <dbaupp> hm, it seems to work
[02:02:50] <mib_793nti> dbaupp: how about (~s).someMethod() a 2nd time?
[02:02:58] <aatch> dbaupp, try assigning to something not `_`
[02:03:01] <dbaupp> mib_793nti: no, that shouldn't work
[02:03:07] <dbaupp> rusti: struct Foo(int, int); let s = Foo(1,2); let _x = ~s; s
[02:03:08] -rusti- {__field__: 1, __field__: 2}
[02:03:21] <mib_793nti> dbaupp: ha ok just wanted to make sure
[02:03:27] <aatch> dbaupp, hmm, odd. It must copy s
[02:03:30] <dbaupp> rusti: struct Foo(~[int]); let s = Foo(~[1]); let _x = ~s; s
[02:03:31] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/cGdV
[02:03:32] <aatch> it shouldn't.
[02:03:37] <MaikKlein> bjz, do you merge it later?
[02:03:46] * strcat tries
[02:03:47] <bjz> MaikKlein: it is pushed
[02:03:48] <aatch> since it's supposed to be move-by-default.
[02:03:50] <strcat> going to segfault
[02:04:04] <strcat> aatch: there are still implicitly copyable things
[02:04:16] <strcat> if a type doesn't have a destructor, a shallow copy isn't a move
[02:04:21] <dbaupp> rusti: struct Foo(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, ); let s = Foo(1,2,3,4, 1,2,3,4, 1,2,3,4, 1,2,3,4, ); let _x = ~s; s
[02:04:22] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/SGcO
[02:04:36] <dbaupp> rusti: struct Foo(int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, ); let s = Foo(1,2,3,4, 1,2,3,4, 1,2,3,4, 1,2,3,4 ); let _x = ~s; s
[02:04:38] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/VICg
[02:04:42] <strcat> it won't do a heap alloc from an implicit copy
[02:04:54] <strcat> it will copy any number of things that don't require an alloc
[02:04:58] <engla> I think bors should learn to hardwrap merge messages
[02:05:16] <dbaupp> aatch: it seems that (tuple) structs of implicitly copyable types are implicitly copyable
[02:05:38] <strcat> dbaupp: yes
[02:05:39] <strcat> and structs
[02:05:42] <strcat> tuples, enums
[02:05:51] <strcat> dbaupp: if a type has a destructor, it moves
[02:05:52] <aatch> strcat, oh ok. I though that only basic types were implicitly copyable, and it didn't propagate up.
[02:05:54] <strcat> that's the rule
[02:06:05] <dbaupp> strcat: I see
[02:06:32] <aatch> More accurately, I thought the rules had changed to that.
[02:07:35] <strcat> aatch: the part that changed was that Copy no longer lets you implicitly copy
[02:07:50] <aatch> strcat, ahh, so you have to do `copy`?
[02:07:51] <strcat> because you can copy vectors/strings via Copy
[02:07:51] <MaikKlein> bjz, uh nice!
[02:07:53] <strcat> aatch: yes
[02:08:03] <strcat> aatch: it was incorrect because it let you implicitly copy things with destructors
[02:08:08] <strcat> anyway Copy is going to die
[02:08:09] <bjz> MaikKlein: what tests were you writing?
[02:08:16] <strcat> and we can have POD instead for types without destructors
[02:08:23] <dbaupp> aatch: (as in, a generic with the Copy bound requires copy now)
[02:08:54] <MaikKlein> bjz, I didn't write any tests yet
[02:09:23] *** Joins: tjc (tjc@moz-BC436F15.hsd1.ca.comcast.net)
[02:09:23] *** ChanServ sets mode: +o tjc
[02:10:46] <bjz> MaikKlein: oh ok
[02:12:03] <roo> rusti: 1 = 1;
[02:12:05] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/DfgO
[02:12:26] <strcat> rusti: let 1 =  1;
[02:12:27] -rusti- <anon>:9:13: 9:14 error: refutable pattern in local binding
[02:12:27] -rusti- <anon>:9          let 1 =  1;
[02:12:27] -rusti-                       ^
[02:12:27] -rusti- error: aborting due to previous error
[02:12:27] -rusti- application terminated with error code 101
[02:12:59] <bjz> MaikKlein: it would be nice. I also have to work on the docs
[02:13:13] <bjz> MaikKlein: would be nice to have a github page eventually
[02:13:21] <MaikKlein> bjz, I can write some tests tomorrow
[02:13:24] <roo> rusti: let () = ();
[02:13:24] -rusti- ()
[02:13:38] <bjz> MaikKlein: awesome!
[02:13:41] <strcat> goodbye C++ vector code
[02:13:45] <strcat> I won't miss you
[02:13:52] <strcat>                     let alloc = n * sys::nonzero_size_of::<T>();
[02:13:54] <strcat>                     *ptr = realloc_raw(*ptr as c_void, alloc + sys::size_of::<VecRepr>);
[02:13:56] <strcat>                     (**ptr).unboxed.alloc = alloc;
[02:13:58] <strcat> seems to work
[02:14:00] <strcat> ;p
[02:14:09] * strcat will leave the managed/managed-unique vector code in C++ for now
[02:14:09] <MaikKlein> bjz, hm we might want to focus on the lib first, to make it stable and add some core functionality. I can write some examples then
[02:14:21] <bjz> MaikKlein: I also have some color types in the works
[02:14:31] <dbaupp> "static constant should have an uppercase identifier
[02:14:31] <dbaupp> static STATE_ONE: State = 1;"
[02:14:31] <dbaupp> I think I implemented it wrong
[02:14:36] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[02:14:38] <bjz> RGB, RGBA, HSV, HSVA
[02:14:44] <MaikKlein> bjz, ah cool
[02:15:00] <aatch> dbaupp, heh, probably doesn't account for the '_'
[02:15:23] <MaikKlein> bjz, but you haven't worked on sth like mat::translate(vec4) yet?
[02:15:31] <dbaupp> aatch: it's checking `c != '_' || !c.is_uppercase()`, so I need an uppercase _ :/
[02:15:42] <dbaupp> aatch: (it should be/now is &&)
[02:15:58] <MaikKlein> bjz, or mat::rotate(axes: vec4, angle);
[02:16:15] <roo> i don't have to do anything other than provide an example that breaks when reporting a bug do I?
[02:16:15] <engla> dbaupp: some scripts don't have lower/uppercase. So japanese script rust programmers might find trouble
[02:16:21] <MaikKlein> bjz, I think I could also add those if you want
[02:16:55] <dbaupp> engla: right, it's the same problem with the non_camel_case_types lint
[02:16:58] <MaikKlein> bjz, or do have already something to get a translation, rotation etc matrix?
[02:17:05] <engla> ah it's just a lint
[02:17:05] <aatch> dbaupp, yeah, probably better to check for 'a'..'z'
[02:17:37] <dbaupp> engla: I guess !c.is_lowercase() might work better
[02:18:12] <aatch> dbaupp, do the is_{upper,lower}case use the unicode tables?
[02:18:17] <dbaupp> aatch: not yet
[02:18:27] <aatch> dbaupp, ah.
[02:18:35] <engla> dbaupp: yes
[02:18:38] <dbaupp> aatch: wait, I lie
[02:18:41] <dbaupp> aatch: they do
[02:19:13] <MaikKlein> bjz, I am also writing a scene graph and a opengl abstraction layer. We might have some pretty good opengl support in the future :)
[02:19:51] <strcat> doener: vec_reserve_shared is no more ;p
[02:21:26] <doener> what? No more confusion about vec_reserve_shared being unique? :-(
[02:21:29] <doener> :-D
[02:21:32] <mib_793nti> MaikKlein: you're writing an opengl wrapper for rust?
[02:21:38] <strcat> doener: yep
[02:21:42] <strcat> it's rust now
[02:21:47] <doener> hehe
[02:22:25] <bjz> MaikKlein: https://github.com/bjz/gl-rs
[02:22:42] <bjz> MaikKlein: hopefully we will have a function loader soon
[02:23:07] <dbaupp> rusti: #[deny(non_camel_case_types)] struct ;
[02:23:08] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/SRGc
[02:23:16] <bjz> MaikKlein: I plan to have a version that uses static muts
[02:23:28] * bjz nudges nmatsakis
[02:23:53] <aatch> bjz, what do you need nmatsakis for?
[02:24:02] <dbaupp> aatch: #6661
[02:24:05] <bjz> aatch: extern fn patch
[02:24:38] <dbaupp> bjz: (I'm lead to believe that's blocked on an LLVM upgrade, so you could also nudge acrichto who seems to be try to get that to go through)
[02:24:56] <aatch> Also, brson has taken issue with it.
[02:24:57] * bjz nudges acrichto
[02:25:14] <acrichto> llvm upgrade?
[02:25:17] <doener> is there a way to just check whether two @mut point to the same thing?
[02:25:35] <aatch> doener, somewhere in std::ptr I think
[02:25:36] <dbaupp> acrichto: https://github.com/mozilla/rust/pull/7115 ?
[02:25:44] <aatch> doener, or std::managed
[02:25:46] <bjz> aatch: I would like to be able to say confidantly on ##OpenGL that rust has first class GL support
[02:25:51] <strcat> doener: checking that the @mut values are equal would assume the gc is non-moving
[02:25:59] <acrichto> bjz: that was blocked on a bug in windows during compilation that was never resolved
[02:26:01] <strcat> use ref_eq(&*x, &*y)
[02:26:10] <bjz> acrichto: indeed :(
[02:26:10] <acrichto> bjz: it also could use more patches then exist today
[02:26:17] <acrichto> I remember trying it recently and it still failed on windows
[02:26:21] <strcat> doener: if there is ever a moving gc, borrows will pin them
[02:26:28] <bjz> acrichto: damn windows :(
[02:26:34] <MaikKlein> mib_793nti, yeah
[02:26:34] <doener> strcat: I mean the things in the box, not the boxes themselves.
[02:26:42] <acrichto> bjz: yeah I would try to debug it if possible but I have no access to windows machines
[02:26:55] <MaikKlein> mib_793nti, but I still have to wait for external function pointers
[02:27:10] <doener> strcat: a moving gc won't duplicate the contents, will it?
[02:27:18] <MaikKlein> bjz, yeah I am checking everyday for EFP :D
[02:27:24] <strcat> doener: no but it could move it in between converting the first @mut to a uint and the 2nd
[02:27:32] <strcat> doener: unlikely but... it could
[02:27:40] <bjz> MaikKlein: what do you think of the loader?
[02:27:49] <bjz> MaikKlein: atm it uses a struct
[02:28:08] <bjz> MaikKlein: but we will be able to use static muts too
[02:28:20] <strcat> doener: you should see how pypy's experimental good gcs have to implement id() ;p
[02:28:25] *** Quits: brson (brson@6A848D32.C1B840DD.76F66111.IP) (Ping timeout)
[02:28:32] <doener> strcat: I'll just trust std::managed::mut_ptr_eq does the right thing
[02:28:40] <strcat> doener: yeah you can assume that
[02:28:44] * strcat didn't know it existed
[02:28:45] <bjz> MaikKlein: the struct might be useful for folks who want multiple contexts though
[02:28:50] <mib_793nti> MaikKlein: are you planning on something similar to the C API or an object oriented sort of thing?
[02:29:07] <bjz> MaikKlein: I'm trying to work out how to parse the registry xml
[02:29:13] <MaikKlein> mib_793nti, yeah on somthing functional / oop , not sure yet 
[02:29:16] <bjz> MaikKlein: in generator
[02:29:48] <MaikKlein> bjz, it definitely looks really nice, I can't wait to write some opengl stuff in rust
[02:30:12] <MaikKlein> bjz,  and I have no experience with glLoadGen , I always used the hmm
[02:30:25] <MaikKlein> bjz, unofficial opengl sdk
[02:30:34] <bjz> MaikKlein: if you could help me figure out the xml stuff that'd be brilliant, but no worries if you busy
[02:30:37] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[02:30:58] <mark_edward> bjz: yo'
[02:31:00] <MaikKlein> bjz, I am busy for the next two weeks, I am writing 3 exams
[02:31:06] <bjz> MaikKlein: basically it loads the function pointers at runtime, so you don't link them statically
[02:31:08] <MaikKlein> bjz, but then I have plenty of time
[02:31:14] <bjz> nice
[02:31:34] <bjz> MaikKlein: I really appreaciate the help on lmath, it's really boosted my morale :)
[02:32:07] <aatch> bjz, well I'm pretty sure I know how to deal with the static mut problem, as in the problem of them not being directly callable.
[02:32:17] <mark_edward> bjz:  you called
[02:32:36] <MaikKlein> bjz, haha the first time I knew that I wanted to use rust for my game engine I was like " oh man I have to write a wrapper for glfw , write some math library ..." but then I saw it's already there :)
[02:32:37] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[02:33:10] *** mib_793nti is now known as mofe
[02:33:50] <bjz> mark_edward: I pushed my generator test - it's pretty ugly atm, and segfaults
[02:34:08] <roo> rusti: let n = 0; (n,1) = (1,1);
[02:34:09] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/OYcI
[02:34:18] <bjz> mark_edward: https://github.com/bjz/gl-rs/blob/master/generator/registry.rs#L12
[02:34:27] <MaikKlein> bjz, I might use rust for a physics engine. I need to write a small one for an exam. I can't wait until we have c++ support, then I can port bullet to rust
[02:34:52] <bjz> mark_edward: might not be curl though - could be libxml
[02:35:03] <roo> rusti: let mut n = 0; (n,1) = (1,1);
[02:35:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/OhiH
[02:35:05] <bjz> MaikKlein: awesome
[02:35:34] <aatch> roo, you can only have pattern binding in let, and then only irrefutable patterns.
[02:35:35] * bjz envisions a physics lib done with lmath, but realises the effort would be enormous
[02:35:45] <roo> its still an ice
[02:35:45] <mark_edward> bjz: what exactly are you doing?
[02:35:54] <mark_edward> what are you generating?
[02:36:06] <strcat> doener: making with_capacity use 1 alloc should be trivial now that there's contains_managed
[02:36:07] <bjz> mark_edward: I use curl to write to a file
[02:36:10] <aatch> roo, yes, and theres an issue open for it.
[02:36:11] <strcat> doener: I'll do that next
[02:36:22] <roo> oh, ok, didn't know
[02:36:24] <strcat> doener: https://github.com/thestinger/rust/commits/vec :)
[02:36:49] <MaikKlein> mark_edward, opengl bindings, so that we can generate bindings for say OpenGL 4.3
[02:36:53] <bjz> mark_edward: instead of storing the string in memory, then writing to a file
[02:37:02] <mark_edward> ah, i see
[02:37:07] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:37:14] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:37:26] <mark_edward> how could i support this behavior?
[02:37:41] <MaikKlein> https://github.com/bjz/gl-rs
[02:37:59] <bjz> mark_edward: no idea, I think it might be best to wait for the better io
[02:38:12] <mark_edward> cool
[02:38:20] <bjz> mark_edward: atm I heve to use a @Writer which is difficult
[02:38:48] <bjz> mark_edward: maybe I could just do it the ugly way of loading the string first, then writing
[02:38:51] <mark_edward> you guys are all writting cool things. i want to make full=blooded http_clieent now
[02:38:53] <bjz> fix it up later
[02:38:57] <MaikKlein> bjz, why is a @Writer difficult?
[02:39:16] <strcat> @Writer is unsound
[02:39:26] <MaikKlein> bjz, oh you are trying to parse xml?
[02:39:34] <bjz> MaikKlein: yah
[02:39:35] <strcat> a lot of that stuff relies on converting slices to/from writers
[02:39:35] <doener> strcat: nice :-)
[02:39:52] <bjz> MaikKlein: see the readme: https://github.com/bjz/gl-rs/tree/master/generator
[02:39:56] <strcat> doener: I think I can probably zap the headers from non-managed ~[] first
[02:40:05] <strcat> doener: probably not that many places to update the offset
[02:40:17] <strcat> can add a new unique_malloc
[02:40:19] <strcat> ;p
[02:40:24] <strcat> it can just be on malloc_raw
[02:40:35] <aatch> strcat, I think most of the places are in the lib.
[02:41:12] <doener> strcat: at least one of us is getting stuff done. I'm about to give up on the scope stuff for today, can't seem to get it right, at least not as a "small scale" change
[02:41:34] * strcat is doing this thing very slowly
[02:41:39] <strcat> iteratively
[02:41:45] <strcat> just ripping out all the headers would be impossible ;p
[02:42:10] <MaikKlein> bjz, and I also wanted to work on some kind of autocompletion for rust, haha so many projects :x
[02:42:19] <doener> ... I'm trying to support scopes within a single llvm basic block, instead of requiring a new block for each scope.
[02:42:27] <strcat> doener: ah, neat
[02:42:33] <doener> But getting the cleanups right isn't exactly trivial
[02:43:09] <MaikKlein> ok it is 5pm the birds are already twittering, time for me to go to bed :) gn8 all
[02:43:17] <strcat> 5am? ;p
[02:43:32] <doener> MaikKlein: don't lie, it's just 4:40am
[02:43:39] <MaikKlein> ups
[02:43:40] <doener> ;-p
[02:43:47] <MaikKlein> am I mean
[02:43:51] <MaikKlein> doener, haha
[02:44:21] <MaikKlein> doener, I see your sleep cycle is pretty broken too :D ?
[02:45:03] <engla> birds have twitter now too?
[02:45:10] <doener> I have two weeks holidays, spent the first day/night on the self double indirection fix and since then it's all messed up
[02:45:40] <MaikKlein> haha
[02:46:13] *** Joins: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP)
[02:46:13] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/nFBeeg
[02:46:13] *** Parts: ghrust (ghrust@AD60B2E3.6A2AE50.F3114085.IP) ()
[02:47:11] <aatch> acrichto, hopefully turning on thread safety works this time.
[02:47:29] * acrichto crosses fingers
[02:48:00] <bjz> MaikKlein: night!
[02:48:07] <bjz> MaikKlein: thanks again!
[02:48:07] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[02:48:22] <dbaupp> doener: it's holidays, *obviously* going to bed at night would be silly ;P
[02:48:46] <huhlig-home> can rust do dynamic library loading currently?>
[02:49:13] <dbaupp> huhlig-home: what do you mean?
[02:49:20] <huhlig-home> shared libraries
[02:49:26] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[02:49:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/wteQZw
[02:49:27] <ghrust> 13rust/06auto 14fcad966 15Alex Crichton: Turn on using LLVM threadsafely
[02:49:27] <ghrust> 13rust/06auto 145c9492f 15bors: auto merge of #7409 : alexcrichton/rust/threadsafe, r=catamorphism...
[02:49:27] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[02:49:32] <huhlig-home> .dllL, .so etc 
[02:49:40] <acrichto> huhlig-home: you should be able to write 'extern mode rustc'
[02:49:42] <huhlig-home> preferably on 64 bit environments
[02:49:42] <dbaupp> currently std, extra, etc are all dynamically loaded, but do you mean choosing a library to load at runtime
[02:49:54] <huhlig-home> dbaupp, yea
[02:50:03] <dbaupp> there's `std::unstable::dynamic_lib`
[02:50:57] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Ping timeout)
[02:52:00] *** Quits: zz_kimundi (kimundi@moz-E9BB74CC.dip0.t-ipconnect.de) (Ping timeout)
[02:53:04] <strcat> ok hm
[02:53:11] <strcat> can a lang item be generic? I guess so
[02:53:29] <aatch> strcat, should be. might be a little difficult to call though.
[02:53:38] <sp3d> is there an issue about the preceding comma in error messages' types like `std::iterator::FlatMapIterator<,&~str,<V6>,foo>` ?
[02:53:49] <dbaupp> strcat: you can have lang items on trait methods
[02:53:55] <strcat> sp3d: it's because lifetimes don't print properly
[02:53:57] <dbaupp> sp3d: probably not
[02:54:13] <sp3d> strcat: ah, that was non-obvious
[02:54:16] <strcat> me
[02:54:19] <strcat> meh
[02:54:25] <strcat> I will just switch exchange_malloc to have the signature....
[02:54:26] <aatch> strcat, used to be worse... used to use the old syntax, then it was using Foo<no-bounds>
[02:54:31] <strcat> exchange_malloc(align, size)
[02:54:33] <strcat> for now
[02:54:43] <strcat> when the header is gone it can be exchange_malloc(size)
[02:54:55] <sp3d> presumably I should be searching for "lifetime", not "comma", then
[02:55:02] <strcat> sp3d: or 'region'
[02:55:06] *** Joins: zz_kimundi (kimundi@moz-58389D08.dip0.t-ipconnect.de)
[02:55:21] <strcat> anyway
[02:55:32] *** zz_kimundi is now known as kimundi
[02:55:35] <strcat> tydescs are no longer *stored* by exchange_malloc
[02:55:38] <strcat> but it gets passed one
[02:55:39] <aatch> sp3d, it's probably in rustc::util::ppaux
[02:55:42] * strcat is putting a stop to that
[02:56:07] <aatch> there's a function that does the type parameters/bounds
[02:56:34] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[02:58:52] <sp3d> thanks
[02:59:41] <acrichto> r? https://github.com/mozilla/rust/pull/7520
[03:00:12] <strcat> stupid codegen sucks
[03:00:18] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[03:00:41] <zslayton> I'm seeing a test fail on make check on x86_64 Linux (tests::package_script_with_default_build in librustpkg/tests.rs). I've looked through the function and it doesn't appear to use any code I've worked on. Is there any chance this is a known problem?
[03:00:55] <zslayton> What's a good next step?
[03:01:05] <strcat> zslayton: it's consistently failing on some systems
[03:01:08] <strcat> you didn't break it
[03:01:17] <zslayton> strcat: Phew!
[03:01:29] <zslayton> strcat: Thanks!
[03:04:15] <strcat> alright
[03:04:22] <strcat> opub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {
[03:04:25] <strcat> old
[03:04:27] <strcat> pub unsafe fn exchange_malloc(align: i32, size: uintptr_t) -> *c_char {
[03:04:30] <strcat> new
[03:04:32] <strcat> lets see if it works...
[03:04:52] <doener> trans_rvalue_dps_unadjusted -- what does dps mean?
[03:05:07] * strcat hopes nothing else uses this lang item
[03:05:16] <strcat> just malloc_raw_dyn, *please* ;p
[03:05:47] <strcat> I really hate how we use this awful dynamic tydesc crap
[03:05:55] <strcat> when we have the static info everywhere but traits and closures
[03:06:08] <strcat> and the trait/closure should be responsible for dealing with it, not the allocator...
[03:06:22] <aatch> strcat, yep. I reckon that most of the pointer casts are bogus.
[03:06:33] <aatch> as in, we know the type from beginning to end.
[03:07:05] <strcat> aatch: http://ix.io/6ry/diff my attempt at removing the last trace of tydesc from exchange allocs
[03:07:25] <strcat> the align param can be dropped completely when the header is gone
[03:07:33] <strcat> ugh typo
[03:08:24] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Ping timeout)
[03:08:31] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[03:08:37] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[03:09:37] <strcat> this better work ;p
[03:10:03] <strcat> aatch: the ~ codegen is already much nicer though :)
[03:10:12] <strcat> aatch: since it no longer copies/inits the header
[03:10:41] <aatch> strcat, yay. that should take some pressure off of LLVM
[03:11:19] <strcat> aatch: http://ix.io/6rz before ;p
[03:11:31] <strcat> and now just
[03:11:34] <strcat> let total_size = get_box_size(size as uint, align as uint);
[03:11:39] <strcat> malloc_raw(total_size as uint) as *c_char
[03:11:58] <strcat> once the header is gone, #[lang = "exchange_malloc"] can go *directly* on malloc_raw
[03:12:16] *** Quits: tjc (tjc@moz-BC436F15.hsd1.ca.comcast.net) (Quit: Places to go, people to annoy)
[03:13:05] <strcat> aatch: exchange_count_ptr() was actually a 2nd ffi call ;\
[03:13:26] <aatch> strcat, really?
[03:13:26] <strcat> + atomic increments/decrements, ruining parallel perf
[03:13:30] <strcat> aatch: yep
[03:13:37] <strcat> aatch: it asked C++ to hand a pointer to the global
[03:13:42] <strcat> and then did atomic crap on it
[03:14:06] <strcat> it's still ridiculous that we have a 4 word header on every exchange allocation but...
[03:14:09] <strcat> I will fix it
[03:14:11] <strcat> ;p
[03:15:32] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[03:17:10] <acrichto> strcat: did you actually benchmark just removing the atomic add/subtract?
[03:18:44] <strcat> acrichto: only on single-threaded code, where it wasn't a big deal
[03:19:03] <acrichto> strcat: I'm curious, because malloc vs locking-the-bus is not really a competition at all
[03:19:11] <strcat> acrichto: are you sure about that?
[03:19:16] <acrichto> strcat: yes
[03:19:16] <strcat> malloc takes 20ns for small objects
[03:19:21] <strcat> it doesn't do a syscall
[03:19:33] <dbaupp> ping cmr
[03:19:35] <acrichto> if you have a super-fast malloc
[03:19:46] <strcat> acrichto: glibc/jemalloc/tcmalloc 
[03:19:55] <strcat> 20-100ns for small objects (amortized)
[03:19:57] <acrichto> strcat: but for every allocation size that we ask for it's 20ns?
[03:20:10] <strcat> acrichto: no that's amortized, like "O(1)" array append
[03:20:27] <strcat> when the pool fills it calls mmap
[03:20:36] <strcat> so that's a context switch to kernel space
[03:20:38] <acrichto> strcat: yeah I was also just curious, all of my knowledge is that "malloc is incredibly slow" but people have obviously tried to fix that
[03:20:54] <strcat> acrichto: basically, glibc/tcmalloc/jemalloc have a thread-local arena for up to 4K allocations
[03:21:06] <acrichto> of course mmap is incredibly slow, but even just doing the stuff necessary for making an allocation can be incredibly slow, but I wasn't sure how fast modern implementation swere
[03:21:27] <strcat> acrichto: http://goog-perftools.sourceforge.net/doc/tcmalloc.html this is very out of date but it explains it fairly well
[03:21:47] <strcat> also their benchmarks are on a pentium4 ;p
[03:22:21] <strcat> glibc/jemalloc/tcmalloc are very competitive for single-threaded, jemalloc/tcmalloc pull ahead with more than a few threads (they scale linearly for small allocs)
[03:22:23] <acrichto> yeah I definitely believe they're super fast, I was just curious how an atomic add actually affected perf
[03:23:10] <strcat> acrichto: well I don't have hard numbers :), except that my changes (removing the initialization + increments/decrements) made it 5-10% faster on single-threaded
[03:23:11] <acrichto> aww bors failed
[03:23:22] <strcat> but to measure the atomic cost you'd need to do a proper contention bench
[03:23:36] <acrichto> strcat: I think you're right in that reducing the header from 4 words would speed up perf by a huge amount
[03:23:48] <strcat> acrichto: yep because we're jumping 2 size classes
[03:23:58] <strcat> acrichto: the smallest size class is 16 bytes (everything is rounded up to that)
[03:24:05] <strcat> the next (with glibc/tcmalloc/jemalloc) is 32 bytes
[03:24:07] <strcat> and we miss that too
[03:24:19] <strcat> so we're hitting either 48/64-byte for an 8-byte alloc depending on the allocator
[03:24:21] <strcat> really sucks.
[03:24:26] <strcat> we're filling a WHOLE cache line
[03:24:29] <strcat> for an integer
[03:24:39] <acrichto> yeah that's absurd
[03:24:40] *** Quits: cubic_ (cubic@moz-FE5AD6C7.mc.videotron.ca) (Ping timeout)
[03:25:01] <acrichto> so have the last users of the headers been removed now?
[03:25:10] <acrichto> or are the headers only going to be removed for unique allocations?
[03:25:17] <strcat> acrichto: for exchange allocations, there are no more users
[03:25:18] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[03:25:18] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/O9U9iw
[03:25:18] <ghrust> 13rust/06auto 145d46bcc 15Huon Wilson: Remove vec::{rfind, rfind_between, find_between}, replaced by slices and iterator adapators.
[03:25:18] <ghrust> 13rust/06auto 1445940ed 15Huon Wilson: Remove vec::[r]position_between, replaced by slices & iterators.
[03:25:18] <ghrust> 13rust/06auto 14a890c2c 15Huon Wilson: Convert vec::{rposition, rposition_elem, position_elem, contains} to methods.
[03:25:20] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[03:25:27] <strcat> acrichto: so, ~ and ~[] not containing @
[03:25:36] <strcat> so I will try to remove the headers from them next
[03:25:46] <strcat> other things don't need headers once the gc lands + tons of work happens ;p
[03:26:09] <acrichto> yeah, but I imagine that could take a sec
[03:26:30] <strcat> acrichto: http://ix.io/6rA what our ~ *should* be (when it doesn't include @)
[03:27:01] <strcat> whoops I left one thing at init() that could be uninit() now
[03:27:53] <acrichto> strcat: so do you know why the type_desc was ever stored in the header to begin with?
[03:28:08] <strcat> acrichto: ~fn uses it, I gave ~fn a temporary allocator
[03:28:23] <strcat> acrichto: and traits used to use it for glue, but now they store a tydesc in the vtable (as they should)
[03:28:24] <acrichto> strcat: what did ~fn use it for?
[03:28:28] <strcat> acrichto: captures
[03:28:30] <strcat> since that's dynamic
[03:28:36] <strcat> it should store it inside the body of the alloc
[03:28:38] <strcat> it abused the header instead
[03:28:41] <strcat> oh well
[03:28:44] <acrichto> what'd dynamic about it?
[03:28:46] <strcat> it has an allocator all to itself to abuse
[03:28:46] <yichoi> hmm should I retry bors ?
[03:28:57] <strcat> acrichto: ~fn() is a type, but it can capture different things
[03:29:00] <strcat> acrichto: not exposed in the type
[03:29:10] <strcat> so if you're passed an ~fn, the ~fn needs to know what it has inside and how big it is
[03:29:16] <acrichto> strcat: yeah but it's know what the type of everythin being captured is?
[03:29:23] <strcat> acrichto: yes
[03:29:31] <strcat> acrichto: and how big it all is, also stored in the tydesc
[03:29:46] <acrichto> strcat: I guess I thought that was the env pointer, I'm actually not sure what the actual difference betwee ~fn &fn and @fn are
[03:30:02] <strcat> acrichto: they all have headers
[03:30:13] <strcat> (yes, stack closures have headers - on the stack, it's embarassing ;p)
[03:30:30] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[03:30:34] <strcat> acrichto: every single rust function is currently passed an env pointer as the first param too ;p
[03:30:41] <strcat> every non-closures
[03:30:43] <strcat> we need to remove that
[03:30:52] <strcat> even non-closures*
[03:30:58] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[03:31:05] <acrichto> interesting..., is there a spot with structs representing &fn ~fn and @fn?
[03:31:09] <strcat> acrichto: https://github.com/mozilla/rust/pull/7495 that was the PR I landed making exchange allocs not such as much
[03:31:28] <acrichto> strcat: yeah I saw that, although it looked mostly like just stopping touching things
[03:31:32] <doener> strcat: IIRC someone said that the env pointer is to be kept on bare fns
[03:31:41] <acrichto> although I don't understand why ~fn changes work, nor why there were needed before
[03:31:46] <strcat> doener: well I talked to pcwalton about it and he said we can kill it
[03:32:12] <strcat> acrichto: librustc/middle/trans/closure.rs
[03:32:18] <strcat> big block comment at the top with the layout
[03:32:26] <strcat> intricate details about how it abuses the header :)
[03:32:38] <strcat> using == abusing though since it shouldn't exist
[03:32:56] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[03:33:04] <doener> strcat: ah, it was nmatsakis -- https://botbot.me/mozilla/rust/msg/4065646/
[03:33:48] <strcat> doener: well the trick for coercing is simple
[03:33:53] <strcat> have a global, immutable env with nothing in it
[03:33:55] *** Joins: alisdair (textual@F511297F.DC0F4EDA.115CE8E4.IP)
[03:33:56] <dbaupp> doener: couldn't there be a default "empty env" pointer
[03:33:59] <strcat> when you coerce extern fn to &fn, use that
[03:34:58] <acrichto> strcat: so why do other users need to know how big ~fn is? It seems that everyone's just passing around a pointer except for the ~fn itself and of course it knows how big it its
[03:35:01] <doener> isn't that the other direction?
[03:35:09] <strcat> acrichto: they don't
[03:35:24] <strcat> acrichto: it's only in the header because ~fn is being stupid and not storing it in the body
[03:35:32] * doener is confused and sleepy and should probably call it a day
[03:35:37] <strcat> acrichto: I didn't want to rewrite ~fn
[03:35:39] <strcat> so I made it an allocator
[03:35:53] <acrichto> strcat: huh, interesting
[03:36:02] <strcat> I care about making rust a viable systems language first and foremost right now, so that means making ~ sane
[03:36:13] <strcat> can't call it a systems language when it has 4 word headers in allocs ;p
[03:36:35] <strcat> anyway I'm not going to spend any time on @/@mut or heap closures atm
[03:36:39] <acrichto> it seems like @ should have a 3-word header (at most), and everything else should have no header at all...
[03:36:39] <strcat> one thing at a time :)
[03:36:44] <strcat> acrichto: no header
[03:36:50] <strcat> acrichto: it should be gc'ed
[03:37:00] <strcat> ;p
[03:37:02] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[03:37:02] <acrichto> strcat: no header for @?
[03:37:05] <acrichto> oh
[03:37:06] <acrichto> I see
[03:37:09] <strcat> acrichto: no header for @, 1-word header for @mut
[03:37:31] <acrichto> it also seems like @ should be passed around as a poitner to the data, not a pointer to the bux
[03:37:34] <acrichto> same thing with @mut
[03:37:36] <strcat> acrichto: extra::rc has a 1-word header for the refcount
[03:37:53] <strcat> the value is first, so a pointer to the box is a pointer to the value (for extra::rc)
[03:37:56] * strcat did that intentionally
[03:38:24] <acrichto> strcat: yeah but the compiler itself seems like it should only pass around pointers to the actual data
[03:38:24] <strcat> brson actually asked me to switch from casting the box to the value to an explicit deref/ref because it was unclear ;p
[03:38:38] <strcat>         unsafe { cast::copy_lifetime(self, &(*self.ptr).value) }
[03:38:46] <strcat> could just be returning self.ptr (with a new lifetime)
[03:38:50] <strcat> it compiles to the same thing anyway.
[03:39:01] <acrichto> strcat: it's probably a lot better to actually access '.value' ...
[03:39:16] <strcat> anyway extra::rc::Rc is essentially a "perfect" refcounted type
[03:39:22] <acrichto> it also seems like passing around just the pointers to the data makes more sense because then everything has the same representation (disregarding headers)
[03:39:25] <strcat> the handle is a ptr, the box has 1 word for a count
[03:39:34] <strcat> borrowing as & or &mut is the identity function
[03:39:42] <strcat> and it moves, so you can pass it by-value without a refcount
[03:39:49] <strcat> RcMut is a mess due to dynamic freezes
[03:39:51] <strcat> oh well.
[03:40:20] <acrichto> strcat: how many lang_item mallocs are there?
[03:40:22] <btipling> is there a weekly stable release
[03:40:31] <btipling> hrm
[03:40:32] <strcat> acrichto: local_malloc, local_free, exchange_malloc, exchange_free
[03:40:34] <aatch> btipling, nope.
[03:40:41] <btipling> I downloaded the 0.6 I think
[03:40:44] <strcat> acrichto: and I added closure_exchange_malloc (uses the same free)
[03:40:46] <acrichto> strcat: local == @, exchange == ~ ?
[03:40:46] <aatch> We should have nightlies eventually.
[03:40:51] <btipling> and have been reading the 0.7 tutorial and docs
[03:40:51] <strcat> acrichto: not exactly
[03:41:02] <acrichto> strcat: well ~[@] == @ ?
[03:41:02] *** Joins: alicedare (textual@1E3F14AE.29819A33.115CE8E4.IP)
[03:41:09] <strcat> acrichto: yeah
[03:41:19] <btipling> are you guys building trunk?
[03:41:20] <strcat> acrichto: ~ containing @ is managed-unique and uses the local alloc/free
[03:41:21] <btipling> or using 0.6
[03:41:33] <strcat> btipling: not much point in using 0.6
[03:41:34] <aatch> btipling, what platform you on?
[03:41:37] <btipling> mac os x
[03:41:45] <acrichto> strcat: that seems unfortunate because then ~[@] has headers on the outside vector?
[03:41:45] <btipling> I just followed the tutorial
[03:41:53] <btipling> rustc 0.6
[03:41:55] *** Quits: alisdair (textual@F511297F.DC0F4EDA.115CE8E4.IP) (Ping timeout)
[03:42:03] <strcat> acrichto: yes, but either way ~[] and ~ will be managed by the gc
[03:42:06] <strcat> acrichto: I don't care
[03:42:09] <btipling> ok so I guess I have to checkout the github and build from that then eh :/
[03:42:14] <strcat> acrichto: if you use @, it's slow
[03:42:18] <btipling> another 45 minutes 
[03:42:21] <strcat> the headers aren't going to be the biggest issue
[03:42:43] <strcat> fast code -> use unique pointers, and *sparingly* use refcounted ones for long-lived objects
[03:42:43] <btipling> is the github the official repository or a mirror?
[03:42:53] <doener> btipling: there's a 0.7-pre release that was cut today
[03:42:55] <acrichto> strcat: yeah but ~[@] is still an owned vector that just can't be sent anywhere
[03:42:56] <mofe> btipling: 0.7 pre release got posted earlier
[03:43:03] <strcat> acrichto: well it's not actually an owned vector
[03:43:07] <strcat> acrichto: it's managed-unique ;p
[03:43:11] <strcat> different type
[03:43:13] <btipling> I'm just going to build from the repo when it's green, there's a waterfall somewhere right
[03:43:15] <acrichto> strcat: in the sense that there's one owner it's owned?
[03:43:26] <strcat> acrichto: well in the sense that it's the same actual type with the same memory representation
[03:43:45] <strcat> acrichto: it uses a different allocator, a different reserve path, etc.
[03:43:56] <aatch> btipling, yep.
[03:43:59] <acrichto> strcat: it seems like 5 alloc/free functions is 3 too many...
[03:44:07] <aatch> I'm hunting down the 0.7 pre-release though
[03:44:23] <strcat> acrichto: sure, I'd prefer a language with no @ and @mut at all ;p
[03:44:26] <aatch> btipling, oh, and the tree is almost always green
[03:44:43] <acrichto> strcat: even with it, why have more than one malloc/free?
[03:44:55] <strcat> acrichto: because the local ones build linked lists
[03:44:58] <strcat> and other crap
[03:45:02] <btipling> http://buildbot.rust-lang.org/builders
[03:45:09] <strcat> acrichto: they leak memory and free it when the task dies
[03:45:10] <strcat> from cycles
[03:45:32] <acrichto> strcat: yeah I guess it's actually already @ built on malloc and just setting up box stuff
[03:45:41] <acrichto> strcat: doing that all in codegen would probably be a bit too expensive
[03:45:43] <strcat> acrichto: yeah but eventually it will be a gc-managed heap
[03:45:46] <strcat> not malloc/free
[03:45:56] <strcat> local_malloc/local_free will use the gc heap
[03:45:56] <acrichto> strcat: good point
[03:46:18] <dbaupp> btipling: github is the main repo
[03:46:21] <strcat> acrichto: anyway I will let graydon or someone else worry about making @/@mut fast
[03:46:27] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[03:46:44] * strcat just wants unique pointers/vectors without headers or tydesc nonsense
[03:46:45] <acrichto> strcat: huh, well thanks for talking to me :)
[03:46:51] <acrichto> I agree
[03:47:01] <strcat> tydesc nonsense is now fully dead
[03:47:11] <strcat> headers are harder to kill ;p
[03:47:20] <strcat> since lots of code treats unique and managed-unique the same....
[03:47:28] <strcat> and some code even treats all boxes the same.
[03:47:40] <acrichto> yeah that's unfortunate
[03:47:47] <strcat> so I am going to end up adding 2 split code paths to dozens of places
[03:48:00] <strcat> the fast unique path and the terribly slow managed-unique path
[03:48:28] <strcat> instrinsics::contains_managed::<T>() makes a constant so LLVM will optimize it away
[03:48:30] <acrichto> strcat: yeah I don't understand why managed stuff doesn't pass around pointers to the data instead...
[03:48:39] <yichoi> strcat: there is no rollup branch for small patch today ?
[03:48:44] <strcat> yichoi: not yet
[03:49:10] <strcat> yichoi: http://buildbot.rust-lang.org/console?branch=auto&refresh=15 buildbot is really messed up :(
[03:49:22] <yichoi> strcat: if you will make, please include my 2 PRs
[03:49:55] <yichoi> strcat: really messed 
[03:50:05] <strcat> one of the mac builds got stuck
[03:50:08] <strcat> and won't cancel
[03:50:12] <strcat> so it's missing a mac bot ;\
[03:50:35] <strcat> acrichto: well it was done backwards ;p
[03:50:43] <strcat> acrichto: rust had managed pointers before unique/borrowed ones
[03:50:50] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[03:50:56] <acrichto> strcat: is there a reason to not do that though?
[03:50:58] <btipling> dbaupp: thanks
[03:51:09] <aatch> acrichto, no, it's just hard
[03:51:11] <acrichto> other than perhaps graydon's gc relies on the opposite?
[03:51:11] <strcat> acrichto: well afaik @ should be a ptr to the data with no header
[03:51:20] <strcat> acrichto: his gc stores metadata itself
[03:51:24] <strcat> acrichto: the headers are still there
[03:51:27] <acrichto> well using the current gc
[03:51:27] <strcat> so you pay double overhead
[03:51:29] <btipling> http://buildbot.rust-lang.org/waterfall
[03:51:33] <btipling> looks like mac is failing right now
[03:52:00] <btipling> http://buildbot.rust-lang.org/builders/try-mac
[03:52:03] <aatch> btipling, no, it was interupted.
[03:52:09] <mofe> btipling: http://static.rust-lang.org/dist/rust-0.7-pre.tar.gz if you were still looking for this
[03:52:09] <strcat> I interrupted master-mac
[03:52:12] <btipling> hrm can I try it again
[03:52:14] <strcat> it doesn't need to keep stealing a bot
[03:52:23] <btipling> mofe: thanks, was just thinking of building from source
[03:52:24] <strcat> we know master is green, auto tests it! ;p
[03:52:31] <btipling> auto?
[03:52:34] <aatch> btipling, and try is for devs testing things
[03:52:39] <strcat> try is broken tho
[03:52:47] <btipling> :\
[03:52:55] <btipling> you guys need help with this rust thing
[03:52:56] <btipling> ?
[03:52:58] <btipling> :P
[03:52:58] <strcat> the doc bot is broken too
[03:53:18] <strcat> http://buildbot.rust-lang.org/builders/doc
[03:53:22] <aatch> btipling, no, we just did a big change and things are still settling.
[03:53:27] <strcat> only graydon can fix the doc bot
[03:53:51] <acrichto> strcat: doc bot -- https://github.com/mozilla/rust/issues/7506
[03:53:51] <mofe> i tried a compile from master earlier and got an llvm error on ./configure
[03:54:02] <btipling> ok
[03:54:09] <btipling> I'm going to check out rust from source and try to build it
[03:54:45] <btipling> thanks for the help
[03:54:47] <aatch> btipling, it might take a while, but it should work fine.
[03:55:11] <btipling> cool, if I build rust from the 0.6 tar gz it doesn't need to rebuild all those old versions again does it?
[03:55:17] <btipling> I installed them with make install
[03:55:57] <strcat> aatch: https://github.com/mozilla/rust/pull/7521 r?
[03:56:49] <mofe> when i try build from master, it says /src/llvm/configure is missing
[03:57:13] <dbaupp> mofe: what happens if you run ./configure again?
[03:57:27] <mofe> dbaupp: uh, same thing
[03:57:50] <dbaupp> oh :( (occasionally these problems can be fixed by running configure/make twice)
[03:57:59] <doener> mofe: try running "git submodule update --init" manually
[03:58:09] <doener> then configure again
[03:58:28] <aatch> strcat, done
[03:59:03] <btipling> the git submodule update --init actually takes a while, is that blocked on github? :O
[03:59:11] <btipling> er not --init
[03:59:14] <mofe> doener: does that require i git clone master? I just downloaded the zip file.
[03:59:32] <dbaupp> mofe: probably
[03:59:32] <btipling> you mean the tarball?
[03:59:44] <doener> mofe: oh, nvm then, I've never built from that
[04:00:26] <btipling> went with make -j4 this time
[04:00:32] <btipling> let's see how much faster that is
[04:01:26] <aatch> btipling, it does take a while at first because it checks out LLVM
[04:01:31] <aatch> which is pretty large.
[04:01:32] <btipling> yes
[04:01:40] <mofe> problem solved. i forgot i didnt have git installed on my computer and the configure script needs it to update
[04:02:02] <mofe> but it is taking a long time
[04:02:16] <aatch> mofe, yes, it does
[04:02:21] <aatch> just be patient
[04:02:24] <btipling> so creates are configuration files that describe a program or a library right
[04:02:29] <btipling> er crates
[04:02:41] <aatch> btipling, no, crates _are_ libraries/binaries
[04:02:46] <btipling> oh
[04:03:01] <aatch> With metadata stored in a section that is read at compile time.
[04:03:12] <aatch> (.note.rustc to be precise)
[04:03:53] <btipling> "A crate that contains a main function can be compiled to an executable."
[04:04:00] <btipling> had me thinking it wasn't a binary
[04:04:30] <btipling> "h compilation processes a single crate in source form, and if successful, produces a single crate in binary form"
[04:04:40] * btipling reads the docs
[04:05:52] <mofe> its binary, but not necessarily executable
[04:07:58] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[04:09:01] *** Quits: mofe (Mibbit@moz-D7F31788.hsd1.mi.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:09:08] *** Joins: mofe (Mibbit@moz-D7F31788.hsd1.mi.comcast.net)
[04:13:45] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[04:13:45] <ghrust> 01[13rust01] 15brson pushed 1 new commit to 06master: 02http://git.io/dFokHA
[04:13:45] <ghrust> 13rust/06master 14d5c5ce3 15Brian Anderson: Update verison numbers in README.md
[04:13:45] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[04:16:35] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[04:16:35] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 142842368 to 14d5c5ce3: 02http://git.io/N3iJvQ
[04:16:35] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[04:16:37] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[04:16:37] <ghrust> 01[13rust01] 15bors pushed 10 new commits to 06auto: 02http://git.io/EljYQQ
[04:16:38] <ghrust> 13rust/06auto 145d46bcc 15Huon Wilson: Remove vec::{rfind, rfind_between, find_between}, replaced by slices and iterator adapators.
[04:16:38] <ghrust> 13rust/06auto 1445940ed 15Huon Wilson: Remove vec::[r]position_between, replaced by slices & iterators.
[04:16:38] <ghrust> 13rust/06auto 14a890c2c 15Huon Wilson: Convert vec::{rposition, rposition_elem, position_elem, contains} to methods.
[04:16:40] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[04:16:45] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[04:20:02] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[04:20:03] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[04:20:03] <ghrust> 01[13rust01] 15brson merged 06master into 06dist-snap: 02http://git.io/8_HW7g
[04:20:03] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[04:20:06] *** Quits: alicedare (textual@1E3F14AE.29819A33.115CE8E4.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[04:20:37] <steven_is_false> Why are RWARC, and MutexArc implemented using ports, and channels? That seems like abstraction inversion to me?
[04:21:21] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[04:22:05] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[04:23:03] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[04:23:44] *** Joins: n00b6502 (kwr5y54@moz-6651F8D4.range86-145.btcentralplus.com)
[04:23:53] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[04:24:02] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[04:24:08] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[04:25:52] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[04:25:54] *** Joins: brson (brson@E9CDE21E.991753BB.CA4D1600.IP)
[04:25:54] *** ChanServ sets mode: +o brson
[04:26:09] <brson> yichoi: what's the state of the android build/
[04:26:53] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[04:28:32] * strcat isn't entirely sure what to do about ~[]
[04:28:56] <strcat> almost every function is going to need 2 code paths
[04:29:02] <strcat> one for managed-unique, one for unique
[04:29:11] <strcat> the branch is a known constant so at least it won't hurt perf
[04:29:35] <dbaupp> strcat: 'every function' where?
[04:30:23] <strcat> dbaupp: well because managed-unique will have headers
[04:30:28] <strcat> so the representation will be different
[04:30:53] <dbaupp> I mean, every function in the runtime, every function in vec, .. every function in the whole codebase?
[04:30:58] <strcat> dbaupp: in vec.rs
[04:31:08] <btipling> that was super quick with j4
[04:31:11] <strcat> managed-unique will be *VecRepr
[04:31:15] <strcat>     pub struct VecRepr {
[04:31:17] <strcat>         box_header: managed::raw::BoxHeaderRepr,
[04:31:18] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[04:31:19] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[04:31:19] <strcat>         unboxed: UnboxedVecRepr
[04:31:21] <strcat>     }
[04:31:23] <strcat> and unique vectors will be UnboxedVecRepr
[04:31:30] *** Quits: mofe (Mibbit@moz-D7F31788.hsd1.mi.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[04:31:40] <strcat> *UnboxedVecRepr, I mean
[04:32:05] <strcat> I
[04:32:14] <strcat> I'll wait for contains_managed to be snapshotted anyway
[04:33:14] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[04:33:29] <doener> hu? Why would rustc complain about std::ptr::to_unsafe_ptr(...), but accept "use std::ptr; ptr::to_unsafe_ptr(...)"?
[04:33:56] <strcat> doener: because inside a crate, you need 'use foo;' of other modules in the crate
[04:34:08] <strcat> is this inside libstd?
[04:34:12] <strcat> if it's not, no idea
[04:34:25] <doener> in rustc
[04:34:27] <doener> librustc
[04:34:35] <btipling> error: multiple matching crates for `std`
[04:34:48] <btipling> how do I get rid of rustc wanting to build with 0.6?
[04:35:03] <aatch> btipling, just delete the old files
[04:35:10] <btipling> ok thanks
[04:36:55] <aatch> So here is a native-rust implementation of `exit()`: https://gist.github.com/Aatch/5898374
[04:37:29] <aatch> technically `exit_group`
[04:38:59] <dbaupp> aatch: neat!
[04:39:10] * dbaupp thinks aatch should port jemalloc to rust
[04:39:13] <aatch> wait, it's not _quite_ right
[04:40:17] <aatch> Ok, _now_ it's correct.
[04:40:31] <aatch> I forgot that exit takes a parameter.
[04:40:39] <aatch> I need to add an intrinsic to rustc though.
[04:41:21] <aatch> dbaupp, I actually found a use for an unreachable intrinsic.
[04:43:23] <dbaupp> does fail!() or loop {} work for now?
[04:45:45] <aatch> dbaupp, yeah. It's just kinda annoying because fail!() creates a dependency on std
[04:45:58] <dbaupp> oh, yeah.
[04:46:18] <dbaupp> (and on the whole try/catch/unwinding stuff too)
[04:47:06] <aatch> dbaupp, well the idea is that it will never get there, but LLVM doesn't know that because it's hidden in the assembly
[04:47:15] <dbaupp> yeah
[04:48:28] <strcat> aatch: exit can fail
[04:48:32] <strcat> (for real)
[04:48:38] <aatch> strcat, really?
[04:48:50] <strcat> aatch: yep, one example is if the process is forbidden from running exit by seccomp :)
[04:49:04] <aatch> strcat, how on earth do you handle that?
[04:49:12] <strcat> aatch: uh, look at what glibc does
[04:49:15] <strcat> it might loop forever
[04:49:46] <strcat> but all syscalls can fail
[04:49:49] <aatch> strcat, well go crashes
[04:50:14] <aatch> oh, wait, no it doesn't
[04:50:23] <aatch> it does on some syscalls.
[04:54:51] <steven_is_false> Ugh. I need a method .recv_or_recv_none for ports
[04:55:09] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[04:55:16] <steven_is_false> I could do if self.head.peak() { let value = self.head.recv(); but that's racy
[04:55:27] <steven_is_false> I need the recv to happen atomically with the peek.
[04:55:41] <dbaupp> steven_is_false: when would it return None?
[04:55:45] <Eridius> if you make htis, call it .try_recv instead of the monstrosity that is .recv_or_recv_none
[04:55:49] <steven_is_false> dbaupp: When there is nothing to recv
[04:55:53] <dbaupp> (there's .try_recv)
[04:56:02] <Eridius> pfft
[04:56:04] <steven_is_false> Eridius: try_recv is for failure.
[04:56:44] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[04:56:47] <steven_is_false> How about poll_recv or something along those lines?
[04:56:50] <Eridius> try_recv_noblock?
[04:57:03] <dbaupp> or just recv_noblock
[04:57:31] <Eridius> what would this do in the failure case?
[04:57:45] <steven_is_false> Eridius: Probable just what try_recv does.
[04:58:29] <dbaupp> Eridius: (I was just bikeshedding the name, it'd return Option<T>)
[04:58:47] <Luqman> doesn't try_recv already return Option<T> ?
[04:58:50] <Eridius> steven_is_false: so I guess you don't want to distinguish between failure and simply nothing being available?
[04:58:59] <brson> steven_is_false: I don't think peek + recv is any racier from a single atomic check. In either case the send can happen after the check
[04:58:59] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[04:59:19] <brson> it is more expensive though
[04:59:24] <brson> by one atomic
[04:59:34] <dbaupp> More useful would be recv_timeout(time: uint) -> Option<T> and use time = 0 for non-blocking.
[04:59:57] <steven_is_false> dbaupp: That makes sense.
[05:00:14] <steven_is_false> dbaupp: Although, as I understand it the current stuff for that is broken.
[05:02:01] <dbaupp> Luqman: try_recv returns None if the channel is closed, not if there is nothing currently in the queue
[05:02:59] <dbaupp> s/queue/channel/
[05:03:24] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[05:04:12] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[05:04:47] <steven_is_false> So I think this is a real bug in the signal method for the Waitqueue data structure where the signal method can block.
[05:05:00] *** Quits: brson (brson@E9CDE21E.991753BB.CA4D1600.IP) (Quit: leaving)
[05:05:27] <aatch> ok, so I'm going to copy most of Go's syscall implementation stuff.
[05:12:07] *** Quits: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP) (Quit: (quit))
[05:12:57] <ross> what's the best way to avoid constantly getting the "multiple matching crates for std" error when you update from master and rebuild?
[05:13:01] *** Quits: jensnock_ (jensnocker@moz-8BE55278.customer.t3.se) (Input/output error)
[05:13:08] <ross> do I have to manually hunt down all the old binaries and delete them by hand?
[05:13:23] <strcat> use a package manager
[05:13:33] <strcat> or do you mean the ones in the build dir
[05:13:38] <strcat> you can get rid of those with make clean
[05:13:49] <strcat> it's a bug that the build system doesn't deal with them itself
[05:13:49] <ross> no not those
[05:14:30] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[05:14:46] <ross> use a package manager? somebody packages and distributes the master branch?
[05:14:54] <ross> sorry I am a bit inexperienced with linux
[05:15:35] *** Quits: dbaupp (Thunderbir@moz-EAB436DB.lns20.syd6.internode.on.net) (Ping timeout)
[05:16:08] <strcat> the only good practice for installing things globally is building a package for the package manager (pacman, dpkg, rpm, etc.) to install/remove/update and handle deps for
[05:16:30] <ross> oh like locally
[05:16:32] <ross> I see
[05:31:27] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[05:31:36] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[05:31:57] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[05:32:35] <strcat> uh, bors broke
[05:32:38] <strcat> it tested this commit twice
[05:33:01] <strcat> wat
[05:33:40] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[05:37:26] <aatch> I'm going to write some documentation for the asm! extension...
[05:38:42] <aatch> since I resorted to reading the LLVM constraint parser...
[05:39:36] <enix> I have a function that takes a &fn() as an argument. I can call the function twice without issue. However, if I try to pass it to another function that also wants a &fn() twice, i get an error about using a moved value: https://gist.github.com/DaGenix/5898568
[05:40:08] <enix> the error i'm getting says to use "copy," but that seems to give me an error about &fn()s not being copyable
[05:40:34] <strcat> enix: can't copy &fn anymore if bblum's changes landed, have to reborrow
[05:40:37] <enix> i'm pretty confused - i didn't think that passing a &fn() to another function would move it
[05:40:37] <strcat> wrap it in another &fn
[05:40:52] <strcat> enix: it's for memory safety
[05:41:05] <enix> ah, ok
[05:41:59] <aatch> strcat, you could (or will be able to) add bounds, to make it possible.
[05:42:28] <enix> how do I do that - if I try to create an inner function that just calls it, i get an error about an "attempted dynamic environment capture"?
[05:42:40] <strcat> enix: another closure
[05:42:40] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[05:42:58] <strcat> inner functions aren't closures and don't have an environment (they can't capture state)
[05:44:47] <enix> ah, ok, that works
[05:44:49] <enix> thanks!
[05:44:55] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[05:45:31] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[05:45:51] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[05:46:01] <strcat> aatch: I really need contains_managed in stage0 ;p
[05:46:15] <aatch> strcat, give it a few days.
[05:46:39] * strcat will work on other things
[05:46:54] <aatch> The current snapshot is live yet!
[05:46:58] <aatch> isn't*
[05:50:21] <aatch> Wow, mips has a lot of registers
[05:51:32] <mcpherrin> aatch: It was the first instruction set I learned to write assembly on.  Everything else since has been disappointing :P
[05:51:35] <mcpherrin> (Except SPARC)
[05:51:42] <aatch> mcpherrin, heh.
[05:52:28] <aatch> I was just making sure that my clobbers for the syscalls were conservative enough and stumbled across some mips-related stuff
[05:53:20] <strcat> aatch: look at itanium ;p
[05:53:41] <strcat>     128 64-bit general purpose registers
[05:53:43] <strcat>     128 82-bit floating-point registers
[05:53:45] <strcat>     64 1-bit predicate registers
[05:53:55] <aatch> strcat, wow...
[05:53:58] <strcat> and 8 branch registers
[05:54:26] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Quit: Konversation terminated!)
[05:54:31] <aatch> I did some machine-level programming in first year (on a javascript-implemented emulator of all things!) with 4 gp regs
[05:54:50] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[05:55:08] <aatch> first year of university I should clarify
[05:55:36] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[05:57:11] <bblum> strcat: tomorrow remind me i have to make a decent error message for that
[05:57:24] <bblum> it'll be pretty inconvenient for anyone who doesn't know
[05:57:37] <bblum> until they become automatically borrowed, which is a project a little over my head
[05:58:05] <mcpherrin> strcat: sparc has 160 GP registers
[05:58:15] <mcpherrin> also itanium is weird
[05:58:23] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[06:01:16] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz)
[06:01:46] <jensnockert> Itanium has a few really nice features though.
[06:01:56] <jensnockert> Like the extended-precision FMAs.
[06:02:44] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[06:03:50] <yichoi> brson: ping
[06:08:28] *** Joins: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de)
[06:11:48] *** Quits: yichoi (yichoi@B9B92496.8529BA9E.1C44CDAC.IP) (Ping timeout)
[06:12:04] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[06:12:44] *** Joins: yichoi (yichoi@B961FD0B.FC55670F.37DE4CB8.IP)
[06:17:48] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[06:19:35] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[06:19:55] *** Joins: dsirenko (mitra@moz-6CD77AE5.led-01.ru.sixxs.net)
[06:23:27] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[06:23:41] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[06:23:55] *** Quits: indirect (indirect_m@moz-770AB053.hsd1.ca.comcast.net) (Quit: ZNC - http://znc.in)
[06:24:16] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[06:29:45] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[06:30:01] *** Joins: indirect (indirect_m@moz-770AB053.hsd1.ca.comcast.net)
[06:30:11] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[06:31:59] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[06:33:51] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (Ping timeout)
[06:34:10] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[06:38:05] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[06:38:57] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[06:39:57] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[06:40:10] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[06:40:31] <strcat> stupid bors
[06:40:34] <strcat> you already tested that
[06:40:56] * strcat sighs
[06:42:52] <steven_is_false> Clang doesn't come with a standard library right?
[06:43:19] <steven_is_false> So I can't look in the header files to see how std::atomic is implemented unless I have the libraries for that right?
[06:44:16] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[06:45:23] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[06:45:23] <aatch> steven_is_false, atomic stuff in C/C++ is odd
[06:45:33] <aatch> dammit.
[06:50:48] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[06:53:43] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[06:55:27] *** Joins: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be)
[06:57:20] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[07:06:19] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[07:07:35] *** Joins: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk)
[07:08:32] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[07:08:44] *** Quits: busylizzy (lisa@FC306F0C:BF233E95:2EB9049C:IP) (Ping timeout)
[07:09:13] <aatch> Argh. stupid constraints
[07:10:02] *** Joins: busylizzy (lisa@FC306F0C:BF233E95:2EB9049C:IP)
[07:11:03] <aatch> hey, movq vs movl? what's the difference?
[07:11:24] <Luqman> quad vs long
[07:11:39] <Luqman> movq 64bits, movl 32bits
[07:12:06] <aatch> Luqman, ah, thank you
[07:12:32] *** Quits: yichoi (yichoi@B961FD0B.FC55670F.37DE4CB8.IP) (Ping timeout)
[07:13:34] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[07:13:34] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/EljYQQ
[07:13:34] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[07:13:45] <aatch> Oh, while I'm asking questions about assembly, rax vs eax? My brain is telling me that rax = full 64-bit reg, and eax = lower 32bit reg
[07:13:51] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[07:14:16] <steven_is_false> Hi! Does the following code make sense (or is it really slow or something?) http://pastebin.mozilla.org/2582178
[07:14:27] <Luqman> aatch: yep
[07:14:39] <aatch> Luqman, cool, thanks
[07:15:01] <Luqman> aatch: there's also ax (lower 16) and al (lower 8)
[07:15:03] <aatch> Turns out the LLVM inline assembly stuff is more complicated than I though.
[07:15:08] <aatch> thought*
[07:15:27] <aatch> Luqman, what about `ai`?
[07:15:49] <Luqman> i don't know of an `ai` o.o
[07:16:22] <aatch> Luqman, uh, what about a `DI`? It comes up a lot here: https://code.google.com/p/go/codesearch#go/src/pkg/runtime/sys_linux_amd64.s&sq=package:go&type=cs&l=12
[07:16:26] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[07:16:26] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/OF_tdQ
[07:16:26] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[07:16:27] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[07:16:27] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/HIX8xA
[07:16:27] <ghrust> 13rust/06auto 140a3f6bc 15Young-il Choi: mk: clean-llvm for cross-compile
[07:16:27] <ghrust> 13rust/06auto 146a2ad08 15bors: auto merge of #7492 : yichoi/rust/fix_cleanllvm, r=luqmana...
[07:16:27] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[07:17:35] <Luqman> aatch: http://msdn.microsoft.com/en-us/library/windows/hardware/ff561499(v=vs.85).aspx says DI is the lower 16bits of rdi
[07:18:06] <aatch> Luqman, oh, so theres a DI register
[07:18:19] * aatch should actually learn assembler
[07:19:11] <Luqman> well not really a register, just a way to refer to a portion of it
[07:19:26] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[07:19:52] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[07:20:37] <aatch> it just turns out that the asm! extension means you have to specify the exact register, if you want an exact register.
[07:21:23] <Luqman> aatch: mm yea, there's a bunch of the stuff that could be done to improve it
[07:21:45] <aatch> Luqman, well hopefully _using_ it will make it obvious.
[07:21:50] <Luqman> clang has a fair bit of logic for inline asm before it passes it off to llvm
[07:22:32] <aatch> I think a good first step would be translating constraints like 'a' to machine-appropriate register constraints.
[07:22:43] *** Joins: Palmik (palmik@moz-CC484FDD.tmcz.cz)
[07:22:54] <aatch> rather than making LLVM try and allocate the 'a' register
[07:23:16] <Luqman> yep, that's the kind of stuff clang does afaik
[07:25:22] *** Joins: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net)
[07:25:23] *** Quits: Voomer (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[07:29:07] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[07:34:20] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[07:35:02] *** Joins: nano (nano@moz-972880B.superkabel.de)
[07:35:15] <aatch> hurray!
[07:36:40] <aatch> I have successfully implemented `open(2)` in pure rust
[07:39:02] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[07:43:30] <steven_is_false> aatch: hurray!
[07:44:13] <aatch> steven_is_false, yep. after figuring out that "rD" was just saying "register constraint, or 'D'"
[07:44:23] <aatch> and it just ignored the 'D'
[07:45:53] <roo> what distinguishes 'self from other lifetimes?
[07:46:04] <aatch> roo, nothing really.
[07:46:50] <aatch> steven_is_false, yep, 2 down (I've also done close(2)), 311 to go :P
[07:47:58] <steven_is_false> Great!
[07:48:32] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[07:49:19] <aatch> heh, tee is a syscall!
[07:51:02] <yichoi> r? #7488
[07:52:06] <ross> hm I'm getting a linking error
[07:52:13] <ross> error: linking with `cc` failed with code 1
[07:52:31] <aatch> ross, there should be more output
[07:52:36] <roo> aatch: Then why does the compiler complain when i don't use 'self in some places? Just completely arbitrary?
[07:52:38] <aatch> normally it's missing symbols.
[07:52:51] <ross> yeah it mentions two functions I'm calling from another crate
[07:52:59] <aatch> roo, oh, right, it's /currently/ only valid in some cases.
[07:53:41] <aatch> ross, hmm, you probably aren't passing the correct linker flags
[07:53:55] <yichoi> thanks aatch
[07:54:02] <ross> I'm doing -L path/to/foo.so
[07:54:05] <aatch> anyway, gotta go.
[07:54:09] <ross> later
[07:54:20] <aatch> ross, you want -L path/to/
[07:54:26] <aatch> since -L adds a search path.
[07:54:34] *** aatch is now known as aatch|gone
[07:56:31] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[07:58:13] *** Quits: SimonSapin (simon@moz-D0C2F181.zone2.bethere.co.uk) (Ping timeout)
[07:59:55] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[08:00:43] <dbaupp> https://github.com/mozilla/rust/pull/7523 r?
[08:03:42] <ross> maybe I broke my rust installation
[08:05:27] <ross> the rust-sdl demo won't compile. same linker error
[08:05:47] <ross> but the functions it's trying to call are definitely in the rust-sdl source I just built from
[08:05:54] *** Joins: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au)
[08:10:23] <roo> what is the whole output?
[08:10:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:11:16] <ross> http://pastebin.com/r7KupRPQ
[08:12:24] <ross> here's the demo code being compiled https://github.com/brson/rust-sdl/tree/master/demo
[08:12:41] <ross> which is calling to here https://github.com/brson/rust-sdl/blob/master/src/sdl.rs
[08:15:05] *** Joins: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP)
[08:16:20] *** Quits: n00b6502 (kwr5y54@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[08:16:24] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[08:18:59] <roo> yeah thats weird, idk. if it knows enough to resolve the mod item in the demo to the crate name, then it is finding an sdl crate in the library search path(s)
[08:19:08] <ross> yeah
[08:19:19] <ross> if I change the name in either the caller or callee, it doesn't compile
[08:19:22] <ross> saying it can't find the name
[08:19:30] <ross> but with them the same, it compiles fine but then won't link
[08:20:49] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[08:21:09] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[08:25:30] *** Quits: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net) (Quit: anri)
[08:28:56] *** Quits: Palmik (palmik@moz-CC484FDD.tmcz.cz) (Quit: Lost terminal)
[08:30:14] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[08:33:03] <ross> https://github.com/mozilla/rust/issues/7338?source=cc looks like this may be the same issue
[08:33:03] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (Connection reset by peer)
[08:33:32] <ross> or not
[08:34:13] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[08:35:04] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.1)
[08:35:39] *** Joins: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de)
[08:37:44] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[08:39:56] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[08:40:03] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (Ping timeout)
[08:45:21] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[08:46:46] *** Joins: JDT (Mibbit@moz-B994FA9E.cs.st-andrews.ac.uk)
[08:57:37] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Quit: echristo)
[08:58:13] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[09:02:31] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[09:09:31] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:11:02] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[09:12:07] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (Client exited)
[09:13:23] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (Ping timeout)
[09:13:40] *** Joins: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk)
[09:17:26] *** Joins: n00b6502 (kwr5y54@moz-6651F8D4.range86-145.btcentralplus.com)
[09:17:28] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[09:22:29] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[09:22:43] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[09:22:43] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/HIX8xA
[09:22:43] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[09:23:56] <klutzy> is rust 0.7 fixed for release?
[09:24:13] <klutzy> I'm curious since there are commits after version bump
[09:25:42] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[09:26:46] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[09:29:10] *** Joins: ghrust (ghrust@79968228.6A2AE50.F3114085.IP)
[09:29:10] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/AAVGbQ
[09:29:10] *** Parts: ghrust (ghrust@79968228.6A2AE50.F3114085.IP) ()
[09:29:16] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[09:29:16] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/AxgWoA
[09:29:16] <ghrust> 13rust/06auto 1480ab877 15Daniel Micay: global_heap: inline malloc_raw and add realloc_raw
[09:29:16] <ghrust> 13rust/06auto 14b731d96 15Daniel Micay: vec: implement exchange vector reserve in Rust
[09:29:17] <ghrust> 13rust/06auto 140d7799d 15Daniel Micay: global_heap: inline get_box_size and align_to
[09:29:17] *** Joins: CarpNet (ac@moz-FD24B77.sohonet.co.uk)
[09:29:18] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[09:29:34] *** Quits: n00b6502 (kwr5y54@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[09:29:56] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (Ping timeout)
[09:30:36] *** Joins: mib_rrkow3 (Mibbit@moz-7A0CB455.glbb.ne.jp)
[09:31:52] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[09:38:03] *** Quits: RMF (RMF@moz-ED65DEAC.dsl.telepac.pt) (Ping timeout)
[09:39:54] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[09:43:55] *** Joins: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP)
[09:51:34] *** Joins: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt)
[09:51:55] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[09:52:27] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[09:54:54] *** kimundi is now known as zz_kimundi
[09:59:25] *** Quits: mib_rrkow3 (Mibbit@moz-7A0CB455.glbb.ne.jp) (Quit: http://www.mibbit.com ajax IRC Client)
[10:04:22] <roo> rusti: fn foo<'self>(in: &'self str) -> (~fn (int) -> ~str) { |int| { in } }; foo("");
[10:04:23] -rusti- error: internal compiler error: unexpected failure
[10:04:23] -rusti- note: the compiler hit an unexpected failure path. this is a bug
[10:04:23] -rusti- note: try running with RUST_LOG=rustc=1,::rt::backtrace to get further details and report the results to github.com/mozilla/rust/issues
[10:04:23] -rusti- application terminated with error code 101
[10:07:11] *** Quits: ross (ross@moz-8A84103E.br.br.cox.net) (Quit: )
[10:07:49] <roo> On my machine it fails silently
[10:11:57] *** Quits: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de) (Ping timeout)
[10:14:22] *** Joins: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de)
[10:15:30] <cmr> dbaupp: pong
[10:16:19] <cmr> yeah I don't know why gnu time does...what it does, but it's consistent and should be easy to parse
[10:16:59] <cmr> it should have a single newline though
[10:18:36] *** Quits: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[10:19:51] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (Quit: pyrac)
[10:21:58] <AutomatedTester> silly question, how do i reverse a vector? I tried let foo = ~["a","b","c"]; foo.reverse() and it says no method called reverse()
[10:22:33] <cmr> rusti: let foo = ~["a", "b", "c"]; foo.rev_iter().collect::<~[&str]>()
[10:22:34] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/NMOa
[10:23:15] <cmr> rusti: let foo = ~["a", "b", "c"]; foo.rev_iter().collect() // maybe?
[10:23:16] -rusti- <anon>:9:37: 10:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[10:23:16] -rusti- <anon>:9          let foo = ~["a", "b", "c"]; foo.rev_iter().collect() // maybe?
[10:23:17] -rusti- <anon>:10     };
[10:23:17] -rusti- application terminated with error code 101
[10:23:20] <cmr> nope
[10:23:30] <cmr> AutomatedTester: it's something along those lines :p
[10:23:37] <AutomatedTester> oh right
[10:23:47] <AutomatedTester> I was misreading http://static.rust-lang.org/doc/core/files/vec-rs.html#vec.reverse then
[10:24:02] <cmr> no you weren't
[10:24:08] <cmr> but I didn't even know those docs existed
[10:24:10] <cmr> those are ancient
[10:24:23] <cmr> Use http://static.rust-lang.org/doc/std/index.html
[10:24:30] <Seldaek> new docs still mention it http://static.rust-lang.org/doc/std/vec.html#function-reverse
[10:25:17] <cmr> rusti: let foo ~[1, 2, 3]; foo.reverse();
[10:25:18] -rusti- <anon>:9:17: 9:18 error: expected `;` but found `~`
[10:25:18] -rusti- <anon>:9          let foo ~[1, 2, 3]; foo.reverse();
[10:25:18] -rusti-                           ^
[10:25:18] -rusti- application terminated with error code 101
[10:25:24] <cmr> rusti: let foo = ~[1, 2, 3]; foo.reverse()
[10:25:26] -rusti- <anon>:9:31: 10:5 error: type `~[<VI2>]` does not implement any method in scope named `reverse`
[10:25:26] -rusti- <anon>:9          let foo = ~[1, 2, 3]; foo.reverse()
[10:25:26] -rusti- <anon>:10     };
[10:25:26] -rusti- error: aborting due to previous error
[10:25:27] -rusti- application terminated with error code 101
[10:25:27] *** concrete.mozilla.org sets mode: +M 
[10:25:37] <cmr> It was removed yesterday I think
[10:25:38] <AutomatedTester> cmr: thats why I get 
[10:25:42] <AutomatedTester> aha
[10:25:45] <cmr> It's what you should get :p
[10:25:50] <cmr> the doc builder is currently broken
[10:25:59] <AutomatedTester> cmr: thats what I am getting
[10:28:41] <AutomatedTester> curious, why have we moved to a more verbose way of reversing a string?
[10:28:53] <Seldaek> rusti: let foo = ~["a", "b", "c"]; let foo: ~[str] = foo.rev_iter().collect()
[10:28:53] -rusti- <anon>:10:4: 10:5 error: expected `;` but found `}`
[10:28:53] -rusti- <anon>:10     };
[10:28:53] -rusti-               ^
[10:28:53] -rusti- application terminated with error code 101
[10:28:56] <AutomatedTester> vector*
[10:29:08] <Seldaek> rusti: let foo = ~["a", "b", "c"]; let foo: ~[str] = foo.rev_iter().collect(); foo
[10:29:10] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/FJTb
[10:29:30] <Seldaek> ah well
[10:29:33] <cmr> AutomatedTester: Using iterators is generic over everything, not just vectors. You can reverse any iterator that supports it with rev_iter().collect
[10:29:55] <Seldaek> that said, having a .reverse() util method would be nice
[10:30:05] <cmr> it would be
[10:30:28] *** concrete.mozilla.org sets mode: -M 
[10:30:32] <roo> rusti: reversed(~[1,2,3,4])
[10:30:32] -rusti- <anon>:9:9: 9:17 error: unresolved name `reversed`.
[10:30:32] -rusti- <anon>:9          reversed(~[1,2,3,4])
[10:30:33] -rusti-                   ^~~~~~~~
[10:30:33] -rusti- error: aborting due to previous error
[10:30:33] -rusti- application terminated with error code 101
[10:31:40] <roo> rusti: use std::vec::reversed; reversed(~[1,2,3,4])
[10:31:41] -rusti- <anon>:9:42: 9:52 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[10:31:41] -rusti- <anon>:9          use std::vec::reversed; reversed(~[1,2,3,4])
[10:31:42] -rusti-                                                    ^~~~~~~~~~
[10:31:42] -rusti- ~[4, 3, 2, 1]
[10:32:30] <Seldaek> that was easy :p
[10:36:32] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[10:44:31] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[10:47:52] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[10:48:50] *** Joins: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt)
[10:51:53] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Ping timeout)
[10:54:54] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[10:56:31] <AutomatedTester> roo: in your reversed example, is that in 0.7 or is that in 0.6?
[10:56:37] <cmr> it is in 0.7
[10:56:42] <AutomatedTester> ahh
[10:56:53] <cmr> dbaupp: do you plan on removing that one?
[10:56:56] <AutomatedTester> that explains why its not working :D
[10:57:07] <cmr> are you using 0.6?
[10:57:11] <AutomatedTester> yea
[10:57:18] <cmr> should upgrade :)
[10:57:27] <AutomatedTester> just using what is available from brew
[10:57:39] *** zz_kimundi is now known as kimundi
[10:59:37] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[11:14:07] *** Joins: Sorella (queen@B12A78F5.BA14766C.95C8B7C6.IP)
[11:24:23] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[11:24:51] *** Joins: yichoi (yichoi@B9B92496.8529BA9E.1C44CDAC.IP)
[11:26:43] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[11:26:56] <xLII> whyDisallow "mut" from distributing over bindings.
[11:27:09] <xLII> why Disallow "mut" from distributing over bindings ?
[11:27:55] *** Quits: jdm (jdm@88F51059.F3BBB17D.144F44FA.IP) (Quit: Lost terminal)
[11:31:08] *** Joins: n00b6502 (kwr5y54@moz-6651F8D4.range86-145.btcentralplus.com)
[11:31:18] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[11:31:40] <xLII> expressions like " let mut (x,y) = (1,2) " cannot be compiled now
[11:34:09] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[11:35:16] <cmr> xLII: because it is fragile and no one agrees on how they should work, and it will unify the codepaths for let and other patterns. will eventually be reintroduced with like `let (mut x, mut y) = (1, 2)`
[11:37:08] *** Joins: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au)
[11:37:18] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[11:37:18] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/AxgWoA
[11:37:18] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[11:38:36] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[11:38:40] *** Joins: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[11:38:57] <xLII> i see
[11:39:03] <xLII> thx
[11:39:08] *** pnkfelix|rcirc is now known as pnkfelix
[11:39:21] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[11:40:22] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[11:40:22] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/TYP2mg
[11:40:22] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[11:40:25] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[11:40:25] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/1pRrUA
[11:40:25] <ghrust> 13rust/06auto 147bcde87 15jihyun: Fixes #7377
[11:40:25] <ghrust> 13rust/06auto 140bd67f6 15bors: auto merge of #7443 : yjh0502/rust/fix_field_dup, r=huonw...
[11:40:25] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[11:41:54] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[11:42:09] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[11:43:28] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[11:45:38] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[11:46:00] *** Quits: JDT (Mibbit@moz-B994FA9E.cs.st-andrews.ac.uk) (Quit: http://www.mibbit.com ajax IRC Client)
[11:46:05] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[11:47:07] <doomlord> float defaults to f32 or f64?
[11:47:33] <bjz> doomlord: always 64bit
[11:48:27] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[11:50:24] <engla> no.. then float would be pointless
[11:50:31] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[11:50:42] *** Joins: biondo1969 (biondo69@moz-327A8798.clienti.tiscali.it)
[11:50:49] *** Quits: biondo1969 (biondo69@moz-327A8798.clienti.tiscali.it) (Quit: )
[11:51:30] <cmr> it's supposed to be the "fastest float" for a given target
[11:51:43] <cmr> but, "fastest" is impossible to nail down, definition-wise
[11:51:59] * cmr still doesn't think float should exist
[11:52:05] <engla>  if there is a platform that doesn't support f64 in the cpu, then it should be f32
[11:53:21] <doomlord> its like int i suppose
[11:53:38] <cmr> well int has very specific meaning: signed fixnum that can hold a pointer
[11:54:00] <cmr> (word sized)
[11:54:12] <doomlord> maybe i'm hazy on definitions - i thought int was 'natural machine register size' - not necaserily pointer releatd; size_t fills that role
[11:54:36] <engla> uint is size_t basically
[11:54:37] <doomlord> eg if you had a machinen with data and adress registers... int would be the data-reg size, size_t would be the adress register size
[11:54:44] <doomlord> oh ok
[11:54:47] <engla> rust int is not C int
[11:55:16] <engla> linux x86-64 has 32-bit C int and 64-bit Rust int
[11:55:44] <doomlord> Perhaps you advocate leaving the symbol 'float' available for progams to define as they see fit; people coming from 'c' would define it as f32
[11:55:46] <cmr> and x32 has a 32-bit int but natively supports fast i64 ops
[11:55:58] *** Joins: hjr3 (hradtke@817E9B7E.C3D4F2AA.56F40276.IP)
[11:56:15] <doomlord> x32 is interesting
[11:56:19] <cmr> doomlord: I'm thoroughly convinced "float" either shouldn't exist, or should be the float with the most precision available
[11:57:01] <cmr> (ie, 80bit for x87 or 128bit for SSE/AVX)
[11:57:19] <doomlord> i think i agree with you that 'not existing' is better - then peeps coming from C can define it for familiarity
[11:57:26] <doomlord> float,double..
[11:57:29] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[11:57:32] <cmr> there is libc::c_int and libc::c_float and such
[11:57:41] <doomlord> although its not an issue i'd kick up a fuss over
[11:58:20] <engla> f64 is just a very ugly type name to use by default
[11:58:55] <doomlord> in my domain f32 is what would be used most of the time
[11:59:04] <doomlord> again .. float is prettier :)
[11:59:25] *** Joins: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net)
[11:59:29] <doomlord> but many c++ sourcebases go the other way for clarity, using f32, u32 etc..
[11:59:43] <cmr> I'd be perfectly fine with it not existing and people who want it using 'type float = f32;' or whatever
[12:00:09] <cmr> doomlord: yeah, I always use uint64 etc
[12:00:13] <cmr> it's just less pain
[12:00:18] <engla> sounds good cmr
[12:00:27] <doomlord> bikeshed?
[12:00:55] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[12:01:31] <doomlord> not having float is a step forward over float being something different to what C-peeps expect... maximum familiarity for people moving from C/C++ would be good IMO, you're not going to get converts from managed or scripting languaegs to rust i think..
[12:06:09] <engla> cmr: as long as type aliases work everywhere
[12:08:47] <cmr> engla: what do you mean?
[12:09:38] <engla> impl Num for float; and so on. Just that you can use it everywhere
[12:09:57] <engla> including static methods
[12:10:09] <cmr> you can't impl for typedefs, but if you have a typedef of float to f32, you should be able to use all the impls for f32
[12:10:17] <cmr> you need newtype to impl on it
[12:10:38] <engla> float as type alias is only a good solution if you can use the alias everywhere
[12:10:42] <engla> including for impl clauses
[12:11:33] <engla> but I think it's getting there
[12:11:57] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (Input/output error)
[12:12:12] <engla> I don't mean newtype.. that creates a new type
[12:12:18] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[12:12:29] <doomlord> lowercase / camelcase etc... whats idomatic
[12:12:30] <engla> that's a different thing
[12:12:43] *** Quits: jeltz (andreas@moz-7C6B0B72.tn.glocalnet.net) (Quit: Lost terminal)
[12:12:44] <engla> CamelCase types
[12:15:18] *** Joins: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP)
[12:18:23] *** Quits: yichoi (yichoi@B9B92496.8529BA9E.1C44CDAC.IP) (Connection reset by peer)
[12:18:23] *** Joins: donri (dag@moz-9BB61102.tbcn.telia.com)
[12:19:39] *** Joins: yichoi (yichoi@B9B92496.8529BA9E.1C44CDAC.IP)
[12:21:20] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[12:21:50] *** Joins: nano (nano@moz-972880B.superkabel.de)
[12:23:09] *** Quits: yichoi (yichoi@B9B92496.8529BA9E.1C44CDAC.IP) (Ping timeout)
[12:24:24] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:25:12] *** Joins: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[12:25:30] *** Parts: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) ()
[12:26:13] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[12:26:59] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:28:21] <cmr> rusti: type float = f32; 4f
[12:28:23] -rusti- 4
[12:29:11] <bstrie> I wouldn't expect that to do what you're implying
[12:29:11] *** Quits: z0w0 (zack@moz-7AEE33DD.qld.bigpond.net.au) (Client exited)
[12:29:27] <cmr> rusti: type float = f32; let x: float = 4.32e32; x
[12:29:28] -rusti- 432000000000000168642686206844420
[12:29:33] <cmr> it doesn't
[12:29:37] <cmr> it's still an f64
[12:29:51] <cmr> rusti: (4.32e32f32, 4.32e32f32f64)
[12:29:52] -rusti- <anon>:9:32: 9:35 error: expected `)` but found `f64`
[12:29:52] -rusti- <anon>:9          (4.32e32f32, 4.32e32f32f64)
[12:29:52] -rusti-                                          ^~~
[12:29:52] -rusti- application terminated with error code 101
[12:30:16] <cmr> rusti: (4.32e32f32, 4.32e32f64)
[12:30:17] -rusti- (431999926844484882886264044802006, 432000000000000168642686206844420)
[12:31:22] <cmr> https://github.com/mozilla/rust/wiki/Proposal-float-removal, feedback?
[12:31:55] <doomlord> +1
[12:32:03] <bstrie> cmr: I think you might as well just stick it in the issue tracker rather than the wiki
[12:32:15] <cmr> bstrie: ok
[12:32:52] <doomlord> should have f80 aswell :)
[12:33:01] <bstrie> and f128
[12:33:14] <bstrie> but those are separate proposals
[12:33:14] <doomlord> and f16 for gpu
[12:33:21] <bstrie> and f1 for completeness
[12:33:25] <cmr> lol
[12:33:37] *** Quits: Aetherspawn (Aetherspaw@moz-8811D9F0.static.tpgi.com.au) (Ping timeout)
[12:33:42] <doomlord> i hope they keep the ambition of rust for gpgpu
[12:33:48] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (Ping timeout)
[12:33:55] <cmr> https://github.com/mozilla/rust/issues/7525
[12:34:26] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[12:35:02] <cmr> Also sent to ML
[12:35:58] <SimonSapin> cmr: dont the same arguments apply to int?
[12:36:08] <cmr> SimonSapin: no
[12:36:12] <doomlord> interesting
[12:36:21] <cmr> int is defined to be able to store a pointer
[12:36:24] <cmr> (and signed)
[12:36:25] <Ms2ger> Surely int is 32 bits everywhere? ;)
[12:36:42] *** Quits: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net) (Ping timeout)
[12:36:45] <bstrie> yes, "the size of a pointer" is a useful concept
[12:37:44] <SimonSapin> so if I have integers that have nothing to do with pointers or even container size, int and uint are proably not appropriate?
[12:37:47] *** Quits: hjr3 (hradtke@817E9B7E.C3D4F2AA.56F40276.IP) (Quit: My MacBook has gone to sleep. ZZZzzz)
[12:38:06] <bstrie> SimonSapin: quite possibly. at the same time, it might not really matter
[12:38:08] <doomlord> pointers tend to correlate with machine word size
[12:38:20] <doomlord> although machines might have different data/adress..
[12:38:24] *** Joins: mw (mw@moz-5AC816E9.adsl.highway.telekom.at)
[12:38:27] <doomlord> strange DSPs..
[12:38:31] <cmr> They're perfectly appopriate if you don't care about their size, but you might also want bigint etc
[12:38:34] <bstrie> pointer-sized integers will always be reasonably efficient
[12:38:43] <doomlord> and past machines.. and cases like x32 as pointed out
[12:39:07] <engla> you can optimize the parts that matter later
[12:39:28] <bstrie> but yes, in a systems world you *should* either be thinking hard about how big your numbers can possibly be, or just use bignums instead
[12:39:52] <doomlord> absolutely
[12:40:09] <doomlord> probably why i32 etc are better 
[12:40:20] <cmr> I agree with strcat that bignum literals would go a long way for improving that situation
[12:40:33] <doomlord> although you can write code with 'int' and 'sizeof(int)' guided behaviour
[12:40:34] <SimonSapin> how about CSS lengths and other dimensions in servo?
[12:40:54] <bstrie> I think css would use floats
[12:40:57] <Ms2ger> i32
[12:41:17] <dbaupp> Seldaek, AutomatedTester, cmr: there is reverse still
[12:41:21] *** Parts: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) ()
[12:41:22] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[12:41:30] <Ms2ger> (At least in the DOM, 32-bit is what's standardized on)
[12:41:34] <dbaupp> rusti: let mut a = ~[1,2,3]; a.reverse(); a
[12:41:35] -rusti- <anon>:9:31: 9:43 error: type `~[<VI2>]` does not implement any method in scope named `reverse`
[12:41:35] -rusti- <anon>:9          let mut a = ~[1,2,3]; a.reverse(); a
[12:41:35] -rusti-                                         ^~~~~~~~~~~~
[12:41:35] -rusti- error: aborting due to previous error
[12:41:35] -rusti- application terminated with error code 101
[12:42:08] <dbaupp> rusti: let mut a = ~[1,2,3]; { let b: &mut [int] = a; b.reverse(); } a
[12:42:08] -rusti- <anon>:9:56: 9:68 error: type `&mut [int]` does not implement any method in scope named `reverse`
[12:42:08] -rusti- <anon>:9          let mut a = ~[1,2,3]; { let b: &mut [int] = a; b.reverse(); } a
[12:42:09] -rusti-                                                                  ^~~~~~~~~~~~
[12:42:09] -rusti- error: aborting due to previous error
[12:42:09] <SimonSapin> bstrie: CSS has both numbers and integers, although integer-only values are more rare
[12:42:09] <doomlord> the tim sweeney langauge-wishlist talk mentions a bignum type which fits in a machine word, but if the upper bit is unset its just a single word.. if the upper bit is set, its a pointer to a bignum...
[12:42:09] -rusti- application terminated with error code 101
[12:42:18] <bstrie> rusti: let mut a = ~[1,2,3]; a.rev_iter().collect()
[12:42:19] -rusti- <anon>:9:31: 10:5 error: cannot determine a type for this bounded type parameter: unconstrained type
[12:42:19] -rusti- <anon>:9          let mut a = ~[1,2,3]; a.rev_iter().collect()
[12:42:19] -rusti- <anon>:10     };
[12:42:19] -rusti- application terminated with error code 101
[12:42:24] <Ms2ger> SimonSapin, and it seems unwise to make CSS's behaviour depend on the user's architecture
[12:42:38] <bstrie> rusti: let mut a = ~[1,2,3]; let b: ~[int] = a.rev_iter().collect(); b
[12:42:39] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/CBLY
[12:42:54] <SimonSapin> Ms2ger: agreed
[12:42:55] <dbaupp> Seldaek, AutomatedTester, cmr: at least, it's in the source still
[12:43:08] <bstrie> doomlord: that sounds fun
[12:43:15] <Ms2ger> dbaupp, it's pretty new, aiui
[12:43:30] <bstrie> doomlord: it also sounds like it absolutely 100% requires precise GC :P
[12:43:45] <dbaupp> rusti: let mut a = ~[1,2,3]; a.mut_slice(0, 3).reverse(); a
[12:43:46] -rusti- <anon>:9:31: 9:59 error: type `&mut [<VI2>]` does not implement any method in scope named `reverse`
[12:43:46] -rusti- <anon>:9          let mut a = ~[1,2,3]; a.mut_slice(0, 3).reverse(); a
[12:43:46] -rusti-                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
[12:43:46] -rusti- error: aborting due to previous error
[12:43:47] -rusti- application terminated with error code 101
[12:44:05] <dbaupp> Ms2ger: ?
[12:44:19] <cmr> doomlord: Using the upper bit of a pointer like that is so wrong though :\
[12:44:24] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[12:44:29] <Ms2ger> dbaupp, .reverse() was only added this weekend, I believe
[12:44:40] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[12:44:44] <doomlord> shift it or something.. means its an aligned adress
[12:44:54] <dbaupp> Ms2ger: right! rusti isn't updated yet
[12:45:05] <bstrie> cmr: fine, we'll use the second-most-significant bit, and leave the msb as the sign bit
[12:45:17] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[12:45:19] <dbaupp> Ms2ger: (in fact, I added it, and I think it only landed a few hours ago :) )
[12:45:24] <cmr> that's not what pointers are :(
[12:45:25] <Ms2ger> dbaupp, oh, heh
[12:46:35] <doomlord> shift it
[12:46:54] <doomlord> if top bit set , shift left 1 and interpret as a pointer
[12:47:05] <doomlord> ... it can't be byte aligned, it has to be word aligned
[12:47:29] <doomlord> actually for the ability to use signed values perhaps the lowest bit would work better
[12:47:41] <doomlord> then its just arithmetic shift right to extract it ?
[12:47:45] <doomlord> in the int case
[12:47:52] <doomlord> whatever. (sorry i'm flooding)
[12:48:09] <bstrie> if you shift right then your sign bit gets messed up
[12:48:12] <bstrie> right?
[12:48:18] <bstrie> at least, if you're negative
[12:48:29] <doomlord> i'm thinking in the case of signed int.
[12:48:33] <dbaupp> https://github.com/mozilla/rust/pull/7523 r?
[12:48:45] <cmr> dbaupp: right, meant to ask you about that
[12:48:56] <dbaupp> cmr: yep?
[12:49:08] <cmr> I'm unconvinced statics being uppercase is a bad idea, and think that the link should be allow by default
[12:49:16] <doomlord> to extract  a 31bit signed int, do 'arithmetic shift right  by 1 place'... to extract unsigned, do "logic shift right by 1 place"
[12:49:20] <SiegeLord> Is this pointer trick a space optimization or a performance one?
[12:49:24] <doomlord> to encode it, just shift left
[12:49:38] <dbaupp> SiegeLord: both
[12:49:42] <doomlord> potentially a bit of both, depending on machine architecture
[12:50:04] <bstrie> doomlord: does any language actually do this
[12:50:06] <dbaupp> SiegeLord: it makes small bignums faster and smaller
[12:50:16] <SiegeLord> Wouldn't you stick an unpredictable branch into the process?
[12:50:25] <doomlord> i dont know. I am reciting from a set of tim-sweeney slides
[12:50:34] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[12:50:34] <bstrie> it's a branch, but I think it would be predictable
[12:50:41] <AutomatedTester> dbaupp: the error you were getting above is what I am getting too locally with 0.6
[12:50:45] <doomlord> its in his wishlist for a language. (rust ticks most of his requests off , interestingly :) )
[12:51:01] <dbaupp> AutomatedTester: as Ms2ger points out, it was only added recently
[12:51:03] <bstrie> it would get more expensive as your number got larger, but that's how bignums work in the first place
[12:51:10] <dbaupp> (like today/yesterday)
[12:51:17] <AutomatedTester> dbaupp: ahh
[12:54:06] <dbaupp> cmr: as in, you're not sure that we should warn statics to uppercase by default?
[12:54:23] <cmr> dbaupp: yes
[12:54:37] <dbaupp> cmr: the error that I show there is *very* confusing
[12:54:59] <dbaupp> having uppercase statics makes it occur much less often
[12:55:32] *** Quits: Blub\w (wry@7E3BB9D.71150E1A.237AE2BA.IP) (Quit: bb2morrow)
[12:56:17] <dbaupp> cmr: it's also an insideous bug in `match some_function() { (Some(a), None) => x, (None, Some(b)) => y, _ => z }`
[12:56:25] <dbaupp> cmr: since that doesn't even complain about irrefutable patterns
[12:56:48] <dbaupp> cmr: (imagine that example had a static a, or static b)
[12:57:10] <cmr> dbaupp: is there an issue open about this? seems like it should be improved
[12:57:22] <dbaupp> cmr: also, https://github.com/mozilla/rust/wiki/Note-style-guide (It's essentially codifying the style guide)
[12:58:01] <cmr> I know the style guide, but I don't think the compiler should enforce it with warnings by default (I also disagree with it, but that's incidental :P)
[12:58:34] <dbaupp> ah, I see
[12:58:46] <dbaupp> (fwiw, non_camel_case_types is warn by default)
[12:59:01] <cmr> But the poor warnings for this case is enough to get my stamp of r+
[12:59:02] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Ping timeout)
[12:59:07] <cmr> or, poor errors
[12:59:17] <dbaupp> thanks
[12:59:27] <AutomatedTester> is the owner of the sublime text snippets in here?
[12:59:52] <dbaupp> cmr: thanks, I'll open bugs about the error messages
[13:00:07] <bstrie> cmr: uppercase globals is basically the only universal naming convention I can think of, I'd say it's less controversial than non_camel_case_types
[13:00:19] <cmr> bstrie: they're not globals though
[13:00:26] <bstrie> w/e :P
[13:00:59] <cmr> uppercase constants is almost always a bad idea IMO... but maybe that's just me
[13:01:05] <engla> dbaupp: I don't see non_camel_case_types unless I turn it on manually
[13:01:09] <SiegeLord> I think the casing is a valid warning to have, nothing else from the style guide imo...
[13:01:15] <dbaupp> engla: really?
[13:01:21] <SiegeLord> Indentation/brace style etc... none of those affect the users
[13:01:30] <dbaupp> engla: oh, right, you are correct
[13:01:34] <cmr> Camel cased types used to make sense because the compiler had broken spans and such when types weren't camel cased
[13:01:40] <cmr> but almost all of those seem to be fixed
[13:01:41] * dbaupp was wrong
[13:02:06] <dbaupp> cmr: why are uppercase constants a bad idea?
[13:02:14] <bstrie> I love the camel cased types idiom
[13:02:17] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[13:02:25] <engla> uppercase statics reminds me of less civilized languages like C
[13:02:48] <cmr> dbaupp: ugly and useless
[13:02:50] <bstrie> engla: that's likely not the only thing in rust that reminds us of C...
[13:02:52] <SiegeLord> I'm really liking the camel cased types + underscored functions... I've never used it myself before rust, but I think it looks great
[13:03:10] <engla> bstrie: we can keep the good parts
[13:03:28] <dbaupp> (should I change it to allow by default?)
[13:03:35] <bstrie> I think allow by default is fine
[13:03:38] <cmr> no I think this is good because of the bad errors
[13:03:44] <cmr> but once those are fixed, yes.
[13:03:51] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[13:03:54] <cmr> (I think it's a great idea to have a lint pass that enforces the style guide btw)
[13:04:25] <bstrie> cmr: open a bug to turn off the lint pass when the error messages are fixed
[13:04:31] <bstrie> otherwise nobody will ever remember
[13:04:45] <dbaupp> how about allow by default, but deny'd in the core crates?
[13:04:47] <bstrie> because nobody sane doesn't capitalize their statics :P
[13:04:55] <dbaupp> cmr: I'll do it in the bug about the error messages :)
[13:05:06] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[13:05:29] <dbaupp> w/e I'll leave it as is
[13:06:23] *** Joins: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP)
[13:06:30] <doomlord> ideally text editor syntax highlighting should differentiate types from variable names and functions
[13:06:37] <doomlord> color coding :)
[13:06:44] *** Quits: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de) (Quit: Verlassend)
[13:06:46] <doomlord> bold/italic.. whatever
[13:07:06] <doomlord> it should be easier for editors to handle with context-free-grammar, right?
[13:07:29] <SiegeLord> Even easier if you could use the case :P
[13:08:20] <bstrie> dbaupp: how does that lint pass interact with non-BMP variable names? :)
[13:08:42] <bstrie> or rather, non-latin variable names
[13:08:50] <dbaupp> bstrie: well, it actually checks for !is_lowercase()
[13:08:51] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[13:09:24] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[13:09:30] <dbaupp> bstrie: (and it corrects the camel case types one to do the same... there's even a test case https://github.com/mozilla/rust/pull/7523/files#diff-47 )
[13:09:34] <doomlord> i tend to prefer CamelCase function names... lowercase variables ... but i'm not religious on it
[13:09:42] <engla> dbaupp: nice
[13:09:57] <bstrie> rust's naming conventions are perfect to me
[13:10:06] <doomlord> so used to needing lowercase prefixes for things like 'global', etc..
[13:10:12] <cmr> doomlord: The Tim Sweeney slides are interesting
[13:10:29] <doomlord> yes, especially looking at rust now. SO much ticked off
[13:10:58] <doomlord> its' practically the lanuage he was asking for
[13:10:58] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Connection reset by peer)
[13:11:06] <cmr> Minus dependent types :p
[13:11:12] <cmr> http://smallcultfollowing.com/babysteps/blog/2013/06/11/data-parallelism-in-rust/ btw, if you haven't seen it yet
[13:11:36] <dbaupp> cmr, bstrie et al: https://github.com/mozilla/rust/issues/7526
[13:11:36] *** Joins: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net)
[13:11:46] <doomlord> yeah this is why i'm interested in map/reduce etc - why i like the idea of versions of these that require pure-functions
[13:11:59] <doomlord> as opposed to sequential-iterators working on code with side-effects
[13:12:02] *** Joins: igl1 (igl@moz-D83316AC.adsl.alicedsl.de)
[13:12:10] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[13:12:13] *** Quits: igl (igl@moz-84B72F4E.adsl.alicedsl.de) (Ping timeout)
[13:12:17] *** Quits: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de) (Quit: cr)
[13:12:19] <doomlord> par::map or pure::map perhaps...
[13:12:26] *** Joins: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net)
[13:13:05] <dbaupp> doomlord: https://github.com/mozilla/rust/wiki/Proposal-for-effects (for purity)
[13:14:31] <doomlord> thats interesting
[13:15:26] <cmr> dbaupp: are you done/mostly done the vec cleanup?
[13:15:33] <dbaupp> cmr: nope
[13:15:41] <cmr> Alright
[13:15:46] <dbaupp> why?
[13:15:51] <cmr> Mind pinging steve on https://github.com/mozilla/rust/pull/7223 when you are?
[13:16:12] <dbaupp> cmr: sure
[13:17:01] <btipling> so all rust characters take up 4 bytes?
[13:17:17] <thiez> nope
[13:17:22] <cmr> btipling: yes, they are UCS-4 encoded code points
[13:17:34] <cmr> but strings are utf-8, so variable width
[13:17:48] <cmr> (a str is not a sequence of char)
[13:18:03] <doomlord> is it best to get the latest version of rust from github or the tar described on the wiki
[13:18:09] <cmr> doomlord: github
[13:18:09] <btipling> how does one know when one byte ends and another byte begins, that's in the utf 8 spec I guess?
[13:18:27] <cmr> btipling: character, and it's standard variable-length encoding using the msb
[13:18:30] *** Joins: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de)
[13:18:43] <engla> utf-8 is a nice encoding, you can find the next character from any offset
[13:18:49] <btipling> ah ok cool
[13:18:53] <cmr> https://en.wikipedia.org/wiki/UTF-8
[13:19:57] <btipling> That's wesome
[13:21:35] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[13:21:50] <btipling> yes I also meant when the byte for one character ends and begins, but you understood that, as bytes are all the same length :P
[13:22:02] <engla> rusti: std::str::from_bytes(&[193, 121])
[13:22:03] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/UNJZ
[13:22:07] <engla> we must fix this though
[13:22:08] <btipling> er characters end and begin
[13:22:10] <engla> rusti: std::str::from_bytes(&[193, 128])
[13:22:11] <engla> oops
[13:22:11] -rusti- ~"@"
[13:22:13] *** Joins: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net)
[13:24:42] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:26:38] <engla> hm that should be easy to fix
[13:27:20] *** Joins: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:27:22] <btipling> what's the issue?
[13:27:25] *** Quits: pnkfelix1 (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Input/output error)
[13:27:39] *** pnkfelix is now known as pnkfelix|rcirc
[13:27:45] *** Joins: saml (sam@moz-14C16814.cst.lightpath.net)
[13:27:46] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:27:48] <engla> overlong encoding, which is that there are two ways of encoding characters
[13:28:12] <engla> utf-8 does not allow it and we don't want to have two ways to encode characters from ascii especially
[13:28:29] <engla> that can be a security issue too
[13:28:45] <doomlord> i find myself wishing it would define struct constructors by default .. Foo  {bar:A,baz:B}   .... ability to write Foo(2,3)  instead of Foo{bar:2,baz:3}... but is there reasoning behind this ?
[13:29:10] <doomlord> i gather people just make Foo::new(2,3) ... but its so common for me :)
[13:29:26] <engla> rusti: (std::str::from_bytes(&[193, 129]), std::str::from_bytes(&[65]))
[13:29:27] -rusti- (~"A", ~"A")
[13:29:40] <doomlord> is it part of keeping it context free ... i'm not sure because you can have tuple-structs - its not like it needs to distinguish the type from the function there
[13:30:12] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[13:31:21] <cmr> both tuple structs and enums generate constructors exactly like that
[13:31:39] <cmr> (although it's not syntax sugar: it literally generates constructor functions)
[13:31:41] <doomlord> oh i didn't think they did for structs
[13:31:51] <dbaupp> engla: (rust's utf8 support essentially sucks, it seems to still support 6 byte encodings)
[13:31:56] <cmr> for structs they don't
[13:32:02] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[13:32:22] <dbaupp> rusti: struct Foo(uint, uint); Foo(1,2) // only way to construct a Foo
[13:32:23] -rusti- {__field__: 1, __field__: 2}
[13:32:45] <SiegeLord> rusti: (1, 2)
[13:32:46] -rusti- (1, 2)
[13:32:49] <doomlord> ok i  know it works for tuple-structs.. its the named structs i'm after
[13:33:15] <doomlord> but is there some reason for why its done this way
[13:33:25] <cmr> probably not besides simplicity
[13:33:45] <cmr> open an issue for it and ask graydon/someone when they're on later
[13:34:05] <SimonSapin> Can I get a &str expression from a ~str?
[13:35:07] <doomlord> i would use tuple-structs a lot more .. if you could access the members without destructuring aswell 
[13:35:43] <cmr> rusti: let x = ~"foo"; println(fmt!("%?", x.as_slice))
[13:35:45] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/RSfF
[13:35:50] <cmr> rusti: let x = ~"foo"; println(fmt!("%?", x.as_slice()))
[13:35:51] -rusti- "foo"
[13:35:52] -rusti- ()
[13:36:04] <doomlord> eg. if i make  Range(T,T) ... i'm happy to have min,max or start/end being anonymous ... its just the fact i would *always* have to destructure that discourages me
[13:36:12] <SimonSapin> my code goes like this:  i32::from_str(if cond { s } else { str::slice(s, ) })  where s is ~str
[13:36:48] *** Quits: bytbox (s@moz-D4F26CEB.hsd1.md.comcast.net) (Ping timeout)
[13:36:53] <SimonSapin> the if does not typecheck as the branches have different types (~str and &str) even though ~str would be passed as a &str argument
[13:36:58] <cmr> SimonSapin: use s.as_slice in the first
[13:37:00] <SimonSapin> (s as &str) does not help
[13:38:22] <SimonSapin> cmr: ah, thats more recent that the rust version used in servo
[13:38:31] <cmr> SimonSapin: s.slice(0, s.len()) then
[13:38:46] <cmr> or, str::slice(s, 0, s.len()), depending on how old it is
[13:39:07] <SimonSapin> Or distribute the i32::from_str
[13:39:10] <SimonSapin> ugly, but meh
[13:39:32] <pnkfelix> doomlord: is defining helper-traits with first, second, etc methods not a palatable solution for that?  (Just thinking out loud; you'd still have to impl the trait and put the destructure in there.)
[13:40:05] <dbaupp> doomlord: (you could even impl the Tuple traits in std::tuple)
[13:40:06] <doomlord> would you need 'first of 2,second of 2', 'first of 3, second of 3...' etc
[13:40:25] <doomlord> its just *so* common it would be nice to build into the language :)
[13:40:30] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: igl1 (igl@moz-D83316AC.adsl.alicedsl.de) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: mw (mw@moz-5AC816E9.adsl.highway.telekom.at) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: nano (nano@moz-972880B.superkabel.de) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: donri (dag@moz-9BB61102.tbcn.telia.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: lucian (lucian@6B2B4644.4304AE1E.CE5E78F6.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: BitPuffin (quassel@moz-49828767.cust.tele2.se) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: n00b6502 (kwr5y54@moz-6651F8D4.range86-145.btcentralplus.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: CarpNet (ac@moz-FD24B77.sohonet.co.uk) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: davbo (dave@moz-3FFA637C.oucs.ox.ac.uk) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: joshua_ (joshua@moz-45967CBE.emarhavil.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: busylizzy (lisa@FC306F0C:BF233E95:2EB9049C:IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: dsirenko (mitra@moz-6CD77AE5.led-01.ru.sixxs.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: kimundi (kimundi@moz-58389D08.dip0.t-ipconnect.de) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: bjz (brendanzab@moz-D2E3CABC.lns6.cha.bigpond.net.au) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: doener (doener@moz-121949B3.unitymediagroup.de) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: kini (kini@8CE7D24D:6948BCE:9B80811F:IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: Houm (Houm@CEBDB141:FB5FB975:C1FCFA8A:IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: aatch|gone (aatch@31200FE3:ADAA592:416E6388:IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: zslayton (Mibbit@moz-14AA87A9.nyc.res.rr.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: prudhvi (prudhvi@moz-154A460A.supr.io) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: jyeo (uid12229@moz-C944F5EC.irccloud.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: dormiens (dormiens@2F2DB458.B767B9B7.2675F9C0.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: barosl (barosl@E287D94F.C81E10FB.7544CABF.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: robertknight (robertknig@moz-54528EE0.wby.mendeley.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: _1126 (1126@moz-83D60E55.lileth.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: geomyidae__ (uid214@moz-C944F5EC.irccloud.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: ruediger (quassel@moz-C9B8D8D0.org) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: heftig (heftig@moz-C12DDF6A.heftig.linuxsecured.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: jpf (jan@moz-A8C26A15.org) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: zol (Zolomon@moz-CE018D85.members.linode.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: klutzy (th@BA61F396.8E859986.ECA1BB11.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: Kroisse (Kroisse@7CF4064D.E3B51CAE.ECA1BB11.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: chee (chee@moz-E5A0DD8.org) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: pcdummy (quassel@moz-CF4CA865.page4me.ch) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: hansjorg (hansjorg@moz-41C5CE61.redpill-linpro.com) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: cade (cadecairos@BBD22340:2039A81A:2829DA14:IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: petantik (oz@399731BC:E9BA9B39:2829DA14:IP) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: thiez (thiez@moz-8F8FE2C.student.utwente.nl) (concrete.mozilla.org sand.mozilla.org)
[13:40:30] *** Quits: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net) (concrete.mozilla.org sand.mozilla.org)
[13:40:32] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[13:40:37] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[13:40:41] *** Joins: petantik (oz@moz-20EC2160.net)
[13:40:47] *** Joins: cadecairos (cadecairos@moz-DB3BF95F.members.linode.com)
[13:41:08] <btipling> :(
[13:41:08] *** Joins: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net)
[13:41:20] *** Joins: Kroisse (Kroisse@7CF4064D.E3B51CAE.ECA1BB11.IP)
[13:42:02] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[13:42:02] *** Joins: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP)
[13:42:03] *** Joins: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt)
[13:42:04] *** Joins: MrFahrenheit (RageOfThou@3FEF494C.29C984D5.783DEDCA.IP)
[13:42:04] *** Joins: geomyidae__ (uid214@moz-C944F5EC.irccloud.com)
[13:42:08] *** Joins: doomlord (doomlod@moz-6651F8D4.range86-145.btcentralplus.com)
[13:42:08] *** Joins: dormiens (dormiens@2F2DB458.B767B9B7.2675F9C0.IP)
[13:42:09] *** Joins: igl (igl@moz-D83316AC.adsl.alicedsl.de)
[13:42:09] *** concrete.mozilla.org sets mode: +R 
[13:42:11] <cmr> I also dislike using tuples and tuple structs for that reason, I wish one could index into them.
[13:42:14] *** Joins: nano (nano@moz-972880B.superkabel.de)
[13:42:16] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[13:42:18] *** Joins: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP)
[13:42:18] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[13:42:20] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[13:42:22] *** Joins: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de)
[13:42:30] *** Joins: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be)
[13:42:35] <doomlord> i like the fact they exist, its nice to be able to omit names
[13:42:41] *** Joins: heftig (heftig@moz-71A49FFB.dip0.t-ipconnect.de)
[13:42:42] *** Joins: zheng_li (zheng_li@moz-D6711E9E.xenplanet.org)
[13:43:06] *** Joins: Earnestly (earnest@2A2BF8F5.321FA5E6.BFD1ABFD.IP)
[13:43:48] <doomlord> i start to feel one thing added but another taken away without straigthforward constructors (plain C does allow initialization like that , and c++ you can make the constructor yourself but i;d like that automated there aswell)
[13:44:05] <doomlord> ... still... its hardly a killer for me
[13:44:21] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[13:44:40] *** Joins: jyeo (uid12229@moz-C944F5EC.irccloud.com)
[13:44:47] <SimonSapin> Is it new that this channel requires a registered nick?
[13:45:03] <cmr> SimonSapin: flooding from the netsplit
[13:45:17] <bstrie> SimonSapin: I think it's the entire server that requires it now
[13:45:19] <cmr> or whatever that was
[13:47:07] *** concrete.mozilla.org sets mode: -R 
[13:47:09] *** Joins: flowsnake (flowsnake@moz-1918C33E.aztw.cable.virginmedia.com)
[13:47:13] *** Joins: thiez (thiez@moz-8F8FE2C.student.utwente.nl)
[13:47:14] *** Joins: kimundi (kimundi@moz-58389D08.dip0.t-ipconnect.de)
[13:47:42] *** Joins: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:48:02] *** Joins: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP)
[13:48:12] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[13:49:01] *** Joins: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP)
[13:49:23] *** kimundi is now known as zz_kimundi
[13:49:37] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:49:44] *** Joins: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de)
[13:49:53] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[13:49:53] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/paT8lQ
[13:49:54] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[13:49:55] *** Joins: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP)
[13:49:55] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/pFMx0Q
[13:49:55] <ghrust> 13rust/06auto 140801861 15Alex Crichton: Turn on using LLVM threadsafely
[13:49:55] <ghrust> 13rust/06auto 14d22c81c 15bors: auto merge of #7409 : alexcrichton/rust/threadsafe, r=cmr...
[13:49:55] *** Parts: ghrust (ghrust@24260B07.6A2AE50.F3114085.IP) ()
[13:49:56] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:50:32] *** Joins: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP)
[13:50:33] *** Joins: doener (doener@moz-121949B3.unitymediagroup.de)
[13:52:46] *** Joins: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP)
[13:52:51] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Quit: jorendorff)
[13:53:18] *** Quits: pyrac (pyrac@EDE6BD92.73C89388.AD05C589.IP) (Quit: pyrac)
[13:53:33] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:54:14] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[13:54:20] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[13:54:25] *** Joins: cubic (cubic@moz-FE5AD6C7.mc.videotron.ca)
[13:54:25] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[13:55:34] *** Joins: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com)
[13:56:41] *** Joins: jarod (Mibbit@7F6AD7E.DFD54BC0.ABA4ADC1.IP)
[13:57:01] *** Joins: bytbox (s@moz-588B96FF.washdc.fios.verizon.net)
[13:57:07] *** Joins: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net)
[13:58:32] *** Quits: jarod (Mibbit@7F6AD7E.DFD54BC0.ABA4ADC1.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[13:58:56] *** Quits: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com) (concrete.mozilla.org sand.mozilla.org)
[13:58:56] *** Quits: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP) (concrete.mozilla.org sand.mozilla.org)
[13:58:56] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (concrete.mozilla.org sand.mozilla.org)
[13:58:56] *** Quits: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP) (concrete.mozilla.org sand.mozilla.org)
[13:58:56] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (concrete.mozilla.org sand.mozilla.org)
[13:58:56] *** Quits: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de) (concrete.mozilla.org sand.mozilla.org)
[13:59:01] *** Quits: jorendorff (jorendorff@moz-2F32ACA3.hsd1.tn.comcast.net) (Ping timeout)
[13:59:02] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[13:59:08] *** Joins: fabiand (fabiand@moz-2B74AB75.adsl.alicedsl.de)
[13:59:20] *** Joins: klutzy (th@BA61F396.8E859986.ECA1BB11.IP)
[13:59:31] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[14:01:12] *** Joins: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP)
[14:01:32] *** Joins: kini (kini@moz-92AA953A.members.linode.com)
[14:04:21] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[14:05:19] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[14:06:48] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Client exited)
[14:07:11] *** Joins: victorporof (victorporo@74A9C5E8.1745F5FA.9B1E38F4.IP)
[14:08:13] <bstrie> the release is tomorrow, yeah?
[14:09:17] <cmr> today I thought
[14:09:22] <cmr> brson already made an rc
[14:09:55] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:09:58] *** Joins: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP)
[14:10:53] <doomlord> i've just tried to update - grab from gitgub, rebuild, make install - when trying to use the new rustc i get an aerror "multiplematching crates for std" (candidates...")
[14:11:08] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[14:11:14] <doomlord> should i just rm /usr/local/lib/rustc and redo make install ?
[14:11:18] <cmr> exactly
[14:11:52] <jedestep> 0.7 is releasing tomorrow?
[14:12:03] <doomlord> ok great that works.
[14:12:45] *** Joins: mib_o3bxiz (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP)
[14:12:48] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[14:15:26] <MaikKlein> doomlord, u can also do a make uninstall
[14:15:44] <doomlord> ok
[14:16:36] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[14:17:03] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[14:17:05] *** Joins: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net)
[14:17:21] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[14:19:14] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[14:19:17] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[14:19:24] <jedestep> macros currently can't be exported to external crates correct?
[14:20:27] <cmr> correct
[14:20:35] *** Joins: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com)
[14:20:47] <jedestep> will this eventually be incorporated or is it not planned
[14:20:52] <cmr> it is planned.
[14:20:55] <jedestep> excellent
[14:21:49] *** Quits: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com) (concrete.mozilla.org sand.mozilla.org)
[14:21:49] *** Quits: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net) (concrete.mozilla.org sand.mozilla.org)
[14:21:49] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (concrete.mozilla.org sand.mozilla.org)
[14:21:50] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[14:22:09] *** Joins: roo (jesse.rudo@moz-FAF2828A.dynamic.ip.windstream.net)
[14:22:22] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[14:22:28] *** Joins: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com)
[14:27:20] <bstrie> jedestep: it is planned, but apparently quite difficult
[14:27:50] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:28:53] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[14:28:58] <dbaupp> I think the main blocker is not having to depend on librustc to read metadata (since it all has to happen in libsyntax), and, from what I've seen, that's a pretty hefty blocker
[14:29:06] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[14:29:37] <SimonSapin> so is there magic for all the built-in macros like fail!() ?
[14:29:54] <cmr> yes
[14:30:04] <cmr> it injects a string containing all of the built-in macros into every crate
[14:30:37] *** Joins: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com)
[14:31:49] *** Quits: hansjorg_ (hansjorg@moz-41C5CE61.redpill-linpro.com) (concrete.mozilla.org sand.mozilla.org)
[14:31:49] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (concrete.mozilla.org sand.mozilla.org)
[14:32:00] *** Quits: Axord (xord@moz-C3CCF156.lsanca.dsl-w.verizon.net) (Quit: I'm sure it's perfectly safe)
[14:32:10] *** Joins: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP)
[14:32:13] <engla> not everything with !() is a macro, there are some syntax extensions too SimonSapin
[14:32:27] <cmr> right, like fmt!(0
[14:32:37] <SimonSapin> oh
[14:32:48] <engla> ah I was just thinking of line!() 
[14:33:00] <cmr> (and bytes!() I think)
[14:33:02] <cmr> but yeah :p
[14:33:12] <SimonSapin> what does bytes!() do?
[14:33:19] <cmr> rusti: bytes!("foo")
[14:33:19] -rusti- &[102, 111, 111]
[14:33:21] <cmr> bytes literals!
[14:33:28] <cmr> rusti: bytes!(1, 2, 'c')
[14:33:28] -rusti- &[1, 2, 99]
[14:34:06] <MaikKlein> rusti: bytes!(10,"hello",~[1,2,3,4,5])
[14:34:07] -rusti- <anon>:9:9: 10:5 error: Non-literal in bytes!
[14:34:07] -rusti- <anon>:9          bytes!(10,"hello",~[1,2,3,4,5])
[14:34:07] -rusti- <anon>:10     };
[14:34:07] -rusti- error: aborting due to previous error
[14:34:07] -rusti- application terminated with error code 101
[14:34:20] <cmr> MaikKlein: ~[] isn't a literal
[14:34:25] <SimonSapin> rusti: bytes!(a)
[14:34:26] -rusti- <anon>:9:9: 10:5 error: Non-literal in bytes!
[14:34:26] -rusti- <anon>:9          bytes!(a)
[14:34:26] -rusti- <anon>:10     };
[14:34:26] -rusti- error: aborting due to previous error
[14:34:26] -rusti- application terminated with error code 101
[14:34:39] <SimonSapin> rusti: bytes!('@')
[14:34:40] -rusti- &[64]
[14:34:51] <SimonSapin> rusti: byte!('@')
[14:34:52] -rusti- <anon>:9:9: 9:13 error: macro undefined: 'byte'
[14:34:52] -rusti- <anon>:9          byte!('@')
[14:34:52] -rusti-                   ^~~~
[14:34:52] -rusti- application terminated with error code 101
[14:34:53] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Ping timeout)
[14:35:01] <cmr> unfortunately there is no byte!() yet
[14:35:27] <SimonSapin> '@' as u8 is shorter :)
[14:35:37] <cmr> and also doesn't work in patterns
[14:35:57] <dbaupp> cmr: neither would byte!()
[14:36:02] <cmr> dbaupp: why not?
[14:36:06] <MaikKlein> rusit: ~[1,2,3,4] as u8
[14:36:14] <MaikKlein> rusti: ~[1,2,3,4] as u8
[14:36:15] -rusti- <anon>:9:9: 9:25 error: non-scalar cast: `~[<VI3>]` as `u8`
[14:36:15] -rusti- <anon>:9          ~[1,2,3,4] as u8
[14:36:15] -rusti-                   ^~~~~~~~~~~~~~~~
[14:36:15] -rusti- error: aborting due to previous error
[14:36:16] -rusti- application terminated with error code 101
[14:36:23] <dbaupp> cmr: macros are allowed precisely where an expression or item is legal
[14:36:26] <MaikKlein> rusti: [1,2,3,4] as u8
[14:36:26] -rusti- <anon>:9:9: 9:24 error: non-scalar cast: `[<VI3>, .. 4]` as `u8`
[14:36:26] -rusti- <anon>:9          [1,2,3,4] as u8
[14:36:27] -rusti-                   ^~~~~~~~~~~~~~~
[14:36:27] -rusti- error: aborting due to previous error
[14:36:27] -rusti- application terminated with error code 101
[14:36:29] *** Quits: sankha93 (Instantbir@9276287F.8CAC2DA9.D2D1FAF0.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[14:36:32] <dbaupp> cmr: (and patterns aren't such a place)
[14:36:32] <SimonSapin> rusti: ~[1,2,3,4] as ~[u8]
[14:36:33] -rusti- <anon>:9:9: 9:28 error: non-scalar cast: `~[<VI3>]` as `~[u8]`
[14:36:33] -rusti- <anon>:9          ~[1,2,3,4] as ~[u8]
[14:36:33] -rusti-                   ^~~~~~~~~~~~~~~~~~~
[14:36:33] *** concrete.mozilla.org sets mode: +M 
[14:36:33] -rusti- error: aborting due to previous error
[14:36:34] -rusti- application terminated with error code 101
[14:36:42] <MaikKlein> rusti: [1,2,3,4].to_bytes()
[14:36:43] -rusti- <anon>:9:9: 10:5 error: type `[<VI3>, .. 4]` does not implement any method in scope named `to_bytes`
[14:36:43] -rusti- <anon>:9          [1,2,3,4].to_bytes()
[14:36:43] -rusti- <anon>:10     };
[14:36:43] -rusti- error: aborting due to previous error
[14:36:44] -rusti- application terminated with error code 101
[14:36:45] <cmr> dbaupp: are the things in match arms called something other than patterns?
[14:38:25] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Quit: dbaupp)
[14:38:28] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[14:38:51] *** Parts: dualhbridge (dad@moz-9FEE6D3B.maine.res.rr.com) ()
[14:39:41] <MaikKlein> rusti: int::from_str(~"123");
[14:39:43] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bdLg
[14:40:02] <MaikKlein> rusti: std::int::from_str(~"123")
[14:40:03] -rusti- <anon>:9:28: 9:34 warning: unnecessary allocation, the sigil can be removed [-W unnecessary-allocation (default)]
[14:40:03] -rusti- <anon>:9          std::int::from_str(~"123")
[14:40:03] -rusti-                                      ^~~~~~
[14:40:03] -rusti- Some(123)
[14:40:25] <MaikKlein> when can I say just "" instead of ~""
[14:40:32] <MaikKlein> just say*
[14:40:35] <cmr> MaikKlein: whenever a & is wanted
[14:40:40] <cmr> &str that is
[14:40:43] <MaikKlein> ok
[14:41:12] <MaikKlein> rusti: ~"5".to_int()
[14:41:14] -rusti- <anon>:9:10: 10:5 error: type `&'static str` does not implement any method in scope named `to_int`
[14:41:14] -rusti- <anon>:9          ~"5".to_int()
[14:41:14] -rusti- <anon>:10     };
[14:41:14] -rusti- error: aborting due to previous error
[14:41:14] -rusti- application terminated with error code 101
[14:41:37] *** concrete.mozilla.org sets mode: -M 
[14:41:58] <dbaupp> cmr: not sure what you mean, but `match foo { this_thing_is_a_pattern => bar }`
[14:42:40] <MaikKlein> rusti: bytes!(42)
[14:42:41] -rusti- &[42]
[14:42:42] <engla>  dbaupp but it could be a syntax extension, not a macro, would that change things?
[14:42:50] <dbaupp> engla: nope
[14:43:24] <dbaupp> engla: syntax extensions are only special in that they are implement in Rust (directly manipulating an ast), they go through exactly the same process as user defined macros
[14:43:56] <dbaupp> *implemented
[14:43:58] <engla> ok
[14:44:13] <MaikKlein> when do I even want to use macros? I see that they are useful for fmt! or fail! or debug!, but are there other use cases?
[14:44:53] <engla> some templating to avoid code repetition
[14:45:04] <cmr> dbaupp: so https://github.com/mozilla/rust/issues/4334#issuecomment-18144094 is wrong?
[14:45:05] <MaikKlein> aren't traits for this?
[14:45:19] <engla> for example a tuple implementation of a trait for n-tuples of n=2,3,4,..
[14:45:21] <cmr> MaikKlein: no, traits don't help in some cases. see std::num
[14:45:22] <Ms2ger> Apparently it's useful for things that C++'s templates can do, but rust's can't
[14:45:43] <dbaupp> rusti: match 1 { fail!() => 1 }
[14:45:44] -rusti- <anon>:9:23: 9:24 error: expected `=>` but found `!`
[14:45:44] -rusti- <anon>:9          match 1 { fail!() => 1 }
[14:45:44] -rusti-                                 ^
[14:45:44] -rusti- application terminated with error code 101
[14:45:56] <benh> I wonder if you could port the entirety of C++'s template system to macros.........
[14:45:56] <dbaupp> cmr: yeah, I think so
[14:46:03] <cmr> dbaupp: that is unfortunate :(
[14:46:08] <engla> MaikKlein: implementations using &T and &mut T for example
[14:46:14] <cmr> benh: no reason you couldn't, they're turing complete iirc
[14:46:18] <benh> rusti: match 1 { (fail!()) => 1 }
[14:46:19] -rusti- <anon>:9:24: 9:25 error: expected `,` but found `!`
[14:46:19] -rusti- <anon>:9          match 1 { (fail!()) => 1 }
[14:46:19] -rusti-                                  ^
[14:46:19] -rusti- application terminated with error code 101
[14:46:23] <MaikKlein> hm k
[14:46:45] <benh> cmr: well, while approximating their user experience/syntax/"interface"
[14:46:51] <SiegeLord> I'd say they have nothing to do with C++ templates... they are just more safe macros
[14:47:00] <SiegeLord> *more safe CPP macros
[14:47:01] <cmr> MaikKlein: plus all the fun metaprogramming you can do. compile-time regex etc (although that's more in the realm of syntax extensinos)
[14:48:44] <cmr> MaikKlein: and anything you'd use macros for in a lisp
[14:49:15] <engla> the hashmap "literal" someone showed yesterday
[14:49:20] <SiegeLord> C++ templates can do logic based on types, and Rust macros can't
[14:49:29] <SiegeLord> Maybe syntax extensions can
[14:49:33] <engla> or the iterator comprehension macro to mimic python syntax
[14:49:50] <cmr> They could if they ran typeck on their input, but otherwise they just get a token tree
[14:50:08] <cmr> (parsed *and* ran typeck, and all sorts of other stuff that rustc already does)
[14:50:20] <roo> https://gist.github.com/jessopher/5901430#file-parser-rs-L84 stuck on the simplest part of this parser combinator
[14:50:58] <engla> and it's easy to write a for_each!(pattern in iterator { body })  to make a closure free loop macro for iterators
[14:51:14] <engla> maybe rust has too much syntax and should leave it to macros ^^
[14:51:42] <dbaupp> fn!(foo(x: uint) -> bar { .. })
[14:51:48] <SiegeLord> I don't know if macros can do typechecking
[14:51:51] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (Client exited)
[14:51:55] <SiegeLord> It seems it'd complicate things quite a bit
[14:51:57] <Ms2ger> Not too much syntax, just ugly syntax ;)
[14:52:15] <dbaupp> SiegeLord: they can't, but their output does get typechecked
[14:52:29] <dbaupp> SiegeLord: (at least, not without the hack cmr mentions)
[14:52:31] <SiegeLord> I'd hope so ;)
[14:52:50] <cmr> Ms2ger: what syntax would you prefer?
[14:53:30] <SiegeLord> dbaupp, What hack?
[14:53:31] <Ms2ger> cmr, oh, sorry, I'm just the peanut gallery :)
[14:54:00] <dbaupp> SiegeLord: "They could if they ran typeck on their input, but otherwise they just get a token tree (parsed *and* ran typeck, and all sorts of other stuff that rustc already does)"
[14:54:18] <engla> I think it sounds tempting to remove the for loop. but that would be a very different language.. also macros are terrible to introduce to newcomers
[14:54:19] <doomlord> I'm trying to declare a trait that builds on another trait - whats the syntax for that.. i'm trying to make default implementations that come from another 'base' trait - but its not having it (are default implemenations broken )
[14:54:19] <SiegeLord> That seems easier said than done
[14:54:29] <cmr> SiegeLord: yes, it most certainly is
[14:54:42] <dbaupp> SiegeLord: it's not actually that hard
[14:54:51] <dbaupp> (getting the output of typeck might be tricky though)
[14:54:51] <cmr> doomlord: can you gist some code?
[14:55:04] <dbaupp> doomlord: yes
[14:55:07] <dbaupp> (I think so
[14:55:08] <dbaupp> )
[14:55:17] * Ms2ger would like a for x in y loop
[14:55:29] <doomlord> ok i'll paste (yes broken? ) ... I can implement manually without default impls.. and leave those commented out for my purpose..
[14:55:31] <cmr> Ms2ger: I agree
[14:55:35] <SimonSapin> +1, Ms2ger
[14:56:00] <dbaupp> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} 1u.bar()
[14:56:01] -rusti- ()
[14:56:01] <cmr> doomlord: Well, you need #[allow(default_methods)] I think
[14:56:16] * dbaupp quite likes `for y |x| { }`
[14:56:25] <dbaupp> doomlord: actually, maybe it does work
[14:56:25] <engla> I don't like that it uses a closure
[14:56:46] <dbaupp> doomlord: (you'll need a pretty recent compiler though)
[14:56:49] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Client exited)
[14:56:51] <dbaupp> engla: yeah, that's due to change
[14:57:02] <cmr> I like that for y |x| reads well from left to right, but mimicing the closure syntax is a huge nono
[14:57:12] <engla> right, and we can't keep the closure syntax if it's not a closure
[14:57:54] <benh> for y => x { } to mimick matches instead?
[14:58:10] <benh> (awkwardly)
[14:58:43] <SimonSapin> it doesnt really mimic match
[14:58:43] <dbaupp> benh: except it's backwards :(
[14:58:49] <Ms2ger> cmr, maybe it's just habit, but I don't know if for y |x| reads much better than the other way around
[14:58:50] <doomlord> (i grabbed the compiler just now from github and rebuilt 2 hours ago)
[14:58:52] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (Ping timeout)
[14:58:53] <dbaupp> for y x => { }
[14:59:10] <dbaupp> doomlord: that should be recent enough :)
[14:59:22] <doomlord> i had other issues .. out of date numerics :)
[14:59:37] <cmr> Ms2ger: I don't think it's really a problem, I still favor `for x in y`
[14:59:44] <jedestep> for y: x { }
[15:00:03] <cmr> definitely not, ew
[15:00:04] <benh> I'm suspicious of the y: x variant because I can never remember whether the iterable or the iteratee goes first
[15:00:18] <Ms2ger> Crap, did I start a bikeshed? :)
[15:00:20] <benh> also it looks a bit like types :)
[15:00:25] <cmr> Ms2ger: more like revived :p
[15:00:25] <engla> for &x: range(0, 10) { }    it's like c++11 syntax.. a bit
[15:00:38] *** Joins: hansjorg (hansjorg@moz-41C5CE61.redpill-linpro.com)
[15:00:56] <engla> for x <- vec { .. }
[15:00:58] <benh> maybe forM y $ \x -> { ... }, there's precedent
[15:00:58] <Ms2ger> cmr, I guess that's a little better :)
[15:01:15] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[15:01:49] <cmr> benh: I don't care whay syntax we get as long as it isn't *that* :P
[15:01:54] <cmr> *what
[15:02:11] *** Joins: tristram (tristram@moz-C498CC41.eu)
[15:02:12] <SiegeLord> for(let mut y = x.next(); y.is_some(); y = y.next()) {}
[15:02:42] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[15:02:48] *** Quits: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP) (concrete.mozilla.org sand.mozilla.org)
[15:02:48] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (concrete.mozilla.org sand.mozilla.org)
[15:02:48] *** Quits: hansjorg (hansjorg@moz-41C5CE61.redpill-linpro.com) (concrete.mozilla.org sand.mozilla.org)
[15:02:56] <Ms2ger> \@for\cs:=y\do{}
[15:03:22] <benh> loop x for y { } or for x loop y { }   >:)
[15:03:23] *** Joins: Sodel_the_V (user@moz-853663E1.va.shawcable.net)
[15:04:14] <doomlord> http://pastebin.com/d40fDfpj  <<< ok it compiles, but i've left what i was trying to do commented out...
[15:05:21] <doomlord> its 'trait VecOps' that i wanted to have default impls' depending on operations in 'VecPrimOps'.. but couldn't seem to figure out the syntax or get it working
[15:05:21] <cmr> doomlord: yeah, traits can't access fields
[15:05:22] <bstrie> so the new for protocol didn't make it into 0.7?
[15:05:28] <cmr> bstrie: no
[15:05:38] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[15:05:39] <doomlord> so i''d need accessor functions at  least, i guessed that;
[15:05:48] <dbaupp> doomlord: what does it complain about?
[15:06:08] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[15:06:27] *** Joins: sankha93 (Instantbir@4C1B4135.A5E24E6D.8B6C1D65.IP)
[15:06:32] <doomlord> if i uncomment - "type Self does not implement any method in scope named mul" .. now as it stands there is nothing saying Self:VecPrimOps
[15:06:36] <cmr> doomlord: and you could do trait VecOps<T: VecPrimOps> { ... }  and use T instead of Self
[15:06:48] <doomlord> i'lll try again..
[15:06:51] <dbaupp> cmr: that seems bad
[15:07:00] <cmr> or, trait VecOps: VecPrimOps { ... }?
[15:07:09] <dbaupp> doomlord: ^
[15:07:11] <bstrie> how about turning `for bar |x| {` into `for bar as x {` to make both camps happy :)
[15:07:13] <dbaupp> cmr: that's right
[15:07:37] <dbaupp> bstrie: breaks context-free-ness, I think
[15:07:49] <bstrie> or we could do the javascript thing... `for bar of x {` :P
[15:08:43] <doomlord> its telling me i need a compiler switch , i tried rustc tset.rs -D default-methods
[15:08:55] <doomlord> test.rs:117:0: 124:1 error: default methods are experimental [-D default-methods]
[15:09:09] <cmr> it's telling you which switch generated that error
[15:09:14] <cmr> you want -A default-methods
[15:09:15] <dbaupp> doomlord: put #[allow(default_methods)]; at the top of the file
[15:09:16] <cmr> (allow)
[15:09:31] <dbaupp> (that enables default methods for the whole module & submodules)
[15:09:49] <dbaupp> doomlord: (including the ;)
[15:10:10] <doomlord> works! thanks
[15:10:11] <cmr> Bah that semicolon is so easy to forget
[15:10:24] <Ms2ger> bstrie, JS has for element of collection, note
[15:11:07] <cmr> roo: so what your inject function does is create a closure that captures v by move and returns it
[15:11:19] <cmr> roo: which isn't allowed, because the closure could be called multiple times.
[15:11:31] <cmr> 'once fn' is an experimental feature that allows this
[15:11:36] <cmr> only lets a closure be called once
[15:11:45] <doomlord> yum :) default impls !!!
[15:12:42] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[15:13:04] <roo> cmr: ok. Yeah that makes sense... not used to thinking about combinator libraries in impure terms.
[15:14:35] <bstrie> how do I map over an iterator?
[15:14:46] <bstrie> .map and .map_ do not exist
[15:14:49] <cmr> bstrie: iter.transform(...)
[15:14:51] <dbaupp> bstrie: .transform
[15:14:53] <cmr> because of the resolve bug
[15:14:54] <bstrie> thanks
[15:16:27] <Ms2ger> Nobody suggested list comprehensions yet?
[15:16:33] <bstrie> why does .collect need a type hint?
[15:16:34] <cmr> Ms2ger: they did
[15:16:37] <bstrie> is that a bug or a fundamental limitation?
[15:16:40] <cmr> bstrie: because it's generic over all containers
[15:17:01] <cmr> you need to tell it which container you want somehow
[15:17:05] *** Quits: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de) (Quit: cr)
[15:17:10] <cmr> (though it's only implemented for vecs right now)
[15:17:27] <cmr> Ms2ger: http://www.reddit.com/r/rust/comments/1gag3t/list_comprehensions_in_rust_iterator/
[15:17:28] *** Joins: huseby (huseby@moz-7CCEB96B.kimsufi.com)
[15:17:48] <dbaupp> bstrie: I think it's a combination of both
[15:18:05] <dbaupp> bstrie: (at least, I'm hoping inference can get stronger, so that the type hint is needed less often)
[15:18:34] <bstrie> I'd be happy if the type hint syntax was just less ugly
[15:18:53] <doomlord> non copyable type self in method style functions.
[15:18:55] <bstrie> it's so bad that I'd be willing to give up a sane grammar for it
[15:19:23] <cmr> bstrie: you can do let x: ~[foo] = ... .collect()
[15:19:57] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[15:20:01] *** Quits: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP) (concrete.mozilla.org sand.mozilla.org)
[15:20:08] <doomlord> should i just use functions insteaed of methods ito avoid that..     fn lerp(self,other,factor) ->Self{ ...} <<< it complains i can't use 'self' twice, because its moved... and any attempts to copy , it tells me Self is not copyable
[15:20:19] <cmr> doomlord: use &self
[15:23:49] <roo> cmr: how do you tell the compiler that the closure is a 'once fn'?
[15:24:23] <cmr> roo: I think it's literally "~once fn" or "once ~fn", and you need -Z once-fns
[15:24:29] <doomlord> hmm. now it seems to object to passing that to places where it wanted self ; i can't seem to deref like in C (*self) , i also tried (copy self).MethodExpectingSelf...
[15:24:37] <roo> alright.
[15:24:43] <cmr> doomlord: you don't want to deref, &self is a pointer
[15:24:55] <cmr> oh I see
[15:25:02] <cmr> generally self-by-value is not desired
[15:25:09] <cmr> you almost always want to use &self
[15:25:19] <doomlord> ok let me refactor..
[15:25:36] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[15:25:36] <doomlord> ... if its &something small immutable, can the compiler optimize it as pass by value
[15:25:46] <doomlord> i could express this all as functions instead of methods
[15:26:00] <bstrie> why does .advance currently need to borrow the iterator as mutable
[15:26:12] <dbaupp> bstrie: it'll always need to do that
[15:26:14] <cmr> bstrie: because it calls .next() on it
[15:26:31] <cmr> immutable iterators are pretty much useles, can't do anything with 'em besides size_hint()
[15:26:33] <bstrie> so it's just to avoid the need to have .next() and .next_mut() ?
[15:26:34] <dbaupp> bstrie: the iterator stores it's current state, and it gets modified each time it is stepped
[15:26:40] <bstrie> ah right
[15:26:45] <bstrie> duh
[15:26:47] <doomlord> just trying it all as &self now..]
[15:26:47] <bstrie> now I get it :P
[15:27:07] <bstrie> was thinking to myself, "I'm not mutating these collections, why should it need to be mutable?"
[15:27:25] <bstrie> overlooking the fact that iterating changes the iterator...
[15:27:27] <dbaupp> you're not the first person with that exact question :)
[15:28:02] <cmr> doomlord: I don't think it does. You would have the same problems with functions, you'd just be using copies everywhere (which you can't do with default methods in traits because it doesn't know what type it is being imlpemented for, although you might be able to do trait Foo<T: Send> or sth)
[15:28:26] <dbaupp> cmr: trait Foo: Copy { .. } allows for copying self
[15:28:37] <cmr> dbaupp: wasn't copy renamed to Send?
[15:28:46] <dbaupp> (although, it should be trait Foo: Clone {} and then calling .clone() )
[15:28:50] <dbaupp> cmr: don't think so?
[15:29:00] <cmr> oh that was Owned
[15:29:02] <cmr> nevermind me :)
[15:29:11] <cmr> doomlord: listen to dbaupp, he knows what he's doing
[15:29:27] <dbaupp> cmr: that's not true :P
[15:31:27] <bstrie> this is so weird
[15:31:33] <bstrie> someone please tell me that this is a bug
[15:31:41] <bstrie> when I do a .transform() on the iterator
[15:31:48] <bstrie> it changes the signature of .advance()
[15:32:05] <dbaupp> hm?
[15:32:09] <bstrie> fg
[15:32:13] <bstrie> er, one sec
[15:32:27] <cmr> https://github.com/cmr/rustdoc-prototype
[15:32:35] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[15:32:35] *** Joins: dforsyth (dforsyth@A677A619.1C765EF.EE6E63A5.IP)
[15:32:54] <dbaupp> bstrie: (.transform actually creates a new iterator object, it essentially becomes MapIterator<OldIteratorType>, is that what you're seeing?)
[15:33:01] *** Quits: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net) (Ping timeout)
[15:33:40] <engla> bstrie: you can map to an iterator of a new type
[15:34:19] <engla> from an iterator of &T to an iterator of U
[15:34:22] <engla> or whatever
[15:34:35] <acrichto> cmr: could I get another r+ on https://github.com/mozilla/rust/pull/7040 ?
[15:34:40] <bstrie> dbaupp: look here
[15:34:45] <bstrie> rusti: let xs = [1,2]; for xs.iter().advance |x| { println(fmt!("%d", *x)); }
[15:34:45] -rusti- 1
[15:34:46] -rusti- 2
[15:34:46] -rusti- ()
[15:34:58] *** Joins: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net)
[15:34:59] <bstrie> rusti: let xs = [1,2]; for xs.iter().transform(|x| x*2).advance |x| { println(fmt!("%d", *x)); }
[15:35:00] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/eGjQ
[15:35:00] <cmr> acrichto: wrong link? that is closed.
[15:35:17] *** Joins: Excureo (c@moz-EB93D257.static.knwc.wa.charter.com)
[15:35:17] <bstrie> dbaupp: when you do a transform, suddently advance expects a raw int rather than a pointer to an int
[15:35:23] <acrichto> cmr: whoops https://github.com/mozilla/rust/pull/7409
[15:35:27] *** Joins: diegoyam (quassel@FF9B1514.A4EC3D18.3A1EC144.IP)
[15:35:40] *** Joins: hansjorg (hansjorg@moz-41C5CE61.redpill-linpro.com)
[15:35:44] <bstrie> fg
[15:35:46] <bstrie> gah
[15:35:57] <acrichto> cmr: thanks
[15:36:02] <cmr> acrichto: np
[15:36:05] <dbaupp> rusti: let xs = [1,2]; for xs.iter().transform(|x| *x*2).advance |x| { println(fmt!("%d", x)); }
[15:36:06] -rusti- 2
[15:36:06] -rusti- 4
[15:36:06] -rusti- ()
[15:36:17] <engla> bstrie: advance gives a &int because that's the type of the vec iterator
[15:36:17] <dbaupp> bstrie: right, that's not a bug
[15:36:33] <bstrie> how is this not a bug?
[15:36:37] <dbaupp> bstrie: Iterator<T>.transform(&fn(T) -> U) -> Iterator<U>
[15:36:51] <engla> the bug is that x*2  compiles without a reference?
[15:36:55] <dbaupp> (~[T]).iter() -> Iterator<&T>
[15:37:02] <engla> *dereference
[15:37:05] <bstrie> ah I see
[15:37:14] <dbaupp> rusti: let xs = [1,2]; for xs.iter().transform(|x| x*2).advance |x| { println(fmt!("%d", x)); }
[15:37:15] -rusti- 2
[15:37:16] -rusti- 4
[15:37:16] -rusti- ()
[15:37:17] <bstrie> so I was multiplying the pointer??
[15:37:34] * dbaupp is confused
[15:37:35] <bstrie> is this a complication of autoderef?
[15:37:41] <doomlord> http://pastebin.com/5f7kEbph <<< i got it working with clone, but this feels odd, is there a better way
[15:37:43] <dbaupp> bstrie: possibly
[15:37:56] <dbaupp> rusti: let x = 1; let y = &x; y * 2
[15:37:57] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/bejX
[15:38:07] <dbaupp> rusti: let x = 1i; let y = &x; y * 2
[15:38:08] -rusti- 2
[15:38:15] *** Joins: mcstar (mcstar@moz-D7A16997.monradsl.monornet.hu)
[15:38:16] <engla> bstrie: yes, check the type inside transform
[15:38:59] <cmr> doomlord: problem is that self-by-value moves, and move deinitializes the old copy. there might be something else you can do, but I don't know what it is
[15:39:36] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Client exited)
[15:39:40] *** Joins: dualhbridge (dad@moz-F0E83B75.dyn-adsl.midmaine.net)
[15:40:03] *** Parts: dualhbridge (dad@moz-F0E83B75.dyn-adsl.midmaine.net) ()
[15:40:23] <bstrie> engla: so if I wanted advance to yield a pointer after .transforming it, how would I do that?
[15:40:52] <engla> you need somewhere to pin down the new value before you can borrow a pointer to it
[15:40:55] <engla> so you can't do that
[15:41:02] <cmr> bstrie: you'd need to allocate to do that.
[15:41:15] <cmr> or, maybe you don't? `*x*2; x` ?
[15:41:32] <dbaupp> bstrie: are you trying to have a branch that returns two different iterators which are then used later?
[15:41:43] <bstrie> dbaupp: no, just curious
[15:41:54] <dbaupp> bstrie: oh, ok
[15:42:22] <engla> the by reference iterator is awkward for ~[int] of course
[15:42:23] <cmr> What function can I set a breakpoint at to debug a task failure?
[15:42:26] <bstrie> dbaupp: in my case I was zipping [1,2,3] with ["one", "two", "three"] and when I was actually iterating I was weirded out by one of those being a pointer
[15:42:55] <dbaupp> cmr: rust_upcall_fail, iirc
[15:43:11] *** Joins: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP)
[15:43:34] <dbaupp> bstrie: right
[15:43:35] *** Joins: Blei (philipp@moz-650B9C6A.cust.bluewin.ch)
[15:43:48] <sanxiyn> Luqman: You are probably not here, but anyway
[15:43:56] <sanxiyn> Luqman: I forward ported #6725
[15:44:09] <cmr> dbaupp: yup that seemed to do it, thanks!
[15:44:14] <sanxiyn> Luqman: Newtype structs as immediates
[15:45:05] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[15:46:01] <doomlord> fn lerp<T:VecOps+Clone>( a:T,b:T,f:f32)->T { a.clone().add(b.sub( a).scale(f))}
[15:46:01] <doomlord>  <<<< this works as a free generic function, again weird. can't seem to make it work with copy.. only clone
[15:46:01] <sanxiyn> I need SIMD structs to be immediate (otherwise they won't be passed in registers), which is very similar
[15:46:52] <doomlord> this seems to be easier to write if i use concrete types , whihc is unexpected for me
[15:47:22] <sanxiyn> Apart from rebasing, I had to fix a bug
[15:47:38] <sanxiyn> -Datum { val: self.val, ty: ty, mode: ByValue }
[15:47:51] <sanxiyn> +Datum { val: ExtractValue(bcx, self.val, 0), ty: ty, mode: ByValue }
[15:47:58] <sanxiyn> val and ty need to change together
[15:48:18] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[15:48:50] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[15:50:48] *** Quits: huseby (huseby@moz-7CCEB96B.kimsufi.com) (Quit: Leaving)
[15:50:54] *** Joins: huseby (huseby@moz-4E8C421A.husebyhome.com)
[15:52:13] <doomlord> i seem to have to implement Clone for vec3, then i can  use my'lerp'... lots happening thats unexpected for me. is this simply the complexity of not having c++ references vs values re-emerging s copys ... or the complexity saved by rust automatically dereferencing pointers
[15:52:29] <doomlord> (reemerging )
[15:53:47] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[15:54:16] *** Quits: wilsonk|2 (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[15:54:18] <doomlord> would i get better results doing vector maths as tuples or [T,..N] instead of struct{...}
[15:54:47] <bstrie> doomlord: iirc bjz has a vector math library
[15:54:47] <doomlord> is this what C# deals with by having POD structs (pass by value) and class 
[15:55:07] <doomlord> ok but i have to know how to write  it myself... or i am not confident with the language
[15:55:16] <cmr> Also lmath is entirely broken
[15:55:24] <doomlord> i mean confident tthat i know that language.
[15:55:24] <cmr> so, there's that :p
[15:55:47] <cmr> doomlord: you should be fine using a struct
[15:55:57] <bstrie> doomlord: are you using #[deriving(Clone)] on your struct?
[15:56:14] <doomlord> what i ended up doing was impl Clone ... i didn't know you could derive 
[15:56:46] <bstrie> doomlord: yeah, the idea is that someone can write a custom clone implementation if they want to, but most people are fine with deriving it automatically
[15:57:02] <bstrie> though I'm not exactly sold on the idea of forcing everyone to tag every struct with that attribute
[15:57:11] * sanxiyn prays tests pass this time...
[15:57:17] <bstrie> doomlord: I have no idea what a lerp is, can you do it without copying?
[15:57:23] <cmr> sanxiyn: what is the status of SIMD, btw?
[15:57:25] <bstrie> sanxiyn: hello! it's been a while
[15:57:30] <sanxiyn> bstrie: Yeah
[15:57:34] <sanxiyn> cmr: Working on it again
[15:57:39] <doomlord> lerp=lineaer interpolation - i'd expect the structs are passed by value
[15:57:46] <bstrie> you can do that
[15:57:51] <bstrie> rust structs are just C structs
[15:57:51] <doomlord> it simply needs to reference the same argument multiple times
[15:58:03] <sanxiyn> cmr: If tests pass this time, it should be possible to pass SIMD structs in registers now
[15:58:20] <cmr> doomlord: you can't do that because by-value is a move, so you need a copy (in C/++ this is implicit in by-value params)
[15:58:37] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[15:58:39] <cmr> I think... I'm not so solid in this part of rust either :)
[15:58:43] <cmr> sanxiyn: awesome!
[15:58:48] <bstrie> doomlord: what's wrong with passing by reference?
[15:59:00] <doomlord> it works as you say if i write a concrete function - but if i use parameterized types i seem to need to write it very differently
[15:59:10] <doomlord> fn lerp( a:Vec3,b:Vec3,f:f32)->Vec3 { a.add(b.sub( a).scale(f))} <<<<< fine
[15:59:33] <sanxiyn> cmr: Well, even if this goes through you can't do any operation yet...
[15:59:34] <doomlord> fn lerp<a:Vec3Ops ....> <<<< language behaviour beyond my precise knowledge
[15:59:37] <dbaupp> doomlord: that's because Vec3 is implicitly copyable
[15:59:44] *** Joins: noam (noam@F6B530A7.720527A7.416762B.IP)
[15:59:44] <sanxiyn> cmr: Looking at Dart's SIMD support for inspiration now
[15:59:57] <bstrie> dbaupp: I thought we got rid of implicitly copyable things a million years ago
[15:59:58] <dbaupp> doomlord: and so with the concrete type, Rust automatically inserts `copy`s as appropriate
[16:00:12] <dbaupp> bstrie: nah, int, uint, float, etc
[16:00:23] <doomlord> fn lerp<T:VecOps+Clone>( a:T,b:T,f:f32)->T { a.clone().add(b.sub( a).scale(f))} <<<thats my fix
[16:00:24] <bstrie> ah
[16:00:25] <dbaupp> (and structs of them, apparently)
[16:00:31] <engla> things are still implicitly copyable, just not in generic functions
[16:00:41] <bstrie> weird, but makes sense
[16:00:43] <engla> T:Copy requires explicit copy
[16:00:54] <doomlord> ok this is surprising for me, but it makes more sense for something else?
[16:01:03] <sanxiyn> engla: I wonder why?
[16:01:16] <doomlord> if you were referencing complex objects... it wuold be pass by adress, and you wouldn't get these issues?
[16:01:19] <bstrie> doomlord: our entire copy/clone story right now is very muddled
[16:01:21] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[16:01:25] <doomlord> ok :)
[16:01:27] <engla> one reason is that copies and allocations need to be visible so you know what you're doing
[16:01:33] <bstrie> doomlord: lots is subject to change in this area
[16:01:39] <cmr> doomlord: in C it's just copying the value by pushing it to the stack before calling it, it's the same thing here, you just don't do it implicitly... I think
[16:01:44] <bstrie> so if it seems confusing, you're right!
[16:01:49] <dbaupp> doomlord: if add, sub and scale took &self, (and &Self), then fn lerp<T:VecOps>(a: &T, b:&T, f:f32)-> T { a.add(b.sub(a).scale(f)) } would work
[16:01:52] <engla> it's frustrating that you are supposed to use .clone() but only some types are clonable and lots are Copy
[16:02:05] <bstrie> yeah
[16:02:10] <sanxiyn> Tests passed this time!
[16:02:37] <doomlord> in C++... you deal with it manually  - you have this complexity because you dont want people to have to use . and -> like in C++ ?
[16:03:10] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Ping timeout)
[16:03:21] <cmr> doomlord: it's more of a memory safety thing that by-value moves
[16:03:24] <dbaupp> doomlord: not really, that's auto-derefing, which is orthogonal to explicit pass-by-reference
[16:03:28] <sp3d> I don't think you ever call methods with by-value self in C++
[16:03:46] <doomlord> dbaupp,  ok - i can rework everything to take adresses, although instinctively im after pass-by-value
[16:03:49] <dbaupp> sp3d: does that even make sense as a concept in C++?
[16:03:59] <dbaupp> doomlord: trust LLVM to do the right thing
[16:04:13] <doomlord> so if you pass the adress of a register and its inlined... :)
[16:04:15] <sp3d> you could call a copy constructor before running the regular method maybe
[16:04:34] <dbaupp> I guess
[16:04:37] <sanxiyn> dbaupp: LLVM does well inside functions, across functions I have some doubt...
[16:04:56] <sanxiyn> Well if you get inlined it works
[16:05:08] <doomlord> sanxiyn is LLVM capable of compiling a SIMD maths library in registers using vectors types as classes
[16:05:14] *** Quits: Jesin (Jessin_@moz-3AD6F09F.res.lehigh.edu) (Ping timeout)
[16:05:23] <doomlord> i remember when we got the xbox360 first, initially its compiler could NOT
[16:05:33] <doomlord> and one had to use typedefs/ c-like functions to acheive that
[16:05:55] <dbaupp> doomlord: (I guess, if you really *always* want by-value, then the Clone bound is required.)
[16:06:31] *** Joins: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net)
[16:06:58] <sanxiyn> doomlord: I think LLVM can do that. I am working on it.
[16:07:19] <sanxiyn> (That is, if you generate right IR)
[16:07:32] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[16:08:31] *** Joins: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP)
[16:08:41] <doomlord> it seems i can easily write what i want with concrete types, i'm just seeing how far i can get mimicking the ways it can be done in c++ 
[16:09:02] *** Quits: Blei (philipp@moz-650B9C6A.cust.bluewin.ch) (Quit: WeeChat 0.4.1)
[16:10:15] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[16:10:29] *** Quits: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be) (Quit: bbl)
[16:10:32] *** Joins: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net)
[16:10:52] <cmr> doomlord: it might be that you need an extra trait bound or few to get the trait to do what you would do with a concrete type, but there are differences right now that will hopefully be resolved soon (implicit copy being the one you're suffering right now)
[16:10:59] *** Joins: jesse98 (jjones@6251EDC2.15651213.B46B86FA.IP)
[16:11:20] <indutny> hey people
[16:11:30] <indutny> can I ask rustc to compile 32bit binary on osx?
[16:11:43] <cmr> indutny: you need to build a cross compiler
[16:11:57] <indutny> cmr: is there any wiki page or just instructions on it?
[16:11:58] <doomlord> well its not crippling :)  ... so eventually you can mark a type to auto copy? it does sound lke C# distinction between struct and class
[16:12:10] <cmr> With configure --targets=..., I don't know what the ... should be for mac
[16:12:13] *** Quits: Jesse (jruderman@moz-537BCF9.hsd1.ca.comcast.net) (Quit: Jesse)
[16:12:42] <cmr> doomlord: I don't know how it will be resolved, might ask the ML with your concerns? they are very good questions
[16:12:53] <indutny> cmr: ok
[16:12:57] <indutny> I'll try to figure it out
[16:13:00] <indutny> thank you
[16:13:04] <indutny> wait
[16:13:13] <indutny> does it mean that I'll be able to compile only 32bit binaries with this compiler?
[16:13:28] <cmr> indutny: no, a cross compiler can target multiple machines
[16:13:32] <doomlord> i'm sure what i'm doing is a common use case, i'd expect the ML/wiki will already have discussion  , maybe i can find it
[16:13:32] <indutny> ah
[16:13:33] <indutny> great
[16:13:39] <cmr> but by default only a native compiler is built
[16:13:50] *** Quits: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt) (Ping timeout)
[16:14:09] <bstrie> doomlord: no, there's actually been very little discussion of the clone -> copy change, and I'm baffled by it. PLEASE send something to the mailing list, we need to spark a discussion with pcwalton
[16:14:15] <cmr> doomlord: Common use case yes, but have been done already? Probably not. Rust is still young, especially its current incarnation.
[16:14:27] <cmr> (it's changed almost entirely between 0.4 and 0.6, it seems)
[16:14:36] <doomlord> ok i will try to comment up my flailing attempt here :)
[16:14:40] <bstrie> I've NEVER seen a complete, coherent discussion of the new clone change
[16:14:55] <doomlord> /^^^^ This works but it surprised me I had to do this... etc
[16:15:17] <cmr> indutny: once you have it you can use --target foo to switch which arch you are compiling for
[16:15:22] <indutny> yeah
[16:15:23] <bstrie> it's literally just pcwalton saying that copy will go away and clone will replace it, and then you can make your own clone implementation. no details whatsoever
[16:15:25] <indutny> I've figured that out
[16:15:31] <indutny> but it wasn't working because of dylibs
[16:15:36] <doomlord> so thre's copy/clone and its in a transient cleanup state perhaps
[16:15:53] <doomlord> well that makes sense from what you've explained
[16:16:20] <doomlord> seems i had to have a residual "impl Copy for Vec3" to make it work. ..but that could be somethign that is going to get cleaned up
[16:16:26] <indutny> I guess ./configure --target-triples="x86_64-apple-darwin, i686-apple-darwin" should do the trick
[16:16:29] <indutny> cmr: thank you
[16:16:36] <cmr> indutny: np
[16:16:55] <indutny> btw, any chance my memory APIs could get into 0.7?
[16:17:06] <doomlord> oh,no,  i'm being a spaz - i'm asking for trait :Copy ... i can remove that
[16:17:13] <cmr> indutny: the mmap ffi is, probably not, the rc has already been cut
[16:17:20] <cmr> (probably not for your new one)
[16:17:26] <indutny> oh
[16:17:33] <bstrie> indutny: it can get into 0.8 though! :)
[16:17:37] <indutny> haha
[16:18:03] <bstrie> indutny: anyway, 0.7 is sooooo ten minutes ago. nobody even uses it anymore
[16:18:20] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[16:18:37] <sanxiyn> indutny: Yes that should work
[16:18:51] <indutny> https://github.com/mozilla/rust/pull/7528
[16:19:07] <indutny> bstrie: yeah
[16:19:09] <indutny> its ok
[16:19:12] <sanxiyn> (I build for both x86_64 and ARM Linux)
[16:19:20] <indutny> so, basically, I don't have enough time to test it on windows
[16:19:28] <indutny> and it seems that tests ain't working on linux
[16:19:38] <indutny> can't figure out how to use Result, Ok, Err in libstd test
[16:20:42] <indutny> though, I think it should work on windows
[16:20:54] <indutny> especially, considering pretty narrow API
[16:22:11] <cmr> indutny: is sysconf really an unsafe function?
[16:22:11] <doomlord> i'm not sure how to word my query to the mailing list just yet.. but just saying, the need to clone was very surrpisign coming from c++
[16:22:19] <indutny> cmr: well
[16:22:27] <indutny> no
[16:22:38] <indutny> it can't fail
[16:22:54] <cmr> Does it ahve any side effects at all?
[16:22:58] <engla> doomlord: it's a very good trade. explicit clone instead of all the crazy constructors of c++
[16:23:00] <indutny> no
[16:23:03] <indutny> it just reads config
[16:23:05] <cmr> right
[16:23:14] <indutny> that sounds like a good idea for next PR :)
[16:23:17] <cmr> would it be possible to mark it safe? (kinda orthogonal to your current PR)
[16:23:23] <cmr> heh :)
[16:23:30] <indutny> yes, sure
[16:23:43] <indutny> but I'm a bit lazy
[16:23:46] <indutny> :)
[16:23:51] <bstrie> doomlord: I think your perspective as a heavy C++ user will be invaluable. ideally lots of C++ users will be looking at rust, so we need to make sure that things make sense for them
[16:23:58] <cmr> indutny: you might also add a static method SYSTEM_INFO::new()
[16:24:03] <cmr> bstrie++
[16:24:10] <indutny> ok
[16:24:26] <indutny> cmr: in os.rs ?
[16:24:32] <indutny> or in libc.rs ?
[16:24:38] <cmr> indutny: I would add it in libc.rs
[16:24:40] <indutny> libc doesn't contain any implementations yet
[16:24:42] <indutny> ok
[16:24:59] *** Joins: nano (nano@moz-972880B.superkabel.de)
[16:25:47] <doomlord> i suppose you can make the error messages guide people a bit. certainly this is something to put in  a "Rust for C++ users" wiki.. pass by value vs reference vs *move* vs *clone*
[16:26:52] <doomlord> of course C++ has the hazard of accidently passing huge objects by value when you ommit a "&":)
[16:27:14] <doomlord> which is why some C people resist moving to references and stick with raw pointers...
[16:27:18] <doomlord> its' clearer
[16:27:26] <bstrie> doomlord: we do have this page https://github.com/mozilla/rust/wiki/Rust-for-CXX-programmers
[16:27:40] <cmr> much of the c++11 library code I've seen is clear as mud
[16:27:43] <bstrie> feel free to add things there, even if it's just a list of things that should be there eventually
[16:27:47] <cmr> const &const ... const
[16:28:50] <doomlord> i should have read it lol, i see it mentions "copying and move semantics"- adding some examples there would be great. Perhaps I can cleanup what i'm doing to suggest something there
[16:29:20] *** Quits: sanxiyn (tinuviel@858F408C.B797260D.EF43EC08.IP) (Quit: Leaving)
[16:30:41] *** Joins: eholk (eholk@moz-BF0BB923.uconnect.utah.edu)
[16:33:14] <cmr> indutny: I'm thinking MmapChunk::new should return a Result<~MmapChunk, MmapErrorCode>, and the MmapErrorCode is just a newtype of c_int and can be translated with a .to_str() function
[16:33:14] <monk> const &const ... const; seems easy enough to read once you've found out what it means, and a fairly common thing to see I would think
[16:34:04] *** zz_kimundi is now known as kimundi
[16:34:12] <indutny> cmr: good idea
[16:34:13] <cmr> monk: it is fairly common, I still see it clear as mud though (and I don't C++ all that often, I'm sure if I was slogging through it daily it would stick in my mind)
[16:34:16] <monk> I guess it's pretty similar looking as if it were missing a const or two
[16:34:24] <indutny> do you like other aspects of API?
[16:34:30] <cmr> indutny: still reviewing
[16:34:57] *** Joins: robertknight (robertknig@moz-54528EE0.wby.mendeley.com)
[16:35:08] <cmr> You don't provide any facility for MAP_SHARED
[16:35:10] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[16:35:13] <cmr> Is it unportable?
[16:35:26] *** Joins: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net)
[16:36:00] <cmr> https://github.com/indutny/rust/commit/65f3974d2bd15d6e476c1a52033826bb763a1855#L0R1466
[16:36:05] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[16:36:17] <cmr> Can be `fail!("Unexpected result %?", r)`
[16:36:56] <cmr> I don't think destructors are *allowed* to fail though
[16:37:18] <cmr> it should probably be an error!()
[16:37:26] <cmr> I don't know for sure though, someone else will have to review that part
[16:39:25] <indutny> cmr: portable
[16:39:42] <indutny> cmr: but its a bit harder
[16:39:47] <indutny> and I'm not ready for it now
[16:39:48] <cmr> indutny: other than what I mentioned, it's very nice, good work
[16:39:49] <indutny> :)
[16:40:00] <indutny> thank you
[16:40:07] <cmr> I would like you to rebase and squash those wip commits, as well as using a real commit message :p
[16:40:12] <indutny> well
[16:40:15] <indutny> that's implied
[16:40:34] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Client exited)
[16:43:01] *** Joins: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt)
[16:46:22] <CanhTak> hi rust devs
[16:47:02] <CanhTak> I'm trying to do a binding to a c library and i have a little problem.
[16:47:17] <mnemotic> what is it?
[16:48:07] <CanhTak> i'm trying to to bind a function who takes in parameter a callback function, for this it's okay and a *c_void who can be anything.
[16:48:48] <CanhTak> I want to pass to the *c_void a object who implement a trait that i made.
[16:49:16] <CanhTak> but i don't find any way to do this right.
[16:49:20] <CanhTak> any idea?
[16:49:38] *** Quits: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net) (Ping timeout)
[16:50:11] <mnemotic> how us what you've got
[16:50:11] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[16:50:19] <mnemotic> s/how/show
[16:52:53] <CanhTak> rustic error or code ?
[16:53:24] *** Quits: bnicholson (bnicholson@moz-E98974C1.hsd1.ca.comcast.net) (Ping timeout)
[16:54:21] <sankha93> are the rust coding guidelines strict about maintaining 80 char line width?
[16:54:42] <doener> 100 is a must, IIRC 80 is preferred
[16:54:55] <doener> the tidy(?) make target checks for 100
[16:55:19] <sankha93> ok, btw how do I run the test suite?
[16:55:29] <doener> make check
[16:55:38] <sankha93> ok, thanks! :)
[16:58:03] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Quit: bye bye)
[17:00:48] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[17:01:26] *** Quits: cowboyd (cowboyd@1D8844A7.1B729417.CEE440B6.IP) (Client exited)
[17:01:36] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:01:45] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[17:03:18] *** Joins: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net)
[17:03:31] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[17:03:37] *** Joins: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[17:05:27] <CanhTak> http://mibpaste.com/eneqOm 
[17:05:33] <CanhTak> this is the error and the code
[17:05:56] <CanhTak> the code is ugly but i have really no idea of how do this
[17:08:35] <doener> CanhTak: says "Invalid link!"
[17:08:41] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[17:08:47] *** Joins: calatalee (Mibbit@moz-B9F69E3D.w80-14.abo.wanadoo.fr)
[17:08:51] <CanhTak> arh
[17:08:57] <CanhTak> http://mibpaste.com/hQkaFA 
[17:09:00] *** Quits: calatalee (Mibbit@moz-B9F69E3D.w80-14.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[17:09:12] <doener> same
[17:09:17] <CanhTak> argh why? 
[17:09:40] *** Quits: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se) (Ping timeout)
[17:09:59] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[17:10:39] *** Joins: kmc (mozilla@2557E599.66715431.D25A875A.IP)
[17:10:50] *** Quits: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net) (Quit: My MacBook has gone to sleep. ZZZzzz)
[17:11:47] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:12:01] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[17:12:54] <CanhTak> http://pastebin.com/ZVrDEXv5
[17:13:04] <CanhTak> this works i think
[17:13:14] <doener> yep
[17:13:16] *** Quits: pnkfelix (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Quit: Leaving.)
[17:13:34] *** Quits: pnkfelix|rcirc (pnkfelix@87C1F78E.1DE10CA8.D8E68FF6.IP) (Input/output error)
[17:13:58] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[17:13:58] *** ChanServ sets mode: +o dherman
[17:14:14] *** Joins: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net)
[17:14:30] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[17:15:07] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[17:15:50] *** Joins: true_droid (Adium@moz-123FD9B8.beck.volia.net)
[17:16:45] *** Quits: true_droid (Adium@moz-123FD9B8.beck.volia.net) (Quit: Leaving.)
[17:18:23] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Ping timeout)
[17:19:15] *** Quits: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net) (Ping timeout)
[17:20:19] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:21:25] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[17:22:30] <doomlord> to get that straight ... is it planned eventually you can flag a type to automatically clone itself without needing to write .clone() 
[17:22:45] <doomlord> and this is just something in a state of flux
[17:23:01] <bstrie> doomlord: you can derive it today
[17:23:07] <bstrie> afaik that should work
[17:23:40] <doomlord> trait VecOps:Clone { ...
[17:23:41] <doomlord> 	fn para(self,axis:Self)->Self {  		axis.clone().scale(self.clone().dot(axis.clone())) }
[17:23:50] <bstrie> woah
[17:23:54] <bstrie> what version are you using?
[17:23:58] <bstrie> that's like 0.5 syntax :)
[17:24:05] <bstrie> oh wait
[17:24:09] <bstrie> that's the trait inheritance syntax?
[17:24:12] <doomlord> ok let me check , i though i got it recently
[17:24:15] <bstrie> I've never even used trait inheritance :)
[17:24:17] <bstrie> nm me
[17:24:22] <doomlord> again i'm very hazy with all this
[17:24:26] <bstrie> that's fair
[17:24:29] <doomlord> i tried all sorts :)
[17:24:29] <bstrie> it's not documented anywhere!
[17:24:33] <bstrie> hope you like experimenting
[17:24:45] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[17:24:48] <doomlord> well i guess its why i'm here
[17:25:16] <doomlord> if i just want to write working code i have c++ :) 
[17:25:26] <bstrie> doomlord: at some point, please do write up your experiences with learning rust. it's super valuable feedback to make us better
[17:26:05] <doomlord> i'm going through this process of indecisiion... familiarity but problems with header files taht i hate ...
[17:26:16] <doomlord> .. and an escape from them here, but the unknown and state of  fllux
[17:26:26] <doomlord> but i'm hoping its possible to get input in here too
[17:26:40] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[17:26:53] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:27:01] <cmr> Yes, definitely.
[17:27:08] <doomlord> i should try to write the whole thing pass y reference , from what i gather.
[17:27:12] <doomlord> ... which is more C-like..
[17:27:29] <doomlord> pass by explicit pointers... instead of writing code which kind of could be ref or value..
[17:27:47] <cmr> LLVM will do what is necessary to make it fast when it inlines functions
[17:28:02] <cmr> (#[inline] attribute)
[17:28:05] <doomlord> and assume, as indicated elsewhere, if these are small values its just optimizing registers (it can still think of a register as an 'adress')
[17:28:09] <doomlord> yes
[17:28:17] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[17:28:19] <doomlord> because C++ *can* turn adreses into registers too
[17:28:29] <doomlord> so i should stop fearing that
[17:28:57] <doomlord> i used to write asm interacting with c and really do think of & as an adress and hence loads and stores
[17:29:01] *** Joins: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP)
[17:29:03] <doomlord> but its smarter than that these days
[17:29:07] <cmr> yeah
[17:29:19] <cmr> I'm always impressed when I read disassembly of rust code
[17:30:29] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[17:30:46] <bstrie> yes, thank goodness for llvm
[17:31:36] <Seldaek> speaking of which, is rust's llvm fork "forever" or is the plan to go back to mainline at some point?
[17:31:54] <cmr> Seldaek: noone wants to do the work to clean up our patches for upstream
[17:31:54] <Seldaek> I have no idea how extensively it was modified
[17:32:10] <Seldaek> I see :)
[17:32:14] <cmr> ask brson when he's on, he maintains the fork
[17:32:26] *** Quits: kmc (mozilla@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:32:52] <bstrie> Seldaek: I think the fear right now is that we don't know for sure whether we'll need more custom llvm support in the future
[17:32:56] *** Quits: Sodel_the_V (user@moz-853663E1.va.shawcable.net) (Input/output error)
[17:33:02] <bstrie> so submitting to upstream right now might be fruitless
[17:33:20] <cmr> Plus we need an asserts build right now anyway
[17:33:22] <Seldaek> well if it's general purpose improvements I guess it never hurts
[17:33:25] <bstrie> obviously we'd like to be on a stable version of llvm
[17:33:30] *** Joins: kmc (mozilla@2557E599.66715431.D25A875A.IP)
[17:33:32] <cmr> it isn't really general purpose though
[17:33:36] <cmr> it's all segmented stack stuff iirc
[17:34:01] *** Joins: SimonSapin1 (simon@88F51059.F3BBB17D.144F44FA.IP)
[17:34:47] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[17:35:49] *** SimonSapin1 is now known as SimonSapin
[17:36:01] <doener> CanhTak: hm, no idea what goes wrong there but as the output says, it looks like a compiler error. I'd suggest that you file a bug report
[17:37:17] *** Joins: wilsonk-laptop (kvirc@moz-39EFBFC2.cg.shawcable.net)
[17:37:25] <CanhTak> okay thanks i gonna does an issue. No idea to does this in and less ugly way?
[17:38:14] <doener> sorry, I've not worked with ffi much, so I have no idea
[17:38:45] <CanhTak> okay thanks
[17:41:03] *** Joins: avik (Mibbit@7AEA1617.2DE6F3E0.EFB84E89.IP)
[17:44:06] <Luqman> sanxiynL awesome! i had that on the back burner since i first needed to fix by-value self. I also ran into a run-pass test failing that i needed to fix
[17:44:49] *** Quits: nano (nano@moz-972880B.superkabel.de) (Quit: nano)
[17:44:53] *** Joins: nano (nano@moz-972880B.superkabel.de)
[17:45:46] <cmr> doy: ping
[17:46:06] <doy> cmr: pong
[17:46:15] <cmr> doy: don't forget about https://github.com/mozilla/rust/issues/6101 :)
[17:46:55] <doy> cmr: yeah, sorry, i've been in the process of getting married and moving over the past couple months(:
[17:47:03] <cmr> excuses!
[17:47:05] *** Parts: avik (Mibbit@7AEA1617.2DE6F3E0.EFB84E89.IP) ()
[17:47:21] <doy> hopefully i'll have time to get back in and take care of these things this month
[17:48:38] *** Joins: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca)
[17:48:58] *** Quits: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net) (Ping timeout)
[17:50:03] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[17:50:04] *** Joins: SiegeLordEx (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:50:08] *** Quits: SiegeLordEx (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: SiegeLordEx)
[17:50:13] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[17:50:45] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[17:50:46] *** Joins: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP)
[17:50:56] *** Joins: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net)
[17:51:06] <nmatsakis> brs
[17:51:09] <nmatsakis> oops
[17:52:40] *** Quits: int3_ (int3_@moz-ABE52D50.hsd1.ca.comcast.net) (Ping timeout)
[17:55:22] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Quit: Leaving)
[17:55:36] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[17:56:24] <MaikKlein> is there already a gui solution?
[17:56:29] <cmr> solution?
[17:57:00] <MaikKlein> yeah like a port of gtk or something similar
[17:57:06] <cmr> oh, no.
[17:57:24] <MaikKlein> i only found https://github.com/ktvoelker/GtkRust but seems a bit abandoned
[17:57:24] <cmr> there's https://github.com/mzabaluev/grust, but that's it
[17:57:30] *** Quits: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[17:57:54] <MaikKlein> ok
[17:57:55] *** Joins: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net)
[17:58:15] <cmr> https://github.com/cmr/rustdoc-prototype, btw
[17:58:38] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[17:59:21] *** Quits: Yurume (yurume@AC58A8CE.8A059B47.E313B915.IP) (Ping timeout)
[17:59:33] *** Quits: kmc (mozilla@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[17:59:48] <jmgrosen> is there a way of custom setting indices?
[18:00:06] <cmr> jmgrosen: no
[18:00:08] <cmr> not yet
[18:00:15] *** Joins: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net)
[18:00:16] <jmgrosen> cmr: ok :(
[18:00:44] *** Joins: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca)
[18:01:10] *** Quits: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net) (Quit: You think I'm not online. But I'm always here. Even if I'm not typing. I'm here. Reading. Judging.)
[18:01:48] <btipling> the matching variable binding pattern is blowing my mind away
[18:01:58] <btipling> that is really awesome
[18:02:01] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:02:07] <doomlord> I reworked my maths attempt to use 'pass by reference' more... requiring & explicitely on parameters (more clike than c++) ... it got rid of most of the 'clones' - but not all:-
[18:02:16] <MaikKlein> cmr, what does it currently output?
[18:02:23] <cmr> MaikKlein: an error :P
[18:02:29] *** Quits: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com) (Client exited)
[18:02:31] *** Joins: anri (solancile@moz-A1CFFAE5.hsd1.wa.comcast.net)
[18:02:35] <cmr> "rust: task failed at 'position 0 does not resolve to a source location', /home/cmr/hacking/rust/src/libsyntax/codemap.rs:406"
[18:02:38] <cmr> haven't debugged it yet
[18:02:53] <cmr> I'm sure I'm setting up the session wrong
[18:03:20] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[18:03:26] *** Joins: jclements (jclements@2557E599.66715431.D25A875A.IP)
[18:03:49] <MaikKlein> which crate are you trying to resolve?
[18:04:05] <cmr> argv[1]
[18:04:11] <cmr> tests/basic_struct.rs
[18:04:11] <doomlord> http://pastebin.com/5eJ7AZwC   <<<< any comments on the issue welcome.. whats the best style. pass by value/reference.. cloning... am i doing this 'right' ..
[18:04:19] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:04:47] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[18:05:01] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[18:05:02] <doomlord> http://pastebin.com/LZmrbJLw << including the definition of Vec3 
[18:05:17] <cmr> doomlord: re line22, I'm pretty sure that's a bug
[18:06:06] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:06:12] *** Joins: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP)
[18:06:17] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:07:11] *** Joins: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net)
[18:07:15] <bstrie> doomlord: does having VecOps inherit from Clone actually work? I'd be very surprised
[18:07:36] <doomlord> this compiles and runs ok, but i'm very much stabbing uncertainly around with some issues
[18:07:39] *** Quits: hjr3 (hradtke@moz-C3821DBF.dsl.pltn13.pacbell.net) (Ping timeout)
[18:07:45] *** Joins: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com)
[18:07:59] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:08:03] <bstrie> I guess Clone isn't really *that* magical
[18:08:07] *** Joins: kmc (mozilla@2557E599.66715431.D25A875A.IP)
[18:08:16] <doomlord> right - it needs inherit from Clone because paraPerp needs .clone() - i could not eliminate this
[18:08:34] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:08:40] *** Quits: kmc (mozilla@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:09:32] <doomlord> it seems to need to write 'clone' to copy the local variable into the return tuple for 'paraPerp'
[18:09:45] <doomlord> that still surprises me
[18:10:01] <bstrie> doomlord: you're also using default methods, which are largely untested
[18:10:06] <bstrie> you're treading in dangerous waters :)
[18:10:09] <doomlord> ok :)
[18:10:15] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:10:17] <SiegeLord> I wonder if slicing of arrays can be made nicer... like via creating a Slice trait
[18:10:20] <doomlord> let me see if its any different in an impl...
[18:10:23] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:10:32] <doomlord> it may have a different idea of the type..
[18:11:28] <doomlord> YES: confirmed. if i move it into the "impl" i can get rid of the clone
[18:11:54] <doomlord> sooo. in the default implementation it doesn't have a complete picture ofwhat the type can & can't do perpahs...
[18:11:54] <cmr> There might be another trait you need to inherit from then...
[18:12:03] <cmr> doomlord: right, exactly.
[18:12:52] <doomlord> hypothesis- isaying trait VecOps:Clone says - you can only IMPL this for things with clone - but it doesn't pass through that knowledge  to the default impl :)
[18:13:24] <cmr> That very well could be
[18:13:24] *** Quits: eholk (eholk@moz-BF0BB923.uconnect.utah.edu) (Quit: eholk)
[18:13:27] <cmr> might be a bug
[18:13:32] *** Joins: mschifer1 (Adium@2557E599.66715431.D25A875A.IP)
[18:13:43] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:13:47] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[18:13:48] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/hjm2pw
[18:13:48] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[18:14:41] *** Joins: brson (brson@63DCD950.E4213B29.318DADF5.IP)
[18:14:41] *** ChanServ sets mode: +o brson
[18:15:09] *** Joins: ecr (ereed@2557E599.66715431.D25A875A.IP)
[18:15:10] <bstrie> doomlord: I believe that sully is the one working on default methods, please let him know if you notice any weirdness
[18:15:10] <lkuper> brson: thanks for the awesome shirt
[18:15:15] <bstrie> oh man
[18:15:32] <brson> lkuper: yw
[18:15:34] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[18:15:40] * brson didn't realize they shipped
[18:15:52] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:15:52] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:16:01] <lkuper> brson: it just arrived today
[18:16:08] <doomlord> should i file a bug with this example
[18:16:19] <cmr> doomlord: can't hurt, cc @msullivan
[18:16:20] <bstrie> doomlord: yes please. better safe than sorry
[18:16:33] <bstrie> lkuper: did you get a confirmation email first?
[18:16:40] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[18:16:40] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/5T2srQ
[18:16:40] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[18:16:42] *** Joins: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP)
[18:16:42] <ghrust> 01[13rust01] 15bors pushed 18 new commits to 06auto: 02http://git.io/EngOzQ
[18:16:42] <ghrust> 13rust/06auto 1446777f1 15Niko Matsakis: Update existing tests to account for stricter, more correct handling of irrefutable patterns
[18:16:42] <ghrust> 13rust/06auto 14ee51013 15Niko Matsakis: Add new tests for irrefutable patterns used in various tricky ways
[18:16:42] <ghrust> 13rust/06auto 149bb85e8 15Niko Matsakis: update ptr intrinsics and rewrite vec routines to be more correct....
[18:16:44] *** Parts: ghrust (ghrust@5FEF1C87.6A2AE50.F3114085.IP) ()
[18:16:48] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[18:16:53] <doomlord> well the default impl's feature is already more useful than broken :)
[18:17:11] <lkuper> bstrie: I got a couple package tracking emails from fedex.
[18:17:42] <bstrie> I've still heard nothing on mine :(
[18:17:44] <SiegeLord> So, vec::slice could take a Slice instead of 3 arguments, and static arrays could be implemented for Slice
[18:18:51] <MaikKlein> rusti; (-0.5f).sqrt().is_NaN()
[18:18:59] <MaikKlein> rusti: (-0.5f).sqrt().is_NaN()
[18:19:00] -rusti- true
[18:20:43] *** Joins: mschifer1 (Adium@2557E599.66715431.D25A875A.IP)
[18:20:48] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:20:50] *** Joins: KindOne (KindOne@moz-913DB376.dynamic.ip.windstream.net)
[18:21:58] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Ping timeout)
[18:22:11] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[18:23:49] *** Joins: mschifer (Adium@2557E599.66715431.D25A875A.IP)
[18:23:49] *** Quits: mschifer1 (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:23:55] *** Joins: jaen (jaen@moz-99FE7DC3.play-internet.pl)
[18:24:25] <doomlord> is there another way to write the trait dependancy    trait VecOps:Clone {...}  .. i was trying things with Self:Clone
[18:24:59] <bstrie> not sure what you mean by Self:Clone
[18:25:32] <doomlord> trait<Self:Clone>  VecOps {...} .. somethign like that
[18:25:45] *** Quits: lmandel (lmandel@moz-BBE1EA67.dsl.bell.ca) (Quit: lmandel)
[18:26:15] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[18:26:19] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[18:26:19] *** ChanServ sets mode: +o dherman
[18:27:17] <cmr> doomlord: no, that's what VecOps: Clone does
[18:28:42] *** Quits: jaen (jaen@moz-99FE7DC3.play-internet.pl) (Ping timeout)
[18:31:46] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[18:31:46] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 14fcab1d0 to 14b44953b: 02http://git.io/N3iJvQ
[18:31:46] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[18:31:48] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[18:31:48] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/LtM9mA
[18:31:48] <ghrust> 13rust/06auto 145183a6c 15Alex Crichton: Turn on using LLVM threadsafely
[18:31:48] <ghrust> 13rust/06auto 14e482856 15bors: auto merge of #7409 : alexcrichton/rust/threadsafe, r=cmr...
[18:31:49] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[18:33:35] *** Joins: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de)
[18:36:23] *** Joins: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com)
[18:37:39] <doomlord> so it seems a 'receiver' automatically references, wheras arguments do not...   a.foo(&b) .. a. means (&a)-> ...
[18:38:14] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[18:38:36] *** Joins: steven_is_false (user@moz-144077DE.bchsia.telus.net)
[18:39:11] <steven_is_false> Hi! How performant are Rust's one shots compared to it's streams (in std::comm?)
[18:39:17] *** Quits: echristo (echristo@60A74940.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[18:39:37] <bstrie> steven_is_false: I think streams might be an internal use things right now...
[18:39:40] <bstrie> wait no
[18:39:44] <bstrie> I'm thinking of tubes
[18:39:52] <bstrie> I've never even heard of streams
[18:40:10] <steven_is_false> bstrie: comm::stream?
[18:40:19] <steven_is_false> bstrie: vs comm::oneshot.
[18:40:20] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[18:41:24] <sankha93> bblum: ping
[18:41:39] <bstrie> steven_is_false: sorry, I have no idea what either of those are intended to be used for
[18:41:47] <bstrie> steven_is_false: perhaps ask brson 
[18:41:51] <bblum> sankha93: pong
[18:41:53] <steven_is_false> Okay.
[18:41:53] <nmatsakis> steven_is_false: oneshot is for sending a single message,
[18:41:57] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[18:41:58] <nmatsakis> steven_is_false: stream is for sending a stream of values.
[18:42:12] <nmatsakis> what does it mean when buildbot's logs say "compile interrupted"?"
[18:42:15] <sankha93> bblum: you mean I need to remove the line containing the closure?
[18:42:23] <cmr> nmatsakis: one of the other tests failed and that build was stopped.
[18:42:44] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:42:49] <steven_is_false> nmatsakis: Right, and so oneshot gives one a lot more control when building up protocols but I'm worried that constantly creating oneshots will have overhead.
[18:42:58] <bblum> sankha93: the two line comment "// error-patern: foo  <newline> // bar" should be either "// error-pattern: foo" or "// error-pattern: foo bar"
[18:43:04] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[18:43:04] <nmatsakis> cmr: ok, that's what I figured.
[18:43:17] <nmatsakis> steven_is_false: they're quite cheap, but it is an allocation.
[18:43:21] <steven_is_false> For example, Chan, and Port can be implemented in terms of oneshots.
[18:43:21] <doomlord> i wonder if rusts' tasks are good for aync file io..
[18:43:32] <bblum> sankha93: but in general, it's better to have a small substring of the error message than the entire thing, in case someone wants to tweak it later
[18:43:39] <sankha93> bblum: ok
[18:43:42] <steven_is_false> nmatsakis: How cheap are they compared to streams?
[18:43:44] <nmatsakis> bblum: sankha93: no context, but also `//~ ERROR` is strongly preferred.
[18:43:50] <nmatsakis> since it identifies the line #
[18:43:57] <bblum> oh right, yes
[18:43:59] <nmatsakis> and also ensures you don't get additional errors
[18:44:11] <nmatsakis> steven_is_false: a stream is just a series of one shot ports
[18:44:14] <sankha93> bblum: even if I put the full message it crosses the max number of chars in a line (>100)
[18:44:25] <bblum> sankha93: i believe the lint checker won't give you grief for that
[18:44:35] <steven_is_false> nmatsakis: Oh good then! So it does make sense to use oneshots instead of streams for my case.
[18:44:40] <bblum> sankha93: niko's suggestion is to write: "code_where_error_is(); //~ ERROR foo bar" 
[18:44:52] <nmatsakis> steven_is_false: yes, one-short ports are supposed to be the building block basically
[18:44:53] <bblum> sankha93: or, "code_where_error_is(); <newline> //^ ERROR foo bar"
[18:44:57] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[18:44:57] *** ChanServ sets mode: +o dherman
[18:45:01] <cmr> What's the word for when you have solid data, rather than just describing something?
[18:45:01] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[18:45:03] <sankha93> bblum: ok! will make the changes.
[18:45:07] <steven_is_false> Thanks.
[18:45:24] <sankha93> bblum: and putting the full error message would be fine right
[18:45:25] <cmr> quantitative
[18:45:25] <sankha93> ?
[18:45:40] *** Quits: brson (brson@63DCD950.E4213B29.318DADF5.IP) (Ping timeout)
[18:45:55] <bblum> sankha93: it would be fine but is not preferred
[18:46:07] <sankha93> bblum: only the first subsection?
[18:46:08] <steven_is_false> If anybody is interested in knowing I'm experimenting with oneshots to make a concurrent dequeue instead of a concurrent queue (streams.)
[18:46:14] <bblum> sankha93: that would be better
[18:46:23] <bblum> thanks!
[18:46:30] <sankha93> bblum: I'll send the updated pull request soon! :)
[18:46:32] <nmatsakis> sankha93: it can be any substring
[18:46:37] <sankha93> ohh
[18:46:44] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[18:46:57] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Ping timeout)
[18:47:26] *** Joins: eholk (eholk@moz-BF0BB923.uconnect.utah.edu)
[18:48:30] *** Joins: mschifer1 (Adium@2557E599.66715431.D25A875A.IP)
[18:48:30] *** Quits: mschifer (Adium@2557E599.66715431.D25A875A.IP) (Connection reset by peer)
[18:49:38] <nmatsakis> I miss the ability to write "impl T" anywhere
[18:49:41] *** Joins: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be)
[18:49:46] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[18:49:46] *** ChanServ sets mode: +o dherman
[18:50:44] *** Joins: jaen (jaen@moz-CC0EA7F8.neoplus.adsl.tpnet.pl)
[18:51:40] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[18:51:41] *** Joins: hjr3 (hradtke@moz-CD5B319C.sfo1.dsl.speakeasy.net)
[18:52:01] *** Joins: kmc (mozilla@2557E599.66715431.D25A875A.IP)
[18:52:27] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[18:53:05] *** Quits: cr (anonymous@moz-FDC7C1D9.dip0.t-ipconnect.de) (Ping timeout)
[18:53:05] *** Quits: kmc (mozilla@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[18:54:26] <bblum> why is TC_EMPTY_ENUM noncopyable
[18:54:36] <bblum> "// we somewhat arbitrary declare that empty enums are noncopyable" ???
[18:54:57] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} 1u.bar()
[18:54:58] -rusti- ()
[18:55:03] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} 1u.foo()
[18:55:04] -rusti- ()
[18:55:36] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} (~1u as ~B).bar()
[18:55:36] -rusti- ()
[18:55:40] <mark_edward> rusti: trait A { fn foo(&self); } trait B: A { fn bar(&self) { self.foo() } } impl A for uint { fn foo(&self) {} } impl B for uint {} (~1u as ~B).foo()
[18:55:41] -rusti- line longer than 150 columns, pastebinned: http://sprunge.us/KdSV
[18:55:43] <doomlord> rust is surprising me less when i write *concrete* code. pass by value without clone voodoo
[18:55:55] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[18:56:00] <cmr> that's good
[18:56:13] <mark_edward> no inheritanc yet :(
[18:56:14] <cmr> https://github.com/mozilla/rust/issues/7532
[18:56:28] <cmr> Seldaek: ^ I believe you were interested in that?
[18:56:29] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[18:56:34] *** Quits: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com) (Quit: webber46)
[18:56:38] <doomlord> not looking for inheritance .. composition :)
[18:56:42] *** Joins: dualhbridge (dad@5033F981.CB6B16F2.1EF4A660.IP)
[18:56:51] <doomlord> oh something else maybe
[18:57:07] *** Parts: steven_is_false (user@moz-144077DE.bchsia.telus.net) (ERC Version 5.3 (IRC client for Emacs))
[18:57:19] <cmr> doomlord: well it is called trait inheritance, though it's different for default methods and trait objects
[18:57:42] *** Parts: dualhbridge (dad@5033F981.CB6B16F2.1EF4A660.IP) ()
[18:57:51] <mark_edward> what i did is supposed to work eventually, right?
[18:57:55] <cmr> Yes
[18:58:16] <mark_edward> ok doomlord confused me
[18:58:20] <nmatsakis> bblum: empty enums can't really exist anyhow? that is, you should never really have an instance of one.
[18:58:41] <bblum> sure, but you can write a function with a bottom argument
[18:59:41] <nmatsakis> anyhow, I don't think of a good reason. it just happens to be what we did at the time I was writin
[18:59:56] <nmatsakis>  *was writing that TypeContents code, hence the comment
[19:00:02] <bblum> i see
[19:00:34] *** Quits: CanhTak (Mibbit@moz-3104B86D.rev.sfr.net) (Quit: http://www.mibbit.com ajax IRC Client)
[19:00:34] <nmatsakis> what grammar. I can't think of a good reason, I meant to write.
[19:01:01] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:01:21] *** Joins: webber46 (webber46@moz-98D2F3C5.cust.bredband2.com)
[19:02:48] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:05:11] *** Joins: tjc (tjc@2557E599.66715431.D25A875A.IP)
[19:05:11] *** ChanServ sets mode: +o tjc
[19:05:21] *** Quits: jorendorff (jorendorff@moz-1747FB68.hsd1.tn.comcast.net) (Quit: jorendorff)
[19:05:46] *** Joins: kmc (mozilla@2557E599.66715431.D25A875A.IP)
[19:06:40] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Quit: jedestep)
[19:06:42] *** Joins: jedestep_ (jedestep@34641662.FB4DE631.66C78B76.IP)
[19:06:52] *** Joins: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de)
[19:07:32] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[19:08:07] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[19:09:19] *** Quits: MaikKlein (maik@moz-5A27DA0F.dip0.t-ipconnect.de) (Ping timeout)
[19:10:42] *** Quits: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt) (Ping timeout)
[19:12:35] *** Joins: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt)
[19:12:44] *** Joins: cp (cp@moz-993078EE.plus.com)
[19:12:53] *** Quits: bytbox (s@moz-588B96FF.washdc.fios.verizon.net) (Ping timeout)
[19:14:06] *** Joins: Mowah (Mowah@moz-78DFE185.cust.bredbandsbolaget.se)
[19:14:16] *** Quits: eholk (eholk@moz-BF0BB923.uconnect.utah.edu) (Quit: eholk)
[19:18:36] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[19:19:29] <bblum> is there an easy way to tell (inside of rustc, post-typeck) if a type derives Clone?
[19:20:15] <mark_edward> can rust add support for "?" and "!" as function identifiers? it's very useful for fuction naming.. one thing i miss from scheme
[19:21:09] <bblum> mark_edward: definitely not for !; ! is already used for the Neg trait
[19:21:20] <bblum> among other sundry meanings in non-function position
[19:21:29] <bstrie> mark_edward: possibly for ?
[19:21:44] <bstrie> people have brought it up in the past
[19:21:56] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[19:22:12] <mark_edward> "?" is still useful though. like ~"".ascii?() instead of ~"".is_ascii(). it represents quries well
[19:22:33] *** Joins: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com)
[19:22:41] <nmatsakis> bblum: why do you ask re: Clone?
[19:22:53] *** Quits: zslayton (Mibbit@1D191528.269AFE30.6A3AF4D7.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[19:23:17] <bblum> nmatsakis: https://github.com/mozilla/rust/issues/7286 -- if the type has Clone, i want to have it suggest "perhaps you meant to use clone()?"
[19:23:40] <bblum> i would do that anyway, but then it would suggest clone for non-clonable types too
[19:23:53] <nmatsakis> bblum: I see. There's no easy way.
[19:24:04] <nmatsakis> bblum: it can be quite complex to determine
[19:24:28] <bblum> nod
[19:25:44] <mjrosenb> oh hey, I suddenly realized a bit more of how all this stuff works.
[19:27:05] <mjrosenb> I'd read the linear lisp paper a few months ago, and its relation to rust just clicked.
[19:27:25] <bblum> mjrosenb: what's the deal with linear lisp? it just has linear types?
[19:28:20] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[19:28:51] <bstrie> linear lisp is just normal lisp but it uses || instead of ()
[19:28:53] <bstrie> very confusing
[19:28:58] *** Joins: joshua_ (joshua@moz-45967CBE.emarhavil.com)
[19:29:46] <mjrosenb> bblum: from what I remember, it forces you to copy *everything*, so garbage collection is trivial.
[19:30:57] *** Quits: RMF (RMF@moz-E58E1E9C.dsl.telepac.pt) (Quit: Textual IRC Client: www.textualapp.com)
[19:31:46] <mjrosenb> e.g. if you were to attempt to reference count it, you would always have either 0 or 1, and usually (possibly always) the 1 -> 0 transition is from a known point in the code, so you can bake your gc algorithms in at compile time
[19:32:03] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[19:32:33] <bblum> ah yes, this is how we do memory management with ~-pointers
[19:32:44] <bblum> although not everything is that easy :P
[19:33:46] <mjrosenb> don't you also do something similar with uhh, not sure of the exact term, but threads, where each piece of memory can only be referenced by 0 or 1 threads?
[19:33:52] <cmr> Tasks
[19:34:14] <mjrosenb> althogh, I guess that is a much more generic feature present in many man languages, mostly borrowed from the pi calculus?
[19:34:17] <mjrosenb> cmr: danke.
[19:34:24] <cmr> And yes, you can only transfer Send data between task, only one task can own a given datum
[19:35:43] <kimundi> "<bblum> mark_edward: definitely not for !; ! is already used for the Neg trait" *COUGH* macros *COUGH*
[19:35:50] <cmr> mjrosenb: http://en.wikipedia.org/wiki/Substructural_type_system#Affine_type_systems
[19:35:52] <cmr> Is what rust has
[19:35:55] *** Quits: snadon (chatzilla@moz-3BC727E8.mc.videotron.ca) (Ping timeout)
[19:36:09] <mark_edward> oh yeah, macros, lol\
[19:36:11] <bblum> kimundi: oh good point, it conflicts more with macros than with functions
[19:36:16] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[19:36:16] *** ChanServ sets mode: +o brson
[19:36:28] <bblum> kimundi: i was thinking just ! as the whole name, rather than at the end
[19:36:34] <cmr> mark_edward: I think ? would be useful but I don't really miss it nor especially desire it.
[19:36:43] <mark_edward> i miss it...
[19:37:02] <cmr> I'd rather keep it reserved for something down the road than allow it in identifiers
[19:37:15] *** Quits: lkuper (lkuper@moz-C0CD33ED.hsd1.in.comcast.net) (Ping timeout)
[19:37:30] *** Quits: naq (naq@D5C2D2DF.E4265FCD.E481B5B.IP) (Quit: leaving)
[19:37:35] <usea> brson, I can't build the rust-sdl demo (make demos). I get a linker error. I don't know if it's my copy of rust or a bug somewhere. can you build it?
[19:38:07] <usea> it worked before, but not since I updated rust and rust-sdl yesterday
[19:39:03] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[19:39:49] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:40:24] <nano> I'd love to use rust for embedded development ... someday
[19:41:22] <cmr> nano: someone wants to do their masters thesis on making rust work on ARM micros (specifically cortex m0)
[19:41:35] <nano> thats great
[19:41:39] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[19:41:55] <cmr> It's not really suitable at all atm
[19:42:03] <nano> currently doing work on avr but switching to arm in near future
[19:42:14] <nano> yeah :(
[19:42:18] <mjrosenb> cmr: is linear types : affine types == linear field : affine field (or algebra)?
[19:42:43] *** Quits: kmc (mozilla@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[19:42:45] <cmr> mjrosenb: I barely know what the first half of that equality is, and no idea about that second half.
[19:43:07] <Ms2ger> If you'd started about affine geometry...
[19:43:27] <kimundi> mark_edward: I think .ascii?() is worse than .is_ascii() in rust. To many sigils/paranthese. In ruby its fine because afaik you can just do .ascii? there (no paranthese)
[19:43:45] *** Joins: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net)
[19:45:39] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[19:47:14] <mjrosenb> Ms2ger: well, affine algerbra is isomorphic to affine geometry.
[19:47:44] <Ms2ger> So it's just linalg with an additive factor?
[19:48:08] <Ms2ger> (It's been years since I did that)
[19:48:30] <mjrosenb> Ms2ger: yup. usually called 'point at infinity' or some such.
[19:48:57] *** Parts: mcpherrin (mimcpher@moz-345B5EBA.csclub.uwaterloo.ca) ()
[19:49:29] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[19:49:33] * Ms2ger preferred projective geometry
[19:50:15] * cmr prefers not thinking too hard about mathematics
[19:50:27] * Ms2ger gently whacks cmr over the head
[19:50:43] <Ms2ger> As a mathematician, I can't approve
[19:51:04] <cmr> Maths are one of my tools, I find nothing desirable about them in and of themselves.
[19:51:05] <doomlord> graphics coder here :) some maths obligitory
[19:51:09] *** Quits: bnicholson (bnicholson@2557E599.66715431.D25A875A.IP) (Quit: Ex-Chat)
[19:51:36] <cmr> Ms2ger: My partner is a mathematician, always give me crap about it :p
[19:52:16] <Ms2ger> Then I won't get in the way :)
[19:52:51] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Ping timeout)
[19:52:58] *** Joins: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch)
[19:53:41] <mnemotic> aatch: ping?
[19:56:18] *** Quits: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net) (Quit: jorendorff)
[19:58:26] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[19:58:42] *** Quits: jaen (jaen@moz-CC0EA7F8.neoplus.adsl.tpnet.pl) (Ping timeout)
[19:59:19] *** Quits: cp (cp@moz-993078EE.plus.com) (Ping timeout)
[20:00:24] <mnemotic> after changing atomic intrinsics (they now take a raw pointer), i'm having to not-stage0 all over the place
[20:00:37] <mnemotic> am i doing it wrong, or was that to be expected? :S
[20:02:18] *** Joins: jmgrosen (jmgrosen@moz-BF80C818.sbcc.edu)
[20:03:24] <kimundi> mnemotic: Expected
[20:03:27] *** Quits: tjc (tjc@2557E599.66715431.D25A875A.IP) (Quit: zzzzzzzzzz)
[20:04:25] <cmr> mnemotic: isn't compiler work lovely? :)
[20:04:35] <mnemotic> just so :)
[20:04:36] <kimundi> mnemotic: stage0 is build with the downloaded snapshot compiler, so intrinics etc have to be what that one expects in stage0
[20:04:40] *** Quits: jmgrosen (jmgrosen@moz-BF80C818.sbcc.edu) (Quit: jmgrosen)
[20:05:26] <mnemotic> kimundi: i realize that; i was just cautious that i might have messed up somewhere
[20:05:27] *** Quits: Cromulent (Cromulent@moz-983B638D.cable.virginmedia.com) (Quit: KVIrc 4.2.0 Equilibrium http://www.kvirc.net/)
[20:05:46] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[20:05:49] <bstrie> mnemotic: you'll know you've messed up when you start seeing the words INTERNAL COMPILER ERROR
[20:06:14] <cmr> or when random unrelated tests begin to fail
[20:06:24] *** Joins: jaen (jaen@moz-CC0EA7F8.neoplus.adsl.tpnet.pl)
[20:06:26] <mnemotic> bstrie: that sounds like !Fun! 
[20:06:33] *** huseby is now known as husebyLUNCH
[20:06:36] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:06:41] * kimundi hums the classic tune around here: ~Like ICE in the sunshine~
[20:07:22] *** Quits: H4199 (chatzilla@moz-64E556D3.austin.res.rr.com) (Quit: ChatZilla 0.9.90 [Firefox 24.0a2/20130628004017])
[20:08:27] <cmr> Having working debuginfo is really awesome
[20:08:29] <mnemotic> are those not-stage0's removed automagically on the next snapshot, or do i get the honors?
[20:08:45] <bstrie> they are not removed
[20:08:46] <cmr> mnemotic: whoever makes the next snapshot will remove them
[20:09:41] <kimundi> mnemotic: Doesn't hurt to add a "// NOTE: Remove after next snapshot" though
[20:10:06] *** Joins: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net)
[20:10:35] <mnemotic> kimundi: eh
[20:14:58] *** Joins: jorendorff (jorendorff@moz-B860E258.hsd1.tn.comcast.net)
[20:15:07] *** Joins: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP)
[20:16:01] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[20:16:09] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[20:16:16] *** Quits: orshem (orshem@973F4E28.E7516DB0.E3D28531.IP) (Quit: Leaving)
[20:17:22] *** Quits: Ms2ger (Ms2ger@moz-12E1F766.adsl-dyn.isp.belgacom.be) (Quit: nn)
[20:21:37] *** Joins: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz)
[20:25:00] *** Quits: echristo (echristo@D423593A.D6CCE4AE.77834EAA.IP) (Quit: echristo)
[20:27:58] <thiez> hmmn, would it be possible to create a lint check that warns when a field of a struct is never read in the crate it is defined in?
[20:28:44] <bstrie> thiez: I don't see why it would be impossible, though I'm not sure how difficult or useful it would be
[20:29:27] <thiez> bstrie: I imagine that it would help keep legacy cruft from large codebases
[20:30:02] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[20:30:18] <thiez> I wonder if any such fields exist in librustc/libsyntax
[20:30:43] *** Joins: eholk (eholk@moz-BF0BB923.uconnect.utah.edu)
[20:31:40] *** Quits: brendan (brendaneic@moz-BE33DA21.fw1.sfo1.mozilla.net) (Quit: brendan)
[20:31:50] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[20:31:55] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:34:24] <SimonSapin> is some_vector[-1] the last element or invalid?
[20:34:33] <cmr> invalid
[20:35:03] <SimonSapin> so the last is some_vector[some_vector.len() - 1], or there something shorter?
[20:35:16] <SimonSapin> oh, theres a last method
[20:35:17] <doener> last()
[20:36:30] *** Joins: busylizzy (lisa@85228838.12D0DC84.211374C4.IP)
[20:40:04] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[20:40:49] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[20:45:52] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[20:48:35] *** Quits: jviereck (Adium@moz-A034D4DA.dclient.hispeed.ch) (Quit: Leaving.)
[20:48:41] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[20:49:22] *** Joins: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr)
[20:51:18] *** Quits: sankha93 (Instantbir@4C1B4135.A5E24E6D.8B6C1D65.IP) (Quit: Instantbird 1.4 -- http://www.instantbird.com)
[20:51:33] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[20:51:38] *** Joins: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net)
[20:51:46] <doomlord> does any ide integration give you a dropbox of potential methods
[20:51:52] <bblum> where's brson :x
[20:51:59] <cmr> doomlord: not yet, no
[20:52:04] <cmr> Not semantic at least
[20:52:18] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:52:42] <cmr> vim's youcompleteme has very good "I see this in the file, let's autocomplete it", whatever that is called :p
[20:53:02] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[20:53:26] <doomlord> torn  between wanting to stay more in free-functions like C (getting plain old name completion) .. and wanting to leverage trait/impls ability to use methods more than in C++
[20:53:53] <doomlord> i notice the maths rework moves heavily toward methods
[20:54:05] <cmr> I think ctags can do methods?
[20:54:52] *** Quits: usea (rossm@moz-EE3BB1DC.br.br.cox.net) (Quit: )
[20:55:21] *** Quits: msingle (Thunderbir@moz-930E5D97.hr.hr.cox.net) (Quit: msingle)
[20:55:33] *** Joins: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com)
[20:55:41] <bstrie> what's the best widely-accepted technical term for rust tasks? green threads? coroutines?
[20:55:51] <cmr> bstrie: green threads
[20:55:55] <bstrie> ok
[20:56:08] <cmr> They're not really coroutines, though you can implement coroutines with tasks
[20:56:18] <cmr> (and iterators)
[20:56:38] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[20:56:38] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: maxli)
[20:56:42] <strcat> bstrie: N:M threading
[20:56:52] <strcat> they aren't really green threads
[20:56:54] *** Joins: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net)
[20:56:59] <strcat> and sometimes they are mapped 1:1 to threads
[20:57:00] <bblum> wow the newsched branch is so stale
[20:57:11] <cmr> bblum: it's all on brson's io branch isn't it?
[20:57:18] <bblum> yeah
[20:57:19] <toddaaro> that isn't where the newsched is for some reason, all on brson's io
[20:57:31] <strcat> maybe I'll trying removing exchange alloc headers today
[20:57:36] <toddaaro> strcat: why do you say they aren't green threads?
[20:57:36] <strcat> now that it's 50% "done"
[20:57:37] <bblum> i didn't actually eveluate merge difficulty but it is a lot of commits behind
[20:57:47] <strcat> toddaaro: because they are mapped over real threads
[20:57:51] <strcat> you can have it mapped 1:1
[20:57:53] *** Quits: parcha (quassel@moz-A9A9F340.hsd1.ma.comcast.net) (Ping timeout)
[20:58:01] *** Joins: kmc (mozilla@2557E599.66715431.D25A875A.IP)
[20:58:04] <toddaaro> strcat: in the old scheduler?
[20:58:25] <strcat> toddaaro: it doesn't just use one thread
[20:58:54] <toddaaro> strcat: ? yes, green threads don't map 1-1
[20:58:58] <tikue> if I want to modify a value in a hashmap without removing it, is mangle the best method to do so? and if so, what is the a: A parameter of mangle?
[20:59:20] <strcat> toddaaro: and rust tasks sometimes do
[20:59:24] <strcat> it's part of the API
[20:59:44] <toddaaro> strcat: rust tasks that 1-1 and rust greenthread tasks are going to be very distinct
[20:59:54] *** Joins: Jesin (Jessin_@moz-48B48C95.eecs.lehigh.edu)
[21:00:13] <toddaaro> using the standard tasks will be entirely green threads, using 1-1 tasks will be a very explicit action, and likely result in a slightly different API
[21:00:16] *** Joins: tjc (tjc@2557E599.66715431.D25A875A.IP)
[21:00:16] *** ChanServ sets mode: +o tjc
[21:00:55] <strcat> it uses the same communication primitives, they're thread-safe
[21:01:00] *** Quits: jaen (jaen@moz-CC0EA7F8.neoplus.adsl.tpnet.pl) (Ping timeout)
[21:01:33] <strcat> any definition of 'green thread' I can find is cooperative scheduling on 1 OS thread
[21:01:50] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[21:01:50] *** ChanServ sets mode: +o brson
[21:01:54] <toddaaro> that is definitely not how the term is usually used
[21:02:19] *** Quits: kmc (mozilla@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[21:02:41] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[21:03:40] *** Joins: azita (Azita@2557E599.66715431.D25A875A.IP)
[21:03:52] *** Quits: brson (brson@2557E599.66715431.D25A875A.IP) (Ping timeout)
[21:04:27] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[21:04:30] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:04:49] <sully> sigh, I hate trying to triage the bugs that are "there was a FIXME in the code and I made a bug"
[21:05:11] <bstrie> haha, me too
[21:05:24] *** Joins: echristo_ (echristo@60A74940.D6CCE4AE.77834EAA.IP)
[21:05:25] <bstrie> "this bug still exists, and I still have no idea what it's talking about"
[21:05:32] *** Quits: echristo (echristo@moz-1892C634.hsd1.ca.comcast.net) (Ping timeout)
[21:05:32] *** echristo_ is now known as echristo
[21:05:47] <strcat> ugh there are 200 places using the stupid box header
[21:05:47] *** Joins: alisdair (textual@moz-EA60A466.dedicated.allstream.net)
[21:05:52] <strcat> as in using an offset
[21:06:03] <SimonSapin> Got in ICE. Is the traceback enough for a bug report?
[21:06:08] <SimonSapin> an*
[21:06:13] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:06:16] <strcat> SimonSapin: and a code sample triggering it
[21:06:18] <bstrie> SimonSapin: a minimized test case if you can, please
[21:06:18] <cmr> SimonSapin: and an example to reproduce it, generally
[21:06:32] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[21:06:34] <SimonSapin> I have no idea what part of my code is responsible :/
[21:07:00] <bstrie> tracebacks by themselves do not seem to be very useful
[21:07:03] *** Joins: brson (brson@2557E599.66715431.D25A875A.IP)
[21:07:03] *** ChanServ sets mode: +o brson
[21:07:05] <bstrie> wrt to this compiler
[21:07:11] <jack> SimonSapin: use gdb and break on upcall_fail
[21:07:14] *** Quits: pyrac (pyrac@moz-18D74BD0.w90-60.abo.wanadoo.fr) (Quit: pyrac)
[21:07:20] *** Quits: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net) (Connection reset by peer)
[21:07:27] <strcat> strip stuff out as long as it still fails and you'll find it
[21:07:31] *** Joins: Voomer_ (Voomer@moz-E97E8EB7.br.br.cox.net)
[21:07:41] <jack> also, if it's metadata skew, make clean and rebuilding will sometimes fix it (the backtrace will show it failing in the decoder in that case)
[21:08:19] <bstrie> brson: we desperately need to update the front page example. I've come up with https://gist.github.com/bstrie/5904591 as a lovely-looking candidate that's not too imposing
[21:08:33] <bstrie> it also shows off our awesome new iterators
[21:08:34] <SimonSapin> Also, when commenting code (including comments) I got "error: expected item" after lines starting with ////. I think this one should pass silently
[21:08:39] *** Joins: bjz (brendanzab@moz-D2E3CABC.lns6.cha.bigpond.net.au)
[21:08:49] <cmr> SimonSapin: already an issue open about it.
[21:09:04] <cmr> https://github.com/mozilla/rust/issues/2789
[21:09:20] <brson> bstrie: ok. in a meeting just now, but I'll update afterward
[21:09:41] <strcat> silently ignore errors and guess what the user means? ;\
[21:09:51] <bstrie> brson: if you think it's acceptable, I'll go ahead and manually make the html so that it gets highlighting
[21:10:21] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[21:10:32] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[21:10:52] <bblum> OH, i finally figured out what the blue bar on the left side of (most of) the issues is
[21:11:14] <bstrie> ...blue bar?
[21:11:22] <cmr> yeah I see no blue bar
[21:11:37] *** Joins: bytbox (s@moz-588B96FF.washdc.fios.verizon.net)
[21:11:39] <bstrie> maybe he figured out that it was a column of dead pixels
[21:11:41] <bblum> not on the issue view, on the issue list view
[21:11:46] <bstrie> ah
[21:11:48] <bstrie> is it unread?
[21:11:51] <bblum> yes
[21:11:58] <strcat> bstrie: I don't think we should have iterators on the main page yet
[21:11:59] <bblum> took me forever to realize that >_>
[21:12:03] <strcat> it's going to change a lot
[21:12:15] <cmr> bblum: I don't have those
[21:12:18] <strcat> and the front page example won't update when master does
[21:12:37] <bstrie> strcat: the front page example hasn't worked for months, it always tracks the releases
[21:12:52] <bstrie> would be cool to automatically test it though
[21:12:57] <bstrie> and highlight it
[21:12:58] <strcat> 'advance', 'transform' and 'iter' there are ugly
[21:13:05] <bstrie> I agree
[21:13:14] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[21:13:16] <strcat> I would really rather not have an example like that
[21:13:18] <bstrie> but I really like that this now shows off our closure syntax
[21:13:24] <strcat> the iterator tutorial explains why things are why they are
[21:13:33] <strcat> as in why it is ugly
[21:13:47] <bstrie> strcat: in any case, how would you remove iter()?
[21:13:53] <strcat> an Iterable trait
[21:14:07] <strcat> transform should be called map
[21:14:11] <strcat> advance shouldn't be there
[21:14:17] <bstrie> right, I originally went looking for map
[21:14:35] <strcat> and you're using indexing so it's not really showing off iterators
[21:15:00] <bstrie> well if you didn't want me showing off the ugly .advance hack then you shouldn't have made it the only option for iteration :P
[21:15:30] *** Quits: novabyte (Instantbir@moz-3E0F9699.cable.virginmedia.com) (Ping timeout)
[21:15:43] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[21:15:47] <bstrie> so eventually that will just look like `nums.map(...).filter(...)` ?
[21:15:56] <strcat> yes
[21:15:59] <bstrie> nifty
[21:16:08] <bstrie> is this one of those things with a million blocker bugs?
[21:16:16] <strcat> maybe not
[21:16:17] <bstrie> like, does it require default methods?
[21:16:24] <strcat> well default methods don't work enough yet so that blocks it
[21:16:35] <strcat> they don't work cross-crate if they're #[inline]
[21:16:36] *** Quits: bytbox (s@moz-588B96FF.washdc.fios.verizon.net) (Ping timeout)
[21:16:44] <bstrie> also I presume that even the current support for .iter() on fixed-length vectors is a hack
[21:17:01] <strcat> there's isn't one on fixed-size vectors
[21:17:08] <strcat> it's just on &[T]
[21:17:12] <bstrie> ah cool
[21:17:14] <bstrie> that's handy
[21:17:18] <strcat> fixed-size vectors can't have impls
[21:17:25] <strcat> because we don't have integers in the type system
[21:17:30] <strcat> unless you hardcode sizes
[21:17:33] <bstrie> right
[21:17:36] <bstrie> that's what I was presuming
[21:17:59] <sully> hm
[21:17:59] <bjz> :(
[21:18:09] <sully> anybody have any idea what the state of the rope code is?
[21:18:17] <sully> Yoric: ping
[21:18:18] <strcat> sully: terrible
[21:18:25] <strcat> sully: very slow, and it has correctness bugs
[21:18:30] <sully> ok
[21:18:31] <bstrie> rope was like the very first extra lib
[21:18:36] <bstrie> it's so old and has never had any users
[21:18:36] <strcat> if you want to improve it you probably want to start over
[21:18:40] <strcat> and not even look at that old code
[21:18:42] <strcat> ;p
[21:18:46] *** Quits: sw17ch (sw17ch@moz-39D8564F.wndsny.tds.net) (Quit: sw17ch)
[21:18:48] <sully> I ask because I got assigned a triage bug about the rope code
[21:18:53] <bstrie> haha
[21:18:55] <strcat> sully: I think we should just remove it
[21:18:59] <bstrie> burn it with fire
[21:19:08] <bstrie> does a rope belong in libextra?
[21:19:13] <strcat> bstrie: sure, if it worked
[21:19:13] <bstrie> how essential are they to have?
[21:19:16] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[21:19:16] *** ChanServ sets mode: +o dherman
[21:19:25] <strcat> if it's mutable it should be owned
[21:19:26] <bstrie> afaik the use case is "text editors"
[21:19:30] <strcat> so the current one just needs to be tossed out
[21:19:33] <bblum> brson: ping
[21:20:21] <strcat> it even uses @~str everywhere
[21:20:27] <bblum> haha @str
[21:20:32] <strcat>                     let local_buf: ~[u8] = cast::transmute(copy *x.content);
[21:20:33] <strcat> wat?
[21:20:41] <strcat> bblum: @~str, not @str ;p
[21:20:46] <bblum> oh
[21:20:50] <bblum> slightly better
[21:20:56] <strcat> str: @~str
[21:21:18] <bblum> it has suffixed integer literals everywhere too
[21:21:45] * strcat thinks we should just remove it
[21:21:58] <cmr> the less code the merrier
[21:22:18] <sully> yeah, I mean, I'd be fine pitching it
[21:22:22] <sully> who makes the final call on these things?
[21:22:59] <bstrie> sully: the person who reviews the PR that removes it, presumably
[21:22:59] <cmr> IMO most of extra should be tossed
[21:23:07] <bstrie> until there's a module owner for libextra, it's a free-for-all
[21:23:12] <strcat> deque, priority_queue and treemap should be in libstd imo
[21:23:24] <strcat> and rc
[21:23:55] <strcat> arena, rope, sort, etc. are all pretty terrible atm.
[21:24:50] <bstrie> I'm not sure what else to show off in the front page example, if not iterators. I want something that's vaguely intuitive to someone who's never heard of rust, so I don't really want to use owned pointers or too many borrowed pointers
[21:25:07] <bstrie> also I want something that's not obviously a workaround for a bug
[21:25:21] <strcat> stay far away from iterator then ;p
[21:25:25] <strcat> the whole thing is a workaround for bugs
[21:25:35] <bstrie> strcat: I said *obviously* :P it still looks very nice!
[21:25:44] <bstrie> the changes you suggest only make it look even prettier
[21:25:57] <bstrie> I'm tempted to just put the "ideal iterator" example on the front page
[21:26:03] <bstrie> because it makes me weep tears of joy
[21:26:04] <cmr> heh
[21:26:05] <strcat> use fold then
[21:26:06] <strcat> and no for loop
[21:26:13] <strcat> like
[21:26:17] <strcat> make a hashset and a vector
[21:26:20] <bstrie> I also want to show off spawn, even if it's a stupid trivial example
[21:26:21] <strcat> zip them and fold it into something
[21:26:54] <bstrie> strcat: but with zip I have to stick .iter() on the inner thing
[21:26:58] <bstrie> which is gross
[21:27:23] <bstrie> comparatively to the ideal vision
[21:27:49] <strcat> rusti: let mut xs = std::priority_queue::PriorityQueue::new();
[21:27:51] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/DMdY
[21:27:59] <strcat> rusti: let mut xs = extra::priority_queue::PriorityQueue::new();
[21:28:00] -rusti- <anon>:9:22: 9:63 error: cannot determine a type for this bounded type parameter: unconstrained type
[21:28:00] -rusti- <anon>:9          let mut xs = extra::priority_queue::PriorityQueue::new();
[21:28:00] -rusti-                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[21:28:00] -rusti- application terminated with error code 101
[21:28:16] <bstrie> and no type hints anywhere in the front page example
[21:28:18] <bstrie> inference or bust
[21:28:19] <strcat> rusti: let mut xs = extra::priority_queue::PriorityQueue::new(); xs.push("bar"); xs.push("foo"); xs.pop()
[21:28:20] -rusti- "foo"
[21:29:40] <strcat> priority_queue needs a bunch of #[inline], I was wondering why it was slower than our current sorts
[21:29:44] * strcat didn't know #[inline] was needed when he wrote it
[21:30:35] <Seldaek> strcat: what does it do exactly? inlines the function body wherever it's used?
[21:30:42] <strcat> no
[21:30:50] <strcat> it does cross-crate inlining
[21:30:56] <strcat> LLVM will already do inlining inside a crate
[21:31:26] <doomlord> a crate is an object file? ... but comes from many sources?
[21:31:32] <strcat> a crate is a .so
[21:31:34] <Seldaek> not sure what that means in practical terms, is it to reduce cross-crate dependnecies or does it make stuff faster?
[21:31:35] <strcat> a library
[21:31:37] <bstrie> a crate is "the thing you compile"
[21:31:47] <strcat> Seldaek: inlining is a performance thing
[21:31:55] <Eridius> inlining trades away binary size to gain perforamnce
[21:31:57] <Eridius> *performance
[21:32:01] <strcat> Eridius: not really
[21:32:06] <strcat> inlining will make it smaller in many cases
[21:32:20] <bstrie> with optimization
[21:32:24] <strcat> and it's more about the optimizations it can do *after* inlining than removing the overhead of stack spilling + calls
[21:32:28] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[21:32:35] <cmr> without optimizations, rust isn't worth considering :p
[21:32:55] <strcat> bstrie: without optimization it doesn't inline
[21:33:06] <strcat> it only runs the inline pass at -O2 and above
[21:33:21] *** husebyLUNCH is now known as huseby
[21:33:25] <bstrie> strcat: right, I mean that inlining reduces code size by enabling optimizations
[21:33:32] <bstrie> did you mean something different?
[21:33:44] <strcat> well also because an integer compare/add or two or three is smaller than the code to do a call
[21:33:59] <strcat> especially since everything has __morestack
[21:34:00] <cmr> plus symbol name, right?
[21:34:10] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[21:34:10] <ghrust> 01[13rust01] 15bors merged 06auto into 06master: 02http://git.io/LtM9mA
[21:34:10] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[21:34:13] <strcat> cmr: yeah and it ends up in the linking hash tables
[21:34:25] <bstrie> I'm interested in how much of a speed difference exists between optimized and unopt rust
[21:34:25] <strcat> that ld uses
[21:34:34] <bstrie> like are we still faster than X other language unopt?
[21:34:39] <cmr> bstrie: like 10x or more
[21:34:39] <strcat> bstrie: no
[21:34:44] <strcat> our unopt code is useless
[21:34:47] <bstrie> haha
[21:35:00] <strcat> might as well be writing javascript
[21:35:02] <strcat> it's slower than js
[21:35:02] <bstrie> 10x slower would still probably beat some slow interpreted languages
[21:35:03] <cmr> Our unopt builds on the buildbots are slower than valgrind.
[21:35:20] <doomlord> i guess the JITs' these days must be good
[21:35:34] <strcat> doomlord: rustc is just really bad
[21:35:35] <cmr> doomlord: for the languages which have them, yes
[21:36:12] <doomlord> C beats everything if you can put the time into manually optimizing.. 
[21:36:17] <strcat> it doesn't
[21:36:23] <strcat> C is slower than fortran
[21:36:26] <strcat> and it doesn't map well to hardware
[21:36:30] <doomlord> __restrict
[21:36:39] <strcat> restrict, you mean
[21:36:43] <strcat> and that doesn't fix it
[21:36:43] <doomlord> whatever
[21:37:06] *** Joins: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP)
[21:37:06] <ghrust> 01[13rust01] 15bors pushed 0 new commits to 06auto: 02http://git.io/EsaLBQ
[21:37:06] *** Parts: ghrust (ghrust@AC22872E.6A2AE50.F3114085.IP) ()
[21:37:08] <doomlord> so fortran auto-vectorizes? where in C you need to use intrinsics ?
[21:37:08] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[21:37:08] <ghrust> 01[13rust01] 15bors pushed 19 new commits to 06auto: 02http://git.io/y0BprA
[21:37:08] <ghrust> 13rust/06auto 1446777f1 15Niko Matsakis: Update existing tests to account for stricter, more correct handling of irrefutable patterns
[21:37:08] <ghrust> 13rust/06auto 14ee51013 15Niko Matsakis: Add new tests for irrefutable patterns used in various tricky ways
[21:37:09] <ghrust> 13rust/06auto 149bb85e8 15Niko Matsakis: update ptr intrinsics and rewrite vec routines to be more correct....
[21:37:11] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[21:37:22] <strcat> doomlord: in *C* you don't do SIMD
[21:37:29] <strcat> if you mean GNU C, sure - you can even pack structs
[21:37:40] *** Quits: saml (sam@moz-14C16814.cst.lightpath.net) (Quit: Leaving)
[21:37:40] <strcat> but it's still not very good at it
[21:37:43] <doomlord> ok well i mean the C compilers i've used :)
[21:37:46] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[21:37:57] <doomlord> they've always exposed SIMD when it mattered
[21:38:30] <doomlord> but requiring specialist knowledge to use well.. more like writing something halfway between asm & c
[21:38:36] <strcat> only if you write routines for every platforms
[21:38:39] <strcat> platform*
[21:38:44] <doomlord> yes
[21:38:54] <strcat> AVX routine, SSE4 routine, SSE3 routine, baseline x86_64
[21:38:57] <strcat> and so on
[21:39:00] <doomlord> and the platforms in question didn't have Fortran compilers :)
[21:39:13] <strcat> even gmp/ffmpeg don't use AVX/SSE4
[21:39:21] <doomlord> powerPC
[21:39:24] <strcat> too much trouble to rewrite a million versions for a 2x speedup
[21:39:24] <doomlord> cell
[21:40:00] <doomlord> i can beleive fortran does array processing well..
[21:40:13] <doomlord> .. but when i think of SIMD i think of video compression & game engines
[21:40:13] <strcat> it optimizes better than C overall
[21:40:22] <strcat> doomlord: sure, it's better at that
[21:40:28] <strcat> anything with pointers or arrays
[21:40:32] <doomlord> i find that hard to beleive
[21:40:35] <strcat> so, everything
[21:40:39] <strcat> doomlord: why is it hard to believe?
[21:40:40] <doomlord> restrict fixes the pointer issues
[21:40:46] <strcat> doomlord: it doesn't 'fix' them
[21:40:51] <doomlord> yes it does
[21:40:57] <doomlord> on game consoles we used to write ASM
[21:41:03] <doomlord> then we gradually moved to C..
[21:41:05] *** Joins: kodablah (Mibbit@moz-296F4F9C.dal05.softlayer.com)
[21:41:10] <doomlord> ... so long as the C was matching what we'd manually write
[21:41:19] <cmr> Every large-scale scientific program I've heard of is written in fortran
[21:41:25] <strcat> you weren't writing good asm if gcc/clang is matching it
[21:41:26] <doomlord> which it did, so long as you used restrict
[21:41:30] <strcat> neither of them is good at vectorizing ;p
[21:41:44] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[21:41:45] <doomlord> it never vectorized. that was done manually with intrinsics
[21:41:54] <strcat> so why did you need restrict?
[21:41:56] <doomlord> and it wasn't as bad as having to do a version perplatform
[21:42:04] <doomlord> to allow it to cache values in registers better
[21:42:23] <doomlord> once you have that hint in place, it "works"
[21:42:51] <doomlord> it wasn't as bad as having to write a version per platform, because there was a common subset of operations that you could abstract
[21:43:00] <doomlord> this got you maybe 80% of the performance everywhere
[21:43:11] <doomlord> 90% 
[21:43:27] <doomlord> datalayout was quickly more important... and C is great at giving you control over htat
[21:43:44] <strcat> doomlord: I don't really see how
[21:43:49] <strcat> malloc always aligns for 'long double'
[21:44:03] <doomlord> alignment beyond that, to cache lines
[21:44:16] <strcat> not in C itself
[21:44:25] <strcat> alignas/alignof didn't even exist until c11
[21:44:26] <doomlord> the platforms in question required manual precaching hints
[21:44:31] <strcat> doomlord: so that's not C
[21:44:31] <doomlord> ok
[21:44:34] <doomlord> right
[21:44:46] <doomlord> but its part of every C compiler i've used since 1995 :)
[21:44:54] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[21:44:54] *** ChanServ sets mode: +o dherman
[21:45:04] <doomlord> so i have this mistaken impression from 15+ years of practical experience that C is fast :)
[21:45:24] <doomlord> near enough to asm to be worth writing very little asm
[21:45:31] <bstrie> C isn't as fast as javascript for scripting webpages
[21:45:33] <bstrie> Q.E.D.
[21:45:46] <doomlord> it would be. just not as productive per programmer hour
[21:45:48] <strcat> bstrie: asm.js shipped
[21:45:53] <strcat> C runs great in a browser ;p
[21:45:55] <bstrie> gg then
[21:46:12] <doomlord> and a C programmer would just re-invent js probably with some DSL
[21:46:16] <doomlord> eventually
[21:46:34] <bstrie> but wait, is there a fortran frontend for llvm? if not, then C really is faster for scripting webpages than fortran
[21:46:59] <mark_edward> doomlord: C is fast, but you have to do so many ridiculous hijinks to get it to be near asm levels. i am not nearly as experienced as you (only programming for 2 years)
[21:47:04] <bstrie> quod ERAT demonstrandum
[21:47:23] <mark_edward> but i had a research internship looking at a lot of HPC and scientific code
[21:47:24] <strcat> bstrie: well llvm can use gcc as the frontend
[21:47:24] <doomlord> C's status is well earned, IMO
[21:47:26] <strcat> so yes
[21:47:33] <bstrie> really? I had no idea
[21:47:42] *** Quits: eschweic (Adium@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[21:47:57] <mark_edward> and it's terrible. pointer madness packing, inline asm, nonsstandardized compiler extensions, etc.
[21:48:04] <strcat> but icc and the intel fortran compiler are still the best
[21:48:07] <bstrie> so then why is it a big deal trying to implement a Go frontend for llvm, if they already have gccgo?
[21:48:09] <doomlord> the thing about restrict .. C++ does actually help with aliasing asumptions
[21:48:23] <strcat> doomlord: where?
[21:48:44] *** Joins: mw (mw@moz-5AC816E9.adsl.highway.telekom.at)
[21:48:46] <doomlord> if you have references to different classes, it assumes they're not aliased, i think, when in methods. its somethign ilke that
[21:48:55] <strcat> doomlord: C has that too
[21:48:57] <strcat> type punning rules
[21:49:11] <doomlord> its definitely different in C++ to C
[21:49:12] <strcat> there are some made undefined intentionally to make things compile better
[21:49:18] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[21:49:50] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[21:49:53] <strcat> afaict the C++ standards defers to the C standard for most of the type punning rules
[21:49:56] <doomlord> well i guess Rust can make better aliasing assumptions since its pointers are more controlled ?
[21:50:00] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[21:50:07] <strcat> doomlord: it could but it doesn't right now
[21:50:19] <cmr> doomlord: (the aliasing rules are a fundamental part of the type system)
[21:50:31] <strcat> the current aliasing rules aren't good enough
[21:50:35] <doomlord> if it could, perhaps you could get rust to the speed of "restrict" C
[21:50:42] <strcat> @mut ruins it
[21:50:50] <cmr> @mut should be canned
[21:51:03] <strcat> @mut can alias with &mut
[21:51:08] * Seldaek writing php, reading people argue about many unknown things. I half regret I don't know more of this, but also feel like a bit glad.
[21:51:18] <doomlord> are there any wiki pages about this sort of detail 
[21:51:19] <cmr> The only place I genuinely see it used in the rust codebase is faking mutable fields
[21:51:29] <cmr> doomlord: https://github.com/mozilla/rust/wiki/Doc-lowlevel-details is a proto-wiki page
[21:51:34] <strcat> cmr: that's an anti-pattern
[21:51:42] <cmr> strcat: I know, and it's awful
[21:51:45] <strcat> it's a bad thing that it has to break the mutability rules like that
[21:51:58] <strcat> it's not owned so it can't inherit mutability
[21:52:12] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[21:52:15] <strcat> so it's either immutable or mutable (and mutable means dynamic failures and aliasing with &mut)
[21:52:30] <strcat> could just enable TBAA if there's no @mut in the entire crate ;p
[21:52:31] <brson> bstrie: the example looks good to me in general, but I don't think I want to put our names on the front page of the website like that
[21:52:31] *** Quits: spider-mario (spidermari@moz-B8FA2FF4.rev.sfr.net) (Connection reset by peer)
[21:52:41] <brson> bblum: pong
[21:52:52] *** Joins: Kruppe (user@moz-E150F49F.cpe.net.cable.rogers.com)
[21:53:02] <brson> does anybody know whether yichoi has fixed the android build?
[21:53:02] <bblum> brson: i'm trying to figure out where the right place to put killed checks is in the new scheduler
[21:53:12] *** Joins: kmc (mozilla@2557E599.66715431.D25A875A.IP)
[21:53:22] <doomlord> does the absence of global variables help with aliasing assumptions
[21:53:25] <cmr> brson: a bunch of pulls landed to fix not, not sure it's fully fixed though...
[21:53:32] <cmr> doomlord: we actually have globals now
[21:53:36] <cmr> static mut
[21:53:38] <doomlord> oh :( :)
[21:53:39] <cmr> requires unsafe code though
[21:53:40] <strcat> there's TLS anyway
[21:53:42] <bblum> brson: current leading thought is somewhere inside the deschedule_/switch_task_and_then family of functions, but the question of whether to do it before calling the provided closure (cleanup job) or after running it is bugging me
[21:53:48] <cmr> TLS uses @ too
[21:54:25] *** Quits: mnemotic (niko@8FFD1BD2.9D81E74C.53DF0002.IP) (Ping timeout)
[21:54:51] <bblum> brson: if i do a killed check before (and don't run the provided closure), then i have access to the ~Task, and can enqueue it for cleanup, but i might... violate some assumptions that certain callers have that the closure will always get run?
[21:55:18] *** Joins: eschweic (Adium@2557E599.66715431.D25A875A.IP)
[21:55:43] <strcat> nmatsakis: so there's probably no way we can actually have C calls without a layer of indirection?
[21:56:26] <doomlord> http://stackoverflow.com/questions/146159/is-fortran-faster-than-c
[21:56:37] <brson> bblum: yes, that would break some I/O code that expects a result to be set before resuming execution
[21:56:47] <doomlord> ^^^ restrict fixes that, and you have the option of caching locals too
[21:56:49] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[21:57:00] <strcat> doomlord: it's not the only thing
[21:57:09] <doomlord> what else then
[21:57:12] <strcat> ADTs
[21:57:13] <bblum> brson: well, "resuming execution" i don't care about, because if the killed check goes off, the task will fail instead of not running the closure
[21:57:25] <strcat> if you do it manually you lose a lot of type info
[21:57:38] <doomlord> can you give me an example
[21:57:58] <strcat> doomlord: adts as in the same thing as rust's enum
[21:57:59] <bblum> brson: question is, is there a use case of ..._and_then() where the closure must get run to meet an assumption of some code that runs *before* the call? (code *after* the call simply won't get run.)
[21:58:00] <doomlord> i can beleive its something that saves programmer time
[21:58:03] <strcat> as in it knows the specific set of tags
[21:58:13] <strcat> doomlord: sure, rust puts range asserts on loads of enum discriminants and bools
[21:58:13] *** Joins: BitPuffin (quassel@moz-49828767.cust.tele2.se)
[21:58:13] <doomlord> but i can't beleive its something that speeds up code
[21:58:14] <brson> bblum: dtors after the call will be run
[21:58:31] <bblum> right, so, such as what?
[21:58:34] <doomlord> it might make *writing fast code* faster.
[21:58:36] <strcat> doomlord: well it does, it was a 2% speedup and a 3% reduction in the size of librustc
[21:58:41] <strcat> adding range asserts
[21:58:56] <doomlord> i can't beleive its something you can't do manually in C
[21:59:11] <doomlord> just more programmer time to get the same result
[21:59:21] <doomlord> more LOC
[21:59:38] <SimonSapin> are there convention in formatting rust code?
[21:59:45] <strcat> doomlord: can't do range asserts in C
[21:59:47] <strcat> even GNU C
[21:59:52] <cmr> SimonSapin: https://github.com/mozilla/rust/wiki/Note-style-guide
[21:59:54] <mw> cmr: Hi, I've got some time for you now
[21:59:57] <doomlord> range asserts speed things up ? how
[21:59:58] *** Quits: eholk (eholk@moz-BF0BB923.uconnect.utah.edu) (Quit: eholk)
[22:00:10] <strcat> doomlord: because they tell the compiler a value is within a certain range at a specific load
[22:00:17] <strcat> and the compiler can then optimize based on that assumption
[22:00:25] <cmr> mw: hello. 1. do you know if there is anything special needed to get good LLDB support?
[22:00:40] <mark_edward> C++ generic sort is faaster than the C quicksort in most cases
[22:00:51] <doomlord> there are plenty of manual optimmizations based on values being in certain ranges
[22:00:53] <mw> cmr: I don't know a lot about lldb
[22:01:09] <mw> but it seems to be integrated with clang
[22:01:09] *** Joins: MaikKlein (maik@moz-CBE88A30.dip0.t-ipconnect.de)
[22:01:18] <doomlord> i dont contest that you can write faster code for a given amount of programmer time
[22:01:19] <strcat> mark_edward: because the C++ sort is defined in the header and qsort is defined in a shared object
[22:01:23] <mw> so, rather C/C++ specific
[22:01:36] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[22:01:46] <doomlord> exactly, that is not an example of C++ beating C, just some library
[22:01:50] <doomlord> one library beating another
[22:01:53] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[22:01:57] <strcat> the only thing that makes the C++ sort easier to optimize is that functors are a type rather than a pointer
[22:01:58] <brson> bblum: I don't see anything that will obviously break
[22:02:02] *** Joins: eholk (eholk@moz-BF0BB923.uconnect.utah.edu)
[22:02:06] <cmr> mw: well, it isn't designed to be C/C++ specific, that's just the only implementations that exploit its so far, I think
[22:02:07] <strcat> but any case you can use a functor, you can use a constant function ptr
[22:02:17] <brson> bblum: mostly it will leave a lot of empty Cells behind
[22:02:28] <cmr> mw: 2. stepping through code seems to be completely broken, are you aware of this?
[22:02:30] <bblum> empty cells are fine
[22:02:45] <bblum> brson: another thought was to potentially call the closure with an Option<~Task>, and the user could decide what to do if failure is imminent
[22:02:57] <bblum> where a None means "sorry, closure, i kept the task for myself because i need to kill it"
[22:03:08] <mw> cmr: no, so far I've only done data layout/type description things
[22:03:31] <cmr> mw: ok. well, stepping through code is completely broken :p
[22:03:33] <mark_edward> i don't think you can leave programmer productivity out of the performance equation though. assembly is fast, but having everyoen switch to it would likely result in terrible code
[22:03:38] <brson> bblum: I'm not sure that checking for kill on every context switch is the best approach though - tasks that are not green threads don't do userspace context switches
[22:03:50] <mw> cmr: I know that variable declaration and reassignment does not work
[22:04:04] <bblum> brson: someplace else? or someplace in addition?
[22:04:14] <doomlord> sure, programmer productivity is part of the equation
[22:04:23] * nano graps popcorn leans back and reads the log of the discussion doomlord started
[22:04:23] <cmr> mw: ah, it might be that, the code in question does have a lot of that
[22:04:38] *** Joins: engla (engla@moz-DBD1D96E.cust.bredbandsbolaget.se)
[22:04:38] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Connection reset by peer)
[22:04:39] <mw> cmr: specifically, I have a test case where the name 'a' is bound to one value, and later to another one of another type
[22:04:41] *** Quits: cowboyd (cowboyd@moz-1BD02A1E.sw.biz.rr.com) (Client exited)
[22:04:48] <strcat> stupid thing keeps segfaulting
[22:04:50] <mark_edward> i mean, i'm thinking about a class project i had to do,write a simple IRC server in C
[22:04:56] <doomlord> i'm sure there will be a similar tradeoff rust vs C++ ....
[22:04:57] <mw> but the debugger cant handle that atm
[22:04:58] <bblum> brson: i mean, do non-green tasks have a context switch path that does something different? or do they just use the kernel context switcher?
[22:05:04] <mark_edward> using only the C standard libraries.
[22:05:11] <doomlord> rust might be a bit slower, but programmers will write bug free code quicker
[22:05:12] <bblum> because we had the latter with oldsched and we didn't have a good killing story for those tasks
[22:05:15] *** Joins: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com)
[22:05:17] <strcat> doomlord: nothing in rust makes it fundamentally slower than C++
[22:05:29] <strcat> assuming you're comparing apples to apples and using unsafe {} as necessary
[22:05:40] <cmr> mw: that actually anwswers the remainder of my questions, thanks! keep up the great work :)
[22:06:03] *** Quits: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP) (Ping timeout)
[22:06:04] <mw> cmr: currently I'm working on support for enums. after that I plan to take a look at some of the things that worked at some time but don't now
[22:06:05] <mark_edward> doomlord: it's not jus bug free. a big part of the project was string handling. i was time limited, so i ended knowing that i did a lot of uecessary string allocs, copies, frees, etc
[22:06:07] <brson> bblum: it's not clear yet since they don't exist. we do need to have a clear story for when it's possible for tasks to be killed. in the new scheduler there will be a lot of susbystems asking for green-thread context switching - do all of them want to be fallible?
[22:06:10] <MaikKlein>  shouldn't rust be even faster? because there is more information for the compiler to optimize?
[22:06:12] <nano> mark_edward, i think this is a really good task... everybody should write a simple irc in his life
[22:06:22] <strcat> MaikKlein: not really
[22:06:32] <mark_edward> my searches and matches were suboptimal, and memory handling as well
[22:06:40] <doomlord> sure , i never claimed C scores well for programmer productivity
[22:06:42] <strcat> if we didn't have @mut
[22:06:44] <bblum> brson: if they don't, they could pass in a "don't check for kill" flag
[22:06:44] <doomlord> it doesn't
[22:06:45] <mw> cmr: mostly function arguments and maybe destructuring
[22:06:46] <brson> eholk: congrats on your harlan release
[22:06:49] <MaikKlein> strcat, just read it on some blog :)
[22:06:58] <eholk> brson: thanks!
[22:07:02] <strcat> MaikKlein: if we didn't have @mut and closures we would have good aliasing information
[22:07:06] <mw> cmr: but I might also  take a look at the variable scope thing
[22:07:07] <mark_edward> just having the C++ std::string would have likely reduced memory use a lot, and resulted in better performance from that angle
[22:07:09] <strcat> but we do have them
[22:07:18] <MaikKlein> :(
[22:07:33] <doomlord> well... i would be very interested to see how rust ends up with the aliasing situation, vs C , C-restrict and fortran :)
[22:07:36] <strcat> the problem is that you can't know if a reference points *inside* an @mut
[22:07:47] <strcat> because you can read from @mut even if it's frozen by &mut
[22:08:06] <strcat> so there are two issues from that
[22:08:14] <strcat> 1) can't do data parallelism with &mut
[22:08:21] <strcat> 2) can't do good alias analysis
[22:08:35] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[22:08:45] <strcat> ideally if you had & it would mean the memory was immutable
[22:08:54] <strcat> and if you had &mut it would be a unique reference
[22:09:08] <strcat> non-Const things make the 1st assumption untrue but at least the compiler *knows* statically, so it doesn't matter
[22:09:14] <bblum> cmr: thanks for review; mind looking again? i added a commit
[22:09:15] <doomlord> &mut .. unique mutable reference because the original is frozen?
[22:09:19] <bblum> eholk: what's harlan?
[22:09:28] <strcat> doomlord: no just because &mut is guaranteed to be unique
[22:09:31] <strcat> it can't alias &
[22:09:40] <strcat> it does alias &const and @mut reads
[22:09:54] <doomlord> i'm seeing const there, is there a const keyword?
[22:09:58] <strcat> yes
[22:10:00] <eholk> bblum: it's my GPU programming language
[22:10:06] <strcat> but we can remove &const without losing much
[22:10:16] <MaikKlein> hm
[22:10:17] <sp3d> I thought const /was/ being removed?
[22:10:19] <strcat> @mut will still exist though
[22:10:20] *** Joins: ghrust (ghrust@C621748.6A2AE50.F3114085.IP)
[22:10:21] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 140023eb2 to 14e482856: 02http://git.io/N3iJvQ
[22:10:21] *** Parts: ghrust (ghrust@C621748.6A2AE50.F3114085.IP) ()
[22:10:22] <MaikKlein> isn't const freez now?
[22:10:23] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[22:10:23] <ghrust> 01[13rust01] 15bors pushed 2 new commits to 06auto: 02http://git.io/-XbEtQ
[22:10:23] <ghrust> 13rust/06auto 149c3ef89 15Luqman Aden: configure: Require one of wget or curl.
[22:10:23] <ghrust> 13rust/06auto 144902f0a 15bors: auto merge of #7498 : luqmana/rust/cow, r=catamorphism...
[22:10:24] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[22:10:28] <strcat> MaikKlein: no
[22:10:32] <strcat> Const and &const are unrelated
[22:10:37] <MaikKlein> oh
[22:10:38] <strcat> Const is Freeze now
[22:10:50] <strcat> &const is non-Freeze anyway
[22:11:26] <strcat> anyway data-parallelism needs the same guarantees as TBAA
[22:11:41] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[22:11:49] <strcat> so we'll have both good TBAA and data parallelism or neither ;p
[22:11:57] <doomlord> TBAA=?
[22:12:07] <strcat> type based alias analysis
[22:12:20] *** Quits: jedestep_ (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:12:54] <doomlord> it would be interesting to see how the new haswell gather instructions help ,and if any languages can use them well..
[22:13:07] <doomlord> other than C doing it manually with intrinsics
[22:13:37] <doomlord> (will those allow more code to be vectorized automatically ...)
[22:14:28] <bblum> brson: i also had a question about oldsched: do you remember where in the failure path the exit code/status gets set?
[22:14:38] *** Parts: mw (mw@moz-5AC816E9.adsl.highway.telekom.at) ()
[22:15:46] <bblum> brson: to be more specific: i'm trying to see if i can make a task fail if it gets to the TCB destructor without having failed yet, so it's too late to actually do fail!() in rust code, but i want to make it pretend like it failed in all other regards
[22:17:30] <mark_edward> doomlord: the summary of my argument is that the extra layers of abstraction the C++ provides over C will give better performanc einterms of what sort of code the average programmer can produce
[22:17:47] <doomlord> fair enough
[22:17:56] <doomlord> performance per programmer time , yes
[22:17:58] <doomlord> you can beat C
[22:18:19] <doomlord> i'll accept that...
[22:18:23] <mark_edward> in that abstractios allow for you to reliably reuse solved problems, i.e. sure, i "know" how to handle strings, but in reality, ahving some class that deals with all fo that leets me right code that's memory safer
[22:18:46] *** Quits: dherman (dherman@2557E599.66715431.D25A875A.IP) (Quit: dherman)
[22:18:57] <doomlord>  idiomatic c++ is usually heavier on dynamic allocations
[22:18:59] <brson> bblum: the exit code is set in rust_kernel::fail, and rust_kernel::fail is called through a complex series of events that i don't understand, originating in the rust_task_kill_all builtin
[22:19:03] <MaikKlein> has anyone here some experience with zmq?
[22:19:12] <mark_edward> and there are cases where you might get better performance, check out the Eigen Matrix library for example. i don't know how you'd pull fo what they do in C. although i know many matrix libraries are written in C
[22:19:16] <bblum> brson: ah yes, thanks
[22:19:28] <doomlord> in C malloc/free is a pita, you're encouraged to write code that includes efficient allocation as part of the solution .. but it does take longer to write.
[22:19:42] <doomlord> ^eigen - i dont accept that
[22:19:56] <doomlord> you can write the same code in C,with restrict, its just you might have to write it manually
[22:19:59] <Luqman> brson: bblum ya, tracing from lang=fail_ leads seems to lead throw a long path to actual failure
[22:20:04] <doomlord> where templates generate it for you in C++
[22:20:24] <mark_edward> what do you mean? i'm talkibg when using the matrix class m1 * m2 * m3 doesn't actually do the multiplication
[22:20:31] <strcat> doomlord: malloc/free aren't an efficient API
[22:20:40] <doomlord> new/delete are better ? 
[22:20:42] <doomlord> i dont think so
[22:20:43] <strcat> doomlord: no
[22:20:51] <strcat> malloc/free are too far from how it works and the performance considerations
[22:21:03] <doomlord> well, good C wwouldn't use malloc/free everywhere :) 
[22:21:07] <mark_edward> it generates a mutiplication expression, that is only finally computed when you assignt he result of the expression. it let's them do some optimizations on the multiplication
[22:21:10] <MaikKlein> can rust auto generate c bindings? (to an extend)
[22:21:18] <doomlord> it would use custom pooling and custom precompiled object graphs and so on
[22:21:18] <strcat> doomlord: not talking about malloc/free vs no dynamic allocation
[22:21:20] <Luqman> MaikKlein: there's bindgen
[22:21:28] <strcat> doomlord: custom pooling == memory fragmentation
[22:21:35] <Luqman> MaikKlein: https://github.com/crabtw/rust-bindgen
[22:21:40] <doomlord> custom pooling = avoiding fragmentation :)
[22:21:44] <strcat> doomlord: no
[22:21:48] <doomlord> yes
[22:21:50] <strcat> your pools are fragmentated memory
[22:21:54] <MaikKlein> Luqman, ah right, thanks. I couldn't remember the name.
[22:22:01] <strcat> the pooled memory is unused memory not available elsewhere
[22:22:03] <doomlord> then you didn't customize it ebough
[22:22:13] <strcat> doomlord: they will always be fragmented memory
[22:22:17] <strcat> and there will always be wasted space
[22:22:19] <strcat> that's what a pool *is*
[22:22:25] <bblum> cmr: ping
[22:22:35] <strcat> the definition of a pool is fragmenting the available memory into groups
[22:22:52] <strcat> I really doubt it will do better than a good general purpose allocation with a good API
[22:23:09] <doomlord> the intent of "custom" is expoiting foreknowledge to improve allocation efficiency 
[22:23:09] <SimonSapin> ICEs. ICEs everywhere :(
[22:23:16] <SimonSapin> and I cant reproduce in an isolated case
[22:23:19] <doomlord> knowledge of lifetime
[22:23:19] <nano> btw is there are nice c++ static pool implementation that is suitable for embedded systems?
[22:23:42] <strcat> doomlord: and by fragmenting the heap into groups, you increase total memory usage and fragmentation
[22:23:50] <strcat> doomlord: http://www.allendowney.com/ss08/handouts/berger02reconsidering.pdf?goback=.gmr_86782.gde_86782_member_253295471
[22:24:02] <doomlord> but by knowing lifetime, you can reduce fragmentation... by putting temporaries somewwhere else
[22:24:10] <MaikKlein> btw if were are talking about c overhead in rust. What does it actually mean? That it will execute slower or that it consumes more memory r ?
[22:24:14] <strcat> doomlord: that doesn't decrease fragmentation
[22:24:17] <doomlord> yes it does
[22:24:36] *** Joins: lkuper_ (lkuper@moz-D862222C.dhcp-bl.indiana.edu)
[22:24:38] <doomlord> furthermore, if you know a group of allocations has the same lifetime
[22:24:39] <strcat> doomlord: general purpose allocators don't fragment memory at all with allocations under page size
[22:24:44] <doomlord> you can manually concatenate them
[22:24:54] <doomlord> a generatl purpose allocator can't match that
[22:24:59] <strcat> doomlord: yes it can
[22:25:02] <doomlord> of course this is a PITA to write
[22:25:02] <strcat> malloc/free is just a bad API
[22:25:22] <doomlord> are we talking about the same thing?
[22:25:39] <doomlord> mymalloc(subheap, size) ..
[22:25:39] <strcat> how about reading the recent paper done by microsoft research about it
[22:25:42] *** Quits: lkuper_ (lkuper@moz-D862222C.dhcp-bl.indiana.edu) (Client exited)
[22:25:49] <doomlord> i dont need to read a paper on it 
[22:26:06] <strcat> okay so then you know that custom memory allocators don't offer anything a general purpose allocator with a good API doesn't
[22:26:10] <doomlord> i know how to deal with this sort of thing :)
[22:26:16] <strcat> all they offer you is *more* inherent fragmentation
[22:26:26] <doomlord> are we just talkinga bout the same thing with different names.
[22:26:36] <doomlord> is your "general purpose allocator with a good api" my "custom allocator"
[22:26:57] <doomlord> if i know many allocations are part of the same object graph , i want to ensure they are sequential
[22:27:06] *** Quits: noam (noam@F6B530A7.720527A7.416762B.IP) (Ping timeout)
[22:27:08] <doomlord> if i know that object's components has the same lifetime
[22:27:19] <doomlord> if i know i have lots of temporaries, i want them somewhere else.
[22:27:23] <doomlord> and i want to manually state that
[22:27:27] <strcat> doomlord: you can
[22:27:34] <doomlord> i dont want a system to have to guess
[22:27:37] <strcat> don't need/want a custom pool
[22:27:47] <doomlord> so what is a "good api"
[22:28:13] <jld> That sounds to me like a problem with malloc/free working on "the" heap instead of *a* heap.
[22:28:17] <strcat> for one thing it needs to expose alignment and stuff that madvise does
[22:28:38] <strcat> and allocations that stay within a thread can be done separately
[22:28:41] <doomlord> i think we're arguing about what its called
[22:28:49] <strcat> the allocator shouldn't have to guess, it can be told in the call
[22:28:55] <doomlord> i call this "custom allocation" , as in everything i want to do that malloc/free , new/delete dont
[22:29:05] <doomlord> i think you're just arguing with me about what its called, LOL
[22:29:22] <doomlord> you dont like me saying that C programmers can use all these tricks
[22:29:26] <strcat> there's a difference between a pool for a specific kind of object
[22:29:30] <doomlord> C programmers do not have to just use malloc/free
[22:29:35] <strcat> and a general purpose allocator that manages all the memory
[22:29:35] *** Joins: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP)
[22:29:35] <ghrust> 01[13rust01] 15brson merged 06master into 06dist-snap: 02http://git.io/YN29fQ
[22:29:35] *** Parts: ghrust (ghrust@1E8607E8.6A2AE50.F3114085.IP) ()
[22:29:39] <doomlord> the whole pooint of C is... its got manual pointers. you can write your own allocators
[22:29:50] <strcat> you can't write an allocator in *C*
[22:29:55] <strcat> you can write a win32/POSIX allocator
[22:30:02] <strcat> C only has malloc/free/calloc
[22:30:05] <doomlord> did i say "a pool for a specific kind of object"??? no. i said CUSTOM ALLOCATION
[22:30:07] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[22:30:08] *** Joins: dherman (dherman@2557E599.66715431.D25A875A.IP)
[22:30:08] *** ChanServ sets mode: +o dherman
[22:30:25] <doomlord> "C only has malooc/free//calloc", NO, plus
[22:30:27] <strcat> there's no mmap/madvise/munmap in C
[22:30:38] <doomlord> plus any custom allocation scheme you want to write yourself
[22:30:42] <strcat> doomlord: using what?
[22:30:50] <doomlord> using memory :)
[22:31:02] <strcat> how are you going to 'use memory'? the C standard doesn't specify a stack or a heap
[22:31:09] <doomlord> you can create your own allocation schemes within larger allocations from the OS
[22:31:14] <doomlord> oh
[22:31:19] <doomlord> this "C standard" again
[22:31:26] <strcat> doomlord: making large allocations with malloc is slow
[22:31:28] <doomlord> sorry i only deal with fictitious REAL c compilers
[22:31:37] <strcat> doomlord: not talking about "REAL" compiler
[22:31:42] <doomlord> not the REAL abstract standard
[22:31:51] <strcat> writing a memory allocator that works on freebsd, windows and linux
[22:31:56] <bblum> toddaaro: find -name '*.rs' will find all rust files
[22:32:09] <doomlord> well... everything i've dealt with, you can solve these problems :)
[22:32:15] <bblum> toddaaro: sed -i 's/\s*$//' will trim all trailing whitespace inside one file
[22:32:19] <doomlord> we called it "CUSTOM ALLOCATION" but you seem to object to that
[22:32:26] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[22:32:28] <bblum> toddaaro: so command1 | xargs command2 will run command2 on all files outputted by command1
[22:32:29] <strcat> doomlord: you were talking about custom pools
[22:32:33] <strcat> as in mixing different allocators
[22:32:36] <doomlord> not JUST pools
[22:32:44] <doomlord> CUSTOM allocation.  many different systems
[22:32:46] <strcat> and if you look at that paper, you'll see that every single case they tested of custom pools/allocators was worse
[22:32:53] <doomlord> based on foreknowledge of how thigns weree used
[22:33:12] <doomlord> aren't they just describing a custom allocator? :)
[22:33:16] <strcat> doomlord: no
[22:33:19] <doomlord> custom allocator could mean anything
[22:33:24] <doomlord> ring buffers.
[22:33:25] *** Quits: Jesse (jruderman@2557E599.66715431.D25A875A.IP) (Ping timeout)
[22:33:27] <strcat> they are describing a general purpose allocator, as in a program only uses it
[22:33:42] <doomlord> we really are just arguing over what something is called 
[22:33:44] <doomlord> this is silly
[22:33:46] <strcat> it doesn't use any other memory allocator, so it avoids prematurely fragmenting the heap and having multiple unshared pools
[22:34:01] <strcat> doomlord: afaict you are advocating for using multiple pools/allocators
[22:34:07] <doomlord> so, if i have a "permanent" area to load assets into and a "temporary" area for workspace...
[22:34:13] *** Quits: brendan (brendaneic@2557E599.66715431.D25A875A.IP) (Quit: brendan)
[22:34:21] <strcat> doomlord: yes, that's what they tested
[22:34:30] <strcat> trying to do a trick like that is slower than having the same allocator handle it all
[22:34:38] <doomlord> jesus
[22:34:41] <cmr> bblum: pong
[22:34:44] <doomlord> same allocator taking a heap pointer
[22:34:46] <doomlord> whatever
[22:34:49] <cmr> bblum: on it
[22:34:57] <doomlord> i am pretty sure what i call "CUSTOM ALLOCATION" can do what they did
[22:34:58] <bblum> cmr: oh never mind, tjc already got there
[22:35:00] <bblum> props tjc :P
[22:35:03] <cmr> ok
[22:35:07] <doomlord> we went through all this
[22:35:16] <doomlord> dealing with streaming systems and multithreading
[22:35:44] <doomlord> and how to avoid fragmentation .. on machines with no MMU..
[22:35:48] <nano> strcat, http://www.dfrws.org/2008/proceedings/p58-schuster.pdf <- is this the publication you were talking about?
[22:35:57] <strcat> nano: no
[22:36:04] <strcat> nano: http://www.allendowney.com/ss08/handouts/berger02reconsidering.pdf?goback=.gmr_86782.gde_86782_member_253295471
[22:36:07] <nano> ty
[22:36:49] <doomlord> sounds like this microsoft paper you are quoting is just one person trying to say his custom allocator is better than everyone elses
[22:37:00] <doomlord> using some contrived tests :)
[22:37:01] <strcat> nano: they are essentially reinventing jemalloc/tcmalloc though and giving it a fancy new name
[22:37:22] <cmr> doomlord: only one author was from microsoft research, and that's the allocator used in glibc
[22:37:32] <strcat> doomlord: ok here's the thing
[22:37:39] <strcat> if you make a region/pool for a specific kind of allocation
[22:37:50] <strcat> you now have unused memory *separate* from other allocations
[22:37:56] <strcat> so the heap is fragmented
[22:38:05] <strcat> there's a big block that's opaque to most allocations/deallocations
[22:38:11] <strcat> despite the fact that lots is unused
[22:38:28] <doomlord> yes, but you only did that where its advantageous. you didn't just do it willy nilly
[22:38:42] <doomlord> if it wasn't an advantage you'd just stick with malloc/free :)
[22:38:51] <strcat> doomlord: this isn't a comparison to malloc/free
[22:39:05] <strcat> malloc/free are known to be a bad, insufficient API for a general purpose allocator
[22:39:15] <doomlord> the point is, you seperate off allocations **where you know its advantageous**
[22:39:23] <strcat> but it's not advantageous
[22:39:34] <doomlord> but it really is sometimes :)
[22:39:37] <strcat> the allocator can already allocate things sequentially as-needed
[22:39:40] <cmr> https://github.com/mozilla/rust/pull/7497 seems to be in limbo
[22:39:44] <strcat> it can already group things by size group
[22:39:49] <MaikKlein> what does this error tell me? "cannot move out of captured outer variable"
[22:39:54] <strcat> except it can then reuse that unused memory at any time
[22:39:56] <doomlord> in a game, you have temporaries - sub frame lifetime, and resources, lifetime over 1 frame.
[22:39:58] <doomlord> its a clear distinction
[22:40:08] <strcat> doomlord: yes, and the single allocator in the program can deal with that fine
[22:40:17] <strcat> malloc/free can't, but we're not talking about them
[22:40:17] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[22:40:31] <doomlord> what is this magic interface
[22:41:28] <strcat> doomlord: for starters it needs to expose alignment and whether something escapes the thread
[22:41:53] <doomlord> well, sure
[22:41:57] <Eridius> MaikKlein: you can't move out of a captured variable, because even if the environment doesn't touch that var again, your function could be called again
[22:41:59] <strcat> and the thread access pattern
[22:42:01] <doomlord> did i say "custom allocation" can't do that :)
[22:42:02] <toddaaro> brson: I'm preparing a pull request for the task/coroutine swap now, should be up soonish
[22:42:13] <toddaaro> brson: depends how long it takes me to rebase-clean the commit log
[22:42:29] <strcat> doomlord: I don't know what you mean by 'custom allocation'
[22:42:37] <doomlord> RIGTH SO STOP ASSUMING YOU DO
[22:42:48] <doomlord> I MEAN DEALING WITH ALL THESE THINGS
[22:42:52] <strcat> I'm not assuming I do, you said different pools for different objects
[22:42:55] <doomlord> alignemnt, threads, lifetime etc
[22:42:56] <strcat> I'm responding to that
[22:43:02] <strcat> doomlord: but it all uses the same allocator
[22:43:16] <doomlord> i didnt' just say differetn pools for differetn objects
[22:43:17] <strcat> the allocator can reuse an unused block for something else
[22:43:21] <doomlord> i said custom allocation
[22:43:31] <doomlord> meaning many different schemes
[22:43:36] <doomlord> not one scheme everywhere
[22:43:54] <brson> toddaaro: ok, thanks
[22:44:03] <strcat> jemalloc/tcmalloc/hoard is 1 scheme used everywhere
[22:44:06] <doomlord> many differetn schemes driven by programmer foreknowledge of lifetime, cache effects, threads, alignment...
[22:44:10] <MaikKlein> Eridius, hm https://gist.github.com/MaikKlein/5905248 do I maybe need @fn?
[22:44:31] <doomlord> well maybe they just package up all the "custom allocators" i've dealt with into one api
[22:44:32] <Eridius> MaikKlein: you're trying to move the self.model value
[22:44:37] <nmatsakis> strcat: what do you mean no C calls w/o indirection?
[22:44:46] <strcat> nmatsakis: as in no function wrapper
[22:44:51] <strcat> nmatsakis: just an annotation on the C call
[22:44:52] <MaikKlein> Eridius, the error is only for the function f
[22:44:59] <nmatsakis> strcat: the PR has no indirection...
[22:45:04] <mark_edward> rust could help with this, right? the compiler knows the lifetime of every non GC'd object, right?
[22:45:07] <strcat> nmatsakis: but you seem to suggest you have to wrap them
[22:45:13] <Eridius> MaikKlein: oh it is? Hmm. You didn't include squigglies
[22:45:16] <strcat> nmatsakis: as in a non-#[inline] wrapper
[22:45:34] <nmatsakis> strcat: I didn't mean to suggest that; however, if we do not wrap them, then the danger that brson raised is probably more prominent
[22:45:36] <MaikKlein> Eridius, yeah sry, I saw that when it was too late :(
[22:45:41] <doomlord> what do you call garanteeing many small, variable sized allocations happen in one sequential buffer
[22:45:46] <Eridius> MaikKlein: I'm not sure why a &anything would be moved instead of copied. What happens if you try calling `copy f`?
[22:45:53] <nmatsakis> strcat: certainly we can always have at least the *option*to have them unwrapped
[22:46:06] <doomlord> this is needed for cache coherency sometimes
[22:46:10] *** Quits: eholk (eholk@moz-BF0BB923.uconnect.utah.edu) (Quit: eholk)
[22:46:22] <strcat> nmatsakis: well I mean for our general purpose things like the exchange allocator
[22:46:27] <doomlord> as well as minimizing fragmentation
[22:46:28] <nmatsakis> strcat: I guess it's more a question of defaults
[22:46:28] <strcat> nmatsakis: LLVM has libcall passes that we're missing out on
[22:46:35] <strcat> nmatsakis: like the dead store elimination
[22:46:45] <MaikKlein> Eridius, tried that, then it tells me that f is not copyable. I tested now @f and it is compiling
[22:46:54] <Eridius> MaikKlein: well @f will definitely work, that's just ugly
[22:46:56] <strcat> nmatsakis: in C it can optimize out an unused malloc
[22:47:08] <strcat> in rust ~ is an opaque thing it will never touch
[22:47:40] <engla> MaikKlein: for now, you need to borrow the closure I think. Try replacing the f in traverse with  |x| f(x))
[22:47:47] <nmatsakis> strcat: I see. That's a tricky one, of course, because of how common it is, but I imagine we can add custom annotations to our own wrapper?
[22:47:58] <bblum> ok, so what's the most idiomatic way to consume an option?
[22:48:02] <strcat> nmatsakis: we'd need to patch LLVM though
[22:48:07] <cmr> bblum: match?
[22:48:08] <strcat> nmatsakis: it hardcodes this stuff :(
[22:48:09] <bblum> i wanna do map_consume but without the Option return value
[22:48:20] <bblum> cmr: without having to waste a line on "None => {}
[22:48:20] <bblum> ""
[22:48:29] <nmatsakis> strcat: oh, really? GCC has various function attributes to indircate this sort of thing, but I guess llvm/clang ignores them?
[22:48:30] <cmr> bblum: get_or_default?
[22:48:37] <nmatsakis> strcat: or maybe I'm mistaken, but I thought it did.
[22:48:39] <strcat> nmatsakis: well it has purity annotations
[22:48:44] <engla> MaikKlein: I mean   x.traverse(self.model, |a| f(a));
[22:48:56] <strcat> nmatsakis: but it has hardcoded stuff for specific C functions
[22:49:05] <strcat> nmatsakis: malloc/free, new/delete/new[]/delete[] in C++
[22:49:14] <bblum> cmr: the function signature i am looking for is fn(Option<T>, fn(T) -> U) -> ()
[22:49:16] <tikue> bblum: for option.iter().advance
[22:49:20] <nmatsakis> strcat: see e.g. the malloc annotation in http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html
[22:49:27] <bblum> tikue: that gives me a reference; i want to consume
[22:49:34] <indutny> cmr: ping
[22:49:38] <nmatsakis> strcat: maybe we could generalize LLVM to support that
[22:49:39] <indutny> can you please r? https://github.com/mozilla/rust/pull/7528
[22:49:39] <cmr> indutny: pong
[22:49:41] <MaikKlein> engla, oh wow it compiles and now I am confused
[22:49:44] <strcat> nmatsakis: ah I don't think it has that
[22:49:50] <indutny> seems to be working now
[22:50:00] <strcat> nmatsakis: for example http://llvm.org/docs/doxygen/html/InstructionCombining_8cpp_source.html#l01378 uses stuff like http://llvm.org/docs/doxygen/html/MemoryBuiltins_8cpp_source.html#l00308
[22:50:05] <strcat> nmatsakis: and it just seems to be hardcoded symbols
[22:50:13] *** Joins: eholk (eholk@moz-BF0BB923.uconnect.utah.edu)
[22:50:17] <cmr> indutny: would it be possible to expand test coverage?
[22:50:18] <engla> MaikKlein: it's a recent change. I'm not sure of the details but it applies to your scenario -- passing down a closure from inside a closure (the for loop). With a closure less for loop (coming) there is no issue
[22:50:20] <nmatsakis> strcat: that's unfortunate
[22:50:23] *** Quits: alisdair (textual@moz-EA60A466.dedicated.allstream.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz)
[22:50:27] <indutny> cmr: ah, yes...
[22:50:28] <strcat> nmatsakis: if we could annotate it, it would be a non-issue
[22:50:29] <tikue> bblum: why not just use a semicolon to squelch the return value
[22:50:37] <tikue> bblum: of map consume
[22:50:38] <indutny> probably without testing Executable flag :)
[22:50:40] <bblum> tikue: yeah, that's what i've been doing
[22:50:42] <bblum> it's kind of nasty
[22:50:46] <nmatsakis> strcat: I don't imagine we want to have every caller of malloc allocating a 2mb stack.
[22:50:51] <bblum> i don't like using semicolons when i can avoid it
[22:50:55] <indutny> but I can even do it, if you'll agree to have inlined assembly here
[22:51:05] <SimonSapin> Can I get a mutable reference a thing in an enum variant ?
[22:51:05] <bblum> because i'm not trying to generate an Option<()>
[22:51:08] <SimonSapin> with match
[22:51:18] <cmr> indutny: no that's ok :p
[22:51:25] <indutny> ok :)
[22:51:27] <cmr> SimonSapin: ref mut foo
[22:51:37] <tikue> bblum: yeah, I don't like it much either but haven't seen a better option if you can't use a reference
[22:51:43] <bblum> nod
[22:52:10] <bblum> i just want an analogue of vec.consume :<
[22:52:11] <bblum> hmm
[22:52:13] <strcat> nmatsakis: well won't that actually happen right now?
[22:52:17] <cmr> indutny: I'd like test coverage for all of the tier 1 platforms for all the features the interface supports before I r+
[22:52:25] <strcat> nmatsakis: it will just end up allocating the stack in the malloc call
[22:52:28] <strcat> the wrapper
[22:52:28] <cmr> (Minus executable, that's a PITA)
[22:52:34] <tikue> bblum: why not just copypasta the map_consume code? it'd be like one line different
[22:52:36] <cmr> Although..
[22:52:36] <nmatsakis> strcat: yes, but then it releases it again,
[22:52:41] <cmr> Nah, too hokey
[22:52:42] <SimonSapin> oh, but vec::last() does not give me a mutable ref anyway :/
[22:52:43] <MaikKlein> engla, ahh thanks, I thought the for loop is already a real for loop now,
[22:52:45] <nmatsakis> strcat: we do some clever logic to reuse it,
[22:52:49] <indutny> cmr: ok
[22:52:52] <indutny> thanks
[22:52:54] <bblum> hm
[22:52:56] <nmatsakis> strcat: but otherwise it kind of defeats the purpose of having segmented stacks to begin with
[22:53:01] <nmatsakis> strcat: which is brson's point
[22:53:37] <tikue> bblum: better yet, just implement the method as map_consume with a semicolon at the end :P
[22:55:11] <strcat> nmatsakis: I've found that fast_ffi is actually slower than the old way
[22:55:13] <strcat> because it thrashes so much
[22:55:25] <strcat> if you set RUST_MIN_STACK it's much faster
[22:55:57] <strcat> but it's still a lot slower than C
[22:55:58] *** Joins: tiffany (kawaii@moz-1E0FE6E8.dhcp.embarqhsd.net)
[22:56:09] *** Quits: nano (nano@moz-972880B.superkabel.de) (Connection reset by peer)
[22:56:15] <MaikKlein> strcat, by slower you mean execution time?
[22:56:18] <strcat> yes
[22:56:28] <strcat> I mean treemap is 20x slower than the same code in C++ when using jemalloc
[22:56:40] <strcat> without the headers on ~, it's still 6-10x slower
[22:57:05] <strcat> small allocations are really expensive to make in rust
[22:57:11] <strcat> jemalloc can do one in 30ns but we take 300-600ns
[22:57:27] <tikue> ouch
[22:57:41] <strcat> with glibc it's only 3x slower
[22:57:43] <strcat> than C++
[22:57:48] <strcat> "only"
[22:57:51] *** Quits: mib_o3bxiz (Mibbit@BBE7C46A.B4F11D08.8612FA94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[22:57:59] <strcat> rust is fast until you start needing allocations...
[22:58:21] <strcat> maybe the solution is really just to not use libc/jemalloc
[22:58:43] <strcat> Go uses segmented stacks but they don't use libc
[22:58:45] <strcat> they make syscalls
[22:58:53] <strcat> I don't think we can sanely do both
[22:59:01] <doener> don't they just mmap 16GB upfront?
[22:59:12] <tikue> lol
[22:59:17] <strcat> doener: yes but I mean all their I/O code and time code uses syscalls
[22:59:31] <doener> ah, ok
[22:59:52] <strcat> Go is hopelessly slow on windows though
[22:59:56] *** Joins: paupau (paul@moz-D6583788.hsd1.ca.comcast.net)
[23:00:14] *** Joins: Jesse (jruderman@2557E599.66715431.D25A875A.IP)
[23:00:48] <strcat> getting the time on linux doesn't take a context switch
[23:01:06] <strcat> and a small malloc should be really simple/fast
[23:01:25] <strcat> so it does cost a lot to do whatever it is fast_ffi is doing.
[23:02:52] <SimonSapin> "error: cannot borrow immutable dereference of & pointer as mutable" Why is indexing a mutable vector an immutable dereference?
[23:03:20] *** Joins: sebcrozet (Mibbit@moz-7FB6C00B.w193-252.abo.wanadoo.fr)
[23:03:23] <tikue> it's not it's an immutable &ptr
[23:03:32] <tikue> and then when dereferencing it, you try to make it mutable
[23:03:56] <SimonSapin> Im trying this: let block: &mut ComponentValue = &block_stack[len - 1];
[23:03:56] <SimonSapin> block_stack is mutable
[23:04:11] <sebcrozet> Hi, got a wierd problem with a recent version of the compiler: https://gist.github.com/sebcrozet/5905390
[23:04:13] <tikue> but the reference to it is not, because otherwise it would be moving it out of the vector
[23:04:30] <SimonSapin> why cant I get a mutable reference without moving?
[23:04:45] <doener> SimonSapin: try &mut block_stack[len - 1]
[23:04:57] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[23:04:58] <tikue> ^ that sounds like it should work
[23:05:03] <SimonSapin> oh, right
[23:05:09] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:05:34] <cmr> sebcrozet: that is quite puzzling indeed.
[23:06:49] <doener> sebcrozet: I get 0.016 for all functions
[23:06:55] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[23:06:58] <cmr> I get the same behavior, without -O
[23:07:00] <doener> with rustc 0.7-pre (ca835f4 2013-06-30 13:12:15 -0700)
[23:07:03] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:07:07] <bblum> i can't think of a good name for the equivalent thing to JoinLatch that i'm implementing in my taskgroup code
[23:07:07] <cmr> With -O everything works as expected
[23:07:13] <bblum> currently i'm just calling it... JoinLatch
[23:07:19] <bblum> suggestions welcome
[23:07:31] <bblum> (and the corresponding spawn mode called 'latched', which is kinda bad)
[23:07:37] <doener> cmr: -O makes no difference for me, works with and without
[23:07:47] <sebcrozet> doener: I use rustc 0.7 (d5c5ce3 2013-06-30 21:08:48 -0700)
[23:07:51] <cmr> doener: the plot thickens!@
[23:08:09] <strcat> nmatsakis: I'm just not very convinced we can have both segmented stacks and hit the systems language niche at this point
[23:08:13] <strcat> because it seems to have a huge cost
[23:08:44] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Ping timeout)
[23:08:53] <strcat> I think for starters we would have to not use libc/libuv
[23:08:56] *** Joins: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP)
[23:09:13] <sebcrozet> cmr: The funny thing is that i you remove the first println, then you have "In b: 0".
[23:09:49] <doener> sebcrozet: hm, no "obvious" commit in between those versions. Just a version bump and strcat's alloc improvements
[23:09:52] <cmr>   br label %call
[23:09:54] <cmr> call:
[23:09:56] <cmr>   br label %call1
[23:09:58] <cmr> call1:
[23:10:00] <cmr> awesome, rustc
[23:10:09] * doener is working on removing those
[23:10:13] <cmr> <3
[23:10:26] <doener> currently I'm running into double frees again
[23:10:35] *** Quits: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP) (Quit: carllerche)
[23:10:58] <doener> but unless I accidently killed some glue calls, those empty blocks made up 10% of libstd
[23:11:05] <cmr> damn
[23:11:13] <doener> std.ll currently goes from 500k to 450k lines
[23:11:19] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:11:46] <strcat> closures really don't optimize well
[23:12:19] <brson> bstrie: what's the status of that code snippet?
[23:12:36] * strcat wonders what we're doing wrong with closures :(
[23:12:58] <doomlord> strcat> there's no mmap/madvise/munmap in C
[23:13:05] *** Quits: hjr3 (hradtke@moz-CD5B319C.sfo1.dsl.speakeasy.net) (Quit: My MacBook has gone to sleep. ZZZzzz)
[23:13:09] <doomlord> source of confusion in our arguemnt :)
[23:13:15] *** Quits: kodablah (Mibbit@moz-296F4F9C.dal05.softlayer.com) (Quit: http://www.mibbit.com ajax IRC Client)
[23:13:21] <doomlord> i've only dealt with situations where functoins like that were available 
[23:13:40] *** Joins: xLII (xLII@4BED3CB3.F5F53E8A.2D6DB75E.IP)
[23:14:23] <strcat> the assembly this closure turns into looks like exploit code
[23:14:26] <strcat> it has long chains of nops
[23:14:28] <strcat> :|
[23:15:03] <strcat> does it really make sense for LLVM to output >20 nops in a row?
[23:15:09] *** Quits: seth (seth@2557E599.66715431.D25A875A.IP) (Input/output error)
[23:15:17] *** Quits: jpochyla (jpochyla@moz-8D99AE5D.broadband18.iol.cz) (Ping timeout)
[23:15:31] <cmr> alignment maybe? alignment for what, I do not know.... or to what
[23:15:54] <paupau> funny coincidence, I'm trying to write a task with its own mmap'd and madvise'd heap and allocator :)
[23:16:24] *** Quits: maxli (maxli@B5559308.9C54E60.2FA4EA88.IP) (Quit: Leaving.)
[23:17:16] <paupau> er, mlock
[23:17:26] * strcat wonders why some nops are much more expensive than others according to perf
[23:17:36] <doomlord> also reading your paper it seems it mentions something called  "regioins" which i include in the phrase "custom allocators".. the paper seperates them, for the purpose of claiming the authors magic combination of regions & heaps is special/unique
[23:17:37] <cmr> strcat: sampling of course
[23:18:03] <strcat> regions are arenas
[23:18:16] <strcat> allocators use their own arenas, it's not magic
[23:18:32] <MaikKlein> we have an asm! macro? 
[23:18:35] <cmr> tjc: ping
[23:18:38] <cmr> MaikKlein: yes
[23:18:51] <tjc> cmr: pong
[23:18:51] <MaikKlein> good that I can only write mips :(
[23:19:01] <strcat> uh
[23:19:03] <strcat>              callq  std..option..Option$LT$$UP$extra..treemap..TreeNode$LT$uint$C$uint$GT$$GT$::_316c8f8435e83c3f::glue_
[23:19:09] <strcat> are we really supposed to be mangling names like that?
[23:19:13] <Luqman> MaikKlein: well theoretically rust can target mips :P
[23:19:15] <strcat> $LT? ;\
[23:19:21] <doomlord> ". We find that the Lea allocator is
[23:19:21] <doomlord> as fast as or even faster than most custom allocators. The excep-
[23:19:21] <doomlord> tions are region-based allocators, which often outperform general-
[23:19:21] <doomlord> purpose allocation"
[23:19:26] <MaikKlein> :D
[23:19:43] <Luqman> strcat: i think the android assembler didn't like some symbols like >, >
[23:20:13] <MaikKlein> rusti: asm!();
[23:20:13] *** Joins: yichoi (yichoi@5AB4884B.FCC4549.14D5B978.IP)
[23:20:14] -rusti- <anon>:1:0: 1:0 error: unexpected token: `<eof>`
[23:20:14] -rusti- <anon>:1 #[allow(default_methods)];
[23:20:14] -rusti-          ^
[23:20:14] -rusti- application terminated with error code 101
[23:20:14] <cmr> tjc: I'm getting some very confusing behavior that I cannot quite pin down, and it seems to be in code you own: https://github.com/cmr/rustdoc-prototype/blob/wip/rustdoc.rs makes https://gist.github.com/cmr/1262b8f752d945052877
[23:20:18] <doomlord> we spent all that time arguing over what you can and can't call a custom allocator lol
[23:20:30] <tjc> cmr: I'll take a look
[23:20:48] <strcat> Luqman: what would $UP be then?
[23:21:10] <MaikKlein> can someone write something simple with asm! ?
[23:21:10] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[23:21:46] *** Quits: jensnockert (jensnocker@moz-C5F27039.cust.bredband2.com) (Input/output error)
[23:21:55] <strcat> treemap::remove::heir_swap_5813::_cd7ca738c5611aed::_00 I mean, that looks sane
[23:22:29] <strcat> maybe it only looks okay because it's mangling wrong
[23:22:34] <strcat> it's a generic function
[23:22:42] <tjc> cmr: the error just means it wasn't in rustc's wired-in idea of where rustpkg puts packages (which is probably wrong anyway) -- the issue is that it's not able to resolve an `extern mod`
[23:22:52] <tjc> I'm not sure which one, since the error message doesn't say
[23:22:59] <Luqman> rusti: let (a, b) = (1, 2); let mut c = 0; unsafe { asm!("add $2, $0" :"=r"(c) :"0"(a), "r"(b)); } c
[23:23:00] -rusti- 3
[23:23:05] <Luqman> MaikKlein: ^
[23:23:17] <cmr> tjc: probably libstd, it's the only extern mod that could possibly be used.
[23:23:18] <heftig> strcat: are you sure it was > 20 nops?
[23:23:24] <strcat> heftig: yep
[23:23:32] <strcat> looking at perf's annotated asm
[23:23:36] <heftig> maybe the cpu you use loads 32-byte words
[23:23:38] <cmr> tjc: I copied the passes I'm running directly from librustc/driver/driver.rs, am I missing something important?
[23:23:58] <doener> strcat: UP/SP are ~ and @
[23:24:00] <strcat> heftig: it's just x86_64 though, rust doesn't have -march=native
[23:24:02] <cmr> maybe basic_options is missing a library path or something
[23:24:04] * cmr looks
[23:24:14] <strcat> doener: and : is . now?
[23:24:23] <doener> apparently
[23:24:26] <strcat> std..option..Option$LT$$UP$extra..treemap..TreeNode$LT$uint$C$uint$GT$$GT$::_316c8f8435e83c3f::glue_dr
[23:24:29] <strcat> rest is cut off
[23:24:32] * doener really _really_ preferred the old mangling
[23:24:33] <strcat> doesn't fit in perf's window
[23:24:40] <heftig> strcat: http://linux.m2osw.com/so-many-nopw-and-nopl-amd64-code
[23:24:52] <tjc> cmr: if you grep for "sysroot" in the rustpkg sources, that *might* tell you what you need to do in your code
[23:25:01] <tjc> to allow it to find libstd
[23:25:01] <Luqman> oh man, inline asm works in rusti (not the bot)
[23:25:31] <cmr> tjc: cool, thanks
[23:26:09] <MaikKlein> Luqman, thanks
[23:27:34] <bblum> brson: what do you think i should call the analogous data structure to JoinLatch in my taskgroup code
[23:27:39] <bblum> currently i am just going with JoinLatch
[23:27:42] <bblum> which... c.c
[23:28:12] *** Quits: kmc (mozilla@2557E599.66715431.D25A875A.IP) (Quit: Leaving.)
[23:29:03] *** Joins: Azdle (patrick@moz-8C723B60.hsd1.mn.comcast.net)
[23:29:06] *** Joins: kmc (keegan@moz-D2A53639.compute-1.amazonaws.com)
[23:29:10] *** Quits: kmc (keegan@moz-D2A53639.compute-1.amazonaws.com) (Quit: kmc)
[23:29:33] *** Joins: kmc (keegan@moz-D2A53639.compute-1.amazonaws.com)
[23:29:34] *** Quits: sebcrozet (Mibbit@moz-7FB6C00B.w193-252.abo.wanadoo.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[23:30:38] *** Joins: carllerche (carllerche@6B070D22.7E6A0813.1428D117.IP)
[23:31:00] *** Quits: illissius (illissius@moz-19397A63.catv.broadband.hu) (Ping timeout)
[23:31:28] *** Joins: illissius (illissius@moz-19397A63.catv.broadband.hu)
[23:32:07] *** Joins: zq (p@moz-4C4640FD.com)
[23:32:34] *** Joins: aatch_ (aatch@moz-2BB0AC01.cable.telstraclear.net)
[23:32:34] *** Joins: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP)
[23:32:34] <ghrust> 01[13rust01] 15brson 04force-pushed 06try from 14b3e73df to 14ddbccec: 02http://git.io/k471pw
[23:32:34] <ghrust> 13rust/06try 1429d8300 15Brian Anderson: core::rt: Move uv idle tests to idle mod
[23:32:34] <ghrust> 13rust/06try 148072690 15Brian Anderson: core::rt: Add bindings for async uv handles
[23:32:34] <ghrust> 13rust/06try 146d8d73c 15James Miller: Add AtomicUint newtype
[23:32:35] *** Parts: ghrust (ghrust@9C8B94D4.6A2AE50.F3114085.IP) ()
[23:32:37] <zq> > let x = 4;
[23:32:52] <cmr> rusti: let x = 4;
[23:32:55] -rusti- <anon>:9:13: 9:14 warning: unused variable: `x` [-W unused-variable (default)]
[23:32:55] -rusti- <anon>:9          let x = 4;
[23:32:57] -rusti-                       ^
[23:33:00] -rusti- ()
[23:33:05] <MaikKlein> haha I just found the weirdest bug I have ever seen (so far)
[23:33:12] <zq> thanks
[23:33:30] <sully> oh, sigh, that is irritating
[23:33:42] <sully> you can't really chain together iterators from a transform
[23:33:45] *** Quits: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk) (Client exited)
[23:33:48] <sully> with ones straight from an option or a vector
[23:33:56] <strcat> sully: you should be able to
[23:33:58] <zq> rusti: let x = if true {4} else {ret 3;}; x
[23:33:59] <MaikKlein> if I use  println everything works, if I don't use it everything goes to ****
[23:33:59] -rusti- <anon>:9:39: 9:40 error: expected `;` or `}` after expression but found `3`
[23:33:59] -rusti- <anon>:9          let x = if true {4} else {ret 3;}; x
[23:33:59] -rusti-                                                 ^
[23:33:59] -rusti- application terminated with error code 101
[23:34:02] <brson> bblum: do you have any suggestions?
[23:34:04] <strcat> sully: what do you mean exactly?
[23:34:10] <bblum> brson: i can't really think of anything
[23:34:14] <cmr> zq: whoa, what are you using to learn rust?
[23:34:18] <cmr> zq: that's ancient syntax
[23:34:20] <bblum> it's kind of a weird concept
[23:34:23] <zq> cmr: how so?
[23:34:31] <bblum> in that it has to do with failure propagation, but has nothing to do with task killing
[23:34:32] <cmr> zq: `ret` is no longer a keyword
[23:34:38] *** Joins: Amanieu (amanieu@moz-D5D10CA8.halls.manchester.ac.uk)
[23:34:43] <sully> strcat: so, the problem is that the option and vec iterators produce & pointers
[23:34:46] <zq> http://dl.rust-lang.org/doc/0.3/tutorial.html , just noticed the '0.3'
[23:34:50] <cmr> ... yeah
[23:34:52] <aatch_> MaikKlein, what's the bug?
[23:34:56] <zq> cmr: what's the kw for an early return?
[23:35:00] <sully> strcat: which I can't really do from the transform
[23:35:03] <cmr> zq: `return`
[23:35:08] <zq> rusti: let x = if true {4} else {return 3;}; x
[23:35:10] -rusti- <anon>:9:42: 9:43 error: mismatched types: expected `()` but found `<VI1>` (expected () but found integral variable)
[23:35:10] -rusti- <anon>:9          let x = if true {4} else {return 3;}; x
[23:35:10] -rusti-                                                    ^
[23:35:10] -rusti- error: aborting due to previous error
[23:35:10] -rusti- application terminated with error code 101
[23:35:13] <cmr> 0.3 is a year old at this point.
[23:35:19] <cmr> http://dl.rust-lang.org/doc/tutorial.html
[23:35:21] <strcat> sully: ah
[23:35:26] <aatch_> zq, `return`, but I suggest... no insist that you check out a newer version
[23:35:33] <strcat> sully: well .map(|&x| x) won't be that bad
[23:35:37] <aatch_> like the just-released 0.7
[23:35:42] <zq> .msg rusti let x = if true {4} else {return 3;}; x
[23:35:44] <cmr> aatch_: not released yet
[23:35:55] *** Quits: aatch (aatch@moz-B437F499.pocketrent.com) (NickServ (GHOST command used by aatch_))
[23:36:02] <cmr> zq: every branch of an if has to have the same return type.
[23:36:10] *** Joins: aatch (aatch@moz-B437F499.pocketrent.com)
[23:36:15] <paupau> is the 0.7 tarball on static.rust-lang final?
[23:36:17] <cmr> zq: although that returns !, probably should be handled differently
[23:36:19] <zq> cmr: what's the return type of "return 3"?
[23:36:25] <cmr> not !
[23:36:26] <strcat> cmr: it will let you do that but the fn it's in doesn't take int
[23:36:30] <strcat> er
[23:36:32] <strcat> return int
[23:36:34] <cmr> oh wait
[23:36:38] <zq> rusti let x = if true {4} else {return 3}; x
[23:36:38] <cmr> herp, forgot about that
[23:36:47] <zq> rusti: let x = if true {4} else {return 3}; x
[23:36:48] -rusti- <anon>:9:42: 9:43 error: mismatched types: expected `()` but found `<VI1>` (expected () but found integral variable)
[23:36:48] -rusti- <anon>:9          let x = if true {4} else {return 3}; x
[23:36:48] -rusti-                                                    ^
[23:36:48] -rusti- error: aborting due to previous error
[23:36:48] -rusti- application terminated with error code 101
[23:36:59] <cmr> zq: rusti runs your code in 'fn main' which doesn't return an int
[23:37:01] <cmr> which is the error
[23:37:11] <tjc> well, also there need to be {} around the block
[23:37:15] <tjc> oh, never mind
[23:37:15] <zq> cmr: yes, this was intentional
[23:37:18] <tjc> misparsed
[23:37:19] <cmr> (and the value of `return` is bottom I think, not positive)
[23:37:26] <zq> cmr: i wanted to see what the return type of return would be
[23:37:37] <zq> i'm assuming that "return" is an expression
[23:37:41] *** Joins: brendan (brendaneic@2557E599.66715431.D25A875A.IP)
[23:37:48] <MaikKlein> aatch_, https://gist.github.com/MaikKlein/5905605
[23:37:50] <aatch_> zq, no, it's not
[23:37:51] <zq> no, it's a statement
[23:37:56] <cmr> Yes it is
[23:37:57] <cmr> http://static.rust-lang.org/doc/rust.html#return-expressions
[23:38:02] <tjc> It's actually both
[23:38:02] <aatch_> cmr, really?
[23:38:04] <zq> so if if-else is an expr
[23:38:05] *** Quits: tikue (tkuehn@2557E599.66715431.D25A875A.IP) (Quit: tikue)
[23:38:05] <strcat> zq: functions can return ! though
[23:38:15] <tjc> because all expressions are also statements (if you add a ';' to the end)
[23:38:27] <zq> tjc: no
[23:38:35] <strcat> rusti: fn bottom() -> ! { fail!() } let x = if true { 3 } else { bottom() }; x
[23:38:36] -rusti- 3
[23:38:38] <zq> tjc: ; just shortcircuits the valuse to ()
[23:38:55] <strcat> zq: it's failing not because of return, but because you're in 'main'
[23:39:03] <strcat> and main doesn't return int
[23:39:10] <zq> my point is that if if-else are expressions, what's the value of an if-else with a return inside of it?
[23:39:21] <strcat> zq: an early return
[23:39:23] <zq> or rather type*
[23:39:24] <strcat> before the end of the fn
[23:39:32] <strcat> zq: the type is just !
[23:39:38] <tjc> zq: the type is the type of the if branch that doesn't return
[23:39:42] <zq> strcat: ! == the "early return" type?
[23:39:46] *** Joins: tikue (tkuehn@2557E599.66715431.D25A875A.IP)
[23:39:46] <aatch_> MaikKlein, hmm, seems like a codegen bug that's killing a dead store.
[23:39:57] <cmr> I thought ! was "this function never returns"
[23:39:57] <strcat> zq: it means it never returns
[23:39:58] <tjc> return has the type _|_ (spelled bottom), which is a supertype of every type
[23:40:02] <strcat> cmr: yes
[23:40:07] <cmr> right, not bottom
[23:40:11] *** Joins: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP)
[23:40:12] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 144902f0a to 14e482856: 02http://git.io/N3iJvQ
[23:40:12] *** Parts: ghrust (ghrust@FD7BC443.6A2AE50.F3114085.IP) ()
[23:40:12] <aatch_> zq, no, the return type of that if-else is the intersection of int and _|_, which is int
[23:40:13] *** Joins: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP)
[23:40:14] <ghrust> 01[13rust01] 15bors pushed 4 new commits to 06auto: 02http://git.io/F7-9DA
[23:40:14] <ghrust> 13rust/06auto 14c63e152 15Niko Matsakis: Constrain maximum lifetime of stack closures that capture variables to...
[23:40:14] <ghrust> 13rust/06auto 147856fca 15Niko Matsakis: Improve test
[23:40:14] <ghrust> 13rust/06auto 1437a8604 15Niko Matsakis: Improve error message
[23:40:14] *** Parts: ghrust (ghrust@CFE85B59.6A2AE50.F3114085.IP) ()
[23:40:16] <strcat> return doesn't ever return flow control to the function it was used in
[23:40:25] <strcat> rusti: let x = if true { 3 } else { return }; x
[23:40:26] -rusti- 3
[23:40:28] <zq> aatch_: what
[23:40:29] <tjc> aatch_: Actually the greatest lower bound, not the intersection
[23:40:41] <aatch_> tjc, I guessed a word
[23:40:44] <MaikKlein> do we have a sleep?
[23:40:48] <MaikKlein> or wait
[23:40:53] <tjc> aatch_: heh, well intersection types are also a thing, but Rust doesn't have them
[23:40:53] <strcat> MaikKlein: extra::timer
[23:41:12] <strcat> tjc: lifetimes?
[23:41:25] * strcat doesn't really know what an intersection type is though
[23:41:31] <tjc> strcat: Oh, maybe I don't understand the lifetime checker enough to know
[23:42:00] <cmr> tjc: So the sysroot seems to be where the executables are stored (here it's ~/.local/bin, on rusti-the-bot it's /home/rust), not libraries... does it look for paths relative to where the binaries are at?
[23:42:11] <zq> strcat: why does rusti accept "else { return }" but not "else { return 4 }"?
[23:42:13] <cmr> s/binaries/executables/
[23:42:17] <strcat> tjc: well if you have a fn taking &'r T in two params, it will become the intersection of the lifetimes
[23:42:24] <cmr> zq: because fn main returns (), and rusti runs all code in fn main.
[23:42:26] <tjc> cmr: hmm, I would guess the sysroot is actually ~/.local --
[23:42:36] <strcat> tjc: dunno if that's an 'intersection type' :)
[23:42:37] <tjc> and then it looks for the binaries in the `bin` subdirectory of that, and the libraries in the `lib` subdir
[23:42:45] <strcat> could also be...
[23:42:50] <zq> rusti: let x = if false {3} else {return}; x
[23:42:56] <cmr> rusti: fn foo() -> int { if true { 3 } else { return 4 } }
[23:42:57] -rusti- ()
[23:43:07] <zq> did i break it?
[23:43:11] <strcat> zq: no
[23:43:11] <cmr> rust-buildbot: 5
[23:43:13] <cmr> erm
[23:43:15] <cmr> rusti: 5
[23:43:16] -rusti- 5
[23:43:17] <strcat> zq: you returned from main
[23:43:21] <cmr> oh, right
[23:43:21] <strcat> so it didn't do anything but return
[23:43:28] <aatch_> zq, it's because the rusti bot just takes your input wraps it in a main, compiles and executes it.
[23:43:33] <zq> grr, i really want the type of that thing
[23:43:36] <strcat> zq: !
[23:43:58] <strcat> rusti: fn foo() -> ! { fail!() } let x = if true { 5 } else { foo() }; x
[23:43:58] -rusti- 5
[23:44:12] *** Joins: sockmister (Mibbit@moz-D7F31788.hsd1.mi.comcast.net)
[23:44:27] *** Quits: sockmister (Mibbit@moz-D7F31788.hsd1.mi.comcast.net) (Quit: http://www.mibbit.com ajax IRC Client)
[23:44:29] <strcat> 'return' leaves the fn
[23:44:31] <aatch_> zq, of the return expr? In theory, it's `!`, in practice it doesn't have one, since it's an early return.
[23:44:52] <zq> ok, 6.1.3.3
[23:44:54] <cmr> tjc: Oh, you're right, I was reading this code wrong.
[23:45:01] <tjc> cmr: ok, cool
[23:45:11] <cmr> It calls pop first, so it is ~/.local
[23:45:16] <tjc> yeah
[23:45:23] <MaikKlein> rusti: for std::int::range(0,2) |x|{print(~"42 ")}
[23:45:25] <tjc> I've spent a fair amount of time being confused about that
[23:45:25] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/KPMV
[23:45:27] <zq> but still, how could that be that let be valid?
[23:45:29] <cmr> heh :)
[23:45:43] <strcat> zq: because ! is the type of things that never return
[23:45:47] <zq> if cond {3} else {return} has type int if cond otherwise !
[23:45:55] <cmr> zq: "Rather, the result type of a diverging function is a special type called  ("bottom") that unifies with any type. Rust has no syntax for ."
[23:45:58] <strcat> zq: the compiler knows ! means it never gets there
[23:46:16] <zq> cmr: yeah, saw that one
[23:46:17] <aatch_> zq, because rustc knows that if it takes the second branch, 'x' will never be assigned to.
[23:46:33] <zq> not strict enough
[23:46:36] <strcat> rusti: fn foo() -> ! { unsafe { libc::abort() } } let x = if true { 5 } else { foo() }; x
[23:46:36] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/UQHP
[23:46:46] <strcat> rusti: fn foo() -> ! { unsafe { std::libc::abort() } } let x = if true { 5 } else { foo() }; x
[23:46:47] -rusti- 5
[23:46:50] <zq> so could you say that "!" is the parent of all types?
[23:46:52] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:47:00] <zq> child, rather
[23:47:02] <cmr> zq: bottom is
[23:47:10] <cmr> tjc already said that
[23:47:13] <aatch_> zq, no, ! is the type of a divergent function.
[23:47:20] <aatch_> so it never returns
[23:47:30] <cmr> and yes, supertype of every type
[23:47:33] <strcat> we don't have type inheritance so the 'parent' of a type doesn't really make sense
[23:47:34] <tjc> zq: ! actually means something different from bottom
[23:47:37] <zq> erf, _|_ is the type, ! is the notation to mark a fn as type _|_
[23:47:38] <tjc> ! means "I always diverge"
[23:47:40] <strcat> cmr: we don't have supertypes though
[23:47:41] <zq> correct?
[23:47:46] <tjc> _|_ means "I don't know anything about this type"
[23:48:13] <tjc> strcat: We do for _|_. that's the one case (aside from lifetimes) where we do subtyping
[23:48:14] <aatch_> zq, no, since a -> ! _by definition_ doesn't return.
[23:48:46] *** Quits: SimonSapin (simon@88F51059.F3BBB17D.144F44FA.IP) (Ping timeout)
[23:49:09] *** Joins: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP)
[23:49:09] <ghrust> 01[13rust01] 15bors 04force-pushed 06auto from 1454158a2 to 14e482856: 02http://git.io/N3iJvQ
[23:49:09] *** Parts: ghrust (ghrust@DE823A67.6A2AE50.F3114085.IP) ()
[23:49:11] *** Joins: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP)
[23:49:11] <ghrust> 01[13rust01] 15bors pushed 5 new commits to 06auto: 02http://git.io/5f4ehw
[23:49:11] <ghrust> 13rust/06auto 14d088a05 15James Miller: Add new snapshot to snapshots.txt
[23:49:11] <ghrust> 13rust/06auto 143fde9dd 15James Miller: Remove stage'd code
[23:49:11] <ghrust> 13rust/06auto 146d77510 15James Miller: Clean warnings
[23:49:12] *** Parts: ghrust (ghrust@2EE61FCC.6A2AE50.F3114085.IP) ()
[23:49:20] <cmr> zq: bottom is a valid type for every expression, always.
[23:49:20] <aatch_> finally!
[23:49:33] <cmr> aatch_: everything seems to be failing... I wouldn't say finally just yet
[23:49:43] <aatch_> cmr, just that it got to it...
[23:49:50] <bblum> brson: what's the deal with TaskBuilder::spawn() overriding the gen_body and the notify_chan with None?
[23:49:53] <aatch_> I submitted that on sunday
[23:50:02] <cmr> Hm
[23:50:04] <cmr> http://buildbot.rust-lang.org/builders/auto-linux-64-nopt/builds/218/steps/compile/logs/stdio
[23:50:15] <cmr> How do these PRs that don't build keep getting through?
[23:50:16] <strcat> tjc: the compiler actually reasons about it that way?
[23:50:21] <aatch_> admittedly it did need rebasing.
[23:50:24] <cmr> I mean, grammar is a thing
[23:50:53] <tjc> strcat: Yes, in sort of an ad hoc way (since we only have one type that can be a subtype)
[23:51:06] <tjc> see typeck/check/mod.rs, I think
[23:51:33] <strcat> oh that evil file
[23:51:37] <bblum> argh this stupid build system
[23:51:43] <strcat> to me, that file is just where you have to deal with intrinsic type signatures ;p
[23:51:46] <zq> i'm quite confused about ! and _|_
[23:51:56] <aatch_> strcat, it's done on a greatest-lower-bound/least-upper-bound way, where bottom is the greatest possible bound.
[23:51:56] *** Quits: jclements (jclements@2557E599.66715431.D25A875A.IP) (Quit: jclements)
[23:52:05] <tjc> I think this discussion shows we could expand our docs
[23:52:07] <tjc> so I opened https://github.com/mozilla/rust/issues/7538
[23:52:08] *** Quits: eholk (eholk@moz-BF0BB923.uconnect.utah.edu) (Quit: eholk)
[23:52:10] <toddaaro> brson: ok, pull request up
[23:52:26] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)
[23:52:57] <zq> aatch_: why would you declare the fn to be type ! but not _|_ if the value of the return statement is _|_?
[23:53:00] <cmr> zq: ! is the type of a function that never returns, _|_ is the type of an *expression* that's value is never used... kinda sorta
[23:53:13] <aatch_> zq, `!` is just the syntax we use to indicate a divergent function. It does fit into the type system, but only as a convenience
[23:53:14] <cmr> not used, really, that's imprecise
[23:53:26] <zq> cmr: but why separate types?
[23:53:36] <aatch_> cmr, there is no syntax for bottom.
[23:53:40] <cmr> zq: because they are different things
[23:53:42] <cmr> aatch_: I know
[23:54:03] <aatch_> cmr, sorry, I mean zq
[23:54:05] <bjz> why can't we actually change ! to _|_ ?
[23:54:08] <strcat> tjc: it's eerily familiar because I often see the errors from this file as ICEs ;p
[23:54:11] *** Joins: eholk (eholk@moz-BF0BB923.uconnect.utah.edu)
[23:54:14] <tjc> strcat: haha, sad
[23:54:24] <aatch_> bjz, because that's annoying to type?
[23:54:30] <cmr> bjz: because they're different things
[23:54:30] <zq> aatch_: but there is. "!" would denote _|_
[23:54:32] <brson> bblum: spawn is swapping the gen_body and notify_chan values out of the TaskBuilder so it can move them somewhere else
[23:54:38] <zq> there could be, rather
[23:54:41] <aatch_> zq, except that it's not true.
[23:54:55] <tjc> so, keep in mind, ! is not a type
[23:54:57] <tjc> _|_ is a type
[23:54:59] <aatch_> you can't return from a function returns `!`
[23:55:03] <zq> what the heck is "!"
[23:55:05] <tjc> you can't write let x: ! = divergent_thing() in Rust
[23:55:05] <bjz> tjc: oh ok
[23:55:11] <tjc> if it were a type, you would be able to write that
[23:55:11] <zq> ! is a type, ! is not a type
[23:55:16] <aatch_> zq, a divergent function.
[23:55:18] <cmr> Oh, my bad :(
[23:55:21] <bblum> brson: oh, right, it's code from before self-by-move existed
[23:55:31] <cmr> it does go in the type position in the function declaration syntax though
[23:55:35] <tjc> Right
[23:55:38] <strcat> tjc: but could you write 'let x: _|_  = return 5;' in a pretend world where it was valid syntax?
[23:55:38] <bjz> tjc: what's the difference between fn() -> () and fn() -> !?
[23:55:50] <nmatsakis> strcat: I confess to having my own doubts
[23:55:54] <cmr> bjz: the first returns (), the second never returns
[23:56:00] <aatch_> bjz, one returns, the other does not.
[23:56:01] *** Quits: azita (Azita@2557E599.66715431.D25A875A.IP) (Quit: azita)
[23:56:07] <tjc> bjz: what cmr said
[23:56:10] <strcat> tjc: well I guess that steps into really weird territory because what would &x be ;p
[23:56:18] <zq> the syntax is, 'fn' func_name arg_list '->' return_value_type body, no?
[23:56:18] * strcat shrugs
[23:56:22] <tjc> strcat: hmm, well, it would be kind of silly, because...
[23:56:22] <bblum> i never understood why ! couldn't be used as a type name
[23:56:27] <tjc> nothing would ever be able to access the name "x"
[23:56:27] <bblum> seemed arbitrary to me
[23:56:33] <bjz> cmr: so || { loop{} } would be fn() -> ! ?
[23:56:37] <tjc> bblum: because we're not Haskell, so you can't name things with the always-diverges type
[23:56:42] <bblum> hmm
[23:56:56] <aatch_> '!' is a hack, a shim.
[23:57:01] <zq> got it
[23:57:02] <cmr> rusti: fn foo() -> ! { loop {} }; foo()
[23:57:04] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/PMhR
[23:57:09] <bjz> (but llvm optimises loop{}s out)
[23:57:11] <zq> i was stuck in the haskell mindset
[23:57:22] <aatch_> it allows Rust to exist in a world where you can call functions that kill the process there and then
[23:57:33] <tjc> the reason ! was added is
[23:57:35] <aatch_> and allow it still ensure memory safety and type check
[23:57:39] <bjz> ok
[23:57:53] <tjc> suppose I want to write: let x = if stuff() { 42 } else { fail!("oh no") };
[23:57:56] <tjc> and then use x
[23:57:59] <strcat> tjc: how different is it from something like 'enum Foo {}' where you can never actually have a Foo?
[23:58:04] <tjc> well, actually, that's not the best example
[23:58:06] *** Joins: seth (seth@2557E599.66715431.D25A875A.IP)
[23:58:09] <tjc> suppose I write: 
[23:58:09] <strcat> it seems like the same thing
[23:58:11] <strcat> to me
[23:58:12] <engla> you can still sub out functions with fail!() yeah
[23:58:21] *** Quits: q66 (q66@6EE9DE40.46454B5D.33AABD5F.IP) (Quit: Leaving)
[23:58:22] <tjc> let x; if stuff() { x = 42; } else { fail!() };  use x ...
[23:58:31] <zq> heavy price to pay for if-else expressions
[23:58:38] <strcat> rusti: enum Foo {}; let x: Option<Foo> = None; x
[23:58:38] <aatch_> zq, what is?
[23:58:39] -rusti- None
[23:58:40] <tjc> if we didn't have !, the analysis that checks if all variables are initialized-before use would say
[23:58:47] <tjc> "oh, in that one branch you call fail but you don't initialize x"
[23:58:54] <tikue> rusti: let mut (a, b) = (1, 2);
[23:58:55] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/HAVd
[23:58:59] <tjc> but it knows about ! so it knows that if you reach taht branch, you'll never reach the code using x
[23:59:01] <bjz> zq: for matches too?
[23:59:04] <tikue> rusti: let (mut a, mut b) = (1, 2);
[23:59:05] -rusti- more than 5 lines of output, pastebinned: http://sprunge.us/ZVYj
[23:59:09] <engla> fn do_stuff(A) -> B { fail!() /* not implemented */ }    in Python we just go  def do_stuff(A): pass
[23:59:12] <tjc> strcat: I'd have to think about that...
[23:59:23] <aatch_> it also would make match expressions on not-enums impossible without dependent types.
[23:59:40] <tjc> strcat: maybe it's not different. it's just that at the time, I'm not even sure we allowed uninhabited declarations
[23:59:41] <bjz> match x { true => foo(), false => fail!() }

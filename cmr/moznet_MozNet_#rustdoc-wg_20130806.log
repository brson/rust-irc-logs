[00:00:59] <cmr> Alrighty, doc(hidden)
[00:01:56] <cmr> Wow I did not structure this very well
[02:02:01] <jga> Seldaek: the best I saw in db api in statically typed languages are the type providers in f#
[02:02:08] <jga> they have one for sql iirc
[07:55:56] <dbaupp> cmr: ping
[11:34:42] <cmr> dbaupp: oh, pong
[11:35:19] <dbaupp> cmr: 2 questions: why are so many of the clone impls in clean not #[deriving]'d?
[11:35:23] <dbaupp> (bugs?)
[11:35:32] <cmr> dbaupp: all of those are autoderef bugs yes
[11:35:41] <cmr> I *did* register my complaints :p
[11:35:51] <dbaupp> and, I saw that you wanted to encode/decode to/from json etc... doesn't #[deriving(Encodable,Decodable)] work?
[11:35:58] <cmr> I have no idea
[11:35:58] <dbaupp> (how are you currently doing it?)
[11:36:09] <cmr> jedestep played with it and says it works
[11:36:20] <dbaupp> oh
[11:36:41] <cmr> I can't decode from json but I have jsonify.rs for encoding
[11:37:00] <dbaupp> also... from memory, I'm vaguely surprised that those types meet with auto-deref bugs.
[11:37:13] <dbaupp> ... I don't remember any & pointers in them?
[11:37:24] <cmr> neither do I
[11:37:27] <cmr> afaict there aren't any
[11:37:31] <cmr> but yet, here we are ;p
[11:37:46] <dbaupp> I'm almost saying "I don't believe you" :P
[11:37:56] <cmr> remove them and try deriving
[11:38:12] <dbaupp> is it updated for for .. in .. ?
[11:38:15] <cmr> yes
[11:39:50] <dbaupp> there's still a foreach apparently :P
[11:39:56] <cmr> oops
[11:40:04] <cmr> oh look my PR was merged
[11:40:06] * cmr updated to master
[11:40:23] <cmr> *updates
[11:40:31] <dbaupp> and.. I hit an ICE :(
[11:40:46] <cmr> where?
[11:40:51] <dbaupp> lookup_item: id not found: 61637
[11:41:06] <cmr> obnoxious :\
[11:41:14] <cmr> the "test suite" ICEs rustc too
[11:41:20] <dbaupp> possibly because I have a confusing rustc setup atm too.
[11:41:57] <dbaupp> "error: mismatched types: expected `~str` but found an enum or structure pattern"
[11:42:19] <cmr> That'd be for span_to_snippet yeah?
[11:42:22] <dbaupp> yup
[11:42:25] * dbaupp updates too
[11:42:27] <cmr> yeah that was my patch
[11:42:41] <cmr> you can just remove the body of to_src and replace it with ~"" as a temporary workaround
[11:43:19] <dbaupp> cool, it works.
[11:43:41] <dbaupp> (as in, it builds)
[11:43:45] * dbaupp tries more deriving
[11:45:54] <dbaupp> struct Struct {, heh
[11:46:11] <cmr> I was almost sad that I didn't need an impl Impl
[11:47:06] <dbaupp> you should add one
[11:48:17] <dbaupp> fwiw, #[deriving(Clone)] doesn't explode everything
[11:48:28] <dbaupp> ok, maybe it explodes some things
[11:49:46] <dbaupp> no, just needed more #[deriving]'s. unexploded now.
[11:51:23] <dbaupp> cmr: changing everything to use #[deriving(Encodable,Decodable)] will (1) possibly change the schema dramatically, but (2) make it extremely easy for Rust programs to interact with rustdoc_ng's jsons... worth it?
[11:51:34] <cmr> dbaupp: Yes!
[11:51:48] <cmr> Seldaek: (sorry!)
[11:52:18] <cmr> I have no idea how extra::serialize works or is designed though
[11:52:21] * dbaupp thinks Seldaek should just port node.js & v8 to rust to allow using the underlying Encodable/Decodable instances
[11:52:39] <dbaupp> cmr: it's not particularly complicated... when given examples.
[11:54:23] <dbaupp> cmr: is Crate.mods always a singleton?
[11:54:28] <cmr> dbaupp: yes
[11:55:06] <dbaupp> couldn't it just be .mod: Module, then?
[11:55:13] <cmr> ...yes
[11:57:31] * dbaupp won't change that now
[12:21:10] <cmr> clean.rs is really a mess
[12:21:18] <cmr> there's like, 3 identifiable layers of different style
[12:21:25] <cmr> (style in "how I am going to extract these"
[12:21:27] <cmr> )
[12:22:10] <dbaupp> ah :(
[12:22:22] * cmr is going through and cleaning it all up
[12:22:37] <dbaupp> well, at least with #[deriving(Encodable, Decodable)] it'll be easier to change without worrying about jsonify
[12:22:43] <cmr> yes
[12:22:44] <dbaupp> (although, Seldaek might not like you. :P )
[12:22:49] <cmr> :)
[12:24:07] <cmr> We're not version 1.0 yet, I don't mind
[12:24:56] <dbaupp> fwiw, I think that having {"metadata": {"schema": "0.6", ...}, "crate": { ... } } would make this easier too.
[12:25:06] <cmr> sure
[12:25:34] <cmr> Also, I'm replacing most direct uses of Struct etc with Item<Struct>
[12:25:40] <cmr> Item just contains name, attrs, where
[12:25:45] <cmr> because *everything* has those
[12:25:54] <cmr> (and it makes doc attr folding etc easier)
[12:25:56] <dbaupp> right
[12:31:46] <cmr> dbaupp: do you have a patch cooking for encodable/decodable?
[12:34:40] <dbaupp> cmr: yeah
[12:34:53] <cmr> alright I won't put too much effort into updating jsonify then
[12:41:42] <cmr> dbaupp: so the problem with like clean.rs:459:11: 459:16 error: mismatched types: expected `clean::Path` but found `&clean::Path` (expected struct clean::Path but found &-ptr)
[12:41:46] <dbaupp> cmr: I'm thinking OutputMetadata { schema: ~str } Output<C> { metadata: OutputMetadata, crate: C }
[12:41:48] <cmr> Is that I was missing another Clone impl?
[12:41:52] <dbaupp> I think so
[12:41:59] <cmr> that is a silly error
[12:42:07] <dbaupp> cmr: the purpose of the generic is to accomodate schema changes
[12:42:14] <dbaupp> ... but that won't work
[12:42:17] <dbaupp> so ignore me :)
[12:43:24] <dbaupp> cmr: (and yeah, syntax extensions can't give useful type errors at all :( )
[12:48:17] <dbaupp> cmr: ah, so the json "schema" is { "schema" : .. , <Crate fields>, <things plugins add> } ?
[12:48:35] <cmr> dbaupp: correct
[12:48:53] <dbaupp> how about { "schema": ..., "crate": { ... }, "plugins": {} } ?
[12:48:55] <cmr> Or, rather, "crate: <Crate fields>
[12:48:59] <cmr> That's fine to me
[12:49:42] <dbaupp> now I have to work out how to use {En,De}codable again :(
[12:50:02] * dbaupp cribs off irfy
[12:52:11] <dbaupp> hmmm... it seems that json doesn't let you encode straight to json... you have to go via a writer. :(
[12:52:46] <dbaupp> cmr: will you hate me if I encode to a string and then reparse it again to get the json of the crate?
[12:53:05] <cmr> dbaupp: not if you have // FIXME: this is awful
[12:53:11] <cmr> and open an issue :p
[12:53:22] <dbaupp> rustdoc and/or rustc?
[12:53:26] <cmr> rustdoc
[12:53:31] <cmr> although rustc probably deserves one too
[12:54:03] <dbaupp> yeah
[12:59:10] <dbaupp> cmr: maybe plugins should just be a list?
[12:59:18] <cmr> dbaupp: plugin content needs a name
[12:59:30] <cmr> "pluginname": pluginoutput
[12:59:46] <dbaupp> the name could/should be part of pluginoutput?
[12:59:53] <cmr> it could be I suppose
[13:00:02] <cmr> if it makes it easier to structure go for it
[13:00:04] <dbaupp> whatever, I'll leave it as is for the moment
[13:08:21] <dbaupp> cmr: any particular reason PluginResult returns @Json?
[13:08:28] <dbaupp> *is
[13:08:33] <dbaupp> (rather than just plain Json?)
[13:09:18] <cmr> dbaupp: lazy plugin output
[13:09:23] <cmr> probably doesn't matter
[13:09:41] <dbaupp> cmr: so if I were to remove the @, that'd be ok?
[13:09:48] <cmr> yup
[13:10:22] <dbaupp> cmr: oh! pluginresult returns a trait object
[13:10:37] <dbaupp> can I just make it return Json rather than @ToJson?
[13:10:39] <cmr> Yes
[13:10:39] * dbaupp misread
[13:10:48] * cmr also misread @ToJson when you wrote @Json
[13:12:17] <dbaupp>     let res = pm.run_plugins(&mut crate);
[13:12:18] <dbaupp>     let plugins_json = ~res.consume_iter().filter_map(|opt| opt).collect();
[13:12:18] <dbaupp>     json.insert(~"plugins", extra::json::Object(plugins_json));
[13:12:21] <dbaupp> <3 iterators
[13:12:44] <dbaupp> (is that too magical?)
[13:12:47] <cmr> (no)
[13:13:18] <dbaupp> ok
[13:13:25] <dbaupp> it works!
[13:13:36] <dbaupp> I guess I've entirely broken Seldaek's stuff :(
[13:13:42] <cmr> yeah that's fine
[13:13:44] <cmr> just bump the json schema
[13:14:12] <dbaupp> yup
[13:16:02] <dbaupp> it seems that using Encodable is slower (presumably the Rust -> str -> Json round trip)
[13:16:20] <cmr> I'm not really worried about effiency
[13:16:28] <dbaupp> yup, it's 9s -> 10s
[13:16:34] <cmr> we're dominated by rustc anyway
[13:16:34] <dbaupp> so still pretty fast
[13:16:41] <cmr> it used to be 3x faster
[13:16:42] <cmr> :(
[13:16:49] <dbaupp> what changed? :(
[13:17:02] <cmr> graydon merged typecheck with the after-typecheck-but-before-trans passes
[13:17:17] <cmr> which is fine, it yielded a huge API cleanup for librustc
[13:17:24] <cmr> just needs some fine tuning
[13:17:41] <dbaupp> yeah, I saw that
[13:19:51] <dbaupp> cmr: yuck:
[13:19:53] <dbaupp> "attrs":[["List","cfg",[["List","not",[["Word","test"]]]]]]
[13:20:14] <cmr> Yeah jedestep said he saw double-listing like that when he was playing with it
[13:21:01] <cmr> It's vdery lispy
[13:21:20] <dbaupp> Oh, I guess it's because enums get encoded like that
[13:21:30] <dbaupp> and each of those things can take multiple values
[13:21:55] <dbaupp> #[cfg(foo, not(bar, baz))] #[other_attr] would make each outer list have length > 1
[13:22:41] <cmr> Is it possible to add a custom ToJson implementation to improve encoding?
[13:23:43] <dbaupp> you can implement Encodable/Decodable by hand
[13:49:18] <cmr> dbaupp: I pushed the massive change to clean
[13:49:47] <dbaupp> cmr: and I just deleted jsonify :P
[13:49:53] <cmr> yay!
[13:50:35] <cmr> dbaupp: thanks for helping out :)
[13:50:43] <dbaupp> np :)
[13:50:55] <dbaupp> cmr: pushed it to master?
[13:50:58] <cmr> yes
[14:01:16] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[14:04:36] <dbaupp> cmr: https://github.com/cmr/rustdoc_ng/pull/28 r?
[14:06:48] <cmr> dbaupp: thanks <3
[14:08:47] <Seldaek> cmr: say whaat? :p it's not fine if dbaupp breaks everything :)
[14:08:47] <dbaupp> cmr: https://github.com/mozilla/rust/issues/8335
[14:09:12] <cmr> Seldaek: I also changed everything besides
[14:09:19] <cmr> Everything has a src
[14:09:21] <cmr> *source
[14:09:30] <Seldaek> the backlog is full of messages saying I'm gonna cry
[14:09:36] <Seldaek> but I didn't read it all yet
[14:09:44] <Seldaek> I'll check later:p
[14:09:55] <Seldaek> if I look now I'll not do my work stuff again..
[14:10:24] <cmr> I haven't updated the json anyway
[14:10:58] <dbaupp> cmr: https://github.com/cmr/rustdoc_ng/issues/29
[14:11:30] <jedestep> aww. dbaupp beat me to it. :(
[14:13:10] <jedestep> though coincidentally I was working on an encoder that would convert clean types to Json.
[14:13:51] * dbaupp apologises :(
[14:14:06] <dbaupp> jedestep: a extra::serialize-style encoder?
[14:14:10] <dbaupp> *an
[14:14:10] <jedestep> yeah
[14:14:29] <jedestep> that's why I hadn't submitted a PR earlier; I didn't like the idea of going to strings then to json
[14:14:36] <jedestep> so I started working on a new encoder
[14:15:33] <dbaupp> that'd still be useful though :)
[14:15:46] <dbaupp> (although: having it easily decodable would be nice.)
[14:16:38] <jedestep> as in having a decoder as well?
[14:16:55] <dbaupp> yeah, but it has to be a decoder that matches exactly what the encoder outputs
[14:17:00] <jedestep> right
[14:17:09] <jedestep> I think that's doable
[14:17:21] <dbaupp> of course :)
[14:19:58] <dbaupp> fwiw, I have a feeling that using the default {en,de}coder is much more maintainable long-term, as they don't get out-of-sync, etc.
[14:20:09] <cmr> pretty json is nice
[14:20:18] <dbaupp> that said, it's late, and I'm about to go to bed, so I'm probably missing something obvious. night all. :)
[14:22:00] <jedestep> the Encoder and Decoder traits should probably have defaults for most of the methods
[14:22:13] <Seldaek> dbaupp: still there?
[14:22:26] <Seldaek> just curious what the filter_map is good for in this: let plugins_json = ~res.consume_iter().filter_map(|opt| opt).collect();
[14:22:35] <Seldaek> it seems to be a noop?
[14:22:51] <Seldaek> or does that just eliminate empty entries or something?
[14:23:13] <dbaupp> magic!
[14:23:44] <dbaupp> Seldaek: nah, Iterator<X>.filter_map(&fn(X) -> Option<T>) -> Iterator<T>
[14:23:48] <dbaupp> (if that makes sense?)
[14:24:11] <Seldaek> ah so it unfolds the Options in the first iterator?
[14:24:17] <Seldaek> otherwise, I guess it didn't make sense to me :p
[14:24:21] <dbaupp> so res.consume_iter() is Iterator<Option<PluginResult>> and yeah, just unwraps the options
[14:24:33] <Seldaek> ok 
[14:24:55] <Seldaek> anyway, I read the backlog, and no worries, if the json looks nicer and is more consistent I'm happy
[14:25:25] <Seldaek> shouldn't be a major pain to upgrade to it
[14:25:54] <dbaupp> well, some bits are a *lot* worse
[14:26:11] <dbaupp> :(
[14:26:24] <jedestep> imports should be worse
[14:26:33] <cmr> attributes are way worse
[14:26:35] <jedestep> yeah
[14:26:41] <jedestep> any enum which contained a list of itself
[14:26:43] <jedestep> got awful
[14:26:46] <dbaupp> as are Primitives
[14:27:03] <jedestep> the default enum encoding is not very good
[14:27:11] <dbaupp> yup
[14:29:41] <cmr> It's nice to have jsonify gone
[14:29:45] <cmr> it was very soul-sucking
[15:01:14] *** Quits: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net) (Ping timeout)
[15:23:14] <jedestep> I don't suppose running the unit tests generated by rustpkg works?
[15:23:21] <cmr> nope
[15:23:26] <cmr> wait
[15:23:30] <cmr> what unit tests generated?
[15:23:40] <jedestep> in build/rustdoc_ng
[15:23:46] <jedestep> there are executables called rustdoc_ngtest and test
[15:23:53] <jedestep> both of them give me a link error when I run them
[15:24:05] <cmr> maybe you need `rustpkg test`?
[15:24:15] <jedestep> rustpkg test gives me a "not implemented yet" error :(
[15:24:36] <cmr> huh
[15:24:42] <cmr> I wonder where thsoe binaries came from O_o
[15:25:05] <jedestep> we have a small number of unit tests, I guess build makes anything marked with cfg test?
[15:25:20] <cmr> maybe, no idea
[16:26:23] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[16:54:51] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:00:51] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[17:19:59] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[17:49:00] *** Quits: n0v (n0v@moz-690FFF9D.org) (Connection reset by peer)
[17:49:35] *** Joins: n0v (n0v@moz-690FFF9D.org)
[18:45:38] <Seldaek> cmr: planning on updating jsons soon or are there more changes coming (I'd rather only refactor it all once if possible:)
[18:46:02] <cmr> Seldaek: Well, there are more changes coming, but they should be quite minor
[18:46:19] <cmr> I warn you, I haven't done doc-attr folding or comment stripping with the new code yet
[18:48:01] <Seldaek> eh just leave it
[18:48:06] <Seldaek> I should work on other stuff anyway :)
[18:48:13] <Seldaek> send it when it's ready
[18:48:16] <cmr> ok
[19:48:17] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[20:00:56] *** Quits: jga (asdf@B61ECB4E.35F814CC.B5524284.IP) (Ping timeout)
[20:17:19] *** Joins: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP)
[20:19:09] *** Joins: jga (asdf@40EF176C.EEFBC26B.B5524284.IP)
[20:25:00] *** Quits: jga (asdf@40EF176C.EEFBC26B.B5524284.IP) (Ping timeout)
[20:41:41] *** Joins: jga (asdf@F1D12213.30CD33A1.B5524284.IP)
[20:46:59] <cmr> Seldaek: here's an idea for the frontend: offer two views of a definition: sorted, and source-order
[20:47:19] <cmr> it's a pita to look for a function in http://seld.be/rustdoc/master/std/iterator/trait.IteratorUtil.html without them being sorted
[20:48:10] <Seldaek> does it make sense to ever show them unsorted? I suppose in some cases.. 
[20:48:18] <Seldaek> but I'd rather avoid such options
[20:48:38] <Seldaek> I'd argue the code should be fixed so the order makes sense though
[20:48:49] <cmr> well, sometimes you'd want to see them in source order, for whatever reason
[20:49:08] <cmr> Seldaek: what order would make sense for this?
[20:49:18] <cmr> They are ordered, sorta
[20:49:21] <Seldaek> I honestly don't know
[20:49:23] <cmr> sensically, that is
[20:49:30] <cmr> Iterator adaptors first, then things that don't return an iterator
[20:49:33] <Seldaek> it's just messy because there's too much crammed on there
[20:49:36] <cmr> yes
[20:49:44] <Seldaek> ctrl-f.. :)
[20:50:26] <Seldaek> I'm wondering if std::option::Option shouldn't be folded into just Option
[20:50:29] <cmr> http://seld.be/rustdoc/master/std/vec/trait.ImmutableVector.html
[20:50:33] <Seldaek> because it's so common and kind of part of the language
[20:50:34] <cmr> Equally as long
[20:50:44] <Seldaek> but it also breaks a convention so I'm not sure
[20:50:57] <cmr> Seldaek: yes, things in the prelude should probably not be fully-qualified
[20:51:05] <cmr> no easy way to do that though, at any level
[20:51:15] <Seldaek> for me it is
[20:51:28] <cmr> Without hardcoding the prelude, that is :p
[20:51:30] <Seldaek> as long as I know the path of what is in the prelude..
[20:51:50] <Seldaek> well if you export thereexports
[20:51:55] <Seldaek> it should be doable no?
[20:51:59] <cmr> it should be yeah
[20:52:02] <cmr> I do export reexports
[20:52:12] <Seldaek> I think it'd be good if you can see the prelude mod in the docs
[20:52:21] <Seldaek> so you clearly see what's present
[20:52:26] <cmr> http://seld.be/rustdoc/master/std/prelude/index.html
[20:52:27] <Seldaek> without digging in the source
[20:52:29] <cmr> :)
[20:52:47] <Seldaek> yeah I know it's there but I'm saying it so you don't remove it in case it has no_doc set :p
[20:52:58] <Seldaek> I think it should be force_doc'd :P
[22:06:25] <cmr> Seldaek: the json just keeps getting worse and worse... so sorry :(
[22:06:44] <cmr> But, the rustdoc code gets cleaner and cleaner
[22:07:00] *** Quits: jedestep (jedestep@34641662.FB4DE631.66C78B76.IP) (Ping timeout)
[22:07:02] <Seldaek> I think that's the wrong way :)
[22:07:11] <Seldaek> and I don't say that only because I have to deal with it
[22:07:19] <cmr> I agree
[22:07:21] <Seldaek> but the json is the API, API is always more important
[22:07:29] <cmr> I think I will be able to fix it to be less ugly
[22:07:37] <cmr> Well, the structs it exports are also the API
[22:07:51] <cmr> It's just the default implementation that kinds sucks a lot
[22:08:03] <cmr> (default implementation of encode for json, that is)
[22:08:23] <cmr> hopefully dbaupp will be around to explain how this pile of magic works
[22:15:17] <Seldaek> ok :)
[22:44:28] *** Joins: dbaupp (Thunderbir@moz-712A1135.lns20.syd6.internode.on.net)

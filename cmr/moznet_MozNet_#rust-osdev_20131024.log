[00:28:50] <pcmattman> strcat: PR updated with a commit for bare functions
[00:29:03] <strcat> pcmattman: can I make you do statics too? :)
[00:29:12] * pcmattman should've seen that coming :)
[00:29:27] <strcat> I'll r+ it though
[00:29:29] <strcat> but it'd be nice ;p
[00:29:35] * strcat will look in a bit
[00:29:37] <pcmattman> but yes, statics should be trivial
[00:29:46] <strcat> pcmattman: yeah there's another building_library check for them
[00:29:57] <strcat> it was my half solution before acrichto fixed the privacy stuff
[00:30:13] <strcat> it used to be that *all* things were external. and it sucked :)
[00:33:04] * pcmattman kicks off another build, gogo librustc
[00:33:12] <pcmattman> (sigh)
[01:17:21] *** Joins: canhtak (jeremy@moz-ABE51D61.wl.t.ulaval.ca)
[01:25:39] *** Joins: maikeru (michael@moz-CD281E3A.compute-1.amazonaws.com)
[02:16:29] *** Quits: zz_kimundi (kimundi@moz-DBB29B3E.dip0.t-ipconnect.de) (Ping timeout)
[02:20:22] *** Joins: zz_kimundi (kimundi@moz-C410002E.dip0.t-ipconnect.de)
[02:20:24] *** zz_kimundi is now known as kimundi
[03:03:36] *** Joins: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net)
[03:06:18] <eddyb9> o_O, we get the externals?
[03:06:27] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Ping timeout)
[03:19:27] <eddyb9> strcat: oh, you removed libc as a module? btw, you're using free instead of free_raw in vec, that looks like a mistake
[03:19:42] <strcat> eddyb9: they're the same
[03:19:49] <eddyb9> (I would make the libc functions priv, too)
[03:19:50] <strcat> I got rid of free_raw
[03:19:56] <eddyb9> oh....
[03:20:05] <strcat> eddyb9: I just want heap.rs to be the libc allocator for now
[03:20:16] <strcat> the wrappers are only there to abort on OOM and tack lang items onto
[03:20:34] <strcat> can't tack them onto extern fns
[03:20:42] <strcat> (that's why free_raw existed)
[03:21:19] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[03:22:22] <eddyb9> strcat: you're (unintentionally) breaking my PR, piece by piece :P
[03:27:40] <eddyb9> I might just use my rust-core fork in rustic, as it doesn't seem I can get the two PRs into your master
[03:29:41] *** Joins: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP)
[03:40:52] <pcmattman> eddyb/eddyb9: not yet
[03:50:03] <eddyb9> I should use eddyb6 and eddyb9, just to see people use eddyb6/9
[03:50:20] <eddyb9> and then I can get mad at them or laugh
[03:54:47] <eddyb> hehe, http://www.reddit.com/r/rust/comments/1p2d5o/is_there_a_way_to_escape_the_rust_runtime/ rust-core and osdev get mentioned together
[04:05:34] *** Quits: jeffdb_ (jeff@moz-D13B6004.hsd1.ca.comcast.net) (Ping timeout)
[04:13:24] <eddyb> strcat: how on earth does this work? https://github.com/thestinger/rust-core/blob/master/core/heap.rs#L27-L29
[04:13:42] <strcat> eddyb: rust mangles symbols
[04:13:54] <strcat> without #[no_mangle] on them
[04:14:03] <eddyb> strcat: I mean the part where you didn't put detail::
[04:14:13] <eddyb> and it looks like infinite recursion
[04:14:24] <strcat> oh that's wrong.
[04:16:10] <strcat> fixed
[04:17:24] <eddyb> I initially thought you were exposing the libc free function directly, without a wrapper, that's why I double-checked
[04:18:15] <pcmattman> strcat: any word on that pr, by chance? all good if you're busy
[04:22:27] *** Quits: canhtak (jeremy@moz-ABE51D61.wl.t.ulaval.ca) (Quit: canhtak)
[05:06:12] *** Quits: eddyb9 (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[05:10:02] *** Joins: eddyb9 (eddy@549891BC.600764B.4A6B528C.IP)
[05:17:14] <strcat> pcmattman: r+'ed
[05:18:34] <eddyb9> pcmattman: did you try building rustic with this? what's the difference between --lib and your patch?
[05:18:53] <strcat> eddyb9: I think I know how I want to do the allocator thing
[05:19:12] <strcat> I like what C++11 does but it's not safe due to swap
[05:19:18] <strcat> hm
[05:19:24] <strcat> well I guess they probably swap the allocator too
[05:19:33] <strcat> we'll see
[05:19:38] <eddyb9> pcmattman: if it tries to produce a standalone version of cpu::gdt::load, then it's not good enough :(
[05:20:24] <pcmattman> eddyb9: I have not built rustic with it
[05:20:56] <pcmattman> it takes the results from the privacy/visibility pass (phase2) and uses them in trans (phase3) to decide whether the function should have external linkage
[05:21:06] <eddyb9> strcat: would it work with a zero-sized allocator, that implements trait functions on a static allocator?
[05:21:08] <pcmattman> so it won't produce a standalone version of cpu::gdt::load, because cpu::gdt::load is private
[05:21:12] <strcat> eddyb9: yes
[05:21:19] <eddyb9> pcmattman: it's not, afaik
[05:21:21] <strcat> something like
[05:21:41] <pcmattman> eddyb9: gdt is not pub mod gdt;
[05:21:44] <strcat> struct A; impl Allocator for A { fn new() -> A { A } ... }
[05:21:51] <strcat> and it will store an allocator in every container
[05:22:01] <strcat> rusti: struct Foo; std::sys::size_of::<Foo>()
[05:22:02] -rusti- pastebinned 7 lines of output: http://sprunge.us/HNDE
[05:22:09] <strcat> rusti: struct Foo; std::mem::size_of::<Foo>()
[05:22:09] -rusti- 0u
[05:22:23] <eddyb9> pcmattman: hmm, okay. so it's just slightly better than --lib. oh the compromise :P
[05:22:27] <strcat> no overhead, unlike C++ where every value has to have a unique address
[05:22:46] <eddyb9> hmm?
[05:23:12] <strcat> in C++ an empty struct has a non-zero size
[05:23:29] <eddyb9> aah. ok
[05:23:52] <eddyb9> what's A above? the allocator?
[05:24:25] <eddyb9> nvm, I got it. kinda like my design, I didn't see it at first :P
[05:24:54] <pcmattman> also cheers strcat, I think the outcome is a lot better for having discussed it and poked into the corners :)
[05:25:15] <eddyb9> strcat: what's the "allocator per container" going to achieve?
[05:25:43] <eddyb9> pcmattman: at least my patch wasn't painful enough to write, I would be sadder then :))
[05:27:36] <strcat> eddyb9: for example, so you can allocate an arena for a specific tree
[05:27:58] <strcat> and it will still be type safe since you won't need to use globals associated with an allocator type
[05:28:03] <eddyb9> strcat: oooh, isolating pathological cases
[05:28:21] <eddyb9> using plain mmap for large allocation sizes, etc :)
[05:29:08] <strcat> I think I will just make the container own the allocator to start things off... you could share an allocator between a set of containers with RcMut I guess
[05:29:40] <strcat> an empty struct will just be copied
[05:29:52] <eddyb9> strcat: right now you can embed an Allocator in any struct, and LibCAllocator is zero-sized, I can update my PR if you want :D
[05:31:32] <eddyb9> default "values" for type parameters might be required to not bloat the containers
[05:32:44] <strcat> yeah I'm thinking about what it's going to do at --opt-level=0/--opt-level=1
[05:34:36] <strcat> pcmattman: I think you might have to xfail-fast the cross-crate tests but we'll wait and see
[05:37:21] <eddyb9> what's with the opt-level
[05:37:21] <strcat> check-fast is used on windows because windows is slow, and it merges all the tests not marked xfail-fast into one giant file
[05:37:33] <eddyb9> oh hehe
[05:37:47] <pcmattman> strcat: oh, that's exciting
[05:37:49] <strcat> windows is too slow to spawn a bunch of rustc processes
[05:38:19] <strcat> (you'll notice that the windows bots finish quite quickly... cause they run 10% of the tests ;p)
[05:38:21] <eddyb9> pcmattman: I had a cool test, where I was using inline assembly to test the attribute((used)) main use case
[05:39:11] <pcmattman> those tests took a while to figure out :) fitting into the existing framework and all
[05:39:37] <pcmattman> but definitely worth it
[05:39:45] <eddyb9> pcmattman: you might want to add/check with that test, since it represents the only problem that can't be solved by moving everything to rust
[05:40:29] <pcmattman> what, the asm!("call <symbolname>") thing?
[05:40:37] <eddyb9> yupp
[05:40:49] <eddyb9> it's fine with me if it runs
[05:41:02] <strcat> I don't think we have per-arch run-pass tests
[05:41:12] <pcmattman> I'm really, really curious as to why you'd need the raw name of a symbol in inline assembly
[05:41:22] <pcmattman> you have inline assembly constraints for that, surely?
[05:41:32] <eddyb9> strcat: it works on x86/x64 and arm
[05:41:39] <eddyb9> pcmattman: the llvm mem* problem
[05:41:45] <pcmattman> asm!("call *%0" :: "m" (xyz));
[05:41:50] <strcat> eddyb9: that will be fixed
[05:41:58] <strcat> a fully public path will be exposed
[05:42:07] <strcat> eddyb9: I tested what clang does
[05:42:13] <eddyb9> strcat: just wanted to make sure :P
[05:42:34] <strcat> you can have a public memcpy, and LLVM will use it, but with -flto, clang will still strip it away
[05:42:37] <eddyb9> like, I wrote that test, might as well test with it :))
[05:44:00] <pcmattman> strcat: ... why would it strip it?
[05:44:08] <eddyb9> hmm, there's a nice aboos that can be done with those intrinsics
[05:44:13] <pcmattman> or does it do the intrinsics later in the process?
[05:45:21] <strcat> pcmattman: it manages to find memcpy and not screw up the lowering with LTO
[05:45:25] * strcat shrugs
[05:45:29] <strcat> without having to expose them
[05:46:20] <pcmattman> sorry wait, clang strips it away with or without -flto
[05:46:21] *** Quits: eddyb9 (eddy@549891BC.600764B.4A6B528C.IP) (Ping timeout)
[05:46:26] <strcat> with -flto
[05:46:36] <pcmattman> hm, okay
[05:46:54] <strcat> it's fine though it still works
[05:47:36] <pcmattman> oh cool
[05:47:43] *** Joins: eddyb9 (eddy@5E8D336C.600764B.4A6B528C.IP)
[05:48:19] <eddyb9> I might have something shorting inside my phone
[05:48:39] <eddyb9> from when I had to open it up to replace a ripped flex connector :/
[05:49:08] <eddyb9> as I was saying, you can use the llvm memcpy intrinsic inside the memcpy function that the intrinsic uses
[05:49:27] <eddyb9> to copy blocks of 128 or 256 bits
[05:49:59] <eddyb9> I'm pretty sure it gets optimized to SSE with the right flags
[05:50:17] <strcat> if you write a loop, it can just vectorize it
[05:50:21] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)
[05:50:35] <pcmattman> that could be nice to disable for freestanding targets (eg, kernel)
[05:50:50] <eddyb9> strcat: the output looked bad for a byte-based loop
[05:51:00] <pcmattman> eddyb9: how'd it look bad?
[05:51:06] <eddyb9> maybe if I move sizeof(uint) at once...
[05:51:06] <strcat> -Z no-vectorize-loops -Z no-vectorize-slp
[05:51:16] <strcat> eddyb9: hm?
[05:51:19] <eddyb9> pcmattman: it wasn't optimized to larger moves, IIRC
[05:51:24] <pcmattman> eddyb9: are you sure?
[05:51:34] <eddyb9> I have to double-check
[05:52:13] <pcmattman> I'd be surprised if a byte-loop memcpy wasn't optimised well to the microarch, it just mightn't look that fast
[05:52:28] <strcat> rep movsb is very fast on modern CPUs
[05:52:50] <strcat> intel actually has instructions for stuff like memcpy ;p
[05:52:59] <pcmattman> rep movsl is more or less equal to rep movsb on modern CPUs as well, IIRC (less so in emulators/virtualisation)
[05:53:30] <eddyb9> well, some llvm flag with native in it broke rustic because it generated SSE instructions, I think
[05:53:42] <pcmattman> -march=native?
[05:53:57] <strcat> eddyb9: it will generate SSE2 by default for x86_64
[05:54:03] <eddyb9> that one, for some reason I thought it wasn't arch
[05:54:05] <pcmattman> mtune, mcpu
[05:54:07] <strcat> and use it for floating point math
[05:54:18] <eddyb9> strcat: x86_32
[05:54:40] <pcmattman> it'll still end up using SSE with 'native' because it's targeting your current CPU
[05:54:48] <pcmattman> on 32 or 64
[05:54:50] <eddyb9> but native means it will use everything my cpu can do (like SSE4.2 in 32bit)
[05:54:58] <eddyb9> yeah
[05:55:39] <eddyb9> pcmattman: remember the many nop's in my screenshots? and how they turned into a single arcane instruction?
[05:55:51] <eddyb9> that's -march=native at work :P
[05:56:08] <pcmattman> yes, that's it aligning to a cache line
[05:56:27] <eddyb9> well, yeah, but it's more compact with newer instructions
[05:56:43] *** kimundi is now known as zz_kimundi
[05:56:46] <pcmattman> if it fits into one cache line, that's nice :)
[05:57:38] <eddyb9> same length, but one instruction instead of 10 sepparate nops
[05:58:05] <pcmattman> oh, so more compact disassembly
[05:58:15] <strcat> eddyb9: http://ix.io/8Jf
[05:58:51] <strcat> eddyb9: becomes http://ix.io/8Jg
[05:58:55] <eddyb9> so what's with the caches? the alignment only happens as a kind of prelude to functions using atomic instructions, but it also is kept when inling :/
[05:58:58] <strcat> with -O --target-cpu core-avx2
[05:59:06] <eddyb9> pcmattman: yeah, and probably less cycles :P
[05:59:11] <strcat> and then it will become a bunch of AVX instructions ;p
[05:59:17] <eddyb9> (you've said so yourself)
[05:59:19] <pcmattman> strcat: mmmmm AVX, so tasty
[05:59:38] <pcmattman> eddyb9: are there branches near the nops?
[06:00:12] <pcmattman> could also be trying to put fluff into the pipeline and avoid kicking off a data prefetch from a branch prediction (but that's a massive guess)
[06:00:16] <eddyb9> intel have gone the way of the microsoft business model. all these different sockets, just for money :(
[06:00:35] <eddyb9> pcmattman: there are branches, but not immediately after
[06:00:40] * pcmattman does enjoy some 256-bit data moves with his morning coffee
[06:00:45] <pcmattman> eddyb9: I mean, immediately before the nops
[06:00:45] <strcat> you'll notice it output an alignment check thing
[06:00:53] <strcat> hm
[06:01:07] <eddyb9> the aligned instruction is a mov from mem to reg
[06:01:19] <eddyb9> then a few instructions afterwards comes an atomic
[06:01:23] <eddyb9> pcmattman: not really
[06:01:39] <eddyb9> hehe, .offset is cute
[06:02:30] <eddyb9> you can grep history for imgur
[06:02:34] <strcat> there's a loop-idiom pass that's supposed to detect something like this as a memcpy
[06:02:39] <strcat> and turn it into the intrinsic
[06:02:41] <strcat> failed here ;p
[06:02:59] <strcat> so loop-vectorize caught it
[06:03:08] <pcmattman> strcat: yes, on GCC it caused breakage as it broke a few libcs out there :)
[06:03:20] <eddyb9> http://i.imgur.com/1d3bA9O.png
[06:03:35] <pcmattman> people were mad that they had to disable a feature for that particular file, but the outcome for so much other code is so much better
[06:04:22] <eddyb9> pcmattman: ooh, there's branches to the aligned code
[06:04:50] <pcmattman> yeah, I was literally about to say something about those branches
[06:05:11] <eddyb9> weird, using xadd instead of a cmpxchg loop removes the second alignment
[06:05:27] <eddyb9> so it maybe "flushes" something before trying the alignment again?
[06:05:35] <eddyb9> err, atomic
[06:06:06] <eddyb9> pcmattman: don't you love the constants in that code :D?
[06:06:47] <eddyb9> wait, something smells of bug
[06:06:59] <eddyb9> pcmattman: why is it adjusting esp? it doesn't touch the stack
[06:08:20] <eddyb9> (hehe, you can inline one of these allocators in cpu::gdt and get away with no stack usage before setting up the TLS. or even allocate the stack on the heap. LOL)
[06:10:36] <eddyb9> (btw, that function allocates exactly one page. I don't know there's code needing more than 2k. hmm)
[06:11:01] <pcmattman> code in Pedigree using SLAM definitely allocates > 4K
[06:11:31] <pcmattman> the largest SLAM allocation that I am consciously aware of is a VGA backbuffer of ~ 3-4 MB
[06:11:55] <eddyb9> this is the Rust version, only 3 caches are used
[06:12:27] <eddyb9> the other two produce larger code because they have multiple objects per slab to insert in their partial list
[06:13:30] <eddyb9> more than 2044 bytes would end up in the 4k cache, which is the first one with one object per slab
[06:13:37] <eddyb9> well, let me look for calls to it
[06:15:20] *** Quits: eddyb (eddy@3C6E2DBB.FFB4E060.A5830293.IP) (Ping timeout)
[06:15:51] <eddyb9> oh dear, did it panic again?
[06:16:07] <eddyb9> is sshd broken or something?
[06:16:12] <pcmattman> rusti: type x = [int, ..256]; std::mem::size_of::<x>()
[06:16:13] -rusti- 2048u
[06:16:39] <pcmattman> okay, that is so much nicer than the magic numbers I have in Rustic's malloc() calls right now.
[06:16:47] <eddyb9> LOL
[06:16:51] <strcat> rusti: std::mem::size_of::<[(), ..10000000]>()
[06:16:51] <pcmattman> rusti: struct X {}; type x = [X, ..256]; std::mem::size_of::<x>()
[06:16:52] -rusti- 0u
[06:16:52] -rusti- pastebinned 6 lines of output: http://sprunge.us/EBIQ
[06:17:16] <strcat> rusti: struct Foo; std::mem::size_of::<[Foo, ..10000000]>()
[06:17:17] -rusti- 0u
[06:17:20] <strcat> ;p
[06:17:22] <eddyb9> pcmattman: you can even allocate from heap with ~
[06:17:33] <pcmattman> oh yeah
[06:17:48] <eddyb9> I planned to rewrite those parts of rustic after SlamAllocator got in
[06:17:48] <pcmattman> rusti: type x = ~[int, ..256]; std::mem::size_of::<x>()
[06:17:49] -rusti- 8u
[06:17:55] <pcmattman> hey cool, 64-bit
[06:18:19] <eddyb9> but it's blocked on my two rust-core PRs, which are blocked on other things
[06:18:25] <pcmattman> rusti: type x = ~[int, ..256]; std::mem::size_of::<*x>()
[06:18:26] -rusti- 8u
[06:18:31] <eddyb9> like strcat's desire to fix atomics
[06:18:39] <strcat> pcmattman: probably don't want to use ~[T], performance-wise
[06:18:41] <pcmattman> now I can't find out how big the actual list is in bytes
[06:18:46] <pcmattman> so that doesn't work for me
[06:18:49] <pcmattman> strcat: good to know
[06:18:51] <eddyb9> pcmattman: that's a pointer to an uniq ptr
[06:19:02] <strcat> pcmattman: ~[T] is different than ~[T, ..n]
[06:19:12] <strcat> well
[06:19:19] <strcat> what you have there is just a unique ptr + fixed-size array
[06:19:33] <strcat> anyway ~[T] (dynamic array) is a really slow implementation of one ;p
[06:19:39] <pcmattman> ah
[06:19:40] * strcat misread the code
[06:19:55] <eddyb9> ~T is also fine, with a static array inside T if you need it
[06:20:07] <eddyb9> s/static/fixed-size/
[06:20:15] <strcat> yeah, ~T is great
[06:20:24] <strcat> pcmattman: https://github.com/mozilla/rust/issues/8981 that's vs. the simple implementation that's in core::vec
[06:20:33] <strcat> poor default vector is so slow :(
[06:20:40] <pcmattman> right
[06:20:54] * strcat really wants to reimplement it
[06:21:00] <pcmattman> it's not possible to get the members of a vector in contiguous memory, right?
[06:21:10] <strcat> pcmattman: hm?
[06:21:10] <eddyb9> huh?
[06:21:21] <eddyb9> a vector is not a linked list :P
[06:21:24] <strcat> ~[T] and Vec are both contiguous
[06:21:25] <pcmattman> let me rewind
[06:21:29] <pcmattman> how is a vector implemented :)
[06:21:41] <eddyb9> like in C++
[06:21:52] <strcat> ~[T] is *{ length, capacity, data[] }
[06:21:56] <strcat> flexible-size struct basically
[06:22:05] <strcat> Vec is { length, capacity, data* }, like most C++ implementations
[06:22:26] <pcmattman> okay, awesome
[06:22:30] <eddyb9> that's the performance problem strcat was talking about
[06:23:11] <eddyb9> I should help him fix it in rustc (to be like Vec, which is better), I like the compact syntax :P
[06:23:25] <strcat> first people need to agree it's a good idea
[06:23:25] <eddyb9> but I'm so efficient I managed to get nothing done this week
[06:23:31] <strcat> and also, managed pointers are really weird
[06:23:39] <strcat> when they're inside ~T and ~[T], they change the representation/handling
[06:23:58] <strcat> and the old vector representation probably needs to stay for ~[T] where T is managed :(
[06:24:03] <pcmattman> hey cool, run-pass/external-linkage.rs failed, that's... a pain. mustn't have been testing what I thought I was earlier today.
[06:24:07] <strcat> otherwise it won't have a pointer to root
[06:24:25] <eddyb9> strcat: dammit :(
[06:24:27] <pcmattman> strcat: hmm
[06:24:46] <pcmattman> let rust-core have fast vectors as a POC :)
[06:24:52] <strcat> ~T vs ~T for a managed T is already different
[06:24:54] <eddyb9> screw managed. make @ a lang item container (Rc for rust-core)
[06:24:59] <strcat> so it's not a big deal
[06:25:17] <strcat> yeah rust-core doesn't need to worry about managed stuff
[06:25:32] <strcat> I like Rc a lot in rust
[06:25:43] *** Joins: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP)
[06:25:46] <strcat> for an immutable one, the only overhead over ~T is a 1-word count
[06:25:54] <eddyb9> waaaait, can we use unicode?
[06:26:08] <strcat> as in strings? I didn't implement any of that
[06:26:09] <eddyb9> to minimize code bloat with Rc
[06:26:34] <strcat> then no one will be able to type it ;p
[06:26:43] <eddyb9> copy-paste :D
[06:26:46] <strcat> need to implement a Pointer trait so it can have deref syntax
[06:27:36] <eddyb9> alias Fn to a lowecase lambda :P
[06:27:42] <eddyb9> *lowercase
[06:27:52] <eddyb9> (when it gets implemented)
[06:28:59] <pcmattman> isn't lambda achieved via closures?
[06:29:13] <eddyb9> Fn will be a generic function trait
[06:29:17] <strcat> &fn is a ptr to an env and a function ptr
[06:29:29] *** zz_kimundi is now known as kimundi
[06:29:32] <eddyb9> so you'll probably be able to create your own callable objects :P
[06:29:41] <strcat> lambdas are inferred to be either a stack closure (they become &fn atm) or ~fn
[06:30:34] <strcat> anyway one of the problems is that stack closures don't exist in the type system so you can't move them around
[06:30:51] <strcat> if they have a capture, they can't currently outlive that stack frame
[06:33:04] <strcat> hm
[06:33:24] <strcat> need to think of a good way to do this without making Vec really painful to use :\
[06:33:56] <eddyb9> strcat: you didn't mention the Fn trait I was talking about :(
[06:34:05] <eddyb9> and what's with Vec? the allocator?
[06:34:08] <strcat> yeah
[06:34:14] <strcat> I think I know what to do though
[06:34:21] <eddyb9> you'll end up redoing what I did on your own, dammit
[06:34:31] <strcat> a bit different ;p
[06:34:42] <eddyb9> I'll have to burn my PR and adapt the rustic one :(
[06:37:22] <strcat> I broke rustc
[06:37:33] <eddyb9> I hate it when this happens, especially since I was waiting on those PRs
[06:37:37] <eddyb9> strcat: karma
[06:37:39] <strcat> task '<unnamed>' failed at 'vtables missing where they are needed', /home/strcat/projects/rust/src/libstd/option.rs:317
[06:37:52] <strcat> compiler bug..
[06:42:45] <strcat> it refuses to let me add an Allocator bound on the Vec allocator type param :(
[06:45:41] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[06:46:20] <strcat> ugh
[06:46:21] <strcat> it's a bug in Drop
[06:46:56] <strcat> maybe..
[06:51:05] <strcat> eddyb9: it can't work yet
[06:51:12] <strcat> type bounds on destructors don't seem to work
[06:51:50] <strcat> need to fix the compiler bug
[07:33:31] *** Joins: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk)
[07:37:51] <eddyb9> I have time to recycle my PR :P
[07:39:24] * eddyb9 now has to find the backdoor in strcat's brain. and where he put the new allocator
[07:43:06] *** Quits: dbaupp (Thunderbir@moz-CB11E887.lns20.syd6.internode.on.net) (Ping timeout)
[07:43:50] <eddyb9> first quantum effect physics experiment. inb4 lame
[07:44:30] <strcat> eddyb9: it can't be implemented yet
[07:44:41] <strcat> generic destructors are unable to call methods ;\
[07:44:57] <strcat> eddyb9: https://github.com/mozilla/rust/issues/4252
[07:44:58] <eddyb9> strcat: well... what about the Allocator itself?
[07:45:35] <strcat> pushed that
[07:46:09] <strcat> er sec
[07:46:12] <strcat> forgot to make Heap pub
[07:47:06] *** Joins: dbaupp (Thunderbir@moz-EA27E3E6.lns20.syd6.internode.on.net)
[07:50:01] <strcat> eddyb9: http://ix.io/8Ji/diff that's how I want to do it
[07:50:03] <strcat> hits that ICE
[07:50:09] <strcat> I'll try fixing rustc tommorow
[07:53:52] * strcat wishes borrowck wasn't still dumb ;p
[07:53:57] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: sleep)
[07:55:04] <eddyb9> ffs, the "experiment" is just some stupid animation with LEDs simulating the photoelectric effect
[07:56:04] *** Quits: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP) (Input/output error)
[08:07:03] * pcmattman fixes broken test
[08:07:13] <pcmattman> (must've used a stale aux file)
[08:11:55] *** kimundi is now known as zz_kimundi
[08:16:50] * eddyb9 looks at strcat's diff just to not get mad at the physics teacher
[08:17:08] <eddyb9> at least I was right that I had nothing to lose today
[08:17:10] *** zz_kimundi is now known as kimundi
[08:19:15] *** Quits: Thiez (thiez@moz-BF669398.student.utwente.nl) (Ping timeout)
[08:20:26] <eddyb9> there's no clean way to map segmentation to wiREd's "IR"
[08:21:34] <eddyb9> you need [(u32(DS) << 4) + u32(ptr)] for [ds:ptr] :(
[08:22:20] <eddyb9> if the selector didn't overlap the address space, it could be implemented as an address space
[08:24:44] <eddyb9> it will work for emulation, but I hope nobody will need to decompile real mode code
[08:26:39] *** Joins: matt (matt@15287214.D6BAED44.659DEE14.IP)
[08:27:12] *** Quits: matt (matt@15287214.D6BAED44.659DEE14.IP) (Quit: irc2go)
[08:29:40] <eddyb9> wait, he closed my PR?
[08:31:56] *** Joins: Thiez (thiez@moz-BF669398.student.utwente.nl)
[08:33:30] <eddyb9> he's not going to make it work without defaults for type parameters
[08:36:17] <eddyb9> hah, his Allocator trait isn't as smart as mine. what he did equivalates to removing the default realloc method, the size bounds method, the LinearAllocator and configurability
[08:37:19] <dbaupp> he did say "simple" didn't he?
[08:38:16] <eddyb9> dbaupp: my extra stuff wasn't getting used with --cfg libc
[08:39:19] <eddyb9> also, it's harder now to put it behind a cfg, as he broke compartimentation
[08:40:14] <eddyb9> he has a module, a struct, an impl and probably more that would need #[cfg(libc)]
[08:40:48] <eddyb9> dbaupp: he's making it more complicated for me :(
[08:41:54] <eddyb9> dbaupp: are defaults for type params even planned?
[08:42:17] <pcmattman> to be fair, something that exists but is behind a --cfg still exists, and results in not simple code
[08:43:02] <eddyb9> where?
[08:43:30] <pcmattman> I was referring to your response to dbaupp's mention of 'simple'
[08:44:01] <dbaupp> eddyb9: you can do something like `type Vec<T> = VecAlloc<T, DefaultAllocator>;` but that has different behaviour in some instances
[08:44:07] <eddyb9> the default realloc implementation made it trivial for me to enable its use in SlamAllocator and even (although useless there) LinearAllocator
[08:44:08] <dbaupp> (specifically, Vec::new() doesn't work.)
[08:44:25] <eddyb9> dbaupp: oh, that's close...
[08:44:53] <dbaupp> eddyb9: I imagine that he might iterate on the design of that trait a few times...
[08:46:55] <eddyb9> it's sad because it delays the adoption of SlamAllocator in pedigree even further
[08:47:10] <eddyb9> err, rustic
[08:47:42] <eddyb9> maybe I need to sleep today. it's not like I could get anything done :(
[08:48:02] <eddyb9> it seems that tomorrow is my bday and I look like crap
[09:13:02] <eddyb9> hmmmm
[09:13:37] <eddyb9> looking at wiREd code, LS: F.C.not().or(F.Z)....
[09:13:58] <eddyb9> everything using the type system would work better in Rust
[09:15:34] <eddyb9> with Rust enums and/or trait objects, I can have the entire "IR" in Rust
[09:16:26] * eddyb9 is so tempted to try and port the analyzer to Rust and test performance
[09:17:26] <eddyb9> but wiREd is a misnomer if I reimplement everything. and without something like servo for GUI... I don't know
[09:17:58] <eddyb9> the neat thing about ES6 was dynamic, fancy "plugins"
[09:19:22] <eddyb9> and a rather compact syntax, minus the lack for operator overloading
[09:22:15] <eddyb9> well, I can still do rudimentary analysis and expose a C-like DAG/AST to ES6 code running in servo
[09:23:09] <eddyb9> (yeah, it's sad, but my JS code was either leaking memory or actually needing more than was obvious :(()
[09:25:03] <eddyb9> using types in Rust is kinda like a dirty pleasure
[09:25:39] *** kimundi is now known as zz_kimundi
[09:37:22] <eddyb9> rusti: fn<T> foobar(x: &T) {}
[09:37:23] -rusti- pastebinned 6 lines of output: http://sprunge.us/FECD
[09:38:14] <eddyb9> rusti: fn foobar<T>(x: &T) {x.baz;}
[09:38:15] -rusti- pastebinned 7 lines of output: http://sprunge.us/ICLb
[09:38:41] <eddyb9> rusti: fn foobar<T>(x: T) {x.baz;}
[09:38:42] -rusti- pastebinned 7 lines of output: http://sprunge.us/NAXj
[09:39:15] <eddyb9> that's weird, can you even get that to work?
[10:02:33] *** zz_kimundi is now known as kimundi
[10:31:41] *** Quits: eddyb9 (eddy@5E8D336C.600764B.4A6B528C.IP) (Ping timeout)
[11:56:30] *** kimundi is now known as zz_kimundi
[12:22:49] *** Quits: jeffdb (jeffbelg@9782ABE9.E8A0C4C2.E25FE9C.IP) (Ping timeout)
[12:24:14] *** Joins: jeffdb (jeffbelg@9782ABE9.E8A0C4C2.E25FE9C.IP)
[12:25:01] *** zz_kimundi is now known as kimundi
[12:49:19] *** Joins: canhtak (jeremy@moz-ABE51D61.wl.t.ulaval.ca)
[12:56:52] *** Joins: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net)
[13:36:00] *** Quits: jeffdb (jeffbelg@9782ABE9.E8A0C4C2.E25FE9C.IP) (Ping timeout)
[13:36:34] *** Joins: jeffdb (jeffbelg@9782ABE9.E8A0C4C2.E25FE9C.IP)
[13:52:07] *** Quits: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net) (Ping timeout)
[14:04:31] *** kimundi is now known as zz_kimundi
[14:37:18] *** zz_kimundi is now known as kimundi
[15:12:06] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:12:22] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:20:03] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[15:20:23] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[15:50:29] <Leo`> mhhhh
[15:50:45] <Leo`> is there a way to access the next value inside an iter() ?
[15:51:06] <Leo`> I mean, inside for i in iter() {
[15:51:23] <Leo`> mh, no
[15:51:27] <Leo`> for i in iter {
[15:51:35] <Leo`> let a = iter.next();
[15:51:54] <Leo`> to "skip" an iteration, and getting the value at the same time
[15:52:06] <cmr> Leo`: not in a for loop no. you need to manually expand to the while loop form, iirc.
[15:52:21] <Leo`> writing this does not work, because one can't borrow the iter 2 times
[15:52:25] <Leo`> cmr: ermf
[15:52:45] <Leo`> this is sad :/
[15:58:11] <cmr> there's an open bug about it somewhere
[15:58:18] <cmr> involves teaching rustc that for loops exist
[15:58:28] <cmr> (right now they're purely a syntax feature)
[15:58:50] <Leo`> mh yep
[15:59:15] <Leo`> but Rustc is able to give to break and continue an intuitive meaning inside for loops, right ?
[16:00:25] <cmr> they are literally while loops. break and continue mean the samething in for as in while
[16:01:18] <Leo`> mh you mean for loops are expanded into while ?
[16:01:28] <Leo`> I had read something quite long ago 
[16:01:32] <Leo`> about do and for loops
[16:01:43] <Leo`> with closures
[16:01:48] <Leo`> this has changed obviously
[16:01:58] <cmr> yes, that's the old for loop that used internal iterators.
[16:02:09] <cmr> run rustc --pretty=expanded on some code usinga for loop to see what it turns into
[16:16:15] *** Joins: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP)
[16:44:04] <eddyb> great, I ended up reverse engineering a DDS board with a VB control software
[16:45:04] <eddyb> (wireshark for serial via USB made it obvious, don't worry about me shit-diving in VB)
[16:45:24] <eddyb> but I wanted to fix up my PR(s) and now I don't have too much time left :/
[16:45:39] <Leo`> hey rustpkg is cool
[16:45:48] <Leo`> https://github.com/LeoTestard/coreutils/commit/3e2516742caf2be5db9c4cd4b05550d963904b1b (cc Seldaek :p)
[16:56:25] <Seldaek> Leo`: you should rebase, KokaKiwi changed everything in the makefile :)
[16:57:25] <Seldaek> and AFAIK rustpkg can also deal with src/cat/cat.rs which is nicer than having all of them called main.rs IMO if you have multiple files open at once :)
[16:57:32] <Seldaek> but other than that +1 
[16:57:54] <cmr> Seldaek: it can't.
[16:58:07] <cmr> not without a custom pkg.rs
[16:59:33] <Leo`> Seldaek: yep, it would be fine to have rustpkg find the crate root under another name than main.rs
[16:59:39] <Leo`> but dunno if possible for now
[17:00:04] <Leo`> but anyway I don't think this branch is ready for merge yet, the Makefile is really messy
[17:00:33] *** Joins: brson (brson@moz-BBE3ABD.mv.mozilla.com)
[17:12:04] <Leo`> Seldaek: but the env util should be ready to be merged. I replied to your comment on GH
[17:16:44] <Seldaek> Leo`: yup I saw, I just wanted to fix a couple things after merge and didn't have time yet
[17:16:57] <Seldaek> this weekend probably
[17:17:47] <Seldaek> as for the main.rs, that sucks a bit I think but not a huge deal 
[17:18:04] <Seldaek> anyway I'm off for today
[18:32:22] *** kimundi is now known as zz_kimundi
[18:43:45] *** zz_kimundi is now known as kimundi
[18:46:40] *** Joins: geoffhill (geoffhill@moz-244CF33A.amazon.com)
[18:48:38] *** Quits: geoffhill (geoffhill@moz-244CF33A.amazon.com) (Ping timeout)
[19:15:50] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[20:12:50] *** Quits: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP) (Quit: Konversation terminated!)
[20:13:23] *** Joins: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP)
[20:15:26] *** Quits: eddyb (eddy@37F72125.9065A63B.FCAAE698.IP) (Ping timeout)
[20:24:20] *** Quits: sw17ch (sw17ch@moz-62998E95.hfc.comcastbusiness.net) (Quit: sw17ch)
[20:30:15] *** Quits: jeffdb (jeffbelg@9782ABE9.E8A0C4C2.E25FE9C.IP) (Ping timeout)
[20:39:10] *** Joins: eddyb9 (eddy@37F72125.9065A63B.FCAAE698.IP)
[20:45:03] *** Joins: jeffdb (jeffbelg@moz-ABCAA64B.efi.com)
[21:44:07] *** Joins: geoffhill (geoffhill@moz-244CF33A.amazon.com)
[21:44:17] *** Quits: jeffdb (jeffbelg@moz-ABCAA64B.efi.com) (Quit: Leaving.)
[22:09:56] *** Quits: devbug (quassel@2D4E172D.4C8B6099.9B57EA59.IP) (Ping timeout)
[22:41:58] <pcmattman> http://buildbot.rust-lang.org/builders/auto-mac-64-nopt-t/builds/1240/steps/test/logs/stdio
[22:41:58] <pcmattman> :(
[22:42:24] <pcmattman> seems -undefined dynamic (or -Wl,-undefined,-dynamic) isn't passed in on OSX for library builds
[22:45:10] *** Joins: tiffany (kawaii@moz-28A8742A.dhcp.embarqhsd.net)
[22:48:48] *** Quits: nielsle (nielsle@moz-5CE8ECCD.boa.fiberby.dk) (Ping timeout)
[22:49:10] <cmr> pcmattman: it doesn't on any platform.
[22:50:41] <pcmattman> other platforms don't seem to have this issue where every symbol in a library has to resolve at link time
[22:52:07] <cmr> oh
[22:53:10] <pcmattman> eg, in a library you might have extern { fn xyz(); } and that's fine on Linux/BSD/etc, but on OSX it'll complain that "_xyz is undefined"
[22:53:32] <cmr> How does that work in the face of dynamic linking?
[22:54:26] <pcmattman> well, you either specify all the necessary libraries on your link line, or for the case of plugins that need to resolve at load-time and such you pass in -undefined dynamic_lookup to the linker
[22:54:42] <pcmattman> *plugins and other such objects
[22:56:38] <pcmattman> example SO post for the issue - http://stackoverflow.com/questions/14090257/error-when-making-dynamic-lib-from-o
[23:02:03] <pcmattman> compiling and running the full testsuite locally now that I'm on my osx laptop to see if my setup reproduces the issue in the buildbot run
[23:06:27] <Luqman> i think i did add -Wl,-undefined,-dynamic for os x when i was doing the crate map stuff
[23:07:00] <Luqman> but i think it may have been changed to just -Wl,-U,crate_map_symbol
[23:07:31] <Luqman> it is annoying that it Just Works (tm) on linux/bsd but os x requires some massaging
[23:07:36] <Luqman> and windows :(
[23:07:49] <pcmattman> there's '-Wl,-U,__rust_crate_map_toplevel'
[23:07:54] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:08:04] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[23:08:10] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:08:21] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:08:21] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[23:08:27] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:12:21] *** Joins: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net)
[23:27:22] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[23:27:28] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Client exited)
[23:29:03] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[23:50:40] *** Joins: devbug (quassel@23AC5F12.9D950176.3655BBF5.IP)
[23:54:04] <pcmattman> hm, using compile-flags in the test to add those options doesn't help either
[23:57:32] *** Quits: sw17ch (sw17ch@moz-675AFBCF.hsd1.mi.comcast.net) (Quit: sw17ch)

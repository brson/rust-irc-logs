[00:01:04] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[00:01:37] <o11c> btw, how close is rust to working with vanilla LLVM?
[00:01:45] <cmr> o11c: 6 patches.
[00:01:56] <o11c> ooh, shiny
[00:02:19] <cmr> https://github.com/rust-lang/llvm/tree/rust-20120106-do-not-delete
[00:02:28] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[00:03:39] <cmr> wait that's the wrong year
[00:03:40] <cmr> heh
[00:03:48] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[00:04:29] <cmr> https://github.com/rust-lang/llvm/commits/rust-llvm-2013-12-27
[00:04:30] <cmr> here we are.
[00:05:58] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[00:10:56] *** Joins: Erik_ (Erik_S@moz-E7E31D21.hlrn.qwest.net)
[00:11:11] *** Joins: kris (kris@moz-147EE6DF.diku.dk)
[00:11:50] *** Quits: kris_ (kris@moz-5A7B69C7.math.ku.dk) (Ping timeout)
[00:14:03] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[00:16:33] *** Quits: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net) (Input/output error)
[00:22:52] *** Quits: negge (unlord@moz-5BD795E6.hsd1.va.comcast.net) (Ping timeout)
[00:25:59] *** Quits: fhahn (fhahn@moz-7924DB5C.vie.surfer.at) (Ping timeout)
[00:27:10] *** Joins: Cevn (sameer@moz-FD022892.wireless.umd.edu)
[00:27:14] *** Joins: negge (unlord@moz-5BD795E6.hsd1.va.comcast.net)
[00:28:55] *** Quits: Cevn (sameer@moz-FD022892.wireless.umd.edu) (Ping timeout)
[00:31:07] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Quit: )
[00:31:07] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[00:33:36] *** Joins: fhahn (fhahn@moz-7924DB5C.vie.surfer.at)
[00:35:28] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[00:35:48] *** Quits: depp (depp@500BAFC1.53465674.3C05E6CB.IP) (Quit: bye)
[00:36:21] *** Joins: Cevn (sameer@moz-FD022892.wireless.umd.edu)
[00:37:30] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[00:37:45] *** Quits: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP) (Ping timeout)
[00:37:48] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[00:38:29] <Tobba> ughhhh
[00:38:33] <Tobba> I think the issue with this
[00:38:40] <Tobba> is that it makes a clone of the value on the stack then calls this method
[00:39:00] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[00:39:13] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[00:39:27] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[00:42:07] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Connection reset by peer)
[00:42:35] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[00:43:09] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Connection reset by peer)
[00:43:35] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[00:43:53] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[00:45:43] *** Quits: ptc (Adium@moz-192425C4.nyc.res.rr.com) (Ping timeout)
[00:46:51] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[00:49:11] *** Joins: sk (sk@61A494B3.BA40E8A.AAC02D62.IP)
[00:49:20] *** Quits: sk (sk@61A494B3.BA40E8A.AAC02D62.IP) (Quit: Leaving)
[00:53:08] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[00:53:19] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[00:53:38] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[00:54:05] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[00:54:07] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[00:54:55] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[00:55:52] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[00:56:00] <carllerche> having some trouble w/ getting my types to work: https://gist.github.com/carllerche/30c1ef6c8bf13ad2174f
[00:59:21] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[01:01:01] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[01:02:37] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[01:04:02] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[01:05:11] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[01:05:13] *** Joins: lpy (lpy@12172131.F09091A8.1348A864.IP)
[01:06:07] <Erik_> Is the rust syntax (keywords, etc) covered somewhere? I want to write a syntax highlighter.
[01:06:25] *** Joins: matthewbot (user@moz-C6814817.ga.at.cox.net)
[01:06:44] <Cevn> Hmm, well, you might be able to glean it from the vim syntax file 
[01:06:55] <Erik_> ugh, that's what I was trying to avoid
[01:06:58] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[01:07:03] *** Joins: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net)
[01:07:14] *** kimundi is now known as zz_kimundi
[01:07:31] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[01:07:31] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[01:07:50] <Cevn> I'm sure someone has it somewhere haha 
[01:07:53] <SiegeLord> Erik_: I got my list from libsyntax
[01:08:20] <SiegeLord> src/libsyntax/parse/token.rs:433
[01:08:26] <Tobba> ugh right
[01:08:36] <Tobba> eddyb: whats with unsafe{} blocks causing values to be cloned all over
[01:08:37] <Erik_> I'll take a look
[01:08:41] <Tobba> I dont think I can sort out this macro if it goes on like this
[01:08:53] <SiegeLord> As for the syntax itself... I also read libsyntax, hah
[01:09:09] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[01:09:10] <SiegeLord> In my case I was doing it for Scintilla, and it requires a hand-written lexer anyway, so I transcribed Rust to C++
[01:11:10] <eddyb> Tobba: no idea... depends what you're doing
[01:11:21] <Tobba> in this case
[01:11:33] <Tobba> a struct (not a reference) leaving an unsafe{} block
[01:11:35] <Tobba> would clone the struct
[01:11:47] <Tobba> while logical, results in really annoying bugs
[01:12:46] <Erik_> SiegeLord: thanks for the token.rs pointer. It's surprisingly readable.
[01:14:15] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[01:15:22] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[01:16:07] *** Quits: dwrensha (chatzilla@moz-B23D2FF6.pitbpa.east.verizon.net) (Ping timeout)
[01:17:38] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[01:18:42] *** Joins: saati (s@moz-11469F61.harmless.hu)
[01:19:02] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Connection reset by peer)
[01:19:23] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[01:20:17] *** Joins: peterdreid (peterdreid@moz-D18776CD.nc.res.rr.com)
[01:20:40] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[01:22:35] *** Quits: heftig_ (heftig@moz-7C22D8AB.dip0.t-ipconnect.de) (Quit: Quitting)
[01:23:23] *** Joins: heftig (heftig@moz-7C22D8AB.dip0.t-ipconnect.de)
[01:24:00] *** Joins: saati (s@moz-11469F61.harmless.hu)
[01:24:05] <peterdreid> Is there a nicer way to write the expression {let x : A = Zero::get_zero(); x} ? Something like Zero::get_zero() as A? If I do that second thing, rustc complains that "the type of this value must be known in this context". Thanks.
[01:24:24] *** Quits: kvanb (kvanb@moz-76614EE8.lns7.lon.bigpond.net.au) (Ping timeout)
[01:25:00] <cmr> peterdreid: std::num::zero::<A>()
[01:25:40] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[01:25:44] *** Parts: ptc (Adium@moz-192425C4.nyc.res.rr.com) ()
[01:26:24] *** Quits: reima (reima@moz-73FDA0CE.dip0.t-ipconnect.de) (Client exited)
[01:26:27] <peterdreid> Thanks
[01:26:50] *** Quits: Cevn (sameer@moz-FD022892.wireless.umd.edu) (Ping timeout)
[01:27:04] *** Joins: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP)
[01:27:36] <carllerche> What is the Send part of `std::option::Option<~proto::SerializedSizeInfo:Send>` ?
[01:27:49] <cmr> carllerche: it's a "kind bound".
[01:28:16] <cmr> http://static.rust-lang.org/doc/master/rust.html#type-kinds
[01:28:55] *** Quits: WebeWizard (Justin@moz-7CCD1DAE.ks.ks.cox.net) (Quit: Leaving)
[01:29:51] <carllerche> cmr: i'm not sure where it's coming from: https://gist.github.com/carllerche/30c1ef6c8bf13ad2174f
[01:29:59] <cmr> https://github.com/mozilla/rust/wiki/The-Rusticon
[01:30:00] <carllerche> I mean, i guess it's part of returning an owned pointer?
[01:30:19] <cmr> carllerche: trait objects have a default bound of Send
[01:30:31] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[01:30:46] <cmr> which line is the error coming from?
[01:30:55] <carllerche> serialize(obj, Some(wat))
[01:31:22] <carllerche> i might be using traits incorrectly
[01:31:58] <cmr> no, the problem is wat is an ~SerializedSizeInfo, and Option<~T> doesn't coerce to an Option<&T>
[01:32:13] <cmr> do wat.as_ref()
[01:32:27] <eddyb> cmr: wouldn't that create Option<&~T>?
[01:32:27] <cmr> or, Some(wat as &...)
[01:32:29] <cmr> yeah
[01:32:32] <cmr> Some(wat).as_ref()
[01:32:46] *** Quits: dbaupp (Thunderbir@moz-54209D42.lns20.syd6.internode.on.net) (Ping timeout)
[01:32:46] *** Quits: kris (kris@moz-147EE6DF.diku.dk) (Ping timeout)
[01:32:46] *** Joins: kris_ (kris@moz-5A7B69C7.math.ku.dk)
[01:32:56] <carllerche> ah, i was under the impression that owned ptrs would be coerced to borrowed ptrs
[01:33:05] <eddyb> carllerche: not when they're nested
[01:33:08] <carllerche> k
[01:33:08] <cmr> they are, but not when they are fields of another type
[01:33:13] <carllerche> good to know
[01:33:31] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[01:33:32] *** Joins: dbaupp (Thunderbir@moz-BFB46368.lns20.syd6.internode.on.net)
[01:33:41] *** Quits: ptc (Adium@6C906E9F.9ECAA4DB.BCDD830B.IP) (Ping timeout)
[01:33:52] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[01:34:20] *** Joins: ptc (Adium@moz-192425C4.nyc.res.rr.com)
[01:34:54] <cmr> carllerche: oh hi, you're from tilde :)
[01:34:58] <cmr> I knew I recognized the name.
[01:35:03] <carllerche> heh, indeed
[01:35:08] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Client exited)
[01:36:19] *** Joins: kvanb (kvanb@2B5C483.28BE6889.1611EE05.IP)
[01:37:18] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[01:37:46] *** Joins: TheHydroImpulse_ (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[01:37:46] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[01:37:53] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[01:37:53] *** TheHydroImpulse_ is now known as TheHydroImpulse
[01:38:55] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[01:39:19] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[01:39:33] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[01:41:30] *** Quits: epdtry (stuart@moz-C31FC981.hsd1.wa.comcast.net) (Quit: WeeChat 0.4.2)
[01:42:26] <Tobba> argh
[01:42:33] <Tobba> it keeps ending up on the stack
[01:42:33] *** Joins: willingc (willingc@moz-B4760708.san.res.rr.com)
[01:42:33] <Tobba> goddamnit
[01:42:40] *** Quits: willingc (willingc@moz-B4760708.san.res.rr.com) (Quit: willingc)
[01:42:42] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[01:42:53] <eddyb> Tobba: what do you need?
[01:43:03] <eddyb> Tobba: by-reference? then take a reference or pass a *T around
[01:43:14] <Tobba> self.borrow().context.enter(&getExtendedState!(pcontext));
[01:43:18] <Tobba> this is what I'm doing right now
[01:43:24] <Tobba> pcontext keeps ending up on the stack though
[01:43:33] <eddyb> Tobba: of course :)
[01:43:51] <carllerche> cmr: seems like Some(wat).as_ref() -> Some(&~SerializedSizeInfo)
[01:43:54] <eddyb> Tobba: &expr is always on the stack, if expr isn't a path to a static or local
[01:43:59] <carllerche> looks like I have to convert wat to a ref first
[01:44:03] <Tobba> well shit
[01:44:17] <Tobba> any idea how to get a proper pointer then?
[01:44:18] <eddyb> Tobba: what is getExtendedState?
[01:44:24] <Tobba> gigantic macro
[01:44:30] <Tobba> in the end it gets an ExtendedState struct
[01:44:37] <eddyb> Tobba: from where?
[01:44:38] <Tobba> and then gets a field
[01:44:45] <Tobba> eddyb: from magic, basicaly
[01:44:59] <Tobba> when the implementation is done it'll just dereference a null pointer at gs
[01:45:01] <eddyb> Tobba: could it produce a &ExtendedState, instead?
[01:45:08] <Tobba> yeah
[01:45:11] <Tobba> thats what it does right now
[01:45:11] <eddyb> okay, don't dereference the pointer
[01:45:41] <eddyb> convert the raw pointer to a.... did you say gs?
[01:45:52] <eddyb> Tobba: give the fuck up and use LLVM's TLS facilities :)
[01:45:55] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[01:45:58] <glennsl> is it possible to have an owned pointer to a trait hold something that doesn't derive from Send?
[01:46:00] <Tobba> eddyb: it doesnt use gs right now
[01:46:04] <Tobba> currently it just does this
[01:46:05] <Tobba> macro_rules! getExtendedState(($f:ident) => {unsafe{::lib::mem::transmute::<*u8, &::state::ExtendedState>(::lib::mem::offset(::core::hal::thread_info[{let tr: u16; asm!("str $0" : "=r"(tr)); (tr-40)/16}].state as *u8, ::lib::mem::size_of::<::core::state::CoreState>() as int))}.$f})
[01:46:07] *** Joins: saati (s@moz-11469F61.harmless.hu)
[01:46:14] <eddyb> Tobba: don't dereference
[01:46:30] <eddyb> Tobba: but if you don't dereference... you can't keep a pointer to GS:0
[01:46:43] <eddyb> Tobba: OOOH, I know. I think
[01:46:49] <eddyb> Tobba: lea
[01:47:01] <Tobba> eddyb: again, I dont care about gs:0 right now
[01:47:06] <Tobba> rust doesnt properly support it
[01:47:12] <Tobba> theres still a few LLVM bugs to fix too
[01:47:25] <eddyb> Tobba: lea would give you an absolute address AFAIK
[01:47:32] <Tobba> nope
[01:47:37] <eddyb> if it can't, there's no point in even trying :(
[01:47:41] <Tobba> yeah again
[01:47:44] <Tobba> I dont care about gs:0 right now
[01:47:48] <Tobba> tryin to make this macro work
[01:47:48] <Tobba> macro_rules! getExtendedState(($f:ident) => {unsafe{::lib::mem::transmute::<*u8, &::state::ExtendedState>(::lib::mem::offset(::core::hal::thread_info[{let tr: u16; asm!("str $0" : "=r"(tr)); (tr-40)/16}].state as *u8, ::lib::mem::size_of::<::core::state::CoreState>() as int))}.$f})
[01:48:43] <eddyb> Tobba: uhm...
[01:48:50] <eddyb> Tobba: what type is the state field?
[01:48:54] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[01:48:56] <Tobba> *mut u8
[01:49:33] <eddyb> Tobba: LOL
[01:49:37] <nightpool> rusti: 0.signum()
[01:49:39] -rusti- pastebinned 22 lines of output: http://ix.io/9Yg
[01:49:42] <eddyb> Tobba: move the & to the inner scope
[01:49:43] <Tobba> did I fuck up badly
[01:49:54] <eddyb> Tobba: instead of &{x.f}, &x.f
[01:49:56] <nightpool> rusti: 0f32.signum()
[01:49:58] -rusti- 1f32
[01:50:35] <eddyb> Tobba: only the latter *could be guaranteed* to not be a stack temporary
[01:51:05] <Tobba> yeah I'm trying to get the latter output
[01:51:11] <Tobba> the { } comes from the macro afaik
[01:51:15] <Tobba> I cant remove that
[01:51:19] <eddyb> Tobba: just put the & inside the macro
[01:51:22] *** Quits: matthewbot (user@moz-C6814817.ga.at.cox.net) (Client exited)
[01:51:31] <eddyb> you'll need it anyway
[01:52:08] <eddyb> Tobba: so, {&unsafe{
[01:52:12] <Tobba> still on the stack
[01:52:22] <nightpool> rusti: 0f32.abs()
[01:52:22] <eddyb> hmm, that's not right
[01:52:23] -rusti- 0f32
[01:52:29] *** Joins: saati (s@moz-11469F61.harmless.hu)
[01:53:07] <eddyb> rusti: struct Foo{f:uint}; static foo: Foo = Foo {f: 0}; &foo.f
[01:53:08] -rusti- &0u
[01:53:20] <eddyb> rusti: struct Foo{f:uint}; static foo: Foo = Foo {f: 0}; &{foo.f}
[01:53:22] -rusti- pastebinned 18 lines of output: http://ix.io/9Yk
[01:53:26] <eddyb> Tobba: ^^
[01:53:39] <eddyb> rusti: struct Foo{f:uint}; static foo: Foo = Foo {f: 0}; &foo.f as *uint as uint
[01:53:40] -rusti- 6236040u
[01:53:47] <eddyb> rusti: struct Foo{f:uint}; static foo: Foo = Foo {f: 0}; &{foo.f} as *uint as uint
[01:53:48] -rusti- 140677212708120u
[01:53:49] *** Joins: gwty (gwtypc@79FFA4AA.D0E9703E.8A00C703.IP)
[01:54:07] <eddyb> Tobba: are you sure you're putting it in the inner-most scope?
[01:54:20] <Tobba> macro_rules! getExtendedStateRef(($f:ident) => {&mut unsafe{::lib::mem::transmute::<*u8, &::state::ExtendedState>(::lib::mem::offset(::core::hal::thread_info[{let tr: u16; asm!("str $0" : "=r"(tr)); (tr-40)/16}].state as *u8, ::lib::mem::size_of::<::core::state::CoreState>() as int))}.$f})
[01:54:23] <rdn> What does #[repr(c)] do?
[01:54:31] <Tobba> self.borrow().context.enter(getExtendedStateRef!(pcontext));
[01:54:41] <eddyb> Tobba: can you split it over multiple lines?
[01:54:49] <Tobba> I probably should yeah
[01:55:10] <cmr> rdn: makes the size of the enum's discriminant the default size of enums that the C ABI for the platform uses.
[01:55:37] <rdn> thanks
[01:57:05] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[01:57:25] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Ping timeout)
[01:58:02] <_achin> when you want to describe something as adhering to standard rust style or convention, do you say it's "rustic" or "rusty"?  :P
[01:58:17] <Tobba> uh, huh
[01:58:21] <Tobba> split it over multiple lines
[01:58:24] <cmr> _achin: rustic
[01:58:28] <Tobba> now getting an error about borrowing mutables
[01:58:41] <_achin> cmr: ok!
[01:58:49] <cmr> _achin: or, in the true style of doge, "very rust"
[01:59:00] <_achin> :P
[01:59:05] <eddyb> Tobba: good
[01:59:09] *** Quits: nkoep (nik@moz-C2878545.pool.mediaways.net) (Quit: Leaving)
[01:59:18] <eddyb> Tobba: errors are good, it means your code is safer :P
[01:59:21] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[01:59:25] <Tobba> hhahahaha
[01:59:26] <cmr> Tobba: wait you seriously wrote that all on one line to begin with O_o
[01:59:32] <Tobba> yes
[01:59:38] <cmr> you're nuts.
[01:59:55] <Tobba> ... okay how the hell did that even compile in the first place
[01:59:58] <eddyb> I've done worse
[02:00:02] <Tobba> I forgot to put down a &mut but it worked anyways
[02:00:16] <cmr> are you sure your whitespaced version is the same as the unwhitespaced version?
[02:00:29] <eddyb> Tobba: because you can borrow stack temporaries
[02:00:39] <peterdreid> Does anyone know where in the source all the Zero impls for tuples come from? There are lots of lines in http://static.rust-lang.org/doc/0.9/std/num/trait.Zero.html like "<A: Zero, B: Zero> Zero for (A, B)", going all the way to L, but I don't see how those are getting made. (I'm trying to do something similar for a function of my own, and am hoping there is a way that doesn't involve lots of 
[02:00:39] <peterdreid> copy/pasting.)
[02:00:41] <Tobba> progress then
[02:00:44] <Tobba> pretty sure
[02:00:48] <eddyb> Tobba: passing the reference through an identity function requiring &'static would help
[02:00:54] <Tobba> though obviously not
[02:01:01] <eddyb> Tobba: that wouldn't let you borrow temporaries
[02:01:08] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[02:01:36] <cmr> peterdreid: they're generated with macros.
[02:01:43] <cmr> peterdreid: see int_macros.rs for example.
[02:01:58] <peterdreid> Perfect, thanks.
[02:02:45] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[02:03:34] <eddyb> #4amfun http://imgur.com/gallery/pltMQo9
[02:04:25] *** Quits: lpy (lpy@12172131.F09091A8.1348A864.IP) (Client exited)
[02:06:22] *** Joins: saati (s@moz-11469F61.harmless.hu)
[02:07:51] <Tobba> ugh screw it, I have an idea
[02:08:35] <bjz> peterdreid: could you elaborate?
[02:08:55] <bjz> peterdreid: there is #[deriving(Zero)]
[02:09:09] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[02:09:20] <bjz> peterdreid: but that is not used in the std because the needs to be abottom turtle :P
[02:10:02] <bjz> peterdreid: the tuple impls are generated in libstd/tuple.rs
[02:10:25] <Tobba> ugh what is wrong with this damn thing
[02:11:33] *** Joins: samx (sami@moz-77A1C177.pp.htv.fi)
[02:11:34] <peterdreid> My use doesn't actually have anything to do with zero at all. I'm making a function to iterate through an sqlite3 result set. I have it working for a specific number of output columns, and am trying to get it working for up to a dozen or so columns.
[02:12:04] <bjz> peterdreid: I'd use a macro
[02:12:18] <bjz> peterdreid: or deriving
[02:12:35] <peterdreid> Ok, thanks.
[02:12:46] <peterdreid> Currently starting at the macros in tuple.rs
[02:12:47] *** Joins: saati (s@moz-11469F61.harmless.hu)
[02:12:49] <peterdreid> staring*
[02:13:01] <bjz> peterdreid: there are more around libstsd
[02:13:18] <bjz> peterdreid: just search for macro_rules
[02:13:21] <peterdreid> Ok, great
[02:13:25] <peterdreid> This is a good puzzle
[02:13:53] *** Quits: samx (sami@moz-77A1C177.pp.htv.fi) (Quit: This computer has gone to sleep)
[02:14:16] <bjz> peterdreid: I really dislike using macros for this stuff, but atm it's the best we have
[02:14:34] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[02:15:30] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[02:15:37] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[02:15:44] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[02:15:53] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[02:16:49] *** Quits: leroux (leroux@moz-421CF1E4.dsl.bell.ca) (Client exited)
[02:18:13] <yuriks> how can I tell rustc to output files to a different directory when using -c?
[02:18:27] <cmr> yuriks: --out-dir iirc
[02:18:33] <yuriks> -o obj/foo.o apparently works, but gives me a warning
[02:18:42] <Tobba> eddyb: fuck yes
[02:18:44] <Tobba> I got it to work
[02:18:51] <Tobba> guess what, magical fucking combination of two bugs
[02:18:53] <yuriks> cmr: oh, I had missed that in the help, sorry
[02:19:02] <Tobba> resulting in the same output until both were fixed
[02:20:09] *** Joins: reima (reima@moz-73FDA0CE.dip0.t-ipconnect.de)
[02:20:11] <diverse> Tobba: how is the kernel brewing?
[02:20:32] <Tobba> well I just spent 3 hours fixing a misplaced {} block and another misplaced *
[02:20:56] *** Quits: reima (reima@moz-73FDA0CE.dip0.t-ipconnect.de) (Quit: Leaving)
[02:23:17] *** Joins: saati (s@moz-11469F61.harmless.hu)
[02:23:37] <Tobba> context switches work though
[02:23:42] <Tobba> I now have preemptive multitasking
[02:24:05] <yuriks> Tobba: osdev?
[02:24:49] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[02:25:10] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[02:25:48] <Tobba> yeah
[02:26:00] <Tobba> I'll go sleep now, that was a really annoying one
[02:26:07] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[02:26:57] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[02:27:57] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[02:28:21] *** Quits: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com) (Ping timeout)
[02:28:23] *** Quits: bjustin (bjustin@moz-4B914826.hsd1.mn.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[02:29:38] *** Joins: saati (s@moz-11469F61.harmless.hu)
[02:29:47] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[02:30:57] *** Quits: paulproteus (quassel@rose.makesad.us) (Ping timeout)
[02:31:35] *** Joins: paulproteus (quassel@moz-E86A3B42.makesad.us)
[02:33:53] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[02:34:01] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Quit: Ex-Chat)
[02:34:19] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[02:35:33] *** Quits: cschneid (cschneid@moz-246E080D.hlrn.qwest.net) (Client exited)
[02:38:06] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[02:38:41] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:39:33] *** Joins: robhobbes (Mibbit@moz-2741C540.slkc.qwest.net)
[02:39:54] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[02:40:43] *** Quits: kvanb (kvanb@2B5C483.28BE6889.1611EE05.IP) (Quit: kvanb)
[02:41:08] <robhobbes> can anyone tell me how to create a new json object?
[02:42:14] <cmr> robhobbes: extra::json::Object(~TreeMap::new())
[02:43:10] *** Joins: leroux (leroux@moz-421CF1E4.dsl.bell.ca)
[02:43:10] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:47:25] *** Quits: leroux (leroux@moz-421CF1E4.dsl.bell.ca) (Client exited)
[02:47:33] <robhobbes> cmr: it says, unresolved name
[02:47:58] <cmr> robhobbes: sure. you'll need to import TreeMap.
[02:48:33] <robhobbes> use extra::treemap ?
[02:48:42] *** Quits: Ferreus (ferreus@moz-B5780FF1.pools.arcor-ip.net) (Quit: WeeChat 0.4.3-dev)
[02:48:54] <cmr> use extra::treemap::TreeMap;
[02:49:14] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[02:49:20] <robhobbes> oh... okay. thanks
[02:49:20] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[02:50:31] <carllerche> so, is doing &*my_var the best way to convert a ~ box to a & box?
[02:51:05] <strcat> & isn't a box
[02:51:13] <carllerche> it's a borrowed btr
[02:51:14] <carllerche> ptr
[02:51:15] <dbaupp> it often auto-borrows to &
[02:51:16] <carllerche> sorry
[02:51:29] <dbaupp> but if it's not working, then yes, that's the best explicit borrow
[02:51:32] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[02:51:36] <carllerche> I'm doing Some(&*my_var)
[02:51:51] <dbaupp> ah, yes, probably requires it explicitly.
[02:54:53] <robhobbes> cmr: so say I'm doing extra::json::from_str on a valid json string, how do I get the value of the result?
[02:55:39] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[02:56:30] <peterdreid> In a macro loop (like "$(..),+" ), is it possible to get the index of iteration?
[02:57:17] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Connection reset by peer)
[02:57:27] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[02:57:55] <dbaupp> peterdreid: no
[02:58:30] <peterdreid> Ok, thanks.
[02:58:37] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:58:38] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Client exited)
[02:58:38] *** Joins: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net)
[02:58:53] <jsonnull> robhobbes: take a look at std::result::Result.ok()
[02:59:10] <jsonnull> robhobbes: that will convert the Result to a Option you can match.
[02:59:17] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[02:59:41] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[02:59:47] *** jorendorff_away is now known as jorendorff
[03:01:27] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Ping timeout)
[03:02:56] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Ping timeout)
[03:03:03] <robhobbes> jsonnull: will I have to match it to one of treemap, list, etc?
[03:04:51] <jsonnull> robhobbes: it will match it to Json
[03:05:37] <jsonnull> robhobbes: specifically, the ok() call will convert it from a Result<Json, Error> to a Option<Json>
[03:05:54] <robhobbes> jsonnull: thanks
[03:06:11] <jsonnull> robhobbes: Hope it helps. :)
[03:06:30] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[03:06:45] *** jorendorff is now known as jorendorff_away
[03:08:12] *** Quits: robhobbes (Mibbit@moz-2741C540.slkc.qwest.net) (Quit: http://www.mibbit.com ajax IRC Client)
[03:08:28] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[03:09:57] *** Quits: DAddYE (DAddYE@moz-98D3933F.hsd1.ca.comcast.net) (Ping timeout)
[03:10:53] *** Quits: zz_kimundi (kimundi@moz-EAE0F638.dip0.t-ipconnect.de) (Ping timeout)
[03:12:00] *** Quits: biardjd (chatzilla@moz-BB97B490.washdc.fios.verizon.net) (Quit: ChatZilla 0.9.90.1 [Firefox 26.0/20131206145143])
[03:13:06] *** Quits: dbaupp (Thunderbir@moz-BFB46368.lns20.syd6.internode.on.net) (Ping timeout)
[03:13:36] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[03:13:37] *** Joins: z0w0 (zack@moz-87AABEA0.lnse1.woo.bigpond.net.au)
[03:14:03] *** Joins: zz_kimundi (kimundi@moz-F79A61BC.dip0.t-ipconnect.de)
[03:14:21] *** zz_kimundi is now known as kimundi
[03:14:30] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Leaving...)
[03:15:26] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[03:17:17] *** Joins: dbaupp (Thunderbir@moz-A840EB3D.lns20.syd6.internode.on.net)
[03:18:26] <_achin> if i want to use an enum type for a arg to a foreign-function, how can i do this safely?
[03:18:46] <_achin> ("warning: found enum type without foreign-funcdtion-safe representation annotation in foreign module")
[03:18:48] <cmr> Any announcements for This Week in Rust?
[03:18:55] <cmr> _achin: #[repr(C)]
[03:20:29] *** Joins: bleibig (bleibig@moz-B4D9C5AF.hsd1.ca.comcast.net)
[03:20:31] <_achin> cmr: thanks
[03:20:49] <sfackler> cmr: I've been working on this as a practical use of the external macro stuff: https://github.com/sfackler/rust-phf
[03:21:03] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Quit: ziad)
[03:22:02] <cmr> sfackler: can you give it a description in the readme?
[03:22:45] <sfackler> sure
[03:23:55] *** Quits: ktt3ja (ktt3ja@moz-54586A12.washdc.fios.verizon.net) (Quit: Leaving)
[03:24:09] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[03:24:38] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Ping timeout)
[03:24:44] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[03:27:37] *** Joins: saati (s@moz-11469F61.harmless.hu)
[03:28:30] <nightpool> is there a better way to get tuple elements then .n0() and .n1()? 
[03:28:33] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[03:28:41] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[03:28:46] <sfackler> cmr: look okay? https://github.com/sfackler/rust-phf
[03:28:53] <cmr> nightpool: you can pattern match, let (a, b, c, d) = some_tuple;
[03:29:14] <cmr> sfackler: yup, thanks!
[03:29:18] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Ping timeout)
[03:29:31] <nightpool> cmr: I'm just looking for individual elements, to use in an inline statement. 
[03:29:49] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[03:29:49] <dbaupp> nightpool: that's the best way, yes. (is there some problem with it?)
[03:29:57] *** Quits: Earnestly (earnest@moz-E86D50FA.dyn.plus.net) (Ping timeout)
[03:30:31] <jsonnull> Do tuples support something like swizzling without doing a match?
[03:30:32] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[03:30:32] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[03:30:52] <dbaupp> no
[03:31:13] <nightpool> dbaupp, no I spose not. I was hoping indexing would work, but rustc is very adament that it doesn't. 
[03:31:14] <dbaupp> (coincidentally people have been discussing swizzling on the mailing list over the past few days)
[03:31:22] <jsonnull> Really?
[03:31:35] *** Joins: jdm (jdm@moz-AC9499B2.cable.teksavvy.com)
[03:31:35] *** ChanServ sets mode: +o jdm
[03:31:46] *** Quits: jdm (jdm@moz-AC9499B2.cable.teksavvy.com) (Quit: Lost terminal)
[03:32:13] <sfackler> in the context of SIMD vectors
[03:32:17] <dbaupp> jsonnull: in the context of SIMD, but it's not a stretch to imagine it being general enough to work with tuples (although using it with tuples could very-reasonably be deemed unnecessary)
[03:32:21] * dbaupp shrugs
[03:32:34] <nightpool> Dbaupp: what about iteration? Do tuples support .map?
[03:32:57] <dbaupp> nightpool: they can't
[03:33:00] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:33:06] <dbaupp> well, they could, but only (A, A, A, ..., A)
[03:33:10] <dbaupp> (i.e. all the same type)
[03:33:51] *** Joins: saati (s@moz-11469F61.harmless.hu)
[03:33:52] <jsonnull> dbaupp: Neat, thanks for sharing.
[03:34:13] <nightpool> Right, all the same type was what I was looking for. 
[03:36:11] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[03:38:27] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[03:40:09] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[03:40:17] *** Joins: michaeljdennis (michaeljde@moz-D1393DB0.socal.res.rr.com)
[03:41:13] *** Joins: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net)
[03:43:03] *** Joins: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp)
[03:43:18] <yuriks> is there a way to have a function accept a string/string slice or a specified size?
[03:43:41] <dbaupp> yuriks: s/or/of/?
[03:43:47] <yuriks> yes
[03:43:57] *** Quits: eibwen (kvirc@moz-166DC175.dip0.t-ipconnect.de) (Ping timeout)
[03:44:03] <dbaupp> just plain old `&str` doesn't cut it?
[03:44:21] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[03:44:48] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[03:44:56] <yuriks> I want to do something like fn<N>(&mut [u16, ..N], &str[..N])
[03:45:00] *** Joins: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net)
[03:45:22] *** Quits: michaeljdennis (michaeljde@moz-D1393DB0.socal.res.rr.com) (Client exited)
[03:46:24] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[03:46:28] <dbaupp> ah, yes, that's not supported
[03:46:34] *** Joins: brianm_ (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[03:46:38] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[03:46:41] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[03:47:04] <yuriks> hm, ok, thanks
[03:47:23] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[03:47:29] <glennsl> is it possible to have an owned pointer to a trait hold something that doesn't derive from Send?
[03:47:29] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[03:47:38] <glennsl> or is there some better way to hide an implementation?
[03:47:47] <dbaupp> glennsl: `~Trait:`
[03:48:04] <dbaupp> ~Trait is by default `~Trait:Send`, but you can override the default with an explicit :
[03:48:09] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[03:49:27] <glennsl> gives me syntax error
[03:49:44] <dbaupp> rusti: ~@1 as ~Eq:
[03:49:48] -rusti- pastebinned 10 lines of output: http://ix.io/9Yu
[03:50:05] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[03:50:11] <dbaupp> rusti: ~Rc::new(1) as ~Eq:
[03:50:16] -rusti- pastebinned 13 lines of output: http://ix.io/9Yv
[03:50:31] <dbaupp> rusti: ~std::rc::Rc::new(1) as ~Eq:
[03:50:33] -rusti- ~std::cmp::Eq<no-bounds>
[03:51:00] <glennsl> it's in a struct though
[03:51:32] <glennsl> rusti struct A { t: ~Eq: }
[03:51:46] <sfackler> rusti: struct A { t: ~Eq: }
[03:51:47] -rusti- <anon>:10:9: 10:29 warning: code is never used: `A`, #[warn(dead_code)] on by default
[03:51:47] -rusti- <anon>:10         struct A { t: ~Eq: }
[03:51:47] -rusti-                   ^~~~~~~~~~~~~~~~~~~~
[03:51:48] -rusti- ()
[03:51:53] *** Joins: saati (s@moz-11469F61.harmless.hu)
[03:52:37] <glennsl> rusti: struct A { t: ~Eq: } let a = A { t: ~std::rc::new(1) }
[03:52:40] -rusti- pastebinned 6 lines of output: http://ix.io/9VA
[03:53:13] <dbaupp> rusti: struct A { t: ~Eq: } let a = A { t: ~std::rc::Rc::new(1) }; a
[03:53:14] -rusti- main::A{t: ~std::cmp::Eq<no-bounds>}
[03:53:43] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[03:54:33] *** Quits: peterdreid (peterdreid@moz-D18776CD.nc.res.rr.com) (Ping timeout)
[03:55:09] <Amaranth> What is the symbol to break on to debug task failure?
[03:55:18] *** Quits: brianm_ (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[03:55:22] <cmr> Amaranth: rust_fail
[03:55:36] *** Joins: dwrensha (chatzilla@moz-B23D2FF6.pitbpa.east.verizon.net)
[03:55:36] <Amaranth> Oh it got nice and simple
[03:55:43] <cmr> yup :)
[03:55:47] *** Quits: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com) (Ping timeout)
[03:56:24] <glennsl> rusti: struct A { t: ~Iterator<int>: }
[03:56:26] -rusti- pastebinned 6 lines of output: http://ix.io/9YA
[03:56:30] *** Joins: vodik (simon@moz-FD4ADBC6.cable.teksavvy.com)
[03:56:40] <glennsl> doesn't seem to play well with parametric type syntax
[03:56:55] <cmr> it's Iterator:<int> I think.
[03:56:58] <dbaupp> rusti: struct A { t: ~Iterator:<int> }
[03:56:58] *** Joins: saati (s@moz-11469F61.harmless.hu)
[03:56:59] -rusti- <anon>:10:9: 10:40 warning: code is never used: `A`, #[warn(dead_code)] on by default
[03:56:59] -rusti- <anon>:10         struct A { t: ~Iterator:<int> }
[03:56:59] -rusti-                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[03:56:59] -rusti- ()
[03:57:35] <glennsl> ah, there we go. Thanks!
[03:57:42] <cmr> http://cmr.github.io/blog/2014/01/18/this-week-in-rust/
[03:58:12] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[03:58:15] *** Quits: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net) (Quit: zzz)
[03:58:43] *** Joins: depp (depp@500BAFC1.53465674.3C05E6CB.IP)
[03:58:57] *** Quits: brson (brson@moz-BBE3ABD.mv.mozilla.com) (Quit: leaving)
[03:59:18] <yuriks> similarly, is it possible to destructure a string during pattern matching?
[03:59:45] <yuriks> hmm, I guess that doesn't really make sense because of variable character lengths
[03:59:53] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[03:59:56] <dbaupp> if you mean `match "foobar" { "foo".. rest => rest == "bar" }`, no
[04:00:13] *** jorendorff_away is now known as jorendorff
[04:01:48] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[04:02:03] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: Textual IRC Client: www.textualapp.com)
[04:02:28] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[04:04:57] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[04:06:32] <dbaupp> cmr: you can't list yourself! :P
[04:07:24] <cmr> dbaupp: I didn't! lars did.
[04:07:43] <dbaupp> sure sure
[04:08:32] *** Joins: saati (s@moz-11469F61.harmless.hu)
[04:08:54] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:09:12] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Quit: Leaving.)
[04:09:14] <dbaupp> cmr: the second and third last Annoucements etc. links are under one bullet point
[04:09:20] <cmr> dammit I hate markdown.
[04:10:05] <dbaupp> write it in plain HTML?
[04:10:10] <depp> ^
[04:10:11] <cmr> I don't hate it that much :p
[04:10:16] <cmr> fixed, thanks.
[04:10:18] *** Quits: saati (s@moz-11469F61.harmless.hu) (Ping timeout)
[04:10:22] <o11c> that tjc quote is awesome
[04:10:25] <cmr> (can't ever have a twir without issue, can I :( )
[04:10:32] <o11c> you should add a donation link to the rust reddit
[04:10:41] <cmr> bstrie_nope: here that?
[04:10:41] <jsonnull> I second that, I love the quotes. :)
[04:10:55] <dbaupp> cmr: where what?
[04:10:56] <cmr> *hear
[04:11:12] <dbaupp> does Rust even have a donation channel?
[04:11:19] <cmr> I don't think so.
[04:11:49] *** wycats_ is now known as wycats
[04:12:47] <dbaupp> cmr: do you submit TWIR to HN and proggit etc?
[04:13:46] *** Joins: saati (s@moz-11469F61.harmless.hu)
[04:14:06] <cmr> dbaupp: proggit yes, HN no.
[04:14:21] <cmr> and LWN.
[04:15:14] <cmr> you should upvote it on proggit before it disappears into oblivion :p
[04:16:10] <cmr> state of rust 0.9 got 7.8k hits.
[04:16:59] <depp> heh, bessel functions got removed... I actually use those, but I understand I'm in the minority
[04:17:36] <cmr> depp: extern { fn f0(f64) -> f64 }
[04:17:37] <cmr> :)
[04:17:40] <cmr> erm, j0
[04:17:54] <depp> not all of them are in libc
[04:18:55] <cmr> we didn't have any that aren't in libm
[04:19:01] <depp> ah
[04:19:16] <cmr> it was just the bindings to them.
[04:19:16] <depp> I think I used one that wasn't available on OS X, so I didn't use it on Linux either
[04:19:33] <depp> for Kaiser windows
[04:21:02] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[04:21:42] *** Joins: gverilla__ (gverilla@moz-5EAE171E.versanet.de)
[04:22:03] *** Quits: notmatt (notmatt@moz-9FB2565E.vc.shawcable.net) (Client exited)
[04:22:40] *** Quits: gverilla_ (gverilla@moz-5AD3DE14.versanet.de) (Ping timeout)
[04:23:02] *** Joins: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP)
[04:23:09] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[04:25:29] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[04:26:29] *** jorendorff is now known as jorendorff_away
[04:26:36] <strcat> depp: the f64 versions of them are POSIX, aren't they on OS X? *shrug*
[04:27:17] <strcat> can just implement f32 ones by converting to f64, running it and converting back
[04:27:30] <strcat> won't get consistent results across platforms with something like that anyway ;p
[04:27:40] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[04:28:18] <dbaupp> cmr: 8k hits! Nice
[04:29:26] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[04:29:47] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[04:29:49] <enix> So, it took me about 4 months longer than I thought it would, but I've finally completed my implementation of AES in Rust.
[04:29:50] <enix> My conclusion - Rust is very well suited for this use case, although integer template parameters would be super nice.
[04:30:34] <dbaupp> awesome!
[04:30:53] <dbaupp> is it in a state where asking for comparative benchmarks is reasonable?
[04:31:09] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[04:31:37] <enix> somewhat
[04:31:56] <enix> I have two different AES implementation - one using AES-NI on Intel hardware and another that is pure software
[04:32:22] <enix> The AES-NI one would be interesting to compare to other ones, for sure, which I haven't really done all that much yet
[04:33:25] <enix> the software one is a little unusual as I wrote it as a bit-spliced implementation so that it should hopefully be invulnerable to timing attacks. As best as I can tell, there aren't any other bit-spliced implementation of AES in high-level languages.
[04:33:48] <dbaupp> Most are in asm or C?
[04:33:49] <cmr> what is bit splicing?
[04:33:53] <enix> so, it might be a little tricky to do an apples-to-apples comparision for that one
[04:34:16] <enix> bit-slicing is where you basically emulate a hardware implementation of an algorithm in software
[04:34:30] <enix> (I always type "spliced" by accident)
[04:34:33] <cmr> ah ok.
[04:34:41] <cmr> I can probably google for bit slice easier :p
[04:34:43] <depp> hm, I'd be worried that LLVM would sabotage some of the tricks
[04:34:54] <enix> the idea is to get all the equivalent bits from various bytes into the same register and then run operations on all those bits as once in parallel
[04:34:55] <jsonnull> Does the default logger write to stdout?
[04:35:00] <cmr> jsonnull: info!() etc?
[04:35:04] <dbaupp> jsonnull: stderr
[04:35:08] <jsonnull> cmr: Yes
[04:35:22] <cmr> stderr, and you need to set RUST_LOG to get the output.
[04:35:25] *** Quits: erickt (Adium@49C4075F.3AC15C18.2321E71E.IP) (Quit: Leaving.)
[04:35:58] <cmr> enix: that sounds really awful to implement.
[04:36:32] <dbaupp> apparently "The fastest AES implementation (without Intel AES instructions) is bit sliced"
[04:36:34] <enix> dbaupp: I had a hard time finding bit sliced implementations in anything except assembly. NaCL has a C implementation, but, its basically just a port of the ASM implementation using a ton of macros and so it still looks like ASM
[04:36:44] <dbaupp> http://eprint.iacr.org/2009/129
[04:36:59] <dbaupp> enix: heh; is there much `unsafe`?
[04:37:19] <cmr> 7.59 cycles/byte, that's really good.
[04:37:23] <enix> Yeah, mine isn't competitice with that one. As best as I could tell, they are getting 100MB/s and higher; mine gets about 70MB/s.
[04:37:57] <enix> I have very little unsafe code, except for the AES-NI implementation which uses lots of ASM. I utilized Rust's support for SIMD operations which seems to work pretty well
[04:38:08] <dbaupp> oh, awesome
[04:38:12] <dbaupp> this sounds better and better
[04:38:29] <cmr> enix: hurry up and post it so I can get it in TWiR before the big rush :p
[04:38:33] <enix> cmr: Had I known how long it would take me to get this working, I probably wouldn't have tried, especially since this is just a for fun project
[04:38:43] <cmr> heh
[04:38:50] <enix> I put it in my rust-crypto library at https://github.com/DaGenix/rust-crypto
[04:39:05] <enix> documentation isn't exactly its strong point right now, but all the code is there
[04:39:21] <cmr> is this the first pure-rust AES?
[04:40:08] <dbaupp> enix: so, your code isn't based on the algorithm in that paper?
[04:40:14] <enix> Its the only one I'm aware of, although I didn't do much of a survey
[04:41:44] <cmr> very cool, nice work :)
[04:42:04] <enix> dbaupp: I referenced that paper since its a great source. I didn't port any code from that paper, though.
[04:42:20] <dbaupp> woah, aesni.rs has so much asm!()
[04:42:45] <enix> All my code is in https://github.com/DaGenix/rust-crypto/blob/master/src/rust-crypto/aessafe.rs along with references. I have lots of references.
[04:43:36] <enix> lol, yeah, lots of asm for that once since I just have a thin wrapper around the AES instructions. I relied heavily on the Intel developer guide for AES for that one.
[04:44:24] <enix> Funny thing - getting AES working was quite a pain; what took me that last 3 months however was trying to get an interface that I liked for the CBC block mode
[04:45:01] <wycats> what does kind bounds can only be used on trait types" mean?
[04:45:39] <cmr> wycats: it means you can only put :Send at the end of ~TraitObject
[04:45:40] <dbaupp> wycats: you can only uses the "builtin" traits for `~Foo:<these things>" http://static.rust-lang.org/doc/master/std/kinds/index.html
[04:45:58] <dbaupp> enix: you've got one, now?
[04:46:12] <wycats> I want to have a struct with a &'a W: SomeTrait
[04:46:29] <wycats> and a fn new::<W: SomeTrait>(writer: &W)
[04:46:29] <enix> yeah, I also implemented ECB, CBC, and CTR modes. AES isn't very interesting without modes to use it with.
[04:46:33] <wycats> is this impossible?
[04:46:58] <dbaupp> wycats: is W a trait or a generic inside the struct?
[04:47:14] <wycats> I would love for it to be generic
[04:47:34] <wycats> https://www.irccloud.com/pastebin/KkB8ztV9
[04:47:48] *** Parts: ptc (Adium@moz-192425C4.nyc.res.rr.com) ()
[04:47:58] <dbaupp> you just use the trait bounds at the point of use of the struct
[04:48:30] <wycats> I'm trying that
[04:48:34] <dbaupp> i.e. struct Foo<W> { ... } impl<W: Writer> Foo<W> { ... } fn foo<W: Writer>(x: Foo<W>) { .. } etc etc.
[04:48:35] <wycats> and getting:
[04:48:36] <wycats> https://www.irccloud.com/pastebin/4s4bOpN2
[04:48:50] <wycats> the arrow is pointing at WrittenOutputStream
[04:49:05] <wycats> writer is a std::io::BufWriter, which implements Writer
[04:49:25] <dbaupp> I'll need to see the declaration of new
[04:49:28] <wycats> ok
[04:50:04] *** Quits: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz) (Quit: Busying myself...)
[04:50:16] <wycats> https://gist.github.com/wycats/7cbfebc5d7f5d44ba170#file-written_output_stream-rs-L10-L14
[04:50:23] <wycats> fwiw I've tried many different things :P
[04:50:40] <wycats> including placing the bounds in different combinations of places in the impl
[04:51:20] <dbaupp> Ah, the generics on fn new... are shadowing those on the impl
[04:51:30] <dbaupp> so just delete them and it should work
[04:51:48] <wycats> aha
[04:52:01] <dbaupp> (i.e. the compiler is thinking the W from impl<..., W> and the W from fn new<..., W> are different, so the first one is left unconstrained.)
[04:52:14] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[04:53:34] *** Quits: bytbox (s@moz-54E13927.washdc.fios.verizon.net) (Input/output error)
[04:53:44] <dbaupp> enix: do the bounds checks on vector accesses cause problems?
[04:54:01] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[04:54:12] <enix> I'm not quite sure
[04:54:53] <enix> Most of the implementation works by transforming arrays into SIMD variables so there aren't array accesses on many of the calculations
[04:55:28] <enix> The bounds checks mostly come into play in the code transformting into the SIMD representations or back out to arrays again, but I haven't had a chance to try to measure that
[04:55:44] *** Joins: bytbox (s@moz-54E13927.washdc.fios.verizon.net)
[04:55:49] <dbaupp> Ah, so not data dependent at all, so should be ok?
[04:56:12] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[04:56:14] <yuriks> https://github.com/thestinger/rust-core/blob/master/core/str.rs
[04:56:14] <dbaupp> enix: what's aes.rs btw?
[04:56:28] <yuriks> how does that wizardry with transmute inferring the string size work?
[04:56:33] <dbaupp> oh, looks like a high level interface to aessafe/aesni?
[04:57:06] <cmr> yuriks: string slices are represented as (ptr, len)
[04:57:11] <dbaupp> yuriks: because &str is represented as (pointer to data, length)
[04:57:13] <strcat> yuriks: probably going to remove it anyway because byte size isn't very relevant
[04:57:29] <strcat> and as_bytes().len() works if you really, really care for some reason (networking?)
[04:57:31] *** Quits: maxiepoo (mnew@moz-6F50ADE.hsd1.il.comcast.net) (Quit: Leaving)
[04:57:48] <yuriks> strcat: I noticed it's been well hidden
[04:57:54] <strcat> hm? it's not hidden
[04:58:05] <yuriks> cmr: is that in the library somewhere or is it just "the compiler says so"?
[04:58:09] <wycats> dbaupp: can you think of any reason this shadowing shouldn't be a warning
[04:58:12] <cmr> yuriks: "the compiler says so"
[04:58:26] <enix> dbaupp: yup, aes.rs tries to select the best implementation of Aes based on the supported features of the processor. aesni.rs and aessafe.rs are those implementations.
[04:58:32] <yuriks> strcat: it's not in any of the string related places I looked
[04:58:44] <yuriks> in the docs, I mean
[04:58:57] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[04:59:25] <enix> dbaupp: Nothing in aessafe.rs should be data dependant, so, I believe it should be immune to timing attacks. Of course, that partially depends on what LLVM is doing behind my back, which I haven't looked into.
[04:59:31] <dbaupp> wycats: nope, no reason at all
[04:59:36] <dbaupp> wycats: file a bug :)
[04:59:40] <yuriks> but I'm not very familiar with type/trait hierarchy yet, so maybe I looked in the wrong places
[04:59:55] *** Joins: pzol (pzol@moz-553BEE64.dynamic.chello.pl)
[05:00:12] <dbaupp> enix: ah, yes; compiler optimisations...
[05:00:41] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[05:00:51] <yuriks> strcat: sure did, it's in Container
[05:01:31] <enix> indeed. Just to make sure I say it, I wouldn't recommend that anyone use my AES code for anything requiring serious security right now, but hopefully this is a good test use case for Rust
[05:01:50] <yuriks> strcat: so what you're saying is you're gonna make it into a pointer + null termination?
[05:02:13] <yuriks> or just do away with that from the interface?
[05:04:11] <strcat> yuriks: no... I didn't say that
[05:04:22] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[05:04:31] <strcat> yuriks: it's a Unicode string, it can't be nul-terminated
[05:04:53] <strcat> yuriks: Container isn't hidden, it's a trait
[05:04:56] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:05:12] <yuriks> strcat: I tought utf-8 was supposed to be null-safe?
[05:05:20] <strcat> yuriks: it's not, that's a misconception
[05:05:35] <strcat> UTF-8 encodes the first code point (0) as a zero byte
[05:05:44] <strcat> you cannot use C strings for UTF-8, only a subset
[05:06:02] <yuriks> interesting. New knowledge acquired :)
[05:06:24] <strcat> I actually updated the incorrect Wikipedia page about C strings to reflect this...
[05:06:30] <cmr> hahah
[05:06:32] <cmr> it really had that?
[05:06:36] <strcat> cmr: yes
[05:06:41] <strcat> and my edits were reverted many times
[05:06:43] <cmr> yucky.
[05:06:46] <strcat> it's well sourced too...
[05:06:57] <cmr> especially yucky.
[05:06:57] <dbaupp> are they currently on the page?
[05:07:09] <strcat> dbaupp: https://en.wikipedia.org/wiki/Null-terminated_string#Character_encodings yep
[05:07:17] *** Quits: AvianFlu (AvianFlu@moz-51534E77.c3-0.43d-ubr2.qens-43d.ny.cable.rcn.com) (Quit: Leaving...)
[05:07:56] <dbaupp> well, at least it got there eventually :)
[05:07:59] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[05:08:53] <strcat> yuriks: I think there are probably bytes you could use the mark the end
[05:08:58] <strcat> yuriks: but 0 isn't one of them ;P
[05:09:31] *** Quits: new_one_afk (new_one@DE471074.940F5E39.B3C0173E.IP) (Quit: leaving)
[05:09:43] <dbaupp> 0xff is an invalid utf-8 byte, right?
[05:09:57] *** Quits: Kxepal (Miranda@moz-B7304D9C.pppoe.mtu-net.ru) (Ping timeout)
[05:10:06] <cmr> ff terminated strings isn't as catchy.
[05:10:20] <wycats> dbaupp: https://github.com/mozilla/rust/issues/11658
[05:10:30] <strcat> dbaupp: 245 to 255 are invalid
[05:10:56] <strcat> as are 192 and 193, apparently
[05:11:08] <yuriks> strcat: I'm looking through the history: "Not true, but I understand the confusion." < heh)
[05:11:19] <strcat> there are invalid sequences too
[05:11:45] <dbaupp> wycats: awesome
[05:12:13] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[05:12:29] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[05:12:39] *** Quits: dwrensha (chatzilla@moz-B23D2FF6.pitbpa.east.verizon.net) (Ping timeout)
[05:12:40] *** Joins: Kxepal (Miranda@moz-33C7CDB3.pppoe.mtu-net.ru)
[05:12:55] <strcat> yuriks: well there are a few other pages I had to do
[05:13:01] <strcat> and was less successful there
[05:13:59] <strcat> I often don't log in and people love reverting anon edits too
[05:16:53] <itdaniher> Luqman: could I trouble you for another ARM hardfloat build?
[05:17:29] <itdaniher> realtedly: do we know what work it'd take to get snapshots & tests working for ARM HF / ARMEL?
[05:19:18] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[05:19:46] *** Quits: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net) (Ping timeout)
[05:22:37] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: Leaving)
[05:22:50] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[05:24:10] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[05:24:10] *** Joins: ziad (ziad@moz-5729CEA7.hsd1.ca.comcast.net)
[05:24:33] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[05:25:14] *** Quits: blank_na1e (blank_name@E7821509.94CCB18F.53C6B850.IP) (Ping timeout)
[05:30:09] *** Joins: leroux (leroux@moz-421CF1E4.dsl.bell.ca)
[05:30:11] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[05:30:32] <wycats> dbaupp: :D
[05:30:41] <wycats> dbaupp: so many error messages drive me crazy
[05:30:45] <wycats> I need to level up so I can fix em
[05:31:53] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[05:33:48] *** Joins: kvanb (kvanb@2B5C483.28BE6889.1611EE05.IP)
[05:34:17] *** Joins: ptc1 (Adium@moz-192425C4.nyc.res.rr.com)
[05:34:20] *** Quits: ptc1 (Adium@moz-192425C4.nyc.res.rr.com) (Client exited)
[05:34:45] *** Quits: leroux (leroux@moz-421CF1E4.dsl.bell.ca) (Ping timeout)
[05:36:21] *** Joins: mib_6fzpfo (Mibbit@39A6AFF0.A6FC4FF2.1BEE1C35.IP)
[05:37:03] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[05:37:10] <yuriks> hm, I managed to crash ld. Nice
[05:37:27] *** Joins: blank_name (blank_name@E7821509.94CCB18F.53C6B850.IP)
[05:37:41] <dbaupp> wycats: :D
[05:37:58] <dbaupp> wycats: and then you can rewrite the compiler to be easy to understand and super-fast too :P
[05:38:02] * dbaupp dreams
[05:38:06] <wycats> dbaupp: lolz
[05:38:10] <wycats> I'm basically a total noob
[05:38:20] <strcat> perfect
[05:38:22] <wycats> I've written compilers before but mostly in the scope of things like handlebars ;)
[05:38:27] <wycats> which is more complicated than it looks, but still
[05:38:33] <strcat> your spirit hasn't been broken yet
[05:39:18] <dbaupp> Write a JIT for handlebars with LLVM for practice, and then rustc should be easy.
[05:39:50] <strcat> LLVM is a lot easier from C++ ;s
[05:40:33] <dbaupp> rewrite LLVM into Rust for practice, and then rustc should be easy.
[05:40:38] <strcat> you could build a good API over the crippled C one but rust doesn't try
[05:44:42] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Connection reset by peer)
[05:46:06] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[05:48:22] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Client exited)
[05:48:40] *** Joins: simlay (simlay@moz-490DE04A.amandrai.net)
[05:48:42] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[05:50:09] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[05:50:34] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[05:50:57] *** Joins: leroux (leroux@moz-421CF1E4.dsl.bell.ca)
[05:51:05] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[05:52:28] *** Quits: mib_6fzpfo (Mibbit@39A6AFF0.A6FC4FF2.1BEE1C35.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[05:52:30] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Ping timeout)
[05:52:47] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[05:52:50] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[05:52:51] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[05:52:59] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[05:54:58] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Ping timeout)
[05:58:40] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[05:59:19] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[05:59:42] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[06:01:23] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[06:04:55] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[06:05:26] *** Quits: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com) (Quit: )
[06:06:32] <o11c> I once wrote a good *python* wrapper for LLVM's C API
[06:07:08] <o11c> and since it's python, it worked against whatever LLVM version you had, anywhere from 3.0 to 3.3
[06:09:16] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[06:11:57] *** Joins: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net)
[06:12:28] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[06:13:31] *** Joins: Cevn (sameer@moz-A91223EF.hfc.comcastbusiness.net)
[06:13:37] <bvssvni> the decision to simplify std::num looks sane
[06:13:41] *** Quits: brianm (brianm@moz-8161EF8D.hsd1.ca.comcast.net) (Quit: Linkinus - http://linkinus.com)
[06:13:56] <bjz> bvssvni: hopefully
[06:14:23] <bvssvni> after playing around with algebraic types, it seems to be difficult to combine efficiency and easiness
[06:14:26] *** Quits: heftig (heftig@moz-7C22D8AB.dip0.t-ipconnect.de) (Ping timeout)
[06:14:33] *** Joins: heftig (heftig@moz-2118892D.dip0.t-ipconnect.de)
[06:15:18] <bjz> bvssvni: algebraic types?
[06:15:30] <bjz> don't you mean type classes/traits
[06:15:32] <bvssvni> with generic traits, it is very easy to over design and it becomes a mental burden
[06:15:37] <bvssvni> bjz: yes
[06:16:17] <bjz> algebraic data types are things defined by enum, for example
[06:16:44] <bvssvni> bjz: I know, it is just I have a meta-model of "algebraic" in my head
[06:17:21] <bvssvni> bjz: everything that is semantically similar to composition gets transformed into "algebraic" :P
[06:17:54] <bjz> yeah, ADTs get thier name because `(T, U)` is a product type, `T | U` is a sum type
[06:18:05] <bjz> there are more examples though
[06:18:50] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Client exited)
[06:19:38] <bvssvni> think I should read up on that
[06:20:04] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[06:21:14] <bjz> bvssvni: in fact in SML, the type of a tuple is written: T * U
[06:21:49] <bvssvni> bjz: hmm
[06:22:12] <bvssvni> bjz: I use '*' in a notion I recently developed
[06:22:28] <bvssvni> bjz: but it means something like generics
[06:22:54] <bjz> bvssvni: to reflect that: the set `S: T * U` contains the cross product of the elements in T and U respectively
[06:23:02] *** Quits: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com) (Ping timeout)
[06:24:29] <bjz> bvssvni: http://en.wikipedia.org/wiki/Algebraic_data_type
[06:24:58] <bvssvni> bjz: what does SML stand for?
[06:25:41] <tautologico> Standard ML?
[06:25:49] <bvssvni> haha
[06:25:51] <bjz> well ML means 'meta language', which refers to it's ability to model languages using ADTs
[06:25:57] <bjz> I think
[06:26:09] <tautologico> no
[06:26:25] <bjz> SML is the standard implementation, but there are other variants
[06:26:35] <tautologico> ML was initially called that because it was created as a meta-language for the LCF theorem prover
[06:26:40] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Connection reset by peer)
[06:26:57] <bjz> http://en.wikipedia.org/wiki/ML_%28programming_language%29
[06:27:03] <bjz> yeah, I was wrong
[06:27:08] <tautologico> but it proved to be useful for general purpose programming
[06:27:27] <bjz> correct translation of ML, but the wrong reasoning behind it
[06:27:29] <bjz> :P
[06:27:43] <tautologico> Standard ML is a language in the ML family, it was an attempt to standardize the many variants at the time (like Common Lisp for lisps)
[06:28:13] <bjz> bvssvni: There is also Caml
[06:28:30] *** Quits: Cevn (sameer@moz-A91223EF.hfc.comcastbusiness.net) (Ping timeout)
[06:28:38] <tautologico> but other variants kept going on, like Caml/OCaml
[06:28:54] <bjz> bvssvni: OCaml is an object oriented version of Caml - rustc was originally written in OCaml actually
[06:29:19] <tautologico> and then F# was created as a variant of OCaml, as an ML language for the .NET platform
[06:29:33] <bjz> bvssvni: which is why it shares some syntactic features and semantics with the ML family
[06:29:42] <bvssvni> I see
[06:30:25] <bvssvni> I am working on a notion to think about data structures - but not too specific to be 'programming'
[06:30:27] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[06:30:33] <bjz> bvssvni: most folks draw analogies between Rust and Haskell, but that's because Haskell was part of a lineage that was also inspired by ML
[06:30:56] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[06:31:08] <bjz> bvssvni: but Rust does have type classes, which Haskell has and ML/SML/OCaml don't have 
[06:31:24] <tautologico> also because the trait system is more similar to Haskell typeclasses than to the ways to structure code more common in the ML family (usually modules)
[06:31:29] <bvssvni> bjz: what is a 'type class'?
[06:31:54] <bjz> tautologico: yep
[06:32:01] <bvssvni> is it that one can implement a trait for different types?
[06:32:04] <bjz> tautologico: rust's modules aren't all that advanced
[06:32:25] <tautologico> rust has modules but only very simple ones... ML modules are quite more powerful (functors etc, OCaml now has first-class modules)
[06:32:38] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[06:32:44] <bjz> tautologico: first class modules ftw!
[06:32:55] <bvssvni> :O
[06:32:55] <bjz> bvssvni: http://en.wikipedia.org/wiki/Type_class
[06:33:25] <bjz> bvssvni: type classes are like OO interfaces, but you can implement them in an ad-hoc way
[06:33:55] <bjz> bvssvni: which reduces the need for adaptor types
[06:34:08] <bvssvni> one day in the future, I hope that Rust can derive the generic constraints from the code
[06:34:48] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[06:34:57] <bvssvni> it complains about it 'no Clone trait', 'no Add trait' etc
[06:35:10] <pyon> Is there anything like weak references for Arcs?
[06:35:18] <tautologico> Clone can be automatically derived
[06:35:33] <bvssvni> tautologico: wasn't what I meant
[06:35:37] <strcat> bvssvni: if it sees foo.clone(), it can't know what trait that's from
[06:35:44] <strcat> you can make multiple traits with the same method name
[06:35:46] <tautologico> for a generic type it may not make sense to derive Add automatically
[06:35:51] <bvssvni> strcat: good point
[06:35:56] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[06:35:59] <strcat> tautologico: I don't think that's what he meant
[06:36:19] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[06:36:37] <strcat> bvssvni: have you used C++? it's the super practical answer to that - just type-check the body for each set of type parameters and see what happens ;p
[06:36:46] <strcat> and that's why people complain about C++ errors
[06:36:56] <strcat> but they're no worse than dynamic typing errors, and you get them statically
[06:37:10] <bjz> bvssvni: C++ templates basically use static duck typing. it's powerful, but also very ugly when you do something erong
[06:37:23] <strcat> bjz: well, it's not that ugly with clang
[06:37:29] <bjz> strcat: yep
[06:37:36] <strcat> it's certainly no worse than a python traceback saying a method is missing or whatever
[06:37:54] <strcat> gcc has always been pretty bad at reporting them
[06:37:59] <strcat> gives too much information by default
[06:38:02] <bvssvni> I prefer ugly against unsafe
[06:38:28] <bvssvni> if you have a 100 000+ lines library it doesn't matter how ugly it is
[06:38:28] <tautologico> template expansion like in C++ is a bad way to do parametric polymorphism
[06:38:38] <strcat> why? it works well
[06:38:52] <strcat> certainly not the only way, and there are pros/cons
[06:39:04] <bjz> strcat: yeah, I agree with you on that
[06:39:05] <pyon> it isn't even really parametric polymorphism... it just happens to be capable of doing parametric polymorphism (and more)
[06:39:06] <o11c> template expansion like in C++ is a pretty good way ... if only they had bounds
[06:39:12] <strcat> pyon: well, neither are traits
[06:39:20] <strcat> size_of, repr, etc.
[06:39:21] <pyon> strcat: sure traits are ad-hoc polymorphism
[06:39:31] <strcat> even generics without traits I mean
[06:39:33] <strcat> in rust
[06:39:36] <strcat> it's not parametric polymorphism
[06:39:40] *** Quits: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca) (Quit: canhtak)
[06:39:56] <strcat> fn foo<T>(x: T) -> uint { size_of::<T>() }
[06:40:09] <pyon> oh well i always avoid that kind of stuff
[06:40:10] <strcat> fn foo<T>(x: T) -> uint { println!("{}", x) } (which is repr/reflect)
[06:40:14] <strcat> er
[06:40:16] <strcat> no -> uint
[06:40:33] <strcat> {:?} *
[06:40:36] <strcat> {} is trait-based ;p
[06:41:31] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[06:43:10] <pyon> i think of size_of and repr as methods of a trait that happens to be impemented for all types... but i get what you mean
[06:43:43] <bvssvni> what is 'repr'?
[06:43:54] *** Joins: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com)
[06:44:07] *** Quits: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com) (Quit: Hack the planet.)
[06:44:19] <strcat> bvssvni: reflection-based printing
[06:44:28] <strcat> the compiler outputs 'visit glue' to implement a reflection visitor thing
[06:44:40] <strcat> it exists for repr only
[06:44:53] <strcat> the use case is debugging but it can be (ab)used for other stuff
[06:45:06] <strcat> for example, rusti here uses it to output results
[06:45:08] <strcat> rusti: 5 + 5
[06:45:14] -rusti- timeout triggered!
[06:45:19] * strcat sighs
[06:45:21] <strcat> rusti: 5 + 5
[06:45:23] -rusti- 10
[06:45:30] <strcat> rusti: struct Foo { x: int } Foo { x: 5 }
[06:45:31] -rusti- main::Foo{x: 5}
[06:45:44] <bjz> bvssvni: {} is resolved statically, {:?} happens dynamically (I think)
[06:45:50] <strcat> {} uses a trait
[06:45:57] <strcat> bjz: {:?} isn't really dynamic
[06:46:04] <bjz> no? ok, neat
[06:46:05] <Amaranth> That doesn't get generated if no one uses it, right?
[06:46:31] <strcat> Amaranth: well... ideally
[06:48:07] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Ping timeout)
[06:48:17] <bjz> bvssvni: did the ADT/type class thing help clarify things?
[06:48:29] <bvssvni> bjz: reading ....
[06:49:05] <bjz> bvssvni: basically `struct` and `enum` declare new ADTs, `trait` declares new type classes
[06:49:18] *** Quits: leroux (leroux@moz-421CF1E4.dsl.bell.ca) (Quit: Leaving)
[06:49:36] *** Joins: Cevn (sameer@moz-A91223EF.hfc.comcastbusiness.net)
[06:50:07] *** Joins: lukem (Mibbit@moz-2B891F75.dyn.iinet.net.au)
[06:50:34] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Quit: csherratt)
[06:50:34] *** Quits: gwty (gwtypc@79FFA4AA.D0E9703E.8A00C703.IP) (Ping timeout)
[06:50:55] *** Quits: Blub\0 (wry@620605B3.71150E1A.237AE2BA.IP) (Ping timeout)
[06:51:09] *** Joins: Blub\0 (wry@620605B3.71150E1A.237AE2BA.IP)
[06:51:32] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[06:52:43] <bvssvni> I find some of the notion in computer science too low level
[06:53:16] <bvssvni> if it basically can be programmed, it is too low level
[06:53:16] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[06:53:37] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Quit: Taking a nap.)
[06:53:46] <bvssvni> I could be just writing the code instead of reasoning much about it
[06:54:05] <bvssvni> the problem is when arising above that level, it becomes ambigious
[06:54:06] *** Joins: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au)
[06:54:28] <bvssvni> so having a notion that strikes the balance between clarity and high level is my goal
[06:54:37] <Edwards> bvssvni: I agreed until I started seriously using languages like Rust and Scala that force the reasoning on you.
[06:54:53] <Edwards> I've found that these kinds of languages take a lot longer to write stuff in
[06:55:05] <Edwards> But once it's done, it's usually pretty much done.
[06:55:27] <Edwards> You don't have to spend months hunting down null dereferences or off-by-one errors or stupid stuff like that
[06:56:00] <Edwards> Because the type systems force the problem to be expressed in a way that the compiler can reason about for you.
[06:56:31] <bvssvni> let's say if I have an interesting problem, but I don't want to go through all the programming
[06:56:50] <bvssvni> I just want to play around with the idea and analyze it
[06:57:10] <bvssvni> whenever I program something, I lock myself to the data structure I use
[06:57:22] <bvssvni> which makes it hard to see other solutions
[06:58:54] <bvssvni> instead of having hash tables, lists, arrays, sets etc. they can all be noted as []*T
[06:59:04] <bvssvni> because they are linear types
[06:59:35] <bvssvni> when you look up one item in a linear type, that equals a specific amount of information
[06:59:45] <bvssvni> which is N, a natural number
[07:00:13] <bvssvni> when an algorithm searches a data structure, it generates information just by navigating through it
[07:00:27] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[07:00:41] <bvssvni> that information can be encoded into the data structure to reduce time of searching
[07:01:00] <bvssvni> that's why every choice I make when programming is a tradeoff
[07:01:09] <bvssvni> between speed and flexibility
[07:01:27] *** Quits: tetsuharu (tetsuharu@moz-A3FEAA56.ap219.ftth.ucom.ne.jp) (Quit: )
[07:02:08] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[07:02:21] <bvssvni> for example a 'bit' can also represent a choice between two options
[07:02:50] <bvssvni> a tuple (X,Y) contains an implicit bit
[07:03:04] *** jorendorff_away is now known as jorendorff
[07:04:10] <dbaupp> A tuple doesn't contain an implicit bit? Either<X, Y> does.
[07:04:21] <dbaupp> (well, Result<X, Y> in modern Rust.)
[07:04:48] <bvssvni> dbaupp: I meant the information you need to identify each element in the tuple
[07:04:49] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Client exited)
[07:05:02] *** Quits: maxli (maxli@moz-F47DD19B.student.cs.uwaterloo.ca) (Quit: Leaving.)
[07:05:10] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[07:05:31] <strcat> bvssvni: hm?
[07:06:03] <bvssvni> like in Huffmann compression, one builds a tree that uses less bits for frequent words
[07:06:22] <bvssvni> the information in the tree corresponds to the size of the data uncompressed
[07:06:46] <bvssvni> the computer spends more time searching, but the total information is about the same
[07:09:03] <bvssvni> I guess this kind of philosphy about information
[07:09:16] <bvssvni> *is
[07:09:31] <Edwards> bvssvni: Have you studied discrete mathematics at all?
[07:09:42] *** Quits: Cevn (sameer@moz-A91223EF.hfc.comcastbusiness.net) (Ping timeout)
[07:10:40] <bvssvni> Edwards: anything particular subject on your mind?
[07:11:06] <bvssvni> Edwards: I live in Norway, so my subjects are not one-to-one matching with US
[07:11:43] <Edwards> I've been watching these videos lately: https://www.youtube.com/watch?v=h_9WjWENWV8&list=PLPcQPsvcfruWF5Ru30xiPX_pjIMhNDeXN
[07:11:54] <Edwards> Seemed like something you might find interesting
[07:12:05] <bvssvni> Edwards: thanks :)
[07:13:19] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Connection reset by peer)
[07:13:29] *** Joins: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP)
[07:13:49] *** Quits: jdavis (jdavis@moz-1BE8A6A1.hsd1.ca.comcast.net) (Ping timeout)
[07:14:07] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[07:14:24] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Quit: This computer has gone to sleep)
[07:15:05] <bvssvni> Edwards: this looks like the usual stuff about computer science I read
[07:15:15] <bvssvni> Edwards: solving difference equations and such
[07:15:33] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[07:16:26] <bvssvni> Edwards: I am familiar with big O notation and have done a lot of discrete analyze
[07:16:58] <bvssvni> Edwards: but I strive to go beyond that, so reason about programs before I write them
[07:17:23] <bvssvni> Edwards: therefore I am looking into abstract algebra
[07:18:02] <bvssvni> Edwards: discrete mathematics works great on algorithms, but not entire programs
[07:18:46] *** jorendorff is now known as jorendorff_away
[07:19:05] *** Joins: deen_ (deen@moz-DCD53577.dip0.t-ipconnect.de)
[07:19:43] <tautologico> bvssvni: http://www.amazon.com/gp/product/0262026651/ref=ox_sc_sfl_title_1?ie=UTF8&psc=1&smid=ATVPDKIKX0DER
[07:19:48] *** Quits: deen (deen@moz-7B78EB6B.dip0.t-ipconnect.de) (Ping timeout)
[07:20:05] <tautologico> there's a long tradition in CS of reasoning about programs
[07:20:26] <depp> Denotational Semantics
[07:20:45] <bvssvni> this looks more like what I am searching for
[07:22:02] <bjz> bvssvni: you might find idris interesting
[07:22:40] <bjz> bvssvni: you can express lots of things in it that you can't express in rust
[07:22:51] *** Quits: ndeine (weechat@FEACE86F.DD5772EA.88820282.IP) (Ping timeout)
[07:23:07] *** Joins: ndeine (weechat@4C8CA1FF.9F6EC2B4.9E74FAD6.IP)
[07:23:07] <bjz> (although rust allows you to express things that idris can't, in respect to memory management)
[07:23:32] <bvssvni> bjz: thanks again!
[07:23:34] <tautologico> semantics, verification techniques like Floyd-Hoare logics, ideas like "correct by construction" advocated by Dijkstra, etc
[07:24:37] *** Joins: Ms2ger (Ms2ger@53A418F8.CD932C3B.187A1082.IP)
[07:25:23] <tautologico> dependent typing is very interesting, I haven't had the time to use Idris but I have a bit of experience with Agda and Coq
[07:25:49] <b> ATS is also rather interesting if you find Idris fun. 
[07:25:58] <bjz> tautologico: they are trying to make well-defined dependent types practical for real world use
[07:26:25] <carllerche> is it possible to implement traits for str?
[07:26:51] <bjz> carllerche: of course, that's how std::str is done
[07:26:58] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[07:27:01] <carllerche> i should just go look there
[07:27:03] <tautologico> bjz: I know about the project and some people behind it, but didn't use it yet
[07:27:10] * bjz can imagine a future systems lang with proper dependant types and theorum proving
[07:27:17] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Quit: This computer has gone to sleep)
[07:27:18] <carllerche> just doing impl MyTrait for str seems to error out
[07:27:30] * bjz doesn't think idris is it though
[07:27:56] <bjz> carllerche: try impl<'a> Trait for &'a str {}
[07:27:58] <carllerche> ah, one must specify a lifetime to implement for &str
[07:28:06] <tautologico> the problem is how much complexity can you accept in the type system
[07:28:14] <bjz> carllerche: or impl Trait for ~str {}
[07:28:29] <bjz> tautologico: well, Rust already takes on some complexity
[07:28:37] <tautologico> if the systems language has to reason about memory, things can get pretty complicated quickly
[07:28:51] <bjz> yeah
[07:29:28] <bjz> I feel though that once Rust has raised the bar higher for systems langs, others will push it further
[07:29:39] <depp> I think the traditional techniques for reasoning about memory are rather complicated but linear logic is not that complicated
[07:29:53] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[07:31:13] <Gracenotes> I'm dealing with a Rust-wrapped C library that expects to be passed callbacks as traits. Is the simplest way to do this making a crate-local unit type? seems like a bit of indirection.
[07:31:37] <Gracenotes> (I don't need any state, for now... I suppose it would stop being a unit type at that point)
[07:31:39] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[07:31:40] <tautologico> anyway it's terribly late here, good night
[07:31:54] <bjz> tautologico: I think it is several years out for that stuff though
[07:32:20] <bvssvni> tautologico: good night
[07:32:25] <bjz> night o/
[07:32:28] <tautologico> bjz: probably, if ever
[07:32:31] <tautologico> see ya
[07:32:37] <bjz> never say never :)
[07:33:22] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[07:37:57] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[07:38:12] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Quit: This computer has gone to sleep)
[07:39:14] *** Quits: ndeine (weechat@4C8CA1FF.9F6EC2B4.9E74FAD6.IP) (Quit: WeeChat 0.4.2)
[07:40:55] *** Joins: pnathan (Adium@moz-A8921E45.tukw.qwest.net)
[07:42:27] *** Joins: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP)
[07:42:28] *** Quits: Benvie_ (brandon@5FD20F9A.53D07D95.EFF8B7BF.IP) (Client exited)
[07:43:15] *** Quits: pnathan (Adium@moz-A8921E45.tukw.qwest.net) (Ping timeout)
[07:44:21] *** Joins: samx (sami@moz-D9F3E0AE.pp.htv.fi)
[07:44:27] *** Joins: pnathan (Adium@moz-A8921E45.tukw.qwest.net)
[07:45:41] <carllerche> I have trait Foo w/ only 1 fn that has a default impl. I have trait Bar that inherits from Foo. I have struct A that has an implementation for Bar. rustc is saying that there is no implementation of trait Foo for struct A
[07:45:49] <carllerche> not sure if that should work
[07:46:10] *** Quits: samx (sami@moz-D9F3E0AE.pp.htv.fi) (Ping timeout)
[07:47:43] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Quit: csherratt)
[07:48:19] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[07:49:06] <dbaupp> carllerche: you currently need impl Foo for A {} explicitly
[07:49:13] <dbaupp> I don't imagine that changing.
[07:49:44] <carllerche> dbaupp: what if the sub trait provides the implementation for the super trait w/ other abstract fns?
[07:50:28] <dbaupp> That's... not possible?
[07:50:45] <carllerche> oh well
[07:50:51] <dbaupp> trait inheritance isn't quite the same as OOP inheritance
[07:51:43] <carllerche> i'm trying to get a handle on what boilerplate is required and what i can refactor out
[07:51:49] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[07:53:34] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[08:01:16] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[08:02:57] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[08:05:56] *** Quits: Erik_ (Erik_S@moz-E7E31D21.hlrn.qwest.net) (Ping timeout)
[08:05:59] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[08:07:47] *** Quits: lukem (Mibbit@moz-2B891F75.dyn.iinet.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[08:08:12] *** Quits: Ms2ger (Ms2ger@53A418F8.CD932C3B.187A1082.IP) (Quit: bbl)
[08:08:18] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[08:09:52] *** Joins: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru)
[08:10:36] *** Joins: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net)
[08:12:30] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[08:12:51] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[08:13:34] *** Joins: gwty (gwtypc@79FFA4AA.D0E9703E.8A00C703.IP)
[08:14:37] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[08:15:54] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[08:21:18] *** Joins: StarLight (StarLight@moz-D32EDF8E.dynamic.avangarddsl.ru)
[08:21:22] *** Quits: StarLight (StarLight@moz-D32EDF8E.dynamic.avangarddsl.ru) (Quit: StarLight)
[08:21:58] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[08:23:43] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[08:26:07] *** Quits: depp (depp@500BAFC1.53465674.3C05E6CB.IP) (Quit: bye)
[08:28:59] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:29:14] *** Quits: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:29:14] *** Quits: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com) (Ping timeout)
[08:29:54] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[08:31:36] *** Quits: azita (Azita@moz-C1FB2A8.hsd1.ca.comcast.net) (Quit: azita)
[08:32:25] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[08:34:16] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[08:34:54] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[08:43:04] *** Joins: StarLight (StarLight@moz-D32EDF8E.dynamic.avangarddsl.ru)
[08:43:14] *** Parts: pnathan (Adium@moz-A8921E45.tukw.qwest.net) ()
[08:43:43] *** Joins: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP)
[08:45:01] *** Joins: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:45:02] *** Joins: rusti (rusti@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:45:16] *** Joins: rustilite (rustilite@moz-54F7FD49.cpe.net.cable.rogers.com)
[08:47:08] *** Joins: remen (Mibbit@moz-BF847080.ias.bredband.telia.com)
[08:50:10] *** Quits: remen (Mibbit@moz-BF847080.ias.bredband.telia.com) (Quit: http://www.mibbit.com ajax IRC Client)
[08:50:14] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[08:52:19] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[08:52:19] *** Quits: glennsl (textual@moz-5D7B804F.getinternet.no) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[08:52:29] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[08:54:02] *** Quits: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru) (Ping timeout)
[08:55:50] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[08:58:03] <pyon> What does #[unsafe_no_drop_flag] mean? :-O
[08:58:45] *** Quits: vadimcn (chatzilla@FB06B64.76F9E272.DA40C4B3.IP) (Client exited)
[08:59:52] *** Joins: oberstet (quassel@moz-287E3326.dynamic.mnet-online.de)
[09:01:56] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[09:03:40] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[09:04:41] <eddyb> pyon: if you impl Drop on a structure without that attribute, it will have a byte at the end, 1 at creation
[09:05:57] <eddyb> pyon: we zero data to cancel cleanup (like, when you move out of it), it works for pointers because the free code checks for ptr == null and ignores it. and a similar thing happens with that flag
[09:06:16] <eddyb> (if flag == 0 {skip_drop/free})
[09:07:26] <pyon> Oh.
[09:08:07] <eddyb> pyon: you have to prevent double free yourself if you add that attribute
[09:08:52] <eddyb> (Rc does it to keep itself small, and I think it checks for ptr == null in its drop impl)
[09:09:19] <Gracenotes> how can I make a top-level string constant?
[09:10:13] <eddyb> Gracenotes: "foo" has 'static lifetime, if that's what you're asking
[09:10:24] <eddyb> (it's in .rodata like C/C++)
[09:10:28] <Gracenotes> ah. what is the syntax for giving it a name?
[09:10:40] <pyon> static foo: &'static str = "foo"; // perhaps like this?
[09:10:47] <eddyb> Gracenotes: you don't give it a name, but you can put it in a static ^
[09:11:01] <eddyb> (foo won't contain "foo", but point to it)
[09:11:20] <pyon> you cannot have unboxed strings anyway
[09:12:24] <Gracenotes> static things cannot be inferred?
[09:12:35] <eddyb> Gracenotes: no. it's possible, but not implemented
[09:12:56] <eddyb> (possible as in, use the uninfered type of the rhs)
[09:13:03] <Gracenotes> hm. I see there used to be a const keyword. having the storage makes more sense, perhaps.
[09:13:23] <eddyb> Gracenotes: everything is const unless mut
[09:13:34] <eddyb> s/const/immutable/ in recent terminology
[09:14:08] <Gracenotes> ah, so Rust wasn't always immutable by default?
[09:14:16] *** Joins: doomlord_ (servitor@moz-D9C46C01.range86-184.btcentralplus.com)
[09:14:21] <eddyb> maybe not. I wasn't around to know
[09:15:03] <eddyb> pyon: I want to be able to do struct StackString<N> {priv length: uint, priv contents: [u8, ..N]} - and abuse uninitialized memory (LLVM has "undef" values) to get cheap string operations in a limited space
[09:15:10] <Gracenotes> so the apostrophe in 'static is strange, but I do see how it's &'static str
[09:15:16] <pyon> eddyb: :-O
[09:15:36] <eddyb> pyon: well, N: static uint or static N: uint
[09:15:44] <pyon> Gracenotes: 'a is a lifetime, in general
[09:15:50] <pyon> Gracenotes: 'static means static lifetime
[09:16:27] <eddyb> that feature (for generics) is not directly related to strings, but enables them, in a way :)
[09:16:31] <pyon> eddyb: We do not have generics parametrized by integers (or, more generally, non-types), right?
[09:16:45] <eddyb> pyon: not yet, that's what I'm waiting for
[09:17:06] <pyon> eddyb: Then perhaps unboxed vectors would not have to be hardcoded into the language!
[09:17:39] <eddyb> pyon: DST needs them to be in the language
[09:17:48] <eddyb> pyon: but it means you can do more stuff with them!
[09:17:51] <pyon> DST?
[09:18:08] <eddyb> dynamically sized types. read DST5 if you want more info, that's most likely what we'll get
[09:18:08] *** Joins: remen (petter.rem@moz-BF847080.ias.bredband.telia.com)
[09:18:10] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Connection reset by peer)
[09:18:25] <pyon> eddyb: Oh, nice, sounds interesting.
[09:19:05] <pyon> I have always wanted dynamically sized types in C++ (e.g., a struct whose first and second members are size_t's, and whose third and fourth members are arrays whose sizes are that size_t).
[09:19:18] <pyon> s/that size_t/those size_t's/
[09:19:21] <eddyb> pyon: one trick DST has is coercing [T, ..N] to [T], even when it's nested in a structure
[09:19:33] <pyon> :-O
[09:20:03] <eddyb> so Rc::new([0, 1, 2, 3]) has type Rc<[int, ..4]>
[09:20:24] <eddyb> that will coerce (without changing the internal allocated RcBox) to Rc<[int]>
[09:20:26] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[09:21:06] <pyon> Dang, so many notions of indirection...
[09:22:10] <pyon> Are there any plans to add weak references to (|Mutex|RW)Arcs?
[09:22:15] *** Joins: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[09:22:23] <eddyb> pyon: you get something like *RcBox<[int, ..4]> -> *RcBox<[int]> (the latter is the original pointer and the dynamic length, 4)
[09:22:35] <eddyb> pyon: hmm, I don't know. ask strcat
[09:23:15] <strcat> pyon: I am not sure what the interaction is with atomic reference counting
[09:23:19] <strcat> I expect you have to do it differently
[09:24:01] *** Quits: dmac1 (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[09:24:52] <strcat> pyon: http://ix.io/9YH reasoning about this is pretty easy ;p
[09:24:58] <eddyb> OMG https://github.com/sfackler/rust-phf
[09:25:04] <strcat> throw in a second refcount field for weak refs and not so much afaict
[09:25:15] <eddyb> why is this not on reddit?
[09:25:36] <pyon> strcat: Let me see.
[09:25:46] <eddyb> (though LLVM will soon be able to do it my itself)
[09:26:03] <pyon> Dang, now I have to learn atomics... :-|
[09:26:11] <strcat> pyon: it's a PITA to reason about :|
[09:26:24] <eddyb> pyon: if you use conservative operations, it might be slow, but it's harder to get wrong
[09:26:28] <strcat> pyon: http://en.cppreference.com/w/cpp/atomic/memory_order
[09:26:37] <eddyb> s/operations/ordering/
[09:26:49] <strcat> pyon: so, an atomic operation is guaranteed to be atomic - it won't be split
[09:26:53] <eddyb> sfackler: oooh, strings, LLVM won't be able to work with that. I like it :D
[09:26:58] <strcat> pyon: but the *ordering* with relaxed ones is arbitrary
[09:27:05] <pyon> Oh.
[09:27:07] <strcat> pyon: because consider that CPUs do speculative execution
[09:27:17] <strcat> pyon: they will assume there are no memory dependencies with relaxed atomics
[09:27:31] <strcat> so they can storm ahead
[09:27:54] <strcat> anyway you can use sequential consistency but... you want more relaxed ordering for lighter instructions
[09:28:10] *** Quits: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au) (Quit: Leaving.)
[09:28:26] <pyon> Concurrency is hard, let's go shopping! :-P
[09:28:43] <pyon> I mean, I am going to read it thoroughly until I understand it.
[09:29:03] *** Quits: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net) (Quit: carllerche)
[09:29:03] <strcat> I understand it but struggle to reason about it when it's anything but something super simple
[09:29:06] <Ralith> eddyb: how can you have PHFs for strings?
[09:29:51] <strcat> pyon: the hard part is using your understand to prove that some code works... very easy to miss something :(
[09:30:01] * strcat would rather copy libc++
[09:30:26] <eddyb> Ralith: you can get close. ask sfackler for more
[09:30:39] <pyon> strcat: Yep, ironically concurrency what needs proofs the most (writing correct sequential code is comparatively a walk in the park), but it is also precisely where proofs are the hardest.
[09:30:51] * Ralith guesses that the hash function only works on a static set of inputs and is adjusted such that is perfect for them
[09:30:58] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[09:31:15] <Ralith> pyon: that seems like exactly what you'd expect, not really ironic
[09:31:47] *** flaper87|afk is now known as flaper87
[09:32:27] <Ralith> if the proofs were easy, you wouldn't need to depend very much upon strict formalizations of them
[09:33:10] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[09:33:45] <eddyb> Ralith: it's a syntax extension, it only does static sets of inputs
[09:34:58] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[09:35:09] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[09:35:24] <Ralith> eddyb: well that seem straightforward enough, then
[09:35:38] *** Quits: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[09:35:53] <Ralith> what's so exciting? just having nice matching on strings built in?
[09:36:10] <eddyb> Ralith: we already have matching on strings
[09:36:37] <eddyb> Ralith: this is an optimization, and it's one of the first loadable syntax extensions we have :D
[09:37:16] <Ralith> slightly nicer matching on strings, then
[09:38:06] <yuriks> strcat: I'm curious about the landing-pad thing from earlier. What is it that would cause failures? Doesn't rust use a no-cost exception scheme on x64?
[09:39:07] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[09:40:09] <eddyb> Ralith: it's not nicer, it's faster
[09:40:25] <Ralith> speed is one of the things that makes a feature nice
[09:42:11] <eddyb> rusti: static foo: Option<int> = Some(0); foo
[09:42:16] -rusti- Some(0)
[09:42:38] <eddyb> hmpf, how does that work? are struct/enum constructors whitelisted?
[09:42:59] <eddyb> rusti: static foo: Option<|int| -> int> = Some(|x| x*x); foo
[09:43:02] -rusti- pastebinned 7 lines of output: http://ix.io/9YI
[09:43:14] <eddyb> rusti: static foo: Option<'static |int| -> int> = Some(|x| x*x); foo
[09:43:23] -rusti- failed to pastebin 6 lines of output
[09:43:32] <eddyb> rusti: static foo: Option<('static |int| -> int)> = Some(|x| x*x); foo
[09:43:35] -rusti- pastebinned 7 lines of output: http://ix.io/9YJ
[09:43:37] <eddyb> bleah
[09:43:57] <eddyb> rusti: type F = 'static |int| -> int; static foo: Option<F> = Some(|x| x*x); foo
[09:43:59] -rusti- pastebinned 7 lines of output: http://ix.io/9YK
[09:44:10] <eddyb> OH
[09:44:22] <eddyb> rusti: static foo: Option<('static |int| -> int)> = Some(|x: int| x*x); foo
[09:44:23] -rusti- pastebinned 7 lines of output: http://ix.io/9YM
[09:44:26] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Quit: )
[09:44:37] <eddyb> pffft
[09:45:08] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[09:45:28] *** Joins: kcii (o0@moz-D77E1EA9.cable.mindspring.com)
[09:47:36] <strcat> yuriks: zero-cost exceptions means table-based unwinding
[09:47:43] <strcat> i.e. no instructions executed in the fast path
[09:47:56] <strcat> but massive DWARF unwinding tables (corresponding to LLVM landing pads) output
[09:48:43] *** Joins: lpy (lpy@481D06B8.DFDBB866.E99F7FDB.IP)
[09:50:48] <yuriks> strcat: so the landing pads are the unwind tables? I had the impression they were something in the style of SJLJ because you said they crash code
[09:51:09] <strcat> yuriks: no I said the segmented stack preludes could
[09:51:20] <strcat> yuriks: landing pads become unwind tables
[09:51:28] <strcat> they're the exceptional unwind path
[09:51:45] <strcat> sjlj is done differently in LLVM, not with landing pads
[09:52:00] *** Quits: lpy (lpy@481D06B8.DFDBB866.E99F7FDB.IP) (Connection reset by peer)
[09:52:16] *** Joins: lpy (lpy@481D06B8.DFDBB866.E99F7FDB.IP)
[09:52:20] <yuriks> hm, ok. But then, why doe disabling landing pads remove the crash potencial? that's what I'm confused about
[09:52:28] * strcat shrugs
[09:53:22] <flaper87> where can I find the documentation for `ref` ?
[09:53:23] <yuriks> hm. Well, I diffed the generate assembly with and without the option and the output was identical. But it's a really trivial program so I assume everything was inlined out
[09:53:34] <flaper87> (if there's any)
[09:53:52] <strcat> flaper87: goes on patterns in the same places as mut and makes them bind by-ref
[09:53:56] <strcat> dunno if there are docs
[09:54:12] <kcii> If anyone has a moment, could someone look at this and tell me if I'm doing something obviously wrong? http://pastebin.com/LnLPvraV
[09:54:35] <kcii> I'm getting task failure from the standard library but I don't know what's wrong.
[09:54:36] <strcat> [ref] [mut] identifier
[09:54:41] <strcat> is the pattern binding syntax
[09:54:44] <strcat> where ref/mut are optional
[09:54:47] *** Joins: lpy_ (lpy@F9486B15.DFDBB866.E99F7FDB.IP)
[09:54:53] *** Quits: lpy (lpy@481D06B8.DFDBB866.E99F7FDB.IP) (Ping timeout)
[09:54:55] *** Quits: wilmoore (wilmoore@moz-71431C3A.hsd1.co.comcast.net) (Quit: wilmoore)
[09:54:55] <flaper87> strcat: gotcha
[09:54:57] <flaper87> thanks
[09:55:26] <strcat> rusti: let x = (1, 2); let (a, _) = x; a
[09:55:31] -rusti- 1
[09:55:35] <strcat> rusti: let x = (1, 2); let (ref a, _) = x; *a
[09:55:36] -rusti- 1
[09:55:44] <strcat> rusti: let x = (1, 2); let (mut a, _) = x; a = 10; a
[09:55:45] -rusti- <anon>:10:30: 10:35 warning: value assigned to `a` is never read, #[warn(dead_assignment)] on by default
[09:55:45] -rusti- <anon>:10         let x = (1, 2); let (mut a, _) = x; a = 10; a
[09:55:45] -rusti-                                        ^~~~~
[09:55:45] -rusti- 10
[09:55:53] <strcat> rusti: let mut x = (1, 2); let (ref mut a, _) = x; a = 10; a
[09:55:55] -rusti- pastebinned 7 lines of output: http://ix.io/9YP
[09:56:04] <strcat> rusti: let mut x = (1, 2); let (ref mut a, _) = x; *a = 10; x
[09:56:05] -rusti- (10, 2)
[09:56:11] <yuriks> strcat: I'll grow my code and experiment. Thanks for bearing with me :)
[09:56:34] * strcat wonders if mut ref mut a works
[09:56:46] <strcat> rusti: let mut x = (1, 2); let (mut ref mut a, _) = x; a = &mut 10;
[09:56:48] -rusti- pastebinned 9 lines of output: http://ix.io/9YQ
[09:56:59] <strcat> rusti: let mut x = (1, 2); let (ref mut a, _) = x; a = &mut 10;
[09:57:01] -rusti- pastebinned 10 lines of output: http://ix.io/9YR
[09:57:04] <strcat> missing feature ;p
[09:57:36] *** Joins: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr)
[09:58:00] <adridu59> is there any other use case to lifetime annotations than functions?
[09:58:04] <flaper87> strcat: hehe, thanks for the examples. very useful
[09:58:15] *** Joins: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au)
[09:58:37] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[10:02:01] <eddyb> when I was playing with closures in statics, I forgot to say, I want unboxed closures in statics (and simple right-to-left inference) - then it would be trivial to implement specialized hash functions :D
[10:03:01] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[10:04:49] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[10:05:35] *** Joins: lpy (lpy@D6988B34.F4539CBC.E99F7FDB.IP)
[10:05:49] *** Joins: jackneill (jackneill@moz-E9D68037.pool.digikabel.hu)
[10:05:59] *** Quits: lpy_ (lpy@F9486B15.DFDBB866.E99F7FDB.IP) (Ping timeout)
[10:06:08] *** Quits: lpy (lpy@D6988B34.F4539CBC.E99F7FDB.IP) (Quit: Leaving...)
[10:09:02] *** Joins: Matthias247 (Miranda@moz-BDD35EC0.hsi5.kabel-badenwuerttemberg.de)
[10:11:15] <jensnockert> If I wanted to write a parser in Rust, are there any libraries to help me?
[10:11:53] <jensnockert> I have tried google, but cannot find anything 0.9 era.
[10:12:01] <mcpherrin> There's ragel output for Rust, I think, though I doubt it's up to date
[10:12:32] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Ping timeout)
[10:12:32] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[10:13:48] <jensnockert> Yeah, it seemed old.
[10:15:10] *** Joins: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP)
[10:15:25] *** Quits: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP) (Client exited)
[10:15:34] *** Joins: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP)
[10:26:31] <flaper87> Has anyone hit this before? https://github.com/FlaPer87/rust-proton/blob/master/examples/send.rs#L41 ?
[10:26:37] <flaper87> the definition is here: https://github.com/FlaPer87/rust-proton/blob/master/src/proton/proton.rs#L262
[10:27:38] *** Quits: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP) (Ping timeout)
[10:29:38] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[10:31:50] <flaper87> erm, this one is the definition: https://github.com/FlaPer87/rust-proton/blob/master/src/proton/proton.rs#L327
[10:32:14] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[10:32:35] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[10:33:22] <eddyb> flaper87: reduce the testcase
[10:33:46] <flaper87> eddyb: ?
[10:33:50] <eddyb> flaper87: then run env RUSTLOG=rustc::middle::trans rustc testcase.rs
[10:33:54] <flaper87> eddyb: this is the call that fails to compile: https://github.com/FlaPer87/rust-proton/blob/master/examples/send.rs#L43
[10:33:55] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[10:34:06] <eddyb> flaper87: yes, remove everything that compiles
[10:34:06] <flaper87> eddyb: oh, lemme try that
[10:34:11] *** Joins: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net)
[10:34:16] <flaper87> eddyb: thanks
[10:34:17] <eddyb> sorry, RUST_LOG not RUSTLOG
[10:34:26] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[10:34:33] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[10:34:35] <eddyb> I hope it's not my fault
[10:35:03] *** Joins: tiffany (kawaii@moz-FC0DB29D.dhcp.embarqhsd.net)
[10:35:36] <eddyb> flaper87: it's your fault, LOL
[10:35:42] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[10:36:00] <eddyb> I'm amazed it's not caught earlier, there must be a serious compiler bug or you're overusing unsafe
[10:36:18] <eddyb> flaper87: https://github.com/FlaPer87/rust-proton/blob/master/src/proton/proton.rs#L46
[10:36:44] <eddyb> flaper87: c_void is an u8, as per clang (it used to be a zero-sized type, but LLVM wasn't optimizing it well enough)
[10:36:56] <eddyb> flaper87: it's not an opaque pointer, that would be *c_void
[10:37:19] <eddyb> all of these are wrong https://github.com/FlaPer87/rust-proton/blob/master/src/proton/proton.rs#L14-L53
[10:38:18] <eddyb> flaper87: this is how the compiler lets you create a c_void https://github.com/FlaPer87/rust-proton/blob/master/src/proton/proton.rs#L216
[10:40:02] <flaper87> oh, mmhh, gtk. I'll change all those types then.
[10:40:27] <flaper87> I wanted to avoid implementing every single struct of that library. I'll implement just the ones that are really needed
[10:40:34] <flaper87> but first I wanted to get it working
[10:40:37] <eddyb> flaper87: use *c_void for opaque pointers
[10:40:38] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[10:40:39] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[10:40:41] <eddyb> flaper87: not c_void
[10:40:51] <flaper87> eddyb: ok, I will. Thanks :)
[10:41:13] <strcat> well, use *c_void when C uses it
[10:41:37] <strcat> you probably want to make an opaque type for the opaque types it has so you get type errors if you pass the wrong thing
[10:41:40] <eddyb> enum OpaqueStruct {} and *OpaqueStruct also works
[10:42:05] <eddyb> (zero-sized and you can't create it safely in Rust)
[10:42:23] <strcat> I prefer using *u8 instead of *c_void when what it means is 'bytes' though
[10:42:28] <strcat> since rust uses *u8 for that
[10:42:53] <eddyb> strcat: we need to disallow c_void in arguments, return - I KNOW HOW :D
[10:42:58] <eddyb> strcat: we make c_void a DST :)))
[10:43:02] <flaper87> eddyb: that worked, thanks
[10:43:14] <eddyb> a DST that is represented as i8 in LLVM
[10:43:23] <eddyb> acrichto: ^^^
[10:48:03] <flaper87> strcat: well, that PnBytes there is not actually bytes but another struct with more things in it. (if that's what you were referring to)
[10:48:26] *** Quits: Ycros (ycros@moz-E0894734.ycros.org) (Ping timeout)
[10:48:48] *** Quits: gwty (gwtypc@79FFA4AA.D0E9703E.8A00C703.IP) (Ping timeout)
[10:48:56] <adridu59> is LTO enabled by default?
[10:49:20] *** Joins: chunyang (Mibbit@B65576E2.7EB6399.C8ED823E.IP)
[10:49:24] <eddyb> adridu59: no. -Z lto
[10:49:28] <flaper87> adridu59: no
[10:49:34] <adridu59> k thanks
[10:49:34] <flaper87> adridu59: erm, what eddyb said
[10:49:36] <flaper87> :)
[10:49:41] <eddyb> flaper87: you should've been passing it with indirection
[10:49:52] <adridu59> there's a user that has a problem with the associated dll on windows https://github.com/mozilla/rust/issues/11651#issuecomment-32705104
[10:49:52] <eddyb> flaper87: how are the C functions defined?
[10:50:05] <flaper87> eddyb: lemme get that link for ya!
[10:50:28] <eddyb> flaper87: as in, PnBytes* or PnBytes?
[10:50:35] <eddyb> (where PnBytes is a structure)
[10:50:40] <flaper87> eddyb: int pn_data_put_string(pn_data_t *data, pn_bytes_t string)
[10:50:41] *** Joins: Ycros (ycros@moz-E0894734.ycros.org)
[10:50:57] <eddyb> flaper87: interesting. pn_bytes_t is a struct, for sure?
[10:51:13] <eddyb> then you need it to be the right size in rust or it will break *for sure*
[10:51:31] <eddyb> if not at compile time, you'll be breaking calling conventions at runtime
[10:51:40] *** Joins: claude (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de)
[10:52:01] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[10:52:19] *** Quits: chunyang (Mibbit@B65576E2.7EB6399.C8ED823E.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[10:53:25] <flaper87> eddyb: http://svn.apache.org/repos/asf/qpid/proton/trunk/proton-c/include/proton/types.h
[10:53:45] <flaper87> mmh, one of my changes that was approved yday hasn't be picked by bors. 
[10:53:45] <eddyb> priv value: &'a util::Void, // yay std::fmt likes to forget types
[10:55:26] *** Quits: claude (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de) (Quit: http://www.mibbit.com ajax IRC Client)
[10:55:55] * flaper87 kicks bors legs
[10:56:03] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[10:56:18] *** Joins: claude (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de)
[10:56:36] *** Quits: twi (Adium@moz-512229A7.lns9.lon.bigpond.net.au) (Quit: Leaving.)
[10:57:03] *** Quits: adridu59 (Mibbit@moz-E1FF077C.rev.numericable.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[10:57:36] <flaper87> strcat: you've r+ powers, right? could you re-approve this? https://github.com/mozilla/rust/pull/11649 
[10:57:42] <flaper87> I think bors is ignoring it
[10:57:49] <strcat> I don't think he is
[10:57:54] <flaper87> oh, mmh
[10:57:56] <strcat> flaper87: http://buildbot.rust-lang.org/bors/bors.html
[10:57:58] <flaper87> then I'll STFU
[10:58:15] <flaper87> like I said, I'll STFU
[10:58:17] <flaper87> :P
[10:58:25] <flaper87> I forgot to check that one
[10:58:51] *** Joins: nkoep (nik@moz-7D0E86DA.pool.mediaways.net)
[11:00:59] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[11:03:26] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[11:05:08] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[11:07:09] *** Joins: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se)
[11:08:09] *** Joins: ricepuddin (graham@moz-7D68765A.cable.virginm.net)
[11:08:13] *** Joins: Florob (Florob@moz-39532932.de)
[11:08:33] <eddyb> please don't tell me I need variadic generics to implement this argument contraption. wait, hmm, I think I can use &[&Trait] instead
[11:09:00] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[11:14:50] *** Quits: pzol (pzol@moz-553BEE64.dynamic.chello.pl) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[11:17:12] *** Quits: claude (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de) (Quit: http://www.mibbit.com ajax IRC Client)
[11:21:12] <diverse> eddyb: wait, you can do that? The '&[&Trait]' thing?
[11:21:26] <eddyb> diverse: of course I can :)
[11:22:06] <diverse> nice
[11:23:00] <eddyb> trait FormatMode<R> {fn fmt<R, F: FormatMode>(&self, s: &str, f: |&mut F| -> R) -> R;}
[11:23:07] <eddyb> I hope I'm close
[11:24:46] *** Quits: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP) (Client exited)
[11:28:00] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Ping timeout)
[11:28:14] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[11:33:13] *** Joins: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP)
[11:34:40] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[11:36:22] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[11:39:17] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[11:40:57] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[11:44:28] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[11:44:58] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[11:45:34] *** Joins: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru)
[11:46:46] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[11:48:49] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[11:56:21] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[11:58:02] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[11:58:15] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[11:59:27] *** Quits: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com) (Quit: Leaving)
[11:59:38] *** Joins: johnsoft (johnsoft@moz-7E09A266.neo.res.rr.com)
[12:01:27] *** Joins: mz2 (Mibbit@moz-1B2F7BC2.threembb.co.uk)
[12:03:02] *** Quits: z0w0 (zack@moz-87AABEA0.lnse1.woo.bigpond.net.au) (Client exited)
[12:04:32] *** Quits: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP) (Ping timeout)
[12:09:31] *** Quits: calien (calien@moz-A9D07610.bstnma.fios.verizon.net) (Quit: WeeChat 0.4.2)
[12:17:03] <mz2> hi all - i'm trying my luck cross-compiling Rust for iOS using the instructions on the wiki. I'm getting stuck on something other than what is listed as known issues: "No rule to make target" for llvm
[12:17:45] <mz2> i then tried just regular ./configure && make and also getting the same. the problem appears to be some build configuration path handling thing, somewhere what is assumed to be a relative path is actually passed as an absolute path:
[12:17:53] *** Joins: pzol (pzol@moz-553BEE64.dynamic.chello.pl)
[12:17:54] <mz2> make[2]: *** No rule to make target `/Users/mz2/Projects/External/rust/src/llvm/Users/mz2/Projects/external/rust/x86_64-apple-darwin/llvm/Makefile', needed by `Makefile'.  Stop.
[12:18:10] <mz2> the correct path would be /Users/mz2/Projects/external/rust/x86_64-apple-darwin/llvm/Makefile
[12:18:16] <mz2> any ideas of where to look?
[12:18:41] *** Quits: pzol (pzol@moz-553BEE64.dynamic.chello.pl) (Quit: Textual IRC Client: www.textualapp.com)
[12:21:36] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[12:25:55] *** Quits: robarnold (rob@moz-59F6B5.hfc.comcastbusiness.net) (Ping timeout)
[12:30:53] *** Joins: edww (Mibbit@B611A123.E2BC2D9F.1D660E71.IP)
[12:32:31] *** Quits: edww (Mibbit@B611A123.E2BC2D9F.1D660E71.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[12:33:15] *** Joins: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com)
[12:34:30] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[12:34:51] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[12:36:43] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[12:37:52] *** Joins: eibwen (kvirc@moz-DB2F0689.dip0.t-ipconnect.de)
[12:38:56] *** Joins: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com)
[12:39:37] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[12:40:20] <eddyb> strcat: any idea if [0u8, ..64] on the stack will be optimized into [undef, ..64] by LLVM if there is no read-before-write?
[12:40:54] <eddyb> (this is about printing numbers in an arbitrary base without allocating on the heap)
[12:41:21] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[12:42:38] <Tobba> pretty sure LLVM has a decent dead write detector
[12:43:08] <strcat> eddyb: likely, if you don't make confusing aliases
[12:43:23] <eddyb> strcat: sweet :D
[12:43:52] <Tobba> I guess you could also do
[12:44:07] <Tobba> [unsafe{uninit<u8>()}, ..64] if you want to be sure
[12:44:14] <Tobba> uninit::<u8>*
[12:44:30] <eddyb> Tobba: yes, but then you have to track the invariant yourself
[12:44:30] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Connection reset by peer)
[12:44:31] <strcat> well you can be sure by looking at the IR
[12:44:36] <strcat> and not doing it if it's not necessary
[12:45:45] <mz2> this llvm compilation issue is reproducible just with ./configure && make on a fresh git clone of the repo on my machine. seems could be something to do with case sensitive file systems and a more generic problem with building llvm :P
[12:46:16] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[12:46:22] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Ping timeout)
[12:49:37] <eddyb> rusti: let v: [&Clone] = [&0, &1u]; print!("{:?} ", v);
[12:49:43] -rusti- timeout triggered!
[12:49:45] <eddyb> it better work :/
[12:49:50] <eddyb> rusti: let v: [&Clone] = [&0, &1u]; print!("{:?} ", v);
[12:49:56] -rusti- pastebinned 10 lines of output: http://ix.io/9YT
[12:50:18] <eddyb> rusti: let v: &[&Clone] = [&0, &1u]; print!("{:?} ", v);
[12:50:20] -rusti- pastebinned 7 lines of output: http://ix.io/9YU
[12:50:31] <eddyb> rusti: let v: &[&Clone] = [&0i, &1u]; print!("{:?} ", v);
[12:50:33] -rusti- pastebinned 10 lines of output: http://ix.io/9YV
[12:50:37] <eddyb> was this fixed, by any chance?
[12:50:53] <mz2> interesting. problem goes away if i move the file away from Projects/external.
[12:51:14] <dbaupp> eddyb: there was a bug filed about coercion not working through vectors, check to see if it is closed yet
[12:51:29] <eddyb> (though I now realize it's a tougher problem than it looks)
[12:53:13] <Tobba> ughhh
[12:53:23] <Tobba> I need to fit the memory tree node structure in 24 bytes so I can refcount it
[12:53:30] <Tobba> but it needs 5 individual pointers, goddamnit
[12:54:24] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[12:54:28] <dbaupp> can you store a pointer to the pointers?
[12:54:33] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[12:54:39] <eddyb> acrichto: how did you remove strdup_uniq?
[12:55:14] <eddyb> don't tell me it was required for ~"foo" but not used :/
[12:55:15] <Tobba> hah, will just make it worse
[12:55:24] <Tobba> I need it to go in under 32 bytes or it'll take too much space
[12:55:28] <dbaupp> eddyb: presumably it's used nowhere
[12:55:33] <dbaupp> (in the compiler)
[12:55:43] <Tobba> considering nudging down my RcBox to count in u16's instead
[12:55:50] <Tobba> but I dont think I can get away with that
[12:56:07] <eddyb> dbaupp: try #[no_std]; #[start] fn start(I forget the arguments) {~"foo"}
[12:56:20] <eddyb> it will complain by strdup_uniq *unless* it was changed recently
[12:56:21] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[12:56:46] <Tobba> compromise: TinyRc and TinyWeak
[12:56:55] <dbaupp> eddyb: weird
[12:57:06] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[12:57:28] <eddyb> Tobba: hehehe. I consider u8 is more than enough in the AST
[12:57:41] <Tobba> hah
[12:57:53] <Tobba> its just that I might end up using it for some kernel object then some moron makes a billion references to it and crashes the kernel
[12:58:00] <eddyb> (only the ast_map should actually store extra references - if not for the map, you could have an owned AST)
[12:58:17] <kimundi> rusti: let f = || return 5u; f() + f()
[12:58:23] -rusti- timeout triggered!
[12:58:40] <eddyb> rusti: version
[12:58:43] -rusti- "rustc 0.10-pre (db7b9a3 2014-01-15 02:09:57 -0500)"
[12:58:48] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[12:58:49] <kimundi> rusti: let f = ||{return 5u;}; f() + f()
[12:58:52] -rusti- 10u
[12:59:11] <eddyb> dbaupp: nope, still there https://github.com/mozilla/rust/issues/11205
[12:59:12] <kimundi> Ah, great it actually works now :)
[12:59:24] <kimundi> (return in a closure, that is)
[12:59:31] <strcat> poor rusti has idle CPU scheduling ;p
[12:59:40] <kimundi> haha :)
[12:59:44] <dbaupp> kimundi: that's worked for weeks now :P (years! :P )
[12:59:54] <eddyb> wish we could say decades
[12:59:59] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[13:00:04] <eddyb> oh, well, I can wait another 6 years
[13:00:06] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[13:00:07] <diverse> eddyb: heh
[13:00:34] <eddyb> C++19 vs Rust 2.0 vs Idris
[13:00:38] <eddyb> everything else is dead
[13:00:43] <eddyb> (well, maybe ES8)
[13:01:02] <Tobba> by 2019 C++ will have died from its tumors
[13:01:17] <strcat> COBOL is still around
[13:01:19] <kimundi> I'm pretty sure everything else has a different opinion about that ;)
[13:01:20] <Tobba> unless a treatment for everything-cancer is invented
[13:01:21] <strcat> C++ has a long life ahead of it
[13:01:31] <Tobba> well yeah
[13:01:43] <strcat> people are writing plenty of new software in C++ ;p
[13:01:47] <johnsoft> is it bad that i found c++19 plausible enough to google it? :/
[13:02:13] <eddyb> strcat: I'd pity them, then again, Rust still isn't fully superior
[13:02:14] <strcat> johnsoft: C++17 'exists'
[13:02:21] *** Joins: daschl (Adium@moz-DC6DE6E2.vie.surfer.at)
[13:02:27] <strcat> clang implements C++14 already, per the draft, but it'll be standard soon
[13:02:33] *** Quits: kcii (o0@moz-D77E1EA9.cable.mindspring.com) (Quit: leaving)
[13:03:05] <eddyb> heh, this reminds me how I've known 2012 Olympics will be in London for years because Doctor Who
[13:03:19] <Tobba> hah
[13:03:28] <eddyb> (it was known at the time, of course, but not by everyone and their grandma)
[13:03:55] <Tobba> hm
[13:04:01] <Tobba> yep I'll have to stick with the TinyRc idea
[13:04:02] <Tobba> dangit
[13:04:13] <eddyb> do you need weak pointers?
[13:04:15] <kimundi> rusti: Some(5u).map(|x| x + 10)
[13:04:16] <Tobba> yeah I do
[13:04:17] <eddyb> s/pointers/refs/
[13:04:22] -rusti- timeout triggered!
[13:04:26] <kimundi> rusti: Some(5u).map(|x| x + 10)
[13:04:31] -rusti- timeout triggered!
[13:04:37] <eddyb> Tobba: fit both refcounts in one byte ;)
[13:04:38] <yuriks> I'm trying out syntax extensions. Intense stuff :D
[13:04:43] <kimundi> por rusti :P
[13:04:48] <diverse> rusti: println!("dangit!")
[13:04:52] -rusti- dangit!
[13:04:52] -rusti- ()
[13:04:53] <strcat> rusti: Some(5u).map(|x| x + 10)
[13:04:54] -rusti- Some(15u)
[13:04:56] <Tobba> eddyb: I was thinking of just doing away with an u8 for TinyTc
[13:04:58] <eddyb> yuriks: DSL :P
[13:04:59] <Tobba> TinyRc*
[13:05:05] <Tobba> and I should be able to fit it
[13:05:24] <eddyb> two bits for weak and six for strong, or the other way around
[13:05:27] <yuriks> eddyb: just trying to steal enough code from syntax::ast::parser so that I can get it to compile something :D
[13:05:44] <eddyb> yuriks: yeah, it's a bit sad we don't have better quasi matching
[13:05:51] <eddyb> we might, it's just a matter of implementing it
[13:06:12] <eddyb> (and then we can rewrite the parser in macro matching syntax :P)
[13:06:28] <eddyb> s/might/could/
[13:06:46] <eddyb> Tobba: do you know LLVM supports arbitrary sized integers?
[13:06:56] <eddyb> {i4. i4} should be a valid LLVM type
[13:07:16] <eddyb> I feel like maybe we should abuse it
[13:07:19] <strcat> you'd need to pad them if you stored them
[13:07:23] <strcat> in a struct
[13:07:25] <eddyb> strcat: :(:(
[13:07:31] <Tobba> eddyb: thats amazing
[13:07:32] <eddyb> strcat: because GEP?
[13:07:33] <Tobba> we dont even have bitfields though
[13:07:40] <strcat> eddyb: well if you did two i4 it might work...
[13:07:42] <strcat> might.
[13:07:44] <strcat> eddyb: yeah
[13:07:57] <strcat> eddyb: that's one reason
[13:07:59] <strcat> I mean...
[13:08:01] <eddyb> so it's invalid to get a pointer to something that doesn't start on a byte boundary?
[13:08:03] <strcat> you can have i1, i4, i214 in LLVM
[13:08:07] <strcat> but it's not going to work for rust
[13:08:16] <eddyb> because &
[13:08:17] <strcat> because we let you put stuff in structs and take pointers to structs
[13:08:29] <strcat> eddyb: yes
[13:08:37] <Tobba> making bools i1's could totally work if it was padded
[13:08:42] <flaper87> dbaupp: damn, you beat me on the is_zero PR
[13:08:44] <flaper87> :P
[13:08:46] <strcat> Tobba: well that's what clang does
[13:08:53] <strcat> Tobba: i8 in-memory (alloca, struct, etc.) 
[13:08:53] <eddyb> and that's what we should do
[13:08:55] <flaper87> I sent my comment and found yours
[13:08:55] <strcat> i1 after load
[13:08:56] <flaper87> :D
[13:09:01] <Tobba> neat
[13:09:13] <strcat> and it passes them as i1 zeroext but that's probably some ABI rule
[13:09:15] <eddyb> that means you should never receive a bool from C though
[13:09:18] <strcat> for _Bool
[13:09:24] <Tobba> probably
[13:09:34] <Tobba> oh yeah
[13:09:39] <Tobba> if you didnt return them as i1 zeroext
[13:09:45] <Tobba> the upper 31 bits of eax would contain trash
[13:09:50] <eddyb> (unless it's _Bool or something standard like that)
[13:09:55] <eddyb> Tobba: ooh, I didn't realize that
[13:10:22] <Tobba> and iirc for C interop, where bools were just ints... well yeah
[13:10:37] <strcat> Tobba: you pass i8 as i8 though
[13:10:37] <eddyb> strcat: so, for {i4, i4, i4, i4} you can take pointers only to fields 0 and 2?
[13:10:37] <Tobba> even if it was just 8 bits it would end badly, hence zeroext I guess
[13:10:39] <strcat> and it works
[13:10:40] <yuriks> O_o I don't get this borrow checker.
[13:10:51] <strcat> Tobba: only i1 gets passed as zeroext by clang
[13:10:57] <strcat> not i8, i16, i32, etc.
[13:11:12] <Tobba> yeah I know
[13:11:20] <yuriks> let mut chars = string.to_utf16().iter().map(|&x| ...); complains about the validity of string
[13:11:22] <eddyb> of course, because i1 is smaller than the smallest machine register (wait. what if we could pass bools in flags? and I nuts? maybe)
[13:11:32] <flaper87> what does `r=username` do in a PR? Does it approves the PR in behalf of `username` ?
[13:11:33] <Tobba> that would actually rock eddyb
[13:11:40] <eddyb> *am I nuts
[13:11:42] <yuriks> let foo = string.to_utf16(); let mut chars = foo.iter().map(|&x| ...); works fine
[13:11:42] <strcat> flaper87: yes
[13:11:43] <Tobba> I hope LLVM's fastcall does that
[13:11:46] <flaper87> kk
[13:11:47] <Tobba> you could totally use the carry flag
[13:11:51] <eddyb> Tobba: I doubt it
[13:11:58] <eddyb> I don't know any calling convention which allows it
[13:12:09] <Tobba> fastcall I guess
[13:12:11] <eddyb> strcat: what about my GEP question?
[13:12:18] <Tobba> aka "no convention do whatever you want"
[13:12:29] <strcat> Tobba: afaik fastcc is likely just the same as sysv abi on x86_64 atm ;s
[13:12:35] <strcat> can look and check
[13:12:41] <Tobba> as long as the method isnt exposed externally LLVM can go hog wild
[13:12:44] <eddyb> because it already passes first two arguments in registers
[13:12:47] <Tobba> I doubt it actually does it though
[13:12:51] <strcat> Tobba: it does
[13:12:54] <eddyb> Tobba: it will inline it :)
[13:13:01] <eddyb> and then who cares where you pass bools
[13:13:04] <strcat> Tobba: it switches internal functions to fastcc if it can see all the call sites
[13:13:04] <Tobba> well yeah
[13:13:12] <strcat> if they get turned into a function ptr it can't necessarily
[13:13:18] <strcat> well it likely just plain can't
[13:13:25] * strcat doubts that fastcc promotion analyzes that
[13:13:26] <eddyb> strcat: #[bit_packed] and then disallow taking pointers to invalid fields
[13:13:41] *** Joins: jakerr (bluehex@moz-1095CD08.kanagawa.ocn.ne.jp)
[13:13:44] <strcat> eddyb: just do it yourself
[13:13:46] <strcat> *shrug*
[13:13:47] <eddyb> strcat: or trans them as &{s.field} instead of &s.field (i.e. temporaries)
[13:13:56] <eddyb> I'm just asking if it's possible
[13:14:08] <strcat> possible...
[13:14:12] <strcat> not necessarily useful ;p
[13:14:12] <eddyb> LLVM gives us the integer types to work with
[13:14:20] <strcat> doesn't mean they are useful
[13:14:29] <strcat> and doesn't mean every target knows how to lower them
[13:14:30] *** Joins: ray (bernhard@moz-FF531B82.vie.surfer.at)
[13:14:37] <strcat> most targets can't lower > i128 afaik
[13:14:46] <eddyb> hmm, that's interesting
[13:14:48] <ray> whats the difference between println! and println? is there a convention like in ruby?
[13:15:02] <eddyb> so i64 on 32bit architectures is a special lowering case?
[13:15:10] <eddyb> ray: the latter is just a function which takes a string
[13:15:11] <ray> as in ! denotes methods/functions that are impure?
[13:15:13] <strcat> ray: ! means macro
[13:15:19] <ray> i see :)
[13:15:27] <ray> ty
[13:15:40] <strcat> because println! provides type-safe format strings
[13:15:42] <ray> why is formatting a println a macro?
[13:15:46] <dbaupp> macros_rule!
[13:15:49] <strcat> ray: compile-time checked format strings
[13:15:54] <strcat> checked and expanded at compile-time
[13:16:00] <strcat> see std::fmt
[13:16:03] <eddyb> though not fully
[13:16:12] <Tobba> its still awesome
[13:16:17] <eddyb> a lot of nonsense is virtualized
[13:16:23] <eddyb> for no reason other than "generics are hard"
[13:16:30] <ray> ok so macros are not like in c probable causes of error
[13:16:40] <strcat> ray: they're not like C macros
[13:16:42] <strcat> they're not textual
[13:16:47] <ray> cool :)
[13:16:47] <eddyb> ray: they're hygienic, pattern matching, etc.
[13:16:59] <Tobba> C macros are stupid text replacements, rust macros are basicaly pattern matching macros on crack
[13:17:01] <eddyb> and format_args! is rust code running on a token tree
[13:17:02] <strcat> 1) they're explicit, 2) they use token trees
[13:17:21] <eddyb> (and now you can have your very own syntax extension!)
[13:17:31] <strcat> and yeah, they're (mostly - should be fully) hygienic
[13:17:44] <eddyb> ray: check this out https://github.com/sfackler/rust-phf
[13:18:21] *** Joins: rca (rcatolino@moz-2FAE8B7B.adsl.proxad.net)
[13:18:33] <eddyb> (for the small price of 20 dogecoins! - *ahem* cmr's comment about abstraction dealing)
[13:18:53] <yuriks> any way to have the compiler auto deduce the size of a static array (if you're initializing it)
[13:18:56] <ray> btw, any idea where i can find the println! macro? somewhere in https://github.com/mozilla/rust/tree/master/src/libstd/io  ?
[13:19:01] *** Quits: pepijndevos (pepijndevo@9EACEF43.E50A3180.BCE47D84.IP) (Max SendQ exceeded)
[13:19:06] *** Joins: pepijndevos (pepijndevo@9EACEF43.E50A3180.BCE47D84.IP)
[13:19:28] <eddyb> yuriks: we need some inference, we don't have it yet
[13:19:36] <eddyb> ray: it's in the parser
[13:19:45] <yuriks> oh well, hardcoded it is for now I guess
[13:19:54] <ray> i see
[13:20:30] <eddyb> it should be moved out of libsyntax soon
[13:20:54] <eddyb> I'm actually rewriting the formatting runtime, I hope to achieve devirtualization for format!
[13:21:18] <eddyb> (not print!/println! because yay the dynamic Task interface)
[13:21:37] <ray> i was hoping to see the magic :D
[13:22:24] <ray> then again i dont really see why youd need a macro for that
[13:22:43] <ray> i mean isnt there some kind of interface that you implemented like toString to make the string replacement possible?
[13:22:48] <Matthias247> eddyb: can you achieve hat it does no longer crash when you do {:?} on a C-like enum where the value is unknown? :)
[13:22:53] <eddyb> ray: it's more complicated than that
[13:22:59] <eddyb> Matthias247: that's orthogonal
[13:23:21] <eddyb> ray: syntax::ext::expand::format or something like that
[13:24:09] <dbaupp> syntax::ext::format
[13:24:30] <dbaupp> it directly creates an AST so the code isn't particularly clear, fwiw
[13:24:45] <eddyb> dbaupp: needs more quasi?
[13:24:58] *** Joins: Earnestly (earnest@moz-E86D50FA.dyn.plus.net)
[13:24:58] <dbaupp> maybe
[13:25:20] <dbaupp> problem with quasiquoting is the current implementation is so ridiculously fragile
[13:25:36] <eddyb> dbaupp: for bootstrapping?
[13:25:38] <dbaupp> relies on generating the exact AST type names
[13:25:40] <dbaupp> yes
[13:25:43] <eddyb> I know I've broken it a couple times
[13:26:02] <dbaupp> so it's annoying to use in any of the bootstrapping libs when things change in the AST
[13:26:20] <dbaupp> (i.e. now, since we're not exactly stable.)
[13:27:00] <eddyb> dbaupp: what's $foo in a macro invocation?
[13:27:38] <eddyb> https://github.com/sfackler/rust-phf/blob/master/phf_mac.rs#L110
[13:28:02] <yuriks> https://github.com/yuriks/starbreaker/blob/master/src/extensions.rs
[13:28:04] <dbaupp> that's the quasiquoting macro interpretting it sepcially
[13:28:07] <yuriks> another little extension
[13:28:07] <dbaupp> *specially
[13:28:19] <dbaupp> eddyb: it's just referring to the `k1` variable
[13:28:22] <yuriks> https://github.com/yuriks/starbreaker/blob/master/src/main.rs#L9
[13:28:35] <eddyb> dbaupp: but in what way?
[13:28:52] <dbaupp> eddyb: by... expanding to be 'k1'
[13:29:16] <dbaupp> the quoting macro has access to the ident that the $k1 is storing (i.e. k1)
[13:29:19] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[13:29:20] <dbaupp> yuriks: that's cool!
[13:30:01] <eddyb> dbaupp: so it's escaping?
[13:30:04] <dbaupp> yuriks: although, syntax::ext::base has some helper functions
[13:30:09] <dbaupp> eddyb: yes
[13:30:23] <dbaupp> yuriks: (possibly ...::ext::expand)
[13:30:29] <eddyb> dbaupp: OH. is it dynamically converting $k1 to an expression?
[13:30:39] <yuriks> dbaupp: I'll take a look. I mostly imitated what the actual parser did to parse an AST...
[13:30:40] <dbaupp> yuriks: e.g. I think there's like single_str_from_tt or something
[13:30:41] <eddyb> well, k1, the local
[13:30:50] <Tobba> hm
[13:31:01] <Tobba> I should implement an upgrade() function for Option<Weak<T>>
[13:31:06] <dbaupp> yuriks: also, ext::build has some really useful methods if I do say so myself
[13:31:11] <yuriks> btw, where does quote_expr! come from? is it builtin?
[13:31:15] <dbaupp> yes
[13:31:23] <eddyb> in syntax::ext::quote
[13:31:46] <eddyb> dbaupp: so if we'd have ${expr}, the expr would be converted to AST *at runtime*?
[13:32:11] <eddyb> like quoting ${1+1} would be equivalent to quoting 2
[13:32:31] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Ping timeout)
[13:32:42] <ray> where should i look for sockets?
[13:32:52] <ray> half of the google links are dead
[13:32:59] <eddyb> ray: the docs
[13:33:10] <ray> section?
[13:33:18] <eddyb> ray: we have a search bar :)
[13:33:29] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[13:33:56] <eddyb> (if you're asking "which docs" - std/master)
[13:33:58] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[13:34:01] <ray> ty
[13:34:19] <eddyb> dbaupp: is it double-quoting? https://github.com/sfackler/rust-phf/blob/master/phf_mac.rs#L142
[13:34:44] <eddyb> I would love to see ${state.k1}
[13:34:48] <ray> http://static.rust-lang.org/doc/master/std/libc/funcs/bsd43/ffi.socket.html ?
[13:34:58] *** Joins: dwrensha (chatzilla@moz-B23D2FF6.pitbpa.east.verizon.net)
[13:35:01] <eddyb> that would bring quasi-quoting to ES6 level, at least for such an usecase
[13:35:14] <eddyb> ray: not that, that's unsafe
[13:35:35] *** Quits: remen (petter.rem@moz-BF847080.ias.bredband.telia.com) (Quit: remen)
[13:35:38] <ray> TcpListener?
[13:35:42] <ray> http://static.rust-lang.org/doc/master/std/io/net/tcp/struct.TcpListener.html#method.socket_name
[13:35:47] <eddyb> ray: and stream http://static.rust-lang.org/doc/master/std/io/net/tcp/struct.TcpStream.html
[13:36:01] <ray> i see thanks
[13:36:17] <eddyb> needs more doc comments (examples would be helpful) http://static.rust-lang.org/doc/master/std/io/net/index.html (and nested modules)
[13:36:42] <dbaupp> eddyb: quote_expr!() creates a value of type ast::Expr
[13:37:01] <eddyb> dbaupp: so $k1 and friends are double-quoted for no reason?
[13:37:03] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[13:37:06] <dbaupp> eddyb: it's not "evaluable" at runtime (without passing it to a JITing version of librustc)
[13:37:13] <dbaupp> eddyb: double quoted??
[13:37:29] <eddyb> it's quoted in the structure
[13:37:33] <eddyb> shouldn't that be enough?
[13:37:41] <dbaupp> I guess its actually unquoting them
[13:37:58] <dbaupp> writing `foo` creates a thing that's Ident("foo"), basically
[13:38:16] <dbaupp> writing $foo creates Ident(<value of `foo`>)
[13:38:36] <dbaupp> (for quote_ident!(foo) and ...!($foo) resp.)
[13:38:37] <eddyb> dbaupp: traceur-compiler allows you to do parse`function foo(arg) {let x = ${JS expression which resolves to an AST piece}; ...}`
[13:38:42] *** Joins: peterdreid (peterdreid@moz-D18776CD.nc.res.rr.com)
[13:38:56] <eddyb> if we can have that kind of partial parsing, syntax extensions will be even easier to use
[13:39:30] <eddyb> dbaupp: I think there's conversion functions from values (like uint in that case) to ExprLit
[13:39:41] <dbaupp> in libsyntax?
[13:39:43] <eddyb> that's what I mean by runtime
[13:39:49] <eddyb> dbaupp: yes, in quote specifically
[13:39:57] <busylizzy> what is box(GC) Bar::new()?
[13:39:58] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[13:40:08] <eddyb> I kinda remember something like that and otherwise I don't see how that would work
[13:40:13] <dbaupp> eddyb: `let foo = 1; quote_expr!($foo);`
[13:40:21] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[13:40:25] <dbaupp> gives you an ExprLit(uint), in theory
[13:40:26] *** Quits: mz2 (Mibbit@moz-1B2F7BC2.threembb.co.uk) (Quit: http://www.mibbit.com ajax IRC Client)
[13:40:29] <dbaupp> but I'm not 100% sure
[13:40:41] <busylizzy> > box keyword
[13:40:47] <dbaupp> hm
[13:40:51] * dbaupp has to think
[13:40:51] <eddyb> dbaupp: so why is it quoted, before using it in the structure literal below?
[13:41:07] <eddyb> dbaupp: it works with impl ToLit for uint
[13:41:28] <busylizzy> wow. new keyword. will it replace ~ and @ syntax for boxes?
[13:41:39] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[13:41:44] <ray> do i need to initialize a struct?
[13:41:52] <eddyb> busylizzy: their construction
[13:42:01] <eddyb> ray: of course. why wouldn't you?
[13:43:26] <ray> ok, as for setting default values on the struct i just use a new method?
[13:43:26] <yuriks> dbaupp: sweet! That made it much shorter :D https://github.com/yuriks/starbreaker/commit/1f5af98ecfbdd457d8ac0da14135d8d3b2b70d74
[13:43:48] <dbaupp> eddyb: it's not a stupid question; e.g. Go doesn't need it, nor does C, so please try to be polite to newbies :)
[13:43:49] <ray> also is there method overloading`
[13:44:13] <eddyb> dbaupp: I'm not saying it is a stupid question
[13:44:17] <ray> as in i want to set a default socket adress, and only if the dev wants to pass in a port or ip address i want to change it
[13:44:32] <dbaupp> eddyb: phrasing it like you did, makes it sound like you thought it was silly
[13:44:40] <dbaupp> yuriks: \o/ awesome
[13:44:47] <eddyb> ray: ah, you want default values, not unitialized values (that's why I asked, I wasn't sure)
[13:45:15] <yuriks> dbaupp: just one question, is DUMMY_SP the correct thing to use there?
[13:45:22] <ray> do i set the default values in the struct? or do i use the new fn?
[13:45:31] <ray> the new fn seems kinda useless
[13:45:39] <eddyb> yuriks: if you have a span, use it instead
[13:45:41] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[13:45:43] <dbaupp> yuriks: oh, I'd guess you should use `sp`
[13:45:46] <yuriks> dbaupp: or should I rather just use the span passed to the expander?
[13:45:53] <yuriks> ah, yeah, that :)
[13:46:08] <eddyb> (because it helps with error messages)
[13:46:16] <dbaupp> eddyb: ah, ok, I looked at the --pretty expanded output
[13:46:35] <dbaupp> eddyb: I don't think the pre-quoting is necessary
[13:46:55] <ray> btw parameter defaults would be a seriously nice thing to have
[13:47:14] <eddyb> dbaupp: some people do weird things like pass a pointer to an uninitialized structure on the stack to a C function. it's valid, but a special case, and different from this one. I'm sorry if my lack of communication skills makes me sound condescending or w/e it is
[13:47:33] <ray> this just feels very weird http://stackoverflow.com/questions/19650265/using-rust-is-there-a-faster-shorter-way-to-initialize-variables-in-a-struct
[13:47:38] <eddyb> ray: arguments or structure fields? both have been mentioned in the past
[13:47:42] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[13:47:50] <ray> eddyb: both :)
[13:48:13] <ray> so i just go with the default think?
[13:48:16] <eddyb> I've thought of Struct {a: a, ..} as an alias for Struct {a: a, ..Default::default()}
[13:48:38] <dbaupp> that would make Default::default yet another lang-item
[13:48:42] <eddyb> which gets close, but it has the downside of requiring all fields to have defaults
[13:48:45] <dbaupp> not sure if that's a good thing or not
[13:48:45] *** Joins: mw1001 (mw1001@moz-17825C76.cable.virginm.net)
[13:48:48] * dbaupp shrugs
[13:48:55] <ray> i though about stuff like: priv number: int = 1
[13:48:59] <ray> in the struct
[13:49:04] <ray> same for arguments
[13:49:19] <ray> fn something(number: int=0)
[13:49:29] <eddyb> ray: get core devs to agree with you and implement it (or bug someone to implement it)
[13:49:44] *** Quits: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au) (Quit: http://www.mibbit.com ajax IRC Client)
[13:49:46] *** Quits: deggert (deggert@moz-2C16B246.host.de.colt.net) (Quit: deggert)
[13:49:55] *** Quits: mw1001 (mw1001@moz-17825C76.cable.virginm.net) (Quit: Ex-Chat)
[13:50:01] <ray> ok, so i just propose it on github?
[13:50:13] <eddyb> ray: there might be an issue already, search first
[13:50:22] *** Joins: doener (doener@moz-C68F600D.unity-media.net)
[13:50:23] <ray> yeah, thanks :)
[13:50:25] <Tobba> pretty sure argument defaults are a maybe
[13:50:42] <eddyb> (I agree with most use cases. variadic generics + trait specialization - which we already have - would allow you to cheat function argument overloading into Rust)
[13:51:01] <eddyb> and then pattern-match function argument types and values with macros
[13:52:21] <yuriks> when I use a vec literal inside a function it gets compiled to a lot of individual movs setting each element. Shouldn't it get stored as a constant instead?
[13:52:48] <yuriks> (I'm asking if that's a bug or intended, because of some semantic I don't know about)
[13:53:23] <Tobba> make sure you're compiling with -O
[13:53:44] <yuriks> I am
[13:54:05] <strcat> yuriks: if you're mutating it it needs to be on the stack
[13:54:39] <Matthias247> I would also favor an optional in-struct-definition-default-value instead of the Default::default thing ;)
[13:54:43] *** Joins: mw1001 (mw1001@moz-17825C76.cable.virginm.net)
[13:54:50] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[13:55:19] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[13:55:33] <ray> ok basically the same as my suggestion :) https://github.com/mozilla/rust/issues/6973
[13:55:40] <yuriks> strcat: I'm only passing it to transmute. But I can just move it to a static non-mut vec instead and it gets compiled to a const with no change in the rest of the code
[13:56:12] <eddyb> dbaupp: this is technically possible (and we might be able to make it shorter using some traits) https://gist.github.com/eddyb/fab5c8000edbb6b6c152#file-phf_mac-rs-L55-L78
[13:56:53] <eddyb> creating a vec should take an Iterable<@Expr>
[13:57:05] *** Joins: Ferreus (ferreus@moz-561EC8C5.pools.arcor-ip.net)
[13:57:06] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[13:57:20] <eddyb> dbaupp: hang on a second, why does ExprVec contain a mutability?
[13:57:33] <yuriks> eddyb: +1 to that question
[13:57:45] <dbaupp> eddyb: [mut int] used to be a thing
[13:57:49] <dbaupp> like ~mut int
[13:57:50] <eddyb> yuriks: I recently removed similar cruft from other things
[13:57:51] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[13:58:08] *** Joins: moostik (Icedove@moz-1FF02BE5.w92-151.abo.wanadoo.fr)
[13:58:18] <strcat> eddyb: there was a time when there was no inherited mutability, no borrowed pointers or lifetimes, etc.
[13:58:20] <strcat> ;p
[13:58:41] <eddyb> oh I know, I'm just curious if there is a valid technical reason *anymore*
[13:58:45] <busylizzy> Why channels have infinite buffer? Potentialy it may lead to out of memory, doesn't it? If the buffer was capped, it could work as sort of conjunction control between fast sender and slow receiver.
[13:59:13] <eddyb> busylizzy: there was a very very long discussion the mailing list about this, you might want to read it :P
[13:59:31] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[13:59:39] <eddyb> pros and cons for both bounded and unbounded and a lot of arguing
[13:59:45] *** Quits: peterdreid (peterdreid@moz-D18776CD.nc.res.rr.com) (Quit: )
[14:00:57] *** Quits: rca (rcatolino@moz-2FAE8B7B.adsl.proxad.net) (Ping timeout)
[14:01:00] *** Joins: nulldata (chatzilla@moz-C5F891AC.seas-nve.net)
[14:01:31] <eddyb> we should provide a configurable interface. I like default type parameters, they will help in making everyone happy (maybe not some HKT proponents)
[14:02:21] <whitequark> but, won't that lead to unnecessary code duplication?
[14:02:24] *** Joins: mceier (mceier@moz-C1591437.dynamic.chello.pl)
[14:02:38] <busylizzy> eddyb: thanks. i found it.
[14:02:48] <eddyb> whitequark: why?
[14:02:50] <strcat> eddyb: meh, all queues are bounded :)
[14:02:52] <strcat> just by memory
[14:03:29] <strcat> explicitly bounded queues just acknowledge that reality and give you choices on how to handle it (timeout, block, return Option<what_you_tried_to_send>)
[14:03:37] <strcat> ;p
[14:03:38] <Florob> Did I just dream that a recent commit made them bounded?
[14:03:43] <strcat> yes
[14:03:56] <strcat> bounded queues would be a different implementation
[14:03:57] *** Quits: anasyrma (x@moz-DE175E38.caltech.edu) (Ping timeout)
[14:04:34] <eddyb> whitequark: default type params actually allow you to reduce code duplication
[14:04:42] <Matthias247> I think with bounded queues you just transform the memory problem into another problem ;)
[14:04:53] <eddyb> into a bounds check problem :P
[14:04:59] <strcat> Matthias247: throttling producers isn't a problem
[14:05:00] *** Joins: anasyrma (x@moz-DE175E38.caltech.edu)
[14:05:16] <strcat> dropping requests after a timeout is often the right thing too
[14:06:12] <Matthias247> but if you have a stateful stream that you transfer then dropping something is not an option.
[14:06:21] <strcat> anyway out-of-memory -> goodbye whole rust process
[14:06:26] <strcat> Matthias247: so block
[14:06:26] <Matthias247> only closing that connection in the end
[14:07:18] <strcat> if your producers are outpacing the consumers (it's either that or the consumers are going faster, as balance won't really happen unless you sync it that way), the queue will expand until OOM
[14:07:40] <strcat> which in the best case causes the rust process to be killed (with overcommit) or get an out-of-memory error and abort (without overcommit)
[14:08:04] <strcat> but may cause a process using more memory to be killed (with overcommit) or give random other processes OOM errors that will likely trigger them to exit
[14:08:09] <strcat> (without it)
[14:08:14] <strcat> that is pretty bad
[14:08:23] <ray> any reason why it complains about line 11? http://nopaste.info/24e0a76864.html 
[14:08:39] <eddyb> ray: that is not valid syntax
[14:08:45] <eddyb> neither is Port
[14:08:53] <eddyb> StructName {field: value, ...}
[14:08:58] <ray> ah right
[14:09:07] <eddyb> (they probably have ctors)
[14:09:17] *** Quits: kvanb (kvanb@2B5C483.28BE6889.1611EE05.IP) (Quit: kvanb)
[14:10:13] <Matthias247> strcat: that's right. But you must be careful about watching the whole chain. If the bound queue only leads to the producer buffering everything internally until he can send than you have won nothing
[14:10:45] <strcat> Matthias247: it can't buffer anything, it will be blocked
[14:10:50] * strcat shrugs
[14:11:42] <Matthias247> depends on if you are talking about a sync interface (like the defualt in Go) or a bounded async interface (the optional thing in Go)
[14:12:16] <strcat> Matthias247: the bounded queues in Go block when they are full
[14:12:33] <strcat> they're not really async... async would be returning you back the thing you tried to send if it was full
[14:12:34] <Matthias247> blocking is often no option. When you have realtime driver running you can not block it because something else doesn't keep up
[14:12:48] *** Quits: spider-mario (spidermari@moz-81131DB6.fbx.proxad.net) (Input/output error)
[14:13:04] <strcat> Matthias247: unbounded growth causing memory exhaustion isn't an option either
[14:13:12] <strcat> and that's what you get when you don't bound it...
[14:13:22] <strcat> a queue either spends most of the time empty or trends to 'full'
[14:13:27] <strcat> whether full is a bound or out-of-memory
[14:13:39] <Matthias247> damn real-life limitations :-)
[14:14:08] <strcat> Matthias247: real-time has hard limits on when stuff should be consumed
[14:14:13] <strcat> so unbounded doesn't really help you
[14:14:25] <strcat> you *need* to discard events or you'll fall behind
[14:14:29] <strcat> if you actually end up in that situation
[14:15:06] * strcat will start calling them bounded and 'bounded-by-memory' ;p
[14:15:57] *** Joins: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net)
[14:15:59] *** Quits: heftig (heftig@moz-2118892D.dip0.t-ipconnect.de) (Ping timeout)
[14:16:02] *** Joins: deggert (deggert@moz-2C16B246.host.de.colt.net)
[14:16:37] <Matthias247> at least we have quite a lot of memory now :-)
[14:16:51] <strcat> depends.
[14:16:55] <strcat> it's a global resource
[14:17:19] <strcat> Matthias247: anyway the problem is that 'trending to full' isn't just going to decide to stop at 2GiB
[14:17:31] <strcat> if you're pulling in some feed and it goes faster than you consume
[14:17:44] <strcat> you *will* go out of memory without a bounded queue
[14:17:45] <Matthias247> of course. Any you can't keep up you will sooner or later die
[14:17:59] *** Joins: heftig (heftig@moz-2118892D.dip0.t-ipconnect.de)
[14:18:20] <strcat> intel dropped unbounded blocking queues from TBB
[14:18:24] <Matthias247> the queue will only help smoothing out spikes in transfers
[14:18:30] <strcat> now they just have a bounded queue and tell you to set it to a huge bound if you don't care
[14:18:32] <strcat> ;p
[14:19:19] <Matthias247> yeah, that's a policital decision: We are not guilty when your application crashed :)
[14:19:37] <strcat> not really a political one
[14:19:43] <strcat> they removed it because it was redundant
[14:19:47] <strcat> as their bounded blocking queue can grow
[14:19:55] <strcat> it doesn't allocate up-front
[14:20:07] <strcat> no point of having a separate unbounded type - wasn't faster than setting a high bound
[14:20:10] * strcat shrugs
[14:20:21] <strcat> and they want to encourage good practices
[14:20:43] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[14:20:48] <strcat> i.e. discourage coarse locks, discourage non-spin-locks (as they want you to only use them for tiny lock scopes), etc.
[14:21:43] <Matthias247> of course the implementation is the same. Only the maxsize will be set to uint by default for an unbounded one
[14:22:23] <strcat> Matthias247: well and the unbounded one had one cond var instead of 2, but it didn't add measurable overhead
[14:22:26] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[14:22:31] <strcat> so they 'merged' it in by deleting it ;p
[14:22:48] <strcat> anyway their queues are weird stuff
[14:23:28] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[14:23:33] <ray> btw, if i return an int from a function, can i also return None?
[14:23:45] <strcat> they use a magical array of arrays with fine-grained specialized spin lock things + a lock-free ticket system on top
[14:23:47] * strcat shrugs
[14:23:48] <Matthias247> only had a very short look at TBB
[14:23:49] <strcat> incomprehensible to me
[14:23:49] <FliPPeh> If you return an Option<int>
[14:23:52] <ray> is that the reason for the existence of Option? that you have in the type signature that None can be returned?
[14:24:05] <eddyb> ray: Option<T> isn't magic
[14:24:13] <eddyb> ray: it's just Option<T> {Some(T), None}
[14:24:18] <eddyb> *enum Option...
[14:24:39] <eddyb> ray: you return Some(int_value) or None
[14:24:40] <ray> what i mean is: it isnt like in java where you can just return or pass in null for anything?
[14:24:46] <eddyb> ray: no
[14:24:46] <ray> and you get bitten by that
[14:24:53] <ray> i see
[14:25:02] <ray> but its not a monad right?
[14:25:11] <eddyb> ray: nope
[14:25:15] <Matthias247> you can only return null in Java when you have a reference type -> Integer instead of int
[14:25:16] <ray> ok :) thanks
[14:25:28] <eddyb> Matthias247: reminds me of how Java doesn't have generics
[14:25:45] <strcat> Matthias247: well, it offers basic concurrency stuff (mutexes, rwlocks, bounded/blocking queue, non-blocking queue, non-blocking priority queue, hash table and vector)
[14:25:52] <eddyb> only virtual polymorphism with no specialization (other than what the JIT does at runtime)
[14:25:53] <strcat> Matthias247: and then also offers a task system
[14:26:09] <strcat> Matthias247: which lets you build a DAG of tasks and is ridiculously fast
[14:26:14] <strcat> since they only have a little context, no stack
[14:26:15] <Matthias247> eddyb: yeah, it's bad. I often hat static analysis errors which where like "type was erased"
[14:26:29] <strcat> GPL tho ;p
[14:26:36] <strcat> since they want you to buy it for other uses
[14:26:44] * strcat doesn't know *why* intel needs to sell software
[14:26:47] <Matthias247> strcat: yup. I've seen that. I look pretty much like the TPL in C#
[14:27:25] <eddyb> strcat: isn't all that socket iteration nonsense not enough of a cash cow to milk?
[14:27:42] <strcat> eddyb: doubt they earn much from that
[14:27:46] <strcat> 99% of people don't replace CPUs
[14:28:07] <strcat> probably has more reason behind it than you think - they just don't care about people who upgrade one bit ;p
[14:28:07] <eddyb> strcat: then they're even more of a bunch of assholes
[14:28:17] <Matthias247> most HW suppliers now also do software. People start to realize that even good hardware isn't worth it when you don't have good software support
[14:28:19] <strcat> they decide they need to move some thing onto the CPU from the motherboard
[14:28:21] <strcat> and change the socket
[14:28:23] <strcat> over and over
[14:28:40] <strcat> Matthias247: well they are one of the top linux kernel contributors...
[14:28:56] <eddyb> it means I can't have 16GB of RAM in my laptop
[14:29:13] <eddyb> without finding an obscure OEM-only i5
[14:29:41] <eddyb> (which is listed on wikipedia as being around $1000 - my entire laptop was less than that)
[14:29:47] <Matthias247> E.g. we are selling embedded systems. And we (and our suppliers) won't buy any SoC from a supplier that won't provide a good BSP/SDK with it
[14:29:56] <busylizzy> wait. Option is a monad.
[14:30:01] <benh> shhh
[14:30:06] <busylizzy> it has 'map' method :D
[14:30:08] <eddyb> busylizzy: depends what you mean by "monad"
[14:30:09] <Matthias247> doesn't help when anybody builds superb hardware but it is nowhere integrated into Linux
[14:30:12] <benh> It doesn't implement a Monad trait, it's all good.
[14:30:23] <strcat> busylizzy: where are the other 2 ops?
[14:30:25] <strcat> ;p
[14:30:25] *** Quits: c-a (c-a@moz-57C82A9.a163.priv.bahnhof.se) (Quit: Ex-Chat)
[14:30:30] <eddyb> benh: wouldn't monads be higher level than traits?
[14:30:38] <strcat> busylizzy: you can represent Option as a monad but rust doesn't
[14:31:03] <benh> eddyb: I think so
[14:31:12] <tiffany> I was going to say something about those lines
[14:31:43] <eddyb> busylizzy: impl Fn<|T|->T, T> for Option<T>. then you can do Some(5)(|x| x*x)(|x| sqrt(x as f64))
[14:31:48] <tiffany> higher kinded types are something which rust lacks and everyone silently wishes it did have them
[14:32:12] <nulldata> Hey
[14:32:26] <ray> whats the preferred way to do excpetions?
[14:32:26] <Matthias247> I think only people that are coming from functional thingies.
[14:32:30] <eddyb> tiffany: traits allow you to replace some of the HKT uses
[14:32:44] <strcat> ray: rust doesn't have catchable exceptions - do you mean report errors?
[14:32:53] <eddyb> ray: Option<T> / Error<T, E>
[14:32:53] <Matthias247> I still have don't know what monads and HKTs are ;)
[14:32:58] <strcat> return Result<T, ErrorType>
[14:32:59] <eddyb> s/Error/Result/
[14:33:03] <tiffany> strcat: well there's still that condition system in extra isn't there?
[14:33:12] <strcat> tiffany: not a catchable exception system
[14:33:17] <ray> ok so Result just combines option and error
[14:33:28] <ray> and i can match it?
[14:33:29] <strcat> conditions are just 'here's a function you can use to handle the error' and it can run it at the call site
[14:33:31] <busylizzy> eddyb: looks good
[14:33:36] <strcat> it's just like passing in a closure doing that
[14:33:42] <strcat> but it uses TLS to store it
[14:34:00] <eddyb> busylizzy: is that close to a Monad?
[14:34:07] <tiffany> how does the condition system handle exits?
[14:34:17] <nulldata> I'm not sure if I am doing something wrong, or it's a bug but I'm looping 
[14:34:26] <nulldata> ^Ignore that message
[14:34:35] <eddyb> it was the former, wasn't it?
[14:34:42] <benh> Result<..., E> is also a monad :D
[14:35:09] <strcat> tiffany: exits?
[14:35:21] <strcat> tiffany: if you can't handle the error it just fails, it's not catchable
[14:35:47] <eddyb> strcat: am I crazy if I use continuations for format!?
[14:35:55] <tiffany> condition systems usually come with a way of defining 'exits' which the condition handler can take in response to an error, I think they work like gotos
[14:35:56] <ray> same reason why go doesnt feature excpetions? because its slow it may lead to bad code?
[14:36:19] <strcat> tiffany: doesn't have anything like that
[14:36:24] <jakerr> I thought I read someone saying Conditions were going away (or at least that they *wanted* to deprecate them). Not sure what the replacement would be.
[14:36:39] <strcat> ray: Go has panic/rescue, rust's stdlib has failure
[14:36:45] <strcat> so 'its slow' can't be a reason
[14:36:49] <strcat> because both still have unwinding
[14:36:57] <tiffany> conditions themselves are pretty okay, but the implementation in rust is really verbose and ugly, and they're used in rust's IO
[14:37:08] <strcat> s/rescue/recover/
[14:37:21] <tiffany> I think there were a number of people who expressed a desire to have explicit Result/Option returns on IO
[14:37:27] <Matthias247> afaik they will be replace by Results in the IO stuff
[14:37:33] <strcat> ray: exceptions are usually implemented as 'cost-free' meaning they add 0 instructions to the fast path
[14:37:45] <strcat> so they're actually faster than bubbling up errors in *some* cases
[14:37:53] <strcat> but the unwind tables make binaries a lot bigger
[14:38:08] <strcat> and if they're catchable you have to worry a *lot* about exception safety
[14:38:46] <ray> java just puts it in the method signature
[14:38:57] <Matthias247> tiffany: https://mail.mozilla.org/pipermail/rust-dev/2013-October/005990.html
[14:38:59] <ray> so basically you have to deal with them
[14:39:03] <yuriks> strcat: huh, what's that last bit about exception safety?
[14:39:50] <strcat> yuriks: if exceptions are around, to be exception-safe code needs to do everything as a transaction
[14:39:57] <strcat> for example, consider a tree map
[14:40:07] <strcat> it takes a user defined comparison op
[14:40:19] <strcat> it can throw as it is doing some internal operation
[14:40:20] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[14:40:22] <strcat> now lets say it gets caught
[14:40:26] <strcat> the tree map state can be invalid
[14:41:09] <Matthias247> ray: Yes, java is the only thing that has checked exceptions and forces you to deal with them
[14:41:16] <strcat> this is why C++ got a programmable noexcept operator thing
[14:41:38] <Matthias247> However the C# and C++ guys also had good reasons why checked exceptions are not that useful
[14:41:39] <strcat> for example, std::vector can move when it needs to resize... if there is a non-throwing move ctor
[14:42:01] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[14:42:05] <strcat> if it can throw, then there is no old vector and there is no new vector - you're screwed
[14:42:13] <strcat> so it has to do a copy transaction
[14:42:15] * strcat shrugd
[14:42:17] <strcat> PITA
[14:42:23] <strcat> everything has to document exception safety
[14:42:23] <benh> Can the Java checked exception / unchecked exception dichotomy be compared to our return Result<> or Option<> / fail!() distinction?
[14:42:34] <Matthias247> no
[14:42:34] <strcat> benh: not really
[14:42:43] <benh> if you add a cultural "you probably don't want to be catching unchecked exceptions" caveat
[14:42:55] <Matthias247> Rust Option/Result is basically the same als plain C Errorcode that are returned
[14:43:04] <eddyb> (but safe)
[14:43:04] <dbaupp> busylizzy: fwiw, .map means that Option is a functor, not a monad :P (although it is a Monad with (in haskell notation) return == Some, and >>=  == .and_then.)
[14:43:07] <Matthias247> or returned by reference parameter
[14:43:18] <strcat> Matthias247: except you get either the result or the error
[14:43:20] <strcat> not both
[14:43:21] <ray> then again it doesnt force me to handle the errors
[14:43:24] <LinearInterpol> Someone mentioned a former REPL for Rust. Is that gonna make a comeback or am I gonna have to construct one?
[14:43:31] <ray> or does it?
[14:43:39] <eddyb> dbaupp: so my Fn implementation for Option<T> is a functor?
[14:43:51] <Matthias247> strcat: for me ignoring the errocode is the same as doing result.unwrap() in Rust. Both is somewhat undetermined :)
[14:43:51] <dbaupp> eddyb: is it just sugar for .map?
[14:43:53] <strcat> anyway failure/unwinding is a stdlib concept ;p
[14:43:54] <eddyb> dbaupp: yes
[14:43:58] <strcat> you can use rust without unwinding
[14:43:59] *** Joins: Mathias (Mibbit@moz-E9EEAB4.cpe.webspeed.dk)
[14:43:59] <benh> LinearInterpol: We'd be excited if someone constructs one but I don't think anyone has plans to build a proper one yet
[14:44:07] <LinearInterpol> Ah.
[14:44:09] <nulldata> I have a `~[]` containing structs that have `Port`s in them. I'm doing a `.mut_iter()` through them and adding them to a `Select` struct ( as `&mut Port` ). The problem seems to be that after that loop, the other `.mut_iter()` for loops all fail due to the vector being rendered frozen. The compile time error says the error occurs at the for loop header, though it would seem that it's the...
[14:44:10] <nulldata> ...reference passed to the `Select` that outlives the loop and keeps it frozen.
[14:44:10] <LinearInterpol> Cool.
[14:44:15] <yuriks> strcat: right, same exception safety from C++. But what's that about it being cacheable? (you talking about CPU caches or what?)
[14:44:32] <strcat> yuriks: no, talking about catchable vs. non-catchable exceptions
[14:44:43] <strcat> and when speaking of exception safety I was talking about C++
[14:44:45] <strcat> or java
[14:44:46] <strcat> or python
[14:44:49] <strcat> or ruby
[14:44:51] <strcat> not rust.
[14:44:52] <dbaupp> eddyb: the implementation isn't the actual Functor; but it is making Option (note the lack of generics) a Functor.
[14:45:14] <strcat> code written in the safe subset of rust doesn't have to worry about unwinding
[14:45:34] <eddyb> dbaupp: I wish that would be easy to understand without knowing what a Functor is
[14:45:34] <strcat> you can't run into exception safety issues... they can't be caught anywhere but a task boundary
[14:45:38] <ray> so the compiler checks the result type
[14:45:57] <dbaupp> eddyb: a Functor is a datatype that supports some form of "map"
[14:46:03] <strcat> ray: Option/Result are just plain old enums (sum types)
[14:46:07] <dbaupp> eddyb: e.g. a vector, Option
[14:46:10] <strcat> ray: just library features
[14:46:25] <benh> strcat: given that we have rwarcs and that sort of thing, does the task boundary really protect us from the pains of exception safety?
[14:46:25] <dbaupp> eddyb: it's not at all complicated, just a slightly funny name
[14:46:34] <strcat> benh: yes
[14:46:34] <eddyb> dbaupp: map(Functor) => Functor?
[14:46:38] <benh> sweet
[14:46:40] <strcat> benh: the RWArc is poisoned if unwinding happens
[14:46:43] <dbaupp> eddyb: no
[14:46:46] <strcat> benh: anything using it fails
[14:46:54] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Quit: csherratt)
[14:46:58] <dbaupp> eddyb: Functor<A>.map(|A| -> B) -> Functor<B>
[14:47:04] <eddyb> dbaupp: riiight
[14:47:05] <dbaupp> HKT
[14:47:09] <strcat> benh: anyway you can use rust without unwinding via #[no_std] ;p
[14:47:12] <benh> That's something everything implementing mutable shared memory wrappers has to take care of?
[14:47:16] <dbaupp> (for true Haskell style functors.)
[14:47:41] <strcat> benh: in the stdlib? yes
[14:47:50] <eddyb> dbaupp: trait Functor<T> {fn map<U>(|T| -> U) -> Self<U>;}?
[14:48:00] <eddyb> dbaupp: Self<U> being the HKT part, right?
[14:48:03] <strcat> benh: well, if they can contain arbitrary data
[14:48:04] <dbaupp> eddyb: there's the law that X.map(id) == X, and X.map(f).map(g) == X.map(|v| g(f(v)))
[14:48:12] <dbaupp> eddyb: well with a Self argument, yes
[14:48:15] <eddyb> dbaupp: isn't that for monads?
[14:48:35] <Matthias247> Funtors for me are things where I overload operator() :-)
[14:48:40] <strcat> benh: alternative way to do it is
[14:48:44] <strcat> logic error -> abort
[14:48:44] <dbaupp> eddyb: those laws? kinda, since monads are actually a subset of functors
[14:48:48] <strcat> not a logic error -> report error
[14:48:49] <eddyb> Matthias247: those are function objects
[14:48:53] <eddyb> dbaupp: oh, interesting
[14:49:00] <eddyb> dbaupp: I was thinking mathematically
[14:49:14] <Matthias247> eddyb: in C++ you find both terms for that
[14:49:19] <benh> strcat: like in C, then
[14:49:26] <strcat> benh: well not really like C ;p
[14:49:33] <strcat> benh: as C returns the result regardless
[14:49:43] <dbaupp> eddyb: i.e. full-on category theory Monads?
[14:49:47] <strcat> and usually logic error -> undefined behaviour
[14:49:56] *** Joins: zeenix (zeenix@moz-B92AB3AA.range109-158.btcentralplus.com)
[14:49:57] <eddyb> dbaupp: myeah
[14:50:09] <dbaupp> ("monoids in the space of endofunctors", etc?)
[14:50:15] <benh> category
[14:50:16] *** Parts: zeenix (zeenix@moz-B92AB3AA.range109-158.btcentralplus.com) (Leaving)
[14:50:25] <dbaupp> meh :P
[14:50:33] <strcat> monads are just a concept like Iterator or Container
[14:50:36] <strcat> they provide 3 ops
[14:50:43] <dbaupp> eddyb: well, functors are a category theoretic thing too
[14:50:44] <strcat> pretty simple stuff if you ignore anything but what they actually are
[14:50:46] <strcat> ;p
[14:50:50] <eddyb> dbaupp: trait Functor<T> {fn map<U, UF: Functor<U>>(|T| -> U) -> UF;} *but that's generic*
[14:50:51] <dbaupp> strcat: yes
[14:51:08] <yuriks> strcat: doh, I'm blind. My bad
[14:51:13] <benh> strcat: ok, i was just thinking of functions that return whether they wrote something to a caller-provided memory location as equivalent to return Option<>
[14:51:23] <dbaupp> strcat: people get all up in arms about "functor" and "monad" when they're actually very simple
[14:51:33] <dbaupp> :'(
[14:51:54] *** Joins: jeff_ (jeff@moz-E6A9E8C9.hsd1.or.comcast.net)
[14:52:00] *** Quits: jeff_ (jeff@moz-E6A9E8C9.hsd1.or.comcast.net) (Quit: jeff_)
[14:52:00] <dbaupp> eddyb: yes, that's not correct, UF is too free
[14:52:06] <eddyb> dbaupp: so that's an use of HKT that we can't substitute
[14:52:21] <eddyb> but we can have Iterable<T, I: Iterator<T>>
[14:52:25] <dbaupp> you can do something like trait Functor<T, UF, U> { ... }
[14:52:27] <benh> dbaupp: I'm getting all up in arms about Control.Monad.Trans.Control
[14:52:33] <eddyb> and even traits generic over *lifetime association*
[14:52:42] <eddyb> (well, not yet, but it's a bug)
[14:52:44] <benh> and I'm eagerly waiting for someone to extend the burrito metaphor to that package
[14:52:45] <dbaupp> and then impl<T, U> Functor<T, Option<U>, U> for Option<T> { ... }
[14:52:51] <dbaupp> benh: heh
[14:53:30] <eddyb> dbaupp: but you can't restrict UF to be Functor<U, ..> because it would become recursive
[14:53:31] *** Quits: deggert (deggert@moz-2C16B246.host.de.colt.net) (Quit: deggert)
[14:53:36] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[14:53:40] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[14:53:41] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[14:54:21] <dbaupp> eddyb: yes, it's a hack that doesn't completely work
[14:54:23] <dbaupp> but kinda does
[14:54:44] <strcat> eddyb: LINQ is monadic ;p
[14:55:02] <strcat> more general though
[14:55:16] <dbaupp> so are Iterators
[14:55:22] <eddyb> strcat: I only know it's an acronym and it works with .NET
[14:55:28] <dbaupp> (although just the [] monad.)
[14:55:29] <eddyb> s/with/on top of/
[14:55:34] <strcat> dbaupp: the monad API is actually a subset of LINQ though
[14:55:41] <Florob> I wonder... is there a good reason for libc::size_t to be either a u32, or u64, instead of always a uint?
[14:55:58] <eddyb> Florob: no, we have an issue open for it
[14:56:06] <strcat> dbaupp: and LINQ provides nice syntax for it... although a haskell programmer is probably disgusted by the terms they use ;p
[14:56:08] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[14:56:18] <eddyb> (it's defined sepparately for each supported architecture, so it's not a problem)
[14:56:25] <strcat> dbaupp: since it masquerades as SQL-like expressions but is much more powerful
[14:56:53] <dbaupp> strcat: "nice" syntax for it... with uppercase method calls, ugh! :P
[14:57:00] <strcat> meh
[14:57:05] <strcat> haskell's naming convention is fooBarBaz ;p
[14:57:12] <eddyb> lowerCamelCase
[14:57:20] <benh> It's kinda amazing how much neat stuff they pushed into C# in the guise of "we're gonna add syntax sugar for sql, people will love it"
[14:57:24] <strcat> with upper for types
[14:57:33] <strcat> well C# has a lot of neat stuff
[14:57:33] <dbaupp> strcat: still better than something.FooBarBaz() :P
[14:57:39] <strcat> async/await is really nice
[14:57:46] <strcat> and yield for generators is nice
[14:57:49] <strcat> LINQ is pretty neat
[14:57:51] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[14:57:58] <strcat> they have user-defined value types, which is a huge step up from java
[14:58:00] <benh> I mean the machinery under LINQ with expression trees etc
[14:58:10] <strcat> sane generics that are actually specialized when used with value types
[14:58:18] <strcat> benh: ah
[14:58:44] * strcat expects async/await to become obsolete though ;p
[14:58:55] <benh> I keep forgetting how async/await actually works
[14:58:55] <whitequark> obsolete?
[14:59:04] <strcat> whitequark: yes :)
[14:59:07] <benh> people keep insisting it's not just punting a callback to a background thread
[14:59:07] <whitequark> why?
[14:59:28] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[14:59:33] <benh> strcat: b/c user mode scheduling / threads becoming cheap enough to not worry about asyncifying everything?
[14:59:37] <strcat> whitequark: same reason linux only uses non-blocking socket I/O and not async file I/O
[14:59:54] <benh> What's the reason for that?
[15:00:01] <benh> I thought we were mad at linux because of it.
[15:00:07] <strcat> why would you be mad?
[15:00:16] <strcat> nginx doesn't use non-blocking/async file I/O
[15:00:21] <strcat> wouldn't be very fast if it did afaik
[15:00:25] <bjz> rusti: () () ()
[15:00:28] <benh> I don't want my file IO to block my realtime cat picture animations!
[15:00:31] -rusti- pastebinned 7 lines of output: http://ix.io/9Z0
[15:00:39] <strcat> whitequark: SSDs, 64-bit address space, [...]
[15:00:48] <bjz> rusti: ; ; ;
[15:00:50] -rusti- ()
[15:01:05] <bjz> strcat: why does () () () not work?
[15:01:24] <strcat> benh: in most cases, you're bounded by one array of drives
[15:01:28] <bjz> OHH
[15:02:10] <bjz> fn (;)<T>(_: &T) {}?
[15:02:18] <strcat> wat?
[15:02:24] <bjz> or something?
[15:02:26] <eddyb> bjz: kinda
[15:02:26] <benh> Those are just three empty statements
[15:02:48] <eddyb> bjz: but it's implemented as {(expr;)+ expr?}
[15:02:54] <bjz> eddyb: yeah :P
[15:03:08] <eddyb> s/+/*/
[15:03:09] <bjz> eddyb: just trying to get the smantics in my head
[15:03:45] *** Joins: squiddy (squiddy@moz-F847A3EE.adsl.alicedsl.de)
[15:04:02] <bjz> rusti: fn f() {} println!("hi") fn g() {}
[15:04:05] -rusti- pastebinned 8 lines of output: http://ix.io/9Z1
[15:04:25] <strcat> whitequark: apache24 is actually competitive with nginx with a thread-based model... but it uses significantly more resources
[15:04:31] <benh> strcat: I don't understand why file IO shouldn't be async :(
[15:04:34] <bjz> rusti: fn f() {} println!("hi") fn g() {} println!("ho")
[15:04:38] -rusti- pastebinned 9 lines of output: http://ix.io/9Z2
[15:04:39] <benh> "disks are fast enough"?
[15:04:40] <eddyb> bjz: you can talk to rusti privately if you want to
[15:04:48] <strcat> benh: ideally, nothing would be async
[15:05:01] <strcat> you'd just make a thread per thing and block
[15:05:05] <strcat> that's the high-level model
[15:05:19] <strcat> so, what matters is resource usage
[15:05:24] <eddyb> so node.js-like async is middle-level?
[15:05:33] <eddyb> not low-level blocking, and not high-level blocking
[15:05:36] <strcat> eddyb: no, node.js is backwards nonsense
[15:05:37] <benh> I feel like sometimes getting all my threads to play nice with each other is more of a bother than doing some demultiplexin with async IO
[15:05:39] <strcat> eddyb: ;p
[15:05:50] <strcat> eddyb: async/await is a modern async API
[15:06:06] <strcat> benh: 'play nice'?
[15:06:18] <bjz> eddyb: heh, I like how declarations work like semicolons
[15:06:34] <eddyb> benh: Rust doesn't require threads/tasks to play nice
[15:06:39] <strcat> benh: when you have no data races and high-level concurrent data structures (rust doesn't have the latter atm), it's way easier
[15:07:40] <benh> If I have a bunch of async callbacks that get executed in sequence, I can just share things between them without worrying about races too
[15:08:02] <strcat> benh: you can share data between threads without worrying about races
[15:08:08] <strcat> data races*
[15:08:12] <strcat> benh: in both cases you have to worry about race *conditions*
[15:08:22] *** Joins: jfbk (jfbk@moz-EEA9CFB3.nyc.res.rr.com)
[15:08:24] <benh> but if I spawn a thread per file/client/process/whatever I need to worry about the state what all the threads are in and who's going to do what to my application state
[15:08:28] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Quit: csherratt)
[15:08:30] <strcat> async certainly suffers as much from race conditions, even in-memory ones
[15:08:36] <strcat> benh: no you don't
[15:08:41] <strcat> benh: we're talking about rust here
[15:08:54] <strcat> not async in C vs. threads in C
[15:08:58] * strcat shrugs
[15:08:59] <whitequark> strcat: interesting
[15:09:31] <whitequark> so... the resources are what, mainly stacks? and wouldn't lazy allocation mostly fix that?
[15:09:41] <benh> I heard in rust we can't even write IRC clients because we can't write to TCP sockets while blocking to read on them ;)
[15:09:42] <whitequark> you still allocate at least 4K per thread
[15:09:42] *** Joins: mib_75jgxr (Mibbit@moz-AB31BF25.w90-26.abo.wanadoo.fr)
[15:09:48] *** Quits: mib_75jgxr (Mibbit@moz-AB31BF25.w90-26.abo.wanadoo.fr) (Quit: mib_75jgxr)
[15:09:55] <benh> now there's ways to solve that but it still makes the whole blocking thing not seem universally desirable
[15:09:59] <strcat> benh: rust's stdlib sucking doesn't mean anything
[15:10:01] <strcat> benh: no, it doesn't
[15:10:10] <strcat> has nothing to do with the concept...
[15:10:33] <strcat> the reader and writer on a socket can easily be separate
[15:10:38] <strcat> that's the sync way of doing it
[15:10:45] <strcat> and in C you'd just share a socket between threads
[15:11:14] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:11:22] *** Quits: jakerr (bluehex@moz-1095CD08.kanagawa.ocn.ne.jp) (Quit: Textual IRC Client: www.textualapp.com)
[15:11:29] <strcat> whitequark: 4K initial stack + probably ~4K in other resources
[15:11:40] <strcat> whitequark: which becomes less and less significant
[15:12:01] <strcat> whitequark: the other issue is scheduling, as you probably don't actually want fair scheduling
[15:12:21] <strcat> google patched linux to support 1:1 threading with a userspace scheduler, they haven't tried to upstream it yet...
[15:13:10] <strcat> whitequark: https://www.youtube.com/watch?v=KXuZi9aeGTw
[15:13:27] <strcat> although that's not really hugely important
[15:13:35] <strcat> you can use SCHED_BATCH
[15:14:28] *** Quits: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net) (Ping timeout)
[15:15:08] <strcat> benh: pipes/sockets are inherently two parts and should give you two parts
[15:15:10] * strcat shrugs
[15:15:16] *** Joins: eternaleye (eternaleye@moz-5668AFCB.hsd1.wa.comcast.net)
[15:15:31] *** Joins: hacker_sam (hacker_sam@C0FE520A.661C02A7.B0CE379A.IP)
[15:15:41] <benh> I guess I need to sit down and read through a bunch of nginx and apache :(
[15:16:12] <strcat> benh: tl;dr is that nginx uses an event loop (epoll, kqueue) for non-blocking sockets and blocking disk I/O
[15:16:26] <strcat> apache has multiple models since it's apache and needs to do everything
[15:16:34] <FliPPeh> It makes sense that you can't write to a socket while blocking it, ownership and such
[15:17:03] <strcat> FliPPeh: you can split it into two parts
[15:17:12] <strcat> reading/writing at the same time is thread safe
[15:17:18] <strcat> a pipe starts off split into two fds
[15:17:41] <benh> Can you actually dup() a socket fd and then shutdown the read- and write-ends on the two fds respectively?
[15:17:52] <benh> not that that's what our API should do
[15:18:06] *** Joins: Sorella (queen@9D963F5D.DF5D8AE7.54BCAB54.IP)
[15:18:09] <strcat> benh: well... you could get away with that in C
[15:18:16] <whitequark> strcat: (google and threading) that's basically saying "rust heavily favors a model which only works in recent linux"
[15:18:58] <strcat> whitequark: well it works fine on freebsd/linux and on windows via reserving disk space
[15:18:59] <whitequark> benh: I think shutdown() sends a FIN, so no
[15:19:02] <strcat> it doesn't work on OS X
[15:19:11] <whitequark> strcat: talking about scheduling more
[15:19:28] <strcat> whitequark: http://msdn.microsoft.com/en-us/library/windows/desktop/dd627187(v=vs.85).aspx
[15:19:40] <benh> reserving disk space? i'm lost
[15:19:58] <strcat> whitequark: you can just use a FIFO or whatever
[15:20:01] <strcat> on windows
[15:20:22] <whitequark> strcat: UMS is available for 64-bit applications running on 64-bit versions of Windows 7 and Windows Server 2008 R2 or later 64-bit versions of Windows.
[15:20:33] <strcat> whitequark: right, because scaling this way can't work on 64-bit
[15:20:37] <strcat> er
[15:20:40] <strcat> on 32-bit
[15:20:46] <strcat> whitequark: before UMS they had fibers
[15:20:51] <whitequark> so, still a big "screw you" sign to most platforms
[15:21:03] <strcat> whitequark: rust isn't going to be supporting XP/Vista
[15:21:03] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[15:21:10] <whitequark> most... hm. arguably the most common platform in the world is 32-bit Linux on ARM
[15:21:21] <strcat> whitequark: which doesn't run servers ;p
[15:21:29] <whitequark> right
[15:21:50] <benh> please don't run a high throughput highly concurrent thing on my phone :V
[15:21:51] <whitequark> so it's a tradeoff which is important for servers, and all other applications work either way pretty much the same
[15:21:53] <whitequark> makes sense then
[15:22:11] <strcat> whitequark: for now though, you do still need non-blocking sockets to play in apache's territory
[15:22:14] <strcat> or IOCP on windows to do the same
[15:22:16] <strcat> er
[15:22:18] <strcat> s/apache/nginx/
[15:22:20] * strcat sighs
[15:22:22] <strcat> tired
[15:22:38] <strcat> whitequark: but it's questionable to expose something like async/await since it's not how linux does stuff...
[15:22:40] <strcat> like
[15:22:45] <strcat> libuv on linux is just doing sync I/O in thread pools
[15:22:49] <strcat> it's 20-30x slower
[15:22:54] <whitequark> yeah, that's much worse
[15:23:05] <strcat> the linux kernel did get AIO stuff, but it never matured as no one cares
[15:23:14] <strcat> glibc's POSIX AIO just spawns a thread
[15:23:27] <whitequark> yeah I know about AIO
[15:23:32] * strcat shrugs ;p
[15:23:38] <whitequark> apparently it even works on files... with O_DIRECT
[15:23:53] *** Joins: jhasse (jhasse@moz-CB992F36.ewe-ip-backbone.de)
[15:24:42] <strcat> whitequark: anyway I do know it's very useful *now*... I just expect it to die over time ;p
[15:25:09] <whitequark> yeah, it's a hard choice for language designers to make. be irrelevant today or tomorrow :p (exaggerating)
[15:25:22] <strcat> well you need threads and sync I/O
[15:25:28] <strcat> so might as well get that right
[15:25:55] <strcat> can have a rust-aio with actual async APIs
[15:26:25] <benh> Are there any languages that ship with kernel modules to get their pet IO model or whatever first-class support? :V
[15:26:45] <strcat> if they cared they could make linux AIO fast/robust
[15:26:46] <whitequark> no, but there's several kernel-mode HTTP servers
[15:28:45] *** Joins: rca (rcatolino@moz-10E18C17.adsl.proxad.net)
[15:28:46] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[15:30:16] <strcat> whitequark: which is insane ;p
[15:30:51] *** Joins: bjustin (bjustin@moz-4B914826.hsd1.mn.comcast.net)
[15:31:03] <benh> beats kernel-mode GUI
[15:31:38] <whitequark> actually, no, kernel-mode GUI is possibly the worst idea in mainstream OSes ever
[15:31:58] <whitequark> is the vulnerability count still in high thousands or in low tens of thousands already? :]
[15:33:17] <eddyb> rusti: (||)
[15:33:21] -rusti- pastebinned 6 lines of output: http://ix.io/9Z3
[15:33:23] <eddyb> rusti: (||{})
[15:33:27] -rusti- fn()
[15:33:48] <eddyb> kernel-mode GUI is sane if you use Rust
[15:34:21] <strcat> eddyb: well...
[15:34:29] <eddyb> (well, GUI is a little weird. but you can run safely without privilege levels if you run Rust)
[15:34:43] <eddyb> (the embedded world might benefit from this, I don't know)
[15:34:48] <strcat> eddyb: opengl isn't very safe ;]
[15:34:49] <whitequark> if you only write safe code in Rust, which is a considerably stronger assumption
[15:35:07] <FliPPeh> rusti: (||{})()
[15:35:08] -rusti- ()
[15:35:12] <whitequark> and if you want to be really pedantic, once Rust's type system is proved correct
[15:35:31] <whitequark> I mean, there's a ton of memory corruption bugs on the tracker.
[15:35:33] <strcat> whitequark: well, practically, just when it's really hard to cause the issues
[15:35:33] <benh> (I've been really mad at blocking/synchronous IO ever since babby me tried to write a command line chat client and couldn't figure out how to wait for user input and network data at the same time)
[15:35:39] <strcat> whitequark: atm it's not there
[15:35:43] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[15:35:51] <eddyb> whitequark: ton?
[15:35:52] <tiffany> benh: you mean building the standard library aside libc instead of on top?
[15:35:55] <strcat> won't take a whole lot to get it to the point where you have to go out of your way to find the holes
[15:36:12] <strcat> mostly there are actual implementation flaws in the compiler rather than language soundness holes
[15:36:13] <tiffany> I thought about that when I saw the syscall impl for rust
[15:36:18] <whitequark> strcat: I dunno, "really hard" for vulnerabilities is not "really hard" for anything else
[15:36:26] *** Joins: Cevn (sameer@moz-FD022892.wireless.umd.edu)
[15:36:36] <eddyb> strcat: and problems in libraries
[15:36:36] <benh> tiffany: aside the existin set of syscalls instead of ontop, really
[15:36:57] <whitequark> eddyb: well I recall about five open bugs
[15:37:11] <tiffany> benh: but the linux and windows syscalls don't necessarily map 1:1 to C
[15:37:24] <tiffany> they're easily reused - I think the major thing lacking is async file IO
[15:37:38] <strcat> and you can't make windows syscalls yourself without relying on undocumented/unstable stuff
[15:37:40] <tiffany> which people keep telling me you can't do because of how hard disk controllers work but that doesn't make any sense
[15:37:55] <strcat> they change the ABI of the stuff below the runtime layer
[15:37:57] <benh> yeah but like. kinda. fread() isn't really read() but it's the same idea.
[15:38:04] <strcat> benh: well not really
[15:38:07] <whitequark> benh: but read() is not syscall
[15:38:27] <strcat> read is a wrapper around *some syscall* (read on linux)
[15:38:31] <benh> I'm just wondering if someone went, screw it all, we're gonna write our own kernel-level language support blob instead of considering how the plebeian libc authors imagined it
[15:38:31] <strcat> fread is buffered I/O
[15:38:36] <strcat> unless you disable the buffer
[15:38:43] <benh> whitequark: well it says read() when i do strace... :(
[15:38:46] <strcat> and then afaik it still has the awful ungetc buffer
[15:39:01] <whitequark> benh: there's syscall read and libc read... the latter has some more logic
[15:39:04] <strcat> benh: strace shows linux syscalls
[15:39:09] <strcat> benh: try fork
[15:39:13] <strcat> you'll see 'clone'
[15:39:17] <strcat> try pthread_create
[15:39:20] <strcat> you'll also see 'clone'
[15:39:22] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[15:39:39] <strcat> in fact linux has a concept of tasks that's not really 'processes' and 'threads'...
[15:40:14] <tiffany> how does that work? is it more fine grained?
[15:40:16] <strcat> you can unshare the address space and get copy-on-write (as fork does), but you can do other fancy stuff too
[15:40:26] <benh> i'm vaguely aware that linux does that
[15:40:31] <strcat> tiffany: well the scheduler treats processes/threads as the same thing
[15:40:40] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[15:41:04] <benh> I don't see why that makes it a stupid question to ask whether any language designers shipped kernel space code with their language implementation instead of relying on what the existing kernel interface offers
[15:41:26] <benh> Besides the C people I guess
[15:41:41] <strcat> tiffany: rusti is a good example of this...
[15:41:46] <whitequark> benh: go
[15:41:48] <strcat> it unshares namespaces
[15:42:02] <strcat> it is pid 1
[15:42:05] <whitequark> benh: but mainly because they couldn't get shared libraries to work :]
[15:42:11] <strcat> in the pid namespace it lives in ;p
[15:42:13] <SiegeLord> Was Real::pow renamed to Real::powf?
[15:42:17] *** Quits: nulldata (chatzilla@moz-C5F891AC.seas-nve.net) (Ping timeout)
[15:42:27] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[15:42:48] <strcat> tiffany: instead of fork-exec you can clone-without-copy-on-write-exec
[15:43:35] <strcat> or maybe you want a new mount tree, unshare the mount namespace and propagate stuff up/down
[15:43:43] <benh> vfork-without-blocking,-exec?
[15:43:50] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[15:43:57] <strcat> benh: well, clone is a lot more powerful than that ;p
[15:44:07] <strcat> look at man 2 clone
[15:44:13] <benh> Is there anything like exec but a lot more powerful?
[15:44:20] <benh> like reading a process image from elsewhere but a path?
[15:44:31] <busylizzy> where are sorting algorithms in the standard/extra library?
[15:44:36] <benh> and deciding in detail what the new process image inherits?
[15:44:40] <eddyb> you can always jump to a mmaped region
[15:44:44] <strcat> ^
[15:44:52] <strcat> benh: so, here's a windows malware trick
[15:44:59] <strcat> benh: open a debugger connection to explorer.exe
[15:45:04] <strcat> write your image there
[15:45:08] <eddyb> and the rtld is just userspace code
[15:45:09] <strcat> start it as a thread
[15:45:14] <strcat> wooo, you're now explorer.exe
[15:45:33] <eddyb> strcat: windows is really dumb
[15:45:39] <strcat> until windows 8, this was usable to break past UAC/administrator boundaries
[15:45:53] <strcat> there are still ways, and they aren't really 'things that will be patched as bugs' ;p
[15:45:56] <eddyb> strcat: and windows 8 doesn't have explorer.exe?
[15:46:02] <strcat> eddyb: it does
[15:46:06] <benh> but surely not just every process can open debugger connections to privileged whatevers?
[15:46:09] <strcat> was just a random example
[15:46:16] <strcat> benh: tell that to winxp/vista/7 ;p
[15:46:17] <eddyb> (I was... joking about the reason it doesn't work anymore)
[15:46:30] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[15:46:35] <strcat> benh: their permissions are really complex though
[15:46:43] <strcat> like they have ACLs and other crap on every kernel object
[15:46:50] <strcat> I am pretty sure if you have a kernel mutex, it has ACLs
[15:46:50] <benh> eddyb: I kinda hoped someone else would still take care of the bits besides loading the code, like all the linking and fd fiddling and unloading the old process
[15:46:52] * strcat shrugs
[15:47:05] <benh> strcat: weird :(
[15:47:21] <strcat> benh: oh and they have that awesomely bad file locking model ;p
[15:47:31] <strcat> mandatory locking
[15:47:42] <strcat> and it assumes non-networked system
[15:47:56] <whitequark> they don't even *need* to lock executables, it's just kept for compatibility with some ancient shit no one needs
[15:48:01] <whitequark> ugh :(
[15:48:07] *** Quits: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru) (Ping timeout)
[15:48:21] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[15:48:30] <strcat> benh: NTFS supports POSIX permissions... windows doesn't use them ;)
[15:48:36] <strcat> + the complex windows permission model stuff
[15:48:39] <strcat> no one uses that anyway
[15:49:09] <strcat> selinux is basically that crap for linux, although I expect selinux is a lot saner ;p
[15:51:44] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Client exited)
[15:52:06] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[15:52:08] <Tobba> using selinux is a horrible experience
[15:52:21] <Tobba> the answer to most selinux question for most people is "turn it off" because the solution is such a mess
[15:52:36] <strcat> well attaching that stuff to files as metadata seems like a bad idea to me ;p
[15:52:44] <strcat> too invisible/complex from the start
[15:53:04] <strcat> they finally added fs.protected_hardlinks + fs.protected_symlinks so path-based stuff can work...
[15:53:32] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[15:53:36] <strcat> although a real sandbox is seccomp + namespaces ;)
[15:53:43] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[15:54:31] <whitequark> a real sandbox is isolated with hw virt :p
[15:55:15] <whitequark> actually that has holes too, just get an additional PC and put it into a box of sand, without any connectivity of course. that'll show 'em
[15:55:38] *** Quits: silotis (quassel@moz-4B8C4631.oc.oc.cox.net) (Ping timeout)
[15:55:56] <FliPPeh> What's the current state of the IO library? Is it usable already or should I expect to run into issues at every corner? :>
[15:55:59] <eddyb> whitequark: last CCC had a talk about broken HW virt :P
[15:56:09] <eddyb> FliPPeh: depends on your usecase
[15:56:23] <whitequark> eddyb: no wonder. I know about the Xen vuln, at least, which is fundamentally in the CPU
[15:56:41] <whitequark> holes all the way down!
[15:56:44] <FliPPeh> eddyb: Simple socket back and forth with plaintext, possibly multitasked, but not necessarily
[15:56:46] *** Joins: canhtak (canhtak@moz-6C22A50C.wl.t.ulaval.ca)
[15:56:48] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[15:57:03] <eddyb> FliPPeh: that's there (but not splitting a TcpStream into a reader and a writer)
[15:57:26] *** Joins: silotis (quassel@moz-4B8C4631.oc.oc.cox.net)
[15:57:29] <FliPPeh> eddyb: So like C with one handle for both operations then?
[15:57:40] <eddyb> FliPPeh: yes
[15:57:51] <FliPPeh> I think I can deal with that, didn't even know that splitting into reader and writer was a thing :)
[15:57:53] *** Quits: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP) (Quit: ERC Version 5.3 (IRC client for Emacs))
[15:58:26] <FliPPeh> Although that does sound very useful, will it works for TcpStream eventually?
[15:58:32] <eddyb> yeah, that's the plan
[15:58:32] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[15:58:36] <FliPPeh> Nice
[16:00:03] *** Joins: pyon (user@A16F2BE6.A9B419CB.1C8C8CE9.IP)
[16:00:45] *** Quits: ray (bernhard@moz-FF531B82.vie.surfer.at) (Quit: Leaving.)
[16:01:36] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[16:01:38] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Ping timeout)
[16:02:06] *** Quits: daschl (Adium@moz-DC6DE6E2.vie.surfer.at) (Quit: Leaving.)
[16:02:24] *** Joins: cc (cc@moz-E604405A.hsd1.ms.comcast.net)
[16:03:03] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[16:03:22] *** Quits: lpy (lpy@7FD2B9AB.3720F6C5.952560D4.IP) (Quit: Leaving...)
[16:07:53] *** Parts: cc (cc@moz-E604405A.hsd1.ms.comcast.net) ()
[16:07:55] <strcat> whitequark: hw virt usually implies a VM though... which has a large surface area
[16:07:57] <_achin> is there a built-in tristate enum in stdlib?  enum TriState {yes, no, maybe} 
[16:08:05] <strcat> whitequark: with seccomp you can allow only read/write/exit if you want ;p
[16:08:29] <strcat> so you're not trusting much of the kernel
[16:08:43] <strcat> using kvm is trusting more :)
[16:08:56] <bstrie_nope> strcat: rusti still gets updated every night, right?
[16:08:59] <strcat> bstrie_nope: no
[16:09:04] <bstrie_nope> oh
[16:09:11] <bstrie_nope> does it not have the rvalue lifetime change?
[16:09:14] <strcat> it doesn't work with actual rust yet
[16:09:18] <strcat> bstrie_nope: doesn't have that
[16:09:23] <strcat> I have to apply a patch to make it work
[16:09:27] <bstrie_nope> oh good, I thought I found a bug :)
[16:09:38] <strcat> so it's a pain as my nightly builds don't do it
[16:09:48] <strcat> so I just haven't been doing it as it was automated before
[16:09:49] <bstrie_nope> what's that rustilite
[16:10:13] <strcat> rustilite: #[deriving(Eq)] struct Foo(int) fn main() { println!("{}", Foo(5) == Foo(5)) }
[16:10:22] -rustilite- pastebinned 6 lines of output: http://ix.io/9Zd
[16:10:33] <strcat> rustilite: #[deriving(Eq)] struct Foo(int); fn main() { println!("{}", Foo(5) == Foo(5)) }
[16:10:33] -rustilite- true
[16:10:59] <strcat> bstrie_nope: just to work around let r = { expr }; annoyances like deriving not currently working in a fn...
[16:11:04] <bstrie_nope> aha
[16:11:12] <bjz> strcat: :O
[16:11:19] <bjz> strcat: #[] works?!
[16:11:27] <strcat> bjz: hm?
[16:11:36] <strcat> deriving just doesn't work in a function scope
[16:11:42] <strcat> and rusti runs code in a fn scope
[16:11:46] <eddyb> strcat: I think I just realized something...
[16:12:08] <strcat> rusti: #[deriving(Eq)] struct Foo(int); /* deriving is a no-op here.... */ Foo(5) == Foo(5)
[16:12:10] <bjz> strcat: oooh, it was rustilite
[16:12:10] -rusti- pastebinned 7 lines of output: http://ix.io/9Ze
[16:12:10] <eddyb> strcat: you don't always need specialization, you can match generic type params with Any
[16:12:36] <eddyb> devirtualization isn't even required
[16:16:00] *** Quits: Cevn (sameer@moz-FD022892.wireless.umd.edu) (Ping timeout)
[16:16:53] <fhahn> hi! does anybody know which version of mingw gcc can be used to build rust on windows? I've tried 4.5.2, but only get errors in wincon.h, windef.h and winnt.h
[16:19:16] <klutzy> what errors did you get?
[16:19:26] <klutzy> afaik rust works with gcc 4.5 ~ 4.8
[16:20:13] <klutzy> but mingw is hard to config, so it may lead cryptic errors
[16:20:20] <fhahn> declaration for parameter 'SID_HASH_ENTRY' but no such parameters
[16:20:24] <eddyb> bleah, so many transmutes in std::fmt
[16:20:34] <fhahn> and many more of those
[16:21:06] <fhahn> I've just installed gcc and g++ with mingw-get install "gcc=4.5.*"
[16:21:19] *** Joins: remen (petter.rem@moz-BF847080.ias.bredband.telia.com)
[16:21:34] <kimundi> What is rustilite anyway?
[16:21:40] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[16:21:51] <kimundi> strcat: ?
[16:22:02] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[16:22:14] <fhahn> klutzy: but I can try with 4,8, if that's supposed to work
[16:22:16] <kimundi> Just an empty file, instead of a min function?
[16:22:20] <kimundi> main*
[16:22:23] <klutzy> fhahn: did you install latest mingw then downgraded? (I have no experience of downgrade, but it is not needed now)
[16:22:41] *** Quits: avsej (avsej@D9A610B8.4841F515.FB33447D.IP) (Ping timeout)
[16:23:15] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[16:23:23] <fhahn> klutzy: I didn't install the latest version of gcc, I only installed 4.5
[16:23:32] *** Joins: avsej (avsej@D9A610B8.4841F515.FB33447D.IP)
[16:23:37] <klutzy> aha, hmm
[16:23:44] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[16:23:44] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[16:23:46] <strcat> kimundi: yes
[16:24:24] <whitequark> strcat: there's projects like Mirage and Erlang on Xen
[16:24:39] <whitequark> they require very little APIs
[16:24:53] *** Quits: mw1001 (mw1001@moz-17825C76.cable.virginm.net) (Quit: Ex-Chat)
[16:24:58] <whitequark> s,little,few,
[16:25:36] *** Quits: remen (petter.rem@moz-BF847080.ias.bredband.telia.com) (Quit: remen)
[16:28:17] <whitequark> strcat: I'm actually wondering how good an idea it would be, make a browser where each tab is a virtualized VM
[16:28:27] *** Joins: g3xzh (g3xzh@moz-FE980943.red.bezeqint.net)
[16:28:43] <whitequark> now that most consumer-class x86 cpus and a significant part of consumer-class arm cpus (exynos) have hwvirt
[16:29:01] <Tobba> why would you ever want to do that
[16:29:12] <Tobba> most browsers already sandbox
[16:29:26] <Tobba> sandbox escapes would be the same as exploiting the hypervisor
[16:29:30] <Tobba> which for a browser would get complex
[16:29:56] *** Joins: Cevn (sameer@moz-FD022892.wireless.umd.edu)
[16:30:03] <whitequark> arguably, not complex. it would receive a GL context and a sandbox context
[16:30:19] <whitequark> er
[16:30:19] <strcat> whitequark: only intel gpus have proper memory protection afaik
[16:30:23] <whitequark> an input context
[16:30:28] <whitequark> strcat: IOMMU to the rescue?
[16:30:32] <strcat> chromium proxies gl calls to another process
[16:30:47] <strcat> slow ;p
[16:30:59] *** Joins: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca)
[16:31:06] <whitequark> Tobba: anyway, the idea is to let anything run inside VMs, letting go of the JS anchor.
[16:31:12] <whitequark> strcat: IOMMU is slow?
[16:31:17] <strcat> no I mean what chromium does
[16:31:21] <whitequark> ah. yes.
[16:31:40] <Tobba> chromium is hilariously slow
[16:31:44] <Tobba> I dont know what the hell they're doing
[16:31:50] <whitequark> all the people pushing webgl seem to have never tried to actually use it on a battery-powered device.
[16:31:56] <Tobba> hahahaha
[16:32:06] <whitequark> or emscripten, or... *shrug*
[16:32:10] <Tobba> correction: never tried to use a battery powered device
[16:32:12] <Tobba> specially phones
[16:32:18] <Tobba> turn on, discharges in 10 seconds
[16:32:26] <whitequark> hell, I still remember how travis-ci.org would eat the entire address space in a few hours and crash
[16:32:31] <whitequark> while consuming 100% of CPU
[16:33:17] <strcat> Tobba: well needing to proxy gl calls is one big issue
[16:33:17] <whitequark> Tobba: I once opened a page with webgl on it and after a few minutes could not touch my phone at all, so hot it was
[16:33:39] <whitequark> I wonder if it's possible to melt the plastic by driving the SoC in just the right way. quite an attack.
[16:33:41] <Tobba> hahhahaa
[16:33:44] <Tobba> thats great
[16:34:15] <whitequark> and yeah, the battery indicator got lower each few seconds
[16:34:23] <whitequark> was quite amazing to watch actually
[16:34:34] <strcat> whitequark: gmail needs 70MiB+ of memory and many CPU events/s just to idle ;p
[16:34:35] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[16:34:48] *** Quits: Cevn (sameer@moz-FD022892.wireless.umd.edu) (Ping timeout)
[16:35:09] <whitequark> yeah, all that. still there's hordes running around shouting "desktop is irrelevant". sigh.
[16:35:14] <strcat> they've got 600KiB CSS strings around
[16:35:41] <Tobba> I dont know what the fuck google are doing
[16:35:47] <Tobba> the front page of google has like 1MB of JS
[16:35:51] <strcat> rolling in money
[16:36:01] <whitequark> web designers saying how HTML is excellent for UIs is a textbook case of stockholm syndrome, I think
[16:36:29] <strcat> Tobba: http://arstechnica.com/business/2013/11/googles-mystery-barge-an-interactive-space-for-new-technology/ ;s
[16:36:31] <Earnestly> web 2.0
[16:36:34] <Earnestly> yay
[16:36:35] <strcat> I think they have several of those now
[16:37:16] <eddyb> fn append(&mut self, bytes: &[u8], then: Option<|&mut Self|>); // this might be the last iteration
[16:37:29] <Earnestly> strcat: What on earth are these things
[16:37:29] <_achin> i can't tell if google dynamicaly loads additional scripts, but my google front-page appears to have 80K of [minified] javascript
[16:37:42] <Tobba> whitequark: hahaha its true
[16:37:53] <strcat> Earnestly: if you don't spend your revenue by the end of the tax year, you pay taxes on profit...
[16:37:53] *** Joins: alonlevy (alon@8BF94F14.BAE2368A.AFF59E38.IP)
[16:37:55] * strcat shrugs
[16:38:02] <Tobba> HTML is horrifying, but you can kinda get around with it for UI design by putting absolute positions and inner divs all over
[16:38:05] <strcat> need something to spend money on
[16:38:10] <Tobba> (and violating your layouting engine in the process)
[16:38:16] <Earnestly> strcat: Yeah, smells like that.  They're also tax dodging in the UK as well
[16:38:26] <whitequark> Tobba: that doesn't really result in a good UI
[16:38:28] <eddyb> Tobba: flexboxes kinda solve the problem
[16:38:29] <strcat> well that's just how businesses run in most countries
[16:38:37] <strcat> they try to maintain 0 profit
[16:38:41] <Earnestly> strcat: Not all, but some of the large ones yeah
[16:38:50] <Earnestly> Using tax havens
[16:38:53] <eddyb> Tobba: I wish old cruft could be removed... and how on earth did nobody think of flexboxes until recently?
[16:39:01] <Tobba> whitequark: more inner divs and absolute positions then, clearly
[16:39:10] <eddyb> servo --no-old-html maybe pls?
[16:39:23] <_achin> oh wait, i lie.  yeah, it's like 1.4M
[16:39:24] <strcat> Earnestly: even without that, if they spend all the money they make, no corporate taxes
[16:39:32] <Earnestly> strcat: Also that's amazing, 70M just to idle at gmail?  I mean that is actually quite impressive
[16:39:58] <benh> flexbox reminds me of the gtk box model
[16:40:05] <strcat> gtk makes me sad
[16:40:06] <benh> no offense
[16:40:23] <whitequark> eddyb: we're stuck with it forever, I'd think
[16:40:29] <whitequark> too much old cruft needs too much hooks to work
[16:40:31] <Earnestly> strcat: But Qt doesn't care about fixing "zero-day" bugs :<
[16:41:02] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[16:41:08] <Tobba> gmail sends you 240kb of HTML
[16:41:09] <Tobba> gross
[16:41:27] <strcat> watch it in firefox's about:memory
[16:41:35] <strcat> or use powertop while visiting a site
[16:41:42] <strcat> insane how much polling lots do
[16:41:51] <strcat> obviously need to poll 800 times a second
[16:41:51] <Tobba> I never figured out why modern browers use so much fucking mem
[16:42:06] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[16:42:11] <Tobba> │  ├─────29.91 MB (01.30%) ++ top(https://mail.google.com/mail/u/0/?tab=wm#inbox, id=14151)/active
[16:42:12] <Earnestly> Tobba: Usually it's either more memory or more cpu usage
[16:42:15] <strcat> Tobba: dynamic typing, JIT compilation, only immutable strings, etc.
[16:42:17] <Tobba> I mean 30MB, goddamnit google
[16:42:22] <strcat> Tobba: hm, let it sit a bit
[16:42:23] <Tobba> though all tabs use that
[16:42:24] <strcat> mine is 80MiB
[16:42:24] <Tobba> which is silly
[16:42:26] <strcat> maybe it leaks
[16:42:35] *** Joins: nulldata (chatzilla@moz-C5F891AC.seas-nve.net)
[16:42:41] <Tobba> afaik only really chrome has massive leaking issues
[16:42:41] <whitequark> Tobba: because it heavily prefers to be fast than to be lean
[16:42:45] <Tobba> casually browse forum for an hour
[16:42:47] <_achin> how much memory would thunderbird use?
[16:42:49] <Tobba> 3GB mem usage
[16:42:49] <strcat> Tobba: I mean gmail leaking
[16:42:51] <whitequark> ever since the js engine arms race
[16:42:51] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[16:43:02] <Tobba> hm yeah
[16:43:09] <Earnestly> strcat: The fact a webpage can cause leaks is scary ;p
[16:43:28] <Tobba> quite rediclous though, specially when the page is just sitting there doing nothing
[16:43:33] <Earnestly> So I guess what's the answer?  Servo?
[16:43:36] <strcat> the fact that we are executing untrusted code all the time without proper sandboxing (even in chromium) is insane
[16:43:42] <Tobba> and oh god google what the hell are you doing
[16:43:43] <strcat> with a *JIT compiler*
[16:43:45] <benh> hey guys how comes firefox hasn't fixed their memory leak yet!! huh!! *is spontaneously swallowed by the ground*
[16:43:58] <Tobba> why does it poll so often
[16:44:02] <_achin> fwiw i've never seen a google-chrome memory leaking issue.  unless it's such a small leak that it takes weeks to notice
[16:44:06] <tiffany> chromium is using 80mb of memory to sit there on the youtube subscriptions page
[16:44:15] <strcat> well
[16:44:15] <Tobba> and why does it poll for js and html files goddamn
[16:44:21] <strcat> gnome-shell uses spidermonkey
[16:44:23] *** Quits: nulldata (chatzilla@moz-C5F891AC.seas-nve.net) (Ping timeout)
[16:44:26] <strcat> and it uses a lot of memory...
[16:44:33] * strcat blames JIT compilation
[16:44:58] <Tobba> better plan: lets come up with a staticaly compileable version of JS that doesnt suck
[16:45:09] <Earnestly> strcat: You feel JIT is basically used as a crutch to make up for slow languages?
[16:45:17] <Tobba> thats basicaly it
[16:45:22] <strcat> well
[16:45:44] <strcat> it's a bit insane to be taking untrusted code and compiling it to machine code with complex optimizations
[16:45:53] <strcat> and giving it access to enormous numbers of APIs
[16:46:02] <strcat> millions and millions of lines of code of APIs
[16:46:14] *** Quits: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP) (Quit: Ex-Chat)
[16:46:20] <strcat> and not actually having a solid sandboxing solution in place
[16:46:28] <Earnestly> strcat: Would a proper sandbox be similar to your playpen/seccomp projects?
[16:46:34] <strcat> the only sandbox that's really srs bsns is the one chrome uses for pepper flash
[16:47:10] <strcat> Earnestly: well it can be better
[16:47:14] <strcat> since you control the application
[16:47:18] <Tobba> even more scary
[16:47:22] <Tobba> is that people actually use JS
[16:47:28] <strcat> js isn't that bad
[16:47:33] <strcat> compared to other dynamic langs
[16:47:36] <Tobba> with a JIT compiler where most of the compiler optimizations are simply hacks
[16:47:39] <strcat> it's the same stuff ;p
[16:47:43] <Tobba> on a single threaded server
[16:47:46] *** Joins: josh (josh@moz-348C4790.hsd1.mn.comcast.net)
[16:47:47] <Tobba> and running big websites on it
[16:47:55] <Tobba> claiming "it scales" after slapping an nginx cache on it
[16:48:13] <strcat> certainly a lot faster than python/ruby ;p
[16:48:20] <eddyb> that's what I was going to say, heh
[16:48:20] <Tobba> rails is a joke
[16:48:26] <eddyb> Tobba: github uses it...
[16:48:34] <Tobba> you'd think with a dynamic language they would have figured out how to avoid remote code execution
[16:48:37] <eddyb> which is surprising, at least a little
[16:48:39] <strcat> eddyb: it's not really a great endorsement ;0
[16:48:48] <Tobba> reddit uses python
[16:48:55] <Tobba> reddit also dies under basicaly any load
[16:48:58] <strcat> Tobba: and gets constant 500 errors :)
[16:48:59] <Tobba> and relies on massive cache servers
[16:49:00] <strcat> yeah
[16:49:10] <eddyb> Tobba: node.js scales like a step further
[16:49:27] <Earnestly> yesod and warp?
[16:49:31] <eddyb> after that you need Rust/what-Rust-tries-to-be
[16:50:00] <whitequark> since we don't see many websites, even high-load, written in C++... guess this isn't a common path for some reason.
[16:50:05] <Tobba> eddyb: by being single threaded and relying on a comparatively slow VM?
[16:50:11] <Tobba> ebay does it I think
[16:50:18] <whitequark> ebay is an exception
[16:50:20] <Tobba> facebook does it
[16:50:24] <eddyb> slow VM?
[16:50:29] <_achin> whitequark: lack of tools is probably a bit reason
[16:50:30] <eddyb> v8?
[16:50:30] <whitequark> no, facebook has HHVM
[16:50:36] <eddyb> whitequark: PHP?
[16:50:42] <Tobba> V8 isnt that slow, but compared to natively compiled code, its slooow
[16:50:47] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[16:50:48] <whitequark> eddyb: a custom PHP VM, HHVM, yes
[16:50:58] <strcat> Tobba: compared to luajit it's sloooooow ;p
[16:51:00] <whitequark> it's actually kinda cool, if you try to forget that it's the damn PHP
[16:51:09] <Tobba> heh yeah
[16:51:09] <eddyb> strcat: what's slow is API calls, I would guess
[16:51:11] <Tobba> luajit rocks
[16:51:18] <eddyb> since luajit has built-in FFI
[16:51:22] <whitequark> V8 is pretty damn impressive considering the language it needs to work with
[16:51:24] <Tobba> though in practice or well, non number crunching
[16:51:27] <strcat> eddyb: v8 itself is a lot slower than luajit just for lang stuff
[16:51:29] <strcat> whitequark: yeah but... luajit
[16:51:29] <Tobba> luajit kinda sucks
[16:51:38] <Tobba> if you're crunching numbers, it owns
[16:51:40] <eddyb> strcat: how so?
[16:51:44] <strcat> whitequark: how can google not compete with 1 guy? ;)
[16:51:49] <whitequark> V8 actually is on-par with firefox on asm.js... without actually implementing "use asm" bullshit
[16:52:22] <eddyb> I like the way they think. sure, you can optimize "use asm", but then you're shitting on any little deviation
[16:52:28] <Earnestly> whitequark: lolwat
[16:52:40] <Earnestly> Sure, on-par with asm.js
[16:52:54] *** Quits: patpat (patpat@moz-85F8C52A.as13285.net) (Ping timeout)
[16:53:09] <whitequark> Earnestly: what I mean is there are constraints of language, which often have a rather hard ceiling
[16:53:15] <strcat> whitequark: luajit beat the language benchmarks game
[16:53:18] *** Joins: patpat (patpat@moz-85F8C52A.as13285.net)
[16:53:19] <strcat> it was up there with C/C++ :P
[16:53:23] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Client exited)
[16:53:23] <Tobba> hah
[16:53:24] *** Joins: remen (petter.rem@moz-BF847080.ias.bredband.telia.com)
[16:53:35] <strcat> before alt lang impls were removed
[16:53:35] <Tobba> as I said, LuaJIT is a tracing JIT; so its amazing for benchmarks basicaly
[16:53:48] <eddyb> strcat: how can luajit beat v8?
[16:53:57] <strcat> eddyb: it's way faster, has a better gc too
[16:53:59] <eddyb> strcat: as in, what does it do better?
[16:54:03] <Tobba> games that use Lua and replaced it with LuaJIT can run slower though
[16:54:04] <eddyb> ah, GC. interesting
[16:54:07] <strcat> eddyb: way faster baseline interpreter
[16:54:11] <strcat> better JIT magic
[16:54:18] <strcat> better GC
[16:54:20] <strcat> amazing C FFI
[16:54:31] <strcat> it's pretty much the best dynamic lang impl out there...
[16:54:33] <strcat> it's faster than the JVM
[16:54:39] <eddyb> the FFI is hardest to fix in v8
[16:54:48] <strcat> as in it's faster than static langs on the JVM
[16:54:57] <strcat> and afaik, it's primarily one person writing it
[16:55:03] <whitequark> well, JVM is a dynamic runtime fundamentally
[16:55:13] <eddyb> though not impossible - I considered exposing Lithium/macro assemblers to JS
[16:55:15] <whitequark> whatever runs on it
[16:55:39] <strcat> anyway I don't really like lua at all
[16:55:43] <strcat> but luajit is really awesome...
[16:55:43] <eddyb> (then you could assemble your own functions. maybe implement a JS-compatible JIT in JS)
[16:55:52] <whitequark> strcat: there was some project that transpiled js to lua basically
[16:55:55] <whitequark> and then ran it with luajit
[16:56:04] <eddyb> whitequark: a subset of JS, right?
[16:56:09] <whitequark> eddyb: I think full JS
[16:56:14] <eddyb> ES3?
[16:56:15] <whitequark> it runs unmodified node modules
[16:56:27] <strcat> lua is pretty similar to js in that it only has doubles and tables
[16:56:31] <whitequark> should be ES3
[16:56:36] <strcat> although I think they are adding (or have added?) integers
[16:56:38] <eddyb> well, sure, most node.js code is ES3 compatible
[16:56:39] <whitequark> eddyb: http://tessel.io/
[16:57:06] <strcat> lua's metatables remind me of js prototypes a bit too... in that they're really weird.
[16:57:08] <eddyb> whitequark: and there's the noduino or something like that
[16:57:10] <whitequark> it's horrible in several other ways, but, I think they solved the task of running JS within limited resources pretty cool
[16:57:17] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[16:57:29] <whitequark> eddyb: that last thing, I think its author once wrote me... one moment
[16:57:33] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[16:58:20] <eddyb> whitequark: aaah, I know
[16:58:22] <whitequark> eddyb: espruino?
[16:58:22] <eddyb> espruino
[16:58:40] <whitequark> it's just a bytecode interpreter
[16:59:10] <whitequark> and a really dumb runtime overall
[16:59:11] <eddyb> espruino runs node.js AFAIK
[16:59:15] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[16:59:21] *** Joins: nulldata (chatzilla@moz-C5F891AC.seas-nve.net)
[16:59:25] <whitequark> I don't think so, it simply has no resources to
[16:59:35] <whitequark> and it's not a full implementation anyway
[17:00:15] <eddyb> "Espruino's JS engine will execute JavaScript in around 1000x less RAM than V8, Rhino or SpiderMonkey. This is what allows us to create a cheap, low-power board."
[17:00:19] <eddyb> come on, cheaters :(
[17:00:29] <whitequark> "HOW POWER EFFICIENT IS ESPRUINO?
[17:00:29] <whitequark> Very. Because it is event based, the Espruino interpreter can put itself to sleep when it knows no action is required.
[17:00:32] <whitequark> This means that code written for Espruino will be substantially more power efficient than the same code written in C, unless the programmer has explicitly added sleep commands and shut down hardware when it is not being used."
[17:00:36] <whitequark> this just makes me so sad.
[17:00:54] <whitequark> http://www.espruino.com/FAQ ←
[17:01:07] <strcat> lol
[17:01:10] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[17:01:15] <strcat> as if js invented events/async
[17:01:15] <eddyb> maybe we just needs to ditch those three and write a JS JIT in Rust for servo
[17:01:19] <strcat> it doesn't even do it very well
[17:01:24] <whitequark> it's just so misguided and ignorant :(
[17:01:26] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[17:01:40] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:01:53] <whitequark> "EVERY DATATYPE IN ESPRUINO IS BASED ON A SINGLE 20 BYTE STORAGE UNIT"
[17:01:56] <whitequark> "ESPRUINO STORES ARRAYS AND OBJECTS IN LINKED LISTS"
[17:01:57] *** Joins: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP)
[17:02:00] * whitequark sighs
[17:02:03] <eddyb> O_O
[17:02:03] <whitequark> http://www.espruino.com/Performance ←
[17:02:08] <eddyb> linked lists?
[17:02:11] <eddyb> they are mad
[17:02:13] <eddyb> truly mad
[17:02:20] <whitequark> yep.
[17:02:31] <eddyb> JS arrays are semantically equivalent to @[@Any]
[17:02:53] <eddyb> you break all but some specific use cases
[17:03:13] *** Quits: nulldata (chatzilla@moz-C5F891AC.seas-nve.net) (Ping timeout)
[17:03:15] <whitequark> well, there was some interesting work on a realtime incremental GC ("Treadmill" by H. Baker), which worked under assumption that memory is divided into equalli sized cells
[17:03:20] <eddyb> strcat: hmm, did you see my comments a few hours ago about quasi-quoting?
[17:03:21] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[17:03:25] <whitequark> but I doubt they actually use that
[17:03:51] <whitequark> "STRINGS OR TYPED ARRAYS ARE THE MOST EFFICIENT WAY TO STORE DATA" hahaha. ha. *sob*
[17:04:03] *** Joins: Cevn (sameer@moz-FD022892.wireless.umd.edu)
[17:04:30] <eddyb> strcat: we can (easily?) make this work: quote_expr!([u8, ..${buffer.len()}])
[17:04:40] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[17:05:10] *** Quits: dwrensha (chatzilla@moz-B23D2FF6.pitbpa.east.verizon.net) (Ping timeout)
[17:05:31] <flaper87> why does NonCopyable implements Drop ?
[17:05:41] <eddyb> flaper87: so it can't be copied :)
[17:05:43] <benh> Because that's how you make something noncopyable. :(
[17:05:44] <g3xzh> error: could not find native static library `rustrt`, perhaps an -L flag is missing?  !!! what the heck!?!?
[17:05:54] <eddyb> g3xzh: make clean
[17:06:08] <g3xzh> eddyb: fast!
[17:06:14] *** Joins: tsurai (Mibbit@moz-D7E15791.versanet.de)
[17:06:27] <eddyb> this used to be common a few weeks ago, I think
[17:06:41] <g3xzh> ;-) alright then
[17:06:53] <flaper87> eddyb: oh, damn, you're right! T_T Dumbest question ever
[17:07:11] <g3xzh> nope... didn't help
[17:07:13] <g3xzh> :\
[17:07:59] <eddyb> g3xzh: you didn't have time to recompile
[17:10:08] *** Joins: shadower (tsedovic@moz-107AD163.redhat.com)
[17:12:24] *** Joins: mib_ukq2v5 (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de)
[17:12:48] <whitequark> eddyb: (JS arrays) but since it has about ~200 elements max anyway, you won't really observe the difference :p
[17:13:00] <eddyb> lol
[17:13:45] <g3xzh> eddyb: i will recompile and install. i hope it will work.
[17:13:46] <g3xzh> thanks
[17:15:13] <whitequark> eddyb: also: comments inside functions make it slower (!)
[17:15:23] <eddyb> *blink*
[17:16:16] <eddyb> LHC? yes, it's me. we need that proton beam. you know, to shoot some... pigeons
[17:17:19] <eddyb> talking about weapons of miniscule destruction - I wonder how much juice they need to create the density required to produce a black hole similar to the ones in Thor 2
[17:17:52] <Tobba> the minimum mass required for a black hole is a few mg I think
[17:17:52] <whitequark> how did they look in Thor?
[17:18:07] <Tobba> look up the planck mass
[17:18:07] *** Joins: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl)
[17:18:16] <whitequark> it's not that hard to make a tiny black hole apparently, it'll just evaporate in a few ms
[17:18:29] <Tobba> mass required for a black hole with the schwarzschild radius of the planck length
[17:18:37] <Tobba> yeah they pretty much decay instantly
[17:19:04] <eddyb> Tobba: the mass is small-ish, but you need to overpower the strong force to get anywhere - I should've asked for energy not "juice" *sigh*
[17:19:20] <Tobba> heh
[17:19:36] <whitequark> eddyb: well, LHC is either capable or borderline capable of creating such black holes, from what I can recall
[17:19:41] <Tobba> though, in theory you dont need to overpower the strong force
[17:19:58] *** Quits: Cevn (sameer@moz-FD022892.wireless.umd.edu) (Ping timeout)
[17:20:06] <eddyb> wait, it's not strong, silly me
[17:20:27] <Tobba> its not strong, and well
[17:20:29] <eddyb> it's "overpower the electric force so the strong force takes over"
[17:20:34] <Tobba> by definition if you have a black hole, it cant break it apart
[17:21:28] <Tobba> so you need like
[17:21:32] <Tobba> Mp*c² joules
[17:21:35] <Tobba> which is basicaly nothing
[17:22:16] <eddyb> though a black hole is all about gravity, isn't it?
[17:22:26] <eddyb> this is pointless methinks *goes back to fiddling with std::fmt*
[17:22:53] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Client exited)
[17:23:07] *** Joins: nulldata (chatzilla@moz-C5F891AC.seas-nve.net)
[17:23:15] *** Joins: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp)
[17:24:14] <whitequark> eddyb: apparently a 72MHz ARM allows to execute a staggering 3.5k iterations per second... combine that with the fact they use bitbanging for communication. yeah.
[17:24:40] *** Quits: jhasse (jhasse@moz-CB992F36.ewe-ip-backbone.de) (Client exited)
[17:25:01] *** Quits: ssira (ssira@moz-DC71C200.kanagawa.ocn.ne.jp) (Ping timeout)
[17:25:09] *** Quits: nulldata (chatzilla@moz-C5F891AC.seas-nve.net) (Ping timeout)
[17:26:07] <eddyb> I'm making everything monadic, almost X_X
[17:27:20] *** Quits: josh (josh@moz-348C4790.hsd1.mn.comcast.net) (Quit: josh)
[17:27:26] *** Joins: short (Mibbit@moz-85C0C507.hsd1.wa.comcast.net)
[17:27:51] *** Quits: mib_ukq2v5 (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de) (Quit: http://www.mibbit.com ajax IRC Client)
[17:28:11] *** Quits: tsurai (Mibbit@moz-D7E15791.versanet.de) (Quit: http://www.mibbit.com ajax IRC Client)
[17:28:25] *** Quits: remen (petter.rem@moz-BF847080.ias.bredband.telia.com) (Quit: remen)
[17:30:15] *** Quits: alonlevy (alon@8BF94F14.BAE2368A.AFF59E38.IP) (Ping timeout)
[17:30:51] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[17:32:16] *** Joins: JamesNZ (james@moz-264643C7.bitstream.orcon.net.nz)
[17:32:36] *** Joins: dwrensha (chatzilla@moz-B23D2FF6.pitbpa.east.verizon.net)
[17:34:01] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:40:35] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[17:41:25] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[17:43:12] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[17:44:27] *** Quits: jix (jix@moz-D969BFFC.de) (Client exited)
[17:46:34] *** Joins: jix (jix@moz-D969BFFC.de)
[17:47:06] *** Joins: nulldata (chatzilla@moz-C5F891AC.seas-nve.net)
[17:47:27] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[17:47:53] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[17:50:17] *** Quits: nulldata (chatzilla@moz-C5F891AC.seas-nve.net) (Ping timeout)
[17:52:41] *** Quits: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net) (Connection reset by peer)
[17:53:00] *** Joins: Erik_ (Erik_S@moz-E7E31D21.hlrn.qwest.net)
[17:53:08] *** Parts: deen_ (deen@moz-DCD53577.dip0.t-ipconnect.de) ()
[17:54:02] *** Joins: sprocket (Mibbit@moz-5BAD9D78.sub-70-194-69.myvzw.com)
[17:54:40] *** Joins: tdc (santegoeds@moz-11C3F42C.range86-159.btcentralplus.com)
[17:55:00] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[17:55:04] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Input/output error)
[17:55:26] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[17:55:29] *** Joins: cosarara (cosarara97@moz-7DC71179.red-88-1-127.dynamicip.rima-tde.net)
[17:55:30] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[17:55:35] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[17:56:16] *** Joins: peterdreid (peterdreid@moz-D18776CD.nc.res.rr.com)
[17:56:23] *** Quits: doener (doener@moz-C68F600D.unity-media.net) (Quit: leaving)
[17:56:36] *** Joins: hoverbear (hoverbear@moz-86FCBF4B.gv.shawcable.net)
[17:56:57] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[17:57:08] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[17:57:12] *** Joins: nano (nano@moz-ED77243C.superkabel.de)
[17:57:14] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[17:58:17] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[17:59:59] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[18:01:52] <cosarara> Hi! What does it mean for an attribute to be only recognized at crate-level? I'm trying to use #[feature(macro_rules)], but adding it to my main.rs seems to do nothing.
[18:02:07] <sprocket> Hello, I'm just starting out with rust using Rust for Rubyists (http://www.rustforrubyists.com/). The second code example in the book (http://www.rustforrubyists.com/book/chapter-01.html) fails on "do 10.times" with the following compiler error: http://pastie.org/8648388. I haven't been able to find any documentation on the times method anywhere else.
[18:02:14] <sprocket> Has it been removed in Rust 0.9?
[18:02:15] *** Joins: remen (petter.rem@moz-BF847080.ias.bredband.telia.com)
[18:02:49] <Erik_> sprocket: yes, it's gone
[18:03:02] *** Quits: moostik (Icedove@moz-1FF02BE5.w92-151.abo.wanadoo.fr) (Ping timeout)
[18:03:06] <Erik_> I believe the new syntax is something like for i in range()
[18:03:08] *** Quits: bvssvni (Mibbit@moz-CBD76C21.bb.online.no) (Quit: http://www.mibbit.com ajax IRC Client)
[18:03:40] <Erik_> rusti: for i in range(0, 10) {         print!("{}  ", i);     }
[18:03:45] -rusti- 0  1  2  3  4  5  6  7  8  9  ()
[18:03:53] <sprocket> Thanks! The range syntax works!
[18:04:03] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[18:04:05] *** Joins: glennsl (textual@moz-5D7B804F.getinternet.no)
[18:05:06] <eddyb> I feel like writing Haskell, almost :/
[18:05:31] *** Joins: JoshK (JoshK@moz-94D285B.dyn.optonline.net)
[18:05:34] <remen> Hey all, I'm trying to build a crosscompiler for targeting raspberry pi (i.e. arm with hard float) using Mac OS X as host. However, I keep running into issues. What is the status of using rust as cross compiler? Are there many known issues with Mac?
[18:05:46] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Ping timeout)
[18:06:02] <remen> Or maybe better to write to mailing list?
[18:07:16] *** Joins: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org)
[18:07:54] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[18:08:06] <FliPPeh> rusti: range(10)
[18:08:09] -rusti- pastebinned 9 lines of output: http://ix.io/9Zm
[18:08:12] <FliPPeh> rusti: range(0,10)
[18:08:14] -rusti- std::iter::Range<int>{state: 0, stop: 10, one: 1}
[18:08:58] <whitequark> is that really syntax? seems like just a function call
[18:09:31] <eddyb> whitequark: it is just a function call
[18:09:44] <eddyb> why does it store "one" inside?
[18:09:54] <eddyb> workaround for associated items not existing?
[18:10:19] <mceier> rusti: range(0,10,2)
[18:10:21] -rusti- pastebinned 9 lines of output: http://ix.io/9Zn
[18:10:48] *** Quits: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru) (Connection reset by peer)
[18:11:28] <mindcat> show me python useful tools XD
[18:12:34] <mindcat> rusti: range<u8>(baka,)
[18:12:36] -rusti- pastebinned 10 lines of output: http://ix.io/9Zq
[18:12:46] <mindcat> rusti: range<u8>(7,9)
[18:12:55] -rusti- failed to pastebin 7 lines of output
[18:13:02] <mindcat> lol
[18:13:22] *** Quits: remen (petter.rem@moz-BF847080.ias.bredband.telia.com) (Quit: remen)
[18:14:20] <kimundi> rusti: range::<u8>(7,9)
[18:14:21] -rusti- std::iter::Range<u8>{state: 7u8, stop: 9u8, one: 1u8}
[18:14:26] *** Joins: remen (petter.rem@moz-BF847080.ias.bredband.telia.com)
[18:14:28] <kimundi> mindcat: missing the :: above
[18:15:13] <cosarara> So, nobody knows where can I put #[feature(macro_rules)] and have it work?
[18:15:28] <kimundi> cosarara: at the top of you crate root, witha  ; after it
[18:16:56] <cosarara> kimundi: thanks! I wasn't using the ;
[18:17:09] *** Joins: mib_d8szdx (Mibbit@moz-4014DDC7.ga.at.cox.net)
[18:17:36] <kimundi> yeah, that trips up pretty much everyone at the first time :)
[18:17:51] <kimundi> a attribute without a ; after it applies to the next item
[18:18:20] *** Quits: mib_d8szdx (Mibbit@moz-4014DDC7.ga.at.cox.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:18:26] <kimundi> But for a crate attribute you want it to apply to the outer module (the crate root itself), which is done by ending them with a ;
[18:18:34] <mindcat> rusti: range::u8(7,9)
[18:18:36] -rusti- pastebinned 13 lines of output: http://ix.io/9Zs
[18:19:03] <strcat> mindcat: the syntax is ::<u8>
[18:19:13] <strcat> although you could also add a suffix to one of the literals
[18:19:24] *** Quits: kris_ (kris@moz-5A7B69C7.math.ku.dk) (Ping timeout)
[18:19:46] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[18:20:44] <mindcat> I think it is werid(?)
[18:21:04] <kimundi> mindcat: what is weird?
[18:21:38] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[18:23:11] <mindcat> kimundi: '::' this part
[18:23:20] *** Quits: dv (dv@4E84A121.6B684CF9.27E2265F.IP) (Client exited)
[18:23:48] <kimundi> mindcat: Its their because otherwise there is a parsing ambiguity in expressions
[18:25:18] *** Quits: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net) (Quit: jmgrosen)
[18:25:36] <FliPPeh> there*
[18:27:33] <mindcat> kimundi: so it is rust language world, a setting part lol
[18:27:51] <kimundi> hm?
[18:28:22] <kimundi> I don't understand :P
[18:28:41] *** Joins: LRN (LRN@moz-50DF30B.nationalcablenetworks.ru)
[18:29:42] <mindcat> kimundi: I am learning C艹
[18:30:15] <peterdreid> What is the syntax for declaring a borrowed pointer to a raw pointer with a named lifetime in a struct? My best guess is "foo: &*'a int", but that is apparently wrong.
[18:30:28] <eddyb> peterdreid: &'a *int
[18:30:31] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[18:30:34] <kimundi> peterdreid: raw pointers don'T have lifetimes
[18:30:50] <peterdreid> Oooh, I see
[18:30:51] <peterdreid> Thanks
[18:30:53] <eddyb> or just &*int if the lifetime is really for the raw pointer
[18:31:03] <SiegeLord> I really wish people wouldn't move stuff out of std until the package story got figured out
[18:31:21] <strcat> SiegeLord: what's being moved out of std?
[18:31:32] <SiegeLord> Some numeric stuff, most recently
[18:31:39] <eddyb> SiegeLord: that's just being removed
[18:31:39] <cmr> it wasn't moved, it was removed.
[18:31:52] <cmr> num-rs doesn't have it, it has a different numeric tower.
[18:31:53] <eddyb> it's refactoring, not splitting out
[18:32:00] <SiegeLord> And somehow they think that FFI is an acceptable alternative
[18:32:24] <SiegeLord> Those functions have to be somewhere, and if not in std/extra, they'll be in a 3rd party library
[18:32:36] <eddyb> SiegeLord: which functions?
[18:32:48] <SiegeLord> Any of the removed ones...
[18:32:54] <eddyb> as far as I've understood, functionality is not being removed, just implementation
[18:33:04] *** Joins: fabiand (fabiand@moz-159A3D86.static.qsc.de)
[18:33:05] <bjz> cmr: washappening?
[18:33:14] <eddyb> SiegeLord: name a few
[18:33:16] <mindcat> I don't know what is raw pointer, wheres documents?
[18:33:22] <cmr> eddyb: lgamma, j0, etc.
[18:33:27] <SiegeLord> eddyb: https://github.com/bjz/rust/commit/1246f0b09441d47cdf29d0d7852a1d1a87533756
[18:33:34] <eddyb> cmr: oooh, I didn't know about those
[18:33:36] <cmr> I think FFI is a fine substitute.
[18:33:41] <SiegeLord> No, it's not
[18:33:42] *** Quits: alonlevy (alon@moz-EB7C9CF3.telavivmakers.org) (Ping timeout)
[18:33:49] <kimundi> mindcat: *T is a raw pointer to a T, as opposed to &T which is a safe reference to a T
[18:33:51] <eddyb> the problem with calling to C is safety
[18:33:59] <SiegeLord> It's not as concise as use, and you need to plop an unsafe block everywhere
[18:34:23] <SiegeLord> Even if you gained an ability to mark C functions as safe, you'd still have to create an unsafe block
[18:34:26] <SiegeLord> *extern block
[18:34:30] <eddyb> SiegeLord: you do realize you can write wrappers, right?
[18:34:39] <cmr> SiegeLord: it's not like it's permanent.
[18:34:40] <bjz> SiegeLord: the issue is whether they need to be in the std. they are not even in ieee754. We could have them in libnum though
[18:34:50] <SiegeLord> eddyb: use std::num::RealExt; is the old way to do it
[18:35:01] <SiegeLord> eddyb: Give me a wrapper that fits in that many characters please :P
[18:35:18] <mindcat> kimundi: are you talking about rust?
[18:35:30] <SiegeLord> bjz: Which brings me to the very beginning, where I said the package story needs to be figured out first
[18:35:48] <eddyb> mindcat: yes he is
[18:35:52] <kimundi> Siegelord: extern mod r;use r::R
[18:35:58] <SiegeLord> Right now I see batteries being taken out with some nebulous "rustpkg will make using 3rd party libraries easy to use"
[18:36:14] <SiegeLord> Where rustpkg is unusable as is
[18:36:22] <eddyb> RealExt is far from batteries
[18:36:32] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[18:36:51] <SiegeLord> I'm doing a course right now and they're using Python
[18:37:05] <SiegeLord> They're reimplementing the matrix class because Python doesn't have it built in :P
[18:37:31] <kimundi> mindcat: yes
[18:37:34] *** Joins: hdevalence (quassel@moz-D125A39F.home3.cgocable.net)
[18:37:35] <bjz> SiegeLord: matrices can be implemented in different ways for different applications
[18:38:16] <strcat> bjz: but it's python, you pretty much might as well use numpy ;p
[18:38:31] <eddyb> type Mat2<T, N, M> = [[T, ..M], ..N];
[18:38:53] <SiegeLord> Maybe it's a bad example...
[18:39:08] <bjz> eddyb: \o/
[18:39:20] <eddyb> bjz: not valid currently
[18:39:21] <mindcat> well, I want split tcpstream before and now, but I didn't research how to
[18:39:28] <bjz> eddyb: aye
[18:39:53] *** Joins: gwty (gwtypc@E2C142AC.FA920D05.137C914F.IP)
[18:40:16] <bjz> eddyb: I know that
[18:41:43] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[18:42:09] * mindcat at bed do something with android phone
[18:42:35] *** Parts: remen (petter.rem@moz-BF847080.ias.bredband.telia.com) ()
[18:42:59] <mindcat> well, its time to sleep, its very late
[18:43:13] *** Quits: squiddy (squiddy@moz-F847A3EE.adsl.alicedsl.de) (Ping timeout)
[18:43:26] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[18:44:23] *** Quits: Leo` (Leo@moz-83832FE2.placeholder.fr) (Ping timeout)
[18:45:57] *** Joins: josh (josh@moz-C350AC70.hsd1.mn.comcast.net)
[18:46:37] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Ping timeout)
[18:46:49] *** Joins: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru)
[18:47:41] *** Joins: Leo` (Leo@moz-83832FE2.placeholder.fr)
[18:48:01] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[18:48:30] *** Quits: oberstet (quassel@moz-287E3326.dynamic.mnet-online.de) (Client exited)
[18:49:21] *** Joins: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net)
[18:49:43] *** Joins: squiddy (squiddy@moz-F847A3EE.adsl.alicedsl.de)
[18:52:03] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[18:55:57] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[18:57:15] *** Joins: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com)
[18:57:37] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Ping timeout)
[18:57:41] <Matthias247> no simple mutex/condvar in std?
[18:58:12] <busylizzy> Matthias247: there is ones in extra
[18:58:14] <cmr> Matthias247: std::unstable::sync
[18:59:03] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[18:59:39] <Matthias247> ok, I'll look the unstable one up. It's not in the documentation
[18:59:53] <cmr> it's not in the documentation because you're not supposed to use it :p
[18:59:57] <Matthias247> The one in extra is too highlevel for what I need
[19:00:16] *** Quits: fabiand (fabiand@moz-159A3D86.static.qsc.de) (Quit: Verlassend)
[19:00:47] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[19:01:07] <busylizzy> cmr: does the standard library have implementation of common algorithms? sort, Nth element, binary search, etc..
[19:01:14] <strcat> yes
[19:01:32] <eddyb> Nth element?
[19:01:39] <cmr> eddyb: .nth()
[19:01:47] <cmr> (on iterators)
[19:01:48] *** Joins: dmz (Mibbit@moz-F30E0473.cpe.net.cable.rogers.com)
[19:01:53] <busylizzy> i didn't find these algorithms
[19:01:58] <strcat> there are sort and binary search on vectors
[19:02:03] <strcat> busylizzy: did you use the doc search?
[19:02:16] <cmr> although that's probably not the Nth element they meant.
[19:02:30] <eddyb> cmr: I have that feeling as well, that's why I asked
[19:03:17] *** Quits: luz (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[19:03:18] <busylizzy> strcat: oops.
[19:04:04] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[19:04:19] *** Quits: g3xzh (g3xzh@moz-FE980943.red.bezeqint.net) (Ping timeout)
[19:04:28] <dmz> I have a question. There is a zip() on iterators to merge, but I can't find any split() of sorts to split an iterator in two. Can I achieve that without writing my own iterator?
[19:04:37] *** Quits: luz (lucy@moz-CD18B14B.customer.cdi.no) (Quit: 04←)
[19:04:47] *** Joins: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br)
[19:04:57] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[19:05:09] <eddyb> dmz: an iterator on tuples?
[19:05:21] <strcat> dmz: clone() it? what do you mean split?
[19:05:27] *** Joins: jhasse (jhass_000@moz-CB992F36.ewe-ip-backbone.de)
[19:05:31] <busylizzy> eddyb: i meant order statistic
[19:05:36] *** Quits: bjustin (bjustin@moz-4B914826.hsd1.mn.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[19:05:36] <pepper_chico> I got curious about this, I was trying do assign a value for a variable of such type, but was unable to do so
[19:05:38] <pepper_chico> http://stackoverflow.com/questions/21214964/primitive-types-in-rust-enums
[19:05:45] <cmr> Iterator<(A, B)> -> (Iterator<A>, Iterator<B>) I imagine?
[19:05:47] <strcat> dmz: clone() it and map() each one
[19:05:53] <cmr> yeah
[19:05:53] <dmz> cmr: yes
[19:05:56] <dmz> ah ok
[19:05:58] <dmz> hmm
[19:06:08] <eddyb> dmz: needs variadic generics I would think, to implement it in the library
[19:06:16] <cmr> pepper_chico: that's not doing what you think it's doing.
[19:06:19] <strcat> dmz: iterators are usually very cheap to clone, as for example the vector iterator is 2 ptrs (+ padding that will go away)
[19:06:30] <pepper_chico> cmr, what is it doing?
[19:06:35] <cmr> pepper_chico: that's creating variants *named* f64 and i32, not using those types.
[19:06:48] <pepper_chico> ah, I though of that too =)
[19:06:55] <pepper_chico> but, aaaa
[19:07:08] <eddyb> waste of stackoverflow HDD space IMO
[19:07:11] <pepper_chico> variants with integer values
[19:07:24] <cmr> enum A { float(f64), int(i32) }
[19:07:24] <dmz> strcat: ok, thanks. I was hoping for a less verbose solution, but the clone() is at least available right now
[19:07:30] <pepper_chico> it's not mine, I just got curious
[19:07:54] <cmr> let x: A = float(42.0); let y: A = int(42); match x { float(a) => { ... }, int(a) => { ... } }
[19:07:56] <cmr> as a small example
[19:08:11] <cmr> bstrie_nope: people are using stack overflow to ask rust questions again.
[19:08:14] <eddyb> keep in mind you're shadowing int
[19:08:37] <pepper_chico> and float
[19:08:42] <eddyb> float isn't a thing
[19:08:46] *** Quits: luz (lucy@moz-CD18B14B.customer.cdi.no) (Ping timeout)
[19:08:51] <cmr> rusti: enum A { float(f64), int(i32) }; let x: int = 42; let y = int(x); y
[19:08:53] <eddyb> (so enum Num {Float(f64), Int(i32)} would be better
[19:08:57] -rusti- pastebinned 7 lines of output: http://ix.io/9Zz
[19:09:04] *** Joins: luz (lucy@moz-CD18B14B.customer.cdi.no)
[19:09:09] <cmr> rusti: enum A { float(f64), int(i32) }; let x: int = 42; let y = int(x as i32); y
[19:09:11] -rusti- int(42i32)
[19:09:12] <cmr> you aren't shadowing anything
[19:09:23] <eddyb> hmm, true, it's a ctor not a type. ignore me :)
[19:09:39] <busylizzy> nope, iter::nth is not that algorithm which i meant. i was saying about oreder statistic.
[19:09:51] <eddyb> busylizzy: wikipedia link?
[19:10:13] <eddyb> (to the precise thing you're talking about)
[19:10:14] <busylizzy> eddyb: http://en.wikipedia.org/wiki/Order_statistic :)
[19:10:16] <pepper_chico> ok then, thanks anyway, if anyone cares to answer the guy who posted the SO question, feel free =)
[19:10:48] *** Quits: Erik_ (Erik_S@moz-E7E31D21.hlrn.qwest.net) (Ping timeout)
[19:10:51] <eddyb> busylizzy: oh, I thought Nth element was something specific, silly me
[19:11:12] <busylizzy> c++ stantard library has implementation of that http://en.cppreference.com/w/cpp/algorithm/nth_element
[19:11:51] <eddyb> ah, a partial sorting algorithm, interesting
[19:12:09] *** Joins: zxcdw (r-a@5F0EDB29.B543C4DE.3933CC16.IP)
[19:12:18] <eddyb> we could probably implement it for &mut [T], I guess
[19:13:10] <mindcat> rusti: let a : *int = 1;a
[19:13:13] -rusti- pastebinned 7 lines of output: http://ix.io/9ZA
[19:13:20] *** Quits: strcat (strcat@moz-54F7FD49.cpe.net.cable.rogers.com) (Quit: WeeChat 0.4.2)
[19:13:21] *** Quits: Mathias (Mibbit@moz-E9EEAB4.cpe.webspeed.dk) (Quit: http://www.mibbit.com ajax IRC Client)
[19:13:28] <mindcat> rusti: let a = *1;a
[19:13:31] -rusti- pastebinned 7 lines of output: http://ix.io/9ZB
[19:14:11] <kimundi> mindcat: You can only create a *T by coercing a &T to it, and it is unsafe to dereference such a pointer
[19:14:39] *** Joins: alonlevy (alon@moz-AFF00A6D.bb.netvision.net.il)
[19:14:59] <kimundi> rusti: let a = 5; let b = &a; let c = b as *int; c
[19:15:01] -rusti- (0x7f86e697ed20 as *())
[19:15:23] <pepper_chico> ok, I posted the answer there
[19:15:25] <busylizzy> eddyb: but partition is implemented only for ~[T]
[19:15:29] <kimundi> The fact that this prints is also a great example of use-after-free :P
[19:15:44] *** Joins: m-r-r (mrr@moz-84B6E1ED.rev.sfr.net)
[19:15:46] <kimundi> As you got a dangling pointer there :P
[19:15:54] <bjz> m-r-r: o/
[19:16:06] <mindcat> kimundi: like C/C艹?
[19:16:16] <m-r-r> Hi
[19:16:29] <kimundi> mindcat: What like C/C++ ?
[19:16:43] <bjz> m-r-r: see, loads more folks here ^_^
[19:16:50] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[19:17:05] <Matthias247> what is unsafe about Mutex::new? :)
[19:17:22] *** Joins: mouse_ (mouse@moz-EC760D71.broadband.corbina.ru)
[19:17:29] <m-r-r> bjz: indeed :-)
[19:17:32] *** Joins: lucian (lucian@moz-8408FDFA.cable.virginm.net)
[19:17:40] <m-r-r> So, i'm trying to create a Rust workspace that contains both a library and a command-line tool, is it possible ?
[19:17:49] *** Quits: lucian (lucian@moz-8408FDFA.cable.virginm.net) (Quit: Leaving...)
[19:17:54] *** Quits: mouse (mouse@moz-32DFB3CF.broadband.corbina.ru) (Ping timeout)
[19:18:38] <bjz> m-r-r: with rustpkg I assume?
[19:18:40] <Florob> kimundi, why is that dangling? `a` seems relatively life to me. And printing a pointer value is hardly use-after free :P
[19:19:02] <m-r-r> bjz: Yes. I've put my library in a `lib` directory, and rustpkg builds it, but it doesn't builds the files in my `bin` directory...
[19:19:03] *** Quits: sprocket (Mibbit@moz-5BAD9D78.sub-70-194-69.myvzw.com) (Quit: http://www.mibbit.com ajax IRC Client)
[19:19:12] *** Quits: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com) (Ping timeout)
[19:19:22] <bjz> m-r-r: rustpkg is a super massive pain atm
[19:19:28] <kimundi> Florob: The pointer itself is dangling. Priniting its value is indeed not use-after-free,
[19:19:35] <cmr> m-r-r: don't bother with rustpkg.
[19:19:43] <eddyb> mindcat: please note that you shouldn't be touching unsafe pointers unless you need them
[19:19:44] * cmr is writing a package manager at this very instant.
[19:19:45] <bjz> m-r-r: it only really works in the simplest case :(
[19:19:50] <bjz> cmr: !!!!!!
[19:19:53] <bjz> :O
[19:19:54] <eddyb> O_O
[19:19:58] <bjz> !!!!
[19:20:02] <bjz> \o/
[19:20:07] <cmr> it's just a python POS, don't get too excited
[19:20:13] <eddyb> BAH
[19:20:14] <bjz> oh
[19:20:19] <kimundi> HAHA
[19:20:21] <mindcat> rusti: let a = [0,1,2,3,4]; let b: *int; b = &a; b
[19:20:22] <bjz> gah
[19:20:23] -rusti- pastebinned 7 lines of output: http://ix.io/9ZC
[19:20:29] *** Quits: japaric (japaric@5F207A99.A347E168.F4D5766F.IP) (Ping timeout)
[19:20:30] <cmr> but it will at least work :)
[19:20:32] * bjz scolds cmr
[19:20:34] <SiegeLord> Can I use write! without moving out of the writer I pass to it?
[19:20:49] *** Quits: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br) (Quit: Ex-Chat)
[19:21:00] <eddyb> SiegeLord: it takes a &mut Writer so you can't move into it
[19:21:00] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[19:21:05] <cmr> bjz: I'd use Rust if I didn't want to release it today :p
[19:21:09] <mindcat> eddyb: yes.
[19:21:21] <m-r-r> so, how should-I package the command line tool that comes with my library ?
[19:21:26] <SiegeLord> eddyb: It's not clear to me why that's a permanent operation
[19:21:27] <bjz> cmr: haw haw
[19:21:37] <eddyb> SiegeLord: I said *you can't move into it*
[19:21:48] <eddyb> SiegeLord: that is, it should never be able to consume the writer
[19:21:56] <SiegeLord> I can temporarily borrow &mut T from T... is it not possible to create a &mut Trait temporarily?
[19:22:11] <kimundi> SiegeLord: It is possible
[19:22:12] <cmr> `&mut whatever` ?
[19:22:16] <eddyb> of course it is, that's how you use write!
[19:22:17] <bjz> m-r-r: Make or CMake! Or a line in the README that you can copy paste
[19:22:35] <bjz> m-r-r: atate of the art Rust package management
[19:22:42] <bjz> -_-#
[19:22:53] <eddyb> (technically, write is broken that it uses a trait object, but I'll see if my changes improve it or make it worse)
[19:22:57] *** Quits: mouse_ (mouse@moz-EC760D71.broadband.corbina.ru) (Ping timeout)
[19:23:14] <cmr> eddyb: it uses a trait object to avoid bloat.
[19:23:34] <bjz> cmr: what would you recommend for m-r-r 
[19:23:34] <eddyb> cmr: what bloat :)?
[19:23:50] <cmr> bjz: exactly what you recommended.
[19:24:03] <bjz> cmr: yay I got it right
[19:24:10] <eddyb> cmr: it's really way more bloated because it can't be inlined
[19:24:15] <bjz> (unfortunately)
[19:24:19] *** Joins: LinearInterpol (RJones@moz-E6F82C3A.maine.res.rr.com)
[19:24:23] *** flaper87 is now known as flaper87|afk
[19:24:45] <bjz> m-r-r: sorry, package management is a well known pain point
[19:25:17] <eddyb> keep in mind format strings are constant and we still do ~3 virtual calls per item to format + all the matching on otherwise constant values
[19:25:28] <bjz> m-r-r: it's hurting the mozilla devs over on servo too, so they are well aware :(
[19:25:43] <m-r-r> ok, I think i'll use a shell script :-p
[19:26:08] <m-r-r> are there a lot of people working on Rust ?
[19:26:09] *** Quits: alonlevy (alon@moz-AFF00A6D.bb.netvision.net.il) (Ping timeout)
[19:26:15] <SiegeLord> The bloat doesn't come from constant strings, it comes from the argument types
[19:26:22] <bjz> m-r-r: atm rustpkg is in a state of disrepair - the tests have even been disabled on our buildbot because they never pass... -_-
[19:26:33] <bjz> m-r-r: yes
[19:26:37] <eddyb> we say "format!/print!/write! generate code to do the formatting" but it's wrong, they generate essentially *bytecode* for the interpreter in std::fmt
[19:26:45] <cmr> m-r-r: 407 contributors :)
[19:26:58] <bjz> m-r-r: for an emerging lang there are a surprising number of contributors
[19:27:07] <cmr> https://www.ohloh.net/p/rust-lang
[19:27:32] <sp3d> eddyb: so rustc can't optimize the bytecode, e.g. to turn fmt! on a literal to just a literal?
[19:27:40] <bjz> m-r-r: https://www.ohloh.net/p/rust-lang/factoids#FactoidTeamSizeVeryLarge
[19:27:41] <eddyb> SiegeLord: it's easy to make the current design turing complete
[19:27:48] <cmr> we're in the top 2% of projects on ohloh, in terms of contributors.
[19:27:48] <bjz> cmr: oh, you beat me
[19:28:08] <cmr> bjz: you also beat me, I was looking for that exact link :p
[19:28:10] <mindcat> oh *bytecode* marcos
[19:28:15] <bjz> haw haw
[19:28:17] <SiegeLord> eddyb: Why is that relevant?
[19:28:40] <eddyb> SiegeLord: we throw away the information we have
[19:29:21] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[19:29:28] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[19:29:28] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[19:29:31] <eddyb> and then we feed a tape to std::fmt
[19:29:36] <eddyb> *it can do recursion*
[19:29:39] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Quit: )
[19:29:54] * mindcat cooks called "bjz" XD
[19:30:05] *** Joins: io2 (io2@moz-871549F5.home.otenet.gr)
[19:30:20] *** Joins: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se)
[19:30:20] <bjz> mindcat: huh?
[19:30:26] <eddyb> SiegeLord: I gtg now. see my partial rewrite: https://gist.github.com/eddyb/f3ef987ea2d965d598d5 Ctrl+F not(stage0) - and my abuse of continuations
[19:31:23] *** Joins: alonlevy (alon@moz-AFF00A6D.bb.netvision.net.il)
[19:31:36] <eddyb> (really, now I'm tempted to add that missing feature to allow someone to perform arbitrary computations in format strings)
[19:31:43] *** Quits: dmac (dmac@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[19:32:35] <SiegeLord> As long as the new design doesn't create template bloat, then it might be good
[19:33:37] *** Joins: Mathias (Mibbit@moz-E9EEAB4.cpe.webspeed.dk)
[19:35:13] *** Joins: Florob (Florob@moz-39532932.de)
[19:35:25] <pyon> How do I make a task wait for all its children to finish?
[19:36:14] <kimundi> pyon: You could wait on "finish" message for all of them - not sure if there is a better waythough
[19:36:36] <pyon> Ah, right!
[19:36:38] <pyon> ty
[19:38:15] *** Joins: mouse_ (mouse@moz-4658FC81.broadband.corbina.ru)
[19:38:38] *** Quits: josh (josh@moz-C350AC70.hsd1.mn.comcast.net) (Quit: josh)
[19:38:58] *** Joins: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP)
[19:39:03] *** Joins: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net)
[19:39:40] *** Quits: nano (nano@moz-ED77243C.superkabel.de) (Connection reset by peer)
[19:39:49] *** Joins: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net)
[19:41:03] *** Quits: enix (enix@moz-A50569DD.c3-0.slvr-ubr1.lnh-slvr.md.cable.rcn.com) (Ping timeout)
[19:42:44] <SiegeLord> kimundi: I'm having trouble with creating it. http://pastebin.ca/2560578
[19:44:40] <kimundi> SiegeLord: Huh, strange. MemWriter does implement the right trait, right? But that does indeed look like it should work...
[19:45:02] <kimundi> SiegeLord: Oh wait, I think I know the problem
[19:45:10] <cmr> SiegeLord: the weirdness is because the macro is stupid.
[19:45:10] <kimundi> SiegeLord: It has a really silly fix :P
[19:45:17] <cmr> use write!(&mut *w, "")
[19:45:57] <SiegeLord> I like it. Thanks
[19:46:04] <kimundi> Does it work?
[19:46:05] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[19:46:07] <SiegeLord> Yep
[19:46:13] <kimundi> oh, okay
[19:46:28] *** Quits: awidegreen (awidegreen@moz-9FADBE94.a357.priv.bahnhof.se) (Ping timeout)
[19:48:15] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[19:49:09] <johnsoft> looks like something broke rust-http
[19:49:26] <johnsoft> I might need to find something else to do for a few days
[19:49:37] <cmr> johnsoft: the rvalue lifetimes stuff broke &'static, it seems.
[19:49:54] *** Joins: Soft (soft@moz-EC8D39F.yok.fi)
[19:50:17] *** Joins: madjar (uid18432@moz-A42E5B7B.irccloud.com)
[19:50:24] <madjar> Hi there
[19:50:34] <johnsoft> does that have anything to do with enum equality?
[19:50:39] <johnsoft> src/main.rs:28:17: 28:55 error: binary operation `==` cannot be applied to type `http::method::Method`
[19:50:39] <johnsoft> src/main.rs:28     let equal = http::method::Get == http::method::Get;
[19:51:12] <madjar> I'm packaging rust for nixos. Is there a way to use the system llvm instead of recompiling it ? Or is compiling mandatory (because of patches, for example) ?
[19:51:20] <cmr> madjar: we have patches, yes.
[19:51:48] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[19:52:13] <madjar> cmr: okay, thanks. Will they land upstream at some point, or are they here to stay ?
[19:52:30] <cmr> madjar: we hope to upstream them eventually.
[19:52:52] <madjar> great, thanks
[19:52:53] <cmr> madjar: thanks for packaging us :)
[19:53:00] <madjar> no problem :)
[19:53:51] <madjar> the snapshot is quite a pain because the build process can't access the web, but I managed to make it work
[19:54:29] *** Quits: mouse_ (mouse@moz-4658FC81.broadband.corbina.ru) (Ping timeout)
[19:55:38] <johnsoft> hmm, just tried recompiling rust-http with rust master, it looks like CharIterator was removed since 0.9?
[19:56:04] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[19:56:05] <cmr> johnsoft: renamed to std::str::Chars
[19:56:14] *** Quits: alonlevy (alon@moz-AFF00A6D.bb.netvision.net.il) (Ping timeout)
[19:56:19] <johnsoft> ah
[19:56:24] <cmr> see http://cmr.github.io/blog/2014/01/18/this-week-in-rust/
[19:56:26] *** Joins: alonlevy (alon@moz-AFF00A6D.bb.netvision.net.il)
[19:56:40] *** Joins: deggert (deggert@moz-2C16B246.host.de.colt.net)
[19:57:35] *** Joins: mouse_ (mouse@moz-813060C4.broadband.corbina.ru)
[19:57:35] *** Quits: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net) (Quit: Sharp)
[19:57:55] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[19:58:32] <johnsoft> handy, thanks
[19:59:31] *** Joins: Sharp (Sharp@moz-EEC85237.hsd1.ca.comcast.net)
[19:59:46] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[19:59:47] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[20:00:15] *** Quits: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP) (Quit: sp3d)
[20:01:32] *** Joins: adwhit (Mibbit@moz-54C61813.cable.virginm.net)
[20:01:37] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[20:02:05] *** Joins: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP)
[20:02:22] <adwhit> Hi - can I have an opinion on whether this is a bug?
[20:02:42] <cmr> adwhit: sure
[20:02:55] *** Joins: jeaye (jeaye@moz-34FEF2BB.hsd1.ca.comcast.net)
[20:03:21] <adwhit> If you use range_step(10,0,-1) but using uints, then -1 -> ffffff... and it silently fails
[20:03:50] <adwhit> now this is sort of expected behaviour but I just got caught out because of type inference
[20:04:15] <adwhit> my start variable was a uint, so the rest was inferred to uint also
[20:04:34] <adwhit> took ages to find the problem! maybe should be a warning or something?
[20:04:52] <SiegeLord> rusti: let a: uint = -1; a
[20:04:54] <cmr> definitely not a bug, but there's an issue for negative literals on unsigned types.
[20:04:57] <whitequark> should -1 silently coerce to uint? I'd say no
[20:04:58] -rusti- 18446744073709551615u
[20:05:05] <cmr> (for warning on it, that is)
[20:05:19] <whitequark> not with generic integers at least, you never know what the actual value will be
[20:05:36] <cmr> I agree. -1u shouldn't be a warning, but -1 should be.
[20:05:49] <cmr> (when it infers to an unsigned type)
[20:06:04] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[20:06:39] <cmr> https://github.com/mozilla/rust/issues/5477
[20:07:15] <adwhit> cool, thanks!
[20:07:50] *** Joins: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de)
[20:08:01] <SiegeLord> I forget... is vec::build discouraged?
[20:08:06] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[20:08:06] *** Joins: james4k (james@moz-E7990244.consolidated.net)
[20:08:22] <cmr> SiegeLord: yes
[20:08:35] <SiegeLord> Seems like a useful function... oh well
[20:08:45] <kimundi> What dos it do?
[20:08:53] <kimundi> does*
[20:08:59] <cmr> SiegeLord: what are you using it for?
[20:09:00] *** Joins: morganb (morgan_b_@moz-5EAC75A2.hfc.comcastbusiness.net)
[20:09:00] *** Quits: deggert (deggert@moz-2C16B246.host.de.colt.net) (Quit: deggert)
[20:09:12] <SiegeLord> I think its an optimization to with_capacity and then a bunch of pushes
[20:09:16] <cmr> IMO all of the second-order-or-higher construction functions should be removed.
[20:09:22] <SiegeLord> Which is exactly what I'm about to do
[20:09:48] *** Quits: james4k (james@moz-E7990244.consolidated.net) (Ping timeout)
[20:09:56] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[20:11:39] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[20:13:36] <indirect> so I feel like I'm missing something obvious, but why can't I define a trait with two functions that have the same name but different argument types?
[20:13:44] <SiegeLord> cmr: This is what I'm doing: http://pastebin.ca/2560589
[20:13:49] <cmr> indirect: beause we don't have overloading.
[20:14:09] <indirect> cmr: oh
[20:14:24] <indirect> well that would explain things :P
[20:14:47] *** Quits: alonlevy (alon@moz-AFF00A6D.bb.netvision.net.il) (Ping timeout)
[20:15:57] <cmr> SiegeLord: and you'd rather have vec::build(|push| { for ... { for ... { ... push(sin(x) * sin(y)); } } } }); ?
[20:16:02] <cmr> well, with the len.
[20:16:38] *** Joins: carllerche (carllerche@moz-CA3FF5F1.hsd1.or.comcast.net)
[20:16:38] <SiegeLord> It's shorter by a line, I suppose
[20:16:51] <SiegeLord> Don't need to freeze it back up
[20:17:07] <cmr> that's ture
[20:17:09] <cmr> *true
[20:18:23] *** Joins: joebobjoe (Dale@moz-4014DDC7.ga.at.cox.net)
[20:18:32] <joebobjoe> What's the difference between generics and macros?
[20:18:33] <carllerche> while loop conditions must be boolean statements? it would be nice if you could do: while Some(v) = maybe_get_something() { … }
[20:18:35] *** Quits: summerlight (summerligh@327FC32B.2C956A45.501EFF44.IP) (Ping timeout)
[20:18:43] *** Joins: JustAPerson (JustAPerso@EAC6AADA.C1481309.D9401097.IP)
[20:18:48] *** Quits: dwrensha (chatzilla@moz-B23D2FF6.pitbpa.east.verizon.net) (Ping timeout)
[20:18:59] <cmr> joebobjoe: they're entirely unrelated.
[20:19:14] <cmr> joebobjoe: generics are a type-level feature, macros are a syntax-level feature.
[20:20:01] <joebobjoe> cmr: Hm. Okay, thanks.
[20:20:50] *** Quits: jackneill (jackneill@moz-E9D68037.pool.digikabel.hu) (Ping timeout)
[20:21:59] <cmr> carllerche: I find loop { match maybe_get_something() { Some(v) => { ... }, None => break } } to be heartily better. Removes a special case that would be refutable patterns in `while` "conditions"
[20:22:55] <cmr> carllerche: as an aside, maybe_get_something() could be an iterator and then you'd be able to use for loops and all the other iterator niceties.
[20:22:57] * cmr afk
[20:27:22] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:29:04] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Ping timeout)
[20:29:23] *** Quits: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net) (Quit: I haz left.)
[20:29:32] *** Joins: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net)
[20:32:37] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[20:33:34] *** Quits: eibwen (kvirc@moz-DB2F0689.dip0.t-ipconnect.de) (Ping timeout)
[20:33:40] *** Joins: alonlevy (alon@moz-AFF00A6D.bb.netvision.net.il)
[20:33:48] *** Joins: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com)
[20:35:14] *** Joins: nif (nif@moz-8181E2AC.oberlin.net)
[20:38:04] *** Quits: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca) (Quit: Leaving.)
[20:38:23] *** Joins: fabiand (fabiand@moz-3814939D.static.hackerspace-bremen.de)
[20:38:26] <fabiand> hey
[20:38:27] <lexs> is there a way to force priority when expanding macros? "asm!(concat!!("mov %", $reg, ", $0") : "=r"(value));" fails because it tries to expand asm! first
[20:38:47] <fabiand> I had some example rs code which worked with 0.8 - but with 0.9 I get:  Package rustyworld depends on std, but I don't know how t
[20:38:51] <fabiand> o find it
[20:39:08] <fabiand> can someone tell me how I can tell rust where to find the std lib?
[20:39:54] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Quit: WeeChat 0.4.2)
[20:40:22] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[20:40:35] <jhasse> fabiand: looks like a bug
[20:40:39] <jhasse> windows?
[20:40:55] <sfackler> lexs: no
[20:41:03] <fabiand> jhasse, na - linux
[20:41:11] <lexs> sfackler: arghh :(
[20:41:57] <jhasse> fabiand: try a complete rebuild
[20:42:08] *** Joins: leroux (leroux@moz-421CF1E4.dsl.bell.ca)
[20:42:28] *** Quits: alisdair (textual@28441AAB.AC6E1995.F0AE27BD.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[20:42:43] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[20:42:57] <jhasse> fabiand: /usr/local/lib/rustc was renamed to /usr/local/lib/rustlib
[20:44:39] <fabiand> jhasse, that is what I tried (rebuild): http://fpaste.org/69850/16425613/
[20:45:13] <fabiand> jhasse, and my fs layout: http://paste.fedoraproject.org/69851/13901642
[20:45:29] <jhasse> fabiand: rm -rf .rust bin lib build
[20:45:43] *** Quits: madjar (uid18432@moz-A42E5B7B.irccloud.com) (Quit: )
[20:45:56] <fabiand> same, jhasse 
[20:46:24] <SiegeLord> Man... I wish you could coerce small integers into larger ones. I just know though that if that were added, people would ask to be able to overload it, and then it'd be abused
[20:46:32] <fabiand> In a complete sentence: There is no change when I also remove those dirs :-/
[20:47:12] <jhasse> can you try `RUST_LOG=rustpkg=4 rustpkg build rustyworld`
[20:47:19] <jhasse> should give more output
[20:47:52] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[20:48:38] <fabiand> jhasse, ah .. I think the system wide search path is not in the workspace
[20:49:01] <fabiand> http://paste.fedoraproject.org/69855/13901645
[20:49:46] <jhasse> fabiand: you've passed hello
[20:51:45] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[20:52:24] *** Joins: japaric (japaric@CED3519C.6B340C30.BFC118EE.IP)
[20:52:58] <fabiand> jhasse, correct - darn
[20:53:02] <fabiand> but no change wit rustyworld
[20:53:14] <jhasse> can u send ouput?
[20:53:17] <fabiand> sure
[20:53:34] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[20:53:50] <fabiand> jhasse,  http://paste.fedoraproject.org/69857/39016480
[20:54:26] *** Joins: psquid (psquid@moz-CEF96322.threembb.co.uk)
[20:55:33] <jhasse> rustyworld isn't found. Are u in the right dir?
[20:56:02] <fabiand> embarassing ..
[20:56:10] <jhasse> np ;)
[20:56:45] <fabiand> jhasse, http://paste.fedoraproject.org/69859/01649601/
[20:57:19] <fabiand> jhasse, libstd is in /usr/lib64 ..
[20:58:11] *** Joins: lennart (lennart@moz-DE70D6F.stanford.edu)
[20:58:18] <jhasse> Did you use `./configure --libdir=/usr/lib64` to build rust?
[20:58:32] *** Quits: adwhit (Mibbit@moz-54C61813.cable.virginm.net) (Quit: http://www.mibbit.com ajax IRC Client)
[20:59:17] <fabiand> jhasse, yep http://copr-be.cloud.fedoraproject.org/results/fabiand/rust-unofficial/fedora-20-x86_64/rust-0.9-1.fc20/build.log
[20:59:38] *** Joins: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP)
[20:59:57] <jhasse> okay this won't work with rustpkg (it's a bug)
[21:00:15] <fabiand> ah right
[21:00:24] <fabiand> but ..
[21:00:30] <fabiand> ah okay - it's a prob with rustpkg
[21:00:31] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[21:00:35] <fabiand> why, jhasse ? :)
[21:00:41] <fabiand> is /usr/lib hardcoded in rustpkg?
[21:01:08] <jhasse> yes :/
[21:01:14] <fabiand> ah rigt
[21:01:16] <fabiand> right
[21:01:17] <fabiand> I see
[21:01:24] <jhasse> I had this fixed, but I needed to change my PR
[21:01:28] <fabiand> well, anyway - nice that libdir is at least somewhat recognized :)
[21:01:31] <fabiand> PR?
[21:01:32] *** Joins: tsurai (Mibbit@moz-D7E15791.versanet.de)
[21:01:35] <fabiand> ah pullr eq
[21:01:35] <jhasse> pull request
[21:01:42] <fabiand> I see
[21:01:44] <jhasse> I implemented --libdir support
[21:01:50] <fabiand> Cool!
[21:01:57] <fabiand> jhasse, +1
[21:02:07] <jhasse> let me thing of a solution ... hm ...
[21:02:17] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[21:02:45] <jhasse> does rustc work?
[21:02:52] <fabiand> let me see
[21:02:53] <jhasse> e.g. rustc src/rustyworld/lib.rs
[21:03:18] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[21:03:50] <fabiand> jhasse, rusts rustlangexample.rs doesnt work
[21:04:19] <fabiand> http://paste.fedoraproject.org/69861/39016543/
[21:04:21] <fabiand> jhasse, ^
[21:05:12] *** Joins: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP)
[21:05:16] <fabiand> jhasse, http://paste.fedoraproject.org/69863/01655031/
[21:05:38] *** flaper87|afk is now known as flaper87
[21:05:41] <fabiand> jhasse, same problem
[21:05:53] <fabiand> it searches /usr/lib - but it got installed into /usr/lib64
[21:06:27] <jhasse> okay. I think I know how to fix it.
[21:06:36] <jhasse> I will reboot to linux, brb ;)
[21:06:43] <fabiand> ack
[21:06:49] *** Quits: jhasse (jhass_000@moz-CB992F36.ewe-ip-backbone.de) (Quit: Verlassend)
[21:07:45] *** Quits: tsurai (Mibbit@moz-D7E15791.versanet.de) (Quit: http://www.mibbit.com ajax IRC Client)
[21:08:35] *** Joins: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca)
[21:08:48] *** Joins: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP)
[21:08:59] *** Joins: nrc (nrc@7BE24E90.A5032A01.3CFC199D.IP)
[21:09:52] *** Joins: jhasse (jhasse@moz-CB992F36.ewe-ip-backbone.de)
[21:10:15] *** Quits: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca) (Quit: Leaving.)
[21:10:17] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[21:10:18] *** Joins: sp3d (s@6361F3B1.19CD1E54.8354FB35.IP)
[21:10:22] *** Joins: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca)
[21:10:25] <jhasse> fabiand: I'm back. Can you open an issue on github for this?
[21:10:48] *** Quits: tdc (santegoeds@moz-11C3F42C.range86-159.btcentralplus.com) (Quit: Leaving)
[21:12:01] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Ping timeout)
[21:12:09] *** Quits: maxli (maxli@moz-EE42E0E.student.cs.uwaterloo.ca) (Ping timeout)
[21:12:57] <fabiand> jhasse, sure
[21:17:28] <fabiand> jhasse, https://github.com/mozilla/rust/issues/11671
[21:17:48] *** Quits: bleibig (bleibig@moz-B4D9C5AF.hsd1.ca.comcast.net) (Quit: bleibig)
[21:18:29] <fabiand> jhasse, need to go - but I'll watch that issue - thanks for responding that quickly in here :)
[21:18:53] <jhasse> np! I hope I can create a patch in the next hour :)
[21:18:58] <jhasse> shouldn't be that hard to fix
[21:19:05] *** Joins: doomlord__ (servitor@moz-D9C46C01.range86-184.btcentralplus.com)
[21:19:10] *** Quits: doomlord__ (servitor@moz-D9C46C01.range86-184.btcentralplus.com) (Client exited)
[21:20:15] <Mathias> I have a question about compiling Rust on Windows, and if someone has successfully done it recently on the master branch?
[21:20:22] <fabiand> jhasse, cool - thanks and have a nice evening
[21:20:28] <jhasse> u2
[21:20:29] *** Quits: jaen (jaen@moz-E0979827.copit.pl) (Ping timeout)
[21:20:33] *** Quits: fabiand (fabiand@moz-3814939D.static.hackerspace-bremen.de) (Quit: Verlassend)
[21:20:38] <jhasse> Mathias: yes
[21:21:16] <jhasse> I'm currently under Linux, but I mainly use Windows for rust development
[21:21:19] <Mathias> Okay, so. I've tried compiling with GCC and G++ version 4.5.*, 4.6.*, 4.7.*, 4.8.*, and all of them fail at some stage of the compilation. With 4.8 and 4.7 it fails when linking count.exe. On earlier versions I get a ton of Windows header-related error spam in the console
[21:21:34] <jhasse> should work with the newest version
[21:21:54] <jhasse> Can you try:
[21:21:57] <jhasse> mingw-get upgrade
[21:22:01] <jhasse> git clean -xfd
[21:22:13] <Mathias> Sure, give me a sec.
[21:22:15] <jhasse> and then a build and send me the output?
[21:22:46] *** Joins: steveno (steveno@moz-2B2BE86F.hsd1.pa.comcast.net)
[21:23:27] *** Joins: jaen (jaen@moz-E0979827.copit.pl)
[21:23:49] *** Joins: ofeldt- (ofeldt@moz-CD295A79.dip0.t-ipconnect.de)
[21:24:45] *** Quits: ofeldt (ofeldt@moz-41357ABF.dip0.t-ipconnect.de) (Ping timeout)
[21:26:33] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[21:26:55] *** Quits: peterdreid (peterdreid@moz-D18776CD.nc.res.rr.com) (Quit: )
[21:27:24] <SiegeLord> Wait... Zero::zero() now forces operator overloading on you?
[21:27:41] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[21:27:44] <cmr> what do you mean?
[21:27:57] <SiegeLord> I was using it for flags
[21:28:13] <SiegeLord> Now I'd have to implement addition for my flag type ;P
[21:28:21] <cmr> you shouldn't?
[21:28:27] <cmr> Zero hasn't changed.
[21:28:33] <SiegeLord> https://github.com/mozilla/rust/pull/11664
[21:28:43] <SiegeLord> Oh, is it different Zero?
[21:29:05] <SiegeLord> No, that's the Zero I use
[21:29:23] <SiegeLord> Zero isn't only an additive identity, it can also be a boolean or identity
[21:31:00] <SiegeLord> I don't like these std::num changes. Also not a fan of powf having the f. Where's sinf, sqrtf etc then?
[21:32:44] <eddyb> sfackler: did you see this? https://gist.github.com/eddyb/fab5c8000edbb6b6c152#file-phf_mac-rs-L55-L78 I don't think it's possible to do that atm, but I want it (and it's technically possible) :D
[21:32:49] <cmr> wait why aren't those in the docs yet.
[21:33:16] <Matthias247> how can I get a reference to a member function of a generic Type? For normal Impls MyObject::member_func works. But I can neither get MyObject::member_func nor MyObject<T>::member_func to work
[21:34:05] <eddyb> Matthias247: you might be able soon
[21:34:07] <SiegeLord> Err... I meant bitwise or identity
[21:34:27] <eddyb> Matthias247: https://github.com/mozilla/rust/pull/11595#issuecomment-32689213
[21:34:32] <cmr> SiegeLord: powf is for floats, pow for all the numerics
[21:34:44] <cmr> (including floats, I think)
[21:34:49] <cmr> but yeah
[21:34:50] <SiegeLord> It's powf inside the Real trait too, though
[21:34:57] <eddyb> Matthias247: keep in mind that you can't just call a method like a normal function, without that PR
[21:35:03] <cmr> yeah it's weird.
[21:35:07] *** Joins: mib_s4rm1h (Mibbit@moz-EDFD85DB.cm-7-7a.dynamic.ziggo.nl)
[21:35:38] *** Quits: mib_s4rm1h (Mibbit@moz-EDFD85DB.cm-7-7a.dynamic.ziggo.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[21:35:46] <Matthias247> that means it currently doesn't work? I mean it already works for me, but not on generic types
[21:35:49] *** Joins: weirdo (Mibbit@moz-EDFD85DB.cm-7-7a.dynamic.ziggo.nl)
[21:35:56] <Matthias247> but I'm not using &self in the method i want to call
[21:36:06] <SiegeLord> I guess I'll switch to Default instead of Zero... it's darn long to type though :/
[21:36:10] <eddyb> Matthias247: oh, static methods?
[21:36:19] <Matthias247> yeah, kind of
[21:36:20] *** Quits: weirdo (Mibbit@moz-EDFD85DB.cm-7-7a.dynamic.ziggo.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[21:36:22] <eddyb> Matthias247: try MyObject::<T>::member_func
[21:36:26] <Matthias247> I pass a raw pointer to the object :)
[21:36:31] *** Joins: mib_yglkln (Mibbit@moz-EDFD85DB.cm-7-7a.dynamic.ziggo.nl)
[21:37:06] <Matthias247> thx, that works
[21:37:14] <eddyb> Matthias247: keep in mind that Foo<T> only works in types
[21:37:16] <Tobba> eugh
[21:37:21] <Matthias247> I tried with :: in front and behind the <T>, but not both :)
[21:37:23] <Tobba> why does yield have to be a reserved keyword, goddamnit
[21:37:41] <eddyb> Tobba: want to name a function yield?
[21:37:54] <Tobba> yeah
[21:38:00] <Tobba> use() is another one of those things
[21:38:03] *** Quits: mouse_ (mouse@moz-813060C4.broadband.corbina.ru) (Ping timeout)
[21:38:14] <eddyb> Tobba: ouch, that sounds bad
[21:38:26] <eddyb> maybe we should have more contextual keywords
[21:38:39] <Matthias247> so tobba_yield()  :-)
[21:38:56] <eddyb> toba = drum in Romanian, so that sounds silly
[21:39:01] <SiegeLord> I'd say we should have no contextual keywords
[21:39:25] <eddyb> SiegeLord: and not let anyone name stuff "in" just because it's used *in one context ever*?
[21:39:36] <SiegeLord> It's hard enough to highlight Rust already with its separate namespaces for types and values
[21:39:38] *** Quits: m-r-r (mrr@moz-84B6E1ED.rev.sfr.net) (Quit: WeeChat 0.4.2)
[21:39:48] <SiegeLord> *variables
[21:39:50] <cmr> eddyb: other languages do it just fine.
[21:40:02] <cmr> it's not like we're worse than others here.
[21:40:15] <Tobba> its just that rust has annoying keywords like use
[21:40:25] <joebobjoe> Will it be possible to implement type providers (similar to F#) as an extension to the Rust comiler in the future?
[21:40:25] <SiegeLord> You're looking at a full compilation pass to properly highlight Rust today :p
[21:40:28] <Tobba> theres a bunch of other nice words that are keywords too iirc, cant find the listing
[21:40:32] <SiegeLord> Just think about that for a second
[21:40:46] <Matthias247> my worst experience last year in that regard was that you can't create a Date class in AS3 because it conflicts with a top level thing. Even though they are in different namespaces :(
[21:41:04] <Tobba> oh yeah, type is also reserved
[21:41:08] <Tobba> which is massively annoying
[21:41:17] <eddyb> type isn't reserved
[21:41:19] <eddyb> type Foo = Bar;
[21:41:28] <Tobba> well, its a keyword
[21:41:29] <Matthias247> yep, the type thing also caught me
[21:41:32] <Tobba> I'd like to have a field named type
[21:41:35] <Tobba> though in this case a module
[21:41:36] <eddyb> (though we might get rid of it - unless we want Haskell-like ADTs :P)
[21:41:39] *** Joins: mr_wibble (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de)
[21:41:41] <Matthias247> I often use that as a member name
[21:41:44] <cmr> rusti: let type = 42; type
[21:41:47] -rusti- pastebinned 9 lines of output: http://ix.io/9ZF
[21:41:52] <eddyb> Tobba: rustc uses "ty" and "_match" as module names
[21:42:00] <Tobba> ew
[21:42:08] <eddyb> SiegeLord: use something that's smart enough to highlight more than a handful of languages and it will work for Rust
[21:42:17] <SiegeLord> eddyb: Like what :P
[21:42:46] <SiegeLord> I will claim that there is no highlighter today that can highlight Rust correctly
[21:42:50] <cmr> can confirm
[21:43:12] <eddyb> kate uses relatively simple XML files and it can do a lot of cool stuff (that don't require a global context - you're highlighting, not doing everything an IDE can do)
[21:43:18] <eddyb> SiegeLord: huh?
[21:43:42] <eddyb> SiegeLord: now you're just intriguing me. what are the big problems?
[21:43:49] <Matthias247> I'm using the sublime plugin and it's quite good. Although I still miss IDE features :(
[21:43:54] <cmr> even the vim highlighter thinks Some(foo) in a match arm is a function call.
[21:44:16] <eddyb> cmr: you... differentiate there?
[21:44:32] <cmr> eddyb: now you need context!
[21:44:51] <SiegeLord> eddyb: let i32: i32 = 1;
[21:44:56] <sp3d> cmr: is it different from a function call?
[21:44:58] *** Quits: leroux (leroux@moz-421CF1E4.dsl.bell.ca) (Quit: Leaving)
[21:45:05] <cmr> sp3d: yes, it's a pattern match.
[21:45:06] <SiegeLord> How do you decide which one of those f32's to highlight?
[21:45:12] <eddyb> SiegeLord: aaaah, I see. challenge accepted
[21:45:15] <SiegeLord> *i32's
[21:45:15] <sp3d> oh, that part of the match arm
[21:45:26] <eddyb> SiegeLord: with scopes, of course
[21:45:28] <cmr> pygments uses a PDA, so it's possible to actually do rust correctly.
[21:45:38] <Matthias247> SiegeLord: that's easy. After let only a name is allowed. And after the : follows the type
[21:45:47] <eddyb> Matthias247: you're wrong
[21:45:55] <eddyb> it's let pattern [: type] [= value];
[21:45:57] <cmr> Matthias247: let (a, b, c) = foo; let Some(d) = foo;
[21:45:59] <mitsuhiko> speaking of which: someone please fix vim's highlighter to not highlight the str in std::str::from_utf8 :P
[21:46:01] <SiegeLord> Or how about Self
[21:46:05] <SiegeLord> How do you highlight Self?
[21:46:18] <SiegeLord> It's a type in some places, not all of them
[21:46:26] *** Joins: dapz (textual@moz-F958911.hsd1.ca.comcast.net)
[21:46:27] <eddyb> rusti: type Self = int;
[21:46:31] -rusti- ()
[21:46:41] <eddyb> o_O I thought it was a non-contenxtual keyword, interesting
[21:46:44] <SiegeLord> rusti: let Self = 1;
[21:46:45] -rusti- <anon>:10:13: 10:17 warning: unused variable: `Self`, #[warn(unused_variable)] on by default
[21:46:46] -rusti- <anon>:10         let Self = 1;
[21:46:46] -rusti-                       ^~~~
[21:46:46] -rusti- ()
[21:46:51] <eddyb> rusti: let self = 1;
[21:46:53] -rusti- pastebinned 7 lines of output: http://ix.io/9ZG
[21:47:33] <andor> what are the values of a ~[~[SomeEnum, ..x], ..y] initialized to?
[21:47:36] <eddyb> (highlighting "in" only in "for ... in" is easy)
[21:47:37] <SiegeLord> Matthias247: You're looking at basically a full parser to get that right
[21:47:47] <Matthias247> jep
[21:47:51] *** Quits: Florob (Florob@moz-39532932.de) (Client exited)
[21:47:55] <andor> or can i not write let x = ~[~[SomeEnum, ..x], ..y]?
[21:48:51] <Matthias247> even worse: You need a fault tolerant parser. That's harder to do than one that will simply abort when something is not valid
[21:48:54] <Tobba> eugh
[21:48:58] <Tobba> I wish you could infer the type of statics
[21:49:16] *** Quits: eddyb (eddy@EDE07015.D51DAF03.FB866788.IP) (Ping timeout)
[21:49:57] <cmr> andor: is that a type or an expression?
[21:50:21] <andor> cmr: which one? first one is a type, second one is an expression
[21:50:22] <cmr> andor: you're creating an owning pointer to a fixed-length array.
[21:50:55] *** Joins: maxli (maxli@moz-B19F68ED.student.cs.uwaterloo.ca)
[21:51:54] <Tobba> eddyb: also, you got any idea how I can set up a generic function pointer of sorts?
[21:52:08] <Tobba> trying to set up a table of syscalls, so I want to just put the function and a listing of the args
[21:52:13] <Tobba> obviously hilariously unsafe, but nonetheless
[21:53:23] <SiegeLord> Matthias247: And now replicate that parser in C++ for Scintilla, Python for Pygments, Haskell for pandoc etc... it gets unmanageable pretty quickly
[21:53:36] <SiegeLord> You can get far with just a lexer (but won't fix any of those problems)
[21:53:52] <SiegeLord> But it will help with nested comments, raw strings
[21:54:11] <SiegeLord> vim's highlighter fails on some crafted nested comments iirc
[21:54:50] *** Parts: JoshK (JoshK@moz-94D285B.dyn.optonline.net) ()
[21:54:51] *** Quits: mmalecki (maciej@DE8E8A22.9EBA3CD1.D6573861.IP) (Connection reset by peer)
[21:55:00] <Tobba> screw it, just gonna use a *u8 for now
[21:55:02] *** Joins: mmalecki (maciej@DE8E8A22.9EBA3CD1.D6573861.IP)
[21:55:18] <andor> cmr: okay, different question then, how do i initialize a fixed-length array properly?
[21:55:28] <Matthias247> [0, ..20] for example
[21:55:30] <cmr> andor: you did it properly. [SomeValue, ..length]
[21:55:53] <cmr> If you want an owning pointer to it, you need ~([SomeValue, ..lenth])
[21:56:06] <cmr> SomeValue needs to be Pod.
[21:56:14] <cmr> otherwise you need [SomeValue, SomeValue, ........]
[21:56:23] <mitsuhiko> rust's single field enums are gone, right?
[21:56:37] <cmr> mitsuhiko: example?
[21:56:53] <bjz> cmr: eh. SiegeLord should be making his own identity for bools
[21:56:56] <mitsuhiko> wasn't there some support for allowing an enum act as if it was a type?
[21:57:06] <mitsuhiko> eg: passing a Foo(~str) as ~str
[21:57:09] <mitsuhiko> or something like this
[21:57:15] <cmr> no, wasn't quite like that.
[21:57:28] <cmr> you used to be able to deref single-variant enums like that into their wrapped type.
[21:57:42] <cmr> struct Foo(~str); *foo was of type ~str
[21:57:53] <mitsuhiko> ah yes.
[21:58:15] <mitsuhiko> trying to figure out how to implement a function for this: http://redis.io/commands/zrangebyscore
[21:58:54] <mitsuhiko> can't come up with a nice looking api :(
[21:59:42] *** Joins: alisdair (textual@moz-7657F365.vc.shawcable.net)
[22:00:02] <SiegeLord> bjz: I don't see what is gained by restricting Zero like that. Seems like like just shuffling chairs. I guess that ship has sailed though...
[22:00:05] <busylizzy> anybody knows is vec::swap safe? in rust any object can be moved just by copying of bytes?
[22:00:29] <bjz> SiegeLord: it has a definition
[22:00:40] <mitsuhiko> how would you represent a range in rust that can be open or closed on both edges and go into infinite?
[22:01:03] <bjz> SiegeLord: we don't use the `+` operator for multiplication
[22:01:12] *** Quits: rca (rcatolino@moz-10E18C17.adsl.proxad.net) (Ping timeout)
[22:01:24] <bjz> SiegeLord: or return `abs` from `pow`
[22:01:28] <busylizzy> enum Boundary { inf, open(int), closed(int) }
[22:01:37] *** Quits: thewonderidiot (mike@moz-5506A033.hsd1.ca.comcast.net) (Ping timeout)
[22:01:53] <busylizzy> (Boundary, Boundary)
[22:02:05] <lennart> busylizzy, mitsuhiko: you probably want a negative infinity constructor as well
[22:02:17] <SiegeLord> bjz: Bitwise or identity is just as good a definition of 0 as any
[22:02:31] <mitsuhiko> busylizzy: that's pretty much what i have just with Inf NegInf
[22:02:46] <mitsuhiko> i hope everybody agrees that (inf and inf is the same
[22:02:52] <bjz> SiegeLord: Bitwise ops have different identities
[22:02:59] <SiegeLord> Addition on a computer is defined via binary OR anyway
[22:03:11] <andor> cmr: okay, but what do i do when i have ~[~[SomeEnum, ..x], ..y]? i can do let x = ~([ ~([SomeVariant, ..x]), repeated y-1 more times]), because if i do the repeat syntax, i get "repeated element will be copied"
[22:03:17] <busylizzy> mitsuhiko: then you probably have LeftBoundary and RightBoundary?
[22:03:22] *** Quits: mib_yglkln (Mibbit@moz-EDFD85DB.cm-7-7a.dynamic.ziggo.nl) (Quit: http://www.mibbit.com ajax IRC Client)
[22:03:28] <joebobjoe> Where can I find a list of the fundamental compiler-provided types in Rust?
[22:03:49] *** Quits: voxpopuli (fanservice@moz-CEF3689A.hsd1.pa.comcast.net) (Ping timeout)
[22:04:15] <cmr> joebobjoe: manual.
[22:04:27] <busylizzy> > anybody knows is vec::swap safe? in rust any object can be moved just by copying of bytes?
[22:04:40] <busylizzy> guys, help me please. how does it work?
[22:04:47] <o11c> busylizzy: yes, in rust all moves are trivial
[22:04:54] <cmr> joebobjoe: http://static.rust-lang.org/doc/master/rust.html#types
[22:05:04] <busylizzy> o11c: thanks =)
[22:05:13] *** Joins: jmgrosen (jmgrosen@moz-848F6087.sb.sd.cox.net)
[22:05:16] <cmr> joebobjoe: int, uint, [u|i][8|16|32|64], bool, f32, f64
[22:05:18] <cmr> joebobjoe: that's it.
[22:05:26] <cmr> oh and ()
[22:06:42] <cmr> oh and the vectors and strings
[22:06:48] <cmr> but those don't need to be provided by the compiler.
[22:07:53] <mceier> and pointers
[22:07:58] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Client exited)
[22:08:16] <mceier> rusti: type i32 = (char,char); let ab : i32 = ('a','b')
[22:08:17] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[22:08:18] *** Joins: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com)
[22:08:19] -rusti- pastebinned 6 lines of output: http://ix.io/9VA
[22:08:30] <cmr> ah yes, borrowed pointers need to be privileged.
[22:08:35] *** Quits: mr_wibble (Mibbit@moz-FA92507D.hsi8.kabel-badenwuerttemberg.de) (Quit: http://www.mibbit.com ajax IRC Client)
[22:09:03] <mceier> rusti: type i32 = (char,char); let ab : i32 = ('a','b');
[22:09:05] -rusti- pastebinned 7 lines of output: http://ix.io/9ZI
[22:09:07] <bjz> SiegeLord: we could have `bottom` and `top` for boolean algebra
[22:09:39] <mceier> ^ why does it fail at "let" and not at "type" ?
[22:10:15] <cmr> mceier: poor error handling in `type` :)
[22:10:30] <mceier> ok ;)
[22:11:10] <SiegeLord> I guess I could add my own Zero trait... maybe I'll call it Nil or something
[22:11:19] <bjz> SiegeLord: but I do think it is important to link specific identities to specific operators. Unfortunately there is no way to do some sort of higher kindedness in Rust at the moment
[22:11:49] *** Joins: ChrisMorgan (chris@moz-6AC741CA.static.tpgi.com.au)
[22:12:41] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[22:13:48] <lennart> what is the difference between a .so and a .rlib?
[22:13:59] <cmr> lennart: .rlib is a static library.
[22:14:22] <cmr> lennart: http://static.rust-lang.org/doc/master/rust.html#linkage
[22:15:05] <lennart> do I need to treat it any differently when building a program that links to it?
[22:15:30] <cmr> shouldn't need to, no.
[22:15:39] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[22:15:47] <cmr> but do read the manual section I linked.
[22:15:55] <lennart> sure, thanks
[22:15:58] <cmr> it can become nuanced when trying to mix static and dynamic.
[22:16:25] *** Quits: kngl (Adium@E5907D90.770DEA4D.7C797F8E.IP) (Quit: Leaving.)
[22:16:52] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[22:18:27] <o11c> IIRC .rlib will fail to link recursively
[22:18:32] *** Quits: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP) (Ping timeout)
[22:18:42] <o11c> at least, someone was complaining about errors the other day.
[22:18:48] <JustAPerson> Does anyone know of a good introduction to rust's build system?
[22:18:51] <o11c> I don't know how it's *supposed* to work.
[22:19:16] <cmr> JustAPerson: what do you want to know specifically?
[22:19:30] <cmr> it's a standard mess of makefiles
[22:19:38] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[22:19:50] <JustAPerson> cmr: how to set up a project's directories and use the `rust` front end.
[22:20:02] <JustAPerson> Oh, so I do have to resort to makefiles
[22:20:04] <cmr> JustAPerson: `rust` doesn't exist anymore, and we don't have a build system like that.
[22:20:16] <cmr> no, I was talking about the compiler's build system.
[22:20:23] <cmr> you can use whatever you want to build your packages.
[22:21:10] <JustAPerson> Ok. It appears `rust` is a left over from a 0.8 installation I didn't remove properly. So just makefiles and rustc?
[22:21:24] <JustAPerson> then gcc or whatever to link objects?
[22:21:35] <cmr> rustc lib.rs
[22:21:54] <cmr> http://metajack.im/2013/12/19/building-rust-code--using-make-part-2/
[22:21:56] <cmr> see that.
[22:22:03] <cmr> our compilation model isn't one-object-file-per-rust-file
[22:22:09] <cmr> it's one-object-file-per-crate.
[22:22:18] <cmr> and rustc does all the linking for you.
[22:23:19] <JustAPerson> ok, thanks a bunch
[22:26:35] *** Joins: Yurumechan (23f9939a@B2F514.E4420F21.EEF52F3A.IP)
[22:29:01] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[22:30:06] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Input/output error)
[22:30:25] *** Quits: vadimg (vadimg@BCFFDE00.DF0A212.39C00A7A.IP) (Ping timeout)
[22:31:53] *** Quits: alisdair (textual@moz-7657F365.vc.shawcable.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[22:32:36] <SiegeLord> What are the rust libraries installed in /usr/local/lib?
[22:33:00] <cmr> SiegeLord: they're the ones the compiler links against iirc.
[22:33:05] *** Joins: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net)
[22:33:24] <cmr> they should be synlinks into rustlib
[22:33:25] <SiegeLord> I'm getting an ICE if I do -L/usr/local/lib so I'm thinking maybe it's picking one of them up
[22:33:31] <SiegeLord> They're all 0.9-pre
[22:34:01] <mceier> is llvm the only C/C++ dependency of rust ?
[22:34:30] <SiegeLord> I deleted them all and it seems to have helped
[22:34:48] <cmr> mceier: no, libuv and libc too.
[22:34:53] *** Joins: leroux (leroux@moz-421CF1E4.dsl.bell.ca)
[22:34:58] <cmr> though you can opt out of uv.
[22:35:12] <SiegeLord> Rust can't seem to decide where to plop the libraries... /usr/local/lib /usr/local/lib/rust and now it's /usr/local/lib/rustlib
[22:35:23] <cmr> SiegeLord: /usr/local/lib/rust should be deleted.
[22:35:25] <Mathias> jhasse: Thanks a lot for your help, I'm still not sure what went wrong the other times, but I suspect that I just overlooked a step along the way. Thanks!
[22:35:27] <cmr> it was renamed to rustlib.
[22:35:38] <mceier> cmr: thanks
[22:35:39] <SiegeLord> For this week at least ;)
[22:35:39] *** Quits: dapz (textual@moz-F958911.hsd1.ca.comcast.net) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[22:35:47] <cmr> I don't know why we have symlinks in /usr/local/lib
[22:36:06] <cmr> I can only assume it's probably for some reason that's no longer relevant.
[22:36:46] <SiegeLord> Heh, maybe it's to break my build >_<
[22:39:59] *** Quits: Soft (soft@moz-EC8D39F.yok.fi) (Ping timeout)
[22:40:25] <SiegeLord> Whoopsie, did a sudo rm libcore *
[22:40:35] <cmr> :(
[22:41:29] <SiegeLord> Well, that has fixed my /usr/local/lib pollution for sure
[22:41:39] <cmr> :P
[22:42:26] *** Quits: jviereck (Adium@moz-56DDD13.dip0.t-ipconnect.de) (Quit: Leaving.)
[22:42:34] <andor> is msys' shell supposed to correctly handle colors?
[22:43:00] <andor> i cannot get colors working for individual characters, only lines with extra::term::Terminal
[22:43:32] <cmr> andor: fg, printing character, and then reset doesn't do it?
[22:44:14] <andor> cmr: haven't tried adding reset
[22:44:18] <wycats> what's the best way to convert a C-style enum into an int?
[22:44:24] <andor> cmr: how am i supposed to be printing characters?
[22:44:24] <cmr> wycats: foo as int
[22:44:32] <wycats> cmr: sweet
[22:44:46] <cmr> andor: so Terminal implements Writer.
[22:45:31] <cmr> so you can do term.fg(RED); term.write_char('+'); term.reset();
[22:45:35] <cmr> and it should Just Work.
[22:45:46] <andor> oh, okay, i was just doing print!()
[22:45:58] *** Joins: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br)
[22:46:05] <andor> i kind of figured that should work, since i'm doing Terminal::new(std::io::stdout());
[22:46:06] <o11c> probably line buffering
[22:46:12] <SiegeLord> Still... I did a make install of Rust, and then tried to do -L/usr/local/lib and got an ICE again
[22:46:24] <cmr> you can use write!(&mut term, "foo")
[22:46:27] <SiegeLord> So it's definitely the new symlinks/w/e that are breaking rustc
[22:46:28] <o11c> and since windows terminal attributes aren't stream based ...
[22:46:28] <andor> o11c: thought so as well, doing flush() and reset() everywhere, doesn't help
[22:46:40] <andor> i'll try doing term.write_x()
[22:46:59] <cmr> andor: you can use write and writeln with term, as if you were using print/println
[22:47:07] *** Quits: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net) (Connection reset by peer)
[22:47:27] <SiegeLord> Although... why are some of them 0.9 and some 0.10-pre
[22:47:34] <SiegeLord> Shouldn't they all be 0.10-pre?
[22:47:40] *** Joins: dmac (Adium@moz-94F55C3.hfc.comcastbusiness.net)
[22:47:48] <pepper_chico> guys, anyone knows whether we'll have * dereference for Gc/Rc soon? through an special pointer trait
[22:48:03] *** Quits: sellout1 (Adium@moz-76D71F1A.hlrn.qwest.net) (Quit: Leaving.)
[22:48:11] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[22:48:13] <pepper_chico> I mean, without .borrow()
[22:48:35] *** Quits: Ferreus (ferreus@moz-561EC8C5.pools.arcor-ip.net) (Quit: WeeChat 0.4.3-dev)
[22:48:58] <andor> cmr: cool, that works :)
[22:49:17] <cmr> SiegeLord: some of them are 0.9 because we haven't had a snapshot with the version number bump yet.
[22:49:23] <SiegeLord> I see
[22:49:56] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[22:50:16] <cmr> I think, pending on snapshot, we'll never have to stagger the version number bump again
[22:50:19] <cmr> I don't remember the details of the pir.
[22:50:21] <cmr> *pr
[22:51:22] <pepper_chico> anyone?
[22:51:42] *** Joins: voxpopuli (fanservice@moz-424BC304.hsd1.pa.comcast.net)
[22:52:02] *** Quits: hjr3 (hradtke@moz-E87BDF1F.socal.res.rr.com) (Quit: My MacBook has gone to sleep. ZZZzzz…)
[22:54:15] *** Quits: valenting (Thunderbir@9A1975C1.39CE2EE.E400A05F.IP) (Ping timeout)
[22:55:11] <indirect> is it possible to get the path of the file being compiled? I have fixture data for a test in the same directory as the test file, and I can't for the life of me figure out how to access that file while running the test binary :\
[22:55:40] <cmr> indirect: you could use include_bin or include_str
[22:56:00] <cmr> rusti: include_str!("/proc/self/cmdline")
[22:56:02] -rusti- "rustc\x00-\x00-o\x00out\x00"
[22:56:18] <cmr> rusti: include_bin!("/proc/self/cmdline")
[22:56:19] -rusti- &[114u8, 117u8, 115u8, 116u8, 99u8, 0u8, 45u8, 0u8, 45u8, 111u8, 0u8, 111u8, 117u8, 116u8, 0u8]
[22:56:27] <cmr> rusti: include!("/proc/self/cmdline")
[22:56:29] -rusti- pastebinned 6 lines of output: http://ix.io/9ZL
[22:56:34] *** Quits: TheHydroImpulse (TheHydroIm@moz-A9FB1B83.ed.shawcable.net) (Quit: TheHydroImpulse)
[22:57:56] <indirect> cmr: whoa, sweet
[22:59:29] <SiegeLord> Looks like I hit https://github.com/mozilla/rust/issues/11195
[22:59:39] <SiegeLord> That said, I don't quite get why rustc isn't statically compiled
[23:00:38] <o11c> wait, isn't there a file!() or something?
[23:00:53] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[23:01:05] <cmr> rusti: file!()
[23:01:06] -rusti- "<anon>"
[23:01:41] *** Quits: jensnockert (jensnocker@moz-7DC16A5F.afb.bredband2.com) (Input/output error)
[23:02:14] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Connection reset by peer)
[23:02:29] *** Quits: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP) (Input/output error)
[23:02:30] <indirect> o11c: even better :)
[23:02:36] *** Joins: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru)
[23:03:03] *** Quits: Mathias (Mibbit@moz-E9EEAB4.cpe.webspeed.dk) (Quit: http://www.mibbit.com ajax IRC Client)
[23:03:20] <indirect> rusti: println!("{:?}", file!())
[23:03:21] -rusti- "<anon>"
[23:03:21] -rusti- ()
[23:03:24] <indirect> ha
[23:03:37] <cmr> (it's compiled from stdin)
[23:03:38] <andor> any idea what the rust equivalent is of windows api's HWND? i'm trying to interface some winapi stuff
[23:03:58] <mitsuhiko> you can just assume a void pointer
[23:04:26] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[23:04:33] *** Joins: earlzlap (earlz@moz-483E1E31.neo.res.rr.com)
[23:04:36] <cmr> andor: https://github.com/klutzy/rust-windows
[23:04:49] *** Joins: AvianFlu (AvianFlu@974D245D.130DDD13.67CD788C.IP)
[23:05:03] *** Quits: spider-mario (spidermari@moz-2F72F6FF.dsl.quantic-telecom.net) (Input/output error)
[23:05:09] <andor> well that is what it is, but what is taht in rust? i tried c_int, but then i get a link time error, i guess it's because i have the wrong return type?
[23:05:12] *** Quits: jsonnull (Thunderbir@E86DD23.582C899D.494A0F8B.IP) (Quit: jsonnull)
[23:05:21] <cmr> *c_void
[23:05:24] <kimundi> andor: *c_void
[23:06:25] <andor> cmr: oh, that's cool too, but i wouldn't want to pull in a whole library because of one or two function
[23:06:25] <cmr> you probably need extern "system" { ... } too.
[23:06:37] <o11c> andor: better to do *T for some T you create just for the task
[23:07:30] <andor> cmr: "system"? is that the system default or? i'm using "stdcall" right now
[23:07:37] <cmr> andor: system default, yes.
[23:09:28] <indirect> o11c: that worked perfectly, btw. thanks! :D
[23:10:02] *** Quits: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:11:52] <andor> cmr: also that repo is cool but has no user32.dll stuff :( sad
[23:12:12] <cmr> andor: pull requests!
[23:12:48] *** Quits: nif (nif@moz-8181E2AC.oberlin.net) (Quit: Konversation terminated!)
[23:15:20] *** Joins: mib_7mnij1 (Mibbit@moz-824F7CDF.wi.res.rr.com)
[23:15:25] *** Joins: tedh (tedh@moz-F3B34318.hsd1.il.comcast.net)
[23:15:42] *** Quits: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net) (Ping timeout)
[23:15:59] *** Joins: Craig (Craig@moz-824F7CDF.wi.res.rr.com)
[23:16:34] *** Quits: mib_7mnij1 (Mibbit@moz-824F7CDF.wi.res.rr.com) (Quit: http://www.mibbit.com ajax IRC Client)
[23:17:14] <andor> and what would a const char* be equivalent to? *u8? *c_char?
[23:17:22] <cmr> *c_char, yes.
[23:17:31] <jmgrosen> people, do you think a slice trait should return arbitrary T or should it have to be a &'a [T]?
[23:17:54] <cmr> jmgrosen: wouldn't be much of a slice if it didn't return a slice?
[23:18:19] <jmgrosen> cmr: well, for example, SiegeLord wanted arbitrary result types for matrices
[23:19:13] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Ping timeout)
[23:19:30] *** Joins: xitology (xi@85437D54.5AFA3E4.CEDFC552.IP)
[23:19:53] *** Joins: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net)
[23:20:01] *** Joins: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com)
[23:20:05] <o11c> cmr: but it might be a slice *object*, not a slice of a vector
[23:20:20] <jmgrosen> yeah, that's what I was thinking
[23:20:28] <o11c> cmr: e.g. if you're returning a slice of something with a stride
[23:20:29] <jmgrosen> some other type of slice specific to a non-vector
[23:20:42] *** Joins: ecl3ctic (Mibbit@moz-E1FAD64C.wzfv1.vic.bigpond.net.au)
[23:21:18] *** Quits: FrozenCow (FrozenCow@moz-B2DF4929.chello.nl) (Client exited)
[23:21:29] *** Quits: a__ (a__@moz-56DB9895.nycmny.fios.verizon.net) (Quit: I haz left.)
[23:22:01] *** Quits: dredozubov (dredozubov@moz-1E374954.nationalcablenetworks.ru) (Ping timeout)
[23:22:40] <andor> i cannot seem to get this right :\
[23:22:49] <andor> i have fn FindWindow(class_name: *c_char, window_name: *c_char) -> *std::libc::c_void;
[23:23:14] <andor> obviously wrapped in link_name... extern etc, and i still get undefined reference
[23:23:25] <andor> did --link-args="-luser32" too
[23:23:28] *** Joins: a__ (a@moz-56DB9895.nycmny.fios.verizon.net)
[23:24:44] *** Quits: bjz (bjz@B398BE78.F804C29E.D35A31DF.IP) (Ping timeout)
[23:25:00] <andor> here's the relevant piece of documentation http://msdn.microsoft.com/en-us/library/windows/desktop/ms633499%28v=vs.85%29.aspx
[23:25:01] *** Joins: smw (smw@moz-26FB3BC7.socal.res.rr.com)
[23:25:03] *** Quits: dave1629 (dave@moz-17578A1A.hsd1.va.comcast.net) (Quit: dave1629)
[23:25:06] *** Joins: Soft (soft@moz-EC8D39F.yok.fi)
[23:25:23] *** Quits: csherratt (csherratt@moz-8D848271.cpe.teksavvy.com) (Quit: csherratt)
[23:25:28] <andor> where HWND == *void, LPCSTR == const char*
[23:25:43] <mceier> andor: try FindWindowA ?
[23:26:01] <joebobjoe> Why do we need Rc and Weak? Why not just ~ and &?
[23:26:37] <andor> mceier: oh wow... care to explain why's that?
[23:26:40] <jhasse> joebobjoe: ~ is not reference counted
[23:26:46] <eevee> joebobjoe: circular linked lists, graphs, config objects
[23:26:58] <andor> i mean why that works
[23:27:12] <mceier> andor: iirc FindWindow is just a macro - it depends on wether you're compiling with unicode support or not
[23:27:15] <jhasse> andor: Every function in windows is a macro
[23:27:48] <andor> oh, fair enough
[23:27:49] <joebobjoe> eevee: Okay. And why not Rc and &?
[23:27:57] *** Quits: steveno (steveno@moz-2B2BE86F.hsd1.pa.comcast.net) (Quit: Leaving)
[23:28:02] <eevee> joebobjoe: Rc adds overhead to every copy and destruction
[23:28:07] <jhasse> FindWindowW is for UTF-16
[23:28:15] *** Quits: hdevalence (quassel@moz-D125A39F.home3.cgocable.net) (Ping timeout)
[23:28:27] <eevee> joebobjoe: also you can't share Rc between threads safely
[23:28:51] *** Joins: Craig_ (Craig@moz-824F7CDF.wi.res.rr.com)
[23:29:31] <dbaupp> eevee: the amount of overhead is very small, fwiw (especially since copies aren't implicit)
[23:29:38] *** Quits: Tobba (Tobba@moz-462B7F7F.ias.bredband.telia.com) (Ping timeout)
[23:30:01] <eevee> dbaupp: probably not something you want on every single pointer in the program though
[23:30:10] *** Quits: Craig (Craig@moz-824F7CDF.wi.res.rr.com) (Ping timeout)
[23:30:14] *** Quits: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP) (Client exited)
[23:30:46] <joebobjoe> Is the lifetime system similar to an "effects system"?
[23:31:12] <dbaupp> eevee: maybe; I think the biggest problem with Rc is actually shared ownership requires some hoops to achieve safe mutability
[23:31:20] <dbaupp> (i.e. Cell and RefCell)
[23:31:27] *** Joins: geomyidae (quassel@DD6F7E3A.21468E9A.30200F38.IP)
[23:31:43] <dbaupp> whereas plain values and ~ just inherit it nicely
[23:31:47] <joebobjoe> dbaupp: Instead of?
[23:31:56] <joebobjoe> Oh, I see
[23:32:12] *** Quits: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net) (Quit: It's a joke, it's all a joke.)
[23:32:15] <jmgrosen> if a Slice trait like https://github.com/mozilla/rust/issues/4160#issuecomment-28909198 is implemented, is there much point in having the std::vec::Vector trait anymore?
[23:32:27] <cmr> o11c: true.
[23:33:03] *** Joins: zq (p@moz-4C4640FD.com)
[23:33:23] <zq> are option types elided by the compiler?
[23:33:49] <joebobjoe> zq: How could they be elided?
[23:34:00] *** Joins: Craig__ (Craig@moz-824F7CDF.wi.res.rr.com)
[23:34:08] <cmr> zq: for nullable pointer types, they're optimized into a single word.
[23:34:09] <joebobjoe> Inlined?
[23:34:18] <cmr> Option<~T>, Option<&T>, etc
[23:34:40] <joebobjoe> cmr: What's null? 0?
[23:34:45] <cmr> joebobjoe: of course
[23:34:50] *** Joins: WebeWizard (Justin@moz-7CCD1DAE.ks.ks.cox.net)
[23:34:52] <jmgrosen> cmr: although I think that's any enum of the type `enum Foo<T> { Variant1(T), Variant2}`, not just Option
[23:35:01] <joebobjoe> cmr: What if I want to put something at the 0th address in memory!?
[23:35:01] <smw> joebobjoe, null is ()
[23:35:07] *** Quits: Craig_ (Craig@moz-824F7CDF.wi.res.rr.com) (Ping timeout)
[23:35:08] <cmr> joebobjoe: LLVM can't handle that, so good luck!
[23:35:12] <cmr> smw: that's nil, not null.
[23:35:24] <smw> cmr, nm then...
[23:35:27] <zq> inlined*
[23:35:44] <cmr> jmgrosen: it's not arbitrary T. Option<int> for example.
[23:35:45] <joebobjoe> jmgrosen: What about Option[int]?
[23:35:58] *** Joins: SiegeLord (sl@moz-CAF07B4C.hsd1.ma.comcast.net)
[23:36:08] <zq> cmr: why the distinction? why wouldn't it work for Option<T> also?
[23:36:15] <jmgrosen> cmr: yeah, not arbitrary T, but an arbitrary enum where the type inside is &T or ~T
[23:36:18] <joebobjoe> zq: How would I represent 0?
[23:36:25] <jmgrosen> joebobjoe: that's not rust syntax...
[23:36:26] <cmr> jmgrosen: sure
[23:36:37] <zq> joebobjoe: you mean Nothing?
[23:36:51] <jmgrosen> zq: Some(0) != None
[23:37:02] <joebobjoe> zq: No.
[23:37:11] <andor> if something is expecting a *c_char, am i right to do unsafe { std::cast::transmute(~"foo".to_c_str()) }?
[23:37:12] <joebobjoe> zq: I mean the integral 0
[23:37:44] <cmr> andor: no.
[23:38:01] <cmr> andor: http://static.rust-lang.org/doc/master/std/c_str/struct.CString.html
[23:38:07] *** Quits: dew (Instantbir@moz-9D36B7B6.static.stls.mo.charter.com) (Quit: Instantbird 1.5 -- http://www.instantbird.com)
[23:38:12] <cmr> andor: you want to be using with_ref
[23:38:26] <cmr> andor: (and more probably, with_c_str)
[23:38:42] <zq> i always thought that Option<T> was a construct to help the compiler statically deduce...stuff
[23:38:43] <joebobjoe> Are there any langs with dependent types built on top of LLVM?
[23:39:01] <joebobjoe> zq: No. It's a physical union.
[23:39:11] <andor> cmr: oh okay, thanks
[23:39:21] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[23:39:37] <cmr> zq: so it's enum Option<T> { Some(T), None }
[23:39:39] <cmr> (literally)
[23:39:44] <zq> damn
[23:40:35] *** Quits: japaric (japaric@CED3519C.6B340C30.BFC118EE.IP) (Ping timeout)
[23:40:57] <jmgrosen> cmr: do you think std::vec::Vector should still exist with the Slice trait?
[23:41:09] <jmgrosen> (all Vector has is an as_slice() trait, which Slice has)
[23:41:09] <zq> doesn't it become redundant for non-pointer types, then? if i wanted a None enum member, i could just tack it inside the declaration of T, right?
[23:41:17] *** Joins: japaric (japaric@465C3E59.F60EC59D.F29ED47E.IP)
[23:41:30] <cmr> jmgrosen: probably not.
[23:41:36] <cmr> zq: not quite?
[23:41:43] <dbaupp> zq: what about Option<int>?
[23:42:33] <cmr> zq: for example consider searching for a substring, fn find_str(&self, &str) -> Option<uint>
[23:42:56] <cmr> it returns Some(index), or None if it's not found.
[23:43:43] <mitsuhiko> and if you want to fudge around a little bit you can do "foo".find_str("o").unwrap_or(0) or something
[23:46:36] *** Quits: io2 (io2@moz-871549F5.home.otenet.gr) (Quit: )
[23:46:51] *** Quits: Craig__ (Craig@moz-824F7CDF.wi.res.rr.com) (Quit: Craig__)
[23:48:17] *** Quits: moostik (Icedove@6181009C.10715965.BCDF592F.IP) (Ping timeout)
[23:48:20] <zq> mitsuhiko: if .unwrap_or is used, then the wrapper could be optimized away, right? because rustc would have enough to know that the uint inside is either whatever find_str would return upon match or just 0
[23:49:22] <cmr> zq: I imagine llvm does that optimization.
[23:49:43] *** Quits: jhasse (jhasse@moz-CB992F36.ewe-ip-backbone.de) (Quit: Verlassend)
[23:49:47] *** flaper87 is now known as flaper87|afk
[23:49:57] <joebobjoe> Will there ever be a day when optimizations are part of the type system? :P
[23:50:10] <dbaupp> I don't think its guaranteed  that the value for the None case is 0
[23:50:12] <zq> that's what i had in mind when i hit /join
[23:50:23] <mitsuhiko> joebobjoe: hopefully not :)
[23:50:39] <joebobjoe> mitsuhiko: Did you write that paper on programming GPUs with Rust?
[23:50:47] <mitsuhiko> no :)
[23:50:52] <joebobjoe> Hrm.
[23:50:59] <cmr> joebobjoe: it *has* an author list you know :p
[23:51:03] <dbaupp> that is, Option is struct { tag: u8, union {  void, value: uint } }, and when `tag` is 0, then the second field is undefined
[23:51:06] <cmr> (and /whois exists)
[23:51:19] <benh> Why's the tag the first field btw
[23:51:21] <benh> and not the last field
[23:51:28] <joebobjoe> cmr: I know. I sent them a message on this chan a few days ago but wasn't on to see if I got a response.
[23:51:31] <dbaupp> benh: fixed offset for `match`ing
[23:51:33] <dbaupp> I think
[23:51:36] <benh> wouldn't that potentially be better with alignment etc
[23:51:38] <dbaupp> not really sure
[23:51:50] <mitsuhiko> if only one could look at the assembler generated :)
[23:51:52] *** Joins: moostik (Icedove@6181009C.10715965.BCDF592F.IP)
[23:51:57] <joebobjoe> Why is memory layout so important?
[23:51:59] <andor> cmr: regarding the with_c_str stuff... is there a less awkward way to write it? ~"foo".with_c_str(|y| { somefunc(y); }); just feels weird
[23:52:21] <mitsuhiko> joebobjoe: so that you can optmize for cache utilization and use simd operations is the general answer
[23:52:24] <dbaupp> joebobjoe: because that dictates memory use, and also CPU cache behaviour
[23:52:28] <bytbox> has anyone made / planned a "go fmt"-like sanitization tool?
[23:52:43] <dbaupp> bytbox: there's `rustc foo.rs --pretty`
[23:52:45] <cmr> bytbox: rustc --pretty
[23:52:53] <dbaupp> but it's not "canonical" style
[23:52:54] <cmr> bytbox: but it's not very goodsauce.
[23:53:18] <SiegeLord> Gosh is configure slow on Windows
[23:53:20] <bytbox> ah. I vaguely remember that now. (Maybe I'll look into improving it.)
[23:53:25] <SiegeLord> I wish rust would switch to CMake :P
[23:53:37] <joebobjoe> mitsuhiko dbaupp: How is that platform agnostic though?
[23:53:45] <mitsuhiko> joebobjoe: nobody said it was
[23:54:15] <joebobjoe> mitsuhiko: So when you're doing manual memory layout, you're usually thinking of a target platform?
[23:54:16] *** Quits: pepper_chico (pepper_chi@moz-13107F6.dsl.telesp.net.br) (Quit: Ex-Chat)
[23:54:27] <andor> anyone? :(
[23:54:31] <cmr> joebobjoe: no, it just doesn't matter.
[23:54:44] <cmr> andor: not really, no.
[23:55:12] *** Joins: dwrensha (chatzilla@moz-DE44EA45.hsd1.pa.comcast.net)
[23:55:18] <dbaupp> andor: no need for the ~ on the string, but yeah, that's the "easiest" way
[23:55:27] <SiegeLord> That sounds like something RAII could address, no?
[23:55:27] <mitsuhiko> SiegeLord: premake!
[23:55:31] <andor> cmr: so if there's more than one i'm going to be chaining it like ~"foo".with_c_str(|x| { ~"bar".with_c_str....?
[23:55:34] <andor> if so, ugh
[23:55:40] <dbaupp> SiegeLord: there is a RAII interface
[23:55:41] <SiegeLord> mitsuhiko, It has to build LLVM too
[23:56:07] <dbaupp> i..e let foo = "foo".to_c_str(); let bar = "bar".to_c_str(); baz(foo.as_ptr(), bar.as_ptr());
[23:56:12] *** Quits: earlzlap (earlz@moz-483E1E31.neo.res.rr.com) (Ping timeout)
[23:56:30] <dbaupp> but with_c_str is faster (for short strings)
[23:56:32] *** Joins: reima (reima@moz-9F359C5F.dip0.t-ipconnect.de)
[23:56:43] <SiegeLord> Why?
[23:57:00] <joebobjoe> Just curious... what is the most commonly asked question on #rust?
[23:57:08] <cmr> joebobjoe: "when is 1.0 going to be released"
[23:57:09] <dbaupp> placed on the stack for < 100 bytes; .to_c_str requires an allocation always
[23:57:14] *** Joins: bleibig (bleibig@moz-B4D9C5AF.hsd1.ca.comcast.net)
[23:57:28] <mitsuhiko> joebobjoe: what's <V0>
[23:57:45] <cmr> mitsuhiko: I haven't seen that one for a while.
[23:57:54] <andor> dbaupp: .as_ptr()?
[23:57:58] <SiegeLord> dbaupp, Is that 100 bytes no stored in CString itself?
[23:58:13] <joebobjoe> mitsuhiko: int8
[23:58:14] <joebobjoe> ?
[23:58:22] <dbaupp> joebobjoe: re platform agnostic; if you're really trying to get peak performance you end up optimising for a single CPU. Although the biggest optimisations are fairly cross-platform
[23:58:25] <dbaupp> andor: yes?
[23:58:32] <dbaupp> SiegeLord: nope
[23:58:42] <dbaupp> SiegeLord: read the source for the details ;P
[23:58:44] <SiegeLord> I see...
[23:58:46] <mitsuhiko> hmm. does rust no longer terminate strings with a null byte?
[23:58:48] <SiegeLord> That's inconvenient
[23:58:53] <andor> dbaupp: test.rs:78:48: 78:82 error: type `std::c_str::CString` does not implement any me
[23:58:55] <andor> thod in scope named `as_ptr`
[23:59:03] <andor> sorry for awkward wrap, windows console
[23:59:05] <mitsuhiko> (i understand it no longer guarnatees it)
[23:59:08] <dbaupp> andor: oh, I must've remembered the name incorrectly, check the docs
[23:59:32] <cmr> mitsuhiko: no, it doesn't.
[23:59:38] <andor> dbaupp: are we talking master or 0.9?

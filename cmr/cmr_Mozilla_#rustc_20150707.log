[00:01:51] *** Quits: klutzy (not@moz-0t8.piq.68.115.IP) (Ping timeout: 121 seconds)
[00:08:30] *** Joins: klutzy (not@moz-0t8.piq.68.115.IP)
[00:24:08] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[00:45:15] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[01:18:58] *** Joins: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP)
[01:19:08] <eternaleye> This may be of interest: http://article.gmane.org/gmane.comp.compilers.clang.devel/43502
[02:18:05] *** Quits: kimundi (kimundi@moz-d91h8n.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:19:53] *** Joins: kimundi (kimundi@moz-q19o2l.dip0.t-ipconnect.de)
[03:58:45] *** Quits: eddyb (eddyb@moz-413.q07.26.188.IP) (Quit: Konversation terminated!)
[03:58:53] *** Joins: eddyb (eddyb@moz-413.q07.26.188.IP)
[04:17:32] *** Quits: Manishearth (manishearth@moz-uc30rq.anapnea.net) (Ping timeout: 121 seconds)
[04:24:20] *** Joins: Manishearth (manishearth@moz-uc30rq.anapnea.net)
[04:24:20] *** ChanServ sets mode: +ao Manishearth Manishearth
[04:44:56] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[04:52:29] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[05:01:36] *** Quits: eddyb (eddyb@moz-413.q07.26.188.IP) (Ping timeout: 121 seconds)
[05:01:53] *** Joins: eddyb (eddyb@moz-413.q07.26.188.IP)
[05:20:37] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Connection closed)
[06:02:54] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[06:23:59] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[06:47:55] *** Joins: laumann (thomas@moz-3m6.3kq.109.2.IP)
[06:48:43] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[07:19:10] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[07:29:01] *** Quits: eddyb (eddyb@moz-413.q07.26.188.IP) (Ping timeout: 121 seconds)
[07:32:16] *** Joins: eddyb (eddyb@moz-413.q07.26.188.IP)
[07:59:25] *** Joins: eddyb_ (eddyb@moz-413.q07.26.188.IP)
[08:02:18] *** Quits: eddyb (eddyb@moz-413.q07.26.188.IP) (Ping timeout: 121 seconds)
[08:02:56] *** eddyb_ is now known as eddyb
[08:18:43] *** Quits: stl (stl@moz-511.ict.15.176.IP) (Ping timeout: 121 seconds)
[08:37:11] *** Joins: stl (stl@moz-stg.7dk.15.176.IP)
[10:04:13] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Connection closed)
[10:30:03] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[11:25:47] *** Joins: eddyb_ (eddyb@moz-tic.sgj.26.188.IP)
[11:28:40] *** Quits: eddyb (eddyb@moz-413.q07.26.188.IP) (Ping timeout: 121 seconds)
[12:16:19] *** Quits: madmalik (uid13697@moz-lfin5p.brockwell.irccloud.com) (Quit: Connection closed for inactivity)
[13:08:50] *** Joins: Tobba (Tobba@moz-9am.9ik.36.192.IP)
[13:34:22] *** Quits: Tobba (Tobba@moz-9am.9ik.36.192.IP) (Ping timeout: 121 seconds)
[13:41:15] *** Joins: Tobba (Tobba@moz-9am.9ik.36.192.IP)
[13:51:56] *** Quits: Tobba (Tobba@moz-9am.9ik.36.192.IP) (A TLS packet with unexpected length was received.)
[17:06:29] *** Quits: laumann (thomas@moz-3m6.3kq.109.2.IP) (Ping timeout: 121 seconds)
[17:08:11] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[17:08:11] *** ChanServ sets mode: +qo brson brson
[18:25:31] *** eddyb_ is now known as eddyb
[18:40:50] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[19:21:48] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Connection closed)
[19:25:51] *** Joins: arielb1 (Ariel@moz-2i0s5u.red.bezeqint.net)
[19:26:09] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[19:33:38] *** Quits: nagisa (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[19:46:35] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (A TLS packet with unexpected length was received.)
[19:49:55] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[19:53:05] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[21:03:24] <nmatsakis> pre-rfc for MIR: https://gist.github.com/nikomatsakis/3c59b0a48e0dcafc85e0
[21:03:40] <nmatsakis> I'm wondering what should be in there -- and what is the "minimum viable product" to land
[21:03:56] <nmatsakis> I'm thinking that if I get the MIR construction building with a -Z option and just dumping out graphviz for now, that's a good target
[21:05:45] <brson> nmatsakis: will the mir itself be a suitable target for transpilers for other rust-like languages?
[21:06:09] <nmatsakis> brson: I would think so, yes. It's kind of analogous to java byte code
[21:06:15] <brson> good
[21:06:23] <brson> so all the analysis will eventually run over the mir?
[21:06:32] <nmatsakis> borrow checking, moves, and liveness for sure
[21:06:37] <nmatsakis> that was something I wanted to do in the RFC actually
[21:06:40] <nmatsakis> was go diging throgh the analyses
[21:06:44] <nmatsakis> and indicate i they're a good fit
[21:06:54] <nmatsakis> the ones that are not necessarily a good fit I've thought of are: lints, privacy
[21:07:05] <nmatsakis> the former because they often want precisely the sort of irrelevant detail we're trying to hide
[21:07:12] <nmatsakis> (e.g., did you use a redundant pair of parentheses?)
[21:07:20] <nmatsakis> (it'll depend on the lint I guess)
[21:07:37] <nmatsakis> privacy for similar reasons: if there are two paths to the same item, one might be legal and the other not, etc
[21:07:43] <nmatsakis> we could potentially retain enough info for privacy checking though
[21:07:46] <nmatsakis> but I'm not sure if that's important
[21:12:13] *** Joins: Tobba (Tobba@moz-4l45on.skybroadband.com)
[21:13:31] <nmatsakis> brson: transpilers are an interesting example. I've been wanting to write a type-checker for the MIR that could serve as a "validation" or our earlier type-checker -- it would not do any inference, and assume all types are known.
[21:13:40] <nmatsakis> brson: seems like it'd be useful for checking output of transpilers as well
[21:22:38] <nagisa> well, Haskellâ€™s Core already knows all types for example
[21:27:52] <jroesch> nmatsakis, nagisa: it also allows you to turn on sanity checking mode when doing core-to-core optimizations 
[21:28:18] <jroesch> which is useful if we start doing our own optimization 
[21:29:22] <jroesch> nmatsakis:  I read over the branch and RFC draft, super excited about landing this in the (hopefully) near future
[21:31:04] <nmatsakis> jroesch: yeah I'm forcing myself not to work on it right now but I want to try and land SOMETHING soon that we can at least play with
[21:32:02] <brson> install failures on fedora-based systems are a pretty big wart right hnow https://users.rust-lang.org/t/installation-error-in-centos7/1938/4
[21:32:11] <brson> this should be pretty easy to fix
[21:32:39] <jroesch>  I'm also in favor of the ML-module flavored trait interface to the HIR is a nice
[21:32:58] <jroesch> it is nice*
[21:41:17] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[21:57:34] *** Quits: Tobba (Tobba@moz-4l45on.skybroadband.com) (A TLS packet with unexpected length was received.)
[21:58:13] *** Joins: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com)
[22:10:33] *** Quits: arielb1 (Ariel@moz-2i0s5u.red.bezeqint.net) (Connection closed)
[22:11:30] <kimundi> nmatsakis: "CALL(LVALUE0 = LVALUE1(LVALUE2...)" Should the argumetns be rvalues?
[22:13:31] <nmatsakis> kimundi: I went back and forth on this. Maybe. I was sticking to the principle that rvalues only appear on RHS of an assignment, but it's not clear if this is best. We may also want a 3rd category, Operand
[22:14:25] <nmatsakis> kimundi: in particular, lvalues can be consumed through basically any appearance except for in a borrow expression
[22:14:58] <kimundi> hmm
[22:19:40] <kimundi> nmatsakis: I've developed a kinda mental model where syntactic positions either want an rvalue or an lvalue, passing them the right one is a no-op, and passing them the wrong one causes a conversion of some kind. Specifically, lvalue -> rvalue is a move/copy, and rvalue -> lvalue is introduction of an temporary
[22:20:01] <kimundi> nmatsakis: I'm not sure if that entirely maps to reality, but I found it useful to think about it like that
[22:22:42] <nmatsakis> kimundi: that's basically right, yes
[22:23:22] <nmatsakis> kimundi: the MIR simplifies that in that temporaries are made explicit, so there is only two cases: consuming an lvalue and borrowing an lvalue
[22:23:33] <nmatsakis> and borrowing only occurs in an &lvalue expression
[22:47:40] <eddyb> nmatsakis: hmpf
[22:48:10] <eddyb> nmatsakis: there's several oddities that I'm not sure could be removed
[22:49:07] <eddyb> nmatsakis: AFAICT you're always using a return pointer
[22:49:20] <nmatsakis> yes
[22:49:28] <nmatsakis> should be trivial to desugar if desired
[22:49:38] <nmatsakis> (that is, in the generated LLVM code)
[22:49:53] <nmatsakis> (in general, optimized away temps that are only assigned once is quite easy)
[22:49:59] <eddyb> though first-class assignment means most of your lvalues can be lowered to SSA values
[22:50:09] <nmatsakis> yes, right
[22:50:20] <nmatsakis> we can do a simple on-the-fly removal of temps etc that are assigned once
[22:50:27] <eddyb> I'm not sure I like it, but it could be (much) worse
[22:50:39] <nmatsakis> for analyses it's definitely a plus to have a good consistent IR
[22:50:45] <nmatsakis> and not have to deal with multiple cases
[22:50:48] <nmatsakis> e.g. return by value vs by ref
[22:50:50] <eddyb> nmatsakis: for some reason I expected the MIR to be safe
[22:50:56] <nmatsakis> it's mostly safe
[22:51:10] <nmatsakis> I guess the two things in there that can't be checked are bounds checks and downcasts
[22:51:16] <eddyb> why do bound checks need to be in the MIR?
[22:51:18] <nmatsakis> and of course we could easily extend type system to cover those
[22:51:20] <nmatsakis> I debated about it
[22:51:30] <nmatsakis> well, they generate panics, which generates unwinding, so we have to know what to drop etc
[22:52:01] <nmatsakis> (that said, I'm pretty comfortable with there being a few things that the MIR asserts, and which a fairly trivial dependent type system could check in any case)
[22:52:03] <eddyb> but so can arbitrary function calls
[22:52:15] <nmatsakis> yes, so?
[22:52:19] <nmatsakis> that's why they are terminators
[22:52:40] <nmatsakis> (that is, they end the basic block, so we can include the unwind edge)
[22:52:52] <eddyb> wait, what?
[22:52:54] * eddyb reads again
[22:53:14] <eddyb> oh, fun, how did I miss that
[22:54:39] <eddyb> I think LVALUE and RVALUE are confusing
[22:55:29] <eddyb> but I can't come up with better names
[22:56:31] * nmatsakis afk
[22:58:05] <eddyb> having both LVALUE = RVALUE and RVALUE as statements doesn't feel right. I know we do some hackery in trans, but why not keep the MIR uniform?
[22:59:52] <eddyb> nmatsakis: wait, what about checked arithmetic?
[23:01:31] <eddyb> x = arr[idx] should be y = arr[idx]
[23:09:22] <eddyb> oh wow https://github.com/nikomatsakis/rust/blob/mir/src/librustc_mir/hir.rs
[23:10:46] <jroesch> eddyb: the HIR is what I was excited about
[23:11:00] <eddyb> is this the same thing from nrc'c RFC?
[23:11:30] <nrc> No, different things, same name, confusion!
[23:11:44] <eddyb> https://github.com/nikomatsakis/rust/blob/mir/src/librustc_mir/hir.rs#L139 hmpf
[23:11:48] <jroesch> yeah that is more Niko's layer mapping down from some "HIR"
[23:12:04] <nrc> Niko's HIR is an abstraction over lower level things - HIR or AST or whatever
[23:13:02] <eddyb> I'm not seeing paths to functions/methods, but maybe those are in the "FIXME Constant"
[23:14:07] <eddyb> oh look, this thing that I wanted to use in trans https://github.com/nikomatsakis/rust/blob/mir/src/librustc_mir/build/mod.rs#L53
[23:14:26] <eddyb> I would've had Block<T=()> but maybe that's too confusing
[23:16:50] <jroesch> eddyb: I posted a PR with my inference changes https://github.com/rust-lang/rust/pull/26870 everything but type aliases appear to work, not sure if you have any insight there
[23:16:58] <eddyb> ehm
[23:17:03] <eddyb> jroesch: they should work
[23:17:20] <eddyb> oh but I may know why
[23:17:30] <jroesch> currently the problem is they are desugared before we reach inference (at least from my reading of the debug log)
[23:17:39] <eddyb> not really
[23:17:44] <jroesch> nmatsakis: said at first we should disallow it 
[23:17:51] <eddyb> they are instantiate at the same time
[23:17:54] <eddyb> *instantiated
[23:18:00] <eddyb> jroesch: you replaced next_ty_vars calls, right?
[23:18:08] <eddyb> (I remember I did that too in my old attempt)
[23:18:13] <jroesch> well when we hit instantiate_path 
[23:18:13] <eddyb> that's probably right
[23:18:14] <jroesch> yes
[23:19:09] <eddyb> https://github.com/rust-lang/rust/pull/26870/files#diff-1d1b0d29a2e8da97c6bfb6e364d920c7L4667
[23:19:11] <jroesch> assuming the test case I have on the PR we end up instantiating HashMap::new() not IntMap::new()
[23:20:10] <eddyb> wait, that's a...
[23:20:31] <eddyb> jroesch: try <IntMap>::new()
[23:20:55] <jroesch> k
[23:21:12] <eddyb> the code instantiating that path is in astconv
[23:21:19] <eddyb> I guess that's the part you missed
[23:21:33] <eddyb> well, the IntMap part of the path
[23:22:32] <jroesch> yeah that is it
[23:22:41] <jroesch> it worked just fine with <IntMap>::new()
[23:23:06] <jroesch> it would be nice for that to be more consistent 
[23:23:17] <eddyb> jroesch: well, it's tricky
[23:23:31] <eddyb> <IntMap>::new() forces the default
[23:23:48] <jroesch> I assumed so ;)
[23:23:51] <eddyb> right now you don't track inference variables created on types used in associated types
[23:24:19] <eddyb> astconv does that and I'm guessing it doesn't use next_ty_vars
[23:24:54] <jroesch> in a function or in multiple places?
[23:25:43] <eddyb> I think there's a method on AstConv
[23:25:58] <eddyb> that you need to modify to take a TypeParamDef or something like that
[23:35:31] <eddyb> nrc: thinking more about resolve building the HIR and IDs not existing in the AST
[23:36:19] <nrc> I think we need some ids in the AST - so tools can identify nodes, but they should be different ids to the compilers
[23:37:00] <eddyb> nrc: parts of resolve would need to be modified to first intern objects and then use references to them
[23:37:36] <eddyb> it should be possible, given that IDs have to come from somewhere, and that source can do the appropriate interning
[23:40:18] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Quit: leaving)
[23:41:32] <nrc> I've been wondering how early we need IDs - one possible implementation of hygiene (scope sets) needs a way to identify scopes in token trees (or the AST), which suggests we might need IDs early. I'd prefer to sue addresses, but that means not folding the AST
[23:43:54] <eddyb> nrc: except the AST doesn't really move :P
[23:44:09] <eddyb> (well, some node types aren't perfect, but most are folded in-place)
[23:44:45] <eddyb> nrc: I wish hygiene could be understood by lesser humans
[23:44:52] <nrc> right, most isn't good enough, but if we can fix that...
[23:45:02] <nrc> or define the right invariants
[23:45:48] <eddyb> I haven't seen any hygiene algorithm description that I can grasp. I could probably implement any of them, but not understand *why* it works
[23:46:01] <eddyb> which is paramount to adapting the algorithm
[23:46:12] <eddyb> (tantamount? I have no idea what those words mean :P)
[23:46:27] <eddyb> nrc: removing the and_then method on P would do it
[23:47:26] <eddyb> but if you just need statio- OH
[23:47:34] <eddyb> nrc: do you need scopes like ast::Block?
[23:47:49] <eddyb> because I wouldn't mind a single AST node having its own IDs
[23:48:20] <eddyb> the problem with the AST is that everything has IDs and they all live in the same namespace
[23:48:24] <nrc> yes, anything that introduces a scope - blocks, fns, items, etc.
[23:48:48] <eddyb> a fn body is a block
[23:49:20] <eddyb> maybe modules and blocks?
[23:49:49] <eddyb> nrc: also see that mention of scope chains for the HIR
[23:50:52] <eddyb> when visiting you can always keep a reference to the innermost scope you're in
[23:51:00] <nrc> there's also scope for the function signature - e.g., type params are in scope there, but not elsewhere in the enclosing item
[23:51:30] <nrc> but you need to store the scopes as part of macros expansion, not just know them temporarily
[23:51:45] <eddyb> so there's no need to walk up parents to find the scope to look in
[23:52:03] <eddyb> nrc: I'm not sure what that entails
[23:52:26] <eddyb> the signature bit is relevant to the HIR scope chain thing
[23:52:44] <eddyb> since you need to be able to resolve associated items in signatures
[23:52:58] <eddyb> wait, no, nevermind
[23:53:25] <eddyb> the scope chain thing is to gather `use foo::bar::Trait;` only
[23:54:11] <eddyb> a fn singature would be in the "import" scope of the enclosing block (or module)

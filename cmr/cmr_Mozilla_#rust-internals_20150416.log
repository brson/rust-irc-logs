[00:01:35] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[00:02:17] *** Joins: blaenk_ (blaenkdenum@moz-12e081.res.rr.com)
[00:03:25] *** Quits: blaenk (blaenkdenum@moz-12e081.res.rr.com) (Ping timeout: 121 seconds)
[00:06:26] *** Quits: blaenk_ (blaenkdenum@moz-12e081.res.rr.com) (Ping timeout: 121 seconds)
[00:08:27] *** Quits: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua) (Ping timeout: 121 seconds)
[00:08:28] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[00:11:01] *** Quits: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP) (Ping timeout: 121 seconds)
[00:12:25] *** Joins: eternaleye (eternaleye@moz-7ps.ehi.245.50.IP)
[00:15:11] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[00:24:35] <jethrogb> I'm soliciting feedback on a draft RFC https://github.com/jethrogb/rfcs/blob/topic/visibility-override/text/0000-visibility-override.md
[00:26:29] <scott> jethrogb: I like the idea. breaking privacy should be strongly avoided, but it's nice to have an easy out when you absolutely need it
[00:27:08] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Quit: leaving)
[00:27:57] <huon> steveklabnik: ping
[00:29:31] <scott> jethrogb: it should perhaps be more emphasized that visibility is highly unsafe
[00:30:16] <scott> jethrogb: eg. you can easily cause some other code to crash with just visibility_override and no unsafe, if the other code assumes invariants which you then break
[00:30:37] <scott> s/visibility/visibility_override/
[00:31:09] <jethrogb> I'll add that to the drawbacks section
[00:35:37] <jethrogb> updated
[00:38:42] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[00:45:07] *** Quits: det (chris@moz-qij3pi.lv.cox.net) (Connection closed)
[00:45:28] *** Joins: det (chris@moz-qij3pi.lv.cox.net)
[00:46:55] <scott> jethrogb: it's a bit bikesheddy, but I would rename it to unsafe_visibility_override or at least something with unsafe in the name in light of my above comments
[00:47:03] *** Quits: marsel (user@moz-v6q.71o.180.94.IP) (Ping timeout: 121 seconds)
[00:47:06] <scott> which also makes it show up in grep if someone's auditing unsafe blocks
[00:47:24] <scott> since it can cause memory unsafety, etc, that's pretty important
[00:48:19] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Connection closed)
[00:48:39] <scott> even more nitpicky, your code sample isn't following standard Rust style (same-line curly braces, spacing around operators and other bits of syntax)
[00:48:41] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[00:48:50] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Quit: Leaving)
[00:48:55] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[00:50:57] <steveklabnik> huon: pong
[00:52:15] <huon> steveklabnik: hi, so for this talk I did at the meetup I found it useful to highlight introduced code (e.g. http://huonw.github.io/concurrency-apr15/#18 vs. the previous slide)
[00:52:31] <huon> steveklabnik: is this something you would want to use e.g. in the book?
[00:52:43] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Ping timeout: 121 seconds)
[00:53:06] <huon> steveklabnik: (I'm trying to work out if it's worth investigating a more structured way to do it, i.e. if it's more generally useful)
[00:53:12] <huon> *do it in rustdoc
[00:54:01] <bstrie> I like the highlighting
[00:54:22] <bstrie> the exact visual style should probably be toned down a bit for the book
[00:55:06] <jethrogb> scott: I assume you're worried about people modifying things like Vec.cap
[00:55:09] *** Joins: mdup (mdup@moz-q9e1g5.abo.wanadoo.fr)
[00:55:13] *** Quits: mdup (mdup@moz-q9e1g5.abo.wanadoo.fr) (Quit: ")
[00:55:35] <steveklabnik> huon: that might be neat, yeah. i often have to refer to parts of a larger example, and it could get tedius
[00:55:38] <scott> jethrogb: yeah, that kind of thing, which may be unclear to people outside the code where the field is private
[00:55:47] <steveklabnik> i would say if it's easy, investigate it, but it's not a _huge_ pain
[00:55:51] <jethrogb> do you think it would make sense to create different patterns for mutable and immutable access?
[00:57:39] <scott> I don't think that would be worth it
[00:58:34] <jethrogb> e.g. the same as proposed for immutable access, but wrap the access in unsafe{} for mutable access
[00:59:10] <sfackler> it's unsafe either way
[00:59:17] <sfackler> e.g. Mutex.inner
[01:01:47] <jethrogb> hmmm
[01:01:51] *** Quits: dcb (textual@moz-j72nfe.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[01:04:36] *** Quits: mjboa (mike@moz-gfdglf.hsi06.unitymediagroup.de) (Quit: leaving)
[01:05:37] *** Joins: dcb (textual@moz-j72nfe.ca.comcast.net)
[01:06:04] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[01:06:40] <jethrogb> is there anything else on here that's wrong? https://doc.rust-lang.org/reference.html#behaviour-not-considered-unsafe
[01:07:43] <scott> it's not wrong
[01:08:06] <scott> reading private fields isn't unsafe{} just like setting Vec.cap isn't, but it's still very dangerous
[01:08:23] <scott> since it can make some other unsafe{} code go wrong
[01:09:21] <jethrogb> in that sense reading Mutex.data is also not unsafe
[01:10:40] <huon> reading it without unsynchronisation can be unsafe (can cause a data race)
[01:10:47] <huon> *without synchronisation
[01:11:49] <jethrogb> right, but according to the definition data races are not unsafe, but forbidden
[01:12:54] <aatch> jethrogb, that's because you shouldn't be able to create a data race without unsafe code to start with.
[01:13:18] <huon> hm, are you meaning unsafe in the literal sense of the `unsafe` keyword in Rust?
[01:13:42] <scott> jethrogb: I think Rust guarantees no data races without unsafe{} code
[01:13:58] <huon> things in Rust are considered `unsafe` if they can lead to forbidden behaviour if the programmer isn't careful
[01:14:16] <jethrogb> I'm confused and not sure what I mean
[01:14:16] <jethrogb> the doc says "The following is a list of behavior which is forbidden in all Rust code, including within unsafe blocks and unsafe functions."
[01:14:17] <huon> (in safe code, the compiler guarantees that nothing forbidden can happen)
[01:14:20] <jethrogb> but clearly you can write whatever you want in unsafe{}
[01:14:44] <huon> right; the program exhibits undefined behaviour and is fundamentally incorrect if it triggers any of those behaviours
[01:14:47] <scott> jethrogb: if you do something forbidden in an unsafe block you generally invoke undefined behaviour
[01:15:17] <huon> `unsafe` gives the programmer more power at the risk of triggering forbidden behaviour since the compiler isn't/can't check the unsafe behaviours fully
[01:15:18] <aatch> In this context, "unsafe" is like rock climbing without the appropriate gear, you might have a good reason to do so, "forbidden" is like time travel, if you manage to do it, the universe breaks.
[01:16:08] <scott> I think "forbidden" being death fits your analogy better :p
[01:16:12] <jethrogb> haha
[01:16:45] <aatch> Well no, the point is more that we assume that "forbidden" things can't happen and therefore if they do, all bets are off.
[01:16:46] <jethrogb> I guess I was thinking about unsafe{} with respect to memory-safety
[01:16:56] <jethrogb> but it's really used for other things too
[01:17:00] <huon> not really
[01:17:22] <aatch> In general, it all boils down to memory safety anyway.
[01:17:29] <scott> data races are included in what Rust means by memory safety
[01:17:38] <huon> all rust code should/must be memory safe; normally the compiler ensures it, but `unsafe` puts the responsibility in the hands of the programmer (locally)
[01:18:05] <aatch> Data races are just a specific case of memory unsafety.
[01:18:21] <jethrogb> ok, so we have demonstrated that you can achieve data races through privacy violations
[01:18:33] <jethrogb> but that can't be both unsafe and not-unsafe
[01:19:08] <scott> different meanings of unsafe are involved
[01:19:29] <jethrogb> I'm afraid so
[01:19:29] <aatch> jethrogb, in that list, getting at the private field requires unsafe code to start with.
[01:19:39] *** Joins: theme (theme@moz-i3mhhb.asianet.co.th)
[01:19:56] <scott> some other code that has direct access to the private field is using unsafe{} and manually preserving some invariants. then it makes the field private to make sure no one breaks those invariants
[01:20:10] <scott> now your new attribute comes along and opens the hole again to break those invariants
[01:20:22] <scott> so unsafety-as-in-forbidden-behaviour can result again
[01:20:36] <jethrogb> would it make more sense to just allow privacy violations in unsafe{} instead of adding this attribute?
[01:20:53] <scott> that seems worse
[01:20:54] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[01:20:55] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Connection closed)
[01:20:57] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[01:21:06] <aatch> jethrogb, my opinion is that the attribute isn't worth the bother.
[01:21:38] <huon> jethrogb: another drawback is that backwards compatibility becomes much more difficult
[01:21:49] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[01:21:54] <huon> e.g. renaming a private field can cause downstream crates to break
[01:22:12] <scott> huon: I see this attribute as a declaration that "if upstream breaks me it's my fault" but I can see people disagreeing with even that
[01:22:23] <jethrogb> what scott said
[01:22:31] <jethrogb> also, upstream can always break things downstream
[01:22:45] <scott> yeah, but private APIs shouldn't ever
[01:23:03] <aatch> it's even more of an issue when the break might be several crates removed.
[01:23:03] *** Joins: pcwalton (pcwalton@moz-6kjabm.ca.comcast.net)
[01:23:03] *** ChanServ sets mode: +o pcwalton
[01:23:19] <sfackler> "it's my fault" does not always end up being the reaction: https://android.googlesource.com/platform/libcore/+/81abb6fb7332dfe62ff596ffb250d8aec61895df%5E!/
[01:24:20] <scott> indeed. de facto dependencies trump everything if you have important downstreams
[01:24:57] *** Quits: pcwalton (pcwalton@moz-6kjabm.ca.comcast.net) (Client exited)
[01:25:15] <aatch> A user (or hell, even author) of crate C isn't going to care if the reason the crate is broken is because crate B relied on private parts of crate A
[01:25:52] <sfackler> it's the same reason there's no way to opt in to features on stable releases: people are going to use unstable stuff and complain if it changes
[01:25:55] <scott> good point with the transitive deps
[01:26:23] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[01:26:29] <jethrogb> I'm not terribly familier with the rust linker, but shouldn't these things be caught at compile/link time?
[01:27:00] <sfackler> it will be, but you're still breaking random downstream stuff in ways you wouldn't expect
[01:27:04] <scott> some changes might be subtle runtime bugs, some may be compiler errors, but that's not even the point of the above reasoning
[01:27:23] <bstrie> jethrogb: I don't believe Rust has any feature that can cause link-time failure
[01:27:43] <sfackler> bugs!
[01:27:49] <bstrie> RFC: more bugs!
[01:28:11] <Gankro> acrichto: Got any more rustdoc stuff in the oven? Don't want to step on your toes.
[01:28:45] <jethrogb> backwards compatibility is an interesting discussion, but it's actually an argument for this attribute
[01:28:51] <acrichto> Gankro: nah the current PR I have I think is one of the last ones for awhile
[01:28:56] <jethrogb> you can already do this using an unsafe typecast
[01:29:03] <jethrogb> and the only way you know it breaks is during runtime
[01:29:13] <jethrogb> but with the attribute at least you get type-checking
[01:29:39] <sfackler> or you could... not access private fields
[01:29:39] <jethrogb> so that should help remediate backwards-compatibility issues
[01:29:43] *** Joins: joneshf-laptop (joneshf@moz-l4h.b5s.208.98.IP)
[01:29:46] <huon> acrichto: https://github.com/rust-lang/rust/issues/24417 would be pretty nice to fix if you're feeling like it...
[01:30:00] <huon> in fact, I'll nominate it
[01:30:32] <acrichto> huon: oh right I keep forgetting that one
[01:30:33] <jethrogb> sfackler: if I have to choose between 10x performance slowdown and accessing private fields I know what I'm choosing
[01:30:59] <scott> jethrogb: seems better to submit something upstream in that case
[01:31:38] *** Quits: empoZ (empoZ@moz-ccitnk.priv.bahnhof.se) (Connection closed)
[01:34:58] <Gankro> acrichto: Current PR? I don't see anything? Already landed?
[01:35:13] <acrichto> Gankro: https://github.com/rust-lang/rust/pull/24396
[01:36:24] *** Joins: bletchcxgfx (Mibbit@moz-juv.9o3.252.72.IP)
[01:37:55] <Gankro> acrichto: Safe to rebase work ontop of that?
[01:38:09] <Gankro> err... non-re-base? ...base...?
[01:38:21] <acrichto> Gankro: eh rustdoc doesn't have too many merge conflicts, but yeah
[01:38:37] <steveklabnik> wow, my rollup passed the first time. that's... a first
[01:38:38] <steveklabnik> lol
[01:38:43] <sfackler> Gankro / acrichto: want to fix https://github.com/rust-lang/rust/issues/24473 if you're already in there?
[01:39:59] <Gankro> sfackler: Yeah jakub's suggested fix seems good
[01:40:08] <Gankro> Probably gonna do that
[01:40:23] <sfackler> though I am pretty sure this is responsible for my github commit streak
[01:40:27] <sfackler> so maybe we should keep it :P
[01:40:31] <Gankro> heh
[01:41:24] <huon> everyone's streaks will disappear once stability kicks in
[01:41:56] <huon> the commits-per-day in the Rust world will fall by orders of magnitude
[01:42:03] *** Quits: bletchcxgfx (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[01:42:15] <steveklabnik> hehehe
[01:43:13] <Gankro> acrichto: Also I'm disappointed you missed the opportunity to call the previous PR "rustdocalypse 2k15"
[01:43:35] *** Joins: summerlight_ (summerlight@moz-99k.2mj.130.121.IP)
[01:43:36] <huon> "rustdoc reform"
[01:44:17] <steveklabnik> lolol
[01:45:04] <huon> what's our cycle time at the moment, btw?
[01:45:48] <Gankro> huon: Not enough bikeshed for "* reform"
[01:46:03] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[01:46:22] <huon> nah, there was a reform reform, so the bikeshed threshold was lowered
[01:46:59] <nrc> can we have "bikeshed threshold" as an official statistic, tracked on the website?
[01:47:20] <nrc> along with an "it has been n days since the last reform RFC" sign
[01:48:51] <bstrie> a few years ago we went through and made sure that every FIXME in the codebase had an associated issue in the tracker, I think we might need to do that again
[01:49:15] <sfackler> doesn't tidy check for that?
[01:49:23] <nrc> not any more
[01:49:29] <nrc> bstrie: I would love that
[01:49:45] <bstrie> as an upper bound, there are only ~1600
[01:49:51] <nrc> I pressed for it a while back, but the consensus was we couldn't be bothered :-s
[01:50:05] <bstrie> sounds like a good project for the latter half of this stability cycle
[01:51:42] <bstrie> like, this FIXME here is waiting on the implementation of DST
[01:51:49] <bstrie> allegedly
[01:51:49] <huon> a "nicer" one would be going through and finding all the fixme's with issue numbers that point to closed issues
[01:51:55] <huon> could probably even be automated
[01:51:58] <steveklabnik> bstrie: but nooo we've been just under 2000 issues for a while ;)
[01:52:01] *** Joins: mib_gklf4x (Mibbit@moz-juv.9o3.252.72.IP)
[01:52:18] <steveklabnik> i've been slacking on my hyper-triage
[01:52:20] <steveklabnik> :p
[01:53:01] <bstrie> steveklabnik: I'll file a bug for reminding you to resume hypertriage
[01:53:59] <bstrie> btw, github isn't doing an octoverse thing this year, but a little birdy told me that rust was #12 among merged PRs for all github projects in 2014
[01:54:16] <bstrie> up from #25 last year
[01:54:26] <steveklabnik> nice
[01:55:18] <aatch> I'm so glad they improved the PR/issue tracker. Now you can look at *just* PRs or *just* issues.
[01:55:42] <aatch> Before it was PRs and PRs+Issues (I believe, may have been the other way around).
[01:57:00] <bstrie> wouldn't it be great if github just had an open issue tracker for their platform :P
[01:57:11] <bstrie> I even know this great site where they can host it
[01:58:21] <acrichto> Gankro: gah I always pass up these fantastic opportunities!
[01:58:39] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[01:58:51] <Gankro> acrichto: It's cool I've got all summer to teach you how to program :P
[01:58:56] <acrichto> lol
[01:59:20] <aatch> Hey, it's one of the hard problems in software.
[01:59:57] <aatch> Two hard problems: Naming things, cache invalidation and off-by-one errors.
[02:04:40] <bstrie> aatch: and updating the documentation
[02:05:04] <eternaleye> Has anyone ever turned that into a proper pastiche of the Spanish Inquisition sketch?
[02:06:38] *** Quits: dustinm (dustinm@moz-9ms.n6q.68.208.IP) (Ping timeout: 121 seconds)
[02:07:25] *** Quits: untitaker (untitaker@moz-0sc349.highway.telekom.at) (Ping timeout: 121 seconds)
[02:07:53] *** Quits: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP) (Ping timeout: 121 seconds)
[02:07:58] *** Quits: Sergio (Sergio@moz-23roph.bz) (Ping timeout: 121 seconds)
[02:08:17] *** Quits: bitemyapp (callen@moz-s2l.6j9.199.198.IP) (Ping timeout: 121 seconds)
[02:08:46] *** Quits: cgaebel (cgaebel@moz-aq9.qj7.199.198.IP) (Ping timeout: 121 seconds)
[02:08:52] *** Quits: jmorton (jmorton@moz-83s.irv.199.198.IP) (Ping timeout: 121 seconds)
[02:09:42] *** Joins: untitaker (untitaker@moz-fojcn1.highway.telekom.at)
[02:09:55] <seanmonstar> steveklabnik: you triage hyper issues? How kind 
[02:10:33] <steveklabnik> seanmonstar: haha :)
[02:11:18] <seanmonstar> steveklabnik: (it triggered a highlight) 
[02:11:24] <steveklabnik> makes sense :)
[02:11:35] *** Joins: dustinm (dustinm@moz-9ms.n6q.68.208.IP)
[02:13:19] <Amaranth> I think updating the documentation counts as cache invalidation :D
[02:15:14] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[02:21:09] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:26:54] <nrc> Hmm, if I have *mut T where t:? Sized, I have no way to tell if I have a fat or thin pointer
[02:26:58] <nrc> that is saddening
[02:28:27] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[02:33:24] *** Quits: ytain (ytain@moz-bps1td.dsl.teksavvy.com) (Quit: Textual IRC Client: www.textualapp.com)
[02:37:08] *** Quits: zz_kimundi (kimundi@moz-nr28ki.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[02:38:08] *** Joins: zz_kimundi (kimundi@moz-6dpcih.dip0.t-ipconnect.de)
[02:38:10] *** zz_kimundi is now known as kimundi
[02:43:21] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Ping timeout: 121 seconds)
[02:44:18] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[02:45:45] *** Quits: Diggsey (diggsey@moz-laps0j.dsl.pipex.com) (Ping timeout: 121 seconds)
[02:45:50] *** Joins: Unwound_ (bkoropoff@moz-kthi5c.wa.comcast.net)
[02:45:54] *** Unwound_ is now known as unwound
[02:46:10] *** Joins: jmorton (jmorton@moz-83s.irv.199.198.IP)
[02:47:43] *** Joins: Sergio (Sergio@moz-23roph.bz)
[02:49:09] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:49:48] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[02:49:59] *** Joins: bitemyapp (callen@moz-s2l.6j9.199.198.IP)
[02:51:49] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[02:56:11] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[02:56:18] *** Quits: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com) (Ping timeout: 121 seconds)
[02:57:05] *** Joins: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP)
[03:00:56] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[03:01:22] <seanmonstar> mem::size_of?
[03:01:24] <Gankro> nrc: Isn't it always fat, where fat supseteq thin?
[03:01:39] <Gankro> Oh derp
[03:01:44] <Gankro> ?Sized not !Sized
[03:02:12] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[03:03:37] <aatch> We could make an 'is_fat_ptr' intrinsic.
[03:04:12] *** Quits: dustinm (dustinm@moz-9ms.n6q.68.208.IP) (Ping timeout: 121 seconds)
[03:04:41] <nrc> I just implemented fat pointer to thin pointer casts, in conjunction with monomorphisation, it fulfils my use case, at least
[03:08:09] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Ping timeout: 121 seconds)
[03:09:53] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[03:10:32] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[03:10:59] *** Joins: dustinm (dustinm@moz-9ms.n6q.68.208.IP)
[03:11:38] *** Quits: dcb (textual@moz-j72nfe.ca.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[03:11:49] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Connection closed)
[03:18:31] <nrc> sigh, I have a segfault, but if I build with debug symbols I get an ICE :-(
[03:20:03] <Mutabah> nrc: Ouchies
[03:20:11] <Mutabah> nrc: Optimisation on?
[03:20:23] <nrc> no
[03:20:29] <nrc> too many new things all at once
[03:27:35] *** Joins: semarie (semarie@moz-72bfrp.torservers.net)
[03:31:00] *** Quits: mib_gklf4x (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[03:33:59] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Quit: )
[03:35:50] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[03:38:55] *** Joins: cgaebel (cgaebel@moz-aq9.qj7.199.198.IP)
[03:43:47] *** Joins: Unwound_ (bkoropoff@moz-kthi5c.wa.comcast.net)
[03:47:21] *** Quits: unwound (bkoropoff@moz-kthi5c.wa.comcast.net) (Ping timeout: 121 seconds)
[03:56:39] *** Quits: rovar (rovar@moz-6iq.47m.88.38.IP) (NickServ (RECOVER command used by rovar_))
[03:56:39] *** rovar_ is now known as rovar
[03:56:52] *** Joins: rovar_ (rovar@moz-6iq.47m.88.38.IP)
[03:59:47] *** Quits: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP) (Ping timeout: 121 seconds)
[04:00:24] *** Quits: Sergio (Sergio@moz-23roph.bz) (Ping timeout: 121 seconds)
[04:00:39] <nathan7> bstrie: any plans to make multirust help out with cross-compilation?
[04:02:25] <bstrie> nathan7: brson is the one to ask
[04:03:20] *** Quits: bitemyapp (callen@moz-s2l.6j9.199.198.IP) (Ping timeout: 121 seconds)
[04:04:22] *** Joins: bitemyapp (callen@moz-s2l.6j9.199.198.IP)
[04:04:43] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[04:05:35] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Connection closed)
[04:05:42] <sfackler> that'd be swee
[04:06:04] <sfackler> multirust extend-toolchain beta unknown-linux-i386" or something like that
[04:06:47] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[04:09:02] <nathan7> bstrie: whoops
[04:10:13] *** Unwound_ is now known as unwound
[04:10:50] *** Joins: Sergio (Sergio@moz-23roph.bz)
[04:15:27] *** Quits: sav (e@moz-9u3te2.cc) (Quit: Caught deadly signal: SIGSLEEP)
[04:17:35] <erickt> woohoo, got syntex compiling again
[04:18:01] <erickt> it's now using the beta libsyntax, but requires nightly to compile :/
[04:18:30] <sfackler> it'd be nice to have a "special" nightly that corresponds to each stable release
[04:18:39] <sfackler> but has all of the unstable stuff turned on
[04:18:46] <erickt> That would be handy
[04:18:55] <sfackler> so people that need unstable things but don't want to be upgrading every day have something to converge on
[04:19:12] <erickt> but it actually looks possible to get libsyntax to compile mostly with stable rust
[04:19:31] <erickt> I already got rid of 2 feature flags
[04:20:57] <bstrie> acrichto: cargo lists a crate's dependencies, but how hard would it be to list a crate's *dependents* :P (just for crates on crates.io, obviously)
[04:21:08] <bstrie> *crates.io lists a crate's dependencies
[04:21:12] <erickt> bstrie: there's support for it!
[04:21:21] <erickt> there's a hidden /reverse_dependencies url
[04:21:21] <bstrie> erickt: show me!
[04:21:35] <erickt> just add that to the end of a crate package
[04:21:39] <erickt> err, crate url
[04:21:41] <bstrie> erickt: awesome, thanks
[04:22:37] <erickt> omg we've had 1.3M crate downloads? that's nuts!
[04:22:41] *** Joins: kemurphy (kemurphy@moz-ke1.ea2.241.192.IP)
[04:23:13] <mcpherrin> that URL is too useful not to be linked anywhere
[04:23:14] <erickt> bstrie: remember back in the day when it was possible to actually read everything happening on #rust?
[04:23:28] <mcpherrin> erickt: haha, yeah
[04:23:30] <erickt> and the commits?
[04:23:36] <erickt> those were the days
[04:23:43] <mcpherrin> I remember the crossover point in #rust, where I started missing things that happened while I was asleep
[04:23:50] <mcpherrin> and then while I was working
[04:23:57] <mcpherrin> and now I read it once a week or so :P
[04:25:39] <erickt> I gave up long ago
[04:26:12] <huon> erickt: http://huonw.github.io/concurrency-apr15/crates-downloads.png
[04:26:28] <huon> (total downloads from crates.io vs time)
[04:26:51] <erickt> now lets all figure out a scheme to make a penny off each download
[04:29:26] <bstrie> erickt: I think it was a day in january 2013 when I realized that it was simply untenable to read #rust's scrollback every morning :P
[04:30:25] *** Joins: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net)
[04:30:38] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[04:31:19] *** Joins: blaenk (blaenkdenum@moz-ig0p4u.n2pv.fsko.e000.2605.IP)
[04:31:55] <erickt> haha, and there was the time when I was just maintaining nearly all of the external rust packages
[04:32:08] <erickt> so very long ago
[04:32:27] <erickt> now I can't keep some of my older projects up to date :(
[04:35:46] <bstrie> erickt: because of language changes?
[04:36:46] <erickt> and me being more responsible, really. serde really needs to happen. keeping ol' mre compiling at the same time when there's other webapp frameworks isn't as important
[04:37:13] <bstrie> haha, I remember mre!
[04:37:26] <erickt> I think it worked for 2 weeks!
[04:37:32] <erickt> then rust happened
[04:37:38] <erickt> HA!
[04:37:45] <erickt> I just realized really why the language is named rust
[04:37:51] <bstrie> 2 weeks is a triumph
[04:37:58] <erickt> it was back then
[04:38:03] <bstrie> we should have been giving out badges
[04:38:20] <erickt> these new kids have no idea what real rust was like
[04:39:14] <bstrie> one day I'll give a presentation entirely about argument modes, and then they shall know true fear
[04:39:34] <erickt> please do that for the 1.0 party
[04:39:43] <aatch> I always feel weird when I remember how long I've been involved with Rust.
[04:39:57] *** Joins: blaenk_ (blaenkdenum@moz-12e081.res.rr.com)
[04:39:58] <cmr> yeah
[04:40:00] <erickt> aatch: when was your first commit?
[04:40:09] <aatch> Uhh...
[04:40:11] * aatch looks
[04:40:35] <erickt> cmr: and you! i was so excited when I learned you started hacking on rust in high school
[04:40:44] <erickt> then was jealous that you got to hack on rust in high school
[04:40:49] <cmr> https://github.com/rust-lang/rust/commit/a289dcd18719018ca7051dc03d4a711993008eb2
[04:40:57] <bstrie> aatch is the prodigal son, having returned to us after so long
[04:41:11] <erickt> I remember being proud that I could draw a sierpinski triangle on the screen
[04:41:43] <cmr> https://github.com/rust-lang/rust/commit/92bf9b68da05504e925e2b66ceb9f3e5f1a5b0ee was my first commit
[04:41:45] <erickt> aatch: ah you're such a youngin!
[04:41:46] *** Quits: blaenk (blaenkdenum@moz-ig0p4u.n2pv.fsko.e000.2605.IP) (Ping timeout: 121 seconds)
[04:41:46] <cmr> so lame
[04:42:01] <aatch> Hey, I've stuck with Rust longer than I did with D
[04:42:20] <erickt> here's me doing some truly important work in my first commit: https://github.com/rust-lang/rust/commit/4d0cbd4310a201c233386ce4a2679cef0c8cc629
[04:42:41] <erickt> where would we be if we didn't have auto-indenting in vim?
[04:43:06] <aatch> erickt, using emacs?
[04:43:07] <erickt> probably would have been a COBOL or something
[04:43:28] * erickt hackles rise
[04:43:34] <erickt> raises?
[04:43:36] <erickt> I dunno
[04:43:49] <aatch> rose-ed
[04:44:07] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Connection closed)
[04:44:16] *** Quits: blaenk_ (blaenkdenum@moz-12e081.res.rr.com) (Quit: Leaving)
[04:44:17] <reem> This is mine: https://github.com/rust-lang/rust/commit/3dace3504480df37d261da2ef3ac753f5ac811ee, also critically important
[04:44:18] <erickt> riseninged
[04:45:04] <erickt> reem: you know, technically that means you were back during sigil times
[04:45:32] <aatch> Whats actually odd is when I see people suggest features that *we already tried*.
[04:45:54] <erickt> reem: you can lord it over the newbies
[04:45:55] <reem> I was actually around a few months before that, I wrote my first rust when ~[T] was still an active thing
[04:45:58] <erickt> haha
[04:46:04] <erickt> aatch: ^
[04:46:09] <reem> aatch: It happens *a lot*
[04:46:25] <erickt> I love the fact that I came to rust because of typestate
[04:46:52] <aatch> Also, "Rust has so many pointer types!"... /o\
[04:47:07] <erickt> if only they knew
[04:47:38] <erickt> we should release a special fork of the 1.0 rust that adds back the sigils
[04:47:40] <Eridius> Any chance I could convince someone to review my over-2-months-old PR on rust.vim? https://github.com/rust-lang/rust.vim/pull/7
[04:47:43] <reem> I think this is my first committed rust https://github.com/reem/rust-euler/commit/3a7cedb9b0b12c09e662e1bee09dffd0f0f0a1d6
[04:47:52] <huon> we could alias @ to Box and ~ to Rc
[04:48:05] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[04:48:07] <reem> Maximally confuse everyone
[04:48:08] <erickt> huon: exactly!
[04:48:14] <aatch> huon, to screw with people?
[04:48:18] <cmr> erickt: who actually has review rights on that repo?
[04:48:23] <cmr> erm, Eridius ^
[04:48:25] <aatch> huon, including yourself?
[04:48:33] <huon> aatch: that's the plan :D
[04:48:49] <Eridius> cmr: I'm not actually sure. Does rust-highfive maintain separate lists for each repo?
[04:48:54] <cmr> I don't know.
[04:48:56] <huon> Eridius: yes
[04:48:57] <Eridius> or rather, bors
[04:49:05] <huon> I don't think bors is active on those repos
[04:49:18] <huon> I'm happy to merge if someone who's familiar with vim gives an r+
[04:49:23] <huon> (I know nothing)
[04:49:23] <Eridius> ah right, it looks like PRs are just manually merged
[04:49:32] <Eridius> huon: I've been running on the PR for the last 2 months with no problem :)
[04:49:45] <huon> heh
[04:49:49] <erickt> reem: ah fizzbuzz, an honorable choice for your first rust project
[04:50:18] <aatch> Heh, looks like my discriminant_value PR happened when I wasn't looking.
[04:50:27] <bstrie> erickt: jeez, I didn't figure you were around longer enough to remember the ocaml compiler :P
[04:50:38] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[04:50:50] <erickt> bstrie: yep! another reason I'm here
[04:51:02] <erickt> I came from felix, which also had an ocaml compiler
[04:51:15] <erickt> I sure enjoyed ocaml back in the day
[04:52:11] <erickt> unfortunately back then the compiler work was all done by the inria, and they tended to throw releases over the wall
[04:52:44] <erickt> so it was hard to participate in the actual language since they didn't want to release code before they wrote papers on their research
[04:53:20] <Eridius> huon: thanks!
[04:53:22] <huon> Eridius: merged
[04:54:41] <aatch> erickt, and I guess that meant contributing code was difficult because you'd change some part they re-wrote but wouldn't tell you?
[04:55:07] <bstrie> aturon: clarification of the 1.0-release cut: are we going to fast-forward the beta branch to master before the cut (on friday or so), or are we just going to cherry-pick the important things that have happened on master over the past two weeks?
[04:55:57] <erickt> it wasn't that bad. really my main breaking point was that they released this nifty build system ocamlbuild that I wanted to contribute to
[04:56:08] <erickt> because I was doing some graphics stuff at the time
[04:56:16] <erickt> and wanted to build c++ things
[04:56:47] <erickt> but I couldn't really get them to commit to whether or not they'd be comfortable extending ocamlbuild to really work well with non-ocaml languages
[04:56:55] <erickt> not unreasonable on their behalf
[04:57:24] <erickt> but made me notice that the rest of the development wasn't happening publically
[04:57:46] <erickt> so it chilled me to trying to get more involved with the core project
[04:58:35] * erickt is jealous of all those people on #rust-gamedev. I miss drawing things on the screen
[04:58:50] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[04:58:53] <erickt> but pratically speaking my skillset has completely diverged from that space
[04:59:42] <aatch> I *want* to get into that kind of thing, but every time I try I get distracted thinking about programming languages.
[04:59:57] <nrc> bstrie: we are doing one fast-forward (probably Friday) and then just cherry-picking
[05:00:05] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Connection closed)
[05:00:52] <erickt> aatch: hehe, that's what sent me down this path! I wanted to use felix because I liked ocaml but I wanted to use threads
[05:00:56] *** cmr changes topic to '4 weeks to 1.0.0 http://blog.rust-lang.org/2015/02/13/Final-1.0-timeline.html | https://botbot.me/mozilla/rust-internals | https://buildbot.rust-lang.org/homu/queue/rust | see also #rustc and #rust-libs'
[05:01:06] <erickt> in my graphic engine
[05:01:12] <erickt> cmr: no way
[05:01:14] *** cmr changes topic to '5 weeks to 1.0.0 http://blog.rust-lang.org/2015/02/13/Final-1.0-timeline.html | https://botbot.me/mozilla/rust-internals | https://buildbot.rust-lang.org/homu/queue/rust | see also #rustc and #rust-libs'
[05:01:17] <erickt> really? just a month?!
[05:01:18] <erickt> oh
[05:01:18] <cmr> stupid months
[05:01:21] <erickt> haha
[05:01:41] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[05:01:54] <erickt> cmr: it'll be better when wycats's time RFCs land
[05:02:16] <wycats> :D
[05:02:30] <wycats> Time is so crazy
[05:02:33] <wycats> humans...
[05:03:08] <erickt> wycats: it's amazing how many things humans just muck up
[05:03:09] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: Leaving)
[05:03:10] <aatch> wycats, tell me about it (not really, I already know). I've spent the past two weeks working on Date-related code.
[05:03:47] <aatch> wycats, including handling stuff like "this time of the day, on this day of the year doesn't exist in this timezone"
[05:03:57] <erickt> aatch: along those lines, way back when I wanted to just call out to strftime. I thought it'd be easy to use it to parse time!
[05:04:13] <wycats> aatch: my favorite thing is explaining to people that "add one month" has no actual meaning
[05:04:19] <erickt> I think it took me a week to remotely debug all the stupid inconsistencies across the OSs
[05:04:27] <wycats> the only plausible way to deal with "add one month" is if you also provide an overflow policy
[05:04:33] <wycats> same thing with "add one year"
[05:04:37] <wycats> February 29, 2012 + 1 year
[05:04:39] <wycats> what is the answer?
[05:05:01] <aatch> wycats, my favorite is explaining that "date + 1 month + 1 month + 1 month" != "date + 3 months"
[05:05:34] <erickt> aatch: don't forget the all the leap seconds we add every now and then
[05:05:49] <bstrie> how do datetime libraries even deal with leapseconds
[05:05:50] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[05:06:04] <nrc> aatch: please explain that one
[05:06:21] <erickt> if I recall correctly, pretty much all the OSs are dependent on literally one guy who's been maintaining the datetime database
[05:06:26] <nrc> my favourite is that given any two date/times in the future you can't tell how much time is between them
[05:06:35] <erickt> bstrie: ^ said database
[05:06:42] <bstrie> erickt: citation needed
[05:06:52] <erickt> hold on, googling
[05:07:23] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[05:07:26] <wycats> bstrie: they don't
[05:07:54] <wycats> aatch: the best is: "date + 1 month - 1 month" != "date"
[05:07:55] <aatch> nrc, oh, so assuming you need a valid date after each operation, "Jan 30 + 1 month" would probably be "Mar 02", then another month is "Apr 02" and then "May 02"
[05:08:05] <wycats> aatch: it depends on the default overflow policy
[05:08:12] <wycats> in Rust, I'm inclined to say you have to provide one
[05:08:31] *** Joins: sav (e@moz-9u3te2.cc)
[05:08:33] <wycats> and there are no overflow policies that satisfy any algebraic properties :P
[05:08:33] <aatch> nrc, whereas "Jan 30" + 3 Months = "Apr 30"
[05:08:47] <wycats> aatch: this arises in billing
[05:08:50] <wycats> if you bill "once a month"
[05:08:55] <wycats> and the user signs up on "January 1"
[05:08:58] *** Joins: annodomini (lambda@moz-qgii5v.ma.comcast.net)
[05:08:59] <wycats> "January 31"
[05:09:00] <nrc> aatch: ah I see
[05:09:02] <wycats> when do you bill next?
[05:09:17] <aatch> wycats, oh, you mean like where I work does?
[05:09:23] <wycats> aatch: ;)
[05:09:39] <wycats> the only plausible answers are "February 28" or "March 1", both of which are examples of overflow policies
[05:09:49] <erickt> bstrie: this has some hints of the story: https://en.wikipedia.org/wiki/Tz_database#History
[05:10:56] <aatch> wycats, I've found that a decent policy for dates is to allow for invalid dates as intermediate values, but require valid dates when it matters.
[05:10:56] <erickt> bstrie: http://www.theregister.co.uk/2011/10/07/unix_time_zone_database_destroyed/
[05:12:19] <aatch> wycats, which would have the advantage of allowing an overflow policy to be provided when calling a method to do so.
[05:12:52] <bstrie> erickt: fascinating
[05:12:52] <aatch> wycats, also means that people can do stuff like add months one at a time and get the answer they were expecting.
[05:13:19] <erickt> we should break new ground, and only use star-trek style stardates for our datetimes
[05:15:01] <wycats> erickt: :shipit:
[05:15:11] <bstrie> erickt: would have made a good april fools RFC
[05:15:21] <wycats> aatch: that's an interesting idea
[05:15:26] <wycats> but how do you know "when it matters"
[05:15:28] <erickt> bstrie: hehe
[05:15:34] <wycats> it seems like you need an "unwrap"
[05:15:47] <wycats> basically an algebra on a special kind of DateResult
[05:15:49] <wycats> that works on Errs
[05:16:02] <wycats> so Feb 30, 2015 is an Err
[05:16:05] <wycats> but you can add a month to it
[05:16:09] <wycats> and get Mar 30, 2015
[05:16:10] <wycats> which is Ok
[05:19:01] *** Joins: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com)
[05:19:21] <aatch> wycats, it might only be realistic for my usecase. What I have is a different representation of a date/time to the provided one that's better for our workload.
[05:19:40] <wycats> say more
[05:20:18] <aatch> wycats, but I didn't duplicate much functionality, so I overflow invalid dates when forwarding to the built-in DateTime methods.
[05:20:41] <wycats> interesting
[05:20:57] <wycats> I agree that this is also a plausible strategy :)
[05:22:33] *** Quits: summerlight_ (summerlight@moz-99k.2mj.130.121.IP) (Connection closed)
[05:22:39] <aatch> wycats, I guess "where needed" is when you want the actual date/time, either to display or compare or something similar.
[05:22:45] <wycats> yeah
[05:22:50] <wycats> the question is how you detect the boundary
[05:22:58] <wycats> an unwrap is ok
[05:23:26] *** Joins: summerlight (summerlight@moz-99k.2mj.130.121.IP)
[05:24:37] <aatch> wycats, yeah, if you want to make the overflow behaviour configurable, you can't just do what I did and do it behind the scenes.
[05:24:53] *** Quits: annodomini (lambda@moz-qgii5v.ma.comcast.net) (Client exited)
[05:29:27] <aatch> Maybe make the overflow behaviour part of the type? (This is where something like DataTypeKinds would be handy...)
[05:36:32] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Connection closed)
[05:36:53] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[05:37:15] *** Quits: O01eg (o01eg@moz-6mt.6j7.212.176.IP) (Client exited)
[05:40:55] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Ping timeout: 121 seconds)
[05:40:58] *** Quits: Tobba (Tobba@moz-o13d22.bredband.telia.com) (Ping timeout: 121 seconds)
[05:42:31] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Connection closed)
[05:46:04] *** Quits: theme (theme@moz-i3mhhb.asianet.co.th) (Quit: Leaving)
[05:50:58] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[05:51:51] *** Quits: sav (e@moz-9u3te2.cc) (Connection closed)
[05:52:13] *** Joins: sav (e@moz-9u3te2.cc)
[05:53:00] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[05:56:11] <wycats> aatch: yeah
[05:56:29] <wycats> once Duration is accepted (fingers crossed!) I plan to try to flesh out more times and dates
[05:57:32] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Ping timeout: 121 seconds)
[05:57:47] *** Joins: kushal (kdas@moz-7op.go6.171.66.IP)
[05:57:56] *** Quits: kushal (kdas@moz-7op.go6.171.66.IP) (Connection closed)
[06:01:30] <richo> I've a bikeshed: I'm working on deterministic builds, but the solution I'm working on right now will only work on linux (and maybe windows) for the foreseeable future
[06:02:04] <richo> I'm planning to hide this behind ./configure --reproducable or --deterministic or something, but should this fail at configure time, or rustc time if you're trying to build deterministically in a place that it won't work
[06:02:07] <richo> (or both?)
[06:04:11] *** Quits: unwound (bkoropoff@moz-kthi5c.wa.comcast.net) (Quit: Ex-Chat)
[06:06:47] *** Quits: sav (e@moz-9u3te2.cc) (Ping timeout: 121 seconds)
[06:08:36] *** Joins: sav (e@moz-9u3te2.cc)
[06:12:00] *** Quits: sav (e@moz-9u3te2.cc) (Connection closed)
[06:12:06] *** Joins: sav (e@moz-9u3te2.cc)
[06:12:28] *** Joins: James (quassel@moz-olnmts.range86-163.btcentralplus.com)
[06:13:04] *** Joins: topolinux (paolo@moz-cl3.9up.77.151.IP)
[06:13:11] *** Quits: LinuxBunny (Retep998@moz-r1n9v0.east.verizon.net) (Ping timeout: 121 seconds)
[06:13:46] *** Joins: LinuxBunny (Retep998@moz-r1n9v0.east.verizon.net)
[06:19:49] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[06:19:53] <bstrie> aturon: mulling over the new "you may not rely on destructors to enforce memory safety" rule, it's starting to feel like it completely undermines RAII as a feature
[06:20:40] <bstrie> aturon: not in any concrete sense, just mentally... like now I'm wary of destructors to the point of not really wanting to use them
[06:25:11] *** Joins: canhtak (jeremy@moz-kcs.u0t.149.5.IP)
[06:25:48] *** Quits: bdero (bran@moz-lbs.91h.47.73.IP) (Ping timeout: 121 seconds)
[06:28:37] *** Quits: sav (e@moz-9u3te2.cc) (Ping timeout: 121 seconds)
[06:28:38] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Connection closed)
[06:29:21] <Eridius> bstrie: it seems like it's fine as long as the RAII value actually enforces the safety itself (e.g. a mutex guard doesn't unlock until it's dropped, so prolonging its lifetime is fine). It's just when the RAII is a proxy that represents "the stack" that it becomes a problem
[06:30:07] *** Joins: sav (e@moz-9u3te2.cc)
[06:30:39] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[06:30:44] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[06:31:06] <wycats> bstrie: that was also my initial instinct
[06:31:32] <wycats> me to aturon privately earlier today: 12:02 AM <wycats> It's kind of a knock on raii
[06:34:43] *** Joins: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk)
[06:36:33] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[06:37:59] *** Quits: acharles (acharles@moz-ulbdcn.ca.comcast.net) (Client exited)
[06:41:31] <reem> I have similar feelings
[06:41:44] <reem> there’s a reason we marked mem::forget unsafe at some distant point in the past
[06:42:43] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[06:46:01] *** Joins: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP)
[06:46:04] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[06:47:09] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[06:48:08] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Connection closed)
[06:48:23] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Connection closed)
[06:50:05] *** Joins: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com)
[06:50:58] *** Quits: James (quassel@moz-olnmts.range86-163.btcentralplus.com) (Ping timeout: 121 seconds)
[06:55:44] *** Joins: p1start (p1start@moz-nftjhe.org)
[06:55:49] *** Joins: eibwen (eibwen@moz-99ev72.dip0.t-ipconnect.de)
[06:56:19] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[06:59:23] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[06:59:25] *** Joins: Tobba|Craptop (Tobba@moz-1hh.7ki.21.217.IP)
[07:00:04] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[07:00:22] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[07:01:21] *** Joins: laumann (thomas@moz-3v9.hq0.225.130.IP)
[07:02:24] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[07:03:18] <acrichto> bstrie: there's a /reverse_dependencies route on crates.io which should fit the bill
[07:03:32] *** Joins: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP)
[07:03:38] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[07:03:39] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[07:03:48] <zwarich> bstrie: move-all-the-things + destructors + unwinding is a recipe for discomfort
[07:06:50] <zwarich> bstrie: in theory you could model actually borrowing a piece of the stack frame
[07:07:37] *** Quits: swgillespie (swgillespie@moz-rn1.vmq.232.104.IP) (Ping timeout: 121 seconds)
[07:08:30] *** Tobba|Craptop is now known as Tobba|Laptop
[07:11:52] *** Joins: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se)
[07:19:10] *** Joins: squiddy (squiddy@moz-md4.pm3.19.178.IP)
[07:19:38] <kimundi> hm, random observation: with the IntoIterator trait taking care of actually calling a lot of the iterator constructors, it would maybe more consistent to rename iter() into as_iter()
[07:23:14] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[07:24:12] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Client exited)
[07:24:43] *** Quits: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk) (Ping timeout: 121 seconds)
[07:25:04] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[07:26:37] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[07:29:38] *** Quits: sav (e@moz-9u3te2.cc) (Ping timeout: 121 seconds)
[07:33:11] *** Joins: sav (e@moz-9u3te2.cc)
[07:34:06] <Mutabah> kimundi: Not really...
[07:41:06] *** Joins: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP)
[07:41:20] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[07:45:03] <doener_> acrichto: regarding the suggested test for gh24472, are you thinking of a test to emit LLVM IR and e.g. grep for the "align" option?
[07:45:03] <[o__o]> Emit correct alignment information for loads/store of small aggregates: https://github.com/rust-lang/rust/pull/24472
[07:45:30] <acrichto> doener_: oh I was thinking just adding the C test case
[07:45:51] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Ping timeout: 121 seconds)
[07:46:09] <doener_> acrichto: hm? I'm not super familiar with the testing infrastructure
[07:46:30] <bstrie> Eridius wycats reem zwarich: note that the Leak proposal would soothe my specific fears here, but it seemed to me like others think it's not worth the complexity
[07:46:45] *** Quits: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com) (Ping timeout: 121 seconds)
[07:46:49] *** Joins: imperio (Mibbit@moz-opqtbe.abo.bbox.fr)
[07:47:19] <acrichto> doener_: oh does this not reproduce with a small C test case?
[07:47:29] <acrichto> doener_: e.g. is ther e a small C example which causes a fault today?
[07:47:55] <bstrie> and of course Leak doesn't necessarily mean that RAII is safe to rely on again, but it would indicate that the language intends to prioritize the ability to do whatever necessary to make such reliance possible
[07:51:03] *** Joins: aepsil0n (eduard@moz-8h7njb.hsi8.kabel-badenwuerttemberg.de)
[07:51:50] <doener_> acrichto: maybe there is some misunderstanding here. There is no C code involved in the failure. Just plain rust code, see gh23431 for an example. We just didn't see the problem before because x86 doesn't care as much about misaligned loads/stores. The ARMv5 that exposed the bug is quite "interesting", trying to load 4 bytes from an address that is not 4 byte aligned ignores the lower bits of the a
[07:51:50] <[o__o]> Incorrectly generated code for struct alignments: https://github.com/rust-lang/rust/issues/23431
[07:51:56] <doener_> ddress for the load, and then does a rotation of the loaded bytes depending on the lower bits
[07:52:32] *** Quits: sav (e@moz-9u3te2.cc) (Ping timeout: 121 seconds)
[07:52:45] <acrichto> doener_: hm ok, I think I'm thinking of some other bug
[07:52:50] <acrichto> doener_: never mind then!
[07:54:04] *** Joins: munksgaard (munksgaard@moz-1f0.hq0.225.130.IP)
[07:54:30] *** Joins: larhat (Adium@moz-8v4.af0.232.213.IP)
[07:54:43] *** Joins: sav (e@moz-9u3te2.cc)
[07:57:01] <zwarich> bstrie: I'm not sure I believe in any solution without a soundness proof at this point
[07:57:03] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[07:57:41] *** Quits: sav (e@moz-9u3te2.cc) (Connection closed)
[07:57:46] *** Joins: tmh_ (e@moz-9u3te2.cc)
[07:57:53] <zwarich> but part of that is that I no longer have perfect recall of all the opt-in traits now :P
[07:59:04] <reem> Leak could do it, since it’s basically just a way to say “you have to run my destructor within my lifetime or memory unsafety”
[07:59:55] *** Quits: tmh_ (e@moz-9u3te2.cc) (Connection closed)
[08:00:44] <zwarich> reem: that's the property you want to hold, but I'm not sure the chosen static mechanism will enforce it
[08:00:48] *** Joins: sav (e@moz-9u3te2.cc)
[08:01:09] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[08:01:21] *** Joins: CaseyLeask (Mibbit@moz-v0ns05.tpgi.com.au)
[08:03:03] <reem> Worse, we’d have to land the entire thing irrevocably in like… 5 weeks? It includes backwards incompatible changes to Rc, at a bare minimum. Perhaps there’s some combination of ?Sized-like shenanigans that could make it work backwards compatibly, but honestly yuck.
[08:04:14] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[08:05:38] *** Joins: pczarn (piotr@moz-9un7t9.izacom.pl)
[08:06:39] <zwarich> reem: my model of what unsafe code 'means' is also in flux right now
[08:06:44] <bstrie> reem: I don't know that it would be backward-incompatible. it would break unsound code
[08:06:50] <nrc> step 1: you ahve to find a better name. If I have to explain to someone why every type in Rust "implements Leak by default" I will be very unhappy
[08:06:56] <bstrie> haha
[08:07:07] <reem> bstrie: Adding a bound to Rc breaks fn<T>(x: T) -> Rc<T> { … }, no matter what the bound.
[08:07:09] *** Quits: sav (e@moz-9u3te2.cc) (Ping timeout: 121 seconds)
[08:07:29] <nrc> "no no no! Wait! Where are you going? It's not like it sounds...."
[08:07:33] <bstrie> reem: doing Sized-shenanigans is necessary anyway, aiui
[08:07:44] <reem> …why?
[08:07:45] <huon> I'm not sure Leak actually solves the underlying problem since there's quite a few ways to cancel destructors (basically, I suspect any time the user has ownership of the value with the destructor one cannot rely on the destructor running no matter how many Leak shenanigans we introduce)
[08:08:01] *** Joins: lambdaburrito (Mibbit@moz-fm3.hl2.118.94.IP)
[08:08:14] <reem> There’s the additional ‘static distinction - this whole issue only applies to not running destructors of non-‘static types.
[08:08:56] <reem> There’s countless ways to “leak” ‘static types, but I don’t really count those as leaks, since ‘static already means that you can drop/use it any time in the future.
[08:08:59] <lambdaburrito> morning, #[cfg(feature = "nightly")] seems broken.... not sure if it's not the right predicate or it's just broken
[08:09:07] <huon> I believe destructors can also be forgotten by deadlocking threads with channels between them
[08:09:12] <huon> lambdaburrito: I don't think that exists
[08:09:20] <reem> huon: Yup, but channel requires ‘static
[08:09:22] <reem> lambdaburrito: hyper?
[08:09:24] <huon> reem: no
[08:09:31] <lambdaburrito> yeah it's been used in hyper and is broken downstream
[08:09:44] <lambdaburrito> reem: yup and anything that uses it
[08:09:46] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[08:09:46] <reem> lambdaburrito: you need to active the nightly feature if you’re on a nightly right now
[08:10:01] <reem> lambdaburrito: yes, it’s a PITA, everything “just works” if you use beta though.
[08:10:04] <bstrie> huon: but isn't this all exactly what Leak means anyway, that if you forget the destructor then things are still okey-dokey
[08:10:16] <bstrie> huon: regardless of how forgetting the destructor is achieved
[08:10:32] <huon> bstrie: right, but I don't think we can actually impose Leak requirements everywhere they need to be
[08:10:37] <bstrie> hm
[08:10:54] <bstrie> so who wants to propose the RAII reform to remove RAII? :)
[08:10:56] <huon> https://github.com/rust-lang/rust/issues/24292#issuecomment-93505374
[08:11:21] <lambdaburrito> thanks jonathan (it's james btw), how do you "activate the nightly feature"
[08:11:32] <bstrie> reading
[08:12:34] <reem> lambdaburrito: Oh hey! In your cargo.toml, add a features = [“nightly”] under hyper’s dependency section.
[08:12:45] <richo> oh god, I just saw how fmt_macros and fmt interact with flags :<
[08:12:51] <reem> I just did it to one crate, let me push and share a link
[08:13:12] <lambdaburrito> reem: thx! i'll give it a go
[08:13:47] <reem> here’s a Cargo.toml which has it set up for nightly use https://gist.github.com/anonymous/d26600bff255c535b6b7
[08:14:06] <reem> you can also have a [dependencies.hyper] section and just set features = .. under it
[08:15:21] <richo> Is there some blessed way to share implementation details between crates in rustc without making them user visible? A fake feature flag seems like it'll still be visible, albeit not actually callable
[08:17:21] *** Quits: lambdaburrito (Mibbit@moz-fm3.hl2.118.94.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[08:18:03] <bstrie> what if we just require all destructors to run a cycle collector on all data they operate upon
[08:18:55] <bstrie> "the revolutionary way in which rust achieved memory safety: garbage collection"
[08:19:49] <bstrie> huon: okay, I'm sold. are we reasonably certain that thread::scoped was the only thing in the stdlib using Drop to enforce memory safety?
[08:20:35] <bluss> however, there are things in the pipeline that would like to use the same mechanism (drain-range iterators)
[08:20:51] <bstrie> Gankro: sorry to hear about drain_range :(
[08:21:09] <huon> we can still do this stuff, but we just can't give the user control of the RAII object
[08:21:48] <huon> meaning we'll use closure-based APIs that expose only &mut's
[08:22:20] <bstrie> seems like there's a more general solution in there screaming to get out, but I'm happy as long as it works
[08:23:11] <cmr> huon: one thing to be cognizant of when reviewing such an API is whether mem::replace works in undesirable ways (I suspect that the lifetimes would not work out in general)
[08:23:58] <huon> cmr: good point; I suspect we can set-up the lifetimes to explicitly not work
[08:24:39] <cmr> (And, of course, the RAII object should not be constructable so that *foo = bar will be impossible to write)
[08:25:20] *** Quits: CaseyLeask (Mibbit@moz-v0ns05.tpgi.com.au) (Quit: http://www.mibbit.com ajax IRC Client)
[08:25:46] <zwarich> bstrie: that solution is actual linearity? :P
[08:26:33] <bstrie> zwarich: like I said, go ahead and file the rfc to remove RAII :P
[08:26:46] <bstrie> you academics and your insufferable linearity
[08:27:46] *** Joins: zxq9 (ceverett@moz-qsm369.mesh.ad.jp)
[08:29:26] <zwarich> bstrie: I can't really make suggestions on what Rust should do, but if I ever make a language that tracks resources I'm sticking to the insufferable ideas of academia :P
[08:29:47] <zwarich> it seems like there are too many spike-filled pits when you get fancy
[08:29:56] <bstrie> what has academia ever done for us
[08:30:30] <zwarich> bstrie: http://en.wikipedia.org/wiki/Carleson's_theorem
[08:32:42] <bstrie> what will we do when we have so many theorems that last names start colliding
[08:32:49] <bstrie> is there a Smith's theorem? are there dozens?
[08:33:06] <cmr> We don't need to want to see what will happen.
[08:33:09] <cmr> Euler's Lemma
[08:33:18] <cmr> Which one? The world will never know.
[08:35:28] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[08:39:54] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[08:40:00] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Ping timeout: 121 seconds)
[08:43:22] *** Quits: canhtak (jeremy@moz-kcs.u0t.149.5.IP) (Ping timeout: 121 seconds)
[08:47:21] <ChrisMorgan> Ooh, cool: I found an ICE. Implement Fn<(i32,), Output = &'static str> on `struct Bar;` and write `Bar(32)` and “adt::represent_type called on non-ADT type: &'static str”. Haven’t found an ICE for *ages*.
[08:47:40] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Connection closed)
[08:48:12] <bstrie> ChrisMorgan: can you implement Fn in the stable release?
[08:48:54] <ChrisMorgan> bstrie: no, it takes feature(unboxed_closures) to define an extern "rust-call" fn.
[08:49:35] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[08:50:04] *** Joins: dinfuehr_ (dinfuehr@moz-b760b5.highway.telekom.at)
[08:50:04] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Connection closed)
[08:51:27] *** Joins: mgottschlag (quassel@moz-5uni2l.h71g.nb65.1398.2a00.IP)
[08:54:43] <munksgaard> Is there any way to inspect attributes of items in foreign crates? Normally I'd use tcx.def_map to get the defid of my item, and the tcx.map.attrs to get at the actual attributes, but the def_map doesn't seem to have entries for items in foreign crates. Is it simply impossible?
[08:59:15] *** Joins: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP)
[08:59:16] *** ChanServ sets mode: +o pnkfelix
[09:00:27] <kimundi> munksgaard: well, you don't have access to the actual source/AST of an external crate, so yeah...
[09:00:46] <munksgaard> kimundi: That's what I thought :(
[09:02:06] <cmr> I think we store attributes in metdata.
[09:04:30] <munksgaard> cmr: How would I go about accessing those?
[09:04:49] *** Joins: canhtak (jeremy@moz-kcs.u0t.149.5.IP)
[09:07:04] <cmr> munksgaard: csearch::get_item_attrs
[09:20:42] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[09:29:27] *** Quits: mgottschlag (quassel@moz-5uni2l.h71g.nb65.1398.2a00.IP) (Ping timeout: 121 seconds)
[09:29:40] *** Joins: Rym (y@moz-4vn.8i0.144.109.IP)
[09:30:52] *** Quits: Rym (y@moz-4vn.8i0.144.109.IP) (Connection closed)
[09:36:10] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[09:36:21] *** Joins: Guest63 (textual@moz-qfs.570.70.83.IP)
[09:36:45] *** Quits: Guest63 (textual@moz-qfs.570.70.83.IP) (Quit: Textual IRC Client: www.textualapp.com)
[09:40:58] *** Joins: gleb (gleb@moz-3u1drv.rusanovka-net.kiev.ua)
[09:43:17] *** kimundi is now known as zz_kimundi
[09:44:10] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Quit: ChatZilla 0.9.91.1 [Firefox 37.0.1/20150402191859])
[09:51:10] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[09:52:01] *** Joins: Rym (y@moz-uso.r81.55.31.IP)
[10:00:23] *** Quits: Rym (y@moz-uso.r81.55.31.IP) (Connection closed)
[10:00:51] *** Joins: Rym (y@moz-uso.r81.55.31.IP)
[10:07:49] *** Quits: seanmonstar (seanmonstar@moz-jd3i0j.fkdv.ulf6.3c01.2600.IP) (Ping timeout: 121 seconds)
[10:08:38] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Connection closed)
[10:08:41] *** Quits: jld (jld@moz-p4d3de.fkdv.ulf6.3c01.2600.IP) (Ping timeout: 121 seconds)
[10:09:04] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[10:09:24] *** Joins: jld (jld@moz-onnk26.xlerb.net)
[10:10:36] *** Joins: seanmonstar (seanmonstar@moz-jd3i0j.fkdv.ulf6.3c01.2600.IP)
[10:14:46] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Connection closed)
[10:14:47] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[10:17:14] *** Quits: Tobba|Laptop (Tobba@moz-1hh.7ki.21.217.IP) (Ping timeout: 121 seconds)
[10:18:26] *** Quits: canhtak (jeremy@moz-kcs.u0t.149.5.IP) (Client exited)
[10:26:09] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[10:39:45] *** Quits: pczarn (piotr@moz-9un7t9.izacom.pl) (Ping timeout: 121 seconds)
[10:40:22] *** Quits: Rym (y@moz-uso.r81.55.31.IP) (Connection closed)
[10:40:47] *** Joins: Rym (y@moz-uso.r81.55.31.IP)
[10:41:05] *** Joins: canhtak (jeremy@moz-kcs.u0t.149.5.IP)
[10:42:42] *** Quits: Rym (y@moz-uso.r81.55.31.IP) (Connection closed)
[10:43:11] *** Joins: Rym (y@moz-uso.r81.55.31.IP)
[10:51:46] *** Joins: marsel (user@moz-j1l.3vh.180.94.IP)
[10:54:34] *** Joins: mgottschlag (quassel@moz-5uni2l.h71g.nb65.1398.2a00.IP)
[10:55:04] *** zz_kimundi is now known as kimundi
[10:59:04] *** Joins: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com)
[11:00:42] *** Quits: canhtak (jeremy@moz-kcs.u0t.149.5.IP) (Client exited)
[11:01:15] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Connection closed)
[11:01:56] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[11:04:04] *** Quits: mgottschlag (quassel@moz-5uni2l.h71g.nb65.1398.2a00.IP) (Ping timeout: 121 seconds)
[11:06:36] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[11:10:22] *** Joins: mgottschlag (quassel@moz-i55fa5.qiv1.bbcb.1398.2a00.IP)
[11:10:33] *** Joins: Diggsey (diggsey@moz-laps0j.dsl.pipex.com)
[11:12:05] *** Joins: ytain (ytain@moz-bps1td.dsl.teksavvy.com)
[11:18:56] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Connection closed)
[11:18:57] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[11:21:46] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Quit: )
[11:22:45] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[11:24:48] *** Quits: Diggsey (diggsey@moz-laps0j.dsl.pipex.com) (Quit: Nettalk6 - www.ntalk.de)
[11:24:58] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[11:24:59] *** ChanServ sets mode: +o nrc
[11:25:39] *** Joins: CaseyLeask (Mibbit@moz-v0ns05.tpgi.com.au)
[11:26:00] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[11:27:29] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[11:29:22] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[11:29:28] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[11:41:11] *** Joins: mib_7lj5s6 (Mibbit@moz-juv.9o3.252.72.IP)
[11:43:06] *** Quits: CaseyLeask (Mibbit@moz-v0ns05.tpgi.com.au) (Quit: http://www.mibbit.com ajax IRC Client)
[11:47:53] *** Quits: mib_7lj5s6 (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:48:23] *** Quits: Kxepal (Miranda@moz-vsh5q9.pppoe.mtu-net.ru) (Ping timeout: 121 seconds)
[11:50:44] *** Joins: Kxepal (Miranda@moz-b1q4s0.pppoe.mtu-net.ru)
[11:51:32] *** Joins: mib_ctnbmf (Mibbit@moz-t3g.hlg.30.193.IP)
[11:51:35] *** Quits: mib_ctnbmf (Mibbit@moz-t3g.hlg.30.193.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[11:53:52] *** Joins: z_beeblebrox (ford_prefec@moz-55rvi2.dclient.hispeed.ch)
[11:54:52] *** Quits: z_beeblebrox (ford_prefec@moz-55rvi2.dclient.hispeed.ch) (Quit: Verlassend)
[11:54:56] *** Joins: smodo (ford_prefec@moz-55rvi2.dclient.hispeed.ch)
[11:56:20] *** Quits: smodo (ford_prefec@moz-55rvi2.dclient.hispeed.ch) (Quit: Verlassend)
[11:59:49] *** Joins: eerie_ (eerie@moz-060j2q.red.bezeqint.net)
[11:59:49] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[12:00:03] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[12:02:57] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[12:03:57] *** Quits: Kingsquee (kingsley@moz-qq7ns6.bchsia.telus.net) (Quit: Konversation terminated!)
[12:07:02] *** Quits: ytain (ytain@moz-bps1td.dsl.teksavvy.com) (Connection closed)
[12:07:24] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Ping timeout: 121 seconds)
[12:07:50] *** Joins: ytain (ytain@moz-bps1td.dsl.teksavvy.com)
[12:08:18] *** Joins: bjz (bjz@moz-puppgq.tpgi.com.au)
[12:12:43] *** Quits: ctennis (ctennis@moz-vcpg3c.in.comcast.net) (Quit: Leaving...)
[12:17:53] *** Quits: mgottschlag (quassel@moz-i55fa5.qiv1.bbcb.1398.2a00.IP) (Ping timeout: 121 seconds)
[12:19:13] *** Joins: canhtak (jeremy@moz-kcs.u0t.149.5.IP)
[12:23:22] *** Joins: ctennis (ctennis@moz-93imdn.bltnin.sbcglobal.net)
[12:25:35] *** Joins: mgottschlag (quassel@moz-5uni2l.h71g.nb65.1398.2a00.IP)
[12:26:05] *** Joins: bdero (bran@moz-lbs.91h.47.73.IP)
[12:41:46] *** Quits: eerie_ (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[12:48:19] *** Quits: rprichard (rprichard@moz-imu4l1.en8f.d045.0009.2601.IP) (Connection closed)
[12:50:56] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[12:55:03] *** Quits: untitaker (untitaker@moz-fojcn1.highway.telekom.at) (Ping timeout: 121 seconds)
[12:57:11] *** Joins: untitaker (untitaker@moz-vns1i0.highway.telekom.at)
[12:59:51] *** Joins: eerie_ (eerie@moz-060j2q.red.bezeqint.net)
[13:02:08] *** Quits: canhtak (jeremy@moz-kcs.u0t.149.5.IP) (Client exited)
[13:03:06] <rovar> When did the Rust project begin at Mozilla?
[13:03:07] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Ping timeout: 121 seconds)
[13:03:17] <rovar> (am making a presentation) 
[13:03:44] <rovar> e.g. When was it adopted..
[13:03:48] <LinuxBunny> rovar, All I know is when rust's git repo first started
[13:04:12] <huon> rovar: around 2009-2010, I think
[13:04:18] <huon> you may be interested in http://www.steveklabnik.com/fosdem2015/
[13:04:43] <rovar> yea, I'm looking at that now
[13:04:53] <huon> ah, wikipedia says 2009
[13:04:54] <rovar> he gave that preso at our NYC rust meetup
[13:05:17] <rovar> Right! The giant body of knowledge about the known universe! I forgot to look there!
[13:05:50] *** Joins: canhtak (jeremy@moz-kcs.u0t.149.5.IP)
[13:05:58] <rovar> Cool. 
[13:06:37] <huon> the citation has now died, but according to the wiki history it is https://gist.github.com/huonw/40493df33bbdc908fa96
[13:06:56] <huon> (rust wiki history)
[13:07:02] <huon> (via https://github.com/rust-lang/rust-wiki-backup )
[13:07:28] *** Joins: jdm (jdm@moz-mu9.06r.98.75.IP)
[13:08:18] <rovar> any idea how many people Mozilla employs to work on Rust and Servo? 
[13:08:53] <huon> on Rust... I think 8
[13:09:00] <huon> no idea about servo
[13:09:19] <imperio> they're really 8 people working on rust ?
[13:09:25] <imperio> I thought it was just 3
[13:09:27] <imperio> or 4
[13:10:25] <huon> alex aaron niko felix steve nick brian patrick
[13:11:03] <imperio> huon: not you ? I thought you were from mozilla
[13:11:07] <huon> rovar: #servo might know more about servo :)
[13:11:10] * huon is a volunteer
[13:12:30] <rovar> I vaguely recall hearing Jack say that it was 3 or 4 Rust people on Servo..
[13:13:00] <imperio> I know there is Simon but that's all
[13:13:36] <huon> all the ops/owners of #servo are mozilla employees on servo, I believe
[13:13:45] <huon> (not necessarily full time on servo, don't know the details)
[13:14:32] *** Quits: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net) (Ping timeout: 121 seconds)
[13:25:26] *** Quits: untitaker (untitaker@moz-vns1i0.highway.telekom.at) (Ping timeout: 121 seconds)
[13:29:53] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[13:30:03] <larsberg> rovar: we usually count Servo as 7 full-time dedicated people (matt, jack, me, simon, keegan, glenn, patrick) - patrick is full-time on servo again now. Obviously, there are some others like josh who contribute a ton but are actually part of gecko
[13:31:15] <rovar> larsberg, thanks!
[13:31:29] <larsberg> rovar: np
[13:32:53] *** Quits: eerie_ (eerie@moz-060j2q.red.bezeqint.net) (Ping timeout: 121 seconds)
[13:34:30] *** kimundi is now known as zz_kimundi
[13:35:05] <rovar> re: The RFC's.  Using the numbering scheme that is present, am I to assume that the total number of submitted RFCs is > 1000, but the ones remaining in the repo were the accepted ones?
[13:36:38] *** Quits: dinfuehr_ (dinfuehr@moz-b760b5.highway.telekom.at) (Connection closed)
[13:36:54] <huon> the numbers in the file name correspond to the PR number assigned by github
[13:37:13] <huon> and yes, the commits ones are the accepted ones
[13:37:46] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[13:38:08] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[13:38:33] <pnkfelix> huon: hey you're local expert on `#[allow_internal_unstable]`, right:
[13:39:09] <pnkfelix> huon: I am trying to deal with a thorny problem
[13:39:17] <pnkfelix> huon: and thought maybe I could bounce some ideas off you
[13:41:11] *** Joins: erickt (erickt@moz-njt.vqi.14.76.IP)
[13:42:06] *** Quits: mgottschlag (quassel@moz-5uni2l.h71g.nb65.1398.2a00.IP) (Ping timeout: 121 seconds)
[13:42:10] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Ping timeout: 121 seconds)
[13:42:52] <huon> pnkfelix: hey
[13:42:53] <huon> pnkfelix: sure
[13:43:34] <pnkfelix> huon: so, here's the problem
[13:43:44] <pnkfelix> huon: I'm trying to resolve gh22932
[13:43:45] <[o__o]> panic!("{}") shouldn't compile: https://github.com/rust-lang/rust/issues/22932
[13:44:20] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[13:44:35] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Connection closed)
[13:44:50] <pnkfelix> by making `panic!(expr)` expand into `begin_unwind( new_macro_ensuring_not_string_literal!(expr), file_lineno_info )`
[13:45:22] <pnkfelix> my problem is that we would prefer for `new_macro_ensuring_not_string_literal!` to be treated as unstable, if possible
[13:46:28] <pnkfelix> I've gone through a couple iterations of ideas for accomplishing this; my latest hairbrained scheme is to have `new_macro_ensuring_not_string_literal!`, when used from outside of `panic!`, include in its expansion a reference to an unstable constant.
[13:47:00] <huon> hm
[13:47:18] <pnkfelix> But, now that I've attempted a `make check`
[13:47:35] <pnkfelix> I've discovered that my scheme is still not quite right
[13:47:58] <huon> I wonder...
[13:48:17] <huon> the problem is associating the expansion of new_macro...! with the panic!, right?
[13:48:23] <pnkfelix> in particular, `panic!(format!("{}", stuff))` ends up passing the `format!(..)` part over to `new_macro_ensuring_not_string_literal!`, and then in the resulting expansion 
[13:48:44] <pnkfelix> (well, what you mention is a problem too, but I hacked around that; I'll explain how in a sec)
[13:48:53] <pnkfelix> the issue I am currently facing
[13:48:59] <pnkfelix> is that when we do the stability check
[13:49:27] <pnkfelix> it thinks that the expansion of `format!(..)` is within `new_macro_ensuring_not_string_literal!`
[13:49:55] <pnkfelix> and so it issues the stability gate error
[13:50:41] <huon> hm, why does it thinking that?
[13:50:45] <huon> that seems like a bug?
[13:51:01] <pnkfelix> huon: that, or I'm doing something wrong in my implementation of new_macro_ensuring_not_string_literal
[13:54:01] <pnkfelix> huon: this is the branch with the work so far: 
[13:54:02] <pnkfelix> https://github.com/pnkfelix/rust/tree/fsk-unary-panic
[13:54:13] * huon looks
[13:54:17] <huon> pnkfelix: I just thought of https://gist.github.com/huonw/1f5eb45dde1cf5c80e02
[13:55:05] *** Joins: scialex (scialex@moz-j5mi8i.cs.brown.edu)
[13:55:33] <pnkfelix> huon: hmm, the `...` in `...::Hack` is just shorthand for some glboal path, like `core::fmt::panic_hack::Hack` ?
[13:55:42] <huon> yeah
[13:55:49] <pnkfelix> huon: that's better than my approach, at least
[13:56:01] <huon> (I'm unsure if it will actually work.)
[13:56:20] <pnkfelix> huon: (i was passing in a string for the name of the calling function, and then special casing the string "unary `panic!`" as a special case that does not emit the unstable constant.
[13:56:44] <huon> from a glance at your implementation it seems fine
[13:56:48] *** Joins: ineol (ineol@moz-akt.oi0.185.94.IP)
[13:56:56] <huon> (re the "seems like a bug" above)
[13:57:12] <huon> pnkfelix: oh
[13:57:36] <pnkfelix> huon: so under the scheme you suggest in that gist, `ensure_not_fmt_string_literal!` would also be tagged as `#![allow_internal_unstable]`, right?
[13:57:59] <huon> yeah
[13:58:03] <pnkfelix> overall I actually think I like your approach
[13:58:17] <pnkfelix> seems much more self-documenting and less magical than my nightmare here
[13:58:27] <huon> it's still a huge hack :(
[13:58:34] <huon> I'm kinda nervous about how we're so reliant on spans for this aspect of stability
[13:58:38] <pnkfelix> huon: yeah but self-contained
[13:58:55] <huon> but I suppose it is better than having no effort to solve the stability here
[13:59:00] <pnkfelix> huon: Yeah, relying on spans for anything static-analysis-related is a bug waiting to happen, right now
[13:59:13] <pnkfelix> huon: since to my knowledge our span computations are still flaky
[13:59:28] <huon> pnkfelix: yeah, that's been my impression too
[13:59:39] <pnkfelix> huon: BTW, I haven't looked ... how does the span-based stability checking interpret DUMMY_SP ?
[14:00:01] <pnkfelix> huon: I assume its either a blanket accept or a blanket reject
[14:00:05] *** Quits: summerlight (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[14:00:38] <huon> pnkfelix: (my intention for allow_internal_unstable was for it be a temporary thing to allow us to release 1.0, 1.1 without undue stabilisations)
[14:00:41] <huon> pnkfelix: I...
[14:00:53] <huon> think it'll consider that as a reject
[14:01:06] <pnkfelix> okay just curious.
[14:01:10] <huon> as in, a DUMMY_SP is not allowed to be unstable
[14:01:17] <pnkfelix> sounds good
[14:01:17] <huon> not really sure.
[14:01:26] <huon> there's no special handling of it
[14:01:30] <huon> afaik
[14:03:28] *** Quits: erickt (erickt@moz-njt.vqi.14.76.IP) (Ping timeout: 121 seconds)
[14:04:47] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[14:06:24] *** Quits: aepsil0n (eduard@moz-8h7njb.hsi8.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[14:07:55] *** Joins: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net)
[14:19:11] *** Joins: larhat1 (Adium@moz-8v4.af0.232.213.IP)
[14:19:31] *** Quits: larhat (Adium@moz-8v4.af0.232.213.IP) (Ping timeout: 121 seconds)
[14:21:29] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[14:21:50] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[14:22:07] *** Quits: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net) (Quit: Leaving)
[14:22:45] *** Joins: arielb1 (Mibbit@moz-8e7ufn.tau.ac.il)
[14:22:58] <arielb1> pnkfelix: ping
[14:23:04] <pnkfelix> arielb1: pong
[14:23:13] *** Quits: larhat1 (Adium@moz-8v4.af0.232.213.IP) (Ping timeout: 121 seconds)
[14:23:14] <arielb1> could you r? gh24475?
[14:23:14] <[o__o]> Fix #24363: https://github.com/rust-lang/rust/pull/24475
[14:23:27] *** Joins: larhat (Adium@moz-8v4.af0.232.213.IP)
[14:24:14] *** Quits: Rym (y@moz-uso.r81.55.31.IP) (Ping timeout: 121 seconds)
[14:24:18] *** Joins: pczarn (piotr@moz-9un7t9.izacom.pl)
[14:25:52] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Ping timeout: 121 seconds)
[14:25:57] <pnkfelix> arielb1: by "clean visit_expr", do you mean its just code-cleanup (i.e. a pure refactoring) ?
[14:28:54] *** Joins: Rym (y@moz-uso.r81.55.31.IP)
[14:28:59] <arielb1> pnkfelix: sure
[14:33:08] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[14:37:29] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Ping timeout: 121 seconds)
[14:37:45] <steveklabnik> pnkfelix: i'm looking at some old issues, i think https://github.com/rust-lang/rust/issues/15435 is solved by extend now, what do you think?
[14:38:08] <pnkfelix> steveklabnik: probably
[14:38:26] <pnkfelix> steveklabnik: I don't know how efficiently we do it today
[14:38:35] <steveklabnik> oh, i guess extend is still at the end
[14:38:41] <steveklabnik> it does a reserve and then push in a loop
[14:38:59] <steveklabnik> so that's not quite the same thing
[14:39:05] <pnkfelix> steveklabnik: yeah, okay, right, not the same. :)
[14:39:17] <pnkfelix> steveklabnik: BTW, do you think you'll have time to make that script we talked about on Tuesday?
[14:39:22] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[14:39:25] <pnkfelix> steveklabnik: I know I was supposed to ping you about it; I forgot
[14:39:43] *** Joins: andrewseidl (andrewseidl@moz-7e86q0.aas.io)
[14:39:46] *** Quits: Rym (y@moz-uso.r81.55.31.IP) (Connection closed)
[14:39:59] <steveklabnik> oh yeah, just give me a gist with what you want it to do, can knock that out
[14:40:20] *** Joins: Rym (y@moz-uso.r81.55.31.IP)
[14:45:00] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[14:45:05] *** Joins: binkarus (textual@moz-014tff.ca.comcast.net)
[14:49:03] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[14:54:10] <pnkfelix> steveklabnik: BTW feel free to move gh15435 to an issue on the RFC repo.  :)
[14:54:10] <[o__o]> Vec could use `insert_all` and `insert_all_move` methods: https://github.com/rust-lang/rust/issues/15435
[14:54:28] <steveklabnik> cool
[14:59:58] *** Quits: jdm (jdm@moz-mu9.06r.98.75.IP) (Quit: )
[15:00:21] *** Quits: ineol (ineol@moz-akt.oi0.185.94.IP) (Client exited)
[15:03:55] *** Joins: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net)
[15:06:38] *** Quits: munksgaard (munksgaard@moz-1f0.hq0.225.130.IP) (Ping timeout: 121 seconds)
[15:07:07] *** Quits: imperio (Mibbit@moz-opqtbe.abo.bbox.fr) (Quit: http://www.mibbit.com ajax IRC Client)
[15:08:27] *** Quits: awe (awe@moz-vpr.va5.236.104.IP) (Quit: ZNC - http://znc.in)
[15:08:35] <laumann> pnkfelix: I think I managed to fix the trace-macros test
[15:09:11] <laumann> pnkfelix: https://github.com/rust-lang/rust/pull/24430
[15:09:24] *** Joins: eerie_ (eerie@moz-060j2q.red.bezeqint.net)
[15:09:25] <pnkfelix> laumann: do you know why your local test runs were not catching the problem?
[15:09:48] *** Joins: awe (awe@moz-vpr.va5.236.104.IP)
[15:09:55] <pnkfelix> laumann: (its not a rhetorical question; I'm legitimately curious.)
[15:10:00] <laumann> pnkfelix: I suspect because &> behaves differently from bash/sh to zsh
[15:10:14] <pnkfelix> laumann: ugh
[15:10:23] <laumann> pnkfelix: running 'make check-stage1' reproduced the error thuogh
[15:10:31] <laumann> s/thuogh/though/
[15:10:46] <pnkfelix> wait, I thought ... you did run ... `make check-stage1` ...
[15:11:31] <laumann> pnkfelix: I did, but the first time around I klutzed it - running in the wrong branch
[15:11:57] <pnkfelix> oh i see
[15:12:02] * laumann is embarrased
[15:12:08] <pnkfelix> that's okay, it happens
[15:12:16] <pnkfelix> so now it passes?
[15:12:23] <laumann> pnkfelix: ye-
[15:12:27] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Ping timeout: 121 seconds)
[15:12:29] <laumann> s/ye-/yes/
[15:13:29] <laumann> pnkfelix: still wonder how Travis could mark the first two runs as passed (when they shouldn't have worked)
[15:13:46] <pnkfelix> laumann: I don't think Travis runs the rmake tests
[15:14:02] <pnkfelix> laumann: I believe it does a pretty limited amount of testing
[15:14:14] <laumann> pnkfelix: ah ok
[15:14:30] <laumann> pnkfelix: it runs 'make tidy' or ?
[15:14:47] <pnkfelix> laumann: I don't remember offhand, I just know that its not as thorough
[15:16:43] *** Joins: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP)
[15:17:01] *** Joins: redblue (redyellow@moz-55rvi2.dclient.hispeed.ch)
[15:20:52] *** Joins: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net)
[15:22:00] <laumann> pnkfelix: anyway, thanks for the help - gotta go
[15:22:05] *** Joins: SiegeLord (sl@moz-9jtaei.ca.comcast.net)
[15:22:09] <pnkfelix> laumann: thanks for the contribution
[15:23:09] *** zz_kimundi is now known as kimundi
[15:24:37] *** Quits: eerie_ (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[15:25:01] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Ping timeout: 121 seconds)
[15:25:56] *** Joins: jdm (jdm@moz-gosqsi.ckpj.s0pt.0450.2001.IP)
[15:26:18] *** Quits: laumann (thomas@moz-3v9.hq0.225.130.IP) (Ping timeout: 121 seconds)
[15:26:20] <doener_> Luqman: ping
[15:29:06] *** Quits: canhtak (jeremy@moz-kcs.u0t.149.5.IP) (Client exited)
[15:29:49] *** Joins: untitaker (untitaker@moz-0gjtv2.highway.telekom.at)
[15:31:54] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[15:34:00] *** Quits: squiddy (squiddy@moz-md4.pm3.19.178.IP) (A TLS packet with unexpected length was received.)
[15:36:47] *** Joins: munksgaard (munksgaard@moz-478pev.u.parknet.dk)
[15:39:37] *** Joins: eerie_ (eerie@moz-060j2q.red.bezeqint.net)
[15:41:00] *** Joins: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net)
[15:42:57] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Ping timeout: 121 seconds)
[15:43:50] *** Joins: O01eg (o01eg@moz-tpvf1k.5gmo.4n8f.2698.2a02.IP)
[15:43:53] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[15:44:08] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Connection closed)
[15:46:20] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[15:50:23] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[15:51:17] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[15:51:27] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[15:51:27] *** ChanServ sets mode: +o brson
[15:52:05] *** Joins: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de)
[15:55:19] *** Joins: jshs (jshs@moz-fqlr0g.dip0.t-ipconnect.de)
[15:55:52] <frewsxcv> steveklabnik: i commend you and your speedy r+'s
[15:57:16] <steveklabnik> :)
[15:57:23] <steveklabnik> only for small patches
[15:57:28] <steveklabnik> i have one or two bigger ones i need to review TODAY
[16:01:30] *** Quits: Astrum|Lap (Astrum|Lap@moz-skcefh.co.comcast.net) (Client exited)
[16:02:02] *** Joins: canhtak (jeremy@moz-kcs.u0t.149.5.IP)
[16:04:43] *** Quits: canhtak (jeremy@moz-kcs.u0t.149.5.IP) (Client exited)
[16:11:02] <LinuxBunny> acrichto, I updated my stdio RFC a bit
[16:11:09] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[16:15:39] <acrichto> LinuxBunny: looking
[16:16:45] <acrichto> LinuxBunny: hm a breaking change at that level would be quite difficult to land for now
[16:17:00] <acrichto> LinuxBunny: perhaps the *_raw functions could return a Result, but the high-level functions will wrap the sink for you?
[16:18:08] *** Quits: rovar (rovar@moz-m2j7h0.dyn.optonline.net) (Ping timeout: 121 seconds)
[16:24:10] <LinuxBunny> acrichto, perhaps
[16:25:38] *** Quits: SiegeLord (sl@moz-9jtaei.ca.comcast.net) (Quit: It's a joke, it's all a joke.)
[16:29:07] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[16:29:28] *** Quits: eerie_ (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[16:30:25] *** Joins: aepsil0n (eduard@moz-g8ss54.mv2h.pepi.8071.2a02.IP)
[16:31:41] *** Joins: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net)
[16:32:38] <LinuxBunny> acrichto, Okay, I swapped with the alternative in the RFC
[16:32:49] <LinuxBunny> and mentioned the raw thing
[16:35:28] <acrichto> LinuxBunny: typo on stderr => io::empty (I think you mean stdin)
[16:35:51] *** Quits: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net) (Ping timeout: 121 seconds)
[16:36:15] <acrichto> LinuxBunny: other than that lgtm, thanks!
[16:37:48] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[16:39:59] *** Joins: imperio (Mibbit@moz-8otf3a.fbx.proxad.net)
[16:41:42] <LinuxBunny> acrichto, typo fixed
[16:41:51] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[16:45:50] *** Joins: c0170 (c0170@moz-4stj9o.cable.virginm.net)
[16:46:35] *** Joins: rkruppe_ (chatzilla@moz-3nj.rnu.131.95.IP)
[16:47:36] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[16:47:44] *** rkruppe_ is now known as rkruppe
[16:48:53] <brson> pnkfelix: this paper about deficiencies in C++ for games programmers is probably relevant to your interests http://www.reddit.com/r/rust/comments/32tmh9/c_paper_n4456_survey_of_c_problems_for_game/
[16:49:22] <pnkfelix> brson: thanks
[16:49:31] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Quit: leaving)
[16:49:40] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[16:49:40] *** ChanServ sets mode: +o brson
[16:50:17] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[16:51:15] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Quit: leaving)
[16:51:57] *** Joins: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net)
[16:52:59] <steveklabnik> brson: good look, i meant to cross-post that today and forgot :)
[16:53:18] *** Joins: dpc (dpc@moz-t6gr4b.ca.comcast.net)
[16:56:21] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[16:56:21] *** ChanServ sets mode: +o brson
[16:56:43] *** Joins: pcwalton (pcwalton@moz-nh2.o1i.216.216.IP)
[16:56:43] *** ChanServ sets mode: +o pcwalton
[16:57:21] *** Joins: munksgaa1d (munksgaard@moz-urnkl5.u.parknet.dk)
[16:57:33] *** Joins: mjboa (mike@moz-gfdglf.hsi06.unitymediagroup.de)
[17:00:20] *** Quits: munksgaard (munksgaard@moz-478pev.u.parknet.dk) (Ping timeout: 121 seconds)
[17:00:41] <steveklabnik> what exactly is cfg_attr? it looks like it sets an attribute if a config value is set, is that 100% accurate? anything else odd to konw about it?
[17:00:50] <sfackler> that's it
[17:00:56] <steveklabnik> straightforward enough :)
[17:01:07] <sfackler> #[cfg_attr(a, b)] expands to #[b] if a is set as a cfg and nothing otherwise
[17:01:18] <steveklabnik> thought so, but figured i'd double cehck
[17:01:39] <steveklabnik> i did a git grep and that looked accurate
[17:05:17] <Luqman> doener_: pong
[17:05:58] <doener_> Luqman: https://github.com/rust-lang/rust/blob/master/src/librustc_trans/trans/attributes.rs#L198
[17:06:22] <doener_> Luqman: looking at the history for that code, you originally introduced that one, and I'm wondering if that's actually reachable.
[17:06:53] <doener_> Luqman: the pairs should currently go through an out-pointer, so we shouldn't get into th else branch
[17:07:29] <doener_> Luqman: and if it wasn't going through an out-pointer, the dereferenceable attribute would be illegal, wouldn't it?
[17:08:52] <doener_> hm, checks for type_is_sized though. Is it actually a pair then?
[17:11:06] <doener_> Luqman: ah, yeah, that seems to be the case, it's not actually a pair, so the comment was just misleading
[17:11:14] <Luqman> doener_: hmm, i think you're right. if it were returning the pair directly then we couldn't mark that as dereferencable anyways
[17:12:03] <Luqman> right, type_is_sized only lets the thin pointers through
[17:12:11] <doener_> Luqman: checked with some code, seems to be for functions like: fn foo() -> Box<[i32; 8]>
[17:12:51] <doener_> Luqman: thanks!
[17:13:42] <doener_> Luqman: (I'm actually working on a PR to pass/return fat pointers by value, that's why I asked :-) )
[17:14:19] <brson> are we ready to make a new beta?
[17:14:35] *** Quits: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net) (A TLS packet with unexpected length was received.)
[17:14:51] <brson> acrichto: still don't need to update cargo for beta?
[17:15:04] <Luqman> doener_: as in, in 2 registers?
[17:15:24] <acrichto> brson: yeah nothing major's been fixed
[17:15:29] *** Quits: dpc (dpc@moz-t6gr4b.ca.comcast.net) (Ping timeout: 121 seconds)
[17:15:30] <acrichto> brson: but it can't hurt really
[17:18:07] <doener_> Luqman: yes. Trades a single register for a reduction in indirection, less memory accesses and sometimes omission of memcpys and a few more possibilities for TCO
[17:18:57] <nmatsakis> aturon: so I was thinking about guaranteed dtors, I hav a hair-brained kernel of a thought
[17:19:12] <aturon> nmatsakis: ooh, let's hear it
[17:19:14] <nmatsakis> this has come up before (no big surprise)
[17:19:19] *** Quits: scialex (scialex@moz-j5mi8i.cs.brown.edu) (Quit: Leaving)
[17:19:19] <nmatsakis> well, these are two disconnected thoughts
[17:19:36] <nmatsakis> first, there is a need sometimes for values that can't be moved -- typically once a pointer into them has been "observed"
[17:19:43] <doener_> Luqman: I'm going a quick approach first, just passing fat pointers as FCA's, but still treating them as non-immediates otherwise. LLVM translates that to passing the two pointers in two registers.
[17:19:45] <nmatsakis> i.e., because that pointer is inserted into a linked list somewhere or something
[17:19:51] <nmatsakis> this is very similar to borrowing basically
[17:19:55] <nmatsakis> one way to do this today
[17:20:07] <nmatsakis> is basically to do that insertion from a &T
[17:20:14] <nmatsakis> but a lot of times you'd like to return it to your caller
[17:20:16] <nmatsakis> and then you are kind of stuck
[17:20:21] <doener_> Luqman: later I want to actually split them into two arguments in the signature, so we can e.g. apply the nonnull attribute to the pointers
[17:20:33] <nmatsakis> this seems to be very similar to the guaranteed dtor problem, and also to some extent to the thread-local-data problem
[17:20:43] <nmatsakis> i.e., if there were a way to say
[17:20:52] <nmatsakis> I want to return this value into a temporary slot allocated somewhere above me with lifetime 'x
[17:21:06] <nmatsakis> that'd be a lot of the way there :)
[17:21:13] <aturon> nmatsakis: (agreed, i have this same intuition of a "missing" construct along those lines)
[17:21:20] <nmatsakis> one annoying problem is mem::swap, which lets you take things out of an &mut
[17:21:27] <nmatsakis> there are ways around that but
[17:21:48] <nmatsakis> I haven't thought of a great one yet; &uniq would I gues help but I hate the thought of another kind of mutability
[17:22:09] <nmatsakis> anyway, eddyb was also pinging me some idaes about this the other day, which I have to revisit and digest
[17:22:27] <nmatsakis> this is also kind of similar to &uninit
[17:22:35] <nmatsakis> but not quite the same
[17:22:51] <nmatsakis> that is, if you reified this "temporary slot" and passed it in, you might want some kind of "special uninitialized cell"
[17:23:04] <aturon> i see
[17:23:06] <nmatsakis> but you want to ensure that this is a *temporary* slot
[17:23:09] <nmatsakis> in these cases
[17:23:14] <nmatsakis> or at least that the owner can't move out o it
[17:23:25] <aturon> this also feels possibly related to the frequent requests for structs containing both a T and a & pointer into that T
[17:23:35] <nmatsakis> yes, I think there is a relationship
[17:23:51] <nmatsakis> though it's not clear to me that they are best addressed through one mechanism
[17:23:54] <nmatsakis> perhaps one overlapping mechanism
[17:24:06] *** Quits: mgottschlag (quassel@moz-8uvcc8.hsi15.kabel-badenwuerttemberg.de) (Ping timeout: 121 seconds)
[17:24:10] <nmatsakis> er, two overlappingmechanisms
[17:24:43] <doener_> meh, and the stupid backtrace test is failing again because LLVM optimizes differently :-/y
[17:24:45] <aturon> right, so my feeling so far has been that the pain here doesn't yet outweigh the complexity of more pointer distinctions
[17:27:32] <nmatsakis> aturon: so I'd kind of like the allocation of the slot to be invisible
[17:27:54] <nmatsakis> but anyway, this is kind of just high-level noodling now
[17:30:41] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[17:35:29] *** Joins: A205B064 (A205B064@moz-9s9nhk.nap.wideopenwest.com)
[17:35:39] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[17:36:22] *** Joins: hyunsik (hyunsik@moz-3qgjl9.ca.comcast.net)
[17:38:16] *** Quits: munksgaa1d (munksgaard@moz-urnkl5.u.parknet.dk) (Ping timeout: 121 seconds)
[17:38:42] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[17:40:24] *** Joins: erickt (erickt@moz-4hh.6p3.217.74.IP)
[17:42:45] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[17:44:15] *** Joins: reedlepee (Mibbit@moz-juv.9o3.252.72.IP)
[17:44:20] *** Quits: pnkfelix (pnkfelix@moz-6v5.3nd.202.89.IP) (Ping timeout: 121 seconds)
[17:45:11] *** Quits: pcwalton (pcwalton@moz-nh2.o1i.216.216.IP) (Client exited)
[17:46:03] *** Quits: Murarth (Murarth@moz-mpmr8r.phnx.qwest.net) (Quit: I have come here to chew bubblegum and kick ass. And I'm all out of bubblegum.)
[17:46:31] *** Joins: Murarth (Murarth@moz-ljhfm9.dyn.nltelcom.net)
[17:47:00] *** Quits: jevin (jevin@moz-sra.ovp.12.72.IP) (Quit: Textual IRC Client: www.textualapp.com)
[17:47:51] *** Joins: ineol (ineol@moz-akt.oi0.185.94.IP)
[17:48:58] <simukis> arielb1: I think that code would be better of as a link to gist
[17:52:34] <arielb1> simukis: fixed
[17:53:30] *** Quits: jdm (jdm@moz-gosqsi.ckpj.s0pt.0450.2001.IP) (A TLS packet with unexpected length was received.)
[17:53:39] *** Joins: jdm (jdm@moz-i5m.05u.207.66.IP)
[17:55:52] <simukis> arielb1: thanks!
[17:56:47] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Connection closed)
[17:57:05] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[17:57:06] *** ChanServ sets mode: +o brson
[17:57:07] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Quit: leaving)
[17:57:36] *** Quits: arielb1 (Mibbit@moz-8e7ufn.tau.ac.il) (Quit: http://www.mibbit.com ajax IRC Client)
[17:58:09] *** Quits: annodomini (lambda@moz-hceqmj.hfc.comcastbusiness.net) (Client exited)
[18:00:30] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[18:00:31] *** ChanServ sets mode: +o brson
[18:03:01] *** Joins: nrc (nrc@moz-4bhi2i.xtra.co.nz)
[18:03:01] *** ChanServ sets mode: +o nrc
[18:04:01] <brson> nmatsakis nrc: do you have any unlanded patches you want in the beta?
[18:04:13] <brson> i want to start a build soon
[18:04:20] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[18:05:36] <nrc> brson: no
[18:05:51] <nmatsakis> brson: hmm I might want to land https://github.com/rust-lang/rust/pull/24461, but I could also cherry-pick it (and wanted to discuss some aspects of it with aturon now anyhow)
[18:05:57] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[18:07:01] <brson> acrichto: r? https://github.com/rust-lang/rust-packaging/pull/27
[18:07:13] <brson> r? anyone
[18:09:06] <brson> nmatsakis: maybe i'll start a build now and if you can get it landed today we'll rebuild, otherwise cherry-pick next week?
[18:12:12] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Ping timeout: 121 seconds)
[18:16:17] *** Quits: reedlepee (Mibbit@moz-juv.9o3.252.72.IP) (Quit: http://www.mibbit.com ajax IRC Client)
[18:17:05] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[18:17:13] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Connection closed)
[18:17:21] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[18:17:44] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Connection closed)
[18:18:03] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Ping timeout: 121 seconds)
[18:18:34] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[18:18:54] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Connection closed)
[18:19:42] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[18:20:01] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[18:20:02] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[18:20:04] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[18:20:16] *** Quits: ineol (ineol@moz-akt.oi0.185.94.IP) (Client exited)
[18:20:29] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[18:23:08] *** Joins: hirschen (hirschen@moz-9j0dnu.h7ls.rebm.810b.2a02.IP)
[18:25:43] *** Quits: imperio (Mibbit@moz-8otf3a.fbx.proxad.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:26:17] *** Joins: jevin (jevin@moz-sra.ovp.12.72.IP)
[18:27:21] *** Joins: proc (proc@moz-13q4fn.dip0.t-ipconnect.de)
[18:28:19] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[18:28:19] *** ChanServ sets mode: +o pcwalton
[18:29:06] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Quit: Leaving)
[18:29:09] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[18:29:09] *** Joins: imperio (Mibbit@moz-8otf3a.fbx.proxad.net)
[18:29:10] <Manishearth> aturon: 
[18:29:11] <Manishearth> oops
[18:29:35] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[18:32:58] <LinuxBunny> Can we reserve a lifetime specifier for a thread local lifetime?
[18:33:31] <simukis> that’s 'static.
[18:33:44] <LinuxBunny> simukis, 'static is for the lifetime of the entire program though
[18:34:06] <LinuxBunny> simukis, Like, I can pass some local variables to Thread::scoped
[18:34:13] <nmatsakis> brson: k
[18:34:16] <LinuxBunny> their lifetime is not 'static
[18:35:02] <LinuxBunny> but if I have something like an APC that can only run on that thread, while currently I need to require the closure for it is 'static, it really only needs the data to be valid for the duration of the thread
[18:35:04] <simukis> Well… I don’t see how you’d enforce thread’s lifetime though… If you could it would be certainly a plausible idea
[18:35:27] *** Joins: lu324 (lu324___@moz-3v8ljg.dhcp.embarqhsd.net)
[18:35:29] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[18:36:07] <LinuxBunny> well, since it wouldn't be 'static, you wouldn't be able to hand it off to other threads except other scoped threads
[18:36:23] <LinuxBunny> so the enforcement of it should be easy
[18:36:39] *** Quits: Murarth (Murarth@moz-ljhfm9.dyn.nltelcom.net) (Quit: brb, washing the cat)
[18:36:53] *** Joins: Murarth (Murarth@moz-mpmr8r.phnx.qwest.net)
[18:37:24] <LinuxBunny> I just want to reserve a lifetime specifier for that in case it ever does get implemented
[18:38:16] <simukis> I think I recall somebody calling for 'thread to be reserved
[18:38:28] <simukis> don’t remember where and whether I dreamt about it or saw it IRL
[18:39:29] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[18:40:01] *** Quits: brson (brson@moz-u3dg2t.sfo1.mozilla.com) (Ping timeout: 121 seconds)
[18:41:28] *** Joins: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com)
[18:43:32] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[18:45:48] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Quit: )
[18:46:59] *** Quits: imperio (Mibbit@moz-8otf3a.fbx.proxad.net) (Quit: http://www.mibbit.com ajax IRC Client)
[18:47:10] *** Joins: imperio (Mibbit@moz-8otf3a.fbx.proxad.net)
[18:47:48] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[18:49:07] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[18:49:28] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Quit: Leaving)
[18:49:34] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[18:50:16] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Connection closed)
[18:50:18] *** Joins: kushal (kdas@moz-udf.p75.171.66.IP)
[18:54:34] *** Joins: eerie (eerie@moz-060j2q.red.bezeqint.net)
[18:55:28] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Connection closed)
[18:59:43] *** Joins: simukis (nagisa@moz-8t068g.static.zebra.lt)
[19:00:10] *** Quits: nrc (nrc@moz-4bhi2i.xtra.co.nz) (Ping timeout: 121 seconds)
[19:00:55] *** Quits: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com) (Client exited)
[19:04:45] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Connection closed)
[19:05:06] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[19:15:27] <nmatsakis> simukis: we've thought about it from time to time
[19:15:50] <nmatsakis> I don't see any reason we'd need to *reserve* though
[19:21:33] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Connection closed)
[19:21:34] *** Joins: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr)
[19:25:04] *** Joins: user7181 (user@moz-hof75n.mullvad.net)
[19:26:34] *** Joins: canhtak (jeremy@moz-1a9fh1.luxdsl.pt.lu)
[19:31:48] *** Quits: aepsil0n (eduard@moz-g8ss54.mv2h.pepi.8071.2a02.IP) (Connection closed)
[19:38:16] *** Joins: swgillespie (swgillespie@moz-upj.3un.220.167.IP)
[19:40:14] *** Joins: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at)
[19:41:02] *** Quits: canhtak (jeremy@moz-1a9fh1.luxdsl.pt.lu) (Client exited)
[19:44:04] *** Quits: eerie (eerie@moz-060j2q.red.bezeqint.net) (Connection closed)
[19:44:17] *** Quits: dinfuehr (dinfuehr@moz-b760b5.highway.telekom.at) (Ping timeout: 121 seconds)
[19:45:02] *** Quits: semarie (semarie@moz-72bfrp.torservers.net) (A TLS packet with unexpected length was received.)
[19:45:37] <eternaleye> So I'm looking at the 'rand' crate, and I'm wondering how people would react to a proposal to change the API of rand::RNG
[19:45:46] <eternaleye> Because it's kind of... weird, IMO
[19:46:34] *** Quits: johnz133 (johnz133@moz-tqd.4t0.72.208.IP) (Quit: )
[19:47:24] <Eridius> hrm, http://doc.rust-lang.org/nightly/rand/index.html still exists and incorrectly claims that the official API is in std::rand
[19:47:33] *** Quits: simukis (nagisa@moz-8t068g.static.zebra.lt) (Quit: Leaving.)
[19:47:34] <apoelstra> eternaleye: how is it weird?
[19:47:40] <apoelstra> eternaleye: i'd react "curiously"
[19:47:47] *** Joins: johnz133 (johnz133@moz-tqd.4t0.72.208.IP)
[19:47:54] <eternaleye> apoelstra: Well for one thing, a lot of its methods should really not be living in Rng IMO
[19:48:05] <apoelstra> hmm, i guess i don't use most of them ..
[19:48:09] <eternaleye> apoelstra: For another, it's based on next_u32 as the baseline, rather than fill_bytes
[19:48:14] <apoelstra> yeah, that's weird
[19:48:26] <apoelstra> tho it's probably the most efficient thing in a lot of cases
[19:48:44] <Eridius> eternaleye: I think the lowest common denominator for RNG impls is being able to produce random u32 values
[19:49:09] <Eridius> fill_bytes can be implemented in terms of u32s, but for a lot of RNG impls, a manual implementation of fill_bytes() would basically be a repeated application of generated u32 values
[19:49:46] *** Joins: pcwalton (pcwalton@moz-l8ebtf.sfo1.mozilla.com)
[19:49:46] *** ChanServ sets mode: +o pcwalton
[19:49:53] <eternaleye> Eridius: On the other hand, a number of RNGs generate much more than a u32, and thus have to either keep a good bit of state between calls, or throw away a good bit of work.
[19:49:54] *** Joins: canhtak (jeremy@moz-1a9fh1.luxdsl.pt.lu)
[19:50:04] <eternaleye> Eridius: ChaCha's unit of generation is 64 _bytes_
[19:50:07] <apoelstra> i'd like if there was a counter Rng in rand which just ran through 0-255 in its output..
[19:50:13] <apoelstra> just something stupidly well-defined for unit tests
[19:50:14] <Eridius> eternaleye: why do that? They can just implement fill_bytes() if they can do so better than the default impl
[19:50:36] <Eridius> eternaleye: default impls of trait methods are just _default_ impls. Trait implementations can override them when it makes sense to do so
[19:50:43] <eternaleye> Eridius: Mm
[19:50:51] <eternaleye> Eridius: True enough
[19:50:58] <Eridius> and the documentation on fill_bytes() explicitly says that implementations that can generate bytes more efficiently than the default implementation (which uses next_u64 and next_u32) should override it
[19:51:25] <eternaleye> Eridius: The other thing is that its methods are IMO quite weird - I mean, gen_ascii_chars?
[19:51:47] <eternaleye> Eridius: That should just use gen_iter with Ascii: Rand
[19:52:01] <eternaleye> Eridius: gen_iter? That should just be a usage of iter::iterate over Rand::rand or Gen
[19:52:08] <Eridius> except it doesn't generate Ascii values, it generates values in the set [a-zA-Z0-9]
[19:52:09] <eternaleye> er, Rng::gen
[19:52:37] <eternaleye> Eridius: ...ewwwwww
[19:52:38] <Eridius> so using a Rand impl would require a bespoke type that represents just that domain of characters that can then be mapped back into chars
[19:52:54] <eternaleye> Eridius: That's kind of what choose is _for_
[19:52:55] *** Joins: nodweber (nodweber@moz-knt.fgq.178.5.IP)
[19:52:57] <Eridius> I think the name is a bit misleading though, and I do wonder what the motivating reason for having it is
[19:53:00] <Eridius> how many clients actually use it?
[19:53:36] <eternaleye> IMO, gen(), choose(), and shuffle() are sensible
[19:53:45] <apoelstra> i'm grepping my ~/code ... looks like just unit tests
[19:53:46] <eternaleye> gen_range is also quite sane
[19:53:52] <apoelstra> for the ascii one
[19:53:56] <Eridius> eternaleye: ok sure, you could build a set &'static [char] of the 62 valid characters and then just repeat a choose() operation, but that's still not necessarily obvious
[19:54:02] <eternaleye> but gen_weighted_bool should just generate a u32 and use >
[19:54:39] <apoelstra> Eridius: it'd be more general tho, what if you want random hex characters or random lowercase letters or random base64 chars or random base58 chars
[19:54:39] <Eridius> the impl of gen_weighted_bool is actually a bit different
[19:54:44] <apoelstra> alphanumerics seems really specific
[19:54:58] <eternaleye> Eridius: Is the weight nonlinear or something?
[19:55:02] <Eridius> it uses gen_range()
[19:55:13] <Eridius> and checks if the result == 0
[19:55:26] <eternaleye> Eridius: ...ewwww
[19:55:30] <Eridius> eww? That seems reasonable
[19:55:49] <Eridius> if you want a 1-in-15 chance, it makes sense to generate a number in the range [0,15) and check if the result is 0
[19:55:56] *** Quits: redblue (redyellow@moz-55rvi2.dclient.hispeed.ch) (Ping timeout: 121 seconds)
[19:56:07] <Eridius> if gen_range() produces a properly uniform distribution then that will give you the correct result
[19:56:12] <eternaleye> Eridius: The eww is that it's got no need to be a method at all
[19:56:32] <Eridius> I assume it was added because it was considered useful. I don't know offhand what code would use it though
[19:56:50] <eternaleye> Eridius: I mean, to paraphrase George Carlin, "You've got a gen_range, you've got a comparison operator, call the bloody thing!" (re: sliced bread)
[19:57:00] <Eridius> looks like rwlock uses it
[19:57:29] <Eridius> .. in a test
[19:57:54] <eternaleye> There's also that SeededRng really ought to be using an associated type for Seed
[19:58:24] <Eridius> what if a Rng can be seeded from multiple different seed types?
[19:58:44] <Eridius> (I don't think any existing Rngs do that right now, but it doesn't seem implausible)
[19:59:03] <eternaleye> Eridius: It does seem implausible to me
[19:59:15] <eternaleye> Eridius: Since an RNG has a state, and seeding is initializing that state
[19:59:36] <eternaleye> Eridius: If stuff can compress down arbitrary data into a seed, then it takes &[u8]...
[19:59:44] <Eridius> ok fine
[19:59:57] <eternaleye> Which is what StdRng does, in fact
[20:00:05] <eternaleye> Ah, no, it takes &[usize]
[20:00:10] <Eridius> note that rand is on crates.io, if you want to propose changes, then you should submit issues to https://github.com/rust-lang/rand
[20:00:10] <eternaleye> For some reason
[20:00:33] <eternaleye> Sure, just thought I'd bring it up in here since it was recently of-rustc/libstd
[20:00:44] <eternaleye> And IIRC rustc uses it
[20:00:47] <Eridius> there actually is a channel #rust-libs now, which I suspect is the "correct" location for this
[20:00:59] <eternaleye> Ah, cool
[20:01:03] <Eridius> although that room is significantly smaller than this one
[20:01:25] <jethrogb> any european developers still awake?
[20:01:46] <eternaleye> There's also #rust-apidesign, though it's very quiet (and I suspect more aimed at holistic design of Rustic APIs)
[20:02:17] <Eridius> huh, I missed that one. We have a lot of channels now apparently
[20:04:55] <eternaleye> Heh, a comment above next_u32 in the trat definition: "FIXME #7771: Should be implemented in terms of next_u64"
[20:06:14] *** Joins: sav (e@moz-9u3te2.cc)
[20:06:34] <Eridius> eternaleye: the referenced issue is that default implementations of methods in a trait should be recursive and therefore require an implementor to only implement one of them
[20:09:16] <eternaleye> Mm
[20:10:42] <eternaleye> Eridius: In that case, I'd favor both of those having default impl's that dispatch to fill_bytes, and fill_bytes dispatching to u64
[20:11:22] <eternaleye> Mm, no
[20:11:33] <eternaleye> u32 -> u64 -> fill_bytes would be better IMO
[20:11:53] <Eridius> why would it be better?
[20:12:12] <Eridius> most random-number generators don't generate an infinite stream of bytes, they generate a stream of discrete chunks, often either 32-bit or 64-bit values
[20:13:03] <Eridius> so having fill_bytes be the "base" impl would actually be awkward, it would require all random-number generators to figure out how to map their discrete u32 or u64 (or whatever) values into an arbitrary stream of bytes, which is then translated by the default impls back into a u32 or u64 value
[20:13:39] <eternaleye> Eridius: I'm saying in the case where circular impls worked
[20:13:54] <Eridius> fill_bytes absolutely should be implemented by default in terms of u32 and u64, and only overridden by generators that can do it better. The only change that should be made is u32 and u64 should be implemented in terms of each other and require trait implementors to implement whichever of those two is more natural, but Rust doesn't support that at the moment
[20:13:56] <eternaleye> Eridius: u32 -> u64 -> fill_bytes -> u64
[20:14:08] <eternaleye> Eridius: That was my meaning
[20:14:40] <Eridius> that cycle you described doesn't work, because it means no implementor can simply implement u32 and work
[20:14:51] <Eridius> so a 32-bit RNG would have to implement either next_u64 or fill_bytes in order to be functional
[20:14:53] <eternaleye> Mm
[20:14:54] <Eridius> and that's a bad requirement
[20:15:11] <eternaleye> Eridius: And for types that *do* work on a fill_bytes basis, like the getrandom syscall, it's also nasty
[20:15:36] *** Quits: sigma (sigma@moz-ohog4c.range86-135.btcentralplus.com) (Ping timeout: 121 seconds)
[20:15:40] <Eridius> I'm not familiar with getrandom. But an RNG built on that could easily manually implement next_u32 or next_u64 in terms of fill_bytes
[20:15:43] <Eridius> it just can't be the default impl
[20:16:08] <Eridius> it's easier for a RNG to implement next_u32 or next_u64 in terms of fill_bytes than it is for an RNG to implement fill_bytes in terms of next_u32/next_u64
[20:16:19] <Eridius> therefore the latter hard impl is the default one
[20:16:32] <eternaleye> Eridius: Sure, but u64 in terms of 32 is not especially difficult either
[20:16:50] <eternaleye> Eridius: And there's always the option of making it a true 3-cycle, u32 -> u64 -> fill_bytes -> u32
[20:17:17] <Eridius> that's inefficient. fill_bytes uses u64 and u32 together for performance reasons
[20:17:34] <eternaleye> Mm
[20:17:35] <Eridius> otherwise a 64-bit RNG would be generating a bunch of 64-bit values, truncating them to 32 bits, and then stitching them back together
[20:17:36] <eternaleye> Eridius: Anyway, part of my perspective comes from the crypto side, too
[20:17:45] <Eridius> instead of just stitching together the 64-bit values
[20:17:48] <eternaleye> Eridius: Where basically nothing operates in units as small as 64-bit
[20:18:25] <eternaleye> Eridius: AES in counter mode? 128-bit blocks. ChaCha? 64-byte chunks. etc.
[20:18:45] <Eridius> and RNGs intended for that use can, and should, implement fill_bytes
[20:18:49] <eternaleye> Eridius: OS random source, which good crypto should be using? buf filler.
[20:19:41] <steveklabnik> acrichto: do you have any idea why http://doc.rust-lang.org/nightly/std/macros/ is blank?
[20:19:59] <steveklabnik>  acrichto it has been for a while, but since you've been so on rustdoc lately
[20:20:27] <acrichto> steveklabnik: hm odd, I dunno
[20:20:31] <acrichto> I didn't think rustdoc generated blank pages
[20:20:40] <acrichto> it could be how were' uploading to S3
[20:20:46] <acrichto> and we forgot to delete it at some point or something like that
[20:20:50] <steveklabnik> hm
[20:20:52] <acrichto> but that module doesn't even exist any more
[20:20:55] <steveklabnik> ah
[20:21:08] <steveklabnik> then that's cool
[20:21:17] <steveklabnik> i was looking to add examples of common ones
[20:21:22] <steveklabnik> i'll stick them in the TRPL chapter
[20:22:07] <eternaleye> Eridius: ...looking at the code of gen_weighted_bool, does anything seem... off... to you?
[20:22:20] <eternaleye> >> fn gen_weighted_bool(&mut self, n: u32) -> bool { n <= 1 || self.gen_range(0, n) == 0 }
[20:22:31] <eternaleye> Eridius: I really don't think that should be an ||...
[20:22:31] <Eridius> eternaleye: no? It always returns true if you ask for 1/0 or 1/1, and it uses the range test for any n>1
[20:22:37] <Eridius> that should indeed be a ||
[20:22:57] <eternaleye> "Return a bool with a 1 in n chance of true"
[20:22:59] <Eridius> it's generating a boolean with 1/N chance of being true. 1/0 is nonsense, so it just arbitrarily returns true. 1/1 is trivially true
[20:23:07] <eternaleye> Oh, gah
[20:23:13] <eternaleye> My brain reversed the operator somehow
[20:23:17] <eternaleye> Blehhhh
[20:23:17] * Eridius chuckles
[20:23:37] *** Quits: topolinux (paolo@moz-cl3.9up.77.151.IP) (Quit: Sto andando via)
[20:25:17] <eternaleye> I do think it'd be clearer with == 0 though
[20:25:26] <eternaleye> Since 1 is trivially true, but gen_range can tell us that
[20:25:48] <eternaleye> == 0 makes it clear it's just avoiding the panic!()
[20:27:28] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[20:31:00] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[20:31:15] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[20:34:41] <seanmonstar> <3 steveklabnik 
[20:34:44] <seanmonstar> (i assume)
[20:40:02] <steveklabnik> it was
[20:40:03] <steveklabnik> :)
[20:40:08] <steveklabnik> <3
[20:42:27] *** Joins: ephemeron_ (ephemeron@moz-h5kea2.i2gt.qoll.a880.2604.IP)
[20:46:36] *** Quits: ctennis (ctennis@moz-93imdn.bltnin.sbcglobal.net) (Quit: Leaving...)
[20:49:51] <steveklabnik> acrichto: you don't need the hash anymore when you r+
[20:50:01] <steveklabnik> bors will pick the last commit at the time you made the comment
[20:50:03] <acrichto> yeah but I don't like getting another email from bors
[20:50:08] *** Quits: sav (e@moz-9u3te2.cc) (Ping timeout: 121 seconds)
[20:50:23] <acrichto> (but thanks for the info!)
[20:50:36] *** Joins: pnkfelix (pnkfelix@moz-eljppb.fbx.proxad.net)
[20:50:37] *** ChanServ sets mode: +o pnkfelix
[20:50:37] <steveklabnik> word
[20:50:37] <steveklabnik> also
[20:50:40] <steveklabnik> is https://github.com/rust-lang/rust/issues/24505#issuecomment-93832839 at me
[20:50:45] <steveklabnik> or ioqp?
[20:51:00] <acrichto> ioqp
[20:51:06] <acrichto> I don't think that's a bug
[20:51:12] <acrichto> but I'm also not sure what it's asking...
[20:51:19] <steveklabnik> he's saying that he expects it TO require a feature
[20:51:28] *** Quits: kushal (kdas@moz-udf.p75.171.66.IP) (Quit: Leaving)
[20:51:36] <steveklabnik> a bare extern crate core doesn't complain
[20:51:40] <steveklabnik> and neither does a bare one with the flag
[20:52:13] <acrichto> no it requires the feature toda
[20:52:14] <acrichto> today*
[20:52:20] <acrichto> foo.rs:1:1: 1:19 error: use of unstable library feature 'core'
[20:53:28] <reem> No matter how much I try to justify it to myself, 1066 feels like losing to me. We built this whole incredible system and we’re just gonna drop it for an, imo worse, solution in the form of closure-taking functions? Ugh.
[20:54:16] *** Quits: larhat (Adium@moz-8v4.af0.232.213.IP) (Quit: Leaving.)
[20:54:51] <steveklabnik> huh, he said it idnd't
[20:54:53] <steveklabnik> didn't
[20:55:31] <Eridius> context?
[20:55:42] <steveklabnik> gh24505
[20:55:42] <[o__o]> No unused annotation warning when externing crate: https://github.com/rust-lang/rust/issues/24505
[20:56:11] <steveklabnik> also, i didn't realize bors accepted without the comment, acrichto. so i've probably spammed you a few times when i didn't realize it was accepted :(
[20:56:12] *** Quits: filsmick (filsmick@moz-s1ht48.abo.wanadoo.fr) (Quit: )
[20:56:12] <Eridius> sorry, I meant for reem.
[20:56:27] <reem> Eridius: RFC 1066 for marking mem::forget safe and saying it’s ok to not run destructors.
[20:56:33] <acrichto> steveklabnik: hehe no worries! I don't mind the email I just avoid it if I can when I'm writing r+ :)
[20:56:37] <Eridius> ah
[20:56:49] * steveklabnik nods
[20:56:58] <reem> I just… I feel defeated, reading this.
[20:57:24] <steveklabnik> well, i mean really this is kinda formalizing what was already happening
[20:57:25] *** Joins: ctennis (ctennis@moz-vcpg3c.in.comcast.net)
[20:57:26] <steveklabnik> re destructors
[20:57:55] <reem> This is definitely the easiest solution, but I am far away from being convinced it’s the best solution
[20:58:45] <reem> “RAII still works if you don’t relinquish ownership of the guard” is not a good plan forward in my opinion, the ability to pass ownership of the guard is *incredibly* useful.
[21:01:41] *** Quits: Rym (y@moz-uso.r81.55.31.IP) (Ping timeout: 121 seconds)
[21:02:29] <sfackler> seems to me like it works just fine for everything except things like scoped's guard that need to run for correctness. If I leak a File by shoving it in an Rc cycle, I don't know why I'd be surprised that it doesn't ever run the Drop impl
[21:02:53] *** Quits: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com) (Connection closed)
[21:02:58] *** Joins: p1start (p1start@moz-nftjhe.org)
[21:03:10] <Eridius> I still feel that the fundamental bug here is Rc/Arc. The ability to construct cycles with those types violates the lifetime rules
[21:03:10] *** Joins: kmcguire (kmcguire@moz-pg1gb9.biz.rr.com)
[21:03:53] <reem> I just think the category of things falling under “my destructor must run for correctness” can be large
[21:04:02] <sfackler> but how do you prevent cycles without solving the halting problem or forbidding things like reference counted trees?
[21:04:06] <reem> scoped is just one example, drain_range is another (incredibly useful) one
[21:04:10] <bstrie> Eridius: that may very well be true, but that doesn't mean that Rc is the only way to make a destructor never run
[21:04:14] <Eridius> a "trivial" fix might be to require 'static on the element type of Rc/Arc, but I don't know how often people actually need to use Rc with values that have lifetimes
[21:04:40] <Eridius> sfackler: it's not so much "no cycles" as it is "no cycles of things that contain non-'static lifetimes"
[21:04:41] <reem> sfackler: Well, one solution is to have a trait, e.g. “MustDrop”, and prevent Rc/Arc from containing those types.
[21:05:17] <reem> Specifically it’s “no cycles containing things which must be dropped within their lifetime for memory safety”
[21:05:25] *** Joins: Kingsquee (kingsley@moz-qq7ns6.bchsia.telus.net)
[21:05:31] <sfackler> yeah, seems like a nice thing that we'll add in a release or two
[21:05:41] <reem> It’s not possible to add it later because Rc has no bounds
[21:05:48] <reem> adding a bound is backwards incompatible
[21:06:07] <sfackler> not if you use the inverse and default impls
[21:06:15] <bstrie> new pointer type: Src (Sound Rc)
[21:06:22] <reem> You mean ?Sized-like stufF?
[21:06:26] <sfackler> yeah
[21:06:35] <reem> … ick, to be honest
[21:06:42] <reem> it just seems like a huge hack
[21:07:00] <bstrie> Rc is a huge hack, from the perspective of our type system. just a useful one, sadly
[21:07:07] <reem> for something this crucial… we should do this the right way, not the worse is better way
[21:07:10] *** Joins: Rym (y@moz-uso.r81.55.31.IP)
[21:07:31] <rkruppe> reem: So destabilize Rc too and work it out in peace?
[21:08:10] <reem> I mean, if we’re going to destabilize Rc we might as well just derail our current 1.0 schedule
[21:08:20] <sfackler> yeah, we could hold back 1.0 until we reach the platonic ideal of a type system plus standard library
[21:08:29] <rkruppe> That's the problem
[21:08:29] <sfackler> or we could release a thing so people in the real world can use it
[21:08:35] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[21:08:39] <acrichto> reem: Eridius: one thing to keep in mind though is that Rc is not the only source of leaks right now
[21:08:42] <bstrie> I propose that we call this period in rust's history "the a-drop-alypse"
[21:08:42] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[21:08:46] <sfackler> every language has warts
[21:08:52] <acrichto> Rc was the original instagation for this, but panicking dtors will trigger leaks as well
[21:08:55] <acrichto> er, may trigger*
[21:08:57] <reem> sfackler: I would normally agree, but this problem seems so much larger to me than most of the other things we would have to delay 1.0 for 
[21:09:20] <reem> acrichto: Right, but that’s a *bug* not a specifically forward compatible piece of the language.
[21:09:33] <acrichto> reem: not necessarily, this "bug" is *incredibly* hard to fix
[21:09:37] <acrichto> and may have quite a performance impact
[21:09:41] <reem> I believe it
[21:09:42] <acrichto> and it's not clear that it's actually a bug
[21:09:49] <reem> It’s not a situation with a clear solution
[21:10:07] <Eridius> it seems clear to me that it is a bug. thread::scoped uses lifetimes in a way that Rust cannot really handle properly
[21:10:16] <rkruppe> Frankly, if thread::scoped() didn't exist, I would say "so what, leaking is bad but it's not unsafe, right?"
[21:10:16] <reem> It just seems to me that making forget safe is the knee-jerk response, but there’s more to this problem, I think.
[21:10:36] <Eridius> specifically, in all other cases where a value with a lifetime is leaked, that's not memory-unsafe because the leaked value is inaccessible to code and therefore can't actually do anything with the lifetime
[21:10:47] <Eridius> but in the case of thread::scoped, the "leaked value" is really a proxy for a thread that is in fact running code
[21:10:50] <bluss> making forget safe is entirely unnecessary and rash
[21:11:15] <Eridius> so I think we just need to destabilize thread::scoped for now and figure out some way to specifically fix thread::scoped without throwing up our hands and declaring that RAII is dead
[21:11:26] <Amaranth> Making forget safe is just a way to tell people "you can never rely on a dtor running" which means RAII is no longer a thing in Rust
[21:11:27] <rkruppe> bluss: Well, I wouldn't put it in the RFC title, but if not-calling-drop is made safe, there is no reason for forget to remain unsafe
[21:11:30] <bluss> I thought we wanted to be cautious with what we promise, we have no need to promise that function safe now
[21:11:44] <acrichto> Eridius: to be clear we're not saying RAII is dead, and saying so is a bit of a misnomer I think, we're saying "destructors which must run for memory safety are dead"
[21:11:50] <reem> acrichto: Fundamentally, my point is that we *don’t* yet have a good solution for this problem, so rushing through a forget-is-safe based solution feels premature.
[21:11:56] <bluss> rkruppe: how about we give it time to understand the situation? There is absolutely no rush needed
[21:12:07] <bluss> rkruppe: better to keep the card on the hand
[21:12:09] <Eridius> I'm not sure I disagree that mem::forget should be made safe, since it's possible to avoid running destructors with safe code in other fashions. But I don't think that needs to have any implications on RAII beyond just an acknowledgement that destructors are not guaranteed to run
[21:12:14] <acrichto> bluss: there's some discussion on the RFC about this, but `unsafe` is for *memory unsfaety*, not general footguns, and `forget` can be written in totally safe code today
[21:12:20] <Eridius> just merely.. guaranteed to run as long as the object is accessible to code
[21:12:34] <rkruppe> bluss: The underlying question is whether drop not being called is unsafe. That seems pretty fundamental for 1.0
[21:12:35] <reem> To be incredibly specific the exact guarantee that we will be losing is that you cannot rely on the destructor for T running if you pass ownership of an instance of T to another owner.
[21:12:50] <rkruppe> What reem said
[21:12:51] <reem> This is different than “RAII is dead” because if you keep ownership of the guard all is good
[21:13:03] <bluss> rkruppe: absolutely. And why the rush to mark forget safe before we even finish discussing the main issue :)
[21:13:20] <reem> but, I hypothesize (and my experience suggests this) that passing ownership of the guard is incredibly useful, and losing this feature will hurt a lot in the future
[21:13:22] <rkruppe> bluss: Yeah, I agree that the RFC should be "make leaks safe"
[21:13:44] <Eridius> I do have a certain preference for keeping it as unsafe, merely because it means you have to think carefully as to whether mem::forget is actually what you want to be doing, but I am sympathetic to the argument that unsafe is for memory unsafety and mem::forget is not memory-unsafe
[21:13:52] <reem> To clarify: there is no need to sensationalize the issue by saying “RAII is dead” - we’re talking about something far more specific.
[21:14:07] <Amaranth> Didn't Gankro say not being able to rely on drop breaks some of the collections API?
[21:14:14] <Amaranth> Like, memory unsafety breaks
[21:14:20] <rkruppe> reem: RAII also works if whoever you pass it to doesn't leak either. But that's not compiler checked, so we're back to the C++ situation of "you just have to do the right thing"
[21:14:28] <Gankro> Amaranth: accepted but unimplemented API
[21:14:41] <Amaranth> ah
[21:14:42] <bluss> acrichto: making it safe is promising one more thing for Rust 1.0 and it's entirely unnecessary. We can just do it later if we want to. There's lots of specifics we are in no rush to stabilize or promise
[21:14:43] *** Quits: ephemeron (ephemeron@moz-h5kea2.i2gt.qoll.a880.2604.IP) (Quit: Disconnected)
[21:15:11] <Amaranth> So do we have anything other than thread::scoped that mem::forget would make unsafe?
[21:15:18] <Gankro> Amaranth: Although all code I've written has been on the assumption of guaranteed dtor's, I can't find any code that uses it
[21:15:36] <Amaranth> Rather than just leaking memory, file descriptors, sockets, and locks
[21:15:45] <sfackler> scoped is the only thing anyone's aware of iirc
[21:15:52] <rkruppe> bluss: Well technically making it safe is a breaking change (or so I heard someone smart say), because of how function pointer subtyping works
[21:16:16] <rkruppe> But yeah, it's a very minor one, in the order of magnitude of bug fixes
[21:17:10] <bluss> rkruppe: oh ok, that's unexpected
[21:17:29] <reem> I’m pretty sure that’s fixable anyway (just make fn() a subtype of unsafe fn())
[21:17:37] <rkruppe> Probably
[21:17:44] <reem> since making it a subtype is not a breaking change, it’s all fine
[21:18:16] <reem> whether mem::forget is unsafe is sort of a red herring for the actual conceptual discussion and guarantees here
[21:19:11] <acrichto> bluss: if Rc is #[stable] then a safe mem::forget is also #[stable] (put another way)
[21:19:43] <jethrogb> soliciting another round of feedback on this draft RFC https://github.com/jethrogb/rfcs/blob/topic/visibility-override/text/0000-visibility-override.md
[21:20:39] <reem> acrichto: If Rc doesn’t change, you’re right, we may as well mark mem::forget safe, but changing Rc is an alternative here, so that might not be the case.
[21:20:57] <bstrie> jethrogb: don't feel bad if there's not a lot of attention to go around, we seem to be occupied at the moment :P
[21:21:06] <acrichto> reem: sure, but the RFC discusses that as well and the current belief is that modifications to Rc are too impractical to work in the current time frame
[21:21:45] <rkruppe> We're between a rock and a hard place here, all options are bad for users of stable and for publicity
[21:21:52] <reem> Yes
[21:21:59] <bstrie> reem: I want to wait to see aturon's new closure-based API for scoped before saying that Rc needs to be neutered
[21:22:05] <rkruppe> If Rc becomes unstable, that breaks a lot of code (and makes a bad impression)
[21:22:42] <rkruppe> If drop isn't guaranteed, people will be all up in arms (right or not), and we lose some nice APIs. At least they become a bit less nice (closures)
[21:22:57] <reem> acrichto: This RFC has to include the new API for thread::scoped in my opinion, or we’re just fumbling around in the dark.
[21:23:47] <acrichto> reem: aturon should be making another RFC shortly specifically about that API
[21:23:55] <reem> In my mind, this issue is big enough that “change the 1.0 schedule” is on the table. I don’t know if anyone else feels the same way.
[21:24:20] <rkruppe> Considering the other options, I'm inclined to agree
[21:24:33] <reem> I’m not saying we should do it, but I’m saying that we should consider it - this really is a big deal for the future of rust design.
[21:24:41] <bluss> acrichto: I just don't understand why this making the function safe is even proposed now before we have solved the actual issue
[21:24:48] <rkruppe> I mean, some people may thing "ha, they can't even get that right in time", but in the long run it's the best place to be in
[21:25:29] <bluss> rkruppe: well someone put it in a positive light by saying "this is how committed they are to guaranteeing safety"
[21:25:29] <acrichto> bluss: the current proposal is to allow Rc to exist (the RFC as state), which is a solution to the issue, just maybe not the most hotly desired issue
[21:26:22] <rkruppe> bluss: Sure, though it's really "committed to being safe *and* to this cool concurrency API"
[21:26:43] <rkruppe> I have to admit I'm a bit concerned myself
[21:27:20] <rkruppe> This hole was tricky to discover (okay, it only took a few weeks, but still), what if there are others or more sneak in in the future?
[21:27:47] <rkruppe> What's the policy for stable APIs (post-1.0-final) that turn out to be unsafe btw?
[21:28:03] <bstrie> rkruppe: that's another RFC that I've been begging aturon to release :P
[21:28:11] <rkruppe> Ah :D
[21:28:32] <bstrie> where is he today, I wanted to go to lunch with him!
[21:33:16] *** Quits: p1start (p1start@moz-nftjhe.org) (Ping timeout: 121 seconds)
[21:36:00] *** Joins: cristicbz (cristi@moz-mno.j2g.209.90.IP)
[21:36:16] <sfackler> iirc unsoundness is one of if not the only time we'd straight up break back compat
[21:36:46] <cristicbz> I'm x-posting from #rust, since this might be the better place to ask since it's a stdlib design question: why doesn't *Map::entry() take the key arg like get() i.e. &Q where K: Borrow<Q>. Then, in the vacant case, it could use q.to_owned() to populate the key. This would save an unnecessary clone in the Occupied case.
[21:37:05] <cristicbz> (sorry Gankro answered in the other place)
[21:41:51] *** Joins: aepsil0n (eduard@moz-6491ha.mv2h.pepi.8071.2a02.IP)
[21:48:14] <aturon> bstrie: sorry had a long mid day appointment. Scope rfc today or tomorrow, API evito rfc next week
[21:48:17] <carllerche> Has any body discussed the possibility of a panic in a dtor aborting?
[21:48:30] <aturon> API evolution (sorry typing on phone)
[21:50:45] *** Joins: tcurdt (tcurdt@moz-tftac1.dip0.t-ipconnect.de)
[21:51:05] <carllerche> I am pretty sure I would prefer an abort over a memory leak :)
[21:51:13] <reem> carllerche: I write all my destructors under that assumption anyway, since panic during panic is an abort already
[21:51:51] <carllerche> i'm guessing that there would be performance implications
[21:52:09] <nmatsakis> carllerche: at this point that is what I favor, I don't think it has to have a big perf cost if we impl it right, but it's been a while since I thought about it
[21:52:21] <nmatsakis> (in the past I didn't favor that)
[21:53:03] <carllerche> I think that permitting memory leaks in safe code is dangerous, and yes I am aware that this is a very difficult bug and I am just piling on uneducated opinions from the outside :P
[21:53:55] <Gankro> I don't think it's dangerous (at least not enough to worry too much about), but it *does* suck to do
[21:54:37] *** Quits: johnsoft (johnsoft@moz-69mrig.res.rr.com) (Ping timeout: 121 seconds)
[21:54:53] *** Joins: johnsoft (johnsoft@moz-69mrig.res.rr.com)
[21:57:59] *** Quits: swgillespie (swgillespie@moz-upj.3un.220.167.IP) (Quit: My MacBook Pro has gone to sleep. ZZZzzz…)
[21:59:01] <carllerche> Gankro: I mean, define dangerous
[21:59:13] <carllerche> I'm unsure what the exact set of trade offs are
[21:59:15] *** Joins: nerdopoly (Mibbit@moz-inc16q.range86-146.btcentralplus.com)
[22:01:23] <Gankro> carllerche: unchecked indexing is dangerous. Overflow is kinda risky. Being able to exhaust memory... eh...
[22:01:38] <carllerche> security wise you mean?
[22:05:24] *** Joins: sav (e@moz-9u3te2.cc)
[22:07:08] *** Quits: nodweber (nodweber@moz-knt.fgq.178.5.IP) (A TLS packet with unexpected length was received.)
[22:08:04] *** Joins: srh (User@moz-cl17cf.q9f2.utp8.0306.2602.IP)
[22:08:09] *** Joins: ineol (ineol@moz-akt.oi0.185.94.IP)
[22:13:17] <LinuxBunny> you can kill someone's server by causing an OOM
[22:13:26] <LinuxBunny> you typically cannot steal their passwords by causing an OOM
[22:14:16] *** Joins: nodweber (nodweber@moz-knt.fgq.178.5.IP)
[22:14:42] *** Joins: summerlight (summerlight@moz-99k.2mj.130.121.IP)
[22:16:31] *** Quits: imperio (Mibbit@moz-8otf3a.fbx.proxad.net) (Quit: http://www.mibbit.com ajax IRC Client)
[22:22:36] *** Joins: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk)
[22:22:49] *** Joins: rprichard (rprichard@moz-6t31kt.en8f.d045.0009.2601.IP)
[22:24:01] *** Quits: canhtak (jeremy@moz-1a9fh1.luxdsl.pt.lu) (Client exited)
[22:24:19] *** Joins: canhtak (jeremy@moz-1a9fh1.luxdsl.pt.lu)
[22:25:00] *** Quits: nerdopoly (Mibbit@moz-inc16q.range86-146.btcentralplus.com) (Quit: http://www.mibbit.com ajax IRC Client)
[22:27:40] *** Quits: Astrum|Lap (Astrum|Lap@moz-7enfbr.co.comcast.net) (Client exited)
[22:28:05] *** Quits: jshs (jshs@moz-fqlr0g.dip0.t-ipconnect.de) (Client exited)
[22:31:13] *** Joins: kushal (kdas@moz-6bbu0u.dsl.bell.ca)
[22:31:41] *** Quits: kushal (kdas@moz-6bbu0u.dsl.bell.ca) (Connection closed)
[22:36:40] *** Quits: bjz (bjz@moz-puppgq.tpgi.com.au) (Quit: My Mac has gone to sleep. ZZZzzz…)
[22:37:13] *** Quits: nodweber (nodweber@moz-knt.fgq.178.5.IP) (Ping timeout: 121 seconds)
[22:38:01] *** Quits: munksgaard (munksgaard@moz-urnkl5.u.parknet.dk) (Ping timeout: 121 seconds)
[22:43:51] *** Quits: summerlight (summerlight@moz-99k.2mj.130.121.IP) (Ping timeout: 121 seconds)
[22:47:18] *** Quits: c0170 (c0170@moz-4stj9o.cable.virginm.net) (Ping timeout: 121 seconds)
[22:50:54] *** Quits: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net) (Ping timeout: 121 seconds)
[22:51:47] <bluss> Rust isn't a sandbox like playpen anyway
[22:54:13] *** Quits: user7181 (user@moz-hof75n.mullvad.net) (Quit: leaving)
[22:54:33] *** Quits: cristicbz (cristi@moz-mno.j2g.209.90.IP) (Quit: Leaving)
[23:03:16] *** Joins: brson (brson@moz-u3dg2t.sfo1.mozilla.com)
[23:03:16] *** ChanServ sets mode: +o brson
[23:05:28] *** Quits: aepsil0n (eduard@moz-6491ha.mv2h.pepi.8071.2a02.IP) (Connection closed)
[23:13:32] *** Quits: canhtak (jeremy@moz-1a9fh1.luxdsl.pt.lu) (Client exited)
[23:16:32] <doener_> eibwen: oh, you are @tbu-?
[23:16:47] <eibwen> doener_: yes. can I have some context?
[23:17:00] <doener_> eibwen: gh24489
[23:17:00] <[o__o]> Performance of inlined code not as expected: https://github.com/rust-lang/rust/issues/24489
[23:17:25] <eibwen> you're dotdash?
[23:17:26] <doener_> eibwen: just lookup you up on rustaceans.org because I wondered who tbu- is
[23:17:29] <doener_> right
[23:17:49] <eibwen> ah :) thanks for fixing this in LLVM. and so quickly!
[23:18:01] *** Quits: jdm (jdm@moz-i5m.05u.207.66.IP) (Quit: )
[23:18:18] <doener_> well, let's wait for what the upstream folks have to say
[23:18:26] <doener_> I'm positive though
[23:18:54] <doener_> and thanks for bringing this to our attention with such a simple test case
[23:20:05] <eibwen> no problem. have you hacked on LLVM before?
[23:21:46] <doener_> I made a few bugfixes and maybe one perf related change. All rust related, but I got (post review) commit access that way.
[23:22:13] *** Quits: zxq9 (ceverett@moz-qsm369.mesh.ad.jp) (Quit: Konversation terminated!)
[23:23:25] <doener_> though I'm primarily trying to get rustc to emit IR that suits llvm's needs
[23:23:41] <eibwen> doener_: can you check whether it generates the same code if you replace `decrement` with `checked_sub`?
[23:27:31] <XMPPwocky> with an extern "stdcall" fn, why is there a stub function created that just calls one with _rust_abi added on the end?
[23:27:44] <XMPPwocky> optimizations seem to remove it, but i care about the layout of the stack
[23:27:54] *** Joins: gsingh93 (gulshan@moz-3fu4am.mi.comcast.net)
[23:28:57] <cmr> XMPPwocky: https://github.com/rust-lang/rust/issues/10116
[23:29:32] <cmr> XMPPwocky: there's no real reason for it anymore beyond compiler cruft iirc.
[23:30:29] <doener_> eibwen: I compiled with -C debug-assertions (because I'm lazy), and neither version did eliminate the overflow check. But at least they're identical
[23:31:03] *** Joins: ELD (textual@moz-mqboa7.co.comcast.net)
[23:31:07] <doener_> steveklabnik: ping
[23:31:35] <eibwen> neither means that it wasn't elided in the `decrement` and the `-` case, but in the `checked_sub`?
[23:32:21] *** Quits: ELD (textual@moz-mqboa7.co.comcast.net) (Quit: Textual IRC Client: www.textualapp.com)
[23:33:17] <doener_> eibwen: "neither" means that both the version using "if a!= 0" as well as the match construct exhibit the same behaviour (because with -C debug-assertions the "val - 1" compuation also got checked)
[23:34:18] *** Joins: swgillespie (swgillespie@moz-upj.3un.220.167.IP)
[23:34:52] *** Quits: marsel (user@moz-j1l.3vh.180.94.IP) (Ping timeout: 121 seconds)
[23:35:03] <doener_> steveklabnik: closing gh24489 was a bit over enthusiastic I think. The upstream "fix" I referenced is still pending review, and we might want to backport that to out LLVM fork
[23:35:04] <[o__o]> Performance of inlined code not as expected: https://github.com/rust-lang/rust/issues/24489
[23:38:17] <doener_> steveklabnik: (please re-open if you agree with that, I don't feel confident re-opening myself, because I might be missing something in your rationale for closing it)
[23:42:36] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[23:43:13] <acrichto> LinuxBunny: ping
[23:43:45] *** Quits: bluss (bluss@moz-ec5o68.cust.bredbandsbolaget.se) (Ping timeout: 121 seconds)
[23:44:08] *** Quits: proc (proc@moz-13q4fn.dip0.t-ipconnect.de) (Quit: Gotta eat my pizza)
[23:44:31] *** Joins: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP)
[23:46:33] *** Joins: blaenk (blaenkdenum@moz-rrtddg.n2pv.fsko.e000.2605.IP)
[23:46:41] <blaenk> yeee specialization is a priority post 1.0
[23:48:00] <blaenk> pleaaaasseee prioritize "borrow checker improvements," it'd be sooo awesome
[23:48:19] *** Quits: eibwen (eibwen@moz-99ev72.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[23:49:09] *** Quits: rkruppe (chatzilla@moz-3nj.rnu.131.95.IP) (Ping timeout: 121 seconds)
[23:49:11] <blaenk> also syn ext :)
[23:50:39] *** Quits: binkarus (textual@moz-014tff.ca.comcast.net) (Quit: My Mac has gone to sleep. ZZZzzz…)
[23:51:24] <blaenk> i wish polymorphic mutability was one, maybe tagged on to the HKT one, in case it can be solved that way
[23:52:26] <blaenk> impl Trait is indeed very important imo
[23:53:01] <Amaranth> So basically you want everything ;)
[23:53:32] <LinuxBunny> acrichto, pong
[23:53:49] <blaenk> hahaha everything ;_;
[23:54:27] <blaenk> yeah, HKT, polymorphic mutability, borrow checker improvements (non-lexical borrows), syn ext, and impl Trait
[23:55:59] <acrichto> LinuxBunny: do you know if there's a difference between GetFullPathName and GetFinalPathNameByHandle? (looking to implement fs::canonicalize)
[23:57:00] <LinuxBunny> hmmmm
[23:57:53] <acrichto> looks like ruby/boost hand-code their implementations 
[23:58:17] <acrichto> and python may as well
[23:59:49] *** Quits: tcurdt (tcurdt@moz-tftac1.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)

[00:02:18] <nrc> acrichto: "Currently the compiler will implicitly add the target lib search path ($prefix/lib/rustlib/$target/lib) to any compilation" - where does this happen?
[00:03:03] <acrichto> nrc: I believe here: https://github.com/rust-lang/rust/blob/master/src/librustc/metadata/filesearch.rs#L56-L64
[00:05:50] <nrc> THanks!
[00:20:39] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[00:38:29] *** Joins: bkoropoff (bkoropoff@moz-kthi5c.wa.comcast.net)
[01:13:30] <nrc> What is the default sys_root after doing a standard rustup install on Linux?
[01:13:54] <nrc> acrichto: ^
[01:20:22] <nrc>  /usr/local
[01:21:57] <brson> nrc: yes
[01:47:40] *** Quits: brson (brson@moz-cfhap5.mtv2.mozilla.com) (Connection closed)
[02:10:25] *** Quits: kimundi (kimundi@moz-2q77u9.obe6.7gie.57bc.2002.IP) (Ping timeout: 121 seconds)
[02:16:15] *** Joins: kimundi (kimundi@moz-lr69rq.56vm.o3ls.4fe2.2002.IP)
[03:11:52] *** Quits: eddyb (eddyb@moz-5k2.pug.25.188.IP) (Ping timeout: 121 seconds)
[03:14:43] *** Joins: eddyb (eddyb@moz-pic.82i.25.188.IP)
[03:38:14] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[03:39:46] *** Quits: bkoropoff (bkoropoff@moz-kthi5c.wa.comcast.net) (Client exited)
[04:06:33] *** Joins: brson (brson@moz-1t0.c9m.56.172.IP)
[04:06:33] *** ChanServ sets mode: +qo brson brson
[04:52:27] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[05:03:16] *** Quits: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP) (Connection closed)
[05:03:39] *** Quits: brson (brson@moz-1t0.c9m.56.172.IP) (Connection closed)
[06:06:29] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Ping timeout: 121 seconds)
[06:22:21] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[06:58:01] *** Joins: nagisa (nagisa@moz-8t068g.static.zebra.lt)
[07:19:21] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[07:37:30] *** Joins: laumann (thomas@moz-3m6.3kq.109.2.IP)
[07:50:31] *** Joins: sigma (sigma@moz-92585k.range217-44.btcentralplus.com)
[07:51:44] *** Joins: killercup (killercup@moz-0pf6i8.dip0.t-ipconnect.de)
[08:19:22] *** Joins: Tobba (Tobba@moz-4l45on.skybroadband.com)
[08:21:38] *** Quits: laumann (thomas@moz-3m6.3kq.109.2.IP) (Ping timeout: 121 seconds)
[08:25:07] *** Quits: sigma (sigma@moz-92585k.range217-44.btcentralplus.com) (Ping timeout: 121 seconds)
[08:54:08] *** Joins: killercu_ (killercup@moz-0pf6i8.dip0.t-ipconnect.de)
[08:56:59] *** Quits: killercup (killercup@moz-0pf6i8.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[08:59:18] *** Joins: laumann (thomas@moz-3m6.3kq.109.2.IP)
[09:27:35] *** Quits: Tobba (Tobba@moz-4l45on.skybroadband.com) (A TLS packet with unexpected length was received.)
[10:29:16] *** ChanServ sets mode: +ao Manishearth Manishearth
[10:48:00] <doener> hm, debug info for closures seems wrong, too
[10:55:59] *** Quits: killercu_ (killercup@moz-0pf6i8.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[12:26:30] *** Joins: killercup (killercup@moz-0pf6i8.dip0.t-ipconnect.de)
[14:03:52] *** Joins: Tobba (Tobba@moz-oecqnu.plus.com)
[14:24:54] <eddyb> https://github.com/nikomatsakis/rust/blob/mir/src/librustc_mir/tcx/expr.rs lovely
[14:25:34] <eddyb> nmatsakis: I'm glad you got to use my recent changes :D https://github.com/nikomatsakis/rust/blob/mir/src/librustc_mir/tcx/expr.rs#L210
[14:26:17] <nmatsakis> eddyb: yes, I was happy
[14:26:49] <eddyb> nmatsakis: do you have a plan for constants?
[14:27:19] <nmatsakis> yes and no. I implemented some AST nodes etc, but I was debating about how constant eval should work in a bigger sense --
[14:27:32] <nmatsakis> I'd like to have one constant processor that yields up a kind of AST that everyone can use
[14:27:39] <nmatsakis> and to integrate this better with assoc constants
[14:27:42] <eddyb> nmatsakis: I was considering a scheme for projections where we cache monomorphic constants
[14:27:48] <nmatsakis> I also found some weirdness in how patterns relate to constants that I am rather unhappy about
[14:28:19] <eddyb> and, e.g. in [T; N], N is represented using the expression ID of the N expression + leaf projections
[14:29:26] <eddyb> normalization walks the tree and should end at either monomorphic or projection leaves
[14:29:58] <nmatsakis> well
[14:30:15] <nmatsakis> this sounds roughly like what I was thinking, modulo that I want to be doing normalization more lazily
[14:30:20] <eddyb> it should be fairly cheap if we cache what we already computed
[14:30:23] <eddyb> actually...
[14:30:30] <eddyb> I was considering doing that on ast::Expr
[14:30:41] <eddyb> but with the HIR/MIR, we don't need separate caching
[14:31:12] <eddyb> we can produce trees that have the constant values embedded in them
[14:31:24] <eddyb> ah, but I remember now, I wanted to have no allocations on normalization :D
[14:31:44] <eddyb> nmatsakis: I'd be curious to see how that normalization works
[14:32:02] <eddyb> nmatsakis: maybe like our existing shallow inference variable resolution?
[14:32:17] <nmatsakis> roughly yes. this is what jroesch is working towards.
[14:32:25] <nmatsakis> or one of the things :)
[14:35:20] <eddyb> nmatsakis: did you see that I've put together somewhat of a plan for generators doubling as async/await?
[14:35:29] <eddyb> and the MIR will make it possible
[14:35:36] <eddyb> well, it's a tiny demo, nothing formal
[14:35:36] <nmatsakis> eddyb: I heard you talk about it, but I've not really seen it
[14:35:57] <eddyb> nmatsakis: https://gist.github.com/eddyb/822c658190ccf18058db
[14:36:02] <eddyb> this is what I have so far
[14:36:17] <eddyb> multiple-entry multiple-exit + return
[14:36:22] <eddyb> MEME+R :P
[14:37:00] <eddyb> nmatsakis: I need to write it up though, because I am already confusing myself trying to explain what's going on
[14:40:35] <nmatsakis> eddyb: is this assuming `yield` as a compiler primitive? that seems to be the missing bit of expansion =)
[14:40:47] <eddyb> nmatsakis: I've been dreading it
[14:41:07] <eddyb> that tiny example expands to quite a bit due to yield+ (yield all sub-elements)
[14:41:22] <nmatsakis> the other question that is less clear to me is the type-checker integration
[14:41:23] <eddyb> nmatsakis: I believe it can be expanded to something that runs on 1.0
[14:41:27] *** Quits: Tobba (Tobba@moz-oecqnu.plus.com) (A TLS packet with unexpected length was received.)
[14:41:38] <nmatsakis> it doesn't really come up in your example I guess
[14:42:04] <eddyb> when I started I had no clue how to make async/await use generators
[14:42:06] <nmatsakis> I was concerned about wanting to e.g. iterate over a buffer you own and have that work out,
[14:42:11] <nmatsakis> but the easiest thing is probably ust to prevent
[14:42:17] <nmatsakis> borrows that span a yield
[14:42:23] <nmatsakis> at least under some conditions
[14:42:35] <eddyb> yes, that's necessary, at least initially
[14:42:38] <nmatsakis> you could permit borrows as long as you know caller will yield too
[14:42:46] <nmatsakis> that is, if you have a delimited continuation,
[14:43:07] <nmatsakis> you can allow a borrow under some conditions as long as the data is "encapsulated"
[14:43:12] <nmatsakis> but then you get into concerns about stack alloc etc
[14:43:19] <nmatsakis> and distinguishing what's in a stable address from what's not
[14:43:19] <eddyb> you mean, known indirecation?
[14:43:30] <eddyb> like that crazy '*a suggestion from a while back
[14:43:33] <nmatsakis> yes right
[14:44:00] <nmatsakis> certianly easiest to just forbid borrows for now but it'd be nice to be able to do something like an iterator
[14:44:09] <eddyb> you can still do a lot with linear data manipulation
[14:44:12] <nmatsakis> (seems plausibl)
[14:44:16] <nmatsakis> oh, yes, I know
[14:44:18] <eddyb> Vec::into_iter would work, for example
[14:44:53] <eddyb> nmatsakis: IMO the borrowck would see the desugared code
[14:44:59] <eddyb> where each yield point is a return
[14:45:57] <nmatsakis> that's the key question :)
[14:46:02] <nmatsakis> it is the ideal situation
[14:46:34] <eddyb> returning the state or having self.state = BB123 { ... }; will trigger the usual "doesn't live long enough"
[14:47:07] <eddyb> I'm a bit more worried about generating types and impls after/during typeck
[14:47:27] <eddyb> that aren't in the source code
[14:51:33] <eddyb> nmatsakis: would the SWITCH terminator have ranges?
[14:52:08] <nmatsakis> eddyb: it could, I didn't add that yet
[14:52:20] <eddyb> nmatsakis: then you might be able to use it instead of LEN :D
[14:53:52] <eddyb> easier to validate it, too
[14:54:17] <eddyb> if all union-type unsafe-ish access goes through a switch
[14:55:23] *** Joins: brson (brson@moz-cfhap5.mtv2.mozilla.com)
[14:55:23] *** ChanServ sets mode: +qo brson brson
[14:56:24] <eddyb> nmatsakis: yeah, so, you can collapse the cases here to 1: https://github.com/nikomatsakis/rfcs/blob/mir/text/0000-mir.md#unchecked-assertions
[14:57:16] <eddyb> nmatsakis: you could even have SWITCH be safe by creating a new variable with the downcast type, but! this only works for enums
[14:58:01] <eddyb> you'd need some subset of dependent types to make it work for bounds-checking
[14:58:44] *** Joins: achanda (achanda@moz-qv7q4n.ca.comcast.net)
[14:59:52] <eddyb> "... or modify the MIR to thread "evidence" of some form that makes it easier to check that the properties hold"
[15:00:07] <eddyb> I like this for a formal proof future
[15:06:09] *** Quits: achanda (achanda@moz-qv7q4n.ca.comcast.net) (Connection closed)
[15:19:41] *** Joins: arielb1 (Ariel@moz-b95g78.red.bezeqint.net)
[16:41:17] *** Quits: laumann (thomas@moz-3m6.3kq.109.2.IP) (Ping timeout: 121 seconds)
[17:23:22] *** Quits: arielb1 (Ariel@moz-b95g78.red.bezeqint.net) (Quit: Ex-Chat)
[17:29:55] *** Joins: achanda (achanda@moz-m7s4h8.static.monkeybrains.net)
[17:40:30] *** Joins: arielb1 (Ariel@moz-b95g78.red.bezeqint.net)
[17:41:14] *** Quits: achanda (achanda@moz-m7s4h8.static.monkeybrains.net) (Connection closed)
[17:41:34] *** Joins: achanda (achanda@moz-m7s4h8.static.monkeybrains.net)
[18:13:32] <doener> pnkfelix: btw, gh27025 has the debuginfo fixes for the crash with -g -O. There's still something wrong with DI for closures (I think), but that's for another day...
[18:14:13] *** Quits: doener (doener@moz-fnh.n4j.147.5.IP) (Quit: leaving)
[18:25:30] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[18:48:23] *** Quits: [o__o] ([o__o]@moz-4s2t5k.compute-1.amazonaws.com) (Ping timeout: 121 seconds)
[19:17:31] *** Joins: achanda_ (achanda@moz-fr1.spq.217.162.IP)
[19:17:31] *** Quits: achanda (achanda@moz-m7s4h8.static.monkeybrains.net) (Connection closed)
[19:19:01] *** Quits: barosl (barosl@moz-tmp.qma.67.220.IP) (Quit: Leaving)
[19:33:33] *** Quits: achanda_ (achanda@moz-fr1.spq.217.162.IP) (Ping timeout: 121 seconds)
[19:35:05] *** Joins: achanda (achanda@moz-fr1.spq.217.162.IP)
[19:39:56] *** Joins: barosl (barosl@moz-tmp.qma.67.220.IP)
[19:42:48] *** Joins: killercu_ (killercup@moz-icpsbi.dip0.t-ipconnect.de)
[19:44:26] *** Quits: killercup (killercup@moz-0pf6i8.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[19:47:36] *** Quits: achanda (achanda@moz-fr1.spq.217.162.IP) (Connection closed)
[19:47:37] *** Joins: [o__o] ([o__o]@moz-4s2t5k.compute-1.amazonaws.com)
[20:38:35] *** Joins: achanda (achanda@moz-fr1.spq.217.162.IP)
[20:54:57] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[21:27:27] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[22:01:40] *** Joins: Tobba (Tobba@moz-o13d22.bredband.telia.com)
[22:08:03] *** Quits: killercu_ (killercup@moz-icpsbi.dip0.t-ipconnect.de) (Ping timeout: 121 seconds)
[22:09:00] *** Joins: killercup (killercup@moz-icpsbi.dip0.t-ipconnect.de)
[22:20:06] <jroesch> eddyb: do you know how cross crate spans are handled in the compiler? Niko suggested I directly attach this span I need to TypeParameterDef but it appears that no span are serialized in metadata, unless I'm missing something (very probable) 
[22:23:47] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[22:28:07] <eddyb> jroesch: you aren't missing anything :D
[22:28:16] <eddyb> the only spans that I can think of are in exported macros
[22:28:35] <jroesch> So I should probably modify the ast_map instead? was hoping to avoid this
[22:28:37] <jroesch> but alas
[22:28:52] <jroesch> so close to having nice error reporting for defaults 
[22:28:58] <jroesch> just need one pesky span
[22:34:08] <eddyb> jroesch: why ast_map in particular?
[22:34:23] <jroesch> I just need to be able to map back from TypeParameterDef to a Span
[22:34:28] <eddyb> jroesch: maybe astencode... but it would be too much work, I'm afraid. actually, hmm
[22:34:47] <jroesch> I'm not too particular where it happens
[22:35:03] <eddyb> ast_map just holds the data, it's not reponsible for the span loss
[22:35:24] <eddyb> it might be hidden in codemap::Span's Encodable/Decodable impls
[22:35:33] <jroesch> well the map doesn't contain TypeParameterDefs at all
[22:35:44] <jroesch> so you can't even find the Item, which I would be okay with for the time being
[22:35:56] <jroesch> vs. highlighting the exact default 
[22:40:18] *** Quits: arielb1 (Ariel@moz-b95g78.red.bezeqint.net) (Quit: Ex-Chat)
[22:55:58] <eddyb> jroesch: hmm, can you get anything useful, like the ID of the default's ast::Ty node?
[22:56:52] <eddyb> jroesch: even if you modify ast_map (which would be fine with me), you wouldn't get cross-crate spans for free
[22:57:30] <jroesch> I mean I have the Ty node via `def.default.ty`
[22:57:38] <jroesch> is that enough?
[22:59:48] <huon> is there a particular reason that get_intrinsic takes `'static` `&str`s?
[23:00:57] <eddyb> huon: none whatsoever IIRC
[23:01:03] <eddyb> other than maybe caching?
[23:03:01] <eddyb> jroesch: can you get def.default.ty.id?
[23:04:43] *** Joins: laumann (thomas@moz-n9e72h.0.fullrate.dk)
[23:06:06] <jroesch> eddyb: is id a method on ty::Ty or would I need to pattern match to get at it?
[23:06:15] <eddyb> jroesch: it's a field
[23:06:17] <eddyb> oh
[23:06:29] <eddyb> jroesch: I forgot middle::ty::Ty was named Ty
[23:06:34] <eddyb> I was hoping you meant ast::Ty
[23:06:40] <eddyb> jroesch: the ID is lost by astconv
[23:06:46] <jroesch> well before I convert the TypeParameDef
[23:06:51] <jroesch> I believe I have an ast.Ty
[23:06:53] <jroesch> ast::TY*
[23:07:20] <eddyb> jroesch: you could cache the default's ast::Ty DefId in TypeParameterDef
[23:07:37] *** Quits: killercup (killercup@moz-icpsbi.dip0.t-ipconnect.de) (Quit: My Mac has gone to sleep. ZZZzzz…)
[23:07:51] <jroesch> is it possible to fully translate to a span there? or is that a problem inside of collect 
[23:09:12] <jroesch> so I have the required data to get the def_id of the ast::Ty
[23:09:16] <jroesch> err node_id
[23:10:00] <eddyb> local_def(node_id) to get a DefId. astencode would be responsible for translating that DefId after reading it from some external crate (all DefId's are local when initially created)
[23:10:13] <eddyb> jroesch: and you can get a span in the local crate
[23:10:19] <eddyb> otherwise there are no spans
[23:10:20] <jroesch> right, that makes sense
[23:10:36] <eddyb> jroesch: one reason would be... that there is no source!
[23:12:56] <jroesch> yeah this error message will be problematic if you call code outside the crate then ... 
[23:13:44] <eddyb> jroesch: you could fall back to getting the path of the enclosing item
[23:13:53] <eddyb> and the name of the type param where it can from
[23:14:16] <eddyb> "default for type parameter `H` of `std::collections::has_map::HashMap`"
[23:14:17] *** Quits: laumann (thomas@moz-n9e72h.0.fullrate.dk) (Ping timeout: 121 seconds)
[23:15:43] <jroesch> so I could instead of using a raw def_id wrap it in enum that is the def_id if local and the path if not 
[23:17:50] <eddyb> jroesch: where?
[23:18:01] <jroesch> inside the TypeParameterDef 
[23:18:03] <eddyb> no
[23:18:07] <eddyb> paths are not serialized
[23:18:17] <eddyb> they are always printed from DefId's
[23:18:34] <jroesch> okay is there a way to check if they are non-local or not? 
[23:20:40] <eddyb> jroesch: use something like opt_span
[23:21:00] <eddyb> (the check for locality is just def_id.krate == LOCAL_CRATE, but it's nicer not to do it manually)
[23:21:18] <jroesch> okay cool, I think I have enough to implement this then 
[23:21:28] <jroesch> as always thanks for guiding me around the compiler 
[23:21:48] <eddyb> jroesch: or maybe always print name + path with optional span (maybe a span_note "note: defined here")
[23:22:42] <jroesch> yeah currently it looks like this (modulo some tweaks to formatting and the dummy spans, which are what I'm trying to fix) https://gist.github.com/jroesch/b592404b7fc8faa1752a
[23:41:54] *** Joins: aatch (james@moz-i1k1ks.tlms.2o1v.e006.2406.IP)
[23:52:12] *** Joins: Rym (uid91135@moz-n2i7qm.charlton.irccloud.com)

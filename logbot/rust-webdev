2018-01-14T20:59:12 #rust-webdev <logbot> channel logging requested by sfackler: https://mozilla.logbot.info/rust-webdev
2018-01-14T23:04:08 #rust-webdev <sfackler> uh
2018-01-14T23:55:49 #rust-webdev <dowwie> hey sfackler
2018-01-14T23:55:57 #rust-webdev <sfackler> hey
2018-01-14T23:56:09 #rust-webdev <dowwie> can I pm you?  it's off topic!
2018-01-14T23:56:25 #rust-webdev <sfackler> sure
2018-01-17T02:14:09 #rust-webdev <mib_ni617z> hi
2018-01-17T02:15:57 #rust-webdev <mib_ni617z> did someone got rocket run fine using x86_64-pc-windows-gnu nightly ?
2018-01-17T02:16:48 #rust-webdev <Sergio> You need MSVC
2018-01-17T02:17:05 #rust-webdev <mib_ni617z> it look like I do 
2018-01-17T02:17:20 #rust-webdev <Sergio> I don't believe you can build ring with the gnu tool chain on windows 
2018-01-17T02:17:28 #rust-webdev <mib_ni617z> so mingw is unusable ?
2018-01-17T02:17:39 #rust-webdev <mib_ni617z> yes it builds
2018-01-17T02:18:17 #rust-webdev <mib_ni617z> wrk -c 4000 -d 10s -t 12 http://192.168.0.1:8000 works once
2018-01-17T02:18:28 #rust-webdev <mib_ni617z> then I get unable to connect to 192.168.0.1:8000 Connection refused
2018-01-17T02:18:43 #rust-webdev <mib_ni617z> hello_world ....
2018-01-17T02:19:34 #rust-webdev <mib_ni617z> while wrk -c 40 -d 10s -t 12 http://192.168.0.1:8000 doesn't erod the payload orbit :)
2018-01-17T02:23:53 #rust-webdev <mib_ni617z> it works fine compiling targeting x86_64-unknown-linux-gnu  ubuntu wsl
2018-01-17T02:33:27 #rust-webdev <mib_ni617z> getting rust msvc hope it will work using 19.13.26110.1
2018-01-17T02:43:13 #rust-webdev <mib_ni617z> hell msvc uses winapi-x86_64-pc-windows-gnu ?
2018-01-17T02:47:27 #rust-webdev <mib_ni617z> err crypto/aes/aes.c:1:0: sorry, unimplemented: 64-bit mode not compiled in
2018-01-17T02:47:54 #rust-webdev <mib_ni617z> chatting I mean pasting the log ...
2018-01-17T03:05:29 #rust-webdev <mib_ni617z> err info: component 'rust-std' for target 'x86_64-pc-windows-msvc' is up to date
2018-01-17T03:05:52 #rust-webdev <mib_ni617z> but doing  rustup toolchain install nightly-x86_64-pc-windows-msvc
2018-01-17T03:43:34 #rust-webdev <mib_ni617z> NO
2018-01-17T03:43:53 #rust-webdev <mib_ni617z> get the same behavior using msvc
2018-01-17T03:44:27 #rust-webdev <mib_ni617z> somewhat good somewhat bad
2018-01-17T03:46:30 #rust-webdev <mib_ni617z> both msvc and mingw stop responding with wrk -c 4000 -d 10s -t 12 http://192.168.0.1:8000 repeated twice against rocket/examples/hello_world
2018-01-17T03:48:48 #rust-webdev <mib_ni617z> oops
2018-01-17T04:08:53 #rust-webdev <mib_ni617z> seems connections are left opened ....
2018-01-17T04:13:56 #rust-webdev <mib_ni617z> so not sure yet but both mingw  and msvc x86_64  might be ok more a rocket issue
2018-01-18T03:00:36 #rust-webdev <YungMoonHodler> steveklabnik: how can a rust exe be made scriptable with wasm?
2018-01-18T03:21:42 #rust-webdev <rovar> YungMoonHodler:  There are some wasm interpreters out that are aiming at that.. I don't know how mature they are, though. 
2018-01-18T03:22:19 #rust-webdev <YungMoonHodler> rovar: any in rust?
2018-01-18T03:22:39 #rust-webdev <YungMoonHodler> is wasm even browser independent enough?
2018-01-18T03:23:57 #rust-webdev <rovar> this has an interpreter :  https://github.com/paritytech/parity-wasm   
2018-01-18T03:24:07 #rust-webdev <rovar> it's "experimental"
2018-01-18T04:22:53 #rust-webdev <YungMoonHodler> rovar: wasm on the blockchain?
2018-01-18T04:24:57 #rust-webdev <rovar> probably.. not sure.. 
2018-01-18T05:12:20 #rust-webdev <steveklabnik> YungMoonHodler: rovar is right
2018-01-18T05:12:32 #rust-webdev <YungMoonHodler> ok
2018-01-18T17:03:22 #rust-webdev <halzy> git status
2018-01-18T17:03:26 #rust-webdev <halzy> Ap
2018-01-18T17:03:29 #rust-webdev <halzy> :p
2018-01-19T10:16:43 #rust-webdev <steveeJ> when using capnproto for data transfer, what's a good data model/storage within the services?
2018-01-20T01:51:37 #rust-webdev <mib_6ifxc7> hi got mingw rust compiling using gcc 7.2 :)
2018-01-21T03:19:39 #rust-webdev <YungMoonHodler> steveklabnik: https://image.prntscr.com/image/hH9W11axQpGPCvGT-TFGVw.png
2018-01-21T16:01:37 #rust-webdev <steveklabnik> :D
2018-01-22T21:49:31 #rust-webdev <WindowsBunny> When I set the default headers on a ClientBuilder in reqwest, are there any default headers by default that I would be overriding?
2018-01-22T21:53:09 #rust-webdev <sfackler> WindowsBunny: it looks like it by default sets a user agent and `Accept: *`
2018-01-22T21:53:44 #rust-webdev <sfackler> it'll also set AcceptEncoding if you enable gzip
2018-01-22T21:54:54 #rust-webdev <WindowsBunny> and gzip is enabled by default
2018-01-22T21:55:11 #rust-webdev <WindowsBunny> so if I wanted a custom user agent I'd have to explicitly specify `Accept: *` still?
2018-01-22T21:56:38 #rust-webdev <sfackler> probably best to
2018-01-22T22:03:37 #rust-webdev <WindowsBunny> or I could just manually set the headers on each request
2018-01-23T03:13:35 #rust-webdev <Psilidae> l7G5j6kz6YMmxFqfPH
2018-01-23T18:55:45 #rust-webdev <seanmonstar> WindowsBunny: no, you don't need to set those headers again if you want the default
2018-01-23T18:56:11 #rust-webdev <seanmonstar> the default_headers config will merge your supplied headers with the library defaults
2018-01-23T18:56:27 #rust-webdev <seanmonstar> so, if you don't change User-Agent of Accept, the lib defaults will be used
2018-01-23T18:58:12 #rust-webdev <WindowsBunny> ah okay, that's good to know
2018-01-23T18:58:20 #rust-webdev <WindowsBunny> should probably be clarified in the documentation
2018-01-25T01:26:24 #rust-webdev <sfackler> seanmonstar: why is this impl for &str rather than just str? https://docs.rs/hyper/0.11.15/src/hyper/uri.rs.html#277-281
2018-01-25T01:34:30 #rust-webdev <seanmonstar> probably a mistake
2018-01-25T01:35:13 #rust-webdev <sfackler> i'll add the str impl
2018-01-25T04:57:27 #rust-webdev <mib_fozyi1> 你好
2018-01-25T17:31:06 #rust-webdev <sfackler> seanmonstar: has there been any work on moving the typed header interface on top of http::HeaderMap?
2018-01-25T17:31:34 #rust-webdev <seanmonstar> not much
2018-01-25T17:32:49 #rust-webdev <seanmonstar> i tried to start a couple weeks ago. i thought that since HeaderMap is actually generic over it's value, it might be a neat feature to be able to map in place to a different type, which could even use the same memory if the types are the same size
2018-01-25T17:34:57 #rust-webdev <sfackler> that seems a bit scary :P
2018-01-25T17:35:13 #rust-webdev <seanmonstar> then you don't have to realloc or rehash :D
2018-01-25T17:35:22 #rust-webdev <sfackler> how much of an impact do you think there would be to not caching the parsed values at all?
2018-01-25T17:35:41 #rust-webdev <sfackler> then it'd just be a simple wrapper around the normal headermap that serializes/deserializes
2018-01-25T17:35:43 #rust-webdev <seanmonstar> yea, that's an avenue
2018-01-25T17:35:58 #rust-webdev <seanmonstar> it's probably fine
2018-01-25T17:36:21 #rust-webdev <seanmonstar> i mean, that's how dealing with string headers works anyways, right
2018-01-25T17:41:54 #rust-webdev <seanmonstar> sfackler: actually, i was just about to write up this issue: what crate should try to improve TLS throughput? should hyper try to notice and change its write size, or should that be left to whatever AsyncWrite is used?
2018-01-25T17:42:39 #rust-webdev <sfackler> maximizing throughput by buffering to the max record size?
2018-01-25T17:43:47 #rust-webdev <seanmonstar> no
2018-01-25T17:44:47 #rust-webdev <seanmonstar> there's some documented heuristics that try to send small records at first, and only ramping up to 16kb if streaming a large body
2018-01-25T17:45:48 #rust-webdev <seanmonstar> to allow the recipient to decode the headers and maybe the start of the document without waiting for 16kb
2018-01-25T17:46:57 #rust-webdev <seanmonstar> thinking about it, it does seem more specific to http than to just generally anyone using TLS
2018-01-25T18:05:11 #rust-webdev <sfackler> well hyper will already send the headers out in a single record first, right?
2018-01-25T18:06:42 #rust-webdev <sfackler> but if it's http specific I guess hyper would need to manage it
2018-01-25T18:08:33 #rust-webdev <seanmonstar> hyper tries to include the headers and first chunk in a single write, currently
2018-01-25T18:08:47 #rust-webdev <seanmonstar> for small responses, its much faster than 2 writes
2018-01-25T18:28:07 #rust-webdev <sfackler> am I a bad person if I make a hybrid hyper/h2 client by tunneling the socket out of Hyper's internals inside of an error if ALPN negotiation picks h2? :P
2018-01-25T18:28:48 #rust-webdev <seanmonstar> i er wat
2018-01-25T18:31:18 #rust-webdev <sfackler> actually nevermind
2018-01-25T18:31:21 #rust-webdev <sfackler> that's a bad idea >_>
2018-01-25T18:32:41 #rust-webdev <seanmonstar> sfackler: are you implying you'd like hyper to gain h2 support sooner? :D
2018-01-25T18:32:59 #rust-webdev <sfackler> rather than later for sure :P
2018-01-25T18:33:26 #rust-webdev <seanmonstar> what do you think of what i mentioned around versioning?
2018-01-25T18:33:38 #rust-webdev <sfackler> opting in via a feature? seems fine
2018-01-25T18:33:42 #rust-webdev <seanmonstar> should 0.11 gain h2 through a feature?
2018-01-25T18:33:48 #rust-webdev <sfackler> something like that already exists for http crate integration, right?
2018-01-25T18:33:53 #rust-webdev <seanmonstar> yep
2018-01-25T18:34:00 #rust-webdev <sfackler> I might just bump to 0.12 though
2018-01-25T18:34:16 #rust-webdev <seanmonstar> thats also a possibility
2018-01-25T18:34:22 #rust-webdev <sfackler> although
2018-01-25T18:34:29 #rust-webdev <seanmonstar> "breaking changes" can be hard for hyper tho
2018-01-25T18:34:41 #rust-webdev <sfackler> what do you think about having a dedicated http/1.1 crate, the h2 crate, and a third crate that multiplexes?
2018-01-25T18:35:28 #rust-webdev <seanmonstar> carllerche has mentioned also the idea of maybe moving the h1 internals (after a refactor) to a dedicated crate, and then hyper joins h1 + h2 + service
2018-01-25T18:35:35 #rust-webdev <sfackler> yeah
2018-01-25T18:36:02 #rust-webdev <sfackler> it seems like making something that supports both transparently is a somewhat nontrivial API problem
2018-01-25T18:36:13 #rust-webdev <sfackler> so having all of the bits available would allow for more iteration
2018-01-25T18:36:34 #rust-webdev <seanmonstar> im not especially against it... at the moment, it just seems like more work to actually release a h1 crate, than to just live with a submodule in hyper
2018-01-25T18:37:13 #rust-webdev <sfackler> I mean, the initial release of h1 could literally be the contents of hyper copied over verbatim, right?
2018-01-25T18:39:13 #rust-webdev <seanmonstar> there'd definitely be a refinement and exposing of more internals, and then likely some breakages as we find the exposed internals arent flexible enough, and anyone depending on h1 specifically will hate me :D
2018-01-25T18:39:25 #rust-webdev <sfackler> haha
2018-01-25T18:39:38 #rust-webdev <seanmonstar> with it being a submodule, i can peak into implementation details, and change them since they aren't exposed
2018-01-25T18:43:20 #rust-webdev <sfackler> I am maybe more okay than most people about crates with frequent breaking changes as long as they call it out explicitly
2018-01-25T18:43:43 #rust-webdev <sfackler> if both projects live in the same repo you don't need to worry about publishing stuff from h1 before you can use it in hyper
2018-01-25T18:44:44 #rust-webdev <seanmonstar> thats true
2018-01-25T18:44:52 #rust-webdev <seanmonstar> i suspect it will probably happen
2018-01-25T18:45:19 #rust-webdev <seanmonstar> i'd need help fomr someone if we wanted it sooner
2018-01-25T18:46:14 #rust-webdev <sfackler> I should be able to help out with this stuff
2018-01-25T18:46:26 #rust-webdev <sfackler> I don't feel super strongly about h1 as a crate in particular though
2018-01-25T18:46:40 #rust-webdev <sfackler> like, it needing to happen immediately
2018-01-25T18:46:46 #rust-webdev <seanmonstar> what do you mean
2018-01-25T18:47:00 #rust-webdev <seanmonstar> didn't you just convince me of its usefulness? :D
2018-01-25T18:47:06 #rust-webdev <sfackler> it's definitely useful!
2018-01-25T18:47:10 #rust-webdev <sfackler> just not necessary :P
2018-01-25T18:49:34 #rust-webdev <seanmonstar> if you have some time to spend on hyper, is there something specific you'd like to see implemented with that time?
2018-01-25T21:05:12 #rust-webdev <sfackler> seanmonstar: I'm starting to prototype a typed header layer for http right now, but the goal is to be able to run http1/http2 clients and servers in a reasonable way
2018-01-25T21:28:44 #rust-webdev <sfackler> seanmonstar: why are InvalidHeaderValue and InvalidHeaderValueBytes distinct types?
2018-01-25T21:30:22 #rust-webdev <sfackler> i'm confused as to why only from_shared returns InvalidHeaderValueBytes
2018-01-25T21:31:06 #rust-webdev <seanmonstar> they are analogous to String::from_utf8 and str::from_utf8
2018-01-25T21:31:36 #rust-webdev <seanmonstar> we might want to be able to return the bytes back in the error
2018-01-25T21:31:42 #rust-webdev <sfackler> oh
2018-01-25T22:12:23 #rust-webdev <sfackler> seanmonstar: how does this seem as an initial API sketch? https://github.com/sfackler/http-headers/blob/master/src/lib.rs
2018-01-26T00:34:02 #rust-webdev <sfackler> seanmonstar: in what cases can HeaderValue::to_str return Err? Don't all of the constructors perform the visible ascii check as well?
2018-01-26T00:35:14 #rust-webdev <sfackler> or I guess all but from_shared_unchecked, but why is that unsafe then if HeaderValue is allowed to contain other bytes?
2018-01-26T00:40:08 #rust-webdev <seanmonstar> sfackler: no, header value don't have to be visible ascii
2018-01-26T00:40:32 #rust-webdev <sfackler> so why is from_shared_unchecked unsafe?
2018-01-26T00:40:32 #rust-webdev <seanmonstar> they can e visible ascii, or any other octet over 127 and encoding is unknown :D
2018-01-26T00:40:57 #rust-webdev <seanmonstar> because they definitely cant have control characters
2018-01-26T00:41:05 #rust-webdev <sfackler> oh
2018-01-26T00:41:34 #rust-webdev <sfackler> so from_bytes is less restrictive than from_str
2018-01-26T00:42:04 #rust-webdev <sfackler> ok thanks
2018-01-26T00:42:30 #rust-webdev <seanmonstar> yea thats it
2018-01-26T00:42:49 #rust-webdev <sfackler> it's a bit weird since str can contain control characters
2018-01-26T00:42:52 #rust-webdev <seanmonstar> maybe should be explained more in the docs
2018-01-26T00:43:15 #rust-webdev <seanmonstar> whats weird?
2018-01-26T00:43:18 #rust-webdev <sfackler> yeah I think if there was a paragraph at the type level that explained it it'd be fine
2018-01-26T00:43:34 #rust-webdev <sfackler> the fact that from_static and from_str only allow visible ascii
2018-01-26T00:57:24 #rust-webdev <sfackler> in what context do you have a &'static hostname for Host?
2018-01-26T19:44:08 #rust-webdev <sfackler> seanmonstar: it seems like RFC 2616 does allow for multiline header values, but I think hyper and http both explicitly disallow them. was that functionality removed in a later RFC or is it just not a thing anyone does?
2018-01-26T19:47:01 #rust-webdev <sfackler> ah looks like it was obsoleted by 7230
2018-01-26T19:49:16 #rust-webdev <fralix> is it possible to use staticfile in iron but still use something like iron to get another name for the file?
2018-01-26T19:49:16 #rust-webdev <fralix> I want something like /a/hallo.png to be forwarded to 1234.png based on database rules.
2018-01-26T19:51:52 #rust-webdev <sfackler> fralix: I don't think you can use staticfile for that
2018-01-26T19:52:07 #rust-webdev <sfackler> but you could copy over the bits that do the file load
2018-01-26T21:08:32 #rust-webdev <glyn> I'm looking at porting an HTTP gateway from Go to Rust and wonder if Iron is the best tool for the job or whether it might be more straightforward to use hyper or something else. The gateway needs to send messages to some Kafka topics and wait for replies on other Kafka topics, so it needs to run multiple threads of execution. I was thinking or using something like Rayon threads communicating via channels to mirror the structure of t
2018-01-26T21:08:32 #rust-webdev <glyn> he Go code. Any advice greatfully received on this general direction and which of these libraries mix well and which don't.
2018-01-26T21:18:18 #rust-webdev <glyn> Hmmm. It's a bit quiet here. I'll try elsewhere.
2018-01-26T21:25:38 #rust-webdev <Faux> Iron is kinda abandoned. Hyper is insane unless you're super committed. Rocket may not be sufficiently flexible.
2018-01-26T21:35:39 #rust-webdev <glyn> Faux: Thanks. It's hard to tell what's current and what's abandoned. How about tokio plus futures as a general approach?
2018-01-26T21:35:57 #rust-webdev <steveklabnik> that's whta you'd be doing with pure hyper
2018-01-26T21:36:09 #rust-webdev <steveklabnik> pure hyper is not *bad*, but it's a library, not a framework, so you do a lot of stuff yourself
2018-01-26T21:36:13 #rust-webdev <steveklabnik> i have been meaning to try gotham
2018-01-26T21:36:29 #rust-webdev <carllerche> hyper is just an http lib... you are on your own past that
2018-01-26T21:36:40 #rust-webdev <Faux> I hear a rumour that it's possible to actually use hyper, yeah. :)
2018-01-26T21:37:47 #rust-webdev <glyn> hyper sounds like it might be the best fit for the HTTP side. What about lightweight threads with channels? Does hyper provide such threads?
2018-01-26T21:38:07 #rust-webdev <steveklabnik> it uses tokio, which does something roughly equivalent
2018-01-26T21:38:12 #rust-webdev <steveklabnik> that is, it's async io
2018-01-26T21:38:23 #rust-webdev <steveklabnik> not via the same mechanism as go, closer to the mechanism of node
2018-01-26T21:38:43 #rust-webdev <steveklabnik> (and the standard library provides channels)
2018-01-26T21:42:18 #rust-webdev <glyn> Ok, thanks. That's avoided me some apparent dead ends.
2018-01-26T21:50:20 #rust-webdev <sfackler> seanmonstar: did you remember why you changed the ContentLength parser to allow rather than reject duplicate headers? https://github.com/hyperium/hyper/commit/31f117ea08c01889016fd45e7084e9a049c53f7a
2018-01-26T21:53:07 #rust-webdev <sfackler> both behaviors are allowed
2018-01-26T21:55:42 #rust-webdev <seanmonstar> sfackler: sorry what
2018-01-26T21:55:57 #rust-webdev <seanmonstar> `Content-Length: 10\r\nContent-Length: 10\r\n` is valid and should be 10
2018-01-26T21:56:27 #rust-webdev <seanmonstar> but if there are duplicate headers and the values differ, its doom
2018-01-26T21:56:32 #rust-webdev <sfackler> 7230 says that recipients must *either* replace it with a single field or reject it
2018-01-26T21:57:38 #rust-webdev <sfackler> > If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a  list of identical decimal values (e.g., "Content-Length: 42, 42"), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either
2018-01-26T21:57:38 #rust-webdev <sfackler> reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.
2018-01-26T21:59:07 #rust-webdev <seanmonstar> oh, so you're asking why it changed from rejecting to allowing in that commit?
2018-01-26T21:59:11 #rust-webdev <sfackler> yeah
2018-01-26T21:59:46 #rust-webdev <seanmonstar> i truly don't remember. i figure i was thinking along the lines of robustness, don't error
2018-01-26T22:00:20 #rust-webdev <sfackler> cool - i'm kind of curious if there exist any implementations that will actually do that
2018-01-26T22:00:33 #rust-webdev <sfackler> I guess there must have been at some point for that special case to have been defined?
2018-01-26T22:01:55 #rust-webdev <sfackler> ha, apparently there are! https://github.com/request/request/issues/2091#issuecomment-328715113
2018-01-26T22:02:08 #rust-webdev <sfackler> the world is truly a terrifying place
2018-01-27T00:13:10 #rust-webdev <seanmonstar> sfackler: spent some time today trying to figure out how to get alpn support in hyper
2018-01-27T00:13:35 #rust-webdev <sfackler> yeah I saw the pr
2018-01-27T00:13:44 #rust-webdev <sfackler> I think that approach makes sense
2018-01-27T00:14:25 #rust-webdev <sfackler> does the connector need to care about need vs prefer h2?
2018-01-27T00:14:40 #rust-webdev <sfackler> as in, can the connector not just know it should look for h2 support and return whatever it finds?
2018-01-27T00:17:46 #rust-webdev <seanmonstar> i don't quite understand the last question
2018-01-27T00:18:28 #rust-webdev <seanmonstar> as for need vs prefer, i think the difference is whether the client alpn sends `http1.1,h2`, or just `h2`
2018-01-27T00:18:42 #rust-webdev <sfackler> oh sure
2018-01-27T00:23:51 #rust-webdev <sfackler> and for h2c you wouldn't ask the connector for any of that?
2018-01-27T00:28:13 #rust-webdev <seanmonstar> nah, h2c just uses http upgrades
2018-01-27T00:42:20 #rust-webdev <bdax> anyone know how rouille and actix-web compare? they seem pretty similar, any reason to prefer one over the other?
2018-01-27T14:46:05 #rust-webdev <steveklabnik> i know actix is based on actors
2018-01-27T14:46:10 #rust-webdev <steveklabnik> and rouille isn't
2018-01-27T14:46:13 #rust-webdev <steveklabnik> that's about it
2018-01-30T01:27:48 #rust-webdev <seanmonstar> just made a successful h2 request in hyper!
2018-01-30T01:28:01 #rust-webdev <seanmonstar> (granted, error handling is a bunch of 'unimplemented!()'s)
2018-01-30T01:28:35 #rust-webdev <sfackler> :D
2018-01-30T01:29:01 #rust-webdev <seanmonstar> sfackler: does your use case need http/1 upgrades to h2?
2018-01-30T01:29:11 #rust-webdev <sfackler> nope, all tls all the time
2018-01-30T01:29:35 #rust-webdev <seanmonstar> do you use tokio-tls?
2018-01-30T01:40:48 #rust-webdev <sfackler> no, tokio-openssl
2018-01-30T01:41:01 #rust-webdev <sfackler> tokio-tls isn't going to work with http2
2018-01-30T01:41:09 #rust-webdev <sfackler> unless someone yells at apple enough :P
2018-01-30T01:41:11 #rust-webdev <seanmonstar> oh?
2018-01-30T01:41:23 #rust-webdev <sfackler> security framework doesn't expose alpn
2018-01-30T01:41:31 #rust-webdev <seanmonstar> wat
2018-01-30T01:41:35 #rust-webdev <carllerche> yeah
2018-01-30T01:41:37 #rust-webdev <sfackler> in tyool 2018
2018-01-30T01:41:38 #rust-webdev <carllerche> only openssl and rustls
2018-01-30T01:42:52 #rust-webdev <seanmonstar> oh well, then those should be able to use the proposed Connect trait to expose alpn and h2 connecting
2018-01-30T01:44:34 #rust-webdev <WindowsBunny> sfackler: you mean not on apple? or does that block it from working on any platform?
2018-01-30T01:45:16 #rust-webdev <sfackler> WindowsBunny: I want to expose a platform independent interface
2018-01-30T01:45:31 #rust-webdev <sfackler> if one of the features unconditionally fails on osx that seems bad
2018-01-30T01:45:46 #rust-webdev <WindowsBunny> solution: migrate everyone off of OS X?
2018-01-30T04:34:32 #rust-webdev <dgwefgsf> t
2018-01-30T04:34:32 #rust-webdev <dgwefgsf> h
2018-01-30T04:34:33 #rust-webdev <dgwefgsf> e
2018-01-30T04:34:33 #rust-webdev <dgwefgsf> c
2018-01-30T04:34:34 #rust-webdev <dgwefgsf> h
2018-01-30T04:34:34 #rust-webdev <dgwefgsf> a
2018-01-30T04:34:35 #rust-webdev <dgwefgsf> n
2018-01-30T04:34:35 #rust-webdev <dgwefgsf> n
2018-01-30T04:34:36 #rust-webdev <dgwefgsf> e
2018-01-30T04:34:36 #rust-webdev <dgwefgsf> l
2018-01-30T04:34:37 #rust-webdev <dgwefgsf> n
2018-01-30T04:34:38 #rust-webdev <dgwefgsf> a
2018-01-30T04:34:38 #rust-webdev <dgwefgsf> m
2018-01-30T04:34:39 #rust-webdev <dgwefgsf> e
2018-01-30T04:34:39 #rust-webdev <dgwefgsf> i
2018-01-30T04:34:40 #rust-webdev <dgwefgsf> s
2018-01-30T04:34:41 #rust-webdev <dgwefgsf> r
2018-01-30T04:34:42 #rust-webdev <dgwefgsf> u
2018-01-30T04:34:42 #rust-webdev <dgwefgsf> s
2018-01-30T04:34:43 #rust-webdev <dgwefgsf> t
2018-01-30T04:34:43 #rust-webdev <dgwefgsf> -
2018-01-30T04:34:44 #rust-webdev <dgwefgsf> w
2018-01-30T04:34:45 #rust-webdev <dgwefgsf> e
2018-01-30T04:34:46 #rust-webdev <dgwefgsf> b
2018-01-30T04:34:46 #rust-webdev <dgwefgsf> d
2018-01-30T04:34:46 #rust-webdev <dgwefgsf> e
2018-01-30T04:34:47 #rust-webdev <dgwefgsf> v
2018-01-30T09:03:37 #rust-webdev <jatentaki> Hi, anyone knows how to pass binary XHTTPRequest contents into rust stdweb code? I tried passing both arraybuffer and Uint8Array but couldn't get it to work
2018-01-30T13:14:34 #rust-webdev <SovietBear> steveklabnik: will there ever be a native asmjs backend, for those of us who want to use rust for frontends in production but have to support old browsers?
2018-01-30T14:10:02 #rust-webdev <steveklabnik> SovietBear: nodejs is a "native asmjs backend"
2018-01-30T14:10:19 #rust-webdev <steveklabnik> but i don't think that's what you're asking
2018-01-30T14:10:26 #rust-webdev * steveklabnik just woke up
2018-01-30T14:10:48 #rust-webdev <SovietBear> steveklabnik: i mean target
2018-01-30T14:10:55 #rust-webdev <steveklabnik> oh oh
2018-01-30T14:10:58 #rust-webdev <steveklabnik> i got hung up on 'native'
2018-01-30T14:11:05 #rust-webdev <steveklabnik> you don't mean 'non-browser' there, right?
2018-01-30T14:18:00 #rust-webdev <ytain> no, he meant the target to be asmjs for node (the backend) which could produce pages that will be supported on old browsers which don't support asmjs
2018-01-30T14:20:37 #rust-webdev <steveklabnik> asmjs is just javascript
2018-01-30T14:20:55 #rust-webdev <steveklabnik> so, anything that supports javascript, something like ES3, supports asmjs
2018-01-30T14:22:16 #rust-webdev <SovietBear> steveklabnik: i mean native as in "without requiring emscripten"
2018-01-30T14:22:21 #rust-webdev <SovietBear> like the native wasm target
2018-01-30T14:22:25 #rust-webdev <SovietBear> but for asmjs
2018-01-30T14:22:47 #rust-webdev <SovietBear> and so that a hello world isnt 1mb
2018-01-30T14:23:13 #rust-webdev <ytain> that's difficult because of std library
2018-01-30T14:23:41 #rust-webdev <steveklabnik> ah
2018-01-30T14:23:51 #rust-webdev <steveklabnik> okay yes, sorry
2018-01-30T14:23:58 #rust-webdev <steveklabnik> so, i doubt that that will exist directly
2018-01-30T14:24:02 #rust-webdev <steveklabnik> *however*
2018-01-30T14:24:08 #rust-webdev <steveklabnik> there has been work on both a wasm -> asm compiler
2018-01-30T14:24:15 #rust-webdev <steveklabnik> and an in-browser wasm interpreter
2018-01-30T14:24:21 #rust-webdev <steveklabnik> both would be viable options going forward
2018-01-30T14:30:33 #rust-webdev <SovietBear> steveklabnik: where are those repos?
2018-01-30T14:31:33 #rust-webdev <steveklabnik> i don't know off the top of my head
2018-01-30T14:31:54 #rust-webdev <SovietBear> steveklabnik: any idea how to make this work? https://github.com/DenisKolodin/yew/issues/124
2018-01-30T14:32:00 #rust-webdev <steveklabnik> "there's been work" also doesn't mean "production ready" yet either
2018-01-30T14:32:29 #rust-webdev <steveklabnik> dunno, i haven't used the asm backend since we first landed it :)
2018-01-30T20:59:53 #rust-webdev <Axel> Hey everyone, what are you guys working on? I'm working on a REST api (in hyper) for a crypto-exchange as a side project
2018-01-30T21:01:32 #rust-webdev <jatentaki> Doing a data visualization of public transportation in Warsaw. Client-side dijkstra (rust wasm) + google maps api
2018-01-30T21:01:45 #rust-webdev <steveklabnik> i am working on rustdoc, which is basically a static site generator :)
2018-01-31T13:35:03 #rust-webdev <GrayShade> Axel: I have a directory-indexing HTTP server that can create archives on the fly (to e.g. download folders)
2018-02-01T10:50:46 #rust-webdev <SovietBear> if hello worl is alread 1mb in asmjs, will a normal web app that has N times the functionality of hello world be N mb in size, or only 1+n*x mb where x < 1mb?
2018-02-01T10:51:16 #rust-webdev <SovietBear> which part of the 1mb is the hello world, and which is fixed runtime?
2018-02-01T11:40:14 #rust-webdev <GrayShade> SovietBear: the "minimal" example from stdweb has a 52 kb .wasm file and a 18 kb .js
2018-02-01T11:40:19 #rust-webdev <GrayShade> it shows an alert box
2018-02-01T11:40:55 #rust-webdev <SovietBear> GrayShade: is the js file the prelude?
2018-02-01T11:42:02 #rust-webdev <GrayShade> a small standard library, I think, to manage data transfer from one side to the other
2018-02-01T11:42:16 #rust-webdev <GrayShade> it's not minified
2018-02-01T11:42:31 #rust-webdev <GrayShade> todomvc is 194 kb wasm / 26 kb js
2018-02-01T11:42:46 #rust-webdev <SovietBear> GrayShade: im talking about asmjs
2018-02-01T11:42:58 #rust-webdev <SovietBear> not wasm + js prelude
2018-02-01T11:43:12 #rust-webdev <GrayShade> ah :/
2018-02-01T11:43:37 #rust-webdev <SovietBear> GrayShade: how large is the stdweb minimal example in asmjs?
2018-02-01T11:43:46 #rust-webdev <SovietBear> hello world is 1mb for me
2018-02-01T11:44:57 #rust-webdev <GrayShade> asm.js todomvc is 7 mb.. that seems a bit excessive..
2018-02-01T11:45:14 #rust-webdev <GrayShade> and minimal is 1.8 mb
2018-02-01T11:45:15 #rust-webdev <SovietBear> GrayShade: todomvc of stdweb or yew?
2018-02-01T11:45:21 #rust-webdev <GrayShade> stdweb
2018-02-01T11:45:32 #rust-webdev <SovietBear> GrayShade: can you try yew's todomvc? :)
2018-02-01T11:45:53 #rust-webdev <SovietBear> i tried but i'm getting this error https://github.com/DenisKolodin/yew/issues/124
2018-02-01T11:46:11 #rust-webdev <SovietBear> created this issue https://github.com/rust-lang/rust/issues/47909
2018-02-01T11:48:18 #rust-webdev <GrayShade> SovietBear: but the stdweb output isn't minified
2018-02-01T11:48:30 #rust-webdev <SovietBear> GrayShade: how large is it minified?
2018-02-01T11:48:45 #rust-webdev <GrayShade> no idea how to do that (:
2018-02-01T11:49:54 #rust-webdev <SovietBear> GrayShade: uglify2
2018-02-01T11:50:00 #rust-webdev <SovietBear> pipe it thru
2018-02-01T11:50:03 #rust-webdev <SovietBear> or parcel.js
2018-02-01T11:50:10 #rust-webdev <SovietBear> https://parceljs.org/
2018-02-01T11:51:48 #rust-webdev <GrayShade> SovietBear: ah, sorry, I missed a --release. stdweb minimal asmjs is 325 kb, todomvc is 656 kb
2018-02-01T11:52:05 #rust-webdev <GrayShade> yew todomvc is 1.1 mb
2018-02-01T11:52:14 #rust-webdev <SovietBear> GrayShade: and minified?
2018-02-01T11:52:20 #rust-webdev <SovietBear> npm install -g uglify
2018-02-01T11:52:21 #rust-webdev <GrayShade> they're minified with --release
2018-02-01T11:52:37 #rust-webdev <SovietBear> npm install uglify-js -g
2018-02-01T11:52:50 #rust-webdev <SovietBear> GrayShade: really? or just dead code eliminated?
2018-02-01T11:54:51 #rust-webdev <GrayShade> SovietBear: uglifyjs makes yew todomvc 700 bytes smaller or so
2018-02-01T11:55:03 #rust-webdev <SovietBear> ok
2018-02-01T11:55:11 #rust-webdev <SovietBear> smaller is always better
2018-02-01T11:55:41 #rust-webdev <SovietBear> GrayShade: is todomvc the biggest yew example?
2018-02-01T11:57:45 #rust-webdev <GrayShade> I think so, at least looking at the source code size
2018-02-01T11:58:08 #rust-webdev <SovietBear> GrayShade: thx, any idea how to fix my issue above?
2018-02-01T11:58:24 #rust-webdev <GrayShade> use WSL? (:
2018-02-01T12:00:25 #rust-webdev <GrayShade> dashboard client yew example doesn't build for me
2018-02-01T12:04:03 #rust-webdev <GrayShade> something about invalid rcgu.bc.z files that don't link and {} is not a function somewhere in uglify-js
2018-02-01T19:15:18 #rust-webdev <seanmonstar> sfackler: if the hyper::Error were to grow a Connect variant, would that break code that's trying to divine connect errors out of Error::Io?
2018-02-01T19:19:18 #rust-webdev <sfackler> seanmonstar: I have some code that smuggles that information through Error::Io
2018-02-01T19:19:28 #rust-webdev <sfackler> but would not be super sad if I was able to delete it :P
2018-02-01T19:20:24 #rust-webdev <seanmonstar> sfackler: but the point is that if those errors suddenly were in `Error::Connect` and not in `Error::Io`, it would be subtely broken with an update, right?
2018-02-01T19:20:35 #rust-webdev <sfackler> yep
2018-02-01T19:20:40 #rust-webdev <seanmonstar> sigh
2018-02-01T19:21:36 #rust-webdev <seanmonstar> ive been thinking how i could improve the Error type without breaking existing patterns, and it might not really be possible until 0.12
2018-02-01T19:22:40 #rust-webdev <sfackler> yeah it seems best to make opaquer in 0.12
2018-02-02T08:54:16 #rust-webdev -gharewewebyet- [arewewebyet] Halamix2 closed pull request #13: CSS fixes (master...master) https://github.com/teepee/arewewebyet/pull/13
2018-02-02T09:33:39 #rust-webdev <Sergio> Weird
2018-02-06T20:34:03 #rust-webdev <mib_ps330g> LKL
2018-02-06T20:34:16 #rust-webdev <mib_ps330g> Hello Everyone
2018-02-08T09:31:03 #rust-webdev <SovietBear> does yew support SVG?
2018-02-08T18:00:04 #rust-webdev <sfackler> seanmonstar: I think I'm hitting this assert on 0.11.12 - do you know if there was something there that has since been fixed? https://github.com/hyperium/hyper/blob/master/src/proto/h1/conn.rs#L316
2018-02-08T18:02:07 #rust-webdev <seanmonstar> sfackler: i recall someone else filed an issue, and i believe it was fixed
2018-02-08T18:02:23 #rust-webdev <seanmonstar> the assert wasn't bad, the code calling try_empty_read was :)
2018-02-08T18:03:00 #rust-webdev <sfackler> cool, thanks
2018-02-08T18:03:07 #rust-webdev <sfackler> i'll upgrade and see how things go
2018-02-08T22:23:48 #rust-webdev <seanmonstar> some thoughts to how streaming bodies would work in hyper 0.12: https://github.com/hyperium/hyper/issues/1438
2018-02-09T04:32:48 #rust-webdev <brandonz> Errors in the implementation of the stdweb feature I'm adding are difficult for me to debug.
2018-02-09T15:41:20 #rust-webdev <nimtiazm> anyone has a non-trivial REST server project example for rust?
2018-02-09T15:41:28 #rust-webdev <nimtiazm> i just tried using Iron
2018-02-09T15:42:20 #rust-webdev <nimtiazm> i’m stuck at trying to use instances outside handler closures. it says handler is fn and I need fnMut
2018-02-09T21:25:59 #rust-webdev <bfrog> it seems as if iron is no longer being worked on according to the repo :(
2018-02-10T11:39:19 #rust-webdev <zofrex> is there any clear consensus on which languages people like to test rust web apps with?
2018-02-10T11:39:29 #rust-webdev <zofrex> obv Rust itself doesn't seem like a great candidate for integration testing web apps
2018-02-10T11:39:39 #rust-webdev <zofrex> the main contenders seem to be nodejs, ruby, or maybe Python
2018-02-10T11:40:01 #rust-webdev <zofrex> does anyone have any idea which of those have the biggest 'overlap' with Rust programmers? ideally I'd want my tests to be as accessible as possible to other contributors
2018-02-10T14:54:41 #rust-webdev <steveklabnik> zofrex: so, according to the survey
2018-02-10T14:54:46 #rust-webdev <steveklabnik> people who know rust know python the most
2018-02-10T14:54:48 #rust-webdev <steveklabnik> then nodejs
2018-02-10T14:54:49 #rust-webdev <steveklabnik> then ruby
2018-02-10T14:55:21 #rust-webdev <steveklabnik> which is like, the opposite of me personally :p
2018-02-10T15:03:48 #rust-webdev <zofrex> haha, same
2018-02-11T14:05:25 #rust-webdev <frogmella> helloo, i would like to use rust for a web-project, but i require a drawing-input, where people can draw lines etc, so i think i would probably have to use javascript as frontend and maybe rust as backend/server? what are people usually using? something as scala.js?
2018-02-11T14:06:21 #rust-webdev <FauxDEM> Sounds reasonable, yes.
2018-02-11T14:07:33 #rust-webdev <frogmella> is there something feeling similar to rust as in type-safe etc (even though javascript is often more functional afaik)? there seems to be a broad variety, purescript, typescript, elm, ...
2018-02-11T14:08:14 #rust-webdev <Faux> Betting on a minority Javascript framework is a massive risk imo; wouldn't even consider anything not used by Facebook or Google.
2018-02-11T14:08:56 #rust-webdev <frogmella> oh, risk as in what? running out of support?
2018-02-11T14:09:56 #rust-webdev <Faux> Yeah, the stack of awful compilers underneath you moving on, and nobody updating the framework.
2018-02-11T14:11:25 #rust-webdev <frogmella> are there any smart recommendations then? probably have to figure out what google and facebook etc use
2018-02-11T14:12:09 #rust-webdev <blackbeard420> rust to asm.js lol
2018-02-11T14:15:58 #rust-webdev <jonimake> typescript seems okay
2018-02-11T14:26:22 #rust-webdev <frogmella> blackbeard420: i doubt rust is lacking frameworks to actually provide strong UI in web : /
2018-02-11T14:26:35 #rust-webdev <frogmella> eh, i think*
2018-02-11T14:27:45 #rust-webdev <Faux> Server-side UI frameworks are all pretty much dead in every language, why would you expect one to exist in Rust?
2018-02-11T14:29:19 #rust-webdev <frogmella> oh, i meant, if i want to provide a canvas/context where people can actually draw, rust seems to be a bad pick for the front end
2018-02-11T14:29:29 #rust-webdev <jonimake> Faux: I thought isomorphic javascript apps are all the rage these days? :P
2018-02-11T14:31:56 #rust-webdev <Faux> frogmella: As a native app? Probably not too bad; conrod has an example of doing that. In the browser? Hell yes, do not even think of running Rust actually in the browser.
2018-02-11T14:37:08 #rust-webdev <frogmella> Faux: hmm, i see, maybe rust as a server then
2018-02-11T14:48:07 #rust-webdev <blackbeard420> css and html5 is all you need nowadays, js is bloat
2018-02-11T14:48:46 #rust-webdev <jonimake> let's see how you do an ajax call without js :P
2018-02-11T14:48:53 #rust-webdev <jonimake> or do practically anything of use
2018-02-11T14:49:01 #rust-webdev <jonimake> unless you want to use forms 
2018-02-11T14:49:05 #rust-webdev <jonimake> for everything
2018-02-11T14:49:23 #rust-webdev <blackbeard420> i know, just being an ass, js is def needed for ajax
2018-02-11T14:49:37 #rust-webdev <blackbeard420> posting forms is from the 90's lol
2018-02-11T15:16:40 #rust-webdev <udoprog> I can swear I used forms extensively well into the 2000s...
2018-02-11T15:17:44 #rust-webdev <jonimake> 2000 was almost two decades ago tho
2018-02-11T19:18:00 #rust-webdev <WindowsBunny> Meanwhile I have JS disabled on most websites by default, so if there's a form that doesn't actually use forms, I can't use that website :D
2018-02-11T20:44:14 #rust-webdev <Calinou> <Faux> Server-side UI frameworks are all pretty much dead in every language, why would you expect one to exist in Rust?
2018-02-11T20:44:21 #rust-webdev <Calinou> server-side rendering is very much a thing in all the large JavaScript frameworks
2018-02-11T20:44:29 #rust-webdev <Calinou> (mainly for SEO reasons
2018-02-11T20:44:32 #rust-webdev <Calinou> )
2018-02-11T21:00:49 #rust-webdev <Faux> Calinou: a) I meant "non-dom-construction based server-side rendering", as apposed to html5 generation from a non-DOM-based language, and b) I'm not even sure that's true, I thought Google and friends got rid of their interest in doing that? THere was a standard, which is now deprecated.
2018-02-11T21:04:00 #rust-webdev <Faux> i.e. Google and friends just run the JS now.
2018-02-11T21:16:35 #rust-webdev <WindowsBunny> I just want websites to work without JS :(
2018-02-11T21:42:05 #rust-webdev <Calinou> Faux: search engines are able to interpret JavaScript to an extent, that's true
2018-02-11T21:42:19 #rust-webdev <Calinou> still, server-side rendering is used in many cases (for mobile websites too, since mobile CPUs are slow, IIRC)
2018-02-11T21:42:27 #rust-webdev <Calinou> for instance, Vue.js and React both offer it
2018-02-11T21:42:44 #rust-webdev <Calinou> WindowsBunny: for simple websites, that's a reasonable goal, but not really for complex web apps
2018-02-11T21:42:54 #rust-webdev <Calinou> unless you're doing page reloads on every action, which sucks for UX
2018-02-11T21:43:16 #rust-webdev <Calinou> imagine Transifex reloading the page on every string you translate! (it's a translation service)
2018-02-11T21:43:26 #rust-webdev <Calinou> ^ as an ADSL user, that's not something I want :)
2018-02-11T21:45:07 #rust-webdev <WindowsBunny> Calinou: The point is the website should be able to fall back to a no-JS version for most trivial websites
2018-02-11T21:45:25 #rust-webdev <WindowsBunny> Calinou: Websites that just offers news articles are my main complaint
2018-02-11T21:47:04 #rust-webdev <RasmusKaj-M> At the same time, security and personal integrity are important concerns.  A growing number of people enables javascript by whitelist only, and a blank page the first time I visit a server make me close it, not whitelist it.
2018-02-11T21:47:53 #rust-webdev <RasmusKaj-M> An app I allready has decided to use can be entirely js-based, but a site that aims to offer content for casual visitors better treat js as progressive enhancement.
2018-02-11T21:59:10 #rust-webdev <WindowsBunny> exactly
2018-02-11T22:35:46 #rust-webdev <Calinou> RasmusKaj-M: "growing number of people" is debatable, but that's just me :P
2018-02-11T22:36:01 #rust-webdev <Calinou> that said, a blank page is terrible user experience in any case
2018-02-11T22:43:20 #rust-webdev <RasmusKaj-M> Well, it's easy to grow if the numbers are very small to begin with.  :-)  But in the more tech-savvy young communitys I think I really do see that.  It might be local, though.
2018-02-11T23:44:42 #rust-webdev <YungMoon> yo
2018-02-11T23:45:16 #rust-webdev <YungMoon> when connecting from a browser instead, should i use "ws://" instead of "http://127.0.0.1:8080/ws/" ? https://github.com/actix/actix-web/blob/master/examples/websocket/src/client.rs#L24
2018-02-11T23:45:28 #rust-webdev <YungMoon> "ws://127.0.0.1:8080/ws/"
2018-02-11T23:45:30 #rust-webdev <YungMoon> ?
2018-02-12T03:13:00 #rust-webdev <WindowsBunny> RasmusKaj-M: Especially with the sheer number of ways to screw with arbitrary memory such as meltdown and rowhammer and spectre
2018-02-14T09:42:02 #rust-webdev <madmalik> hi everyone! i'd like to get some hints regarding the rust webdev ecosystem. I plan to experiment with building a CMS thingy, but i'm  not sure what libraries to choose/look into
2018-02-14T09:43:43 #rust-webdev <madmalik> diesel for db-integration seems like a no-brainer, but i'm not sure what http lib i should choose
2018-02-14T09:44:26 #rust-webdev <madmalik> rocket seems a little bit to unstable and high level. is anyone using hyper?
2018-02-14T09:44:35 #rust-webdev <Sergio> What's unstable about it?
2018-02-14T09:49:12 #rust-webdev <madmalik> my impression was that it's still a little bit in flux. but i've no idea about the state of the rust webdev ecosystem right now, hence asking for direction so i can change that...
2018-02-14T09:49:28 #rust-webdev <Sergio> No software is ever complete...
2018-02-14T09:49:40 #rust-webdev <Sergio> Rocket is entirely stable in the semver sense.
2018-02-14T09:49:48 #rust-webdev <madmalik> ah, ok
2018-02-14T09:49:59 #rust-webdev <Sergio> The only caveat is that you need to use the latest nightly.
2018-02-14T09:50:05 #rust-webdev <Sergio> To use Rocket
2018-02-14T09:50:23 #rust-webdev <madmalik> maybe thats the source of my impression ^^ are you the developer of rocket?
2018-02-14T09:50:33 #rust-webdev <Sergio> I'm the original author, yeah.
2018-02-14T09:51:08 #rust-webdev <madmalik> oh, ok. sorry for the implications of my question.
2018-02-14T09:52:43 #rust-webdev <Sergio> I actually address this particular idea here: https://www.youtube.com/watch?v=t_FUZ34ahBE&t=1772s
2018-02-14T09:54:30 #rust-webdev <eijebong> Can confirm, rocket has a stable API, and it's great
2018-02-14T09:54:44 #rust-webdev <madmalik> ok, thank you! i think i'll try out rocket first then :D
2018-02-14T09:57:20 #rust-webdev <eijebong> madmalik: :) Also if you haven't seen it, I recommend the whole talk that Sergio linked, it's really good
2018-02-14T09:57:47 #rust-webdev <madmalik> its bookmarked for my lunch break :)
2018-02-14T09:58:25 #rust-webdev <Sergio> Thanks, eijebong. :)
2018-02-14T09:59:24 #rust-webdev <Sergio> madmalik: Also, if you're interesting in releasing your project and exposing it to the world, a web framework like Rocket protects you from the evils that be!
2018-02-14T10:00:22 #rust-webdev <Sergio> This was the subject of the talk I gave at StrangeLoop, if you're interested: https://www.youtube.com/watch?v=QS8mrbAPLJc
2018-02-14T10:00:38 #rust-webdev <Sergio> And there's a lot more work coming to making Rocket the most secure web framework in existence, bar none.
2018-02-14T10:01:02 #rust-webdev <madmalik> ok, bookmarked that talk for the evening ^^
2018-02-14T10:08:59 #rust-webdev <madmalik> a little bit of background: i do a lot of work with ZMS, which is content managment system written in python. its quite old and has a lot of dusty corners, but has a rather unique content model which makes it very suitable for complex websites. its mostly used in scientific and medical institutions. I'd like to try if the good parts of that content model are translatable into a modern CMS
2018-02-14T10:33:02 #rust-webdev <Sergio> madmalik: Cool!
2018-02-14T15:28:44 #rust-webdev <jxs> btw, Sergio what is the status on https://github.com/SergioBenitez/Rocket/issues/17 and hyper 0.11 ?
2018-02-14T19:22:40 #rust-webdev <Sergio> jxs: It remains untouched
2018-02-14T19:23:23 #rust-webdev <dowwie> madmalik:  although diesel reached 1.0, that doesn't mean it is feature complete. Is your CMS data model going to use self-referencing tables?  well, self-referential joins aren't supported.  CTE's also aren't.  etc etc.  It's a great opportunity to contribute or opt for a lower-level alternative, such as rust-postgres
2018-02-14T19:23:52 #rust-webdev <dowwie> madmalik:  err, self-referencing FKs
2018-02-14T19:34:57 #rust-webdev <cholcombe> o/ i'm having some trouble with reqwest and a custom root cert.  I'm dealing with an https setup where a server has a self signed cert and a custom root cert.  I downloaded the root cert, did a der encoding on it and imported it with reqwest but i'm still get an ssl verification failure.  anyone know what i might check to figure out what's wrong?  openssl s_client says it's a error code 19 which kinda helps
2018-02-14T19:38:02 #rust-webdev <seanmonstar> disclaimer: im a noob at cert verification.
2018-02-14T19:38:15 #rust-webdev <seanmonstar> do the hostnames match?
2018-02-14T19:38:42 #rust-webdev <cholcombe> i believe they do
2018-02-14T19:38:50 #rust-webdev <cholcombe> let me double check again
2018-02-14T19:39:25 #rust-webdev <cholcombe> yeah the subject and the hostname matches
2018-02-14T19:39:33 #rust-webdev <Sergio> cholcombe: Which OS?
2018-02-14T19:39:35 #rust-webdev <cholcombe> at least the dns name matches
2018-02-14T19:39:49 #rust-webdev <cholcombe> Sergio: i'm not sure.  it's an emc storage product called xtremio
2018-02-14T19:40:32 #rust-webdev <Sergio> Sorry, I mean, on which OS are you running the client?
2018-02-14T19:40:38 #rust-webdev <Sergio> The client needs to trust the root cert as well
2018-02-14T19:40:45 #rust-webdev <cholcombe> oh
2018-02-14T19:40:47 #rust-webdev <cholcombe> that's ubuntu
2018-02-14T19:41:01 #rust-webdev <Sergio> You need to install the root cert in the appropriate location.
2018-02-14T19:41:09 #rust-webdev <cholcombe> i downloaded the root cert off the storage server and put it into /usr/local/share/ca-certificates and then ran update-ca-certificates
2018-02-14T19:41:18 #rust-webdev <cholcombe> that dropped it into /etc/ssl/certs on ubuntu 16
2018-02-14T19:41:27 #rust-webdev <cholcombe> openssl s_client still says the exact same thing though
2018-02-14T19:42:04 #rust-webdev <Sergio> Have you tried manually setting a -CApath?
2018-02-14T19:42:09 #rust-webdev <cholcombe> yeah
2018-02-14T19:42:11 #rust-webdev <cholcombe> doesn't seem to help
2018-02-14T19:43:26 #rust-webdev <cholcombe> openssl sees 2 certs in the chain.  cert 0 and 1.  
2018-02-14T19:44:55 #rust-webdev <Sergio> Is your root cert a CA cert?
2018-02-14T19:46:22 #rust-webdev <Sergio> This is how I generate self-signed certs: https://github.com/SergioBenitez/Rocket/blob/master/examples/tls/private/gen_cert.sh
2018-02-14T19:46:53 #rust-webdev <Sergio> And can confirm that OpenSSL, rustls, Chrome, Safari, and Firefox all accept them.
2018-02-14T19:47:41 #rust-webdev <cholcombe> is there a way i can check that with openssl?  i don't have control over the generation of that cert
2018-02-14T19:48:16 #rust-webdev <Sergio> Use openssl x509 -in yourcert.pem -text
2018-02-14T19:48:31 #rust-webdev <Sergio> Look for the 'CA: TRUE' or CA: FALSE line
2018-02-14T19:48:32 #rust-webdev <cholcombe> ok lets see
2018-02-14T19:48:33 #rust-webdev <Sergio> Or is NO/YES
2018-02-14T19:48:42 #rust-webdev <Sergio> I think it's NO/YES.
2018-02-14T19:48:55 #rust-webdev <Sergio> One of them.
2018-02-14T19:49:07 #rust-webdev <cholcombe> yeah i see CA:True
2018-02-14T19:49:46 #rust-webdev <Sergio> Well, I'd try using my script to generate known okay certs and seeing if things work out.
2018-02-14T19:49:53 #rust-webdev <Sergio> If it doesn't work out, then it might be on Hyper's side
2018-02-14T19:50:07 #rust-webdev <Sergio> Everything you've said thus far sounds good.
2018-02-14T19:51:21 #rust-webdev <cholcombe> hmm ok
2018-02-14T19:51:37 #rust-webdev <cholcombe> it's weird.  when i had a fully self signed cert on another array and i imported it into reqwest it worked fine
2018-02-14T19:51:53 #rust-webdev <cholcombe> this time i have a self signed cert + a different root cert and i can't seem to find some combination of things that work
2018-02-14T19:54:25 #rust-webdev <cholcombe> when i look at showcerts on the storage server neither of the certs in the chain seem to match the root cert i downloaded
2018-02-14T19:54:39 #rust-webdev <cholcombe> maybe that's the problem
2018-02-14T19:56:46 #rust-webdev <Sergio> That would do it...
2018-02-14T19:56:46 #rust-webdev <cholcombe> Sergio: if you have 2 certs in the chain do you have to import both of them into reqwest?
2018-02-14T19:57:03 #rust-webdev <cholcombe> the root and the self signed one
2018-02-14T19:57:07 #rust-webdev <Sergio> Presumably
2018-02-14T19:57:40 #rust-webdev <cholcombe> ok i'll try that
2018-02-14T20:01:57 #rust-webdev <cholcombe> damn that fixed it.  Thanks Sergio!!
2018-02-14T20:07:06 #rust-webdev <sfackler> cholcombe: you should only need to import the root. the server is responsible for sending all of the intermediates
2018-02-14T20:07:59 #rust-webdev <cholcombe> sfackler:  i can't explain why but importing the self signed cert or the root cert by itself doesn't work
2018-02-15T15:50:29 #rust-webdev <dwigton> What framework is seeing the most stable use. I have somewhat settled on Rocket but am a bit leery that it uses Nightly is actix-web production ready?
2018-02-15T15:50:46 #rust-webdev <Sergio> What do you mean by "stable use"?
2018-02-15T15:51:19 #rust-webdev <Sergio> If you want to hear my talk about Rocket's stability, I do so here: https://www.youtube.com/watch?v=t_FUZ34ahBE&t=1772s
2018-02-15T15:52:19 #rust-webdev <dwigton> Ah cool thanks. I just mean use in production without breaking changes.
2018-02-15T15:52:35 #rust-webdev <Sergio> Rocket is fully stable as far as semver goes.
2018-02-15T15:52:48 #rust-webdev <Sergio> Zero semver breaking changes.
2018-02-15T15:53:05 #rust-webdev <Sergio> But you to have to track nightly
2018-02-15T15:53:07 #rust-webdev <Sergio> you do*
2018-02-15T15:53:16 #rust-webdev <dwigton> I am very new to rust in general and just play with it in the few moments I get between work and family. It is hard to get a handle on what tools are actively used.
2018-02-15T15:53:41 #rust-webdev <Sergio> I can tell you that Rocket's seeing a lot of use in production environments, both big and small.
2018-02-15T15:54:11 #rust-webdev <Sergio> From company's like System76 and NPM, to starts-ups and consulting firms.
2018-02-15T15:54:16 #rust-webdev <Sergio> companies*
2018-02-15T15:54:44 #rust-webdev <dwigton> Not to mention a very committed maintainer ;-)
2018-02-15T15:54:51 #rust-webdev <Sergio> !
2018-02-15T15:54:51 #rust-webdev <Sergio> :)
2018-02-15T15:54:54 #rust-webdev <steveklabnik> rocket is pre 1.0, so yeah, semver doesn't say much ;)
2018-02-15T15:55:05 #rust-webdev <Sergio> That's not true, steveklabnik.
2018-02-15T15:55:15 #rust-webdev <steveklabnik> semver says before 1.0, nothing matters
2018-02-15T15:55:17 #rust-webdev <steveklabnik> but
2018-02-15T15:55:19 #rust-webdev <Sergio> As long as we stick to Cargo's definition of semver
2018-02-15T15:55:33 #rust-webdev <steveklabnik> really, i cannot wait until rocket on stable
2018-02-15T15:55:39 #rust-webdev <steveklabnik> it will be the best
2018-02-15T15:55:49 #rust-webdev <Sergio> This year!
2018-02-15T15:55:52 #rust-webdev <Sergio> It's the year!
2018-02-15T15:55:53 #rust-webdev <Sergio> Haha
2018-02-15T15:55:56 #rust-webdev <steveklabnik> :metal:
2018-02-15T15:56:00 #rust-webdev <steveklabnik> seriously. 
2018-02-15T15:56:02 #rust-webdev <steveklabnik> i am pumped
2018-02-15T15:56:14 #rust-webdev <Sergio> I'm really happy to hear that!
2018-02-15T15:56:17 #rust-webdev <Sergio> For the record: me too!
2018-02-15T15:56:24 #rust-webdev <dwigton> Does Rocket use metal or is it fancy composites and such?
2018-02-15T15:56:32 #rust-webdev <steveklabnik> <3
2018-02-15T15:57:42 #rust-webdev <dwigton> I have to admit, you could not have picked a better name to pull me in. I wanted to be a rocket scientist but ended up a webdev. :-p
2018-02-15T15:58:45 #rust-webdev <Sergio> steveklabnik: The plan is to target the new epoch. Given everything I've read, this is more than doable.
2018-02-15T15:59:04 #rust-webdev <steveklabnik> awesome :)
2018-02-15T15:59:05 #rust-webdev <Sergio> dwigton: Haha. I'm glad you like the name!
2018-02-15T16:05:30 #rust-webdev <dwigton> What
2018-02-15T16:05:52 #rust-webdev <dwigton> What is an epoch?
2018-02-15T16:05:58 #rust-webdev <dwigton> In rust terms
2018-02-15T16:06:13 #rust-webdev <Sergio> https://github.com/rust-lang/rfcs/pull/2052
2018-02-15T16:07:25 #rust-webdev <Aaronepower> dwigton: A non breaking way to to have breaking changes on a much longer release cycle. For example the current epoch is Rust 2015 the next epoch will be Rust 2018.
2018-02-15T16:08:36 #rust-webdev <Aaronepower> It's worth noting that Rust 2018 will be the first epoch release as this model didn't exist when Rust went 1.0 in 2015.
2018-02-15T16:09:48 #rust-webdev <dwigton> Can cargo.toml specify an epoch?
2018-02-15T16:09:53 #rust-webdev <Sergio> Not yet!
2018-02-15T16:09:56 #rust-webdev <Sergio> But eventually.
2018-02-15T16:10:02 #rust-webdev <Sergio> Check out the RFC.
2018-02-15T16:10:09 #rust-webdev <Sergio> It has all the details.
2018-02-15T16:10:13 #rust-webdev <Sergio> (https://github.com/rust-lang/rfcs/pull/2052)
2018-02-15T16:13:20 #rust-webdev <steveklabnik> https://www.techempower.com/benchmarks/#section=data-r15&hw=ph&test=plaintext <-
2018-02-15T16:13:26 #rust-webdev <steveklabnik> seanmonstar: ^ :D
2018-02-15T16:13:32 #rust-webdev <steveklabnik> also carllerche 
2018-02-15T16:13:38 #rust-webdev <Sergio> Nice!
2018-02-15T16:14:02 #rust-webdev <Sergio> It's from the future, even.
2018-02-15T16:14:04 #rust-webdev <Sergio> 2019
2018-02-15T16:14:49 #rust-webdev <Sergio> Which is everything twice as slow as last time?
2018-02-15T16:14:55 #rust-webdev <steveklabnik> heh
2018-02-15T16:17:40 #rust-webdev <dwigton> Rocket not listed? I forget does rocket use tokio or hyper?
2018-02-15T16:17:48 #rust-webdev <Sergio> Hyper uses tokio.
2018-02-15T16:17:51 #rust-webdev <Sergio> Rocket uses Hyper
2018-02-15T16:18:03 #rust-webdev <Sergio> Except that it uses a version of Hyper that doesn't use tokio
2018-02-15T16:18:22 #rust-webdev <Sergio> And it doesn't use hyper too much
2018-02-15T16:18:32 #rust-webdev <dwigton> lol
2018-02-15T16:19:24 #rust-webdev <dwigton> Just a dash of tokio-less hyper
2018-02-15T16:20:40 #rust-webdev <Sergio> Rocket's plenty fast, though.
2018-02-15T16:20:59 #rust-webdev <Sergio> We'll subject it to arbitrary benchmarks eventually.
2018-02-15T16:29:52 #rust-webdev <dwigton> Well seeing as how the PHP frameworks I have relied on are stacking up, It could be 10% as fast as tokio and I would still be impressed.
2018-02-15T16:33:38 #rust-webdev * steveklabnik used to work on rails so how do you think he feels
2018-02-15T16:42:16 #rust-webdev * dwigton used to use rails as well, but never took to it.
2018-02-15T17:29:33 #rust-webdev <carllerche> steveklabnik: woot... though it also seems that, at the top ~5, ranking is pretty much random depending on the run?
2018-02-15T17:29:43 #rust-webdev <carllerche> afaik, nothing really changed... unless rust got faster somehow
2018-02-15T17:30:46 #rust-webdev <steveklabnik> that's possible yeah
2018-02-15T18:07:40 #rust-webdev <seanmonstar> oh yay
2018-02-20T01:08:17 #rust-webdev <painhex> Anyone here played around with tungstenite?
2018-02-25T20:00:51 #rust-webdev <raymondsiu> Hi web dev's, what are you guys using to build backends in Rust? iron, rocket, plain hyper?
2018-02-25T20:01:00 #rust-webdev <raymondsiu> *guys/gals
2018-02-25T20:02:46 #rust-webdev <blackbeard420> rocket is sweet imo
2018-02-25T20:04:17 #rust-webdev <raymondsiu> Have you have experience with rocket and if so, how do you find the performance?
2018-02-25T20:07:30 #rust-webdev <blackbeard420> i haven't ran any hard benchmarks on it, however the performance has been great and i dont see it being an issue
2018-02-25T20:09:48 #rust-webdev <raymondsiu> @blackbeard420 Thanks
2018-02-27T12:36:35 #rust-webdev <andor> seanmonstar: is my assumption correct that on osx you don't need to supply the CA root certs to reqwest manually, whereas on linux you do?
2018-02-27T12:45:01 #rust-webdev <andor> asking because the same binary compiled on osx will have no problem making an SSL request through hyper, but compiled on linux certificate verification fails; my assumption is that thanks to rust-native-tls osx's SSL impl already loads the certs, but not on linux
2018-02-27T12:59:17 #rust-webdev <andor> hmm, interesting, setting `SSL_CERT_DIR` manually fixed it
2018-02-27T17:22:31 #rust-webdev <sfackler> andor: different linux distros store their CA roots in different places. if you're statically linking to openssl and want it to work portably on different distros, you'll need to use something like https://docs.rs/openssl-probe/0.1.2/openssl_probe/
2018-02-27T17:22:55 #rust-webdev <sfackler> that's what cargo uses for example
2018-02-27T18:06:48 #rust-webdev <andor> sfackler: ahh, that does make sense
2018-02-27T18:07:24 #rust-webdev <andor> i am faux-crosscompiling on osx to linux, then putting the resulting binary in another docker image based on ubuntu, so CA root location might be different because of that
2018-02-27T18:08:26 #rust-webdev <andor> i might open a ticket on reqwest regarding openssl_probe, given that it has a "batteries included" approach it might make sense to include that
2018-02-27T18:13:09 #rust-webdev <sfackler> yeah I've considered pulling it into native-tls
2018-02-27T18:13:13 #rust-webdev <sfackler> but it's a bit weird
2018-02-27T18:13:19 #rust-webdev <sfackler> since it's only necessary if you're statically linking
2018-03-02T15:22:56 #rust-webdev <painhex> is anyone here familiar with configuring  virtual hosts for apache on arch linux? I'm following their documentation but still struggling to get it working :/
2018-03-02T15:26:44 #rust-webdev <RyanOde> What's happening?
2018-03-02T15:28:40 #rust-webdev <RyanOde> One thing that tends to get me is that I always forget to put the "require all granted" part
2018-03-02T15:29:04 #rust-webdev <painhex> I get a message back from my server saying: "Invalid Request Header"
2018-03-02T15:29:32 #rust-webdev <painhex> The app thats running is just a default angular app that connects to a websocket on my rust server
2018-03-02T15:31:37 #rust-webdev <RyanOde> I haven't seen that before. Apologies. Sounds like an issue with the http requests though. 
2018-03-02T15:32:38 #rust-webdev <painhex> What does the "require all granted" do exactly?
2018-03-02T15:40:09 #rust-webdev <RyanOde> It allows any IP address to access the directory specified if I recall correctly
2018-03-02T15:46:46 #rust-webdev <painhex> I found the issue, angular was checking the host matched the domain it was being served from. I was going down the wrong rabbit hole :D
2018-03-02T15:48:06 #rust-webdev <RyanOde> Glad to hear :)
2018-03-05T10:26:56 #rust-webdev <dbrgn> already posted this in #rust, but I think here's the better place for it :)
2018-03-05T10:27:00 #rust-webdev <dbrgn> in a hyper Service, how can I access the event loop (so that I can do a HTTP client request inside the HTTP server request handler)?
2018-03-05T10:27:03 #rust-webdev <dbrgn> it seems that I can get a tokio Handle as soon as I have bound a server, but at that point in time I have already instantiated the service.
2018-03-05T10:29:02 #rust-webdev <dbrgn> ah, maybe I need Http::serve_addr_handle ?
2018-03-05T10:50:28 #rust-webdev <dbrgn> hm, that will return a Serve though. can I somehow convert that to a Server?
2018-03-05T17:52:45 #rust-webdev <badboy> dbrgn: you don't need to
2018-03-05T17:53:07 #rust-webdev <badboy> let me grab a code example
2018-03-05T17:53:40 #rust-webdev <badboy> https://github.com/hyperium/hyper/blob/master/examples/multi_server.rs#L57-L61
2018-03-05T17:53:49 #rust-webdev <badboy> (oh only now realized you asked a couple of hours ago)
2018-03-08T00:37:42 #rust-webdev <sfackler> seanmonstar: what was the impetus for set_host? hopefully there's nothing that barfs on host headers!?
2018-03-08T00:38:47 #rust-webdev <seanmonstar> sfackler: i needed it as a transparent proxy: if we dont receive a host header, we shouldn't add one as it goes through our client
2018-03-08T00:38:56 #rust-webdev <sfackler> ah sure
2018-03-08T00:39:15 #rust-webdev <seanmonstar> looked around and saw similar options in other libs, so figured it might be useful
2018-03-08T23:41:11 #rust-webdev <peeves> Ola
2018-03-09T20:29:17 #rust-webdev <sfackler> seanmonstar: the Response stream will send an error if the response body cuts off early, right?
2018-03-11T15:09:38 #rust-webdev <moschroe> hi, does anyone have experience with tera templates, more specifically, how to get error messages?
2018-03-12T01:07:54 #rust-webdev <SovietBear> which rust crate maps file extensions to mime types?
2018-03-12T11:32:08 #rust-webdev <mitsuhiko> is there some timeframe for hyper on tokio 0.1?
2018-03-12T11:34:14 #rust-webdev <eijebong> mitsuhiko: I guess you meant 0.2 ?
2018-03-12T11:34:28 #rust-webdev <mitsuhiko> why 0.2?
2018-03-12T11:34:32 #rust-webdev <mitsuhiko> i thought the plan is to support 0.1
2018-03-12T11:34:40 #rust-webdev <eijebong> Isn't tokio already 0.1 ?
2018-03-12T11:34:53 #rust-webdev <mitsuhiko> yes. but hyper does not support it
2018-03-12T11:35:02 #rust-webdev <eijebong> Hyper 0.11 does
2018-03-12T11:35:04 #rust-webdev <mitsuhiko> no
2018-03-12T11:35:09 #rust-webdev <mitsuhiko> hyper is stuck with tokio-core
2018-03-12T11:35:19 #rust-webdev <eijebong> Oh, ok didn't know that was something different
2018-03-12T11:35:41 #rust-webdev <eijebong> For me tokio is the whole tokio-* ecosystem
2018-03-12T11:37:41 #rust-webdev <mitsuhiko> should probably have asked that in #tokio
2018-03-12T11:37:46 #rust-webdev <mitsuhiko> eh, hyper
2018-03-12T11:45:58 #rust-webdev <memoryruins> mitsuhiko: the hyper 0.12 milestone aims for new tokio and future 0.2 https://github.com/hyperium/hyper/milestone/4
2018-03-12T11:46:31 #rust-webdev <mitsuhiko> memoryruins: i was trying to estimate the timeframe
2018-03-12T11:46:45 #rust-webdev <mitsuhiko> mostly: is it a week out, a month, more
2018-03-14T20:07:40 #rust-webdev <sfackler> seanmonstar: not going to be the one library in the universe to support http1 chunked trailers? :P
2018-03-14T20:09:15 #rust-webdev <seanmonstar> bleck
2018-03-14T20:10:01 #rust-webdev <seanmonstar> i was looking recently (i have a horrible bed time habit of reading the source of http libraries), it looks like nodejs actually does support them
2018-03-14T20:10:08 #rust-webdev <seanmonstar> i feel like thats new, but cant remember
2018-03-14T20:11:24 #rust-webdev <sfackler> I think go might also but lol if anyone uses that
2018-03-14T20:12:25 #rust-webdev <sfackler> how would you feel about pulling the low level client and server Connection futures out into an http1 crate at the same low-level kind of setup as h2 for 0.12?
2018-03-14T20:12:45 #rust-webdev <sfackler> and hyper's then a moderately higher level thing that does the h1/h2 routing and connection pooling
2018-03-14T20:12:54 #rust-webdev <carllerche> sfackler: I have the h1 crate and hope to do a similar treatment...
2018-03-14T20:12:59 #rust-webdev <carllerche> but time is lacking for me personally
2018-03-14T20:13:18 #rust-webdev <carllerche> I've been experimenting with a different way to structure the internals but haven't gotten very far
2018-03-14T20:14:13 #rust-webdev <seanmonstar> i'd probably be fine with it, just not a high priority for me. especially now that hyper has both low- and high-level apis in the client and server
2018-03-14T20:15:36 #rust-webdev <sfackler> ok thanks - i might poke around to night and make a PR that extracts it to another crate in the hyper repo so we can se what it'd look like
2018-03-17T06:49:35 #rust-webdev <zippity> hey guys
2018-03-17T08:40:43 #rust-webdev <SovietBeer> zofrex: sup
2018-03-17T21:56:27 #rust-webdev <zofrex> hey SovietBeer 
2018-03-17T21:56:37 #rust-webdev <SovietBeer> hey zofrex 
2018-03-17T21:57:17 #rust-webdev <zofrex> you pinged? (pung?)
2018-03-17T21:58:56 #rust-webdev <SovietBeer> zofrex: when?
2018-03-17T21:59:12 #rust-webdev <zofrex> about 13 hours ago
2018-03-17T22:00:56 #rust-webdev <SovietBeer> zofrex: can't remember
2018-03-17T22:03:28 #rust-webdev <zofrex> ah. sorry, was offline for almost a week
2018-03-17T22:03:37 #rust-webdev <zofrex> if you remember I probably won't take 13 hours to reply next time
2018-03-17T22:08:59 #rust-webdev <SovietBeer> ok :)
2018-03-20T16:02:28 #rust-webdev <freefall> i'd really like to be able to query a subset of a table's columns in diesel without having to list the columns as a tuple in .select()
2018-03-21T09:15:35 #rust-webdev <sfackler> seanmonstar: at least for the low-level client::Connection, how would you feel about switching to something similar to what h2 does to handle the request body?
2018-03-21T09:15:51 #rust-webdev <sfackler> and response body
2018-03-21T09:16:17 #rust-webdev <sfackler> it's a bit of a pain to wrap stuff "around" the full request now since the body write is essentially spawned off
2018-03-21T19:15:53 #rust-webdev <seanmonstar> sfackler: what do you mean
2018-03-21T19:16:16 #rust-webdev <seanmonstar> that hyper::client::conn module hasn't been released yet, so there is time to consider changes
2018-03-21T19:17:14 #rust-webdev <sfackler> seanmonstar: in the hyper setup, you pass hyper a Request<Stream>, or Response<Stream>, whereas in h2 you pass a Request<()> or Response<()> and get a thing back that you write the body into
2018-03-21T19:17:46 #rust-webdev <sfackler> the second approach is a bit easier to work with when doing things like request logging that includes response times or body sizes for example
2018-03-21T19:18:01 #rust-webdev <sfackler> I can write up some pseudo-code if that's still kind of unclear
2018-03-21T19:18:34 #rust-webdev <seanmonstar> sfackler: fwiw, we're thinking of inverting h2's api in 0.2
2018-03-21T19:19:03 #rust-webdev <seanmonstar> having to write onto the SendStream kind of forces you to have to spawn 2 tasks
2018-03-21T19:20:19 #rust-webdev <sfackler> you essentially have to do that either way though right?
2018-03-21T19:20:30 #rust-webdev <sfackler> it's just whether you're doing it or the library is
2018-03-21T19:21:11 #rust-webdev <seanmonstar> well, only sometimes
2018-03-21T19:21:59 #rust-webdev <seanmonstar> if h2 holds a stream, then it can poll it inside the same task that is processing the request/response
2018-03-21T19:22:40 #rust-webdev <seanmonstar> i guess you mean that to provide a stream, a user needs to spawn a task to provide the eventual chunks?
2018-03-21T19:22:51 #rust-webdev <sfackler> yeah
2018-03-21T19:23:00 #rust-webdev <seanmonstar> right, so only sometimes
2018-03-21T19:23:36 #rust-webdev <seanmonstar> if you already have the data produced, or if you already have a stream from something else, you could just provide the stream
2018-03-21T19:23:54 #rust-webdev <seanmonstar> for instance, when we proxy, we already have the incoming body stream
2018-03-21T19:24:18 #rust-webdev <seanmonstar> since we have to push on the sender, it forces us to spawn a 3rd task, that simply forwards from the stream onto the sender
2018-03-21T19:25:06 #rust-webdev <seanmonstar> so by using this sink approach always, users always have to spawn a new task. if we take a stream, then not always
2018-03-21T19:26:17 #rust-webdev <sfackler> hmm
2018-03-21T19:27:58 #rust-webdev <sfackler> i guess that makes senes
2018-03-21T19:27:59 #rust-webdev <sfackler> *sense
2018-03-21T19:29:39 #rust-webdev <sfackler> moving from Stream to Entity or whatever it's called will hopefully make it a bit less weird to do "on completion" stuff
2018-03-21T19:30:16 #rust-webdev <sfackler> maybe we could add an explicit "completed" function that hyper/h2 calls when it's totally done with the request?
2018-03-21T19:30:36 #rust-webdev <sfackler> right now you either do stuff when the stream/entity drops or when you finish returning body chunks
2018-03-21T19:33:41 #rust-webdev <seanmonstar> hm, Drop seems kind of like the natural place, no?
2018-03-21T19:34:28 #rust-webdev <sfackler> as long as hyper doens't hold onto the type for some reason
2018-03-21T19:37:33 #rust-webdev <sfackler> I could imagine the future holding the entity to get chained onto something else that causes the entity to not drop for a while after the request is done
2018-03-21T19:38:30 #rust-webdev <seanmonstar> internally in hyper?
2018-03-21T19:39:07 #rust-webdev <sfackler> yeah
2018-03-21T22:32:10 #rust-webdev <seanmonstar> in hyper, if theres an error or the stream ends, its dropped immediately. though it could be possible for someone wrapping the Connection future to drop
2018-03-21T22:32:40 #rust-webdev <seanmonstar> but i believe itd only be a problem if the Connection werent poll enough to have determined the stream is done, so even a callback wouldn't have helped
2018-03-21T23:05:16 #rust-webdev <sfackler> yeah i'm not worried about the early-drop or no polling cases
2018-03-22T17:06:21 #rust-webdev <commie> has anyone been able to control Rocket(ideally) or Hyper chunking with streams so as not to wait for a full read and Ok(0) but instead send chunks on ErrorKind::Interrupted or similar?
2018-03-22T17:09:56 #rust-webdev <Sergio> commie: Not currently possible with Rocket.
2018-03-22T17:09:59 #rust-webdev <Sergio> But that will likely change soon.
2018-03-22T17:10:09 #rust-webdev <commie> oh man
2018-03-22T17:10:50 #rust-webdev <Sergio> What are you trying to do?
2018-03-22T17:13:02 #rust-webdev <commie> malware/ids reasearch: basically need to display a browsers ability to request additional resources as it decompresses each chunk of a stream. So if a stream should have 5 chunks, each with a different resource request, i want to show that a short time after recv chunk 1 it requests resource 1 despite not having recv chunks[2-5]
2018-03-22T17:14:08 #rust-webdev <commie> working with rocket up til this barrier has been fantastic!! all the documentation appears to support it, but you are *the* person to know if it would work or not :)
2018-03-22T17:14:36 #rust-webdev <Sergio> Why do you need to be able to send early?
2018-03-22T17:15:06 #rust-webdev <Sergio> Asked another way, how does the current behavior impede what you're trying to do?
2018-03-22T17:15:11 #rust-webdev <commie> gotcha
2018-03-22T17:20:28 #rust-webdev <commie> its slightly hard to explain without giving up the exact issue im trying to display to corp engineering but lets try.... for our use case the browser will request a page that is chunked. for each chunk at the time of recv, it will parse that chunk and look for additional resources it should load such as images, js, etc. Lets now add a proxy between rocket and this browser, that is doing some form of detection to block malicious actions, how is 
2018-03-22T17:20:28 #rust-webdev <commie> not important. this proxy chooses to internally hold each chunk for the full page before detection, but in an effort to appease browsers also forwards on chunks[1-4] until 5 is recv. 
2018-03-22T17:21:31 #rust-webdev <commie> if there is something malicious being requested in chunks[1-4] the browser would already request these items well before the proxy had a chance to detect this, per browser requesting additional resources for each chunk
2018-03-22T17:22:45 #rust-webdev <commie> so i was hoping to add say 500ms delay to each chunk being sent to the browser. this would provide enough time for a low powered VM to display this async behavior and request resources from chunks[1-4] prior to 5 ever being sent by rocket
2018-03-22T17:23:28 #rust-webdev <Sergio> If all you want is a delay, then you can do it with Rocket.
2018-03-22T17:23:31 #rust-webdev <commie> i can see this is happening in the way rocket is polling and accessing read() from my type. however it strictly appears to wait for Ok(0)
2018-03-22T17:23:40 #rust-webdev <commie> i can? where did I miss it?
2018-03-22T17:23:45 #rust-webdev <Sergio> Well, it's not obvious.
2018-03-22T17:23:48 #rust-webdev <Sergio> And you would never do this for real.
2018-03-22T17:23:49 #rust-webdev <commie> :)
2018-03-22T17:23:54 #rust-webdev <commie> totally agree
2018-03-22T17:24:00 #rust-webdev <commie> security testing stuff is funky
2018-03-22T17:24:09 #rust-webdev <Sergio> Rocket waits until there is CHUNK_SIZE (or whatever the variable is) to send the chunk.
2018-03-22T17:24:15 #rust-webdev <Sergio> So as to minimize overhead.
2018-03-22T17:24:37 #rust-webdev <Sergio> Anyway, long story short, just sleep() on the read.
2018-03-22T17:25:47 #rust-webdev <Sergio> If you know the chunk size (which you can set: https://api.rocket.rs/rocket/response/struct.ResponseBuilder.html#method.chunked_body), then you can sleep right after the nth chunk is sent by simply keeping track of how much data you've sent.
2018-03-22T17:26:11 #rust-webdev <commie> ok so i should just switch to sleep instead of erroring. OK cool that was the alternative i was thinking, and completely forgot to test
2018-03-22T17:26:34 #rust-webdev <Sergio> You can also just return Interrupted for whatever time you want.
2018-03-22T17:26:36 #rust-webdev <Sergio> Rocket will just keep retrying.
2018-03-22T17:26:42 #rust-webdev <Sergio> But why waste CPU cycles.
2018-03-22T17:27:11 #rust-webdev <commie> well thats what I am doing presently, i can see rocket builds the response with each chunk, but still holds them for the full read
2018-03-22T17:27:30 #rust-webdev <commie> let me see if i can build a gist without too much hassle. that would probably be a much better description
2018-03-22T17:29:00 #rust-webdev <Sergio> Do you mean it's not actually writing out the bytes to the network until all chunks are ready?
2018-03-22T17:32:21 #rust-webdev <commie> correct
2018-03-22T17:32:34 #rust-webdev <commie> that is 100% what i appear to be seeing
2018-03-22T17:32:43 #rust-webdev <Sergio> Rocket writes out a chunk as soon as it's ready.
2018-03-22T17:32:56 #rust-webdev <Sergio> But, it doesn't flush, so it's possible that the OS/Hyper is buffering.
2018-03-22T17:33:34 #rust-webdev <Sergio> You can test this by adding `stream.flush()` in this match arm: https://github.com/SergioBenitez/Rocket/blob/master/lib/src/rocket.rs#L161
2018-03-22T17:34:44 #rust-webdev <commie> let me try that
2018-03-22T18:21:03 #rust-webdev <commie> its so wonderful!!! thanks Sergio `stream.flush()?` works perfectly and displays my exact issue
2018-03-22T18:21:15 #rust-webdev <Sergio> commie: Awesome. :)
2018-03-22T18:22:37 #rust-webdev <freefall> anyone know why performance of actix-web appears to be an order of magnitude better than other rust web frameworks?
2018-03-22T20:25:22 #rust-webdev <seanmonstar> freefall: order of magnitude? which others?
2018-03-23T20:48:28 #rust-webdev <maikklein-M> Does anyone know if I can open streams with reqwest? I think I have to user hyper directly.
2018-03-23T20:48:51 #rust-webdev <seanmonstar> what does it mean to open a stream?
2018-03-23T20:49:36 #rust-webdev <maikklein-M> I want to listen for incoming values
2018-03-23T20:50:02 #rust-webdev <seanmonstar> say a little more
2018-03-23T20:50:17 #rust-webdev <maikklein-M> I send a get request and then I periodically receive values.
2018-03-23T20:50:30 #rust-webdev <maikklein-M> I am not familiar with the terminology.
2018-03-23T20:50:33 #rust-webdev <seanmonstar> in the body of the response?
2018-03-23T20:51:12 #rust-webdev <maikklein-M> yes, I think. At least I got it working that way with hyper
2018-03-23T20:51:30 #rust-webdev <seanmonstar> the Response is a Read, so you can call res.read(buf)
2018-03-27T21:34:56 #rust-webdev <maikklein-M> seanmonstar: If I do read on a Response, it always read 0 bytes. Is there a good way to debug this? It works in curl and the response header looks identical.
2018-03-27T21:38:12 #rust-webdev <maikklein-M> Uh okay I just needed to use read_line
2018-03-28T16:30:46 #rust-webdev <seanmonstar> maikklein-M: if read (with a non-zero buffer) returns Ok(0), its body is empty
2018-03-28T17:04:24 #rust-webdev <KB5> Hello everyone
2018-03-28T17:06:19 #rust-webdev <KB5> Can someone please explain the difference between actix-web, gotham and rocket to a newbie? Actix-Web appears to be based on actor model (not very knowledgeable on the subject) and excels in benchmarks, yet appears to be quite complex to use. Rocket seems to be exact opposite, preferring to accomplish most with least amount of code, could be easiest to learn and use? But where does Gotham fit?
2018-03-28T17:15:17 #rust-webdev <Faux> Use rocket, it's the one people care about. The performance is excellent compared to other language's web frameworks.
2018-03-28T17:17:42 #rust-webdev <zygentoma> What I personally don't like about rocket is that you can't use it with stable rust … :/
2018-03-28T17:18:30 #rust-webdev <Faux> I gave up on stable rust long ago; nearly any random library you find online for anything interesting is going to be nightly only. I have had so few problems with nightly that it's not really worth running stable.
2018-03-28T17:19:20 #rust-webdev <KB5> Uh well yeah, I'd prefer to stay on stable
2018-03-28T17:19:45 #rust-webdev <zygentoma> yeah, at home I use nightly as well, but at work I need to stay with stable
2018-03-28T17:19:49 #rust-webdev <KB5> And if Rocket is the one people care about, what's the story behind Gotham then?
2018-03-28T17:20:39 #rust-webdev <Faux> Maybe it's people who can't put up with Rocket's nightly-only policy. Dunno. :)
2018-03-28T17:21:14 #rust-webdev <Faux> Gotham is async which means it's going to be ugly as hell like Actix.
2018-03-28T17:22:55 #rust-webdev <zygentoma> I built a project with iron, once … maybe one should resurrect that one ;)
2018-03-28T17:23:13 #rust-webdev <KB5> You'd need to resurrect Iron first, no? :)
2018-03-28T17:23:26 #rust-webdev <zygentoma> yeah, that's what I meant
2018-03-28T17:23:28 #rust-webdev <Faux> I also have two things live on Iron.
2018-03-29T12:01:32 #rust-webdev <charmander> hello, i checked the awwy-domain but is there a definite answer if using is really worth it for web? is there a field where rust is actually superior or decent compared to another option?
2018-03-29T13:07:33 #rust-webdev <Sergio> charmander: I think you can write faster, safer web applications in Rust. 
2018-03-29T13:07:40 #rust-webdev <Sergio> Here's my take: https://rocket.rs/overview/
2018-03-29T13:58:29 #rust-webdev <freefall> i see people are proposing that rocket use actix-web over hyper now...
2018-03-29T14:15:07 #rust-webdev <charmander> are there any example applications that are actually built with rocket?
2018-03-29T14:15:45 #rust-webdev <Sergio> Lots of stuff is built with Rocket. A lot of it is private, like NPM's stuff. 
2018-03-29T14:16:14 #rust-webdev <Sergio> Not sure what you mean by "example" though. The repository has lots of examples, but they're fairly small. The todo example is bigger. 
2018-03-29T15:07:55 #rust-webdev <SovietBeer> anyone using yew?
2018-03-29T15:08:07 #rust-webdev <SovietBeer> how are services better than subscriptions?
2018-03-29T15:08:16 #rust-webdev <SovietBeer> what about async chaining?
2018-03-29T19:02:13 #rust-webdev <smitra2> Hi guys, would anyone be able to help me out with translating some openssl 0.7.14 code to 0.9.x?
2018-03-29T19:03:48 #rust-webdev <Faux> Someone might if you ask.
2018-03-29T19:04:30 #rust-webdev <smitra2> Great, just wanted to make sure this channel was the right place to ask
2018-03-29T19:04:54 #rust-webdev <smitra2> So, first things first, are these features in-built now? "openssl = { version = "0.7.14", features = ["tlsv1_2", "npn", "alpn"] }"
2018-03-29T19:06:44 #rust-webdev <Faux> Seems likely.
2018-03-29T19:08:17 #rust-webdev <smitra2> Oh hm, it looks like this package I'm trying to adapt (apns2-rust) uses a package (solicit), and that uses the old openssl, and I can't mix versions :/
2018-03-29T19:12:29 #rust-webdev <Faux> Time to update solict first, then!
2018-03-29T19:12:54 #rust-webdev <Faux> hyper/reqwest Just About(tm) have support for http/2 so it might not be so important anymore.
2018-04-01T18:59:07 #rust-webdev <ehiggs> Hi all! Is there a production quality websocket framework?
2018-04-02T14:21:14 #rust-webdev <GrayShade> seanmonstar: I'm having some trouble with EMFILE since hyper 0.11.23
2018-04-02T14:21:38 #rust-webdev <GrayShade> I think it might be related to https://github.com/hyperium/hyper/pull/1450
2018-04-02T14:24:24 #rust-webdev <GrayShade> my code is here https://github.com/scottlamb/http-serve/blob/master/benches/file.rs#L92, strace output is here https://bpaste.net/show/0ba07df1fe35, console is here https://bpaste.net/show/f25e6f535b8b
2018-04-02T14:24:38 #rust-webdev <GrayShade> accept4() returns EMFILE, because there are too many open sockets
2018-04-02T14:25:36 #rust-webdev <GrayShade> it also seems to poll on accept4() for a while, not sure why
2018-04-02T14:26:04 #rust-webdev <GrayShade> do you have any idea what it might be?
2018-04-02T14:27:30 #rust-webdev <GrayShade> oops, this should have been in #hyper
2018-04-02T17:00:26 #rust-webdev <seanmonstar> GrayShade: the errors look like from a client, right?
2018-04-02T20:29:40 #rust-webdev <GrayShade> seanmonstar: I don't think so, the error is on accept()
2018-04-02T20:32:05 #rust-webdev <seanmonstar> GrayShade: ah, the failure output looks like errors from reqwest
2018-04-02T20:32:20 #rust-webdev <GrayShade> thread '<unnamed>' panicked at 'called `Result::unwrap()` on an `Err` value: Io(Os { code: 24, kind: Other, message: "Too many open files" })', libcore/result.rs:945:5
2018-04-02T20:32:25 #rust-webdev <GrayShade> that one is the server
2018-04-02T20:32:39 #rust-webdev <GrayShade> the client then panics because the server died
2018-04-02T20:36:08 #rust-webdev <seanmonstar> GrayShade: im guess the panic is from here? https://github.com/scottlamb/http-serve/blob/master/benches/file.rs#L63
2018-04-02T20:36:43 #rust-webdev <seanmonstar> in 0.11.x, the sleep on error stuff isn't on by default
2018-04-02T20:36:56 #rust-webdev <GrayShade> accept4(9, 0x7fb6dbffb970, [128], SOCK_CLOEXEC) = -1 EMFILE (Too many open files)
2018-04-02T20:37:23 #rust-webdev <seanmonstar> so yea, its definitely seeing that error since theres too many fds open
2018-04-02T20:38:27 #rust-webdev <GrayShade> I should have included connect in the strace filter
2018-04-02T20:39:18 #rust-webdev <seanmonstar> so, the pooling in hyper changed a little to be less complicated, but i do think it made it possible for some cases to not see an available idle connection before creating a new one
2018-04-02T20:40:15 #rust-webdev <seanmonstar> GrayShade: it could be that your benchmark is managing to hit that, and create a new connection isntead of reuse the just-about-to-be-idle one
2018-04-02T20:40:33 #rust-webdev <seanmonstar> (not saying its the benchmark's fault)
2018-04-02T20:41:04 #rust-webdev <GrayShade> that would make sense, but.. is that on the client side?
2018-04-02T20:41:38 #rust-webdev <seanmonstar> GrayShade: yes, but since your client and server are in the same process, they share the FD limit
2018-04-02T20:43:48 #rust-webdev <seanmonstar> to be clear, if its what im describing, its a bug in hyper/reqwest
2018-04-02T20:46:54 #rust-webdev <GrayShade> I'm no longer able to run it under strace :/
2018-04-02T20:47:02 #rust-webdev <GrayShade> (it doesn't fail)
2018-04-02T20:47:05 #rust-webdev <GrayShade> different computer
2018-04-02T20:47:27 #rust-webdev <seanmonstar> hm, more cores available?
2018-04-02T20:47:41 #rust-webdev <GrayShade> yes
2018-04-02T20:47:58 #rust-webdev <GrayShade> should I try cpuset?
2018-04-02T20:48:05 #rust-webdev <GrayShade> cpu..
2018-04-02T20:49:22 #rust-webdev <seanmonstar> it definitely would be more noticeable with less cores, since the threads putting the idle connection back into the pool are different than the one starting the request (in this bench)
2018-04-02T20:49:48 #rust-webdev <GrayShade> on a third (even slower) computer, it works even without strace
2018-04-02T20:50:24 #rust-webdev <GrayShade> but reqwest is sync, can that really happen?
2018-04-02T20:51:44 #rust-webdev <seanmonstar> the way reqwest exposes a sync api is by spawning an extra thread to run all requests asynchronously, and then the sync methods can basically call `fut.wait()`
2018-04-02T20:52:33 #rust-webdev <GrayShade> so after the future completes it could be possible that a connection isn't yet ready to be reused, so a new one gets created?
2018-04-02T20:52:55 #rust-webdev <seanmonstar> yes, its possible
2018-04-02T20:53:34 #rust-webdev <seanmonstar> (the connection is probably ready to be reused, but to detangle the pool code, some internal knowledge was removed such that it doesn't always know immediately)
2018-04-02T21:00:31 #rust-webdev <GrayShade> do you think it would be worth reducing that test case?
2018-04-02T21:07:26 #rust-webdev <GrayShade> I tried, but the obvious things didn't work
2018-04-02T21:17:27 #rust-webdev <GrayShade> if you want to test it, use https://github.com/lnicola/http-serve/tree/bump-deps and change hyper to =0.11.23
2018-04-02T21:19:48 #rust-webdev <GrayShade> I'll file an issue tomorrow otherwise
2018-04-03T18:37:44 #rust-webdev <seanmonstar> GrayShade: do you still see that flakiness? i may have thought of a solution to the problem i imagine, but curious if it happens often
2018-04-03T21:26:43 #rust-webdev <seanmonstar> GrayShade: if you have a reproducible thing, if you want to update the Cargo.toml to replace hyper with the 0.11.x branch, i believe it should be fixed
2018-04-03T21:59:57 #rust-webdev <GrayShade> seanmonstar: yes, it's reproducible for be
2018-04-03T22:00:20 #rust-webdev <GrayShade> do you mean https://github.com/hyperium/hyper/commit/7fe9710a98650efc37f35bb21b19926c015f0631 ?
2018-04-03T22:00:49 #rust-webdev <seanmonstar> GrayShade: yes
2018-04-03T22:01:38 #rust-webdev <GrayShade> but.. I don't know how to do that. the code depends on hyper both directly, and also through reqwest
2018-04-03T22:01:58 #rust-webdev <GrayShade> I'm not sure how to convince cargo to use a specific revision for both
2018-04-03T22:02:05 #rust-webdev <seanmonstar> GrayShade: using [replace] in your Cargo.toml can do it
2018-04-03T22:02:35 #rust-webdev <seanmonstar> well, [patch] is even better
2018-04-03T22:03:10 #rust-webdev <seanmonstar> GrayShade: [patch.crates-io] hyper = { git = "https://github.com/hyperium/hyper", branch = "0.11.x" }
2018-04-03T22:03:29 #rust-webdev <seanmonstar> cargo will sub that in for anything in your dependency graph trying to use hyper
2018-04-03T22:05:30 #rust-webdev <GrayShade> hmm, cargo update fails with "error: no matching package named `hyper` found"
2018-04-03T22:05:45 #rust-webdev <GrayShade> "location searched: https://github.com/hyperium/hyper"
2018-04-03T22:05:53 #rust-webdev <GrayShade> that's strange
2018-04-03T22:08:45 #rust-webdev <GrayShade> oh, nvm
2018-04-03T22:15:31 #rust-webdev <GrayShade> seanmonstar: yup, it's working now
2018-04-03T22:38:56 #rust-webdev <GrayShade> to be more specific, that commit seems to fix the EMFILE issue for me
2018-04-03T23:16:04 #rust-webdev <seanmonstar> GrayShade: so, shipit? :D
2018-04-04T05:17:24 #rust-webdev <GrayShade> seanmonstar: yup! 
2018-04-06T20:22:37 #rust-webdev <sfackler> seanmonstar: futures 0.2 was the last external blocker for a new hyper release, right?
2018-04-06T20:24:21 #rust-webdev <seanmonstar> sfackler: sorta, the integration of futures 0.2 with tokio is buggy :(
2018-04-06T20:25:58 #rust-webdev <sfackler> ah :(
2018-04-06T20:35:59 #rust-webdev <seanmonstar> as an alternative, i'm working on a futures-compat crate atm
2018-04-06T21:23:44 #rust-webdev <seanmonstar> sfackler: and this comment has me in a bit of conundrum as well https://www.reddit.com/r/rust/comments/8ac85w/futures_02_is_here/dwxm9on/
2018-04-06T21:27:25 #rust-webdev <sfackler> well that solves the tokio compat problem then! :P
2018-04-06T21:29:40 #rust-webdev <carllerche> sfackler: what do you mean?
2018-04-06T21:29:52 #rust-webdev * carllerche pops head out of the sand
2018-04-06T21:30:16 #rust-webdev <sfackler> seanmonstar was saying that there were some bugs with the futures 0.2 tokio integration
2018-04-06T21:30:32 #rust-webdev <carllerche> ah yeah... there are segvs :P
2018-04-07T11:36:41 #rust-webdev <aep> any idea how to implement a timeout for hyper::Client?
2018-04-07T11:36:54 #rust-webdev <aep> or any alternatives that have timeouts?
2018-04-07T11:48:08 #rust-webdev <freefall> aep: did you see https://hyper.rs/guides/client/timeout/ ?
2018-04-07T12:00:29 #rust-webdev <aep> nice thanks
2018-04-07T12:00:42 #rust-webdev <aep> that doesnt work for the server right?
2018-04-07T12:00:52 #rust-webdev <aep> since there's nothing you can hook into before http was parsed
2018-04-07T12:08:45 #rust-webdev <freefall> aep: did you see this example? https://docs.rs/hyper/0.11.25/hyper/server/trait.Service.html#middleware
2018-04-07T12:09:12 #rust-webdev <freefall> not sure if it actually works
2018-04-07T12:09:35 #rust-webdev <aep> yes, but that's not the timeout i need
2018-04-07T12:09:51 #rust-webdev <aep> it's fairly easy to DOS hyper by not finishing the http header
2018-04-07T12:09:58 #rust-webdev <aep> at that point the service isnt called yet
2018-04-07T12:20:07 #rust-webdev <freefall> hopefully seanmonstar can comment on what's possible at the HTTP parsing stage and earlier
2018-04-07T13:49:59 #rust-webdev <diego> Hi, I am experiencing an issue using the hyper HTTP client on a web application which is served in the hyper server. I have some code which makes a request to a 3rd party system, if my application executes this code before starting the hyper server, it works well, it fetches contents from 3rd party API, however if the SAME code is executed after th
2018-04-07T13:49:59 #rust-webdev <diego> e hype server has been started, when the server receives an HTTP request. I get this error "cannot recursively call into Core"
2018-04-07T13:52:25 #rust-webdev <aep> both are on the same core?
2018-04-07T13:54:42 #rust-webdev <diego> No, they are different components all together, so I didn't write the server, just the client you see. The server was written by my friend.
2018-04-07T13:55:10 #rust-webdev <diego> I create a new core in my client and use that
2018-04-07T13:56:39 #rust-webdev <aep> and you're waiting for the client core to return first?
2018-04-07T13:56:48 #rust-webdev <diego> Also I had to import the tokio_core library as they server wasn't using it so I assumed servers don't need cores?
2018-04-07T13:57:35 #rust-webdev <aep> the default api just hides the core
2018-04-07T13:57:44 #rust-webdev <diego> Ah okay, I am calling core.run in my client, is that waiting ?
2018-04-07T13:58:11 #rust-webdev <aep> yah, but are you executing the server _after_ that?
2018-04-07T13:59:03 #rust-webdev <diego> Don't know what you mean, sorry only been working with this library for a couple days can you explain please ?
2018-04-07T13:59:17 #rust-webdev <aep> can you show some code?
2018-04-07T13:59:40 #rust-webdev <diego> Sure I'll create a paste bin with my client code
2018-04-07T14:00:13 #rust-webdev <aep> nah, just where it's called
2018-04-07T14:03:03 #rust-webdev <diego> It's a bit hard to share because it's in the middle of some graphql code, but essentially these are the lines of code used to call the client.
2018-04-07T14:03:08 #rust-webdev <diego> let mut api_client = ApiClient::new();
2018-04-07T14:03:08 #rust-webdev <diego>         api_client.fetch_product();
2018-04-07T14:03:30 #rust-webdev <diego> ApiClient code is here https://pastebin.com/FLFBgR9Z
2018-04-07T14:04:12 #rust-webdev <diego> This code is executed when I make a request to the graphql server from the browser.
2018-04-07T14:04:49 #rust-webdev <aep> is the client called from the server code?
2018-04-07T14:05:56 #rust-webdev <diego> Yeah, I have got hyper and then a graphql library called juniper which defines resolvers for requests, it's in one those resolvers.
2018-04-07T14:06:13 #rust-webdev <aep> yes, dont do that
2018-04-07T14:06:18 #rust-webdev <aep> you're blocking the server core
2018-04-07T14:06:28 #rust-webdev <aep> return a future
2018-04-07T14:06:53 #rust-webdev <diego> Where ?
2018-04-07T14:07:09 #rust-webdev <aep> from fetch_product()
2018-04-07T14:07:42 #rust-webdev <diego> I see, how can I return a Future there, after calling core.run ?
2018-04-07T14:08:57 #rust-webdev <aep> dont call core.run. use the servers core.
2018-04-07T14:09:05 #rust-webdev <aep> look at the bottom of this page https://hyper.rs/guides/server/response_strategies/
2018-04-07T14:09:21 #rust-webdev <aep> 'The ResponseExamples Service'
2018-04-07T14:09:56 #rust-webdev <aep> or i guess you could spawn a thread
2018-04-07T14:17:50 #rust-webdev <diego> okay, don't know at this point how to do that, could you modify the code I shared to show me? I have to look into the hyper server at some point.
2018-04-07T14:18:03 #rust-webdev <diego> If it's easy
2018-04-07T14:20:05 #rust-webdev <aep> not really. you'd have to change at least the service to pass the core. see the link for how to do that
2018-04-07T14:21:18 #rust-webdev <diego> Okay, will have a read through the server's documentation today to make my client play nicely with it. Thank you very much for your help, I really appreciate it.
2018-04-07T18:42:42 #rust-webdev <aep> any idea how to create a hyper::Response from a futures::Stream ?
2018-04-07T18:43:14 #rust-webdev <aep> it looks like the only api is Response::with_body which expects a Body, which can only be constructed from full strings
2018-04-07T19:12:53 #rust-webdev <sfackler> aep: https://docs.rs/hyper/0.11.25/hyper/struct.Body.html#method.pair
2018-04-07T19:29:09 #rust-webdev <aep> yeah that requires a channel tho
2018-04-07T19:29:12 #rust-webdev <aep> i dont do threads
2018-04-07T19:29:28 #rust-webdev <aep> i think i found a hack anyway, thanks
2018-04-07T19:29:38 #rust-webdev <sfackler> you don't need threads to use channels
2018-04-07T19:30:48 #rust-webdev <aep> well, still sounds like overhead
2018-04-08T14:29:01 #rust-webdev <diego> Hi, I have a question about Futures, I have an application with the following architecture : A hyper http server passes requests to a graphQL server implemented using the Juniper library, the graphQL server uses my custom library to fetch data for a web api to fulfil the graphql request (it uses the hyper client to fetch the data). I am struggling 
2018-04-08T14:29:01 #rust-webdev <diego> at the moment with the hyper client, it returns a future, but I don't know how to execute that future, I can't pass it back to the hyper server code as a response because the Juniper library won't let me.
2018-04-08T14:29:10 #rust-webdev <diego> how can I execute that future and wait for it to complete in my library ?
2018-04-08T17:40:03 #rust-webdev <alsuren> @diego your hyper http server's GET callback is expected to return a Future. You need to coerce the Future returned by hyper::client into the form that hyper::server expects
2018-04-08T17:41:19 #rust-webdev <alsuren> you can use Future.then() and Future.and_then() to process the http response 
2018-04-08T17:42:48 #rust-webdev <diego> Let me share some code with you
2018-04-08T17:43:24 #rust-webdev <alsuren> There are a bunch of examples of this pattern in the Gotham repo at https://github.com/gotham-rs/gotham/tree/master/examples/handlers#handler-examples but but the ideas should be translatable to raw hyper if you're lucky
2018-04-08T17:43:36 #rust-webdev <diego> https://pastebin.com/6tknjz4c
2018-04-08T17:44:32 #rust-webdev <diego> The hyper::client returns a future, but I need a way to wait for that future and access the resulting data there and then in the graphql resolver function.
2018-04-08T17:44:58 #rust-webdev <diego> Because the Juniper graphql resolver function must return a data structure (product).
2018-04-08T17:45:34 #rust-webdev <alsuren> do you have a repo with your full in-progress setup?
2018-04-08T17:45:40 #rust-webdev <diego> I actually found this which if I understand correctly, means you cannot use Futures with Juniper yet. https://github.com/graphql-rust/juniper/issues/2
2018-04-08T17:45:56 #rust-webdev <diego> It's a private one at the moment unfortunately, I don't own it.
2018-04-08T17:46:17 #rust-webdev <diego> But hold on I'll see what I can do
2018-04-08T17:49:07 #rust-webdev <diego> Do you have atom? I can enable teletype
2018-04-08T17:50:15 #rust-webdev <alsuren> not at the moment
2018-04-08T17:52:48 #rust-webdev <diego> Ah okay, but did you see the code I shared? Do you know how to get the computed value of the future ?
2018-04-08T17:53:35 #rust-webdev <diego> As I understand it I would need to pass the future to an executor, maybe I can just instantiate a new one? using the hyper library.
2018-04-08T17:54:58 #rust-webdev <alsuren> I'm assuming that FieldResult<Product> is a thing that juniper forces you to return?
2018-04-08T17:55:12 #rust-webdev <diego> Yeah
2018-04-08T17:55:41 #rust-webdev <alsuren> (sorry, I got distracted trying to work out whether https://github.com/actix/actix-web/blob/master/examples/juniper/src/main.rs contains any useful patterns that you might be able to use. I don't know either technology well enough though
2018-04-08T17:56:38 #rust-webdev <diego> Was your first idea to pass the future along to the hyper server as a response ?
2018-04-08T17:56:53 #rust-webdev <diego> Then let the hyper server execute it ?
2018-04-08T17:57:20 #rust-webdev <alsuren> yeah
2018-04-08T17:58:13 #rust-webdev <diego> I am starting to think that is the only way of doing it, which means I can't use Futures with Juniper, but then are there any other ways of calling a web api, without using the hyper::client and Futures?
2018-04-08T17:58:22 #rust-webdev <alsuren> Is juniper trying to act as an http server in your case, or more like a generic library for managing graphql syntax/state?
2018-04-08T17:59:31 #rust-webdev <diego> Like a library, so the server is hyper, but then it delegates the logic to Juniper which my code talks to so it's like an intermediary between my code and the hyper server.
2018-04-08T18:00:26 #rust-webdev <diego> And because of how grapthQL works, I am forced to return structs, such as a product in this case, which Juniper transforms into a GraphQL response which passes back to hyper server, I then transform that into a future which hyper executes.
2018-04-08T18:01:17 #rust-webdev <diego> But I would like to execute a future before Juniper returns the struct to the hyper server, before that is the only way I can generate the struct in the first place
2018-04-08T18:08:54 #rust-webdev <alsuren> I mean... you could use future.wait() but that's completely missing the point of futures ;-)
2018-04-08T18:09:38 #rust-webdev <diego> Yeah and also I tried that and it never returns because I am guessing I still need to pass it to an executor.
2018-04-08T18:10:27 #rust-webdev <diego> I mean if that is what it takes, it wouldn't be the end of the world if my web api call blocks the program until is complete, at this point I just want to get it working.
2018-04-08T18:11:16 #rust-webdev <diego> But I only know the hyper::client to make web api requests and it seems it always uses futures so I don't know how to do a blocking web api call that doesn't involve futures at all.
2018-04-08T18:12:21 #rust-webdev <alsuren> I have to head off soon, and I'm still not clear how everything fits together
2018-04-08T18:12:32 #rust-webdev <alsuren> can you paste the code that calls `field product(&executor, sku: String) -> FieldResult<Product>`?
2018-04-08T18:14:11 #rust-webdev <diego> one sec
2018-04-08T18:16:31 #rust-webdev <diego> I can share the hyper server code, which calls request.execute and passes in my custom graphql schema, The actually call to my product resolver function you mention is done by Juniper internally if it detects the request is looking for a product so I don't have the code for that.
2018-04-08T18:16:33 #rust-webdev <diego> https://pastebin.com/eLwrQ7hY
2018-04-08T18:18:33 #rust-webdev <diego> request.execute is a Juniper method as well, it basically maps an http requests and figures out what resolvers functions it needs to call to fulfil it. In this case the response is asking for a product so my product function ends up being called, and it needs to return a product struct.
2018-04-08T18:18:50 #rust-webdev <diego> *request is asking for a product
2018-04-08T18:21:30 #rust-webdev <diego> Do you know how to make a web api call in a blocking way, without relying on futures?, it is disappointing but It looks like I am going to have to do it that way.
2018-04-08T18:22:35 #rust-webdev <alsuren> use an older version of hyper that doesn't use futures?
2018-04-08T18:23:12 #rust-webdev <alsuren> or use reqwest, which hasn't yet migrated to using futures
2018-04-08T18:23:25 #rust-webdev <alsuren> I have to go now
2018-04-08T18:23:46 #rust-webdev <diego> Thanks for you help mate
2018-04-08T18:23:54 #rust-webdev <diego> Will look into those :)
2018-04-09T21:26:57 #rust-webdev <FreeMasen> I am curious if it is possible to join the future returned from `hyper::Server::Run` with another future. Currently I am getting the Error that `join` is not implemented on `(): futures::Future`
2018-04-12T22:17:27 #rust-webdev <doc_tuna> does rocket run on rust stable?
2018-04-12T22:17:47 #rust-webdev <doc_tuna> i think i originally picked iron over rocket because it worked on stable
2018-04-12T22:19:29 #rust-webdev <eijebong> doc_tuna: It doesn't
2018-04-12T22:45:10 #rust-webdev <doc_tuna> :(
2018-04-12T22:45:27 #rust-webdev <doc_tuna> do we know if it ever will?
2018-04-12T22:45:50 #rust-webdev <doc_tuna> or if theres like a target rust release where it will?
2018-04-12T22:51:10 #rust-webdev <ytain_> rocket requires proc_macro2 which is only available on nightly, so till the proc_macro2 is stabilized and available on stable, rocket still requires nightly
2018-04-12T22:51:30 #rust-webdev <Sergio> proc_macro2 is a crate, which Rocket doesn't use.
2018-04-12T22:51:40 #rust-webdev <Sergio> But yes, Rocket requires procedural macros
2018-04-12T22:51:50 #rust-webdev <ytain_> oh, sorry
2018-04-12T22:52:06 #rust-webdev <Sergio> (It will soon though, so you're only wrong for now!)
2018-04-12T22:52:13 #rust-webdev <Sergio> But also, proc_macro2 works with stable.
2018-04-12T22:52:21 #rust-webdev <Sergio> doc_tuna: My hope is that Rocket will compile on stable by the end of the year.
2018-04-12T22:52:32 #rust-webdev <Sergio> Ideally with the Rust 2018 edition being released in September.
2018-04-12T22:52:43 #rust-webdev <Sergio> I'm trying to work with the core team now to make it happen.
2018-04-12T22:53:42 #rust-webdev <doc_tuna> cool
2018-04-12T22:54:19 #rust-webdev <doc_tuna> thanks for the detailed reply :)
2018-04-13T06:42:05 #rust-webdev <GrayShade> doc_tuna: there's also https://gotham.rs/, which I haven't used and doesn't seem as nice as Rocket, but works on stable now and is async
2018-04-13T06:42:19 #rust-webdev <GrayShade> iron is kind of unmaintained
2018-04-15T18:15:35 #rust-webdev <Diego> Hi, I am using hyper server to run a web application, when I start the server, I get a tokio_core::reactor::Handle object which I pass around my application, at some point I have Future which I want to wait on until its resolved, I only see the Handle object has an spawn method which doesn't wait for the future to be resolved and doesn't rits value
2018-04-15T18:15:35 #rust-webdev <Diego> , is there a way to wait for the future by blocking the current thread?
2018-04-15T18:15:35 #rust-webdev <Diego> _
2018-04-15T18:39:44 #rust-webdev <GrayShade> Diego: you usually stick other futures at the end of that one
2018-04-15T18:40:17 #rust-webdev <GrayShade> and you can pass the final one to hyper
2018-04-15T18:41:01 #rust-webdev <Diego> I know, I am afraid I can't do that in my app because I am using a library which sits in between my domain logic and the hyper server which doesn't support Futures, and doesn't let me send the future back to the hyper server so that it can be resolved there.
2018-04-15T18:41:34 #rust-webdev <Diego> The library is Juniper, a graphql server
2018-04-15T18:41:54 #rust-webdev <GrayShade> maybe wait for it on a thread pool, then?
2018-04-15T18:42:13 #rust-webdev <Diego> How would I do that?
2018-04-15T18:42:38 #rust-webdev <GrayShade> the easiest way would be futures_cpupool, I suppose
2018-04-15T18:42:50 #rust-webdev <GrayShade> https://docs.rs/futures-cpupool/0.1.8/futures_cpupool/
2018-04-15T18:43:35 #rust-webdev <Diego> Does that return a future ?
2018-04-15T18:43:59 #rust-webdev <GrayShade> yes
2018-04-15T18:45:33 #rust-webdev <Diego> Will that work with my future which I think is somehow dependant on the hyper server's core ?
2018-04-15T18:46:01 #rust-webdev <GrayShade> I.. don't know
2018-04-15T18:46:01 #rust-webdev <Diego> I used the hyper core's handle to create the future.
2018-04-15T18:46:10 #rust-webdev <GrayShade> but if it doesn't, there's also futures::sync::mpsc::channel
2018-04-15T18:46:57 #rust-webdev <Diego> Okay thanks, will try those out
2018-04-15T18:47:13 #rust-webdev <GrayShade> you can e.g. create a Body value, get a sender from it, pass the Body to hyper, then, from another thread, you can use the sender to pass data for the client
2018-04-15T18:47:29 #rust-webdev <GrayShade> not sure if that made sense
2018-04-15T18:48:14 #rust-webdev <Diego> Don't have that much experience with concurrency so not as much as I would have liked :)
2018-04-15T18:49:07 #rust-webdev <Diego> If you could provide some code, I think that'd help, otherwise I will have to go through the documentation for those functions you mentioned.
2018-04-15T18:49:44 #rust-webdev <GrayShade> I can tell you how I'm using that. I have an app that reads files on a thread pool and streams the data back to the client
2018-04-15T18:50:03 #rust-webdev <GrayShade> over a Stream, which is mostly like Body
2018-04-15T18:50:21 #rust-webdev <GrayShade> hmm, I guess I can show you the code, but it's pretty much terrible
2018-04-15T18:50:50 #rust-webdev <Diego> My main problem understanding that is that I don't know what you mean by Body.
2018-04-15T18:51:09 #rust-webdev <Diego> Is that a Rust type ?
2018-04-15T18:51:24 #rust-webdev <GrayShade> it's a hyper type, it's what gets sent to the client
2018-04-15T18:51:46 #rust-webdev <GrayShade> https://docs.rs/hyper/0.11.25/hyper/struct.Body.html
2018-04-15T18:51:58 #rust-webdev <GrayShade> the body of the response
2018-04-15T18:52:50 #rust-webdev <Diego> Oh yeah, I don't have access to that, imagine if you had to pass a custom struct instead of that, that is my situation. I am inside a function which must return a struct I defined.
2018-04-15T18:53:20 #rust-webdev <Diego> I just a future which if I could execute and wait on it, It will give me the type I need back.
2018-04-15T18:54:05 #rust-webdev <GrayShade> so you have a future, want to do some sync stuff after it completes, then send it back to the client?
2018-04-15T18:55:06 #rust-webdev <Diego> so this is my architecture at the moment : Hyper Server <-> Juniper (GraphQL layer) <-> My Domain logic
2018-04-15T18:56:15 #rust-webdev <Diego> My domain logic can only talk to Juniper, and Juniper doesn't support Futures and needs me to return a struct instead, the problem is my domain logic called some 3rd party API to fetched the struct and it is inside a future.
2018-04-15T18:56:27 #rust-webdev <Diego> If that makes sense
2018-04-15T18:57:03 #rust-webdev <Diego> I used the hyper client to call the 3rd party API and hyper client works with futures only :(
2018-04-15T18:57:34 #rust-webdev <GrayShade> then your domain logic is async, so Juniper can't call it
2018-04-15T18:57:49 #rust-webdev <GrayShade> and if you block on it, you'll also block the hyper's event loop?
2018-04-15T18:57:53 #rust-webdev <GrayShade> -'s*
2018-04-15T18:58:19 #rust-webdev <Diego> Yeah, I run into blocking the hyper's even loop before so I think you are right.
2018-04-15T18:58:52 #rust-webdev <GrayShade> and Juniper calls your code in response to a HTTP request?
2018-04-15T18:59:03 #rust-webdev <Diego> Yeah
2018-04-15T18:59:18 #rust-webdev <GrayShade> I guess moving the Juniper stuff to a thread pool could work, then
2018-04-15T18:59:58 #rust-webdev <GrayShade> you get back a future from the thread pool, and pass that to hyper
2018-04-15T19:00:09 #rust-webdev <GrayShade> it doesn't matter that it's not spawned on the same Core
2018-04-15T19:00:31 #rust-webdev <GrayShade> that is, if you don't run into issues with types not being Send
2018-04-15T19:01:39 #rust-webdev <Diego> That sounds like it could work
2018-04-15T19:02:18 #rust-webdev <GrayShade> but be aware that the API will change soon :)
2018-04-15T19:02:26 #rust-webdev <Diego> Which API ?
2018-04-15T19:03:54 #rust-webdev <GrayShade> hyper, tokio, then futures
2018-04-15T19:04:34 #rust-webdev <Diego> Yeah, that is going to be fun I think :)
2018-04-15T19:06:09 #rust-webdev <Diego> Just so I got this right, by creating a thread pool you mean, using this https://docs.rs/futures-cpupool/0.1.8/futures_cpupool/ to create a pool, then the hyper server will call spawn on it, and inside that Juniper will run along with my domain logic, then return a future back to hyper server?
2018-04-15T19:06:20 #rust-webdev <GrayShade> yup
2018-04-15T19:07:29 #rust-webdev <Diego> But wouldn't i still have the same issue where Juniper will call my domain logic which will create a future and I would still need to someone execute that future before I can pass it back through Juniper ?
2018-04-15T19:10:27 #rust-webdev <GrayShade> but you could safely block on your future
2018-04-15T19:10:43 #rust-webdev <GrayShade> relatively, note that the thread pool is fixed in size
2018-04-15T19:11:11 #rust-webdev <Diego> That is what I don't know how to do, block the current thread to wait for my future
2018-04-15T19:11:28 #rust-webdev <Diego> How do you do that ?
2018-04-15T19:11:32 #rust-webdev <GrayShade> .wait()?
2018-04-15T19:13:52 #rust-webdev <Diego> That doesn't work for me, I tried that but it never finishes. The only way I have been able to execute my future so far is by using the core Handle from the hyper server.
2018-04-15T19:14:22 #rust-webdev <Diego> Handle::spawn, but of course that doesn't wait for the future to finish so I can't use that.
2018-04-15T19:14:24 #rust-webdev <GrayShade> have you tried that on the thread pool?
2018-04-15T19:15:16 #rust-webdev <GrayShade> "This method is not appropriate to call on event loops or similar I/O situations because it will prevent the event loop from making progress (this blocks the thread). This method should only be called when it's guaranteed that the blocking work associated with this future will be completed by another thread."
2018-04-15T19:15:18 #rust-webdev <GrayShade> hmm
2018-04-15T19:15:35 #rust-webdev <Diego> No, I can try that just don't understand why it didn't work on the main thread. Do you think it will work on the thread pool, if so, what is the difference ?
2018-04-15T19:15:51 #rust-webdev <GrayShade> so your domain logic would need to run somewhere else, like on the Core, would that work?
2018-04-15T19:15:57 #rust-webdev <GrayShade> the same as hyper's
2018-04-15T19:16:18 #rust-webdev <Diego> On the same core as hyper's server ?
2018-04-15T19:16:36 #rust-webdev <Diego> Like running core.run(my domain future) ?
2018-04-15T19:18:01 #rust-webdev <GrayShade> like being returned by a hyper client that got passed the same Handle
2018-04-15T19:18:13 #rust-webdev <GrayShade> or a clone of it
2018-04-15T19:18:16 #rust-webdev <Diego> Yeah, I did that.
2018-04-15T19:18:19 #rust-webdev <GrayShade> same Handle as that of the Core
2018-04-15T19:18:21 #rust-webdev <GrayShade> okay, it's fine
2018-04-15T19:18:31 #rust-webdev <GrayShade> it hung because you had a deadlock
2018-04-15T19:18:43 #rust-webdev <Diego> Ah got you
2018-04-15T19:18:56 #rust-webdev <GrayShade> so.. tokio/hyper futures do IO and need to be polled by the Core to advance
2018-04-15T19:19:17 #rust-webdev <GrayShade> if the Core is busy, they don't get polled and do nothing
2018-04-15T19:19:49 #rust-webdev <GrayShade> thread pool futures are not like that: they get polled once to start (I think), run, finish, and that's all
2018-04-15T19:20:13 #rust-webdev <Diego> so do you think if I put that future which was created using the hyper server core's handle (clone) in a thread pool, it will work ?
2018-04-15T19:20:42 #rust-webdev <GrayShade> in your case you were calling wait() on a future that did IO, while you were on the Core's thread
2018-04-15T19:20:48 #rust-webdev <GrayShade> so it blocked waiting for itself
2018-04-15T19:21:19 #rust-webdev <Diego> Oh I see now
2018-04-15T19:21:22 #rust-webdev <GrayShade> I'm actually not sure what's the difference
2018-04-15T19:21:25 #rust-webdev <GrayShade> you could do either
2018-04-15T19:22:43 #rust-webdev <Diego> could you clarify which way you think it would work please?
2018-04-15T19:22:49 #rust-webdev <GrayShade> client.get(..).and_then(|response| pool.spawn(|| sync_stuff(response))
2018-04-15T19:23:07 #rust-webdev <GrayShade> (I'm not sure about the API, but you get the idea)
2018-04-15T19:23:16 #rust-webdev <GrayShade> and return that to hyper
2018-04-15T19:23:19 #rust-webdev <GrayShade> (the result of and_then)
2018-04-15T19:24:11 #rust-webdev <GrayShade> or you could do let f = client.get(...); pool.spawn(|| f.and_then(response));
2018-04-15T19:24:24 #rust-webdev <GrayShade> and return that
2018-04-15T19:24:49 #rust-webdev <GrayShade> I'm not sure about the difference between them, but I think the first one makes more sense
2018-04-15T19:25:05 #rust-webdev <Diego> what would f be at that point ?
2018-04-15T19:25:16 #rust-webdev <GrayShade> in the second case?
2018-04-15T19:25:34 #rust-webdev <GrayShade> it's the future returned by hyper::Client
2018-04-15T19:26:29 #rust-webdev <Diego> Yeah, not sure I understand. I can't work with a future, I need to get to a point where I have a variable holding the result of the future.
2018-04-15T19:26:41 #rust-webdev <Diego> I don't know how to get to that point
2018-04-15T19:27:11 #rust-webdev <GrayShade> brb. try the first way, response is the value, not a future
2018-04-15T19:28:12 #rust-webdev <Diego> okay
2018-04-15T21:03:55 #rust-webdev <GrayShade> did you try it?
2018-04-18T08:53:24 #rust-webdev <halia> hello! would it make sense to use rust for a REST-api and file uploading/downloading already? very important: HTTPS via TLS
2018-04-18T09:00:16 #rust-webdev <freefall> yes
2018-04-18T09:02:05 #rust-webdev <freefall> some of your options are https://github.com/actix/actix-web https://hyper.rs/ https://rocket.rs/ https://github.com/tomaka/rouille
2018-04-18T09:03:59 #rust-webdev <halia> ohh, cool, now i just gotta look for the best developed/best maintained one : D
2018-04-18T09:04:30 #rust-webdev <freefall> all of those are actively developed and maintained
2018-04-18T09:05:06 #rust-webdev <freefall> also https://gotham.rs/
2018-04-18T09:05:08 #rust-webdev <halia> afaik hyper is low level and the others are usually basing on it?
2018-04-18T09:05:29 #rust-webdev <freefall> rocket and gotham based on hyper, the others aren't
2018-04-18T09:06:17 #rust-webdev <halia> why are there so many web frameworks? isn't that wasted energy kinda?
2018-04-18T09:07:23 #rust-webdev <freefall> no. there are a lot of different trade-offs and design priorities in the http server space. different projects emphasize different things and have different priorities, and users then have a variety of options to choose from
2018-04-18T09:08:12 #rust-webdev <halia> i'm not that well versed in web, so that was a bit of a mean sounding comment of mine, sorry if that went into the wrong direction
2018-04-18T09:09:13 #rust-webdev <freefall> one big issue in rust is the state of async i/o. it's available but in a state of very rapid development and churn
2018-04-18T09:09:27 #rust-webdev <freefall> so different http servers take different positions on whether and how to support async
2018-04-18T09:11:04 #rust-webdev <halia> i will have to see which of them would suit me the best then, i guess : ) there is probably no guiding list i fear but the little descriptions on arewewebyet
2018-04-19T16:43:00 #rust-webdev <sfackler> seanmonstar: is there a meaningful difference timing-wise between when the body stream returns None and when the stream is dropped/
2018-04-19T16:43:36 #rust-webdev <sfackler> or more precisely, is one going to be more accurate than the other in being the "end time" of the request?
2018-04-19T22:36:01 #rust-webdev <seanmonstar> sfackler: a stream you provide, not hyper::Body received?
2018-04-19T22:36:19 #rust-webdev <sfackler> yeah
2018-04-19T22:40:04 #rust-webdev <seanmonstar> so currently, the stream is taken out of the Option self field, and polled. if it returns None, its just never put back in and that function returns shortly after
2018-04-19T22:40:39 #rust-webdev <seanmonstar> it does possibly buffer a `0\r\n\r\n` if chunked
2018-04-19T22:41:07 #rust-webdev <seanmonstar> so, it could be a a few nanoseconds difference, i suppose?
2018-04-19T22:41:09 #rust-webdev <sfackler> ok cool thanks
2018-04-19T22:42:00 #rust-webdev <seanmonstar> i'd recommend putting it in Drop
2018-04-19T22:42:22 #rust-webdev <seanmonstar> since i'd like to optimize by possible skipping a poll for None by checking is_end_stream
2018-04-19T22:42:44 #rust-webdev <sfackler> ah sure good point
2018-04-19T22:43:21 #rust-webdev <seanmonstar> would mean chunked streams could be ended one 1 poll earlier, and in h2, it can skip sending an empty DATA frame
2018-04-23T00:05:09 #rust-webdev <nerima> hello! if i want to design a server to upload and download files, receive database requestes and send data that shall be inserted, would rust be up to this task already or is it too complicated compared to go, php, ...?
2018-04-23T00:06:38 #rust-webdev <ytain> several web frameworks can do that as well
2018-04-23T00:06:42 #rust-webdev <ytain> written in rust
2018-04-23T00:06:51 #rust-webdev <ytain> like iron framework, rocket or actix
2018-04-23T00:06:58 #rust-webdev <nerima> async seems to be an issue tho
2018-04-23T00:07:05 #rust-webdev <Sergio> Actix is async
2018-04-23T00:07:08 #rust-webdev <freefall> nerima: it works well. you have several http servers to choose from, including hyper, rocket, actix-web, rouille, and gotham. for the database side the best option is diesel
2018-04-23T00:07:26 #rust-webdev <Sergio> But there are no popular async database drivers, as far as I know.
2018-04-23T00:07:37 #rust-webdev <nerima> i worked with diesel, not sure if it supports async
2018-04-23T00:07:41 #rust-webdev <Sergio> It does not.
2018-04-23T00:07:45 #rust-webdev <Sergio> But I don't see why you'd need async for what you want to do.
2018-04-23T00:07:56 #rust-webdev <nerima> it just seems natural for the task
2018-04-23T00:08:00 #rust-webdev <Sergio> How?
2018-04-23T00:08:00 #rust-webdev <freefall> but actix supports diesel nicely through its sync actor capability
2018-04-23T00:08:41 #rust-webdev <Sergio> Most popular web frameworks (Rails, Django, Laravel, etc.) aren't async, for instance.
2018-04-23T00:08:43 #rust-webdev <freefall> though i agree with Sergio that lots of people just seem to assume they need async when a lot of the time they really don't
2018-04-23T00:08:49 #rust-webdev <nerima> well, a lot of rest is also written in javascript, being functional, being async is kinda natural
2018-04-23T00:09:19 #rust-webdev <Sergio> "natural" is rather subjective.
2018-04-23T00:09:26 #rust-webdev <nerima> probably
2018-04-23T00:09:31 #rust-webdev <Sergio> Most people would claim that synchronous APIs are more natural.
2018-04-23T00:09:33 #rust-webdev <Sergio> "natural"
2018-04-23T00:09:42 #rust-webdev <nerima> what is the most supported and active web framework?
2018-04-23T00:09:51 #rust-webdev <Sergio> Probably Rocket
2018-04-23T00:09:53 #rust-webdev <Sergio> But it's not async.
2018-04-23T00:09:57 #rust-webdev <freefall> the fact that javascript is based on async i/o is neither here nor there, it's a quirk of the language and its runtimes
2018-04-23T00:10:13 #rust-webdev <nerima> i wonder why rust did not bother with async until now
2018-04-23T00:10:31 #rust-webdev <Sergio> Async in Rust is harder than in many other languages.
2018-04-23T00:10:38 #rust-webdev <Sergio> At the language design level, I mean.
2018-04-23T00:10:55 #rust-webdev <Sergio> Unless you do stackful coroutines, which for some reason or another, people don't like.
2018-04-23T00:11:28 #rust-webdev <freefall> people have been bothering about it in rust almost from the start, it just hasn't been generally usable til recently
2018-04-23T00:11:43 #rust-webdev <freefall> and one could argue about whether it's hit "usable" yet
2018-04-23T00:12:25 #rust-webdev <freefall> anyway, for most web things sync+threads is more than good enough
2018-04-23T00:14:16 #rust-webdev <nerima> ah, rocket is nightly only, so that's that
2018-04-23T00:14:23 #rust-webdev <Sergio> Ah, right.
2018-04-23T00:14:30 #rust-webdev <Sergio> Nightly's where it's at.
2018-04-23T00:17:21 #rust-webdev <nerima> are there any strong differences between gotham and actix-web?
2018-04-23T00:17:59 #rust-webdev <Sergio> I think they're pretty different.
2018-04-23T00:18:17 #rust-webdev <Sergio> gotham is built on hyper, and acxtix-web has its own HTTP library
2018-04-23T00:18:22 #rust-webdev <Sergio> actix*
2018-04-23T00:18:31 #rust-webdev <Sergio> actix seems to be a bit more active than gotham at the moment.
2018-04-23T00:19:32 #rust-webdev <Sergio> Not really sure what else.
2018-04-23T00:21:23 #rust-webdev <nerima> actix web says `SSL support with OpenSSL or native-tls`, but the second one is tls.. so it supports SSL and TLS, I assume
2018-04-23T00:23:41 #rust-webdev <ytain> native-tls means the SSL is provided by the OS
2018-04-23T00:23:49 #rust-webdev <ytain> not OpenSSL
2018-04-23T00:24:04 #rust-webdev <nerima> oh, so no TLS support? 
2018-04-23T00:24:19 #rust-webdev <ytain> what I meant the OS is the operating system
2018-04-23T00:24:37 #rust-webdev <ytain> TLS is always provided by every operating system
2018-04-23T00:24:49 #rust-webdev <ytain> if it provides a SSL library
2018-04-23T00:28:52 #rust-webdev <nerima> ahh. then i will probably have to compare both : )
2018-04-23T13:53:30 #rust-webdev <dbrgn> is there a migration guide for hyper 0.11 to 0.12? it seems that a *lot* changed.
2018-04-23T14:20:50 #rust-webdev <dbrgn> also, is it correct that the new http crate does not provide type safety on a HTTP header level anymore (so it's possible to return "Content-Length: asdf")? if yes, is there a discussion about this design decision somewhere?
2018-04-23T14:21:03 #rust-webdev <steveklabnik> 1. yes
2018-04-23T14:21:05 #rust-webdev <steveklabnik> 2. i forget where
2018-04-23T14:21:13 #rust-webdev <steveklabnik> i believe it introduces some extra costs
2018-04-23T14:21:18 #rust-webdev <steveklabnik> and you can still build such a thing on top of it
2018-04-23T14:21:28 #rust-webdev <steveklabnik> maybe seanmonstar knows where he laid that out :)
2018-04-23T14:24:19 #rust-webdev <dbrgn> ok. too bad, I really liked the type safe header API :) something like .header(CONTENT_LENGTH, &*$text.len().to_string()) looks weird (but maybe there are other, cleaner ways to set numeric headers).
2018-04-23T14:26:20 #rust-webdev <steveklabnik> you shouldn't need that * and not sure what the $ is
2018-04-23T14:34:56 #rust-webdev <dbrgn> ah, sorry. it's an expr :)
2018-04-23T14:35:04 #rust-webdev <steveklabnik> oh, a macro, i see
2018-04-23T14:35:07 #rust-webdev <steveklabnik> i don't write macros, heh
2018-04-23T14:35:59 #rust-webdev <dbrgn> the parameter to .header(...) is HeaderValue: http::HttpTryFrom<T>, which is not implemented for T=&String. only for T=&str.
2018-04-23T14:36:18 #rust-webdev <dbrgn> so in this case it seems required unfortunately :(
2018-04-23T17:29:44 #rust-webdev <seanmonstar> dbrgn: the changelog will include a list of breaking changes and fixes, and i'll try to outline them in the announcement too
2018-04-23T17:30:31 #rust-webdev <seanmonstar> as for typed headers, they aren't in the http crate, for good reason, but we can have a typed layer over it
2018-04-24T14:50:44 #rust-webdev <zelda> Hi, has anyone used mpsc::channel along with rocket? I'm not sure how to make it managed state. Can someone help?
2018-04-24T16:33:23 #rust-webdev <dbrgn> seanmonstar: it seems that hyper 0.12 Server::bind requires the service future to be Send, whereas before this was not a requirement. is that correct?
2018-04-24T18:26:35 #rust-webdev <seanmonstar> dbrgn: yes, and for the most part, the reason is because tokio and futures both seem to be moving to Executors that require Send by default
2018-04-24T20:34:45 #rust-webdev <megas> /quit
2018-04-24T20:34:52 #rust-webdev <megas> help
2018-04-24T20:34:54 #rust-webdev <megas> quit
2018-04-27T05:46:59 #rust-webdev <davidlewis> Hey everyone!
2018-04-27T05:55:15 #rust-webdev <Sergio> Hello, davidlewis!
2018-04-28T08:54:23 #rust-webdev <omix> I am writing a function which will return a websocket client and I think that I am getting the return types of `connect1` or `connect2` wrong: https://play.rust-lang.org/?gist=d66e17da6a4dac152f11e3cef2dfa9c8&version=stable&mode=debug
2018-05-03T14:09:19 #rust-webdev <nasenferrari> What is the recommended way to handle to handle multiple forms on a page/route in rocket?
2018-05-03T14:27:08 #rust-webdev <nasenferrari> Assigning ranks explicitly works for now, but is there a better solution?
2018-05-03T18:10:57 #rust-webdev <nasenferrari> Ok, so I'm now using Option<> and custom request guards, which seems to work nicely
2018-05-03T18:12:43 #rust-webdev <ytain_> nasenferrari you can ask in channel #rocket
2018-05-03T18:14:04 #rust-webdev <nasenferrari> Thanks, I didn't know about it. Still new to IRC
2018-05-04T18:42:07 #rust-webdev <sfackler> seanmonstar: is changing the method to GET after a 301/302 the "standard" approach in real world clients? it seems like reqwest does that but the rfc claims that wasn't intended
2018-05-04T18:42:35 #rust-webdev <seanmonstar> yes
2018-05-04T18:42:48 #rust-webdev <sfackler> yay "standards"
2018-05-04T18:42:58 #rust-webdev <seanmonstar> it wasnt intended, but its what ended up happening, so they eventually added new status codes, 307/308, for that
2018-05-05T12:29:38 #rust-webdev <golergka> Hi. I'm trying to create an integration test suite for my diesel-backed app, but I'm still a bit confused. I'm new to Rust and didn't use integration tests before — where should I put the initialization that should run before all integration tests (creating a test db and running embedded migrations on it)?
2018-05-14T17:01:20 #rust-webdev <tac> What technologies do people use to stream videos (like in YouTube, Vimeo, Twitch)?
2018-05-15T23:44:16 #rust-webdev <doc_tuna> tac: late reply here, but i think they're just progressively downloading files, all the magic is done on the front end in js/html5, previously flash
2018-05-15T23:46:31 #rust-webdev <doc_tuna> for live streaming stuff i'm not sure
2018-05-15T23:54:20 #rust-webdev <doc_tuna> servers might just pretend they're serving up a static file still
2018-05-16T13:58:16 #rust-webdev <SovietBear> anyone here using stdweb or yew?
2018-05-16T14:36:45 #rust-webdev <svenstaro> SovietBear: absolutely
2018-05-16T14:36:51 #rust-webdev <svenstaro> me, for instance
2018-05-16T14:38:23 #rust-webdev <SovietBear> svenstaro: nice :)  btw, do you know how i can get a pointer to a `html! { <canvas></canvas> }` dom element, so that i can call stdweb's `fill_rect()` on it?
2018-05-16T14:38:34 #rust-webdev <svenstaro> uh no idea
2018-05-16T14:38:34 #rust-webdev <SovietBear> https://github.com/koute/stdweb/pull/80/files#diff-f6c540db6098f68dcb244aeeb396e8f8R37
2018-05-16T14:38:41 #rust-webdev <svenstaro> you might have more luck in the gitter btw
2018-05-16T14:38:53 #rust-webdev <svenstaro> the yew and stdweb people use gitter a lot more
2018-05-16T14:39:05 #rust-webdev <SovietBear> but there is no yew gitter channel, right?
2018-05-16T14:39:31 #rust-webdev <svenstaro> there is
2018-05-16T14:39:43 #rust-webdev <svenstaro> called "yewframework"
2018-05-16T14:39:45 #rust-webdev <svenstaro> for some reason
2018-05-16T14:39:50 #rust-webdev <SovietBear> ah! thanks :)
2018-05-16T14:40:28 #rust-webdev <svenstaro> you're welcome
2018-05-16T14:40:43 #rust-webdev <SovietBear> svenstaro: hm, i can't find it with google
2018-05-16T14:41:03 #rust-webdev <SovietBear> ah nvm, i found it through gitter search
2018-05-16T15:51:19 #rust-webdev <Axelderan> Does anyone know of any businesses using Rust for web development in a production capacity?  Or perhaps experimenting with it on a dev server somewhere?
2018-05-16T15:55:39 #rust-webdev <steveklabnik> npm, inc
2018-05-16T15:56:44 #rust-webdev <steveklabnik> i think onesignal?
2018-05-16T15:57:07 #rust-webdev <Axelderan> thanks, I currently do Rails dev but I'm considering a future with typed languages
2018-05-16T15:57:15 #rust-webdev <Axelderan> and I've enjoyed the past few months with Rust
2018-05-16T15:57:16 #rust-webdev <steveklabnik> there's also a lot of stuff that's web-adjacent, but may not exactly be what you're thinking of
2018-05-16T15:57:26 #rust-webdev <steveklabnik> ah hi! i used to work on rails before i started with rust :)
2018-05-16T15:57:33 #rust-webdev <steveklabnik> there's no rails equivalent yet
2018-05-16T15:57:50 #rust-webdev <Axelderan> That's fine.  Rocket looks adequate.
2018-05-16T15:57:53 #rust-webdev <steveklabnik> over the next 6 months or so, a lot of stuff is gonna shake out with regards to the web dev story
2018-05-16T15:57:58 #rust-webdev <Axelderan> Cool.
2018-05-16T15:58:04 #rust-webdev <Axelderan> Thanks for the great docs, by the way
2018-05-16T15:58:09 #rust-webdev <steveklabnik> you're welcome!
2018-05-16T15:58:36 #rust-webdev <Axelderan> phone interview in 2 minutes, gtg
2018-05-16T15:58:40 #rust-webdev <Axelderan> will idle in here
2018-05-16T22:39:18 #rust-webdev <Calinou> steveklabnik: why will a lot of things change in the next 6 months when it comes to webdev in Rust?
2018-05-16T22:39:24 #rust-webdev <Calinou> I'm curious :P
2018-05-16T22:43:06 #rust-webdev <freefall> Calinou: https://blog.rust-lang.org/2018/03/12/roadmap.html
2018-05-16T22:43:37 #rust-webdev <freefall> notably futures/tokio + async/await
2018-05-17T16:25:04 #rust-webdev <steveklabnik> Calinou: yes, what freefall said. async/await, new futures/tokio releases, the release of a whole book, "asynchronous programming in rust"
2018-05-17T16:25:10 #rust-webdev <steveklabnik> not to mention wasm maturing
2018-05-18T00:37:21 #rust-webdev <jokerstroke> is there any way to check total download size of Rust? using Windows 7
2018-05-18T00:51:53 #rust-webdev <ytain> without installing any software no
2018-05-18T00:52:18 #rust-webdev <ytain> you could install curl or python and you have option to check for download size
2018-05-18T00:53:43 #rust-webdev <ytain> https://stackoverflow.com/questions/4497759/how-to-get-remote-file-size-from-a-shell-script   or    https://stackoverflow.com/questions/5909/get-size-of-a-file-before-downloading-in-python
2018-05-19T17:44:34 #rust-webdev <thomspoon> Hello, I'm trying to type alias an enum using: `pub type AwsRegion = rusoto_core::Region`, but for some reason when I include my lib, I get "no `AwsRegion` in `crate`. Did you mean to use `Region`?
2018-05-19T17:45:28 #rust-webdev <thomspoon> Damn wrong chat room, sorry
2018-05-21T13:35:33 #rust-webdev <zelda> what's the difference between resource and route in actix-web? resource is a set of routes? just this?
2018-05-29T23:23:15 #rust-webdev <sfackler> seanmonstar: reqwest doesn't publicly expose native-tls, right?
2018-05-29T23:25:38 #rust-webdev <seanmonstar> sfackler: the only way is indirectly, if you downcast `error.cause()`
2018-05-29T23:25:48 #rust-webdev <sfackler> cool thanks
2018-05-29T23:26:15 #rust-webdev <sfackler> a native-tls 0.2 is going to be coming out sometime soon for background
2018-05-29T23:35:02 #rust-webdev <seanmonstar> sweet!
2018-05-31T17:18:14 #rust-webdev <freefall> in actix-web, is there any good way to attach some non-string data to a request in a middleware?
2018-05-31T20:17:01 #rust-webdev <IslandUsurper> Is anyone at all working on a SOAP crate? I have a need to interact with some services, and I really would rather not do it in PHP or learn Java to do it.
2018-06-01T16:35:50 #rust-webdev <sfackler> seanmonstar: does hyper emit a write for each item in the body response stream or does it have some buffering?
2018-06-01T17:38:09 #rust-webdev <seanmonstar> sfackler: it will poll the body and buffer chunks until the body says its not ready, and *then* it will try a flush. it will also try to have bundled the headers with the body
2018-06-01T17:38:27 #rust-webdev <sfackler> interesting thanks
2018-06-01T17:38:39 #rust-webdev <seanmonstar> though, on by default, it will buffer without copying, using writev
2018-06-01T17:40:07 #rust-webdev <seanmonstar> since 2 write syscalls is usually much slower than copying into a buffer
2018-06-01T17:42:01 #rust-webdev <sfackler> does the server side of things automatically detect when writev's not supported and fall back to copying? looks like it can only be explicitly configured for clients
2018-06-01T17:44:22 #rust-webdev <seanmonstar> ah, so the default is to the auto strategy
2018-06-01T17:44:51 #rust-webdev <ytain_> writev is available on mac
2018-06-01T17:45:06 #rust-webdev <seanmonstar> a config was added to clients since someone noticed that the switch to using writev hurt the performance of their client requests
2018-06-01T17:45:16 #rust-webdev <seanmonstar> the config was added before the auto detection was added
2018-06-01T17:45:22 #rust-webdev <sfackler> ah ok
2018-06-01T17:45:54 #rust-webdev <seanmonstar> however, the detection happens per connection, so if you're only using 1 request per connection, the auto detection may not help you much
2018-06-01T17:46:42 #rust-webdev <sfackler> yeah all of the stuff i'm working with on both the client and server sides is tls'd so writev isn't going to work ever
2018-06-01T17:47:33 #rust-webdev <seanmonstar> yep
2018-06-01T17:48:47 #rust-webdev <sfackler> might be nice to add a `supports_writev` method to AsyncWrite or something
2018-06-01T17:48:59 #rust-webdev <seanmonstar> so, inside hyper::proto::h1::Conn, it defaults to Strategy::Auto, and will try a writev, observing if the iovecs were created. if they werent, after the first write call, it will flatten the remaining queue of buffers, and only call `write` from then on
2018-06-01T17:49:56 #rust-webdev <seanmonstar> a further optimization hyper could try is to maybe remember that setting depending on the TypeId of the transport used?
2018-06-01T17:50:27 #rust-webdev <sfackler> that could have issues if you're using a MaybeTlsStream or something like that
2018-06-01T17:50:34 #rust-webdev <sfackler> or even a Box<AsyncWrite>
2018-06-01T17:50:34 #rust-webdev <seanmonstar> then new connections could skip detection... but it might mean that a new transport of the same type was configured differently
2018-06-01T17:50:43 #rust-webdev <seanmonstar> thats true
2018-06-01T17:51:07 #rust-webdev <seanmonstar> would you like that config to exist for the server as well?
2018-06-01T17:51:16 #rust-webdev <sfackler> that'd work for me yeah
2018-06-01T17:51:40 #rust-webdev <sfackler> probably not a huge deal but it'd be nice to have
2018-06-01T17:57:43 #rust-webdev <seanmonstar> sfackler: https://github.com/hyperium/hyper/issues/1527
2018-06-01T17:57:59 #rust-webdev <sfackler> thanks!
2018-06-01T17:58:25 #rust-webdev <seanmonstar> sfackler: was the original question about buffering because you were seeing some odd behavior?
2018-06-01T18:01:04 #rust-webdev <sfackler> nope, I'm planning on restructuring how response compression works for the server i'm working on and wanted to see if I could be sloppy and stick the gzip header/footer in separate blocks than the data :)
2018-06-01T18:01:19 #rust-webdev <sfackler> without them ending up as their own chunks
2018-06-01T18:19:42 #rust-webdev <seanmonstar> sfackler: as long as they a yielded before a NotReady is gotten, they should be written together
2018-06-01T18:20:01 #rust-webdev <seanmonstar> one other condition is there is a max buffer size (and related config)
2018-06-01T18:20:06 #rust-webdev <sfackler> sure yeah
2018-06-01T18:20:54 #rust-webdev <seanmonstar> in 0.12, you could implement Buf and put the header/footer as separate slices, and only need 1 poll
2018-06-01T18:21:16 #rust-webdev <seanmonstar> if you're using TLS though, it will still get flattened so :shrug:
2018-06-01T18:29:37 #rust-webdev <sfackler> yeah
2018-06-01T18:29:51 #rust-webdev <sfackler> should be pretty easy to just tack them on myself
2018-06-01T18:32:21 #rust-webdev <seanmonstar> i havent looked into yet, but i wonder if using kernel TLS would mean writev is still a win
2018-06-01T18:39:44 #rust-webdev <sfackler> probably
2018-06-01T18:39:54 #rust-webdev <sfackler> openssl could also just add a SSL_writev :P
2018-06-01T19:17:57 #rust-webdev <seanmonstar> sfackler: actually, since openssl is going to write the encrypted bytes to a buffer anyways, and then flush when you ask, perhaps the copy before passing to openssl could be prevented?
2018-06-01T19:19:00 #rust-webdev <seanmonstar> if AsyncWrite::write_buf for SslStream is implemented to do that, should save a copy automatically
2018-06-01T19:25:49 #rust-webdev <sfackler> openssl doesn't buffer - each SSL_write call produces a separate TLS frame that's immediately written out
2018-06-01T22:49:28 #rust-webdev <sfackler> seanmonstar: :confetti_ball:
2018-06-01T22:49:52 #rust-webdev <seanmonstar> im still coordinating all the things that need to updated XD
2018-06-01T22:52:08 #rust-webdev <sfackler> is there a new "standard" typed header crate for http? i was working on something a while ago but kind of fell off on it...
2018-06-01T22:56:41 #rust-webdev <seanmonstar> sfackler: that's as far as i got too :P
2018-06-01T22:56:45 #rust-webdev <sfackler> haha
2018-06-01T22:57:17 #rust-webdev <seanmonstar> "oh hey, this way is even faster, and .... hey, lets get h2 into hyper!"
2018-06-01T22:57:17 #rust-webdev <sfackler> someone copied Headers/Header/etc out to a separate crate which i'll probably use in the short term
2018-06-01T23:08:05 #rust-webdev <seanmonstar> ok, i think all the things are published now
2018-06-02T00:04:35 #rust-webdev <sfackler> seanmonstar: the server logic automatically infers http1 or h2 for each connection based off the header?
2018-06-02T00:05:56 #rust-webdev <seanmonstar> sfackler: by default, it assumes http1, and if theres a version parse error, it checks to see if it was the h2 magic prefix
2018-06-02T00:06:29 #rust-webdev <seanmonstar> it doesnt' do anything with ALPN yet
2018-06-02T00:07:48 #rust-webdev <sfackler> the current fallback thing should be reliable right? no need to explicitly tell it except for maybe a very tiny perf difference?
2018-06-02T00:08:21 #rust-webdev <sfackler> asdfasdfadsf when is docs.rs going to get off that version of rustdoc that hides all information
2018-06-02T00:08:49 #rust-webdev <seanmonstar> yea, or if you explicitly want to forbid http1
2018-06-02T00:09:45 #rust-webdev <seanmonstar> h2 MUST always start a connection with "PRI * HTTP/2.0", which httparse will be upset about the 2.0
2018-06-03T18:45:15 #rust-webdev <Erk> Hallo anyone around, I have some questions about hyper 0.12 if anyone knows something about it.
2018-06-03T18:46:17 #rust-webdev <seanmonstar> Erk: ask away :D
2018-06-03T18:48:00 #rust-webdev <Erk> So in hyper 11 it was possible to write the body of a response to disk pretty easy, but when I try it with hyper 12 I get errors or empty files
2018-06-03T18:48:32 #rust-webdev <Erk> And I do not want to concat the whole file together in memory qbecause they can get quite big.
2018-06-03T18:49:30 #rust-webdev <seanmonstar> Erk: streaming bodies is definitely the preferred way. whats the exact issue you're seeing?
2018-06-03T18:51:49 #rust-webdev <Erk> This is the function I am trying at the moment https://github.com/Erk-/rsget/blob/hls_support/rsget_lib/src/utils/downloaders.rs#L143
2018-06-03T18:52:00 #rust-webdev <Erk> This terminate without writing anything
2018-06-03T18:53:09 #rust-webdev <seanmonstar> Erk: there is no error? and there is definitely a body?
2018-06-03T18:54:18 #rust-webdev <Erk> I am trying to use it to download mediafiles, which it does not work for, I could get it to work for downloading the html of a page
2018-06-03T18:57:05 #rust-webdev <seanmonstar> Erk: what is the status/headers of the response?
2018-06-03T19:01:32 #rust-webdev <Erk> Oh
2018-06-03T19:01:57 #rust-webdev <Erk> just looked at them and can now see I have done an error it is a 302 redirect
2018-06-03T19:02:17 #rust-webdev <Erk> I'll try and make a rediretor and then see if I still have problems
2018-06-03T20:02:36 #rust-webdev <Erk> seanmonstar I fixed my error but it still does not work, this is the status and header I get https://gist.github.com/Erk-/47f5dcd1d278533e899d2f535ed77f7f
2018-06-03T20:04:12 #rust-webdev <seanmonstar> Erk: and something like curl does see a body?
2018-06-03T20:08:30 #rust-webdev <Erk> as far as I can tell it does
2018-06-03T20:10:43 #rust-webdev <Erk> I have added the curl log to the gist I posted
2018-06-03T20:27:34 #rust-webdev <Erk> seanmonstar did `.body()` use to consume the body?
2018-06-03T20:28:21 #rust-webdev <seanmonstar> Erk: oh! i see the issue
2018-06-03T20:28:39 #rust-webdev <seanmonstar> no, body() wouldn't poll the body till the end before
2018-06-03T20:29:16 #rust-webdev <seanmonstar> but, in the code above, you take the body and add a `map` combinator, but then just drop it afterwards
2018-06-03T20:29:45 #rust-webdev <seanmonstar> Erk: change the into_body().map() into a into_body().for_each
2018-06-03T20:32:07 #rust-webdev <Erk> seanmonstar still stops without writing anything, but the log seems a bit interesting let me post it
2018-06-03T20:33:01 #rust-webdev <Erk> I have added the full log to the gist
2018-06-03T20:35:57 #rust-webdev <seanmonstar> Erk: log looks like it does read some body
2018-06-03T20:41:47 #rust-webdev <Erk> seanmonstar in that case it is strange because it does not write anything to the file
2018-06-03T20:43:07 #rust-webdev <seanmonstar> Erk: it does seem like a second request doesnt read its body
2018-06-03T20:44:21 #rust-webdev <Erk> Yeah the first request is made with another function that deserialises the body, but the seems just to fail silently
2018-06-03T20:47:41 #rust-webdev <seanmonstar> Erk: try changing from request.map() to request.and_then()
2018-06-03T20:48:06 #rust-webdev <seanmonstar> you're returning the ForEach future in the first `map`, and then dropping it with the second `map(|_| ())`
2018-06-03T20:48:49 #rust-webdev <Erk> oh
2018-06-03T20:48:56 #rust-webdev <Erk> That works :)
2018-06-03T20:49:02 #rust-webdev <Erk> Many thnaks for your time
2018-06-04T16:36:14 #rust-webdev <sfackler> seanmonstar: is Destination intentionally not Clone?
2018-06-04T16:37:10 #rust-webdev <seanmonstar> sfackler: it was intentionally conservative to not need breaking changes
2018-06-04T16:37:35 #rust-webdev <seanmonstar> maybe it should be clone, or something else, but i stuck with minimum neccesary to start :)
2018-06-04T16:39:21 #rust-webdev <sfackler> it's a bit awkward to work with when making wrapper connectors for stuff like tls. i'll get a PR up on hyper-openssl and we can see how things look
2018-06-04T16:41:20 #rust-webdev <seanmonstar> sfackler: would it need to be clone, or is the issue that its not static?
2018-06-04T16:42:35 #rust-webdev <sfackler> it is currently static I think - the current design of hyper-openssl is that we connect via the inner HttpConnector and then do the ssl stuff
2018-06-04T16:42:39 #rust-webdev <sfackler> but that depends on the host/port
2018-06-04T16:43:03 #rust-webdev <sfackler> I think I can restructure it to do the SSL setup before the HTTP connection and not have to clone at all
2018-06-04T16:43:25 #rust-webdev <seanmonstar> ah gotcha
2018-06-04T16:44:16 #rust-webdev <seanmonstar> sfackler: i've been wanting to add an alpn piece to Destination as well, to allow signaling if and which alpn to use
2018-06-04T16:45:03 #rust-webdev <sfackler> hmm, seems like ideally you'd ask the transport but the bounds on that are just asyncread + asyncwrite
2018-06-04T16:46:16 #rust-webdev <seanmonstar> right
2018-06-04T16:46:49 #rust-webdev <sfackler> if that would be indicated through desination, I think we'd either need to be able to clone destination or the ALPN bit if we want to continue to be able to rely on a separate connector to do the low level socket connection
2018-06-04T16:47:17 #rust-webdev * seanmonstar nods
2018-06-04T16:47:37 #rust-webdev <seanmonstar> it does seem unfortunate to need to configure alpn both in the connector and at the top level client...
2018-06-04T16:48:08 #rust-webdev <sfackler> the top level client hopefully wouldn't care about it right?
2018-06-04T16:48:12 #rust-webdev <seanmonstar> well, maybe you wouldn't need to configure the connector much
2018-06-04T16:48:21 #rust-webdev <sfackler> yeah
2018-06-04T16:48:38 #rust-webdev <sfackler> connector configuration is mostly around stuff like trusted root CAs
2018-06-04T16:48:42 #rust-webdev <seanmonstar> i can imagine you could want to configure that a client is http1 only, or h2, or both
2018-06-04T16:48:59 #rust-webdev <sfackler> it seems reasonable for the Destination to include that info
2018-06-04T16:49:12 #rust-webdev <sfackler> the less clear part is how you get the negotiated proto back out
2018-06-04T16:49:48 #rust-webdev <seanmonstar> oh yea, for that, i'd expect Connect to annotate the Connected value
2018-06-04T16:50:05 #rust-webdev <seanmonstar> "we connected, and pre-negotiated h2"
2018-06-04T16:50:40 #rust-webdev <seanmonstar> that'd be important since if alpn negotiated h2, its 'illegal' to try to use h1 on the connection, so hyper would need to know somehow
2018-06-04T16:51:01 #rust-webdev <sfackler> ah! I missed that the future returns the transport and extra info
2018-06-04T16:51:03 #rust-webdev <sfackler> that all seems fine then
2018-06-04T16:51:42 #rust-webdev <seanmonstar> yea, i added that specifically for alpn, but didn't have enough experience with it to build in the alpn methods
2018-06-04T16:51:57 #rust-webdev <seanmonstar> so it was mostly reserving api space
2018-06-04T16:52:05 #rust-webdev <sfackler> yep that whole bit seems reasonable
2018-06-04T16:52:23 #rust-webdev <sfackler> so I think ideally Destination would be Clone but I can work with it not being
2018-06-04T16:56:01 #rust-webdev <seanmonstar> yea that may be best
2018-06-04T16:58:41 #rust-webdev <sfackler> Connected::proxy is only relevant for HTTP and not HTTPS proxies, right?
2018-06-04T17:00:35 #rust-webdev <seanmonstar> correct
2018-06-04T17:01:10 #rust-webdev <seanmonstar> tunneled proxies are essentially invisible to the rest of it
2018-06-04T18:43:22 #rust-webdev <sfackler> seanmonstar: this may or may not be a bug, but this kind of test no longer passes in 0.12: https://github.com/sfackler/hyper-openssl/blob/master/src/lib.rs#L353
2018-06-04T18:43:38 #rust-webdev <sfackler> it complains that the server closed the connection before it could write its response
2018-06-04T18:43:43 #rust-webdev <sfackler> i'm assuming that's intended?
2018-06-04T18:44:06 #rust-webdev <sfackler> the error is either Error { kind: Closed, cause: None } or Error { kind: Canceled, cause: Some(Error { kind: Io, cause: Some(Custom { kind: InvalidData, error: StringError("unexpected bytes before writing message") }) }) } depending on the timing
2018-06-04T18:46:49 #rust-webdev <seanmonstar> sfackler: with keep alive or not?
2018-06-04T18:46:58 #rust-webdev <sfackler> with and without I think
2018-06-04T18:48:30 #rust-webdev <sfackler> yeah doesn't seem to matter
2018-06-04T18:49:14 #rust-webdev <sfackler> i could see there being potentially situations where a server replies before the client request if e.g. it's not yet fully online or something
2018-06-04T18:49:35 #rust-webdev <sfackler> here's a little example: https://gist.github.com/sfackler/2f381eeef05d08034c0a0ce9ebdaa141
2018-06-04T18:49:54 #rust-webdev <seanmonstar> yea, there's actually a test inside hyper for this case, and it expects to fail
2018-06-04T18:50:00 #rust-webdev <sfackler> ah cool
2018-06-04T18:50:01 #rust-webdev <seanmonstar> though it was also there in the 0.11.x branch
2018-06-04T18:50:09 #rust-webdev <sfackler> i'll be less lazy with my tests then :P
2018-06-04T18:50:53 #rust-webdev <seanmonstar> the test could be wrong, if that seems like a common thing to do...
2018-06-04T18:51:18 #rust-webdev <sfackler> i haven't personally seen it before
2018-06-04T18:51:20 #rust-webdev <seanmonstar> but it doesnt sound too common to reply in http1 before knowing anything about the connection
2018-06-04T18:51:23 #rust-webdev <sfackler> yeah
2018-06-04T18:51:36 #rust-webdev <sfackler> I just stuck a 1 byte read in before replying and it seems to sync things up properly
2018-06-04T21:15:02 #rust-webdev <sfackler> seanmonstar: what are the implications of disabling the runtime feature? It looks like the connection pool does something special if it's enabled?
2018-06-04T21:16:09 #rust-webdev <seanmonstar> special?
2018-06-04T21:17:15 #rust-webdev <sfackler> spawn_idle_interval: https://github.com/hyperium/hyper/blob/master/src/client/pool.rs#L390
2018-06-04T21:18:42 #rust-webdev <seanmonstar> sfackler: ah, that will try to reap idle connections that have been idle lnger than the configured timeout
2018-06-04T21:19:04 #rust-webdev <seanmonstar> so far, needed runtime in order to use the timer
2018-06-04T21:19:11 #rust-webdev <sfackler> ah gotcha
2018-06-05T00:30:05 #rust-webdev <seanmonstar> sfackler: 0.12.1 with Clone for Destination
2018-06-05T00:35:32 #rust-webdev <sfackler> thanks!
2018-06-05T14:37:09 #rust-webdev <mib_tyr0sx> Hi
2018-06-05T21:14:20 #rust-webdev <sfackler> seanmonstar: would it be possible to add a method to body::Sender to indicate that the request should be aborted? send_error exists and does basically this but it's private
2018-06-05T21:15:33 #rust-webdev <seanmonstar> sfackler: yea, i think something like that makes sense
2018-06-05T21:16:12 #rust-webdev <sfackler> something like `fn abort(&mut self) -> Result<(), Chunk>`?
2018-06-05T21:16:51 #rust-webdev <seanmonstar> i wondered about these things around it: a) should you be able to somehow specify an h2 error code to reset the stream? b) should send some other error type?
2018-06-05T21:17:12 #rust-webdev <sfackler> ah sure
2018-06-05T21:17:41 #rust-webdev <seanmonstar> could start conservatively and add more functionality later
2018-06-05T21:17:43 #rust-webdev <sfackler> yeah
2018-06-05T21:18:13 #rust-webdev <sfackler> `fn abort(&mut self, abort: Abort) -> Result<(), Chunk>` `struct Abort(()); impl Default for Abort {}`?
2018-06-05T21:18:36 #rust-webdev <seanmonstar> why does it return a Result? and why a Chunk in error case?
2018-06-05T21:18:47 #rust-webdev <sfackler> oh right chunk seems wrong
2018-06-05T21:18:55 #rust-webdev <seanmonstar> should it consume the sender?
2018-06-05T21:19:49 #rust-webdev <sfackler> seems like it needs to return some kind of result since you want to make sure the error makes it into the channel
2018-06-05T21:19:52 #rust-webdev <sfackler> if the buffer's full
2018-06-05T21:20:19 #rust-webdev <sfackler> there could be a separate oneshot just for an error though to avoid that case
2018-06-05T21:21:35 #rust-webdev <seanmonstar> oh i see
2018-06-05T21:21:47 #rust-webdev <seanmonstar> it seems annoying to have to retry an abort
2018-06-05T21:21:59 #rust-webdev <sfackler> yeah the oneshot approach seems pretty plausible
2018-06-05T21:22:08 #rust-webdev <seanmonstar> i'd probably lean towards it should always succeed
2018-06-05T21:22:15 #rust-webdev <sfackler> it's definitely cleaner that way
2018-06-05T21:22:47 #rust-webdev <sfackler> ooh, how about this
2018-06-05T21:22:56 #rust-webdev <sfackler> we replace the close_rx with an error_tx
2018-06-05T21:23:03 #rust-webdev <sfackler> so it does double-duty
2018-06-05T21:23:56 #rust-webdev <sfackler> and poll_ready calls self.error_tx.poll_cancel() rather than self.close_rx.poll()
2018-06-05T21:26:33 #rust-webdev <seanmonstar> yea :+1:
2018-06-05T21:26:44 #rust-webdev <sfackler> cool i'll make a pr
2018-06-05T21:37:52 #rust-webdev <sfackler> seanmonstar: hmm, so presumably we'd want to stick a poll_abort on Payload as well, but then there's some overlap between poll_data returning an error and poll_abort
2018-06-05T21:38:04 #rust-webdev <sfackler> I guess poll_abort would let you have more control over h2 errors though
2018-06-05T21:39:40 #rust-webdev <seanmonstar> could probably hold off on adding something to Payload
2018-06-05T21:39:50 #rust-webdev <sfackler> ok
2018-06-05T21:40:13 #rust-webdev <sfackler> so just have Sender::abort which takes an opaque Abort type and just turns into some generic hyper::Error?
2018-06-05T21:41:55 #rust-webdev <seanmonstar> sfackler: we could probably start with `fn abort(self) {`, i think
2018-06-05T21:42:04 #rust-webdev <sfackler> ah sure even easier
2018-06-05T21:45:55 #rust-webdev <sfackler> do we care about telling the user if the other side of the request handling's already hung up?
2018-06-05T21:47:38 #rust-webdev <seanmonstar> likely eventually. there is both poll_ready that will tell you if the channel is closed
2018-06-05T21:48:12 #rust-webdev <seanmonstar> but you can't use it to be notified of *when* the channel closes while you wait for something else to generate more chunks
2018-06-05T21:49:24 #rust-webdev <sfackler> i guess that failure mode doesn't really matter. the client isn't going to finish sending the request until the Sender drops or some other error has already occurred, so the request isn't going to be completed either way
2018-06-05T21:51:57 #rust-webdev <seanmonstar> we recently did have to figure something out for it in conduit, since we'd like to cancel pending resources if the client gave up on a request
2018-06-05T21:52:20 #rust-webdev <seanmonstar> as we find it works, i expect it to end up in hyper
2018-06-05T21:52:41 #rust-webdev <sfackler> oh yeah that's a thing I'd love to have as well
2018-06-05T21:53:06 #rust-webdev <seanmonstar> works well for h2, since the client can send an explicit RST_STREAM. hard to tell in h1
2018-06-05T21:53:32 #rust-webdev <sfackler> yeah I filed an issue a long time ago on tokio/mio about being able to poll for socket disconnects
2018-06-05T21:53:41 #rust-webdev <sfackler> it seems like it might be a thing on linux?
2018-06-05T21:53:45 #rust-webdev <sfackler> can't really remember
2018-06-05T21:53:53 #rust-webdev <seanmonstar> i believe you can now
2018-06-05T21:54:08 #rust-webdev <seanmonstar> something like `poll_read_ready(Ready::hup()`
2018-06-05T21:54:31 #rust-webdev <sfackler> the server i'm working on processes a lot of expensive/long running requests, and it'd be great if we could cancel those if the client gives up rather than spinning for a while
2018-06-05T21:58:43 #rust-webdev <seanmonstar> however, detecting socket hang up only works if hung up cleanly
2018-06-05T21:59:06 #rust-webdev <seanmonstar> if client trips on their power cord, a FIN is probably never sent
2018-06-05T21:59:44 #rust-webdev <sfackler> if you had tcp keepalive turned on I think you'd still realize
2018-06-05T22:00:01 #rust-webdev <seanmonstar> yea eventually
2018-06-05T22:00:13 #rust-webdev <seanmonstar> fastest way to detect a broken connection is to try to write
2018-06-05T22:00:22 #rust-webdev <sfackler> i still need to write a test, but does this look reasonable? https://github.com/hyperium/hyper/pull/1543
2018-06-05T22:00:26 #rust-webdev <sfackler> ugh gitcop
2018-06-05T22:00:42 #rust-webdev <seanmonstar> don't worry about gitcop, i dialed down its complaints, i fix up commit message when merging
2018-06-05T22:00:54 #rust-webdev <sfackler> haha ok
2018-06-05T22:00:55 #rust-webdev <seanmonstar> its just a red x to remind me to fix the message
2018-06-05T22:04:56 #rust-webdev <seanmonstar> sfackler: yep, i think that works perfectly
2018-06-05T22:07:12 #rust-webdev <seanmonstar> i've also thought sometimes that it might be nice to have some sort of guard version, where if it isn't explicitly closed, itd signal an error
2018-06-05T22:07:56 #rust-webdev <seanmonstar> since otherwise, a panic while holding a Sender would just mean the body ended, and if you were using chunked encoding, the remote could assume it'd gotten the full body
2018-06-05T22:12:35 #rust-webdev <sfackler> yeah
2018-06-05T22:12:58 #rust-webdev <sfackler> i think that'd be the more defensive approach but it is a breaking change
2018-06-05T22:13:14 #rust-webdev <sfackler> there instead of `fn abort(self)` you have `fn commit(self)`
2018-06-05T22:14:30 #rust-webdev <sfackler> hmm, I'm not sure how to make a reliable test for this
2018-06-05T22:15:20 #rust-webdev <sfackler> oh nevermind
2018-06-05T22:15:29 #rust-webdev <sfackler> just need to synchronize the read
2018-06-05T22:25:27 #rust-webdev <sfackler> hmm, it looks like hyper isn't setting a chunked transfer encoding for my test
2018-06-05T22:26:12 #rust-webdev <sfackler> which seems weird
2018-06-06T00:42:32 #rust-webdev <sfackler> omg I got my hyper 0.12 upgrade compiling and all of the tests immediately passed
2018-06-06T00:42:49 #rust-webdev <seanmonstar> \o/
2018-06-06T00:44:50 #rust-webdev <sfackler> +679 −730
2018-06-08T15:53:42 #rust-webdev <silven> Hi, does anyone know if (and if yes, how) you can setup a cargo workspace with both frontend (wasm) and backend crates?
2018-06-09T15:44:53 #rust-webdev <chasote> so if one of my future programming/rust goals is to be able to create a SaaS web app, Rust would be perfectly capable of doing that right? I could use it as the backend (possibly using a framework like Actix or Rocket) and/or in the future I could also use it on the front end with wasm (and/or something like Yew)? 
2018-06-09T15:46:48 #rust-webdev <chasote> when using it on the "backend" I would then need to create my own html/css/js(w/ possibly vue if the front end is complicated?) or use a compile to js language like Elm. Would Elm work with Rust? And if I use Rust for the front end (wasm or Yew) do you also use something like Actix on the backend? 
2018-06-09T15:47:01 #rust-webdev <chasote> and is all of this possible with rust stable or only the back end stuff for now?
2018-06-09T15:48:10 #rust-webdev <freefall> chasote: yes, it's not only possible but a good choice to use rust for the backend today
2018-06-09T15:48:31 #rust-webdev <freefall> chasote: if your backend just exposes a json api, you can do whatever you want on the frontend independent of rust
2018-06-09T15:48:49 #rust-webdev <chasote> and what else would I need to learn. Database (postgresql? or something) and then deployment stuff to actually put it on a server? (is this what kubernetes or docker are used for?)
2018-06-09T15:49:37 #rust-webdev <chasote> what would be your advice if i wanted to use Rust for all of this as much as possible? I know basic html/css but would like to avoid js except when necessary. 
2018-06-09T15:49:43 #rust-webdev <freefall> if you need a db (as most apps do), then postgres is the best default choice, and the best rust interface to it is https://diesel.rs/
2018-06-09T15:49:59 #rust-webdev <chasote> this is perfect. thank you!
2018-06-09T15:50:11 #rust-webdev <freefall> you'll also need a good grasp of http
2018-06-09T15:50:28 #rust-webdev <freefall> that has nothing to do with programming language, you just need to understand the protocol
2018-06-09T15:50:58 #rust-webdev <chasote> so does wasm basically equate to rust on the frontend or am i thinking of that wrong? and is any wasm capability available on rust stable?
2018-06-09T15:51:22 #rust-webdev <chasote> not wasm in total but in terms of rust compiling to wasm. 
2018-06-09T15:51:30 #rust-webdev <freefall> just use something like actix-web + diesel + postgres for the backend, and probably start with TypeScript or Elm on the frontend for now
2018-06-09T15:52:34 #rust-webdev <freefall> wasm in principle allows you to build your front end in any language that compiles to wasm, including rust
2018-06-09T15:52:51 #rust-webdev <chasote> perfect! I love that stack. 
2018-06-09T15:53:00 #rust-webdev <freefall> but it's still very early days and wasm is far from mature
2018-06-09T15:53:30 #rust-webdev <freefall> so if you're learning all this stuff from scratch, you're better off waiting on wasm until you know the other stuff well
2018-06-09T15:54:20 #rust-webdev <chasote> i understand. i'm in it for the long haul and am just learning all this so i hope by the time i can actually understand how to use it it will be much more mature. and if i learn basic Elm right now (which i love, i think i'm addicted to super helpful compiler errors) than I can transition those skills to something like Yew if I wanted
2018-06-09T15:55:04 #rust-webdev <chasote> but to start what would you recommend for the most basic stable Rust backend practice with minimal html/css front end? 
2018-06-09T15:55:35 #rust-webdev <chasote> I'm working through the book now and I actually think it does a web server project at the end so maybe i should just be patient and get to that first.
2018-06-09T15:56:00 #rust-webdev <freefall> what i already said
2018-06-09T15:56:59 #rust-webdev <chasote> cool beans. thank you! I've added postgres, diesel, and http to my learning tasks
2018-06-09T15:58:01 #rust-webdev <chasote> what is your opinion on frameworks? is Actix too complex/overkill for beginners or does the batteries included approach actually help while learning?
2018-06-09T15:59:41 #rust-webdev <freefall> actix-web is actually pretty lightweight and extremely fast, and unlike rocket it runs on rust stable
2018-06-09T16:00:04 #rust-webdev <chasote> good stuff. i appreciate it. i'll let you be now. thank you!
2018-06-09T16:00:14 #rust-webdev <freefall> it's also evolving very rapidly and the owner is very responsive and active, so it's a good project to contribute to
2018-06-09T16:01:14 #rust-webdev <freefall> the docs at https://actix.rs/ are in fairly good shape now too
2018-06-09T16:04:56 #rust-webdev <chasote> i'm excited for it. i just want to focus on learning Rust but just am not sure how much front end i have to learn to start making something with Actix. i have seem to have a lot more motivation when playing with Rust than the hmtl/css/js stack but also want to create web apps so I'm probably being a little dumb about it.
2018-06-09T16:06:13 #rust-webdev <freefall> the frontend is kind of a mess, yes
2018-06-09T16:06:29 #rust-webdev <freefall> but both Elm and TypeScript make dealing with it considerably better
2018-06-09T16:06:54 #rust-webdev <freefall> React is also fine and has good docs
2018-06-09T16:08:21 #rust-webdev <freefall> from a learning perspective, if you want to focus on rust now you can just ignore the front end
2018-06-09T16:08:34 #rust-webdev <freefall> just write a generic back-end service with a json api
2018-06-09T16:09:30 #rust-webdev <chasote> sounds like a plan 
2018-06-09T16:10:56 #rust-webdev <chasote> when you say "a json api" does that mean the back end will produce json? which is sort of a data format right? and then if i wanted to get more involved in the front end I would be using that json to display the data to the user?
2018-06-09T16:11:41 #rust-webdev <chasote> so my Elm code would take the json provided by the rust backend computations and display it in a SPA?
2018-06-09T16:12:24 #rust-webdev <chasote> or if keeping it even more simple i would have that json data just populate a regular webpage through html/css/basic js?
2018-06-09T16:14:12 #rust-webdev <freefall> json is a generic text-based data representation format that's convenient to deal with in software these days. see https://tools.ietf.org/html/rfc8259
2018-06-09T16:15:13 #rust-webdev <chasote> great convo (for me! hahaha) i think I have a lot more clarity on my learning path now. 
2018-06-09T16:15:15 #rust-webdev <freefall> a typical web app backend will store its data in a db, and provide access to the data over http by serializing it to json
2018-06-09T16:15:27 #rust-webdev <chasote> ahh!
2018-06-09T16:15:54 #rust-webdev <freefall> that makes it fairly convenient for any software program to get data from the backend
2018-06-09T16:16:05 #rust-webdev <freefall> one such software program is a web browser
2018-06-09T16:16:35 #rust-webdev <chasote> so Actix puts the data in postgres and then postgres turns that data into json and provides it to the front end code (or is that what diesel does?) 
2018-06-09T16:18:05 #rust-webdev <freefall> you put the data in postgres, actix-web handles http requests, and as part of handling an http request for data, the handler you write will use diesel to get the data from postgres
2018-06-09T16:18:50 #rust-webdev <freefall> you can also write http handlers that allow clients to insert or update data, so in that case your handlers will use diesel to insert or update data in the db
2018-06-09T16:19:56 #rust-webdev <chasote> it sounds so simple when you explain it! now i just need to put in the years to learn how to properly execute it
2018-06-09T16:21:46 #rust-webdev <chasote> i might be going too off topic here but say i want to create a cli app instead of a web app. should i think of it in the same way? rust as a "back end" does it's thing with provided data and then sends it to the terminal ("front end") in some format (instead of json)
2018-06-09T16:21:57 #rust-webdev <freefall> a typical backend api supports some or all of the classic CRUD (create, read, update, delete) operations on data. so the R operation will be like: 1. client send HTTP GET request to http://server.com/api/data 2. server receives the request and gets data from its db 3. server serializes the data to json and sends it back to client as an http response 4. if client is a browser, it probably turns the 
2018-06-09T16:22:03 #rust-webdev <freefall> data into part of a UI for the user
2018-06-09T16:22:33 #rust-webdev <freefall> the other operations are similar, e.g. the C operation will be the client sending an HTTP POST request with some data to a URL and the server processing the data the client sent and storing it in the db
2018-06-09T16:23:29 #rust-webdev <chasote> i've seen CRUD mentioned a lot. Something like the TODO app I see everwhere would be a CRUD app?
2018-06-09T16:25:06 #rust-webdev <freefall> basically a web back-end is just a layer in between the client and a database that uses the HTTP protocol and the JSON data format as an intermediate language to express data operations
2018-06-09T16:25:45 #rust-webdev <freefall> (the data format exchanged between client and server doesn't have to be json, that's just the most common choice at the moment)
2018-06-09T16:26:22 #rust-webdev <chasote> got it. and then front end is putting that data into a UI for the user. 
2018-06-09T16:26:29 #rust-webdev <freefall> yes, the todo app idea appears a lot in web tutorials because it's very simple but involves all of the create/read/update/delete operations
2018-06-09T16:27:43 #rust-webdev <freefall> a CLI app is similar in the sense that it has a "front end" (text-based terminal), but most CLI apps aren't backed by databases
2018-06-09T16:28:04 #rust-webdev <chasote> makes sense
2018-06-09T16:28:26 #rust-webdev <freefall> well, most CLI tools. if it's more of an "app" than a "tool" it probably has some kind of db, though probably not a big one like postgres
2018-06-09T16:32:52 #rust-webdev <chasote> this has been so helpful. i feel like this could help a lot of beginners, its kind of sad that it will be lost in the irc void. when is your book/tutorial coming out? hahaah
2018-06-09T20:00:04 #rust-webdev <frogonia> hi there
2018-06-09T20:00:25 #rust-webdev <frogonia> i got a problems with diesel orm 
2018-06-09T20:18:19 #rust-webdev <migi> ok how do you actually convert a stdweb::Number to a f64?
2018-06-09T20:18:57 #rust-webdev <migi> it's a conversion that should always work so I don't like to use .try_into().unwrap() but it seems like it's the only way
2018-06-10T18:51:06 #rust-webdev <WindowsBunny> just to clarify if I use ClientBuilder::default_headers
2018-06-10T18:51:18 #rust-webdev <WindowsBunny> and then I later specify some custom headers for a given request
2018-06-10T18:51:24 #rust-webdev <WindowsBunny> it will only override headers with the same name?
2018-06-10T18:51:35 #rust-webdev <WindowsBunny> So if I didn't override a specific header, the default value will remain?
2018-06-11T09:50:36 #rust-webdev <andor> the API around actix's HttpResponseBuilder is so extremely awkward
2018-06-11T09:51:06 #rust-webdev <andor> it seems like they deliberately prevent you from changing _anything_ on the response once you set a body
2018-06-11T10:01:32 #rust-webdev <freefall> what do you want to do?
2018-06-11T10:03:09 #rust-webdev <Faux> That's pretty standard in HTTP stuff? It wants to send the headers just before it starts thinking about the body.
2018-06-11T10:03:21 #rust-webdev <Faux> No point supporting changing the headers after the headers are sent.
2018-06-11T10:04:36 #rust-webdev <freefall> the outcome of an HttpResponseBuilder is an HttpResponse, which is still mutable
2018-06-11T10:05:57 #rust-webdev <freefall> in particular it has headers_mut(), set_body(), and replace_body() methods
2018-06-11T10:10:30 #rust-webdev <andor> well, i wanted to unset some cookies
2018-06-11T10:11:13 #rust-webdev <andor> but it's not that i've already begun _sending_ the response, it's just that i have a helper function which does some templating and sets the body to the result of the templating
2018-06-11T10:11:25 #rust-webdev <andor> plus sets appropriate content-type header
2018-06-11T10:11:51 #rust-webdev <andor> but if i want to set the body that means i can no longer do anything to my builder
2018-06-11T10:12:30 #rust-webdev <andor> e.g. i can't make this helper function take a mutable HttpResponseBuilder, set the body and the header, and then go on with potentially modifying the response, this has to be the last step
2018-06-11T10:13:49 #rust-webdev <andor> i'd understand if HttpResponse could not be modified/was quasi immutable, but the fact that i can't set the body on a HttpResponseBuilder (emphasis builder) then make some other changes seems excessive
2018-06-11T10:19:28 #rust-webdev <freefall> you know you can convert an HttpResponse back into a builder with .into_builder(), right? :)
2018-06-11T10:20:57 #rust-webdev <andor> yes, but that does not help me in any way, if i do that i effectively "lose" the body, because as yet another completely incomperhensible thing to me, `finish` will set the body to empty
2018-06-11T10:21:42 #rust-webdev <andor> i.e. if i set the body in my helper function, then outside of my function i convert it back into a builder, i have effectively lost the body
2018-06-11T10:22:40 #rust-webdev <freefall> what's the problem with just constructing an HttpResponse directly?
2018-06-11T10:23:35 #rust-webdev <andor> i can't set cookies, for one (the whole reason this thing came up)
2018-06-11T10:24:16 #rust-webdev <andor> i mean i could obviously do so manually with `headers_mut` and doing it all by myself manually, but yeah
2018-06-11T10:25:06 #rust-webdev <andor> it just seems like a silly limitation on HttpResponseBuilder with no good reason to me
2018-06-11T10:27:21 #rust-webdev <freefall> i'm not sure why exactly it works that way, but two things should be done
2018-06-11T10:28:02 #rust-webdev <freefall> one, open an issue to clarify whether that restriction is important for some reason or can be relaxed. i'm sure it will get a response very quickly
2018-06-11T10:28:33 #rust-webdev <freefall> two, submit a PR to add the cookie methods to HttpResponse
2018-06-11T10:29:37 #rust-webdev <andor> while i haven't checked others, cookie was just an example that came up because that's what i was looking for, but probably there are other methods/things too, which makes sense IMO, some things are "computed" into the response
2018-06-11T10:32:24 #rust-webdev <freefall> there is this open issue: https://github.com/actix/actix-web/issues/246
2018-06-11T10:41:39 #rust-webdev <freefall> right now the "into HttpResponse" logic is done in the body() method and finish() just calls body(Body::Empty), which does seem a little weird
2018-06-11T10:42:28 #rust-webdev <freefall> also the only thing that logic really does is convert the builder cookie jar cookies into headers
2018-06-11T10:45:57 #rust-webdev <freefall> i suggest opening an issue to ask if there's any reason we can't change this so that body() just sets the body and finish() does the final conversion
2018-06-11T10:51:24 #rust-webdev <freefall> heh. into_builder() also just drops cookies right now with this line: cookies: None, // TODO: convert set-cookie headers
2018-06-11T14:27:25 #rust-webdev <andor> is there a way to dump the routes in actix? a route of mine is not getting matched and i'm having a hard time figuring out why not
2018-06-12T00:02:36 #rust-webdev <sfackler> seanmonstar: do you know if servers typically set longer read/write timeouts for h2 connections than http/1.1 connections?
2018-06-12T00:03:24 #rust-webdev <seanmonstar> that i dont know
2018-06-12T00:03:46 #rust-webdev <seanmonstar> perhaps yes if idle connections are triggering a timeout
2018-06-12T13:23:03 #rust-webdev <freefall> seanmonstar: are you aware of problems with the http::header::OccupiedEntry::remove_entry_mult() code?
2018-06-12T13:26:20 #rust-webdev <freefall> if i try to use it i get: assertion failed: self.entries.len() > prev  @ http-0.1.5/src/header/map.rs:1388:17
2018-06-12T13:29:28 #rust-webdev <freefall> backtrace shows 8: <http::header::map::ValueDrain<'a, T> as core::ops::drop::Drop>::drop at http-0.1.5/src/header/map.rs:2887; 7: <http::header::map::ValueDrain<'a, T> as core::iter::iterator::Iterator>::next at http-0.1.5/src/header/map.rs:2871
2018-06-12T17:13:16 #rust-webdev <seanmonstar> freefall: im not personally aware, but sounds like a bug!
2018-06-13T17:24:12 #rust-webdev <sfackler> seanmonstar: does h2 try to automatically detect that writev isn't supported like hyper's http1 support does? it looks like there are separate tcp packets for magic/settings/request
2018-06-13T17:24:54 #rust-webdev <sfackler> when using a thing that doesn't writev
2018-06-13T17:44:45 #rust-webdev <sfackler> oh looks like they're sent separately even with writev
2018-06-15T17:14:10 #rust-webdev <freefall> seanmonstar: you're doing god's work with the analysis of unsafe in actix-web. thanks
2018-06-17T05:00:43 #rust-webdev <sfackler> seanmonstar: how does client::dispatch::Sender differ from a normal bounded futures sender?
2018-06-17T19:03:58 #rust-webdev <xor> I reading up on the cookie crate and I was expecting a way to sign a cookie server-side before sending it to the client. There are cookie jars that can be signed, but the way I understand it those are supposed to be used client side. Are we expected to use another crate and just sign the cookie ourselves?
2018-06-17T21:44:43 #rust-webdev <xor> For the log, cookie jar works both client and server side, that's the answer to my question.
2018-06-18T16:39:41 #rust-webdev <seanmonstar> sfackler: besides being bounded, it also "isnt ready" until the receiver has polled for a new message
2018-06-18T16:40:31 #rust-webdev <seanmonstar> sfackler: this helps to keep a pending request in the buffer if the h1::Conn determines it can't keep-alive and thus never polls for a new request to send
2018-06-18T16:40:48 #rust-webdev <seanmonstar> er, it keeps the pending request out of the channel
2018-06-18T16:41:18 #rust-webdev <seanmonstar> so that if the connection has to shutdown, the pending request isn't just dropped, but instead can be sent on a different channel that *is* ready
2018-06-18T16:50:01 #rust-webdev <sfackler> ah ok
2018-06-18T17:09:47 #rust-webdev <seanmonstar> it *also* tries to help deal with the race condition in futures::sync::mpsc ;_;
2018-06-18T17:40:19 #rust-webdev <freefall> for some reason this doesn't fill me with confidence https://github.com/actix/actix-web/issues/289#issuecomment-397897695
2018-06-18T17:55:24 #rust-webdev <seanmonstar> freefall: i'm really not trying to be a jerk, but it.. shouldn't https://github.com/actix/actix-web/issues/289#issuecomment-398140594
2018-06-18T17:59:25 #rust-webdev <freefall> seanmonstar: sigh. thanks for your efforts. (might want to tag the owner in that comment)
2018-06-18T18:00:21 #rust-webdev <freefall> i don't really understand the thinking behind writing that kind of code in rust
2018-06-18T18:00:59 #rust-webdev <freefall> and a web server sounds like an especially bad place to have it in
2018-06-18T18:01:33 #rust-webdev <seanmonstar> yep ;_;
2018-06-18T18:02:39 #rust-webdev <freefall> are any of the problems you found the kind that can be exploited from outside?
2018-06-18T18:04:11 #rust-webdev <seanmonstar> freefall: what does that mean?
2018-06-18T18:04:47 #rust-webdev <seanmonstar> by a user? or by an attacker?
2018-06-18T18:05:08 #rust-webdev <freefall> by an attacker hitting the server over the network, for example
2018-06-18T18:05:44 #rust-webdev <seanmonstar> it'd depend on the exact code, i believe
2018-06-18T18:18:59 #rust-webdev <sfackler> seanmonstar: the client pool currently ensures that only a single http2 connection is being created at any time. with alpn support that'll get a bit weird since we don't know for part of the handshake if it will be http2 or not. It seems like there are 3 options: 1) get rid of the "single handshake logic" and throw away the second connection if one's already present while trying to insert into the pool, 2) throw away the existing
2018-06-18T18:19:29 #rust-webdev <sfackler> connection, or 3) keep the "single handshake logic" but only apply it after the connector finishes with the TLS/TCP side of things
2018-06-18T18:19:42 #rust-webdev <sfackler> do you have any preferences?
2018-06-18T18:20:46 #rust-webdev <seanmonstar> sfackler: yea... as an example, finagle and grpc (both using netty) put the single connection part in the Connector instead of the pool
2018-06-18T18:21:29 #rust-webdev <sfackler> how does that work?
2018-06-18T18:21:38 #rust-webdev <seanmonstar> that could help, but it also puts of the onus of reusing http2 connections onto every connector implementor
2018-06-18T18:22:20 #rust-webdev <seanmonstar> hm, it probably wouldn't work that well actually, since in hyper, a connector returns an IO, not an http2 service
2018-06-18T18:22:24 #rust-webdev <sfackler> oh, like, the connector is responsible for the connection and http2 handshake?
2018-06-18T18:22:24 #rust-webdev <sfackler> yeah
2018-06-18T18:22:35 #rust-webdev <sfackler> the reuse part is pretty straightforward with the current pool
2018-06-18T18:23:04 #rust-webdev <sfackler> it's just the "don't race making N http2 connections right at startup and then throwing away N-1 of them" bit that's a little less clear
2018-06-18T18:24:47 #rust-webdev <sfackler> freefall: in particular, a sufficiently patient/creative attacker can probably turn a use-after-free or out of bounds write into something bad
2018-06-18T18:25:52 #rust-webdev <seanmonstar> sfackler: right... may be worth writing in the issue. im sure oh_lawd wouldn't love for a rush of requests to open thousands of connections until the handshake said it was h2 :D
2018-06-18T18:26:03 #rust-webdev <sfackler> heh
2018-06-18T18:26:15 #rust-webdev <sfackler> I guess there is 4) sequentialize the first connection
2018-06-18T18:26:19 #rust-webdev <sfackler> but that's a bit of a bummer
2018-06-18T18:26:22 #rust-webdev <sfackler> er, serialize
2018-06-18T18:26:34 #rust-webdev <sfackler> I guess not too bad though
2018-06-18T18:26:56 #rust-webdev <sfackler> that might be the best option honestly
2018-06-18T18:27:48 #rust-webdev <sfackler> it does mean there's an interesting difference between an http1 host with all connections checked out an a host with no connections
2018-06-18T18:27:52 #rust-webdev <sfackler> *and
2018-06-18T18:30:51 #rust-webdev * seanmonstar nods
2018-06-18T21:04:37 #rust-webdev <seanmonstar> sfackler: you believe there's value in `dst.set_port(None)`?
2018-06-18T21:05:03 #rust-webdev <sfackler> sure - imagine you're redirecting to a proxy that's using the default port
2018-06-18T21:05:16 #rust-webdev <sfackler> you could stick in 80 or 443 but that's another place to remember the magic numbers
2018-06-18T21:08:01 #rust-webdev <seanmonstar> fair
2018-06-19T15:23:26 #rust-webdev <sfackler> seanmonstar: am I missing something or will the current client pool evict http2 connections every time the keepalive interval is hit? There's not special idle tracking for http2 as far as I can tell
2018-06-19T17:15:16 #rust-webdev <seanmonstar> sfackler: idle h2 connections will be evicted. however, when checking out, the idle_at timestamp will be updated
2018-06-19T17:15:41 #rust-webdev <sfackler> ah right
2018-06-21T10:08:58 #rust-webdev <dowwie> has anyone managed to get an enum field to work within a struct used by serde_urlencoded ?
2018-06-22T02:44:12 #rust-webdev <perryprog> quit
2018-06-22T20:06:56 #rust-webdev <sfackler> seanmonstar: seems like hyper/h2's type hierarchy is getting a bit deep :P https://gist.github.com/sfackler/e8c4ed2eb55182a4b3adfc1f8a07cd59
2018-06-22T20:08:43 #rust-webdev <seanmonstar> ;_;
2018-06-22T23:07:17 #rust-webdev <seanmonstar> you have a tunneling proxy connector, right?
2018-06-22T23:09:45 #rust-webdev <seanmonstar> sfackler: woops, meant to mention you ^
2018-06-22T23:09:53 #rust-webdev <sfackler> yeah
2018-06-22T23:11:00 #rust-webdev <seanmonstar> im trying to finish up CONNECT support through the Client, and im left with wondering what to do if the user wants to CONNECT, but the returned IO claims to a proxy already
2018-06-22T23:11:59 #rust-webdev <sfackler> I think that'd be fine right?
2018-06-22T23:12:06 #rust-webdev <sfackler> you'd double-tunnel for an https proxy
2018-06-22T23:12:15 #rust-webdev <sfackler> and just proxy a connect for an http proxy
2018-06-22T23:13:13 #rust-webdev <seanmonstar> hm yea
2018-06-25T02:38:30 #rust-webdev <sfackler> seanmonstar: i'm getting ready to pull the trigger on native-tls 0.2. anything in the changelog seem off to you? https://github.com/sfackler/rust-native-tls/blob/master/CHANGELOG.md
2018-06-25T16:53:54 #rust-webdev <halfbit> is there a future/tokio based cql client that anyone knows of?
2018-06-25T16:54:14 #rust-webdev <halfbit> been using the cdrs driver but timeouts can cause unwrap errors currently, which sucks :(
2018-06-25T17:05:59 #rust-webdev <seanmonstar> sfackler: looking now
2018-06-25T17:07:11 #rust-webdev <seanmonstar> sfackler: looks great to me!
2018-06-26T15:53:42 #rust-webdev <Sergio> Is there a concrete plan for Futures 0.3 and a Hyper/Tokio migration to it?
2018-06-26T15:54:06 #rust-webdev <Sergio> seanmonstar: Do you have an idea of how much Hyper's API would change as a result of such a migration?
2018-06-26T15:56:06 #rust-webdev <carllerche> Sergio: there currently is no plan to migrate to 0.3
2018-06-26T15:56:26 #rust-webdev <Sergio> What does that mean?
2018-06-26T15:56:33 #rust-webdev <carllerche> 0.3 is going to be nightly only for the immediate future, and on the Tokio side of things, I have no plan to rush to migrate
2018-06-26T15:57:07 #rust-webdev <carllerche> there will probably be a feature flag or something like that to add optional support for futures 0.3 at some point
2018-06-26T15:58:58 #rust-webdev <carllerche> It also would be possible to use a compat layer, similar to http://crates.io/crates/futures-compat
2018-06-26T16:04:39 #rust-webdev <Sergio> I see. Hmm. 
2018-06-26T16:05:02 #rust-webdev <Sergio> This is because of the nightly-ness?
2018-06-26T16:05:54 #rust-webdev <carllerche> yes
2018-06-26T16:06:15 #rust-webdev <carllerche> and, after 0.2, I want to make sure that 0.3 will have long term support before migrating to it
2018-06-26T16:21:36 #rust-webdev <seanmonstar> Sergio: i expect that the Futures and Executors pieces in hyper would need to change, but i dont think the rest of it would
2018-06-26T16:53:02 #rust-webdev <seanmonstar> sfackler: if im not exposing native-tls publicly, is upgrading to 0.2 smooth enough? or would it technically break people on old openssl?
2018-06-26T16:54:09 #rust-webdev <sfackler> It should not break anyone. openssl 0.10 still uses openssl-sys 0.9
2018-06-26T16:55:02 #rust-webdev <seanmonstar> so reqwest 0.8.7 can just upgrade transparently
2018-06-26T16:58:31 #rust-webdev <sfackler> Yeah
2018-06-26T18:17:31 #rust-webdev <seanmonstar> sfackler: shoot, will be a pain to backport hyper-tls and tokio-tls and stuff, is it mostly just new features?
2018-06-26T18:17:55 #rust-webdev <sfackler> hmm?
2018-06-26T18:18:21 #rust-webdev <seanmonstar> native-tls 0.2... is it just new features from 0.1, or fundamentally fixes something?
2018-06-26T18:18:52 #rust-webdev <sfackler> it upgrades openssl and security-framework and adds features
2018-06-26T18:18:59 #rust-webdev <sfackler> what are you trying to backport?
2018-06-26T18:20:43 #rust-webdev <seanmonstar> hyper-tls 0.1 exposes native-tls, so its a breaking change there, but 0.2 is already changed for hyper 0.12
2018-06-26T18:20:56 #rust-webdev <seanmonstar> so, i'd probably just need to inline that stuff directly into reqwest
2018-06-26T18:21:03 #rust-webdev <sfackler> sounds like time for 0.3 then?
2018-06-26T18:21:30 #rust-webdev <seanmonstar> yes, but 0.2 with hyper 0.12, 0.3 with 0.11?
2018-06-26T18:21:50 #rust-webdev <sfackler> oh
2018-06-26T18:22:06 #rust-webdev <sfackler> nah, hyper 0.11 will be fine with native-tls 0.1
2018-06-26T18:23:07 #rust-webdev <seanmonstar> ok, thats what i was wondering, if native-tls fixed something important that warrants backporting
2018-06-26T18:23:29 #rust-webdev <sfackler> gotcha - no there's nothing particularly broken about 0.1
2018-06-27T13:46:53 #rust-webdev <GrayShade> how can I create a non-'static cookie using the Cookie crate?
2018-06-27T13:46:56 #rust-webdev <GrayShade> cookie crate*
2018-06-27T13:47:04 #rust-webdev <GrayShade> https://docs.rs/cookie/0.10.1/cookie/
2018-06-27T13:49:47 #rust-webdev <GrayShade> actually, String should work for Cow<'static, str>
2018-06-30T06:52:11 #rust-webdev <WindowsBunny> seanmonstar: ahhhhhhhhhhhhhhhhhh, why is reqwest::multipart::Form not Clone and why does RequestBuilder::multipart require taking Form by value???
2018-06-30T06:52:59 #rust-webdev <WindowsBunny> How am I supposed to support automatic retry when I can't resend the same Form over and over?
2018-06-30T06:57:12 #rust-webdev * WindowsBunny also wonders why Form's methods take self by value while RequestBuilder takes &mut self
2018-06-30T20:42:16 #rust-webdev <seanmonstar> WindowsBunny: RequestBuilder using &mut self i feel was the wrong design, and should be changed to by-value again in 0.9
2018-06-30T20:42:56 #rust-webdev <seanmonstar> the Form bits... i don't remember the context like at all XD
2018-07-01T01:02:05 #rust-webdev <guacamole> which serverside web stack would you use if you wanted something solid? something like express/koa for node, but more minimal would be fine too if a high level solution isn't mature yet
2018-07-01T01:02:54 #rust-webdev <guacamole> i was thinking actix web but it doesn't feel mature yet so i'm looking at hyper now, going down in layers of abstraction till i find a solid/mature solution 
2018-07-01T01:28:39 #rust-webdev <seanmonstar> guacamole: we use a combination of hyper (for HTTP) and tower (for middleware stack) to build the conduit.io proxy
2018-07-01T01:31:29 #rust-webdev <WindowsBunny> seanmonstar: Is it possible to get multipart file data to use filename instead of filename* ?
2018-07-01T01:31:39 #rust-webdev <WindowsBunny> I'm trying to debug why mediawiki is refusing to accept my uploads
2018-07-01T01:34:40 #rust-webdev <seanmonstar> WindowsBunny: if the value required percent-encoding, it will be `parametername*`
2018-07-01T01:35:18 #rust-webdev <seanmonstar> i believe thats part of the multipart spec...
2018-07-01T01:35:43 #rust-webdev <seanmonstar> if you want without the *, the value must a valid path segment that didn't need encoding
2018-07-01T01:39:06 #rust-webdev <guacamole> seanmonstar: is tower a function signature or more?
2018-07-01T01:39:58 #rust-webdev <seanmonstar> guacamole: the base building block is a function signature, and the tower repo includes several "middlewares" that are generic over it
2018-07-01T01:48:53 #rust-webdev <guacamole> ah thats what confused me 
2018-07-01T15:53:10 #rust-webdev <alice_> Is tokio::run() supposed to block forever, even after all futures have completed?
2018-07-01T16:35:13 #rust-webdev <sfackler> it blocks until all futures have completed
2018-07-03T19:12:34 #rust-webdev <mr_wannabe> hello everyone! i'm pretty new to rust (following the book) but have a very specific goal: writing audionodes in rust (->wasm) and connect other nodes to it in the browser with the webaudio api. do anyone of you know a good starting point? every hint would be appreciated.
2018-07-05T11:43:07 #rust-webdev <SovietBear> how can i use geolocation in yew?
2018-07-07T16:04:50 #rust-webdev <sfackler> seanmonstar: have you ever run into a situation where you've wanted something like a weak mpsc::Sender?
2018-07-08T17:33:58 #rust-webdev <seanmonstar> sfackler: weak as in Arc::downgrade weak?
2018-07-08T17:34:21 #rust-webdev <sfackler> yeah
2018-07-08T17:34:46 #rust-webdev <seanmonstar> possibly, what did you have in mind?
2018-07-08T17:48:18 #rust-webdev <sfackler> the tokio-postgres rewrite has a similar connection + client setup to hyper/h2
2018-07-08T17:48:31 #rust-webdev <sfackler> requests are sent over a channel, and the connection shuts down when the channel closes
2018-07-08T17:49:06 #rust-webdev <seanmonstar> what does a weak channel give?
2018-07-08T17:49:16 #rust-webdev <sfackler> a prepared statement object needs to hold a reference to the channel so it can clean up its state when it drops, but we don't want to hold the connection open just because statements are lying around
2018-07-08T17:49:24 #rust-webdev <sfackler> since the state is cleaned up when the connection drops anyway
2018-07-08T18:11:23 #rust-webdev <seanmonstar> yea ive wanted that before too, i dont remember what i did to get around it...
2018-07-08T20:10:56 #rust-webdev <sfackler> I ended up having an extra arc anyway to store some other stuff so I stuck the sender in that
2018-07-09T19:51:40 #rust-webdev <abcrawf> Is there a recommended framework for an extremely simple web app (two or three routes, read-only cache state read from the routes)?
2018-07-09T19:52:25 #rust-webdev <abcrawf> I'm using Gotham, but it looks like the project is being abandonded (it looks like it hasn't been updated for the latest release of hyper).
2018-07-09T19:54:02 #rust-webdev <seanmonstar> abcrawf: if only 3ish simple routes, might be simple enough to just use hyper directly
2018-07-09T19:54:35 #rust-webdev <seanmonstar> a new framework using hyper 0.12 may be announced soon ;)
2018-07-09T19:54:46 #rust-webdev <abcrawf> Heh, awesome!
2018-07-11T19:03:02 #rust-webdev <GrayShade> abcrawf: gotham isn't abandoned yet
2018-07-11T19:04:16 #rust-webdev <GrayShade> https://github.com/gotham-rs/gotham/pull/231
2018-07-11T19:04:59 #rust-webdev <abcrawf> GrayShade: Ah, cool.
2018-07-11T19:05:12 #rust-webdev <GrayShade> slowly getting there
2018-07-11T19:05:14 #rust-webdev <GrayShade> :-)
2018-07-18T02:56:09 #rust-webdev <lilis> Hi guys, I'm having trouble communicating with Bing Custom Speech API via HTTP. I can communicate with Speech API just fine though. I don't know what caused this error:
2018-07-18T02:56:12 #rust-webdev <lilis> `thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Io(Custom { kind: Other, error: Custom { kind: Other, error: Kind(UnexpectedEof) } })', libcore/result.rs:945:5`
2018-07-18T02:56:34 #rust-webdev <lilis> Here's the Gist if anybody is interested: https://gist.github.com/rust-play/f04550d6995230065d87c9efacc42607
2018-07-18T02:57:12 #rust-webdev <lilis> It's a minimal example that can reproduce the error I got.
2018-07-18T02:57:49 #rust-webdev <lilis> The error happens at line 122
2018-07-18T08:46:42 #rust-webdev <vegai> "work" is a bit complicated there
2018-07-18T08:46:58 #rust-webdev <vegai> perhaps break up the unwraps on line 122 at least to find out which of them causes the error?
2018-07-19T20:13:50 #rust-webdev <SovietBear> anyone using yew 0.5 here?
2018-07-20T10:04:23 #rust-webdev <mib_8qyumg> hello
2018-07-21T09:12:06 #rust-webdev * Jacob-M uploaded an image: rif-1532164318529.jpg (53KB) < https://matrix.org/_matrix/media/v1/download/matrix.org/PsLhefpoGSYXdvHtXFOfyxtC >
2018-07-26T22:26:00 #rust-webdev <SovietBear> can you script google sheets with wasm?
2018-07-27T04:01:11 #rust-webdev <tac-tics> actix-web vs rocket, what kind of tradeoffs are there between the packages?
2018-07-27T04:01:36 #rust-webdev <Sergio> Main one is whether you're okay with using nightly or not.
2018-07-27T04:04:07 #rust-webdev <tac-tics> Oh hi. I loved your talks, btw.
2018-07-27T04:04:57 #rust-webdev <Sergio> Thanks! :)
2018-07-27T04:05:03 #rust-webdev <tac-tics> I actually have already worked through the Rocket tutorial. I am curious about the overall landscape of Rust's web packages.
2018-07-27T04:05:40 #rust-webdev <tac-tics> And it seems actix is the other big project
2018-07-27T04:05:52 #rust-webdev <Sergio> The two objective differences between Rocket and active-web are that 1) Rocket requires nightly while actix-web works on stable, and 2) actix-web is asynchronous while Rocket is synchronous.
2018-07-27T04:06:22 #rust-webdev <Sergio> Rocket will eventually (ideally soon) work on stable and will be fully async rather soon as well.
2018-07-27T04:07:12 #rust-webdev <tac-tics> So what you're saying is, it's all about whether or not I like the Rocket emojis? :P
2018-07-27T04:07:18 #rust-webdev <Sergio> Haha.
2018-07-27T04:07:33 #rust-webdev <Sergio> In general, Rocket pushes as much validation as possible to compile-time. Things like validating routes, ensuring that you validate all incoming request data, etc.
2018-07-27T04:07:47 #rust-webdev <Sergio> While actix-web is rather traditional in this sense: error will occur at runtime.
2018-07-27T04:07:48 #rust-webdev <Sergio> errors*
2018-07-27T04:08:45 #rust-webdev <Sergio> For instance, something like https://github.com/actix/actix-web/issues/318 would never happen with Rocket.
2018-07-27T04:10:12 #rust-webdev <tac-tics> Right. You pay a little up front with macros and typing, and you have more static gaurantees.
2018-07-27T04:10:24 #rust-webdev <Sergio> I don't think there's any cost to it.
2018-07-27T04:10:37 #rust-webdev <Sergio> You typically type quite a bit less with Rocket.
2018-07-27T04:10:44 #rust-webdev <Sergio> (Because Rocket generates the code for you.)
2018-07-27T04:11:12 #rust-webdev <Sergio> And because Rocket generates code for you, you can't possibly get it wrong.
2018-07-27T04:11:14 #rust-webdev <tac-tics> Of course. I mean cost in a general sense, meaning you give up a bit of control to the macro gods.
2018-07-27T04:11:41 #rust-webdev <Sergio> Ah, I see.
2018-07-27T04:12:13 #rust-webdev <tac-tics> Is the Rocket.toml file used at runtime or compile time, btw?
2018-07-27T04:12:40 #rust-webdev <Sergio> It's used at launch time
2018-07-27T04:13:02 #rust-webdev <Sergio> Configuration is dynamic: you can set it just before the server starts. So there's no way to check it at compile-time.
2018-07-27T04:13:17 #rust-webdev <Sergio> But we do all kinds of checks before the application is allowed to start and prevent it from doing so if anything looks off.
2018-07-27T04:13:26 #rust-webdev <tac-tics> Excellent.
2018-07-27T04:14:10 #rust-webdev <tac-tics> On a more general note, what do people typically use for templating? I have a few jinja2 templates that I'd ideally like to reuse.
2018-07-27T04:14:40 #rust-webdev <Sergio> https://api.rocket.rs/rocket_contrib/struct.Template.html
2018-07-27T04:14:45 #rust-webdev <tac-tics> (I find it kind of silly that so many templating languages are tied to a particular language)
2018-07-27T04:15:06 #rust-webdev <Sergio> Rocket has built in support for two separate engines, one of which is "tera" that borrows from Jinja
2018-07-27T04:15:20 #rust-webdev <tac-tics> thanks
2018-07-27T04:15:23 #rust-webdev <Sergio> They look like this: https://github.com/SergioBenitez/Rocket/blob/master/examples/tera_templates/templates/index.html.tera
2018-07-27T04:15:43 #rust-webdev <tac-tics> Neat. I could probably port that without any trouble.
2018-07-27T04:16:40 #rust-webdev <tac-tics> This is for my personal website, so it's fairly tiny.
2018-07-27T04:16:55 #rust-webdev <Sergio> Got it.
2018-07-27T04:16:58 #rust-webdev <Sergio> There's also handlebars
2018-07-27T04:17:31 #rust-webdev <Sergio> There's also https://github.com/djc/askama/, which is a compile-time engine that also looks like Jinja
2018-07-27T04:17:34 #rust-webdev <Sergio> Which supports Rocket as well
2018-07-27T04:22:35 #rust-webdev <tac-tics> Thanks for all the help, Sergio. I'll look over all this and give it a go this weekend :)
2018-07-27T05:34:23 #rust-webdev <tac-tics> Cool. I got the static pages working. However, it looks like I'm going to have to learn Serde before I can get the dynamic aspects working.
2018-07-27T05:42:21 #rust-webdev <vegai> how's Rocket+stable rust looking these days?
2018-07-27T05:42:28 #rust-webdev <vegai> any guesses? :)
2018-07-27T05:43:11 #rust-webdev <vegai> ah, I see https://github.com/SergioBenitez/Rocket/issues/19 is still there
2018-07-27T05:45:44 #rust-webdev * tac-tics sneakily doesn't learn serde and instead just copy-pastas the Rocket tera templates example code
2018-07-27T06:37:49 #rust-webdev <Sergio> vegai: Will know more in 1.5 months.
2018-07-27T06:38:03 #rust-webdev <Sergio> It's one of only three major pushes for the 0.5 release.
2018-07-27T06:50:09 #rust-webdev <vegai> okay
2018-07-27T09:52:05 #rust-webdev <KB5> Sergio: thanks for the comparison. I wasn't aware of these differences between actix-web and rocket.
2018-07-27T09:52:20 #rust-webdev <Sergio> KB5: Sure thing!
2018-07-27T09:52:52 #rust-webdev <KB5> It would seem rocket is more fool-proof "if it compiles, it works" kind of thing
2018-07-27T09:53:01 #rust-webdev <Sergio> That's the intention.
2018-07-27T09:53:36 #rust-webdev <KB5> Oh wait, you're the main dev of rocket?
2018-07-27T09:54:05 #rust-webdev <Sergio> I am.
2018-07-27T09:54:20 #rust-webdev <KB5> Cool. Thanks for your hard work.
2018-07-27T09:54:57 #rust-webdev <Sergio> :)
2018-07-27T09:57:40 #rust-webdev <KB5> There is no open issue for async though?
2018-07-27T09:58:01 #rust-webdev <Sergio> #17 is the catch-all for changes to the underlying HTTP engine
2018-07-27T10:04:12 #rust-webdev <KB5> An interesting read. Taking it slow and steady is a good thing. Hopefully Rust 2018 Edition will have all the necessary features stable to allow Rocket to work with stable, with async.
2018-07-29T00:30:09 #rust-webdev <Sergio> Does that mean "interested in purchasing spam"?
2018-07-29T00:30:55 #rust-webdev <Sergio> Ah, it's a weird smear campaign.
2018-07-31T17:34:37 #rust-webdev <sfackler> seanmonstar: we seem to be running into situations where at some point no future requests made via a hyper client ever complete again. It doesn't look like they're sent to the other server. seems to have popped up after an upgrade from hyper 0.12.3 to 0.12.5
2018-07-31T17:34:52 #rust-webdev <sfackler> does that seem familiar to you/any tips on debugging what's going on
2018-07-31T17:35:31 #rust-webdev <sfackler> it seems to be pretty rare - only happened twice in the last 8 days on a bunch of pretty heavily used servers
2018-07-31T17:42:24 #rust-webdev <sfackler> this is the only thing that pops out as potentially interesting I think: https://github.com/hyperium/hyper/commit/f2d464ac79b47f988bffc826b80cf7d107f80694
2018-07-31T18:01:01 #rust-webdev <sfackler> we also bumped tokio-threadpool from 0.1.4 to 0.1.5
2018-07-31T18:01:10 #rust-webdev <sfackler> which could be it as well?
2018-08-01T18:35:51 #rust-webdev <seanmonstar> sfackler: logs dont say something horrible happened?
2018-08-01T18:53:34 #rust-webdev <sfackler> nah nothing at info or higher
2018-08-01T18:53:53 #rust-webdev <sfackler> I would turn on debug logging but I think we'd just end up crushed under the weight of it
2018-08-01T18:54:11 #rust-webdev <sfackler> i'm kind of suspicious this may be a host problem since it's happened twice on one box and never anywhere elase
2018-08-02T00:16:33 #rust-webdev <sfackler> seanmonstar: out of curiosity have you ever done any benchmarking comparing http/1.1 to http/2? I was talking to a coworker who said that they found that the Jetty implementation of http2 was ~15% slower due to presumably more contention or state machine processing in the implementation
2018-08-02T00:22:43 #rust-webdev <sfackler> but the Jetty implementation also fails like 30 of the http2 compliance test suite so it may just be bad :P
2018-08-02T00:23:18 #rust-webdev <seanmonstar> sfackler: yea, we're currently looking to automatically upgrade/translate all http1 traffic in linkerd when we know the other side is another linkerd proxy, and benchmarks suggest 20% less cpu
2018-08-02T00:23:37 #rust-webdev <sfackler> 20% less when going from http1 to http2?
2018-08-02T00:24:15 #rust-webdev <seanmonstar> right, without the change, we just pass the http1 along as http1, with the change, we translate the request to http2, and send them all on the single h2 connection
2018-08-02T00:24:37 #rust-webdev <seanmonstar> and it seems to be a pretty nice win
2018-08-02T00:24:37 #rust-webdev <sfackler> nice!
2018-08-02T10:16:16 #rust-webdev <zer0> Hello
2018-08-02T10:16:31 #rust-webdev <zer0> Can we ask a question related to text encodings?
2018-08-02T11:05:55 #rust-webdev <freefall> seanmonstar: congrats on warp! looks promising. checking out the examples... how would one do cookie-based session handling? would the todos example work more or less as-is with diesel+r2d2, or would another approach be needed? any support for multipart handling (file uploads)?
2018-08-02T16:53:45 #rust-webdev <seanmonstar> freefall: i do hope to add better session support, but for now, the cookie filters let you grab any cookie, and then you can set a Set-Cookie header in your reply
2018-08-02T16:54:27 #rust-webdev <seanmonstar> yea, the todos would likely work fine with diesel instead of a memory db, you just might need to put any long blocking calls in a separate thread
2018-08-02T16:54:59 #rust-webdev <seanmonstar> multipart is a todo, need to figure out a pleasant api that feels like filters
2018-08-02T18:08:58 #rust-webdev <sfackler> seanmonstar: ok, so that weird issue reappeared, and it seems like it may be a tokio thing rather than a hyper thing
2018-08-02T18:09:07 #rust-webdev <sfackler> LSOF's reporting a bunch of unconnected TCP sockets
2018-08-02T18:09:20 #rust-webdev <sfackler> which makes me think that the connection just isn't progressing
2018-08-02T18:09:26 #rust-webdev <seanmonstar> which issue?
2018-08-02T18:09:44 #rust-webdev <sfackler> all client requests blocking forever
2018-08-02T18:10:20 #rust-webdev <seanmonstar> ahhh, you're using tls right?
2018-08-02T18:10:30 #rust-webdev <sfackler> yeah but this wouldn't even hit that stage
2018-08-02T18:11:12 #rust-webdev <sfackler> there are just a bunch of connections that look like `process 10607 user *231u     sock                0,7        0t0   70556778 protocol: TCP`
2018-08-02T18:11:17 #rust-webdev <seanmonstar> does it get to the dns resolve stage?
2018-08-02T18:11:39 #rust-webdev <sfackler> rather than `process 10607 user *268u     IPv4           70538128        0t0        TCP some_host.com:4242->some_other_host.com:44202 (ESTABLISHED`
2018-08-02T18:11:42 #rust-webdev <sfackler> unclear
2018-08-02T18:11:48 #rust-webdev <sfackler> I am using tokio-threadpool's blocking for DNS
2018-08-02T18:11:55 #rust-webdev <sfackler> (a custom connector
2018-08-02T18:12:06 #rust-webdev <sfackler> but there aren't any threads blocked on getaddrinfo
2018-08-02T18:12:11 #rust-webdev <sfackler> the whole worker pool is totally idle
2018-08-02T18:12:50 #rust-webdev <seanmonstar> it could be in tokio, but it certainly could be in hyper too
2018-08-02T18:13:42 #rust-webdev <seanmonstar> do you have logs that show the last thing the futures seem to do?
2018-08-02T18:14:20 #rust-webdev <sfackler> I don't unfortunately - I can't turn on trace logging when it's operating normally since I'll get crushed under the load, and by the time I notice the server's fully saturated and rejects new requests :(
2018-08-02T18:14:41 #rust-webdev <sfackler> I might need to add some special "no seriously, run this query" thing to force some requests through
2018-08-02T18:18:35 #rust-webdev <sfackler> the only other "interesting" version changes were mio 0.6.14 -> 0.6.15 and tokio-threadpool 0.1.4 -> 0.1.5
2018-08-02T18:18:44 #rust-webdev <sfackler> there was a concurrency change in tokio-threadpool there
2018-08-02T18:18:50 #rust-webdev <sfackler> I wonder if that interacts poorly with blocking or something
2018-08-02T18:20:32 #rust-webdev <sfackler> no interesting looking mio changes, so I guess we'll try dropping tokio-threadpool back down and see if that does the right thing?
2018-08-02T18:20:38 #rust-webdev <sfackler> might be best to stop using blocking for DNS as well
2018-08-02T18:21:22 #rust-webdev <seanmonstar> in linkerd we've been able to use trust-dns-resolver recently
2018-08-02T18:21:29 #rust-webdev <sfackler> oh really
2018-08-02T18:21:37 #rust-webdev <sfackler> does it hook into system dns config properly?
2018-08-02T18:22:04 #rust-webdev <seanmonstar> i believe mostly, i recall the docs saying theres some caveats...
2018-08-02T18:22:17 #rust-webdev <seanmonstar> and i believe it only reads /etc/hosts when you tell it to
2018-08-02T18:22:39 #rust-webdev <sfackler> interesting
2018-08-02T18:22:51 #rust-webdev <sfackler> for now I think i'll just run a couple of DNS threads but that'd be interesting to look into
2018-08-02T18:22:55 #rust-webdev <seanmonstar> but if you dont use that file to dynamically change things, should be fine?
2018-08-02T18:36:34 #rust-webdev <sfackler> probably, but I also don't know what the networking setup is on our instances so it'd probably take some experimentation
2018-08-04T17:07:50 #rust-webdev <xor> I want to add a copyright footer to all pages, I figured I could use the template engine(askama) to do that, but the way I'm thinking I would have to feed a variable with the year to every single template. Isn't there a way to setup a default context?
2018-08-05T20:27:43 #rust-webdev <phil905> hello is this the right place for wasm questions?
2018-08-05T21:30:28 #rust-webdev <SovietBear> i want to use proper devops for my Rust server that uses postgres. what's the right way?
2018-08-08T05:21:57 #rust-webdev <hjr3> how are people communicating errors for HTTP POST/PUT bodies being deserialized into json? for example, the json body was missing two required fields. in this case i want to return a single response with both errors. my ~1 hour reading of serde_json seems to support returning only one error at a time
2018-08-08T21:19:58 #rust-webdev <sfackler> seanmonstar: interesting, okhttp doesn't bother serializing the initial connection to a host to avoid multiple http2 connections apparently
2018-08-08T21:20:30 #rust-webdev <seanmonstar> sfackler: i dont follow
2018-08-08T21:20:48 #rust-webdev <sfackler> for ALPN support, we discussed what to do on the first connection to a host
2018-08-08T21:21:09 #rust-webdev <sfackler> since you don't know if it supports HTTP2, and we want to only keep a single HTTP2 connection but allow multiple HTTP1 connections
2018-08-08T21:21:16 #rust-webdev <sfackler> https://github.com/hyperium/hyper/issues/1485#issuecomment-398776401
2018-08-08T21:21:20 #rust-webdev <seanmonstar> oh sure sure
2018-08-08T21:22:22 #rust-webdev <sfackler> we could follow okhttp's lead which would simplify things
2018-08-08T21:22:57 #rust-webdev <sfackler> from what I can tell, if there's no pooled connection, every requesting thread/task makes a new connection, and then they all try to deduplicate immediately after finishing
2018-08-08T21:23:16 #rust-webdev <sfackler> which we already basically cover by racing the connection and checkout
2018-08-09T12:28:10 #rust-webdev <jens1o> What is like the beginner-friendlist framework to build a RESTful API? I used express.js most of the time for now, but I want to explore the "rust-way" of it
2018-08-09T12:28:40 #rust-webdev <jens1o> (It should be maintained)
2018-08-09T12:31:29 #rust-webdev <anis> while in development, how do you reload a web server automatically after changing files?
2018-08-09T12:51:35 #rust-webdev <Faux> You could rig up inotify-wait if you want.
2018-08-09T13:07:02 #rust-webdev <Calinou> https://github.com/mattgreen/watchexec
2018-08-09T13:07:08 #rust-webdev <Calinou> write your app, not a script :P
2018-08-09T13:07:19 #rust-webdev <Calinou> anis: ^
2018-08-09T13:11:31 #rust-webdev <zygentoma> iron handlebars supports a watch-feature https://github.com/sunng87/handlebars-iron/blob/master/examples/watch_server.rs
2018-08-09T13:11:48 #rust-webdev <Calinou> that works too :) it's best to use the built-in framework feature if there is one
2018-08-09T13:12:00 #rust-webdev <Calinou> watchexec is really nice for daily usage still (even if you're not developing in Rust)
2018-08-09T13:12:30 #rust-webdev <Calinou> it's also smart enough to perform an initial build when you first call it (something I've seen many frameworks fail to do)
2018-08-09T18:08:33 #rust-webdev <carllerche> I have opened up Tower Web (async web framework w/ macros) https://medium.com/@carllerche/tower-web-a-new-web-framework-for-rust-e2912856851b
2018-08-09T18:18:48 #rust-webdev <jens1o> carllerche Why should I use exactly this framework instead of a well-maintained, well-documented and stable framework? Is it any different?
2018-08-09T18:20:05 #rust-webdev <sfackler> if only there was some kind of blog post discussing the design decisions
2018-08-09T18:20:28 #rust-webdev <jens1o> If this is irony: I don't see so many differences
2018-08-09T18:20:53 #rust-webdev <carllerche> jens1o: "instead of a well-maintained, well-documented and stable framework" if you know of one that covers the same features, then go for it :)
2018-08-09T18:21:19 #rust-webdev <jens1o> Well, I was wondering whether I should extent my horizon in any way ^^
2018-08-09T18:21:40 #rust-webdev <carllerche> jens1o: I wrote tower-web because I do not know of any other options that cover the use casees
2018-08-09T18:21:55 #rust-webdev <jens1o> like async handling?
2018-08-09T18:22:09 #rust-webdev <carllerche> re: "well-documented and stable framework", this comes with time... I do have some cred in getting to that point.
2018-08-09T18:22:30 #rust-webdev <carllerche> jens1o: 1) async handling 2) decoupling HTTP from app logic
2018-08-09T18:22:39 #rust-webdev <carllerche> 3) works on stable
2018-08-09T18:23:47 #rust-webdev <seanmonstar> 4) built on top of crates that get wide production use inside linkerd2
2018-08-09T18:32:58 #rust-webdev <wadadli> linkerd2 is written in rust?
2018-08-09T18:33:26 #rust-webdev <wadadli> I thought that entire ecosystem was go nuts
2018-08-09T18:33:29 #rust-webdev <carllerche> wadadli: https://github.com/linkerd/linkerd2-proxy
2018-08-09T18:34:00 #rust-webdev <carllerche> sean and I both work @ buoyant (linkerd)
2018-08-09T18:34:57 #rust-webdev <wadadli> oh that's cool!
2018-08-09T18:35:27 #rust-webdev <wadadli> so  I always wanted to ask, what's a service mesh for dummies?
2018-08-09T18:39:24 #rust-webdev <carllerche> wadadli: it's a very fancy proxy
2018-08-09T18:40:29 #rust-webdev <carllerche> a proxy w/ tight integration w/ the whole kubernetes / cloud / microseervice / $buzzword thing
2018-08-09T18:44:20 #rust-webdev <seanmonstar> wadadli: quick pitch: takes no config and installs in a couple seconds, gives you telemetry of all requests, can secure all your inter-service communication with automatic TLS, auto HTTP2 your http1 services. if you hate it, it uninstalls in a couple seconds, so worth trying to see if you like it
2018-08-15T23:46:38 #rust-webdev <joe_thomas> Hello!
2018-08-15T23:57:59 #rust-webdev <Sergio> Hi!
2018-08-16T04:21:42 #rust-webdev <wadadli> Sergio: o/
2018-08-16T04:21:51 #rust-webdev <Sergio> Hello!
2018-08-16T04:22:03 #rust-webdev <wadadli> :)
2018-08-17T15:35:55 #rust-webdev <algermissen> @seanmonstar Do I understand correctly that there is *at the moment* no possibility to implement a wrapping filter outside the warp crate?
2018-08-17T17:50:37 #rust-webdev <seanmonstar> algermissen: that's correct, the way to do so even internally doesnt feel great, and i wanted room to try to improve that api first
2018-08-19T18:11:32 #rust-webdev <mib_7qpvv8> ?
2018-08-20T06:32:17 #rust-webdev <frogmella> hi
2018-08-20T06:32:59 #rust-webdev <frogmella> can anyone tell me what does rust do???
2018-08-20T06:34:07 #rust-webdev <frogmella> ow does it help in web dovelempment
2018-08-20T11:38:53 #rust-webdev <algermissen> seanmonstar: Is there a way in warp to force a reply (not rejection) out of a filter that stops going further down the filter chain (eg reply 401 from authentication header filter if the header is not present).
2018-08-22T22:38:46 #rust-webdev <SovietBear> hey
2018-08-22T22:39:19 #rust-webdev <SovietBear> if anyone is coming from Elm/PureScript or other functional langs, you might be interested in this: https://www.reddit.com/r/rust/comments/99hr4j/yew_ideas_for_typesafe_childquerying_and/
2018-08-23T21:33:07 #rust-webdev <theobromine> help! i'm trying to send emails containing only "plain text" and "links". these links can be somewhat long (longer than 78 characters). what is the "best" method of doing this? when i use lettre and send the emails encoded in plain text, the links get truncated and so are unusable. also as a minor nit, the mandatory carriage returns can make the formatting look funky. i wrote a simple parser to convert my plain text + links to mjml, 
2018-08-23T21:33:07 #rust-webdev <theobromine> and then convert the mjml to html, but i'm ending up with some really confusing mangling of the html when i send it to gmail
2018-08-23T21:44:02 #rust-webdev <theobromine> in particular the link href appears to point to xn--2ca093cn, but i don't have that anywhere in my code/html/etc
2018-08-23T23:42:31 #rust-webdev <theobromine> Carol: hey, talking to me?
2018-08-24T19:56:40 #rust-webdev <seanmonstar> why are these spambots even a thing
2018-08-24T20:00:35 #rust-webdev <ytain> yeah, I wonder
2018-08-24T20:01:04 #rust-webdev <sfackler> I should probably set +r I guess
2018-08-24T20:01:11 #rust-webdev <ytain> correct
2018-08-24T20:03:54 #rust-webdev <sfackler> should be set now I think?
2018-08-24T20:03:58 #rust-webdev <sfackler> how do I even irc
2018-08-24T20:04:47 #rust-webdev <ytain> the channel mode should be CFfjnrst
2018-08-24T21:08:54 #rust-webdev <seanmonstar> rofl
2018-08-24T22:19:57 #rust-webdev <ytain> as I said before the channel modes should mirror the ones from #rust
2018-08-24T22:47:35 #rust-webdev <ytain> it's missing the 'n' mode
2018-08-24T22:51:05 #rust-webdev <sfackler> I told chanserv to add it: `mode #rust-webdev set +CFfjnrst 5:3 5:3 10:5`
2018-08-24T22:52:45 #rust-webdev <ytain> I see
2018-08-24T22:52:48 #rust-webdev <ytain> oh well
2018-08-24T22:52:58 #rust-webdev <ytain> let's see how it fares against spammers
2018-08-24T23:00:40 #rust-webdev <sfackler> rage
2018-08-24T23:01:21 #rust-webdev <ytain> ugh
2018-08-25T15:24:05 #rust-webdev <ytain> stupid spammer
2018-08-25T15:24:15 #rust-webdev <ytain> got a prvmsg from that one
2018-08-25T17:54:39 #rust-webdev <jiuweigui> time to do something for the channel permissions
2018-08-25T18:39:35 #rust-webdev <ytain> the channel modes should be the same as #rust
2018-08-26T06:47:55 #rust-webdev <cornelius> hey all.
2018-08-28T03:44:28 #rust-webdev <IgnitusLairron> hey there guys, anyone around that could help me with some stuff related to Iron?
2018-08-28T09:14:06 #rust-webdev <sluggo> fgg 
2018-08-29T12:26:38 #rust-webdev <SovietBear> how to setup heroku (free dyno) with rust and postgres?
2018-08-30T01:50:39 #rust-webdev <seanmonstar> sfackler: how do you feel with what you explored in typed-headers? i've finally started on https://github.com/hyperium/headers
2018-08-30T01:50:54 #rust-webdev <seanmonstar> though the repo currently isnt usable...
2018-08-30T02:01:07 #rust-webdev <sfackler> seanmonstar: I feel reasonably good about it - the main question I'd have is if the level of pedantry is too much for the "standard" header implementation
2018-08-30T02:01:38 #rust-webdev <sfackler> e.g. it force-lowercases tokens and is particular about the contents of the authorization header
2018-08-30T02:02:55 #rust-webdev <seanmonstar> i'll be looking tomorrow to tackle as many as possible
2018-08-30T11:54:51 #rust-webdev <jens1o> hey there
2018-08-31T08:51:47 #rust-webdev <zygentoma> hi DeborahE61990
2018-08-31T08:53:57 #rust-webdev <zygentoma> haha
2018-08-31T21:49:45 #rust-webdev <theobromine> i have a postgres table which i'm going to be adding and deleting a lot of rows from and need to come up with a sensible key (incidentally im using diesel along with this)
2018-08-31T21:50:00 #rust-webdev <theobromine> i could use serial and with 99.9% likelihood that's fine,
2018-08-31T21:50:07 #rust-webdev <theobromine> but i'm worried about hitting some kind of maximum value
2018-08-31T21:50:34 #rust-webdev <theobromine> is there a sensible key type i can use ? i'm okay if a key used on a deleted row ends up being the same as a key on a new row later
2018-08-31T21:52:03 #rust-webdev <sfackler> theobromine: use bigserial and you have 2^63 values
2018-08-31T21:54:06 #rust-webdev <theobromine> looks like i can set CYCLE?
2018-08-31T21:54:25 #rust-webdev <theobromine> im not interested in a windows 95 situation where my application dies because it hits a lame maximum value somewhere
2018-09-02T05:10:10 #rust-webdev <xor> Is anyone using a redis rust client? Which one/s? I can't find one that supports clustering, pipelining and pubsub. Would it be feasible to use multiple?
2018-09-02T05:20:46 #rust-webdev <xor> There is of course redis-rs which supports pipelining and pubsub, but no clustering. Then there is the less known fred.rs, which supports clustering and pubsub, but no pipelining, and also doesn't distribute reads across slaves.
2018-09-02T05:33:06 #rust-webdev <xor> Found one, not too sure about it though. https://github.com/tickbh/td_rredis
2018-09-02T08:20:14 #rust-webdev <xor> td_rredis doesn't seem to distribute reads through slaves either.
2018-09-07T20:55:36 #rust-webdev <dowwie> @seanmonstar hey I'm struggling to find an example of how a (session) cookie used in reqwest request can be included with a redirect.. I suspect there's a param or something related to the RedirectPolicy to do this?
2018-09-07T20:59:37 #rust-webdev <seanmonstar> dowwie: there is no such option
2018-09-07T21:00:27 #rust-webdev <seanmonstar> just a tracking issue to implement cookies/sessions https://github.com/seanmonstar/reqwest/issues/14
2018-09-07T21:03:43 #rust-webdev <dowwie> seanmonstar:  ok I'll make do :( thx
2018-09-12T23:38:05 #rust-webdev <Michelle_37> Bonjour!
2018-09-13T05:14:55 #rust-webdev <Ruth_43> Salut
2018-09-18T15:13:18 #rust-webdev <Guest66> Hi, I am trying to modify the response from Iron to be chunked if there is a Range header. I can get the Byte([FromTo(0, 10]) from the headers, and I have the response that is the full body. Im stuck where to go from there
2018-09-20T16:14:50 #rust-webdev <cschneid> just looked at the issues in the Tower repo, and it looks like it's still pretty new? Stuff like no support for cookies, template engine integration still rough? I like its style and carllerche is a good person to trust when it comes to frameworks. But still too new for a project?
2018-09-20T16:41:09 #rust-webdev <carllerche> cschneid: the best way to push it forward is to use it and contribute missing pieces
2018-09-20T16:42:39 #rust-webdev <cschneid> carllerche: of course :) I'll spike something out. At worst, most of the code I write is just plain rust anyway
2018-09-20T16:43:13 #rust-webdev <carllerche> @cschneid handlebars support (for templates) is coming really soon
2018-09-20T16:43:21 #rust-webdev <carllerche> adding cookie support is probably not *too* hard
2018-09-20T16:43:22 #rust-webdev <cschneid> I saw that issue
2018-09-20T16:43:32 #rust-webdev <carllerche> I'd open an issue to discuss requirements / design
2018-09-20T16:46:12 #rust-webdev <cschneid> I'll need to dive into the code base a bit to figure out how things on the incoming & outgoing edges work. In other frameworks there's a `response` variable of some sort that you mutate with what you want. But it doesn't seem like that's how tower does it? 
2018-09-20T16:46:24 #rust-webdev <cschneid> The response is how you set stuff like status codes and headers
2018-09-20T16:47:10 #rust-webdev <cschneid> anyway, I'll play with it and report back - thank you for building something cool
2018-09-20T16:48:06 #rust-webdev <carllerche> cschneid: at the very least, you can always return a response type from a handler
2018-09-20T16:48:18 #rust-webdev <carllerche> or you can "just" set headers
2018-09-20T16:48:33 #rust-webdev <carllerche> there probably should be special support or cookies
2018-09-20T16:48:51 #rust-webdev <carllerche> cschneid: I"d look at how custom headers are read / set and then we probably want to do something similar w/ cookies
2018-09-20T17:51:15 #rust-webdev <nkr> Whats the recommended rust web framework these days?
2018-09-20T17:52:47 #rust-webdev <seanmonstar> nkr: thats an opinionated topic
2018-09-20T17:53:02 #rust-webdev <nkr> Hm most updated then?
2018-09-20T17:53:24 #rust-webdev <seanmonstar> im biased to suggest warp, but theres also tower-web, gotham, rocket, rouille, actix, ...
2018-09-20T18:00:14 #rust-webdev <nkr> Warp is your project?
2018-09-20T18:00:40 #rust-webdev <nkr> Looks cool!
2018-09-20T18:01:24 #rust-webdev <nkr> I'll try it out
2018-09-20T18:15:50 #rust-webdev <carllerche> nkr: tower-web is objectively the best in the world! ;)
2018-09-20T18:16:07 #rust-webdev <nkr> haha
2018-09-20T18:16:09 #rust-webdev <nkr> Ill try it out too
2018-09-20T18:16:11 #rust-webdev <nkr> So many options
2018-09-20T18:31:32 #rust-webdev <dowwie> nkr:  check out https://actix.rs
2018-09-20T18:31:42 #rust-webdev * dowwie glares at carllerche and seanmonstar
2018-09-20T18:32:42 #rust-webdev <nkr> "and most fun web framework"
2018-09-20T18:32:44 #rust-webdev <nkr> nice haha
2018-09-20T18:32:49 #rust-webdev <dowwie> yeah I don't know where that came from
2018-09-20T18:38:39 #rust-webdev <nkr> Im looking for something with templating and such
2018-09-20T18:40:16 #rust-webdev <carllerche> nkr: tower-web should have templating support in a few days :)
2018-09-20T18:42:49 #rust-webdev <nkr> You guys are good salesmen
2018-09-20T18:52:17 #rust-webdev <dowwie> I'm not selling anything.  These are all good projects
2018-09-20T18:54:27 #rust-webdev <nkr> Im just kidding
2018-09-20T18:54:36 #rust-webdev <nkr> They all seem great
2018-09-20T19:01:44 #rust-webdev <nkr> carllerche: What templating are you including?
2018-09-20T19:07:51 #rust-webdev <carllerche> nkr: handlebars initially, but mostly to test the integration. It's being added so that the templating engine can be configured.
2018-09-20T19:08:13 #rust-webdev <carllerche> nkr: see here: https://github.com/carllerche/tower-web/issues/103
2018-09-20T19:08:42 #rust-webdev <carllerche> nkr: this comment shows the rough API I'm going for: https://github.com/carllerche/tower-web/issues/103#issuecomment-420329399
2018-09-20T20:56:37 #rust-webdev <seanmonstar> dowwie: huh what? glare? confused
2018-09-20T20:59:53 #rust-webdev <dowwie> seanmonstar:   sorry I think that was the wrong word.. more like, fades back into hedges like Homer Simpson
2018-09-20T21:03:47 #rust-webdev <seanmonstar> dowwie: oh ok, np! confusion was because definition of glare is "stare in an angry or fierce way" ;)
2018-09-22T21:47:53 #rust-webdev <panicbit> Hey, I'm currently running into issues while using ipfs-api
2018-09-22T21:48:38 #rust-webdev <panicbit> When I resolve one of the futures via blocking on the local thread I consistently get "unexpected bytes before writing message" ( https://github.com/hyperium/hyper/blob/1448e4067b10da6fe4584921314afc1f5f4e3c8d/src/proto/h1/conn.rs#L267 )
2018-09-22T21:49:19 #rust-webdev <panicbit> OTOH, when running on a thread pool, I get wildy differing errors
2018-09-22T21:50:52 #rust-webdev <panicbit> These are the 3 different errors I'm getting randomly on different runs https://gist.githubusercontent.com/panicbit/7bef90ffb53ec7064cea865a0c1696c2/raw/4bcd48b98270123a3a5500aed62c0b59f80c32dd/errors
2018-09-22T21:52:12 #rust-webdev <panicbit> These are not network issues, since I'm connecting to localhost
2018-09-22T22:30:04 #rust-webdev <panicbit> Whoops, wrong port
2018-09-22T22:30:43 #rust-webdev <panicbit> Still weird that the errors are so different
2018-09-22T22:34:30 #rust-webdev <panicbit> Ah, another service is running at the other port
2018-09-22T22:34:43 #rust-webdev <panicbit> I guess exerything makes sense now
2018-09-25T19:50:22 #rust-webdev <FreeMasen> Does anyone know of a way to debug routing in warp?
2018-09-25T19:51:24 #rust-webdev <seanmonstar> FreeMasen: if you enable logging for warp, you can see most of the filters its trying
2018-09-25T19:52:21 #rust-webdev <FreeMasen> I do have logging enabled
2018-09-25T19:52:43 #rust-webdev <FreeMasen> but I also have a catch-all route in the end of my combinator chain
2018-09-25T19:52:58 #rust-webdev <FreeMasen> would I need to remove that, all my requests are just matching that right now
2018-09-25T19:56:10 #rust-webdev <FreeMasen> If I remove my catch-all I get the following in the terminal
2018-09-25T19:56:12 #rust-webdev <FreeMasen> https://gist.github.com/FreeMasen/040e3e1be05ce69409c8801e999c1e6a
2018-09-25T19:57:06 #rust-webdev <FreeMasen> I am trying to figure out why my browser requests are failing. I have a test that spins up the server and makes the requests using `reqwest` and that passes just fine
2018-09-25T19:57:26 #rust-webdev <FreeMasen> but now that I am trying to make the request from javascript, they are failing
2018-09-25T20:04:35 #rust-webdev <seanmonstar> FreeMasen: try setting warp's log level to trace to get everything
2018-09-25T20:04:54 #rust-webdev <FreeMasen> ok, I will try that. Thanks!
2018-09-26T16:11:36 #rust-webdev <KB5> Does Rockket work with the recently released 2018 Edition RC1?
2018-09-26T16:59:34 #rust-webdev <seanmonstar> KB5: i dont see why it wouldn't, but should be easy to check if you use rustup
2018-09-26T16:59:52 #rust-webdev <seanmonstar> oh wait
2018-09-26T17:00:20 #rust-webdev <seanmonstar> i think it still requires some nightly features, and the rc1 isnt a nightly?
2018-09-27T14:50:14 #rust-webdev <mib_l44g06> Does anyone know if you can make http requests from Rust in a WebAssembly context?
2018-09-27T14:58:27 #rust-webdev <ytain> Fetch service?
2018-09-28T03:30:27 #rust-webdev <Psilidae> \q
2018-10-01T07:21:12 #rust-webdev <aep1> which framework do i want if i'm just building a json api? stable rust
2018-10-01T07:22:36 #rust-webdev <Faux> https://github.com/tomaka/rouille
2018-10-01T07:25:01 #rust-webdev <aep1> i'm also lazy and wouldnt mind an ecosystem of available compatible stuff :D
2018-10-01T07:25:12 #rust-webdev <aep1> like auth
2018-10-01T07:25:47 #rust-webdev * Faux shrugs.
2018-10-01T07:42:56 #rust-webdev <vegai> https://python.org :)
2018-10-01T07:43:46 #rust-webdev <vegai> https://www.arewewebyet.org/topics/auth/ 
2018-10-03T16:01:51 #rust-webdev <dowwie> seanmonstar:   upgraded my reqwest crate today and entered a world of pain because of the header value changes
2018-10-03T16:34:31 #rust-webdev <Faux> I picked up that upgrade, and the header changes simplified a load of code. \o/
2018-10-03T16:43:18 #rust-webdev <FreeMasener> When using the warp `dir` filter, is there a good way to serve the index.html for the `/` route?
2018-10-03T16:53:37 #rust-webdev <seanmonstar> dowwie: :( theres a hyper-011 'cargo feature' you can enable if that'd help
2018-10-03T16:54:05 #rust-webdev <seanmonstar> i've also been working on revamped typed headers over here https://github.com/hyperium/headers/pull/4
2018-10-03T16:57:58 #rust-webdev <FreeMasener> or rather any `/` route like /blog/ should return /blog/index.html and /contact/ should return /contact.html
2018-10-03T16:58:38 #rust-webdev <seanmonstar> FreeMasener: as a redirect, or transparently?
2018-10-03T16:59:14 #rust-webdev <FreeMasener> transparently, ideally but a redirect would also work
2018-10-03T16:59:59 #rust-webdev <seanmonstar> FreeMasener: seems like the feature needs to be written XD https://github.com/seanmonstar/warp/issues/108
2018-10-03T17:01:06 #rust-webdev <FreeMasener> alright, good to know I wasn't just missing it
2018-10-03T17:19:01 #rust-webdev <dowwie> seanmonstar:   why was to_string() taken away for HeaderVal ?
2018-10-03T17:19:49 #rust-webdev <seanmonstar> dowwie: because it was incorrect (and indeed the error was hit in real world)
2018-10-03T17:20:02 #rust-webdev <seanmonstar> HTTP doesn't require header values to be utf8
2018-10-03T18:33:33 #rust-webdev <dowwie> seanmonstar:  I'm feeling a bit lost since this reqwest upgrade.  No docs showing the changes.  can I get some guidance?
2018-10-03T18:34:16 #rust-webdev <seanmonstar> dowwie: do these help? https://github.com/seanmonstar/reqwest/blob/master/CHANGELOG.md#v090
2018-10-03T18:43:36 #rust-webdev <dowwie> seanmonstar:  no it doesn't, far from.  this is a really bad experience 
2018-10-03T18:46:03 #rust-webdev <seanmonstar> dowwie: what is missing from the breaking changes?
2018-10-03T18:46:51 #rust-webdev <dowwie> seanmonstar:  for instance I used to be able to pass a Cookie into header(..) within request building ,
2018-10-03T18:48:12 #rust-webdev <seanmonstar> dowwie: in the breaking changes section of the changelog, it mentions how to re-enable a compatibility to use typed headers
2018-10-03T18:55:49 #rust-webdev <seanmonstar> dowwie: is there something about that entry that isn't clear? how can i make it better?
2018-10-03T18:56:26 #rust-webdev <dowwie> seanmonstar:  I don't want to live in the past if I just knew how to transition to the future :)
2018-10-03T18:58:06 #rust-webdev <dowwie> seanmonstar:  for instance, a  MIGRATIONS.md might contain something like "before, you might have set a session cookie using X. now, you'd do it using Y"
2018-10-03T18:58:11 #rust-webdev <seanmonstar> dowwie: so, you can change to `.header("cookie", some_cookie_str)`... and im trying to work on the new typed headrs as quickly as possible
2018-10-03T18:59:05 #rust-webdev <seanmonstar> dowwie: does the example with '// Old' and '// New' for useragent do what you mean?
2018-10-03T18:59:39 #rust-webdev <dowwie> seanmonstar:  it does -- I don't pass a Cookie type anymore?
2018-10-03T19:00:34 #rust-webdev <seanmonstar> the typed headers are in hiatus, but there is also a 'stringly' api
2018-10-03T19:32:14 #rust-webdev <dowwie> seanmonstar:  step 1:  let cookie_h = response.headers().get(header::SET_COOKIE).unwrap();     step 2: (FAILS) Cookie::parse(cookie_h.to_str()).clone().unwrap();      with a COW related error .. I'm trying to create a Cookie.  doesn't really matter how.
2018-10-03T19:34:50 #rust-webdev <seanmonstar> dowwie: header_val.to_str() can fail, https://docs.rs/http/0.1.13/http/header/struct.HeaderValue.html#method.to_str
2018-10-03T19:35:13 #rust-webdev <seanmonstar> you're passing the `Result<&str, ToStrError>` to `Cookie::parse`
2018-10-03T19:35:40 #rust-webdev <dowwie> ohh I was missing an unwrap
2018-10-03T19:36:00 #rust-webdev <dowwie> seanmonstar:   thx good catch
2018-10-03T20:20:44 #rust-webdev <dowwie> seanmonstar:  seems like I've gotten through the rough spots.. thx for the help
2018-10-04T03:35:12 #rust-webdev <Psilidae> Does anyone here have experience deploying a rust app to Heroku with emk's buildpack? I feel like I'm pretty close, but I'm struggling getting my diesel migrations to run. I assume I need to specify diesel's `DATABASE_URL` environment var somewhere, but I'm not sure where (this is my first time using Heroku). Anyone have any tips?
2018-10-04T03:52:16 #rust-webdev <Psilidae> Okay, after reading over the docs, I figured out that the pg addon adds it automatically. It looks like diesel-cli isn't being installed for some reason. :/
2018-10-04T05:04:55 #rust-webdev <Psilidae> Alright figured it out. I guess he hasn't updated the release version of the buildpack. I needed to use the "edge" version directly from the git repo, and declare my own "DIESEL_FLAGS" config value. 
2018-10-08T07:53:49 #rust-webdev <letharion> I've gotten a trivial webserver up and running by looking at actix-web: https://actix.rs/docs/getting-started/ Now I'm trying to work out, how do I return another status-code, redirect/302. I tried grepping through actix-web for 302 and a few other status codes, assuming that somewhere the underlaying numbers would be hardcoded, but that yielded nothing?
2018-10-08T08:06:16 #rust-webdev <freefall> letharion: https://actix.rs/api/actix-web/stable/actix_web/struct.HttpResponse.html#method.Found
2018-10-08T08:07:21 #rust-webdev <freefall> more generally, https://actix.rs/api/actix-web/stable/actix_web/dev/struct.HttpResponseBuilder.html#method.status
2018-10-08T08:28:22 #rust-webdev <letharion> freefall: Thanks, I'll take a look.
2018-10-09T13:18:52 #rust-webdev <dowwie> @seanmonstar are you aware of any work done for flexible, type-safe PATCH operations for Rust web dev?
2018-10-09T18:13:17 #rust-webdev <cschneid> I know of Yew, but is there a list of other frontend frameworks built on rust + wasm? Curious to look and see whats out there. I'm starting a new side project and don't want to just go down the elm route if I could be doing rust instead :) 
2018-10-09T18:47:30 #rust-webdev <freefall> i think it's safe to say that, so far, the number of rust front-end web frameworks is small
2018-10-09T18:56:20 #rust-webdev <seanmonstar> dowwie: i was actually looking into that for warp, and noticed that there seems to be some support in serde
2018-10-11T22:06:27 #rust-webdev <halfbit> it seems most people have been moving on from iron for webdev related work?
2018-10-11T22:06:37 #rust-webdev <halfbit> I see a few commits there, but no release in quite awhile
2018-10-11T22:06:41 #rust-webdev <halfbit> and lots has changed
2018-10-11T22:06:55 #rust-webdev <halfbit> kind of concerned at this point I'm going to end up with something broken in the future
2018-10-11T22:19:47 #rust-webdev <freefall> you could say iron is getting pretty... rusty
2018-10-11T22:20:07 #rust-webdev <halfbit> and I'm still using 0.5 
2018-10-11T22:20:09 #rust-webdev <halfbit> scary
2018-10-11T22:20:36 #rust-webdev <halfbit> on the other hand... it just continues to work well for me
2018-10-11T22:22:30 #rust-webdev <halfbit> sigh I guess I'll spend a little time investigating alternatives
2018-10-11T22:22:37 #rust-webdev <halfbit> trying to update to 0.6 gives me errors anyways
2018-10-11T22:24:06 #rust-webdev <halfbit> seems like actix and tower? not really interested in requiring unstable
2018-10-11T22:24:13 #rust-webdev <halfbit> did that before for serde, that was painful
2018-10-11T22:28:40 #rust-webdev <freefall> actix-web is pretty comprehensive, already has some serious production users
2018-10-11T22:29:26 #rust-webdev <freefall> warp/tower-web are promising but still haven't merged yet and are in early days
2018-10-11T22:44:07 #rust-webdev <blackbeard420> rocket is solid
2018-10-11T22:51:54 #rust-webdev <freefall> and nightly-only
2018-10-11T22:56:15 #rust-webdev <halfbit> yeah, nightly only is a no go
2018-10-11T22:56:15 #rust-webdev <halfbit> I've done that and it was painful
2018-10-11T22:56:43 #rust-webdev <halfbit> did it for serde when it was that or use the horribly slow compile time generator stuff
2018-10-11T22:56:51 #rust-webdev <halfbit> never again
2018-10-11T22:58:55 #rust-webdev <halfbit> I feel like the the more I look at this, the more I just thinking staying with iron for now is fine
2018-10-11T23:02:49 #rust-webdev <halfbit> like tower looks pretty magical honestly
2018-10-11T23:03:19 #rust-webdev <carllerche> Tower web is stable
2018-10-11T23:03:41 #rust-webdev <carllerche> halfbit: what is magical?
2018-10-11T23:03:51 #rust-webdev <halfbit> I'm not arguing that, but using the param name to determine where args get parsed from seems pretty magical
2018-10-11T23:04:12 #rust-webdev <halfbit> also, my body is a protobuf and I need to decode differently based on a header
2018-10-11T23:05:14 #rust-webdev <carllerche> halfbit: the param name is a default. In the future there will be an attribute to specify which
2018-10-11T23:05:31 #rust-webdev <carllerche> It’s a matter of taste, I prefer less boilerplate :-)
2018-10-11T23:06:37 #rust-webdev <halfbit> carllerche: yeah I mean, if I were starting fresh this would be cool
2018-10-11T23:06:57 #rust-webdev <halfbit> just feel like the already entrenched client base would make all the awesomeness not really that awesome in my scenario
2018-10-11T23:08:26 #rust-webdev <halfbit> I might be wrong, would have to spend more time looking
2018-10-12T13:20:37 #rust-webdev <t2> Is there a decent example of a combination of actix, postgres, and connection-pooling? I'm not a fan of ORM for the most part so I wasn't hugely interested in diesel, but if it's "the one true path" then I guess I don't have much choice.
2018-10-12T13:29:23 #rust-webdev <freefall> t2: i also don't usually like orms but diesel is the way to go for rust. it's very solid and gives you full type safety
2018-10-12T13:30:21 #rust-webdev <freefall> t2: this example has what you asked for: https://github.com/actix/examples/tree/master/diesel
2018-10-12T13:32:23 #rust-webdev <t2> Thanks freefall 
2018-10-12T13:34:01 #rust-webdev <t2> Is there much of a speed difference these days? I was kinda hoping for something purely async (like tokio-postgres) but this area still seems a bit... fragile. I liked at the techempower code and I don't even think it still compiles against later versions for example
2018-10-12T13:34:15 #rust-webdev <t2> s/liked/looked/
2018-10-12T13:35:55 #rust-webdev <freefall> there's no sane way to do async database i/o at the moment
2018-10-12T13:36:14 #rust-webdev <t2> Ah, shame. :(
2018-10-12T13:37:02 #rust-webdev <freefall> in practice you just spawn a bunch of threads that use the db connection pool
2018-10-12T13:37:11 #rust-webdev <freefall> that's completely fine for most use cases
2018-10-12T13:37:52 #rust-webdev <freefall> if you use actix, it handles that aspect for you transparently via SyncArbiter
2018-10-12T13:38:46 #rust-webdev <t2> Fair enough, I'll give it a go. Thanks again.
2018-10-12T19:52:53 #rust-webdev <halfbit> so looking harder at whats out there and what I might use to replace iron... warp and actix seem the closest, I like that warp keeps hyper
2018-10-17T18:35:41 #rust-webdev <edcragg> what is this spam? bizarre
2018-10-17T18:36:15 #rust-webdev <edcragg> ...or is someone working on a rust spam bot?
2018-10-17T18:36:31 #rust-webdev <edcragg> or running tests
2018-10-17T18:36:58 #rust-webdev <Faux> It is everywhere, and continuous, except in places where ops have set registered-people-only.
2018-10-17T18:37:15 #rust-webdev <edcragg> hrm
2018-10-17T21:41:27 #rust-webdev <seanmonstar> looking at the modes on this channel, it has 'r', which should require registered i think. compared with #rust, i only see a 'j' additional mode, which is a join throttle...
2018-10-17T21:43:05 #rust-webdev <ytain> well #rust has additional modes 'fjn'
2018-10-17T21:44:53 #rust-webdev <ytain> f mode is forwarding if the number of users is too big and additional channel #rust2 will be created
2018-10-17T21:45:11 #rust-webdev <ytain> n is no external messages
2018-10-17T21:45:21 #rust-webdev <ytain> only channel members can talk
2018-10-17T21:51:33 #rust-webdev <ytain> I think the r must be switched with R
2018-10-17T21:52:37 #rust-webdev <ytain> cause on every ircd daemon for every irc network I know of, it shows that r is for registered channel, while R is for registered users (via NickServ) are allowed to join the channel
2018-10-17T21:53:43 #rust-webdev <ytain> but I don't know the proper channel modes for the mozilla irc
2018-10-17T21:54:48 #rust-webdev <ytain> https://www.unrealircd.org/docs/Channel_modes
2018-10-17T21:55:18 #rust-webdev <ytain> I don't know which irc daemon mozilla irc network uses
2018-10-17T21:55:48 #rust-webdev <ytain> oh, it's inspircd
2018-10-17T21:55:52 #rust-webdev <ytain> InspIRCd-2.0
2018-10-17T21:56:19 #rust-webdev <ytain> https://wiki.inspircd.org/2.0/Channel_Modes
2018-10-18T00:27:21 #rust-webdev <seanmonstar> we can try it i guess
2018-10-18T06:38:41 #rust-webdev <Faux> \o/
2018-10-18T18:40:13 #rust-webdev -gharewewebyet- [arewewebyet] s-panferov closed pull request #10: Add Rustless to the list (master...patch-1) https://github.com/teepee/arewewebyet/pull/10
2018-10-18T20:00:58 #rust-webdev <sfackler> seanmonstar: would you be interested in a `Resolve` impl that uses tokio_threadpool::blocking rather than the separate cpupool the default impl uses?
2018-10-18T20:01:18 #rust-webdev <sfackler> not sure how extensive you want the hyper-shipped functionality to be
2018-10-18T20:05:37 #rust-webdev <seanmonstar> sfackler: seems like a fair idea (have you been using that yourself?)
2018-10-18T20:05:58 #rust-webdev <sfackler> yeah - seems to work fine
2018-10-18T20:06:03 #rust-webdev <seanmonstar> i think it might be possible to do easily with the `GaiResolve::new_with_executor(exec_that_wraps_in_blocking)`
2018-10-18T20:06:19 #rust-webdev <sfackler> particularly now that tokio-threadpool can shut down idle blocking threads
2018-10-18T20:06:33 #rust-webdev <sfackler> that seems like it could work yeah
2018-10-18T20:09:06 #rust-webdev <carllerche> I've been wanting to figure out how to associate a dns resolver w/ a tokio runtime
2018-10-18T20:12:25 #rust-webdev <seanmonstar> though, i suppose a separate type could skip the oneshot and spawn overhead
2018-10-18T20:13:36 #rust-webdev <sfackler> there's so little going on in the resolver other than the sync-to-async logic that it might just be cleaner to have two types
2018-10-18T20:30:13 #rust-webdev <seanmonstar> yea i'd make a separate type
2018-10-18T20:30:29 #rust-webdev <seanmonstar> TokioGaiResolver or something?
2018-10-18T20:31:05 #rust-webdev <sfackler> ideally it'd mention the tokio-threadpool requirement but TokioThreadpoolGaiResolver is a bit wordy
2018-10-18T20:34:46 #rust-webdev <seanmonstar> TkBlockingGaiResolver ;)
2018-10-18T21:02:43 #rust-webdev <seanmonstar> sfackler: did you want to contribute that?
2018-10-18T22:32:40 #rust-webdev <sfackler> sure i'll make a PR
2018-10-29T20:42:49 #rust-webdev <seanmonstar> @sfackler: any thoughts on the alpn support in hyper besides what you've said before in the issue?
2018-10-29T20:54:24 #rust-webdev <sfackler> not really - the basic approach of indicating via Connected seems reasonable
2018-10-29T20:54:38 #rust-webdev <sfackler> I had a PR in progress a long time ago but it was waaaaay more complicated :P
2018-11-02T19:41:28 #rust-webdev <sfackler> seanmonstar: when were you planning on cutting a hyper release? I'm excited to pick up the ALPN support!
2018-11-02T21:20:51 #rust-webdev <seanmonstar> sfackler: could today! want to also land https://github.com/hyperium/hyper/pull/1692
2018-11-02T21:26:02 #rust-webdev <sfackler> I’m about to file a bug so maybe hold off :p
2018-11-02T21:26:39 #rust-webdev <sfackler> H2 protocol error on the client side talking to google
2018-11-02T23:57:00 #rust-webdev <sfackler> seanmonstar: sounds like I move that issue over to h2?
2018-11-02T23:57:47 #rust-webdev <seanmonstar> im building a test to see
2018-11-03T00:16:04 #rust-webdev <seanmonstar> yep, its an h2 bug
2018-11-05T20:11:42 #rust-webdev <sfackler> seanmonstar: thoughts on exposing Payload::__hyper_full_data? I think `fn full_data(&mut self) -> Result<Option<Self::Data>, Self::Error>` seems pretty reasonable?
2018-11-05T20:12:21 #rust-webdev <sfackler> I guess it could alternatively be  poll_full_data instead?
2018-11-05T20:13:11 #rust-webdev <seanmonstar> sfackler: with tokio_buf::BufStream, it should be possible to get the same optimization just by checking the size hint
2018-11-09T20:59:26 #rust-webdev <quarkstone> Hey folks. Just wondering if there's something similar to stdweb js! macro in wasm-bindgen
2018-11-09T20:59:33 #rust-webdev <quarkstone> Also, what's the best strategy to inherit an es6 class that's defined in javascript?
2018-11-09T21:00:55 #rust-webdev <quarkstone> Basically, I'd like to inherit HTMLElement and write a Custom Element, with the standard "connectedCallback", "attributesChanged" etc, methods.. I'm wondering how to do this in rust.
2018-11-09T22:51:09 #rust-webdev <sfackler> seanmonstar: is there any reason that service_fn and service_fn_ok dont' take FnMut?
2018-11-09T22:52:46 #rust-webdev <seanmonstar> sfackler: if i remember right, there was possible confusion that mutating values in the closure might make you think the changes happen across all connections
2018-11-09T22:52:59 #rust-webdev <seanmonstar> i dunno, maybe that was crazy
2018-11-09T22:53:05 #rust-webdev <sfackler> hmm
2018-11-15T17:18:26 #rust-webdev <rovar> @seanmonstar,  Is there a way to force a larger buffer size in hyper client?  I'm running into a bottleneck with rusoto.. part of the problem is that it creates a new vec for every buffer delivered in the body.. 
2018-11-17T15:22:14 #rust-webdev <nifker> does someone know how to solve this? https://play.integer32.com/?version=stable&mode=debug&edition=2015&gist=2bad9a5b4bbfb79886114234fea3001c
2018-11-17T23:43:59 #rust-webdev <nifker> how can this be done? https://play.integer32.com/?version=stable&mode=debug&edition=2015&gist=2bad9a5b4bbfb79886114234fea3001c
2018-11-18T15:39:40 #rust-webdev <nifker> how can I use poll_data on Body if I get the body from a Request which is immutable because service_fn_ok requires it to be immutable but poll_data needs a mutable reference?
2018-11-18T16:17:25 #rust-webdev <nifker> how do I consume a stream?
2018-11-22T10:55:54 #rust-webdev <ahnk> should I be using wasm_bindgen or stdweb?
2018-11-22T11:36:38 #rust-webdev <chicoxyzzy> wasm-bindgen IMO
2018-12-03T04:54:19 #rust-webdev <sfackler> seanmonstar: any reason Payload binds over Buf and not IntoBuf?
2018-12-03T17:18:31 #rust-webdev <seanmonstar> sfackler: at the time, i didnt see any benefit in IntoBuf, would it be useful?
2018-12-03T17:19:00 #rust-webdev <sfackler> I was just making a similar change to tokio-postgres and noticed
2018-12-03T17:19:18 #rust-webdev <sfackler> IntoBuf does mean you can work directly with Stream<Item = Bytes> or Item = Vec<u8> or whatever
2018-12-07T14:44:32 #rust-webdev <dowwie> what category does the ``typed-html`` crate fall into?  is part of the templating libraries, such as tera, maud, or handlebars?  (https://github.com/bodil/typed-html)
2018-12-25T10:35:24 #rust-webdev <WindowsBunny> so uh
2018-12-25T10:35:43 #rust-webdev <WindowsBunny> using reqwest 0.9, how exactly do I turn a CookieJar into a string for the COOKIE header?
2019-01-03T14:12:55 #rust-webdev <dowwie> Has anyone written a wrapper for a multipart stream to measure and constrain uploads on file size ? I want to proxy a futures byte stream and close the valve once too many bytes have passed through.
2019-01-03T16:14:01 #rust-webdev <Spyro-M> I've done that in a library that trys to handle multipart data in a not-entirely-terrible way, but it's for Actix Web and I haven't touched it in a while
2019-01-03T16:14:26 #rust-webdev <Spyro-M> it won't fit your needs exactly, but maybe I can find the code I used for that part specifically
2019-01-03T16:15:56 #rust-webdev <Spyro-M> ah, I created an AtomicUsize and fetch_add'd each time I read bytes from the stream inside an and_then, returning and error if the usize got too big
2019-01-03T18:13:54 #rust-webdev <dowwie> Spyro-M:  did you get it working?  I'm using actix-web
2019-01-03T19:32:12 #rust-webdev <dowwie> Spyro-M:  think I figured it out
2019-01-24T18:51:29 #rust-webdev <sfackler> seanmonstar: something seems broken with h2 0.1.16 - i'm seeing a simple HTTP2-via-hyper test request deadlock after updating
2019-01-24T18:52:55 #rust-webdev <seanmonstar> from what previous version?
2019-01-24T18:53:00 #rust-webdev <sfackler> 0.1.15
2019-01-24T18:53:08 #rust-webdev <seanmonstar> 0.1.16 should have just been some log changes
2019-01-24T18:53:14 #rust-webdev <sfackler> I think
2019-01-24T18:53:15 #rust-webdev <sfackler> let me make sure
2019-01-24T18:53:55 #rust-webdev <seanmonstar> https://github.com/carllerche/h2/compare/v0.1.15...v0.1.16
2019-01-24T18:53:58 #rust-webdev <sfackler> oh no 1.15 was bad too
2019-01-24T18:54:17 #rust-webdev <seanmonstar> ah ok
2019-01-24T18:54:49 #rust-webdev <sfackler> checking 0.1.14 (with an accompanying downgrade of hyper to 0.12.21)
2019-01-24T18:54:52 #rust-webdev <seanmonstar> This landed in 0.1.15, seems likely https://github.com/carllerche/h2/pull/338
2019-01-24T18:55:07 #rust-webdev <sfackler> ok that combo seems to work
2019-01-24T18:56:19 #rust-webdev <sfackler> seanmonstar: oh it might actually be a problem with hyper 
2019-01-24T18:56:32 #rust-webdev <sfackler> h2 0.1.16 and hyper 0.12.21 work fine
2019-01-24T18:56:40 #rust-webdev <sfackler> but hyper 0.12.22 breaks
2019-01-24T18:57:28 #rust-webdev <seanmonstar> could be https://github.com/hyperium/hyper/pull/1754
2019-01-24T18:57:55 #rust-webdev <seanmonstar> hyper had an extra channel floating around specifically to try to prevent the race that could happen in h2
2019-01-24T18:58:05 #rust-webdev <seanmonstar> with it supposedly fixed, i removed the extra channel
2019-01-24T18:58:06 #rust-webdev <seanmonstar> i can revert
2019-01-24T18:59:27 #rust-webdev <sfackler> sure - i'll patch to the branch with a revert to confirm if that fixes it
2019-01-29T10:11:45 #rust-webdev <johndoe78954_> hi, I am using rocket with diesel postgres, is there any example usage for it? I want to know the best way to retrieve and insert on my db, for now, I get raw queries, but diesel seems to have much more and I want to use that but I'm unsure how with rocket integration
2019-01-29T10:11:46 #rust-webdev <johndoe78954_> thanks
2019-01-29T10:12:50 #rust-webdev <ytain> try the #rocket channel
2019-01-29T10:13:09 #rust-webdev <ytain> as for an example, look on github repo, in rocket_contrib folder
2019-01-29T10:14:26 #rust-webdev <johndoe78954_> I looked at it already and I did not find any example matching my use case; anyways I think I got onto something; apparently, Rocket integration is light, so I just have to get the conn and give it to diesel and use it just like diesel says, thanks
2019-01-29T10:15:59 #rust-webdev <ytain> what you need is connection pool
2019-01-29T10:16:12 #rust-webdev <ytain> https://github.com/SergioBenitez/Rocket/blob/master/contrib/lib/src/databases.rs
2019-01-29T10:33:46 #rust-webdev <johndoe78954_> ytain: yes, I had that, thanks
2019-01-29T10:35:06 #rust-webdev <ytain> johndoe78954_ also an webapp example based on Rocket https://github.com/TatriX/realworld-rust-rocket
2019-01-29T11:50:54 #rust-webdev <johndoe78954_> ytain; very useful
2019-02-01T19:26:42 #rust-webdev <sfackler> seanmonstar: is the headers crate in a place where I should deprecate typed-headers and point people that way?
2019-02-01T19:27:34 #rust-webdev <seanmonstar> sfackler: perhaps? ive been meaning to fix up the mime crate and get headers 0.3 out
2019-02-01T19:27:41 #rust-webdev <seanmonstar> just so spread thin atm
2019-02-01T19:27:48 #rust-webdev <sfackler> yeah no worries
2019-02-01T19:27:55 #rust-webdev <sfackler> just noticed a new release
2019-02-08T19:06:27 #rust-webdev <halfbit> so in my webapp currently, which was based on iron, I have a get a request, decode that into a struct, then I handle that request itself in a threadpool of my own creation by sending mpsc queue messages to some worker thread, then wait on a response for some time returning a timeout if it takes too long
2019-02-08T19:06:56 #rust-webdev <halfbit> thats worked quite well, but I'm looking to move away from iron, so I'm looking at the new scene, and seemingly I could maybe do the same thing with a Future
2019-02-08T19:08:03 #rust-webdev <halfbit> I'm kind of confused what crate my best serve this purpose
2019-02-08T19:08:14 #rust-webdev <halfbit> like there's tokio-threadpool which seems like it might be relevant
2019-02-08T19:08:35 #rust-webdev <halfbit> it would be especially nice if I didn't have to load balance requests on my threadpool myself
2019-02-08T19:09:08 #rust-webdev <halfbit> which I'm doing now by rand() % nworkers, then if that worker is busy (mpsc queue full) I try the next one until I find a free one or timeout currently
2019-02-08T19:09:22 #rust-webdev <halfbit> I feel like I did a lot of hacky stuff here just to ensure I could timeout
2019-02-08T20:28:04 #rust-webdev <rovar> out of curiosity, has anyone tried porting a web framework over to futures 0.3?
2019-02-08T20:31:12 #rust-webdev <carllerche> rovar: in what way? futures 0.3 is mostly a mechanical conversion. async/await is new (tower-web supports async / await)
2019-02-08T20:34:13 #rust-webdev <rovar> I know most of it is naming and module changes,  but that seems to be the direction of things
2019-02-08T20:34:21 #rust-webdev <rovar> I'll muck about with tower.. 
2019-02-08T20:36:08 #rust-webdev <rovar> -we
2019-02-08T20:36:09 #rust-webdev <rovar> b
2019-02-08T22:54:22 #rust-webdev <rovar> carllerche,  - that was easy:  https://gitlab.com/rrichardson/flip/blob/master/src/main.rs
2019-02-08T22:54:25 #rust-webdev <rovar> :P
2019-02-08T22:55:02 #rust-webdev <rovar> I meant to look and see if all of those macros could sit under a module so I don't have to name them all when importing in 2018 edition
2019-02-08T22:57:31 #rust-webdev <carllerche> rovar: the next breaking change will probably make tower-web 2018
2019-02-08T23:55:02 #rust-webdev <halfbit> seanmonstar: really like warp quite a lot, looks like some breaking changes coming with 0.2?
2019-02-09T00:32:34 #rust-webdev <Sergio> ~rocket
2019-02-09T00:32:36 #rust-webdev <Sergio> Oh.
2019-02-09T00:32:37 #rust-webdev <Sergio> !rocket
2019-02-09T00:32:40 #rust-webdev <Sergio> Oh.
2019-02-09T00:32:41 #rust-webdev <Sergio> :'(
2019-02-16T14:30:18 #rust-webdev <WALT> What are currently some game engines/frameworks with a lot of momentum that can build to WASM?
2019-02-16T14:30:26 #rust-webdev <WALT> *wasm/WASM I dunno :) 
2019-03-26T18:49:47 #rust-webdev <Joeyjoejoejr> Hey.  I'm using Actix web for a project.  Does anybody have a good resource outlining how to run tasks in the background?  It seems like I should be able to do this using an actor, but I'm unsure of how to go about it.
2019-04-17T18:13:42 #rust-webdev <sfackler> seanmonstar: hmm, would using `http2_half_close(false)` cause the connection future to return `an IO error occurred: unexpected EOF waiting for response`?
2019-04-17T18:14:08 #rust-webdev <sfackler> I'm seeing a bunch of that message spam in logs and did recently turn that config on
2019-04-17T18:14:24 #rust-webdev <seanmonstar> mmmmmaybe
2019-04-17T18:14:57 #rust-webdev <seanmonstar> that sounds like a client error
2019-04-17T18:15:14 #rust-webdev <sfackler> which is weird, yeah
2019-04-17T18:15:29 #rust-webdev <seanmonstar> but this is a server i assume?
2019-04-17T18:15:32 #rust-webdev <sfackler> yeah it is
2019-04-17T18:15:53 #rust-webdev <sfackler> from a server::conn::Connection future
2019-04-17T18:16:45 #rust-webdev <sfackler> it looks like it's happening in spikes at the same time, which could align with an upstream client rolling or something like that and closing a bunch of keepalive'd connections at once
2019-04-17T18:17:21 #rust-webdev <seanmonstar> it looks like that message is just misleading (in that its waiting for a response)
2019-04-17T18:19:48 #rust-webdev <sfackler> could this be happening when the connection's idle or is it a valid error since the client actually hung up during a request?
2019-04-17T18:20:29 #rust-webdev <seanmonstar> dunno if my last message went through (says i disconnected)
2019-04-17T18:20:40 #rust-webdev <sfackler> last one I saw as "it looks like that message..."
2019-04-17T18:20:54 #rust-webdev <seanmonstar> it returns that message if conn isn't currently idle
2019-04-17T18:20:58 #rust-webdev <seanmonstar> so it should mean a request or response is still streaming when the EOF happens
2019-04-17T18:21:08 #rust-webdev <sfackler> ok cool thanks
2019-04-17T18:21:51 #rust-webdev <seanmonstar> https://github.com/hyperium/hyper/blob/master/src/proto/h1/conn.rs#L301
2019-04-17T18:22:00 #rust-webdev <seanmonstar> so, must_error if conn isnt idle
2019-04-17T18:22:38 #rust-webdev <sfackler> ah ok
2019-04-17T18:22:52 #rust-webdev <sfackler> so if anything it just needs to tweak the message if it's a client or server connection
2019-04-17T18:23:11 #rust-webdev <seanmonstar> yea thatd be a good idea
2019-04-17T18:25:32 #rust-webdev <sfackler> unrelated, but do you know of any http clients in the wild that actually close half close the connection after making a request? it seems like a weird thing to do, at least in the modern world
2019-04-17T18:27:27 #rust-webdev <seanmonstar> it does seem odd
2019-04-19T23:52:31 #rust-webdev <sfackler> seanmonstar: couldn't the behavior here cause infinite buffering if the client pipelines requests? https://github.com/hyperium/hyper/blob/master/src/proto/h1/conn.rs#L293
2019-04-19T23:54:00 #rust-webdev <sfackler> oh nevermind we only do it the first time
2019-04-19T23:54:01 #rust-webdev <seanmonstar> sfackler: just above it, once the buffer has some bytes, it wont try the socket again
2019-04-19T23:54:03 #rust-webdev <sfackler> ya
2019-04-19T23:54:33 #rust-webdev <sfackler> I just realized that tweaking the half_close option interacts poorly with our socket-level read timeouts :(
2019-04-19T23:55:04 #rust-webdev <sfackler> gotta roll that change back
2019-04-19T23:55:21 #rust-webdev <seanmonstar> :(
2019-04-19T23:55:34 #rust-webdev <seanmonstar> what were you hoping to deal with originally?
2019-04-19T23:55:49 #rust-webdev <seanmonstar> just detecting hups earlier?
2019-04-19T23:55:51 #rust-webdev <sfackler> ya
2019-04-19T23:56:10 #rust-webdev <sfackler> the service I work on often processes long running requests and it'd be good to know if the client's already given up
2019-04-19T23:56:33 #rust-webdev <sfackler> but honestly the disconnects weren't even propagated through the rest of the networking bits between the user and this server so it probably wasn't doing anything real in practice anyway
2019-04-19T23:56:57 #rust-webdev <seanmonstar> how does it interact poorly with the read timeouts?
2019-04-19T23:57:08 #rust-webdev <sfackler> we have a 30 second read timeout around the TCP socket
2019-04-19T23:57:20 #rust-webdev <sfackler> which is fine, unless you read while the request is being processed
2019-04-19T23:57:25 #rust-webdev <sfackler> since that starts the 30 second timer
2019-04-19T23:57:33 #rust-webdev <sfackler> so if the request takes more than 30 seconds, the connection dies
2019-04-19T23:57:36 #rust-webdev <seanmonstar> which is, i imagine, if a `read()` returns WOULDBLOCK, start a timer?
2019-04-19T23:57:40 #rust-webdev <sfackler> ya
2019-04-19T23:57:46 #rust-webdev <sfackler> with the tokio-io-timeout crate
2019-04-19T23:57:58 #rust-webdev <sfackler> basically just emulating the set_read_timeout functionality with blocking sockets
2019-04-19T23:58:33 #rust-webdev <seanmonstar> is this supposed to be active always? or more for idle timeouts?
2019-04-19T23:58:46 #rust-webdev <sfackler> it's a bad way to handle generally poorly behaved clients
2019-04-19T23:59:18 #rust-webdev <sfackler> the better solution is higher level timeouts around "time to finish reading headers"
2019-04-19T23:59:27 #rust-webdev <sfackler> and "time to read some more request body"
2019-04-19T23:59:48 #rust-webdev <sfackler> I filed an issue about this last year but never followed up on it :P
2019-04-19T23:59:50 #rust-webdev <seanmonstar> thinking about it some, i think one would probably want a read timeout at the app level when streaming a client body, and a socket timeout when idle
2019-04-19T23:59:59 #rust-webdev <sfackler> right yeah
2019-04-20T00:00:08 #rust-webdev <sfackler> you also want a "only keepalive for N seconds"
2019-04-20T00:00:37 #rust-webdev <seanmonstar> its making think of netty's idle detector thingy
2019-04-20T00:01:04 #rust-webdev <sfackler> there's also some prior art in Go's HTTP stack iirc
2019-04-20T00:01:18 #rust-webdev <sfackler> brb walking home
2019-04-25T16:32:18 #rust-webdev <seanmonstar> sfackler: im cleaning up those eof errors, but curious: were you relying on them being io::ErrorKind::UnexpectedEof?
2019-04-25T16:32:35 #rust-webdev <seanmonstar> or just noting the log messages?
2019-04-25T16:32:42 #rust-webdev <sfackler> nope, just noticed them in the logs and was a bit confused
2019-04-25T16:33:15 #rust-webdev <sfackler> btw, have you had a chance to look at the idle/headers/etc timeouts issue?
2019-04-25T16:34:00 #rust-webdev <seanmonstar> i saw the comment, but havent had time to think it through :(
2019-04-25T16:34:06 #rust-webdev <sfackler> cool, no worries
2019-04-25T16:34:33 #rust-webdev <sfackler> I did end up implementing idle timeouts externally by tracking active requests per connection, but it's pretty complex to handle that way
2019-04-25T16:35:04 #rust-webdev <seanmonstar> oh wow
2019-04-25T16:35:43 #rust-webdev <sfackler> i'll stick the implementation in a gist when I get to work
2019-04-25T16:35:52 #rust-webdev <sfackler> it's kind of neat
2019-04-25T21:05:02 #rust-webdev <sfackler> seanmonstar: https://gist.github.com/sfackler/3dd4a13a00f17e7e312b89c14a6eedba
2019-04-25T22:02:53 #rust-webdev <seanmonstar> ah sure
2019-04-25T22:07:24 #rust-webdev <sfackler> it definitely works, it's just a bit sad since hyper/h2 already knows if the connections idle or not
2019-05-07T16:18:15 #rust-webdev <sfackler> seanmonstar: is there a meaningful time period from when a response's payload returns None from poll_data to when the payload is dropped?
2019-05-07T16:18:20 #rust-webdev <sfackler> assuming there are no trailers
2019-05-07T16:59:07 #rust-webdev <seanmonstar> sfackler: how do you mean? are you noticing a significant delay between the two?
2019-05-07T17:00:37 #rust-webdev <sfackler> no - we currently make request logs in the Drop impl of our response payload, but i'm thinking about moving that to poll_data unless we'll lose out on interesting amounts of time that we should be including in the duration bit of the log
2019-05-07T17:01:27 #rust-webdev <sfackler> i.e. is the payload dropped ~as soon as there's no more data, or does it stick around until buffers finish flushing or something like that
2019-05-07T17:01:29 #rust-webdev <seanmonstar> i suppose exactly when its dropped is an implementation detail...
2019-05-07T17:01:37 #rust-webdev <sfackler> oh yeah for sure
2019-05-07T17:03:11 #rust-webdev <seanmonstar> but looks like atm, the body is dropped immediately after getting None
2019-05-07T17:03:57 #rust-webdev <sfackler> cool thanks
2019-05-14T15:17:58 #rust-webdev <Yatekii> o/
2019-05-27T15:54:54 #rust-webdev <polybuildr> As part of trying out different ways to implement a TCP server, I tried to write one in mio, but I'm having issues.
2019-05-27T15:55:18 #rust-webdev <polybuildr> Some context (where I tried out a simple single-threaded, blocking TCP server) is at https://users.rust-lang.org/t/is-this-the-fastest-idiomatic-code-for-a-simple-counter-tcp-server/28012
2019-05-27T15:55:38 #rust-webdev <polybuildr> Here's my mio code (tried to keep it short-ish), could someone please help me figure out what's wrong? https://gist.github.com/polybuildr/25d54be1669fb1861a73b12aac59670f
2019-05-27T15:55:44 #rust-webdev <polybuildr> I'm fairly certain it's an "obvious" mistake.
2019-05-27T15:56:05 #rust-webdev <polybuildr> When I send requests by hand using netcat, things seem fine.
2019-05-27T15:56:26 #rust-webdev <polybuildr> When I try to run my client code, something weird happens to the polling/queue part. client code: https://gist.github.com/polybuildr/4b98e45f928b86af66707f6ae17d9024
2019-05-27T15:57:14 #rust-webdev <polybuildr> When the load grows, firstly, requests seem to be getting processed at like 1/sec, which is very odd.
2019-05-27T15:57:41 #rust-webdev <polybuildr> Then when I kill the client and try sending something through netcat again, poll.poll returns but seems to process a previous stream.
2019-05-27T15:57:55 #rust-webdev <polybuildr> (oops, I forgot to check the state of the hashmap where I'm maintaining connections... off to do that now)
2019-05-27T15:59:58 #rust-webdev <polybuildr> No... the connections HashMap also seems to only have one connection at a time.
2019-05-27T16:00:09 #rust-webdev <polybuildr> I'm lost, would love some help! :)
2019-05-27T17:46:52 #rust-webdev <polybuildr> If someone does have an answer to the question I asked earlier, plz comment on one of the gists - my IRC connection might get closed.
2019-05-27T20:11:59 #rust-webdev <polybuildr> Aha, https://github.com/hyperium/hyper/issues/1493#issuecomment-486846244 helped me figure out what I was doing wrong. Edge-level for TcpListener means that there could be multiple streams to accept - had missed that!
2019-06-09T11:20:36 #rust-webdev <quite> i'm having some trouble after bumping reqwest 0.9.13 to 0.9.18. getting "attempted to run an executor while another executor is already running"
2019-06-09T11:21:07 #rust-webdev <quite> from a_client_builder.get(url).send()
2019-06-09T11:21:13 #rust-webdev <quite> (tell me if i'm in the wrong place :)
2019-06-11T11:06:06 #rust-webdev <quite> ok somebody created https://github.com/seanmonstar/reqwest/issues/541 
2019-07-26T14:26:37 #rust-webdev <nikos> hi guys
2019-07-26T14:26:45 #rust-webdev <nikos> anyone in here? 
2019-08-08T14:24:31 #rust-webdev <svenstaro> plenty
2019-08-08T14:24:51 #rust-webdev <svenstaro> wrong window :D
2019-08-08T14:25:01 #rust-webdev <svenstaro> but anyway, how's everybody? :D
2019-08-15T18:56:40 #rust-webdev <randomname> silly question but what rust web project is a great/greatest example of good structure and nice code. I am just learnin the basics and I am kind of afraid that I am structuring things badly and need to read more rust code.
2019-08-15T18:56:54 #rust-webdev <randomname> (open source of course…… )
2019-09-30T14:29:22 #rust-webdev <vejetaryenvampir> I'm coming from nodejs backend, is the nickel framework the "familiarest" one?
2019-09-30T14:29:57 #rust-webdev <vejetaryenvampir> specificly expressjs*
2019-10-01T13:33:56 #rust-webdev <ubert> hello, i've written my first rocket app
2019-10-01T13:34:30 #rust-webdev <ubert> now i'd like to launch it into production, but there's a few things i don't quite understand
2019-10-01T13:35:14 #rust-webdev <ubert> https://codereview.stackexchange.com/questions/229703/caching-image-thumbnail-web-application-based-on-rocket
2019-10-01T13:36:36 #rust-webdev <ubert> so when i access the filesystem, do i have to lock files?
2019-10-01T13:37:13 #rust-webdev <ubert> deploying in a docker container how does that work?
2019-10-01T13:44:31 #rust-webdev <ubert> i keep getting "Error: Failed to write response: Os { code: 32, kind: BrokenPipe, message: "Broken pipe" }." how can i debug/fix this?
2019-10-01T15:52:14 #rust-webdev <ubert> Error Os { code 32 ...} might have resulted from a full volume :D
2019-10-27T21:02:43 #rust-webdev <vejetaryenvampir> Hi.
2019-10-29T22:03:45 #rust-webdev <sluggo222> Hello, I've been tasked with replacing a caching service that uses cassandra with something faster. I was hoping to use rust and build a simple web API (actix) with cdrs to query cassandra but I can't figure out how to get a cdrs session into a responder function. I was hoping that someone could help me get started or point me towards some example code.
2019-11-08T12:20:28 #rust-webdev <sidju> If someone could help me with this design question I would be thankful: https://stackoverflow.com/questions/58766267/should-diesel-be-run-using-a-sync-actor-actix-webwebblock-or-futures-cpupoo
2019-11-18T14:57:52 #rust-webdev <_jac_> Is here a better place to ask beginner Qs?  #hyper doesn't seem too active
2019-11-18T14:58:08 #rust-webdev * _jac_ doesn't want to cross-post without checking first
2020-01-01T20:05:10 #rust-webdev <Mike> Hi all, having a problem understanding Yew interacting with JavaScript stuff. I don't really even know what to search for it - anything with Yew interacting with JS is about using JS functions in code, but I want to use JS to make my app interactive
2020-01-01T20:05:58 #rust-webdev <Mike> I want to create elements with Yew, then position them using GoldenLayout. Firstly, I don't even know how, because the view function returns HTML - do I return a script tag with my actual html?
2020-01-01T20:06:12 #rust-webdev <Mike> Secondly, will using JS this way play badly with the virtual DOM?
2020-01-02T03:58:09 #rust-webdev <desikoder> Happy new year everyone!
2020-02-07T03:56:18 #rust-webdev <hamhock> greetings
2020-02-18T20:22:29 #rust-webdev <arxra> Heyoo
2020-02-21T10:19:04 #rust-webdev <eutampieri> Hello, is there a way to stream a response in iron? After a quick search I found nothing
2020-02-26T12:34:46 #rust-webdev <dr_bibble> !
